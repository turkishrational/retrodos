     1                                  ;*****************************************************************************
     2                                  ; MSDOS6.BIN (MSDOS 6.0 Kernel) - RETRO DOS v4.0 by ERDOGAN TAN - 03/11/2022
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 09/07/2024 - Retro DOS v4.2 ((Previous: 07/07/2024))
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 07/07/2018 (Retro DOS 3.0), 22/04/2019 (Retro DOS 4.0)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.15
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	   ((nasm msdos6.s -l msdos6.lst -o MSDOS6.BIN -Z error.txt)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Modified from 'msdos3.s' file of Retro DOS 3.0 source code (10/09/2018)
    13                                  ; ----------------------------------------------------------------------------
    14                                  ; Derived from 'msdos2.s' file of Retro DOS 2.0 source code (04/05/2018)
    15                                  ; ----------------------------------------------------------------------------
    16                                  ; Derived from 'MSCODE.ASM' file of MSDOS 2.0 (IBM PCDOS v2.0) source code
    17                                  ; by Microsoft, 25/08/1983 (DOSLINK - 'MSDOS.ASM')
    18                                  ;*****************************************************************************
    19                                  ; main file: 'retrodos4.s'
    20                                  ; incbin 'MSDOS5.BIN'
    21                                  ;=============================================================================
    22                                  ; Modified from 'msdos6.s' (modified MSDOS 6.21 kernel src as Retro DOS v4.0)
    23                                  ; 28/07/2019  /// Retro DOS v4.0 (2022) -> Modified MSDOS 5.0 IO.SYS+MSDOS.SYS
    24                                  ;=============================================================================
    25                                  
    26                                  ; 30/12/2022 - Retro DOS v4.2 Kernel ('msdos6.s')
    27                                  ; Modified from 'msdos5.s' (29/12/2022, Retro DOS v4.1 Kernel) file
    28                                  ; as below:
    29                                  ;	1) MS-DOS version has been changed to 6.22 (It was 5.0) 
    30                                  ;	2) Retro DOS version has been changed to 4.2 (It was 4.1)
    31                                  ; (The content has not been changed except kernel version because the kernel
    32                                  ;  code is already compatible with MSDOS 6.x and it is optimized before.)
    33                                  ;	(But IO.SYS part of the kernel is not same with Retro DOS v4.1 code.)	
    34                                  
    35                                  ; ----------------------------------------------------------------------------
    36                                  
    37                                  ; 03/11/2022 - Erdogan Tan (Istanbul)
    38                                  
    39                                  ; Note:	This code is a part of Retro DOS 4.0 kernel source code
    40                                  ;	(as included binary, 'MSDOS5.BIN') 
    41                                  ;	Equivalent of MSDOS 5.0 MSDOS.SYS kernel file 
    42                                  ;	
    43                                  ;	((MSDOS 6.0 kernel source code has been modified by using disassembled
    44                                  ;	MSDOS 5.0 MSDOS.SYS)) -- Disassembler: HEX-RAYS IDA Pro --
    45                                  ;	((Disassembly -Reverse engineering- reference: MSDOS 6.0 kernel src))
    46                                        
    47                                  ;------ Retro DOS v2 (v3) boot sector loads RETRODOS.SYS (MSDOS.SYS)
    48                                  ;	at 1000h:0000h and loader (initialization) part of RETRODOS kernel
    49                                  ;	moves IO.SYS (DOSBIOSCODE & DOSBIOSDATA, 'IOSYS5.BIN') to 70h:0000h.
    50                                  ;	Then SYSINIT code to the next segment (4D6h for current version)..
    51                                  ;	SYSINIT code relocates itself and DOSBIOSCODE and MSDOS.SYS
    52                                  ;	(MSDOS5.BIN) according to request/setting in 'config.sys' file.
    53                                  
    54                                  ;=============================================================================
    55                                  ; Most of comments in this file are from the original MSDOS 6.0 source code
    56                                  ;-----------------------------------------------------------------------------
    57                                  
    58                                  ; MSDOS 6.0 Kernel source files:
    59                                  ;	MSDATA.ASM, 
    60                                  ; 		(MSHEAD.ASM, MSCONST.ASM,CONST2.ASM, MS_DATA.ASM,
    61                                  ;		DOSTAB.ASM, LMSTUB.ASM, WPATCH.INC, MPATCH.ASM)
    62                                  ;	MSTABLE.ASM, MSCODE.ASM, MSDOSME.ASM (DOSMES.INC), TIME.ASM,
    63                                  ;	GETSET.ASM, PARSE.ASM, MISC.ASM, MISC2.ASM, CRIT.ASM, CPMIO.ASM,
    64                                  ;	CPMIO2.ASM, FCBIO.ASM, FCBIO2.ASM, SEARCH.ASM, PATH.ASM, IOCTL.ASM,
    65                                  ;	DELETE.ASM, RENAME.ASM, FINFO.ASM, DUP.ASM, CREATE.ASM, OPEN.ASM,
    66                                  ;	DINFO.ASM, ISEARCH.ASM, BUF.ASM, ABORT.ASM,CLOSE.ASM, DIRCALL.ASM,
    67                                  ;	DISK.ASM, DISK2.ASM, DISK3.ASM, DIR.ASM, DIR2.ASM, DEV.ASM,
    68                                  ;	MKNODE.ASM, ROM.ASM, FCB.ASM, MSCTRLC.ASM, FAT.ASM, MSPROC.ASM
    69                                  ;	ALLOC.ASM, SRVCALL.ASM, UTIL.ASM, MACRO.ASM, MACRO2.ASM, HANDLE.ASM
    70                                  ;	FILE.ASM, LOCK.ASM, ROMFIND.ASM, SHARE.ASM, MSINIT.ASM, ORIGIN.ASM
    71                                  ;
    72                                  ; MSDOS 2.0 Kernel source files:
    73                                  ; 	MSDOS.ASM (STDSW.ASM + MSHEAD.ASM + MSDATA.ASM)
    74                                  ;	MSCODE.ASM
    75                                  ;	DOSMES.ASM ... STDIO.ASM, TIME.ASM, XENIX.ASM, XENIX2.ASM
    76                                  
    77                                  ;============================================================================
    78                                  ; DOSLINK
    79                                  ;============================================================================
    80                                  ;msdos mscode dosmes misc getset dircall alloc dev dir +
    81                                  ;disk fat rom stdbuf stdcall stdctrlc stdfcb stdproc +
    82                                  ;stdio time xenix xenix2
    83                                  
    84                                  ;============================================================================
    85                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    86                                  ; output in TASM syntax (July 2018 -> NASM syntax) [ IBMDOS.COM, 17/03/1987 ]
    87                                  ;============================================================================
    88                                  ;
    89                                  ; ###########################################################################
    90                                  ; #	This file is generated by The Interactive Disassembler (IDA)	    #
    91                                  ; #	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    #
    92                                  ; #			 Licensed to: Freeware version			    #
    93                                  ; ###########################################################################
    94                                  ;
    95                                  ; Input	MD5   :	75959BC417C19135B982F7959EE9C92A
    96                                  
    97                                  ; ---------------------------------------------------------------------------
    98                                  ; File Name   :	C:\Documents and Settings\Erdoðan Tan\Desktop\MSDOS621.BIN
    99                                  ; Format      :	Binary file
   100                                  ;============================================================================
   101                                  ; MSDOS621.BIN = MSDOS.SYS, 13/02/1994, 38138 bytes (MSDOS 6.21 kernel) 2019
   102                                  ;----------------------------------------------------------------------------
   103                                  ; MSDOS5.BIN = MSDOS.SYS, 11/11/1991, 37394 bytes (MSDOS 5.0 kernel) 2022
   104                                  
   105                                  ;============================================================================
   106                                  ; MSDOS.ASM
   107                                  ;============================================================================
   108                                  
   109                                  ;TITLE   Standard MSDOS
   110                                  ;NAME    MSDOS_2
   111                                  
   112                                  ; Number of disk I/O buffers
   113                                  
   114                                  ;	INCLUDE STDSW.ASM
   115                                  ;       INCLUDE MSHEAD.ASM
   116                                  ;       INCLUDE MSDATA.ASM
   117                                  
   118                                  ;	END
   119                                  
   120                                  ;============================================================================
   121                                  ; STDSW.ASM
   122                                  ;============================================================================
   123                                  
   124                                  TRUE    EQU     0FFFFH
   125                                  FALSE   EQU     ~TRUE ; NOT TRUE
   126                                  
   127                                  ; Use the switches below to produce the standard Microsoft version or the IBM
   128                                  ; version of the operating system
   129                                  ;MSVER   EQU	false
   130                                  ;IBM     EQU	true
   131                                  ;WANG    EQU	FALSE
   132                                  ;ALTVECT EQU	FALSE
   133                                  
   134                                  ; Set this switch to cause DOS to move itself to the end of memory
   135                                  ;HIGHMEM EQU     FALSE
   136                                  
   137                                  ;	IF      IBM
   138                                  ESCCH    EQU	 0			;character to begin escape seq.
   139                                  CANCEL   EQU	 27			;Cancel with escape
   140                                  TOGLINS  EQU	TRUE			;One key toggles insert mode
   141                                  TOGLPRN  EQU	TRUE			;One key toggles printer echo
   142                                  ZEROEXT  EQU	TRUE
   143                                  ;       ELSE
   144                                  ;       IF      WANG			;Are we assembling for WANG?
   145                                  ;ESCCH	 EQU	1FH			;Yes. Use 1FH for escape character
   146                                  ;       ELSE
   147                                  ;ESCCH	 EQU	1BH
   148                                  ;       ENDIF
   149                                  ;CANCEL  EQU	"X"-"@"			;Cancel with Ctrl-X
   150                                  ;TOGLINS EQU	WANG			;Separate keys for insert mode on
   151                                  					;and off if not WANG
   152                                  ;TOGLPRN EQU	FALSE			;Separate keys for printer echo on
   153                                  					;and off
   154                                  ;ZEROEXT EQU	TRUE
   155                                  ;        ENDIF
   156                                  
   157                                  ;============================================================================
   158                                  ; MSHEAD.ASM
   159                                  ;============================================================================
   160                                  
   161                                  ;--------------------------------------------------------------
   162                                  ; TITLE   MSHEAD.ASM -- MS-DOS DEFINITIONS
   163                                  ;--------------------------------------------------------------
   164                                  
   165                                  ; MS-DOS High-performance operating system for the 8086  version 1.28
   166                                  ;        by Microsoft MSDOS development group:
   167                                  ;           Tim Paterson (Ret.)
   168                                  ;           Aaron Reynolds
   169                                  ;           Nancy Panners (Parenting)
   170                                  ;           Mark Zbikowski
   171                                  ;           Chris Peters (BIOS) (ret.)
   172                                  
   173                                  ; ****************** Revision History *************************
   174                                  ;          >> EVERY change must noted below!! <<
   175                                  ;
   176                                  ; 0.34 12/29/80 General release, updating all past customers
   177                                  ; 0.42 02/25/81 32-byte directory entries added
   178                                  ; 0.56 03/23/81 Variable record and sector sizes
   179                                  ; 0.60 03/27/81 Ctrl-C exit changes, including register save on user stack
   180                                  ; 0.74 04/15/81 Recognize I/O devices with file names
   181                                  ; 0.75 04/17/81 Improve and correct buffer handling
   182                                  ; 0.76 04/23/81 Correct directory size when not 2^N entries
   183                                  ; 0.80 04/27/81 Add console input without echo, Functions 7 & 8
   184                                  ; 1.00 04/28/81 Renumber for general release
   185                                  ; 1.01 05/12/81 Fix bug in `STORE'
   186                                  ; 1.10 07/21/81 Fatal error trapping, NUL device, hidden files, date & time,
   187                                  ;               RENAME fix, general cleanup
   188                                  ; 1.11 09/03/81 Don't set CURRENT BLOCK to 0 on open; fix SET FILE SIZE
   189                                  ; 1.12 10/09/81 Zero high half of CURRENT BLOCK after all (CP/M programs don't)
   190                                  ; 1.13 10/29/81 Fix classic "no write-through" error in buffer handling
   191                                  ; 1.20 12/31/81 Add time to FCB; separate FAT from DPT; Kill SMALLDIR; Add
   192                                  ;               FLUSH and MAPDEV calls; allow disk mapping in DSKCHG; Lots
   193                                  ;               of smaller improvements
   194                                  ; 1.21 01/06/82 HIGHMEM switch to run DOS in high memory
   195                                  ; 1.22 01/12/82 Add VERIFY system call to enable/disable verify after write
   196                                  ; 1.23 02/11/82 Add defaulting to parser; use variable escape character Don't
   197                                  ;               zero extent field in IBM version (back to 1.01!)
   198                                  ; 1.24 03/01/82 Restore fcn. 27 to 1.0 level; add fcn. 28
   199                                  ; 1.25 03/03/82 Put marker (00) at end of directory to speed searches
   200                                  ; 1.26 03/03/82 Directory buffers searched as a circular queue, current buffer
   201                                  ;               is searched first when possible to minimize I/O
   202                                  ;      03/03/82 STORE routine optimized to tack on partial sector tail as
   203                                  ;               full sector write when file is growing
   204                                  ;      03/09/82 Multiple I/O buffers
   205                                  ;      03/29/82 Two bugs:  Delete all case resets search to start at beginning
   206                                  ;               of directory (infinite loop possible otherwise), DSKRESET
   207                                  ;               must invalidate all buffers (disk and directory).
   208                                  ; 1.27 03/31/82 Installable device drivers
   209                                  ;                 Function call 47 - Get pointer to device table list
   210                                  ;                 Function call 48 - Assign CON AUX LIST
   211                                  ;      04/01/82 Spooler interrupt (INT 28) added.
   212                                  ; 1.28 04/15/82 DOS retructured to use ASSUMEs and PROC labels around system
   213                                  ;               call entries.  Most CS relative references changed to SS
   214                                  ;               relative with an eye toward putting a portion of the DOS in
   215                                  ;               ROM.  DOS source also broken into header, data and code pieces
   216                                  ;      04/15/82 GETDMA and GETVECT calls added as 24 and 32.  These calls
   217                                  ;               return the current values.
   218                                  ;      04/15/82 INDOS flag implemented for interrupt processing along with
   219                                  ;               call to return flag location (call 29)
   220                                  ;      04/15/82 Volume ID attribute added
   221                                  ;      04/17/82 Changed ABORT return to user to a long ret from a long jump to
   222                                  ;               avoid a CS relative reference.
   223                                  ;      04/17/82 Put call to STATCHK in dispatcher to catch ^C more often
   224                                  ;      04/20/82 Added INT int_upooler into loop ^S wait
   225                                  ;      04/22/82 Dynamic disk I/O buffer allocation and call to manage them
   226                                  ;               call 49.
   227                                  ;      04/23/82 Added GETDSKPTDL as call 50, similar to GETFATPT(DL), returns
   228                                  ;               address of DPB
   229                                  ;      04/29/82 Mod to WRTDEV to look for ^C or ^S at console input when
   230                                  ;               writting to console device via file I/O.  Added a console
   231                                  ;               output attribute to devices.
   232                                  ;      04/30/82 Call to en/dis able ^C check in dispatcher Call 51
   233                                  ;      04/30/82 Code to allow assignment of func 1-12 to disk files as well
   234                                  ;               as devices....  pipes, redirection now possible
   235                                  ;      04/30/82 Expanded GETLIST call to 2.0 standard
   236                                  ;      05/04/82 Change to INT int_fatal_abort callout int HARDERR.  DOS SS
   237                                  ;               (data segment) stashed in ES, INT int_fatal_abort routines must
   238                                  ;               preserve ES.  This mod so HARDERR can be ROMed.
   239                                  ; 1.29 06/01/82 Installable block and character devices as per 2.0 spec
   240                                  ;      06/04/82 Fixed Bug in CLOSE regarding call to CHKFATWRT.  It got left
   241                                  ;               out back about 1.27 or so (oops).  ARR
   242                                  ; 1.30 06/07/82 Directory sector buffering added to main DOS buffer queue
   243                                  ; 1.40 06/15/82 Tree structured directories.  XENIX Path Parser MKDIR CHDIR
   244                                  ;               RMDIR Xenix calls
   245                                  ; 1.41 06/13/82 Made GETBUFFR call PLACEBUF
   246                                  ; 1.50 06/17/82 FATs cached in buffer pool, get FAT pointer calls disappear
   247                                  ;               Frees up lots of memory.
   248                                  ; 1.51 06/24/82 BREAKDOWN modified to do EXACT one sector read/write through
   249                                  ;               system buffers
   250                                  ; 1.52 06/30/82 OPEN, CLOSE, READ, WRITE, DUP, DUP2, LSEEK implemented
   251                                  ; 1.53 07/01/82 OPEN CLOSE mod for Xenix calls, saves and gets remote dir
   252                                  ; 1.54 07/11/82 Function calls 1-12 make use of new 2.0 PDB. Init code
   253                                  ;               changed to set file handle environment.
   254                                  ; 2.00 08/01/82 Number for IBM release
   255                                  ;      01/19/83 No environ bug in EXEC
   256                                  ;      01/19/83 MS-DOS OEM INT 21 extensions (SET_OEM_HANDLER)
   257                                  ;      01/19/83 Performance bug fix in cooked write to NUL
   258                                  ;      01/27/83 Growcnt fixed for 32-bits
   259                                  ;      01/27/83 Find-first problem after create
   260                                  ; 2.01 02/17/83 International DOS
   261                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   262                                  ;               an IBM PC
   263                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
   264                                  ; (MSHEAD.ASM, MSDOS 6.0, 1991) - mshead.asm 1.1 85/04/10 -
   265                                  ; 2.10 03/09/83 Start of NETWORK support
   266                                  ;		New Buffer structure
   267                                  ;		New Sytem file table structure
   268                                  ;		FCB moved to internal representation
   269                                  ;		DOS re-organized
   270                                  ; 2.11 04/21/83 Continuation of 2.10, preliminary Network
   271                                  ;		device interface.
   272                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   273                                  ;               an IBM PC
   274                                  ; 2.50 09/12/83 More network stuff
   275                                  ;
   276                                  ; *************************************************************
   277                                  
   278                                  ; ----------------------------------------------------------------------------
   279                                  ; EQUATES
   280                                  
   281                                  ; Interrupt Entry Points:
   282                                  
   283                                  ; INTBASE:      ABORT
   284                                  ; INTBASE+4:    COMMAND
   285                                  ; INTBASE+8:    BASE EXIT ADDRESS
   286                                  ; INTBASE+C:    CONTROL-C ABORT
   287                                  ; INTBASE+10H:  FATAL ERROR ABORT
   288                                  ; INTBASE+14H:  BIOS DISK READ
   289                                  ; INTBASE+18H:  BIOS DISK WRITE
   290                                  ; INTBASE+1CH:  END BUT STAY RESIDENT (NOT SET BY DOS)
   291                                  ; INTBASE+20H:  SPOOLER INTERRUPT
   292                                  ; INTBASE+40H:  Long jump to CALL entry point
   293                                  
   294                                  ENTRYPOINTSEG   EQU     0Ch
   295                                  MAXDIF          EQU     0FFFh
   296                                  SAVEXIT         EQU     10
   297                                  ; 06/05/2019
   298                                  WRAPOFFSET	EQU	0FEF0h  ; (MISC.ASM, MSDOS 6.0, 1991)
   299                                  
   300                                         ; INCLUDE DOSSYM.ASM
   301                                         ; INCLUDE DEVSYM.ASM
   302                                  
   303                                  ; SUBTTL ^C, terminate/abort/exit and Hard error actions
   304                                  ; PAGE
   305                                  ; There are three kinds of context resets that can occur during normal DOS
   306                                  ; functioning:  ^C trap, terminate/abort/exit, and Hard-disk error.  These must
   307                                  ; be handles in a clean fashion that allows nested executions along with the
   308                                  ; ability to trap one's own errors.
   309                                  ;
   310                                  ; ^C trap - A process may elect to catch his own ^Cs.  This is achieved by
   311                                  ;           using the $GET_INTERRUPT_VECTOR and $SET_INTERRUPT_VECTOR as
   312                                  ;           follows:
   313                                  ;
   314                                  ;           $GET_INTERRUPT_VECTOR for INT int_ctrl_c
   315                                  ;           Save it in static memory.
   316                                  ;           $SET_INTERRUPT_VECTOR for INT int_ctrl_c
   317                                  ;
   318                                  ;           The interrupt service routine must preserve all registers and
   319                                  ;           return carry set iff the operation is to be aborted (via abort
   320                                  ;           system call), otherwise, carry is reset and the operation is
   321                                  ;           restarted.  ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE
   322                                  ;           RESULTS.
   323                                  ;
   324                                  ;           To restore original ^C processing (done on terminate/abort/exit),
   325                                  ;           restore INT int_ctrl_c from the saved vector.
   326                                  ;
   327                                  ; Hard-disk error -- The interrupt service routine for INT int_fatal_abort must
   328                                  ;           also preserve registers and return one of three values in AL: 0 and
   329                                  ;           1 imply retry and ignore (???)  and 2 indicates an abort.  The user
   330                                  ;           himself is not to issue the abort, rather, the dos will do it for
   331                                  ;           him by simulating a normal abort/exit system call.  ANY DEVIATION
   332                                  ;           FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   333                                  ;
   334                                  ; terminate/abort/exit -- The user may not, under any circumstances trap an
   335                                  ;           abort call.  This is reserved for knowledgeable system programs.
   336                                  ;           ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   337                                  
   338                                  ;SUBTTL SEGMENT DECLARATIONS
   339                                  
   340                                  ; The following are all of the segments used.  They are declared in the order
   341                                  ; that they should be placed in the executable
   342                                  
   343                                  ;
   344                                  ; segment ordering for MSDOS
   345                                  ;
   346                                  
   347                                  ;START           SEGMENT BYTE PUBLIC 'START'
   348                                  ;START           ENDS
   349                                  
   350                                  ;CONSTANTS       SEGMENT BYTE PUBLIC 'CONST'
   351                                  ;CONSTANTS       ENDS
   352                                  
   353                                  ;DATA            SEGMENT WORD PUBLIC 'DATA'
   354                                  ;DATA            ENDS
   355                                  
   356                                  ;CODE            SEGMENT BYTE PUBLIC 'CODE'
   357                                  ;CODE            ENDS
   358                                  
   359                                  ;LAST            SEGMENT BYTE PUBLIC 'LAST'
   360                                  ;LAST            ENDS
   361                                  
   362                                  ;DOSGROUP    GROUP   CODE,CONSTANTS,DATA,LAST
   363                                  
   364                                  ; The following segment is defined such that the data/const classes appear
   365                                  ; before the code class for ROMification
   366                                  
   367                                  ;START		SEGMENT BYTE PUBLIC 'START'
   368                                  ;           	ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
   369                                  ;		JMP     DOSINIT
   370                                  ;START		ENDS
   371                                  
   372                                  ;============================================================================
   373                                  ; BPB.INC, MSDOS 6.0, 1991
   374                                  ;============================================================================
   375                                  ; 09/07/2018 - Retro DOS v3.0
   376                                  
   377                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   378                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   379                                  ;									   ;
   380                                  
   381                                  ;**	BIOS PARAMETER BLOCK DEFINITION
   382                                  ;
   383                                  ;	The BPB contains information about the disk structure. It dates
   384                                  ;	back to the earliest FAT systems and so FAT information is
   385                                  ;	intermingled with physical driver information.
   386                                  ;
   387                                  ;	A boot sector contains a BPB for its device; for other disks
   388                                  ;	the driver creates a BPB. DOS keeps copies of some of this
   389                                  ;	information in the DPB.
   390                                  ;
   391                                  ;	The BDS structure contains a BPB within it. 
   392                                  
   393                                  struc A_BPB
   394 00000000 ????                    .BPB_BYTESPERSECTOR:	resw	1
   395 00000002 ??                      .BPB_SECTORSPERCLUSTER:	resb	1
   396 00000003 ????                    .BPB_RESERVEDSECTORS:	resw	1
   397 00000005 ??                      .BPB_NUMBEROFFATS:	resb	1
   398 00000006 ????                    .BPB_ROOTENTRIES: 	resw	1
   399 00000008 ????                    .BPB_TOTALSECTORS:	resw	1
   400 0000000A ??                      .BPB_MEDIADESCRIPTOR:	resb	1
   401 0000000B ????                    .BPB_SECTORSPERFAT:	resw	1
   402 0000000D ????                    .BPB_SECTORSPERTRACK:	resw	1
   403 0000000F ????                    .BPB_HEADS:		resw	1
   404 00000011 ????                    .BPB_HIDDENSECTORS:	resw	1
   405 00000013 ????                    			resw	1
   406 00000015 ????                    .BPB_BIGTOTALSECTORS:	resw	1
   407 00000017 ????                    			resw	1
   408 00000019 ????????????            			resb	6	; NOTE:  many times these
   409                                  ;					; 	 6 bytes are omitted
   410                                  ;					;	 when BPB manipulations
   411                                  ;					;	 are performed!
   412                                  .size:
   413                                  endstruc
   414                                  
   415                                  ;                                                                          ;
   416                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   417                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   418                                  
   419                                  ;============================================================================
   420                                  ; BUFFER.INC, MSDOS 6.0, 1991
   421                                  ;============================================================================
   422                                  ; 04/05/2019 - Retro DOS v4.0
   423                                  
   424                                  ; <Disk I/O Buffer Header>
   425                                  
   426                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   427                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   428                                  ;									   ;
   429                                  
   430                                  ; Field definition for I/O buffer information
   431                                  
   432                                  struc BUFFINFO
   433 00000000 ????                    .buf_next:	resw 1		; Pointer to next buffer in list
   434 00000002 ????                    .buf_prev:	resw 1		; Pointer to prev buffer in list
   435 00000004 ??                      .buf_ID:	resb 1		; Drive of buffer (bit 7 = 0)
   436                                  				; SFT table index (bit 7 = 1)
   437                                  				; = FFH if buffer free
   438 00000005 ??                      .buf_flags:	resb 1		; Bit 7 = 1 if Remote file buffer
   439                                  				;	= 0 if Local device buffer
   440                                  				; Bit 6 = 1 if buffer dirty
   441                                  				; Bit 5 = Reserved
   442                                  				; Bit 4 = Search bit (bit 7 = 1)
   443                                  				; Bit 3 = 1 if buffer is DATA
   444                                  				; Bit 2 = 1 if buffer is DIR
   445                                  				; Bit 1 = 1 if buffer is FAT
   446                                  				; Bit 0 = Reserved
   447 00000006 ????????                .buf_sector:	resd 1		; Sector number of buffer (flags bit 7 = 0)
   448                                  ; The next two items are often refed as a word (flags bit 7 = 0)
   449 0000000A ??                      .buf_wrtcnt:	resb 1		; For FAT sectors, # times sector written out
   450 0000000B ????                    .buf_wrtcntinc:	resw 1		; "   "     "   , # sectors between each write
   451 0000000D ????????                .buf_DPB:	resd 1		; Pointer to drive parameters
   452 00000011 ????                    .buf_fill:	resw 1		; How full buffer is (flags bit 7 = 1)
   453 00000013 ??                      .buf_reserved:	resb 1		; make DWORD boundary for 386
   454                                  .size:	; 20 bytes
   455                                  endstruc
   456                                  
   457                                  %define buf_offset	BUFFINFO.buf_sector ; 22/07/2019
   458                                  				;For buf_flags bit 7 = 1, this is the byte
   459                                  				;offset of the start of the buffer in
   460                                  				;the file pointed to by buf_ID. Thus
   461                                  				;the buffer starts at location
   462                                  				;buf_offset in the file and contains
   463                                  				;buf_fill bytes.
   464                                  
   465                                  BUFINSIZ        EQU     BUFFINFO.size
   466                                  
   467                                  buf_Free	EQU	0FFh	; buf_id of free buffer
   468                                  
   469                                  ;Flag byte masks
   470                                  buf_isnet	EQU	10000000B
   471                                  buf_dirty	EQU	01000000B
   472                                  ;***
   473                                  buf_visit	EQU	00100000B
   474                                  ;***
   475                                  buf_snbuf	EQU	00010000B
   476                                  
   477                                  buf_isDATA	EQU	00001000B
   478                                  buf_isDIR	EQU	00000100B
   479                                  buf_isFAT	EQU	00000010B
   480                                  buf_type_0	EQU	11110001B	; AND sets type to "none"
   481                                  
   482                                  buf_NetID	EQU	BUFINSIZ
   483                                  
   484                                  ;                                                                          ;
   485                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   486                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   487                                  
   488                                  ;============================================================================
   489                                  ; DOSSSYM.INC, MSDOS 6.0, 1991
   490                                  ;============================================================================
   491                                  ; 04/05/2019 - Retro DOS v4.0
   492                                  
   493                                  ; <Control character definitions>
   494                                  
   495                                  c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
   496                                  c_BS	    EQU     08h 	; ^H ASCII backspace
   497                                  c_CR	    EQU     0Dh 	; ^M ASCII carriage return
   498                                  c_LF	    EQU     0Ah 	; ^J ASCII linefeed
   499                                  c_ETB	    EQU     17h 	; ^W ASCII end of transmission
   500                                  c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
   501                                  c_ETX	    EQU     03h 	; ^C ASCII end of text
   502                                  c_HT	    EQU     09h 	; ^I ASCII tab
   503                                  
   504                                  ; <User stack inside of system call>
   505                                  ; Location of user registers relative user stack pointer
   506                                  
   507                                  struc	user_env   ; user_environ
   508 00000000 ????                    .user_AX: resw 1
   509 00000002 ????                    .user_BX: resw 1
   510 00000004 ????                    .user_CX: resw 1
   511 00000006 ????                    .user_DX: resw 1
   512 00000008 ????                    .user_SI: resw 1
   513 0000000A ????                    .user_DI: resw 1
   514 0000000C ????                    .user_BP: resw 1
   515 0000000E ????                    .user_DS: resw 1
   516 00000010 ????                    .user_ES: resw 1
   517 00000012 ????                    .user_IP: resw 1
   518 00000014 ????                    .user_CS: resw 1
   519 00000016 ????                    .user_F:  resw 1
   520                                  .size:
   521                                  endstruc
   522                                  
   523                                  ; ---- <Disk map> ----
   524                                  
   525                                  ;	MSDOS partitions the disk into 4 sections:
   526                                  ;
   527                                  ;  phys sector 0:   +-------------------+
   528                                  ;	|	    | boot/reserved	|
   529                                  ;	|	    +-------------------+
   530                                  ;	|	    |  File allocation	|
   531                                  ;	v	    |	   table(s)	|
   532                                  ;		    |  (multiple copies |
   533                                  ;		    |	  are kept)	|
   534                                  ;		    +-------------------+
   535                                  ;		    |	  Directory	|
   536                                  ;		    +-------------------+
   537                                  ;		    |	  File space	|
   538                                  ;		    +-------------------+
   539                                  ;		    |	Unaddressable	|
   540                                  ;		    |  (to end of disk) |
   541                                  ;		    +-------------------+
   542                                  ;
   543                                  ; All partition boundaries are sector boundaries.  The size of the FAT is
   544                                  ; adjusted to maximize the file space addressable.
   545                                  
   546                                  ; <File allocation Table information>
   547                                  
   548                                  ; The File Allocation Table uses a 12-bit entry for each allocation unit on
   549                                  ; the disk.  These entries are packed, two for every three bytes.  The contents
   550                                  ; of entry number N is found by 1) multiplying N by 1.5; 2) adding the result
   551                                  ; to the base address of the Allocation Table; 3) fetching the 16-bit word
   552                                  ; at this address; 4) If N was odd (so that N*1.5 was not an integer), shift
   553                                  ; the word right four bits; 5) mask to 12 bits (AND with 0FFF hex).  Entry
   554                                  ; number zero is used as an end-of-file trap in the OS and is passed to the
   555                                  ; BIOS to help determine disk format.  Entry 1 is reserved for future use.
   556                                  ; The first available allocation unit is assigned entry number two, and even
   557                                  ; though it is the first, is called cluster 2.	Entries greater than 0FF8H
   558                                  ; (12-bit fats) or 0FFF8H (16-bit fats) are end of file marks; entries of zero
   559                                  ; are unallocated.  Otherwise, the contents of a FAT entry is the number of
   560                                  ; the next cluster in the file.
   561                                  ;
   562                                  ; Clusters with bad sectors are tagged with FF7H.  Any non-zero number would
   563                                  ; do because these clusters show as allocated, but are not part of any
   564                                  ; allocation chain and thus will never be allocated to a file.	A particular
   565                                  ; number is selected so that disk checking programs know what to do (ie.  a
   566                                  ; cluster with entry FF7H which is not in a chain is not an error).
   567                                  
   568                                  ;**	Character Type Flags
   569                                  ;
   570                                  ;	These flags are used in a lookup table indexed by the character code.
   571                                  ;	They're used to quickly classify characters when parsing paths.
   572                                  ;	I think that these are only used to parse FCBs - jgl
   573                                  
   574                                  FCHK	equ 1		; I think this means "normal name char, no chks needed" -jgl
   575                                  FDELIM	equ 2		; is a delimiter
   576                                  FSPCHK	equ 4		; set if character is not a space or equivalent
   577                                  FFCB	equ 8		; is valid in an FCB
   578                                  
   579                                  ;** Bit definitions for DOS_FLAG
   580                                  ;
   581                                  ; Bit 0 - this is set when a $open call is made from $exec. This is used in
   582                                  ;	  $open to indicate to the redirector that this open is being made
   583                                  ;	  by an exec call.
   584                                  ;
   585                                  ; Bit 2
   586                                  ;
   587                                  ; M003, M027:
   588                                  ;
   589                                  ; The start up code of MS PASCAL 3.2 programs depend on the 1M address wrap 
   590                                  ; if they load below 64K. This is a likely possiblity in DOS 5.x with DOS in
   591                                  ; the HMA. By default DOS will turn A20 OFF before Xferring control to the
   592                                  ; user program in the case of an Exec call. The next call to DOS will turn
   593                                  ; A20 line ON. It has been observed that MS PASCAL 3.2 start up does an int
   594                                  ; 21 ah=25h call before executing the faulty code. This will turn A20 On. 
   595                                  ; In order to support this we will set Bit 2 of this flag in the DOS exec
   596                                  ; call (msproc.asm) if DOS is running in the HMA. In $set_interrupt_vector in
   597                                  ; getset.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
   598                                  ; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
   599                                  ; is non zero then A20 will be turned OFF before returning to the user. 
   600                                  ; Bit 2 will be unconditionally cleared here.
   601                                  ;
   602                                  ; M009, M027:
   603                                  ;
   604                                  ; Mace utilities MKEYRATE.COM version 1.0 copyright 1987 is an execpacked 
   605                                  ; program converted to a com file. Therefore if DOS is loaded high and if 
   606                                  ; this program is loaded below 64K it will blurt out "packed file is corrupt".
   607                                  ; This program does an int 21 ah=49h before executing the buggy execpacked
   608                                  ; code. This int21 call turns a20 on and hence the problem. In $dealloc
   609                                  ; alloc.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
   610                                  ; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
   611                                  ; is non zero then A20 will be turned OFF before returning to the user. 
   612                                  ; Bit 2 will be unconditionally cleared here.
   613                                  
   614                                  EXECOPEN	EQU	00000001b	; bit 0 of DOS_FLAG
   615                                  SUPPRESS_WINA20	EQU	00000010b	; M025
   616                                  EXECA20OFF	EQU	00000100b	; bit 2 of DOS_FLAG
   617                                  
   618                                  ;============================================================================
   619                                  ; VECTOR.INC, MSDOS 6.0, 1991
   620                                  ;============================================================================
   621                                  ; 04/05/2019 - Retro DOS v4.0
   622                                  
   623                                  ; 09/07/2018 - Retro DOS v3.0 (VECTOR.INC, MSDOS 3.3, 1987)
   624                                  
   625                                  ; <interrupt definitions>
   626                                  
   627                                  INTTAB          EQU     20H
   628                                  INTBASE         EQU     4 * INTTAB
   629                                  ENTRYPOINT      EQU     INTBASE+40H
   630                                  
   631                                  ;	IF      ALTVECT
   632                                  ;ALTTAB  EQU     0F0H
   633                                  ;ALTBASE EQU     4 * ALTTAB
   634                                  ;	ENDIF
   635                                  
   636                                  ;
   637                                  ; interrupt assignments
   638                                  ;
   639                                  ;	IF	NOT ALTVECT
   640                                  int_abort	    EQU     INTTAB	; abort process
   641                                  int_command	    EQU     int_abort+1 ; call MSDOS
   642                                  int_terminate	    EQU     int_abort+2 ; int to terminate address
   643                                  int_ctrl_c	    EQU     int_abort+3 ; ^c trapper
   644                                  int_fatal_abort     EQU     int_abort+4 ; hard disk error
   645                                  int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   646                                  int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   647                                  int_keep_process    EQU     int_abort+7 ; terminate program and stay
   648                                  					; resident
   649                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   650                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   651                                  ;									   ;
   652                                  int_spooler	    EQU     int_abort+8 ; spooler call
   653                                  int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   654                                  int_IBM 	    EQU     int_abort+10; critical section maintenance
   655                                  ;									   ;
   656                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   657                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   658                                  ;	ELSE
   659                                  ;int_abort	    EQU     INTTAB	; abort process
   660                                  ;int_command	    EQU     int_abort+1 ; call MSDOS
   661                                  ;int_terminate	    EQU     ALTTAB	; int to terminate address
   662                                  ;int_ctrl_c	    EQU     int_terminate+1 ; ^c trapper
   663                                  ;int_fatal_abort    EQU     int_terminate+2 ; hard disk error
   664                                  ;int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   665                                  ;int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   666                                  ;int_keep_process   EQU     int_abort+7 ; terminate program and stay resident
   667                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   668                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   669                                  ;									   ;
   670                                  ;int_spooler	    EQU     int_terminate+3 ; spooler call
   671                                  ;int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   672                                  ;									   ;
   673                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   674                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   675                                  ;	ENDIF
   676                                  
   677                                  addr_int_abort		EQU    4 * int_abort
   678                                  addr_int_command	EQU    4 * int_command
   679                                  addr_int_terminate	EQU    4 * int_terminate
   680                                  addr_int_ctrl_c 	EQU    4 * int_ctrl_c
   681                                  addr_int_fatal_abort	EQU    4 * int_fatal_abort
   682                                  addr_int_disk_read	EQU    4 * int_disk_read
   683                                  addr_int_disk_write	EQU    4 * int_disk_write
   684                                  addr_int_keep_process	EQU    4 * int_keep_process
   685                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   686                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   687                                  ;									   ;
   688                                  addr_int_spooler	EQU    4 * int_spooler
   689                                  addr_int_fastcon	EQU    4 * int_fastcon
   690                                  addr_int_ibm		EQU    4 * int_IBM
   691                                  ;									   ;
   692                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   693                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   694                                  
   695                                  ;============================================================================
   696                                  ; DIRENT.INC, MSDOS 6.0, 1991
   697                                  ;============================================================================
   698                                  ; 04/05/2019 - Retro DOS v4.0
   699                                  
   700                                  ; BREAK <Directory entry>
   701                                  
   702                                  ;
   703                                  ;       +---------------------------+
   704                                  ;       |  (12 BYTE) filename/ext   |       0       0
   705                                  ;       +---------------------------+
   706                                  ;       |     (BYTE) attributes     |       11      B
   707                                  ;       +---------------------------+
   708                                  ;       |    (10 BYTE) reserved     |       12      C
   709                                  ;       +---------------------------+
   710                                  ;       | (WORD) time of last write |       22      16
   711                                  ;       +---------------------------+
   712                                  ;       | (WORD) date of last write |       24      18
   713                                  ;       +---------------------------+
   714                                  ;       |   (WORD) First cluster    |       26      1A
   715                                  ;       +---------------------------+
   716                                  ;       |     (DWORD) file size     |       28      1C
   717                                  ;       +---------------------------+
   718                                  ;
   719                                  ;   First byte of filename  = E5 -> free directory entry
   720                                  ;                           = 00 -> end of allocated directory
   721                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   722                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   723                                  ;
   724                                  struc dir_entry
   725 00000000 <res Bh>                .dir_name:	resb 11			; file name
   726 0000000B ??                      .dir_attr:	resb 1			; attribute bits
   727 0000000C ????                    .dir_codepg:	resw 1			; code page DOS 4.00
   728 0000000E ????                    .dir_extcluster: resw 1			; extended attribute starting cluster
   729 00000010 ??                      .dir_attr2:	resb 1			; reserved
   730 00000011 ??????????              .dir_pad:	resb 5			; reserved for expansion
   731 00000016 ????                    .dir_time:	resw 1			; time of last write
   732 00000018 ????                    .dir_date:	resw 1			; date of last write
   733 0000001A ????                    .dir_first:	resw 1			; first allocation unit of file
   734 0000001C ????                    .dir_size_l:	resw 1			; low 16 bits of file size
   735 0000001E ????                    .dir_size_h:	resw 1			; high 16 bits of file size
   736                                  .size:
   737                                  endstruc
   738                                  
   739                                  attr_read_only      EQU      1h
   740                                  attr_hidden         EQU      2h
   741                                  attr_system         EQU      4h
   742                                  attr_volume_id      EQU      8h
   743                                  attr_directory      EQU     10h
   744                                  attr_archive        EQU     20h
   745                                  attr_device	    EQU     40h	; This is a VERY special bit.
   746                                  				;   NO directory entry on a disk EVER
   747                                  				;   has this bit set. It is set non-zero
   748                                  				;   when a device is found by GETPATH
   749                                  
   750                                  attr_all            EQU     attr_hidden+attr_system+attr_directory
   751                                                                          ; OR of hard attributes for FINDENTRY
   752                                  
   753                                  attr_ignore         EQU     attr_read_only+attr_archive
   754                                                                          ; ignore this(ese) attribute(s)
   755                                                                          ; during search first/next
   756                                  
   757                                  attr_changeable     EQU     attr_read_only+attr_hidden+attr_system+attr_archive
   758                                                                          ; changeable via CHMOD
   759                                  
   760                                  DIRFREE		equ	0E5h	; stored in dir_name[0] to indicate free slot
   761                                  
   762                                  ;============================================================================
   763                                  ; DPB.INC, MSDOS 6.0, 1991
   764                                  ;============================================================================
   765                                  ; 24/04/2019 - Retro DOS v4.0
   766                                  
   767                                  ; 19/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 3.3, 1987)
   768                                  ; 07/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 6.0, 1991)
   769                                  
   770                                  ; ---------------------------------------------------------------------------
   771                                  ;**	DPB - Drive Parameter Block
   772                                  ;
   773                                  ;	BUGBUG - this isn't authorative - it's my probably incomplete and
   774                                  ;	possibly inaccurate deductions from code study... - jgl
   775                                  ;
   776                                  ;	The DPB is DOS's main structure for describing block devices.
   777                                  ;	It contains info about the "Drive" intermingled with info about
   778                                  ;	the FAT file system which is presumably on the drive.  I don't know
   779                                  ;	how those fields are used if it's not the FAT file system - BUGBUG
   780                                  ;
   781                                  ;	The DPBs are statically allocated and chained off of DPBHead.
   782                                  ;	Users scan this chain looking for a match on DPB_DRIVE.
   783                                  ;	The DPBs are built at init time from info in the SYSDEV structure.
   784                                  ; ---------------------------------------------------------------------------
   785                                  
   786                                  struc	DPB
   787 00000000 ??                      .DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
   788 00000001 ??                      .UNIT:		resb 1		; Driver unit number of DPB
   789 00000002 ????                    .SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
   790 00000004 ??                      .CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
   791 00000005 ??                      .CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
   792 00000006 ????                    .FIRST_FAT:	resw 1		; Starting record of FATs
   793 00000008 ??                      .FAT_COUNT:	resb 1		; Number of FATs for this drive
   794 00000009 ????                    .ROOT_ENTRIES:	resw 1		; Number of directory entries
   795 0000000B ????                    .FIRST_SECTOR:	resw 1		; First sector of first cluster
   796 0000000D ????                    .MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
   797                                  ; MSDOS 3.3
   798                                  ;.FAT_SIZE:	resb 1		; Number of records occupied by FAT
   799                                  ; MSDOS 6.0
   800 0000000F ????                    .FAT_SIZE:	resw 1		; Number of records occupied by FAT
   801 00000011 ????                    .DIR_SECTOR:	resw 1		; Starting record of directory
   802 00000013 ????????                .DRIVER_ADDR:	resd 1		; Pointer to driver
   803 00000017 ??                      .MEDIA:		resb 1		; Media byte
   804 00000018 ??                      .FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
   805                                  				; check the first time this DPB is used
   806 00000019 ????????                .NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
   807 0000001D ????                    .NEXT_FREE:	resw 1		; Cluster # of last allocated cluster
   808 0000001F ????                    .FREE_CNT:	resw 1		; Count of free clusters, -1 if unknown
   809                                  .size:
   810                                  endstruc
   811                                  
   812                                  DPBSIZ  EQU     DPB.size	; Size of the structure in bytes
   813                                  
   814                                  DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)
   815                                  
   816                                  ;                                                                          ;
   817                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   818                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   819                                  
   820                                  ;============================================================================
   821                                  ; SF.INC, MSDOS 6.0, 1991
   822                                  ;============================================================================
   823                                  ; 25/04/2019 - Retro DOS v4.0
   824                                  ; 07/07/2018 - Retro DOS v3.0
   825                                  
   826                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   827                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   828                                  ;                                                                          ;
   829                                  
   830                                  ; ---------------------------------------------------------------------------
   831                                  ;**	SF.INC - System File Table
   832                                  ;
   833                                  ;   AN000   version 4.00   Jan. 1988
   834                                  ;   AN003   PTM 3680 --  make NAME offset the same as before (<=3.30)
   835                                  ;   AN009   PTM 3839	 reorder SFT for MS WINDOWS
   836                                  ; ---------------------------------------------------------------------------
   837                                  ;**	System File Table SuperStructure
   838                                  ;
   839                                  ;	The system file table entries are allocated in contiguous groups.
   840                                  ;	There may be more than one such groups; the SF "superstructure"
   841                                  ;	tracks the groups.
   842                                  ; ---------------------------------------------------------------------------
   843                                  
   844                                  struc	SFT
   845 00000000 ????????                .SFLink:	resd 1
   846 00000004 ????                    .SFCount:	resw 1		; number of entries
   847 00000006 ????                    .SFTable:	resw 1		; beginning of array of the following
   848                                  .size:
   849                                  endstruc
   850                                  
   851                                  ; ---------------------------------------------------------------------------
   852                                  ;**	System file table entry
   853                                  ;
   854                                  ;	These are the structures which are at SFTABLE in the SF structure.
   855                                  ; ---------------------------------------------------------------------------
   856                                  
   857                                  ; 25/04/2019 - Retro DOS v4.0
   858                                  
   859                                  struc SF_ENTRY
   860 00000000 ????                    .sf_ref_count:	resw 1		; number of processes sharing entry
   861                                  				;   if FCB then ref count
   862 00000002 ????                    .sf_mode:	resw 1		; mode of access or high bit on if FCB
   863 00000004 ??                      .sf_attr:	resb 1		; attribute of file
   864 00000005 ????                    .sf_flags:	resw 1		;Bits 8-15
   865                                  				; Bit 15 = 1 if remote file
   866                                  				;	 = 0 if local file or device
   867                                  				; Bit 14 = 1 if date/time is not to be
   868                                  				;   set from clock at CLOSE.  Set by
   869                                  				;   FILETIMES and FCB_CLOSE.  Reset by
   870                                  				;   other reseters of the dirty bit
   871                                  				;   (WRITE)
   872                                  				; Bit 13 = Pipe bit (reserved)
   873                                  				;
   874                                  				; Bits 0-7 (old FCB_devid bits)
   875                                  				; If remote file or local file, bit
   876                                  				; 6=0 if dirty Device ID number, bits
   877                                  				; 0-5 if local file.
   878                                  				; bit 7=0 for local file, bit 7
   879                                  				;      =1 for local I/O device
   880                                  				; If local I/O device, bit 6=0 if EOF (input)
   881                                  				;		Bit 5=1 if Raw mode
   882                                  				;		Bit 0=1 if console input device
   883                                  				;		Bit 1=1 if console output device
   884                                  				;		Bit 2=1 if null device
   885                                  				;		Bit 3=1 if clock device
   886 00000007 ????????                .sf_devptr:	resd	1	; Points to DPB if local file, points
   887                                  				; to device header if local device,
   888                                  				; points to net device header if
   889                                  				; remote
   890 0000000B ????                    .sf_firclus:	resw	1	; First cluster of file (bit 15 = 0)
   891 0000000D ????                    .sf_time:	resw	1	; Time associated with file
   892 0000000F ????                    .sf_date:	resw	1	; Date associated with file
   893 00000011 ????????                .sf_size:	resd 	1	; Size associated with file
   894 00000015 ????????                .sf_position:	resd	1	; Read/Write pointer or LRU count for FCBs
   895                                  
   896                                  ; Starting here, the next 7 bytes may be used by the file system to store
   897                                  ; an ID
   898                                  
   899                                  ; 09/07/2018 - Retro DOS v3.0
   900                                  
   901                                  ; MSDOS 3.3 SF.INC, 1987
   902                                  ;.sf_cluspos:	resw	1	; Position of last cluster accessed
   903                                  ;.sf_lstclus	resw	1	; Last cluster accessed
   904                                  ;.sf_dirsec:	resw	1	; Sector number of directory sector
   905                                  ;				; for this file
   906                                  ;.sf_dirpos:	resb	1	; Offset of this entry in the above
   907                                  
   908                                  ; MSDOS 6.0, SF.INC, 1991
   909 00000019 ????                    .sf_cluspos:	resw	1	; Position of last cluster accessed
   910 0000001B ????????                .sf_dirsec:	resd	1	; Sector number of directory sector
   911                                  				; for this file
   912 0000001F ??                      .sf_dirpos:	resb	1	; Offset of this entry in the above
   913                                  
   914                                  ; End of 7 bytes of file-system specific info.
   915                                  
   916 00000020 <res Bh>                .sf_name:	resb	11	; 11 character name that is in the
   917                                  				; directory entry.  This is used by
   918                                  				; close to detect file deleted and
   919                                  				; disk changed errors.
   920                                  ; SHARING INFO
   921 0000002B ????????                .sf_chain:	resd	1	; link to next SF
   922 0000002F ????                    .sf_UID:	resw	1
   923 00000031 ????                    .sf_PID:	resw	1
   924 00000033 ????                    .sf_MFT:	resw	1
   925                                  
   926                                  ; MSDOS 6.0, SF.INC, 1991
   927 00000035 ????                    .sf_lstclus:	resw	1	;AN009; Last cluster accessed
   928 00000037 ????????                .sf_IFS_HDR:	resd	1
   929                                  
   930                                  .size:
   931                                  endstruc
   932                                  
   933                                  ; 20/07/2018
   934                                  ; MSDOS 3.3, SF.INC, 1987
   935                                  %define sf_netid   SF_ENTRY.sf_cluspos    ; byte
   936                                  %define sf_OpenAge SF_ENTRY.sf_position+2 ; word
   937                                  %define sf_LRU	   SF_ENTRY.sf_position	  ; word
   938                                  ; MSDOS 6.0, SF.INC, 1991
   939                                  %define sf_fsda	     SF_ENTRY.sf_cluspos  ; byte ;DOS 4.00
   940                                  %define sf_serial_ID SF_ENTRY.sf_firclus  ; word ;DOS 4.00
   941                                  
   942                                  ; 19/07/2018
   943                                  ; MSDOS 3.3, SF.INC, 1987
   944                                  
   945                                  sf_default_number  EQU	5
   946                                  
   947                                  ; Note that we need to mark an SFT as being busy for OPEN/CREATE.  This is
   948                                  ; because an INT 24 may prevent us from 'freeing' it.  We mark this as such
   949                                  ; by placing a -1 in the ref_count field.
   950                                  
   951                                  sf_busy EQU -1
   952                                  
   953                                  ; mode mask for FCB detection
   954                                  sf_isFCB		EQU	1000000000000000B
   955                                  
   956                                  ; Flag word masks
   957                                  sf_isnet		EQU	1000000000000000B
   958                                  sf_close_nodate 	EQU	0100000000000000B
   959                                  sf_pipe 		EQU	0010000000000000B
   960                                  sf_no_inherit		EQU	0001000000000000B
   961                                  sf_net_spool		EQU	0000100000000000B
   962                                  
   963                                  ; 25/04/2019
   964                                  sf_entry_size equ SF_ENTRY.size ; 59 (MSDOS 6.0)
   965                                  
   966                                  ; ---------------------------------------------------------------------------
   967                                  ; Local file/device flag masks
   968                                  ; ---------------------------------------------------------------------------
   969                                  
   970                                  devid_file_clean        EQU     40h     ; true if file and not written
   971                                  devid_file_mask_drive   EQU     3Fh     ; mask for drive number
   972                                  
   973                                  devid_device            EQU     80h     ; true if a device
   974                                  devid_device_EOF        EQU     40h     ; true if end of file reached
   975                                  devid_device_raw        EQU     20h     ; true if in raw mode
   976                                  devid_device_special    EQU     10h     ; true if special device
   977                                  devid_device_clock      EQU     08h     ; true if clock device
   978                                  devid_device_null       EQU     04h     ; true if null device
   979                                  devid_device_con_out    EQU     02h     ; true if console output
   980                                  devid_device_con_in     EQU     01h     ; true if console input
   981                                  
   982                                  ; ---------------------------------------------------------------------------
   983                                  ; structure of devid field as returned by IOCTL is:
   984                                  ;
   985                                  ;       BIT     7   6   5   4   3   2   1   0
   986                                  ;             |---|---|---|---|---|---|---|---|
   987                                  ;             | I | E | R | S | I | I | I | I |
   988                                  ;             | S | O | A | P | S | S | S | S |
   989                                  ;             | D | F | W | E | C | N | C | C |
   990                                  ;             | E |   |   | C | L | U | O | I |
   991                                  ;             | V |   |   | L | K | L | T | N |
   992                                  ;             |---|---|---|---|---|---|---|---|
   993                                  ;       ISDEV = 1 if this channel is a device
   994                                  ;             = 0 if this channel is a disk file
   995                                  ;
   996                                  ;       If ISDEV = 1
   997                                  ;
   998                                  ;             EOF = 0 if End Of File on input
   999                                  ;             RAW = 1 if this device is in Raw mode
  1000                                  ;                 = 0 if this device is cooked
  1001                                  ;             ISCLK = 1 if this device is the clock device
  1002                                  ;             ISNUL = 1 if this device is the null device
  1003                                  ;             ISCOT = 1 if this device is the console output
  1004                                  ;             ISCIN = 1 if this device is the console input
  1005                                  ;
  1006                                  ;       If ISDEV = 0
  1007                                  ;             EOF = 0 if channel has been written
  1008                                  ;             Bits 0-5 are the block device number for
  1009                                  ;                 the channel (0 = A, 1 = B, ...)
  1010                                  ; ---------------------------------------------------------------------------
  1011                                  
  1012                                  devid_ISDEV     EQU     80h
  1013                                  devid_EOF       EQU     40h
  1014                                  devid_RAW       EQU     20h
  1015                                  devid_SPECIAL   EQU     10H
  1016                                  devid_ISCLK     EQU     08h
  1017                                  devid_ISNUL     EQU     04h
  1018                                  devid_ISCOT     EQU     02h
  1019                                  devid_ISCIN     EQU     01h
  1020                                  
  1021                                  devid_block_dev EQU     1Fh             ; mask for block device number
  1022                                  
  1023                                  ;============================================================================
  1024                                  ; PDB.INC, MSDOS 6.0, 1991
  1025                                  ;============================================================================
  1026                                  ; 04/05/2019 - Retro DOS v4.0
  1027                                  ; 08/07/2018 - Retro DOS v3.0
  1028                                  
  1029                                  ; ---------------------------------------------------------------------------
  1030                                  ; BREAK <Process data block>
  1031                                  ; ---------------------------------------------------------------------------
  1032                                  ;**	Process data block (otherwise known as program header)
  1033                                  ;
  1034                                  
  1035                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
  1036                                  ;	can be rearranged here, ever. Reserved areas are probably safe
  1037                                  ;	for use.
  1038                                  ; ---------------------------------------------------------------------------
  1039                                  
  1040                                  FILPERPROC	EQU     20
  1041                                  
  1042                                  struc PDB	; Process_data_block
  1043 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
  1044 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
  1045 00000004 ??                                      resb 1
  1046 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
  1047 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
  1048 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
  1049 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
  1050 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
  1051 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
  1052 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
  1053 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
  1054 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
  1055 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
  1056 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
  1057 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
  1058 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
  1059 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
  1060 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
  1061 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
  1062 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
  1063 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
  1064                                  				;  an extended FCB
  1065                                  ;endstruc 	; MSDOS 3.3
  1066                                  	  	; MSDOS 6.0
  1067 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
  1068 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
  1069 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
  1070 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
  1071                                  endstruc
  1072                                  
  1073                                  ;============================================================================
  1074                                  ; EXE.INC, MSDOS 6.0, 1991
  1075                                  ;============================================================================
  1076                                  ; 04/05/2019 - Retro DOS v4.0
  1077                                  
  1078                                  ;**	EXE.INC - Definitions for the EXEC command and EXE files
  1079                                  ; ---------------------------------------------------------------------------
  1080                                  ; The following get used as arguments to the EXEC system call.  They indicate
  1081                                  ; whether or not the program is executed or whether or not a program header
  1082                                  ; gets created.
  1083                                  
  1084                                  exec_func_no_execute EQU 1	; no execute bit
  1085                                  exec_func_overlay    EQU 2	; overlay bit
  1086                                  
  1087                                  struc EXEC0
  1088 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
  1089 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
  1090 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
  1091 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
  1092                                  .size:
  1093                                  endstruc
  1094                                  
  1095                                  struc EXEC1
  1096 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
  1097 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
  1098 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
  1099 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
  1100 0000000E ????                    .SP:		resw 1		; stack pointer of program
  1101 00000010 ????                    .SS:		resw 1		; stack seg register of program
  1102 00000012 ????                    .IP:		resw 1		; entry point IP
  1103 00000014 ????                    .CS:		resw 1		; entry point CS
  1104                                  .size:
  1105                                  endstruc
  1106                                  
  1107                                  struc EXEC3
  1108 00000000 ????                    .load_addr:	resw 1		; seg address of load point
  1109 00000002 ????                    .reloc_fac:	resw 1		; relocation factor
  1110                                  endstruc
  1111                                  
  1112                                  ;**	Exit codes (in upper byte) for terminating programs
  1113                                  
  1114                                  EXIT_TERMINATE		EQU	0
  1115                                  EXIT_ABORT		EQU	0
  1116                                  EXIT_CTRL_C		EQU	1
  1117                                  EXIT_HARD_ERROR 	EQU	2
  1118                                  EXIT_KEEP_PROCESS	EQU	3
  1119                                  
  1120                                  ;**	EXE File Header Description
  1121                                  
  1122                                  struc EXE
  1123 00000000 ????                    .signature:   resw 1		; must contain 4D5A (yay zibo!)
  1124 00000002 ????                    .len_mod_512: resw 1		; low 9 bits of length
  1125 00000004 ????                    .pages:       resw 1		; number of 512b pages in file
  1126 00000006 ????                    .rle_count:   resw 1		; count of reloc entries
  1127 00000008 ????                    .par_dir:     resw 1		; number of paragraphs before image
  1128 0000000A ????                    .min_BSS:     resw 1		; minimum number of para of BSS
  1129 0000000C ????                    .max_BSS:     resw 1		; max number of para of BSS
  1130 0000000E ????                    .SS:          resw 1		; stack of image
  1131 00000010 ????                    .SP:          resw 1		; SP of image
  1132 00000012 ????                    .chksum:      resw 1		; checksum of file (ignored)
  1133 00000014 ????                    .IP:          resw 1		; IP of entry
  1134 00000016 ????                    .CS:          resw 1		; CS of entry
  1135 00000018 ????                    .rle_table:   resw 1		; byte offset of reloc table
  1136 0000001A ????                    .iov:         resw 1		; overlay number (0 for root)
  1137 0000001C ????????                .sym_tab:     resd 1		; offset of symbol table in file
  1138                                  .size:
  1139                                  endstruc
  1140                                  
  1141                                  exe_valid_signature     EQU 5A4Dh
  1142                                  exe_valid_old_signature EQU 4D5Ah
  1143                                  
  1144                                  ;**	EXE file symbol info definitions
  1145                                  
  1146                                  struc symbol_entry
  1147 00000000 ????????                .value:	resd 1
  1148 00000004 ????                    .type:	resw 1
  1149 00000006 ??                      .len:	resb 1
  1150 00000007 <res FFh>               .name:	resb 255
  1151                                  endstruc
  1152                                  
  1153                                  ;**	Data structure passed for ExecReady call
  1154                                  
  1155                                  struc ERStruc
  1156 00000000 ????                     .ER_Reserved:	resw	1	; reserved, should be zero
  1157 00000002 ????                     .ER_Flags:	resw	1
  1158 00000004 ????????                 .ER_ProgName:	resd	1	; ptr to ASCIIZ str of prog name
  1159 00000008 ????                     .ER_PSP:	resw	1	; PSP of the program
  1160 0000000A ????????                 .ER_StartAddr:	resd	1	; Start CS:IP of the program
  1161 0000000E ????????                 .ER_ProgSize:	resd	1	; Program size including PSP
  1162                                   .size:
  1163                                  endstruc
  1164                                  
  1165                                  ;** bit fields in ER_Flags
  1166                                  
  1167                                  ER_EXE		equ	0001h
  1168                                  ER_OVERLAY	equ	0002h
  1169                                  
  1170                                  
  1171                                  ;============================================================================
  1172                                  ; ARENA.INC, MSDOS 6.0, 1991
  1173                                  ;============================================================================
  1174                                  ; 24/04/2019 - Retro DOS v4.0
  1175                                  ; 04/08/2018 - Retro DOS v3.0
  1176                                  
  1177                                  ;BREAK <Memory arena structure>
  1178                                  
  1179                                  ;**	Arena Header
  1180                                  
  1181                                  struc ARENA
  1182 00000000 ??                      .SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
  1183 00000001 ????                    .OWNER:		resw 1		; owner of arena item
  1184 00000003 ????                    .SIZE:		resw 1		; size in paragraphs of item
  1185 00000005 ??????                  .RESERVED:	resb 3		; reserved
  1186 00000008 ????????????????        .NAME:		resb 8		; owner file name
  1187                                  .headersize:			
  1188                                  endstruc
  1189                                  
  1190                                  ; 20/05/2019 - Retro DOS v4.0
  1191                                  ARENAHEADERSIZE equ ARENA.headersize 
  1192                                  
  1193                                  ; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
  1194                                  ; and arena_owner_system are all equal to zero and are contained in DI.
  1195                                  ; Change them and change ALLOC.ASM.
  1196                                  
  1197                                  arena_owner_system  EQU 0               ; free block indication
  1198                                  
  1199                                  arena_signature_normal	EQU 4Dh		; valid signature, not end of arena
  1200                                  arena_signature_end     EQU 5Ah         ; valid signature, last block in arena
  1201                                  
  1202                                  FIRST_FIT	EQU	00000000B
  1203                                  BEST_FIT	EQU	00000001B
  1204                                  LAST_FIT	EQU	00000010B
  1205                                  
  1206                                  ; MSDOS 6.0
  1207                                  LOW_FIRST	EQU	00000000B	; M001
  1208                                  HIGH_FIRST	EQU	10000000B	; M001
  1209                                  HIGH_ONLY	EQU	01000000B	; M001
  1210                                  
  1211                                  LINKSTATE	EQU	00000001B	; M002
  1212                                  
  1213                                  HF_MASK		EQU	~HIGH_FIRST	; M001
  1214                                  HO_MASK		EQU	~HIGH_ONLY	; M001
  1215                                  
  1216                                  STRAT_MASK	EQU	HF_MASK & HO_MASK	; M001;
  1217                                  						; M026: used to mask of bits
  1218                                  						; M026: 6 & 7 of AllocMethod
  1219                                  
  1220                                  ;============================================================================
  1221                                  ; MI.INC, MSDOS 6.0, 1991
  1222                                  ;============================================================================
  1223                                  ; 07/07/2018 - Retro DOS v3.0
  1224                                  
  1225                                  ;BREAK <Machine instruction, flag definitions and character types>
  1226                                  
  1227                                  mi_INT		EQU	0CDh
  1228                                  mi_long_jmp	EQU	0EAh
  1229                                  mi_Long_CALL	EQU	09Ah
  1230                                  mi_Long_RET	EQU	0CBh
  1231                                  mi_Near_RET	EQU	0C3h
  1232                                  
  1233                                  ;			xxxxoditszxaxpxc
  1234                                  f_Overflow	EQU	0000100000000000B
  1235                                  f_Direction	EQU	0000010000000000B
  1236                                  f_Interrupt	EQU	0000001000000000B
  1237                                  f_Trace 	EQU	0000000100000000B
  1238                                  f_Sign		EQU	0000000010000000B
  1239                                  f_Zero		EQU	0000000001000000B
  1240                                  f_Aux		EQU	0000000000010000B
  1241                                  f_Parity	EQU	0000000000000100B
  1242                                  f_Carry 	EQU	0000000000000001B
  1243                                  
  1244                                  ;============================================================================
  1245                                  ; FILEMODE.INC, MSDOS 6.0, 1991
  1246                                  ;============================================================================
  1247                                  ; 13/07/2018 - Retro DOS v3.0
  1248                                  ; 29/04/2019 - Retro DOS v4.0
  1249                                  
  1250                                  ;**	Standard I/O file handles
  1251                                  
  1252                                  stdin       EQU     0
  1253                                  stdout      EQU     1
  1254                                  stderr      EQU     2
  1255                                  stdaux      EQU     3
  1256                                  stdprn      EQU     4
  1257                                  
  1258                                  ;**	File Modes
  1259                                  ; <Xenix subfunction assignments>  ; MSDOS 3.3 FILEMODE.INC
  1260                                  
  1261                                  open_for_read   EQU 0
  1262                                  open_for_write  EQU 1
  1263                                  open_for_both   EQU 2
  1264                                  
  1265                                  ; MSDOS 6.0
  1266                                  OPEN_FOR_BOTH	equ 2
  1267                                  EXEC_OPEN	equ 3	; access code of 3 indicates that open was 
  1268                                  				; made from exec
  1269                                  
  1270                                  access_mask	EQU 0Fh ; 09/08/2018
  1271                                  
  1272                                  SHARING_MASK	    equ 0F0h
  1273                                  SHARING_COMPAT	    equ 000h
  1274                                  SHARING_DENY_BOTH   equ 010h
  1275                                  SHARING_DENY_WRITE  equ 020h
  1276                                  SHARING_DENY_READ   equ 030h
  1277                                  SHARING_DENY_NONE   equ 040h
  1278                                  SHARING_NET_FCB     equ 070h
  1279                                  SHARING_NO_INHERIT  equ 080h
  1280                                  
  1281                                  ; 29/04/2019
  1282                                  
  1283                                  ;**	Extended Open Definitions
  1284                                  
  1285                                  RESERVED_BITS_MASK equ 0FE00h	; reserved bits for extended open flags
  1286                                  EXISTS_MASK	   equ 0Fh 	; "file exists" action field
  1287                                  NOT_EXISTS_MASK    equ 0F0h
  1288                                  
  1289                                  ;*	SF_MODE values
  1290                                  
  1291                                  AUTO_COMMIT_WRITE	equ 4000h
  1292                                  INT_24_ERROR		equ 2000h
  1293                                  
  1294                                  ;*	Flags in EXTOPEN_ON
  1295                                  
  1296                                  EXT_OPEN_ON		equ 01h
  1297                                  EXT_FILE_NOT_EXISTS	equ 04h
  1298                                  EXT_OPEN_I24_OFF	equ 02h
  1299                                  
  1300                                  ;*	Flags in EXTOPEN_FLAG
  1301                                  
  1302                                  ACTION_OPENED		equ 01h
  1303                                  ACTION_CREATED_OPENED	equ 02h
  1304                                  ACTION_REPLACED_OPENED	equ 03h
  1305                                  EXT_EXISTS_OPEN 	equ 01h
  1306                                  EXT_EXISTS_FAIL 	equ 00h
  1307                                  EXT_NEXISTS_CREATE	equ 10h
  1308                                  
  1309                                  ;**	Extended Open Structure
  1310                                  
  1311                                  struc EXT_OPEN_PARM
  1312 00000000 ????????                .SET_LIST:	resd 1
  1313 00000004 ????                    .NUM_OF_PARM:	resw 1
  1314                                  endstruc
  1315                                  
  1316                                  ;============================================================================
  1317                                  ; SYSCALL.INC, MSDOS 6.0, 1991
  1318                                  ;============================================================================
  1319                                  ; 29/04/2019 - Retro DOS v4.0
  1320                                  ; 09/07/2018 - Retro DOS v3.0 (SYSCALL.INC, MSDOS 3.3, 1987)
  1321                                  
  1322                                  ; <system call definitions>
  1323                                  
  1324                                  ABORT                           EQU 0   ;  0      0
  1325                                  STD_CON_INPUT                   EQU 1   ;  1      1
  1326                                  STD_CON_OUTPUT                  EQU 2   ;  2      2
  1327                                  STD_AUX_INPUT                   EQU 3   ;  3      3
  1328                                  STD_AUX_OUTPUT                  EQU 4   ;  4      4
  1329                                  STD_PRINTER_OUTPUT              EQU 5   ;  5      5
  1330                                  RAW_CON_IO                      EQU 6   ;  6      6
  1331                                  RAW_CON_INPUT                   EQU 7   ;  7      7
  1332                                  STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
  1333                                  STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
  1334                                  STD_CON_STRING_INPUT            EQU 10  ; 10      A
  1335                                  STD_CON_INPUT_STATUS            EQU 11  ; 11      B
  1336                                  STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
  1337                                  DISK_RESET                      EQU 13  ; 13      D
  1338                                  SET_DEFAULT_DRIVE               EQU 14  ; 14      E
  1339                                  FCB_OPEN                        EQU 15  ; 15      F
  1340                                  FCB_CLOSE                       EQU 16  ; 16     10
  1341                                  DIR_SEARCH_FIRST                EQU 17  ; 17     11
  1342                                  DIR_SEARCH_NEXT                 EQU 18  ; 18     12
  1343                                  FCB_DELETE                      EQU 19  ; 19     13
  1344                                  FCB_SEQ_READ                    EQU 20  ; 20     14
  1345                                  FCB_SEQ_WRITE                   EQU 21  ; 21     15
  1346                                  FCB_CREATE                      EQU 22  ; 22     16
  1347                                  FCB_RENAME                      EQU 23  ; 23     17
  1348                                  GET_DEFAULT_DRIVE               EQU 25  ; 25     19
  1349                                  SET_DMA                         EQU 26  ; 26     1A
  1350                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1351                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1352                                  ;                                                                          ;
  1353                                  GET_DEFAULT_DPB                 EQU 31  ; 31     1F
  1354                                  ;                                                                          ;
  1355                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1356                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1357                                  FCB_RANDOM_READ                 EQU 33  ; 33     21
  1358                                  FCB_RANDOM_WRITE                EQU 34  ; 34     22
  1359                                  GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
  1360                                  GET_FCB_POSITION                EQU 36  ; 36     24
  1361                                  SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
  1362                                  CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
  1363                                  FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
  1364                                  FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
  1365                                  PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
  1366                                  GET_DATE                        EQU 42  ; 42     2A
  1367                                  SET_DATE                        EQU 43  ; 43     2B
  1368                                  GET_TIME                        EQU 44  ; 44     2C
  1369                                  SET_TIME                        EQU 45  ; 45     2D
  1370                                  SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
  1371                                  ; Extended functionality group
  1372                                  GET_DMA                         EQU 47  ; 47     2F
  1373                                  GET_VERSION                     EQU 48  ; 48     30
  1374                                  KEEP_PROCESS                    EQU 49  ; 49     31
  1375                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1376                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1377                                  ;                                                                          ;
  1378                                  GET_DPB                         EQU 50  ; 50     32
  1379                                  ;                                                                          ;
  1380                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1381                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1382                                  SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
  1383                                  GET_INDOS_FLAG                  EQU 52  ; 52     34
  1384                                  GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
  1385                                  GET_DRIVE_FREESPACE             EQU 54  ; 54     36
  1386                                  CHAR_OPER                       EQU 55  ; 55     37
  1387                                  INTERNATIONAL                   EQU 56  ; 56     38
  1388                                  ; XENIX CALLS
  1389                                  ;   Directory Group
  1390                                  MKDIR                           EQU 57  ; 57     39
  1391                                  RMDIR                           EQU 58  ; 58     3A
  1392                                  CHDIR                           EQU 59  ; 59     3B
  1393                                  ;   File Group
  1394                                  CREAT                           EQU 60  ; 60     3C
  1395                                  OPEN                            EQU 61  ; 61     3D
  1396                                  CLOSE                           EQU 62  ; 62     3E
  1397                                  READ                            EQU 63  ; 63     3F
  1398                                  WRITE                           EQU 64  ; 64     40
  1399                                  UNLINK                          EQU 65  ; 65     41
  1400                                  LSEEK                           EQU 66  ; 66     42
  1401                                  CHMOD                           EQU 67  ; 67     43
  1402                                  IOCTL                           EQU 68  ; 68     44
  1403                                  XDUP                            EQU 69  ; 69     45
  1404                                  XDUP2                           EQU 70  ; 70     46
  1405                                  CURRENT_DIR                     EQU 71  ; 71     47
  1406                                  ;    Memory Group
  1407                                  ALLOC                           EQU 72  ; 72     48
  1408                                  DEALLOC                         EQU 73  ; 73     49
  1409                                  SETBLOCK                        EQU 74  ; 74     4A
  1410                                  ;    Process Group
  1411                                  EXEC                            EQU 75  ; 75     4B
  1412                                  EXIT                            EQU 76  ; 76     4C
  1413                                  _WAIT				EQU 77  ; 77     4D
  1414                                  FIND_FIRST                      EQU 78  ; 78     4E
  1415                                  ;   Special Group
  1416                                  FIND_NEXT                       EQU 79  ; 79     4F
  1417                                  ; SPECIAL SYSTEM GROUP
  1418                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1419                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1420                                  ;                                                                          ;
  1421                                  SET_CURRENT_PDB                 EQU 80  ; 80     50
  1422                                  GET_CURRENT_PDB                 EQU 81  ; 81     51
  1423                                  GET_IN_VARS                     EQU 82  ; 82     52
  1424                                  SETDPB                          EQU 83  ; 83     53
  1425                                  ;                                                                          ;
  1426                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1427                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1428                                  GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
  1429                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1430                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1431                                  ;                                                                          ;
  1432                                  DUP_PDB                         EQU 85  ; 85     55
  1433                                  ;                                                                          ;
  1434                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1435                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1436                                  RENAME                          EQU 86  ; 86     56
  1437                                  FILE_TIMES                      EQU 87  ; 87     57
  1438                                  ALLOCOPER			EQU 88	; 88	 58
  1439                                  ; Network extention system calls
  1440                                  GETEXTENDEDERROR		EQU 89	; 89	 59
  1441                                  CREATETEMPFILE			EQU 90	; 90	 5A
  1442                                  CREATENEWFILE			EQU 91	; 91	 5B
  1443                                  LOCKOPER			EQU 92	; 92	 5C Lock and Unlock
  1444                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1445                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1446                                  ;									   ;
  1447                                  SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
  1448                                  					;	    CloseByName, CloseUser,
  1449                                  					;	    CloseUserProcess,
  1450                                  					;	    GetOpenFileList
  1451                                  ;									   ;
  1452                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1453                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1454                                  USEROPER			EQU 94	; 94	 5E Get and Set
  1455                                  ASSINGOPER			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
  1456                                  XNAMETRANS			EQU 96	; 96	 60
  1457                                  PATHPARSE			EQU 97	; 97	 61
  1458                                  GETCURRENTPSP			EQU 98	; 98	 62
  1459                                  HONGEUL 			EQU 99	; 99	 63
  1460                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1461                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1462                                  ;									   ;
  1463                                  SET_PRINTER_FLAG		EQU 100 ; 100	 64
  1464                                  ;									   ;
  1465                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1466                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1467                                  GETEXTCNTRY			EQU 101 ; 101	 65 
  1468                                  GETSETCDPG			EQU 102 ; 102	 66
  1469                                  EXTHANDLE			EQU 103 ; 103	 67
  1470                                  COMMIT				EQU 104 ; 104	 68
  1471                                  
  1472                                  ; 29/04/2019 - Retro DOS v4.0
  1473                                  ; (MSDOS 6.0, SYSCALL.INC, 1987)
  1474                                  
  1475                                  GetSetMediaID			EQU 105 ; 105	 69
  1476                                  IFS_IOCTL			EQU 107 ; 107	 6B
  1477                                  ExtOpen 			EQU 108 ; 108	 6C
  1478                                  
  1479                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1480                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1481                                  ;                                                                          ;
  1482                                  ;ifdef ROMEXEC
  1483                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
  1484                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
  1485                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
  1486                                  ;endif
  1487                                  ;                                                                          ;
  1488                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1489                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1490                                  
  1491                                  SET_OEM_HANDLER			EQU 248 ; 248    F8
  1492                                  ;OEM_C1				EQU 249 ; 249    F9
  1493                                  ;OEM_C2				EQU 250 ; 250    FA
  1494                                  ;OEM_C3				EQU 251 ; 251    FB
  1495                                  ;OEM_C4				EQU 252 ; 252    FC
  1496                                  ;OEM_C5				EQU 253 ; 253    FD
  1497                                  ;OEM_C6				EQU 254 ; 254    FE
  1498                                  ;OEM_C7				EQU 255 ; 255    FF
  1499                                  
  1500                                  ;============================================================================
  1501                                  ; VERSIONA.INC (MSDOS 6.0, 1991)
  1502                                  ;============================================================================
  1503                                  ; 24/04/2019 - Retro DOS 4.0
  1504                                  
  1505                                  ;MAJOR_VERSION	EQU     6
  1506                                  ;;MINOR_VERSION	EQU	00
  1507                                  ;MINOR_VERSION	EQU     21  ; MSDOS 6.21
  1508                                  
  1509                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  1510                                  ;MAJOR_VERSION	EQU     5
  1511                                  ;MINOR_VERSION	EQU     0
  1512                                  
  1513                                  ; 30/12/2022 - Retro DOS v4.2
  1514                                  MAJOR_VERSION	EQU     6
  1515                                  MINOR_VERSION	EQU     22
  1516                                  
  1517                                  ;============================================================================
  1518                                  ; INTNAT.INC, MSDOS 3.3, 1987
  1519                                  ;============================================================================
  1520                                  ; 09/07/2018 - Retro DOS 3.0
  1521                                  
  1522                                  ; Current structure of the data returned by the international call
  1523                                  
  1524                                  struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  1525                                  .Date_tim_format:
  1526 00000000 ????                    		RESW 1		; 0-USA, 1-EUR, 2-JAP
  1527                                  .Currency_sym:
  1528 00000002 ??????????              		RESB 5		; Currency Symbol 5 bytes
  1529                                  .Thous_sep:
  1530 00000007 ????                    		RESB 2		; Thousands separator 2 bytes
  1531                                  .Decimal_sep:
  1532 00000009 ????                    		RESB 2		; Decimal separator 2 bytes
  1533                                  .Date_sep:
  1534 0000000B ????                    		RESB 2		; Date separator 2 bytes
  1535                                  .Time_sep:
  1536 0000000D ????                    		RESB 2		; Time separator 2 bytes
  1537                                  .Bit_field:	
  1538 0000000F ??                      		RESB 1		; Bit values
  1539                                                                     ;   Bit 0 = 0 if currency symbol first
  1540                                                                     ;         = 1 if currency symbol last
  1541                                                                     ;   Bit 1 = 0 if No space after currency symbol
  1542                                                                     ;         = 1 if space after currency symbol
  1543                                  .Currency_cents:
  1544 00000010 ??                      		RESB 	1	; Number of places after currency dec point
  1545                                  .Time_24:
  1546 00000011 ??                      		RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
  1547                                  .Map_call:
  1548 00000012 ????                    		RESW	1	; Address of case mapping call (DWORD)
  1549 00000014 ????                                    RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
  1550                                  				;  in pieces.
  1551                                  .Data_sep:
  1552 00000016 ????                    		RESB	2	; Data list separator character
  1553                                  .size:		
  1554                                  endstruc
  1555                                  
  1556                                  ; Max size of the block returned by the INTERNATIONAL call
  1557                                  
  1558                                  internat_block_max	EQU	32
  1559                                  
  1560                                  ;============================================================================
  1561                                  ; SYSVAR.INC (MSDOS 6.0, 1991)
  1562                                  ;============================================================================
  1563                                  ; 08/07/2018 - Retro DOS v3.0
  1564                                  
  1565                                  ;SysInitVars STRUC
  1566                                  struc SYSI
  1567 00000000 ????????                .DPB:	    resd 1		; DPB chain
  1568 00000004 ????????                .SFT:	    resd 1		; SFT chain
  1569 00000008 ????????                .CLOCK:	    resd 1		; CLOCK device
  1570 0000000C ????????                .CON:	    resd 1		; CON device
  1571 00000010 ????                    .MAXSEC:    resw 1		; maximum sector size
  1572 00000012 ????????                .BUF:	    resd 1		; points to Hashinitvar
  1573 00000016 ????????                .CDS:	    resd 1		; CDS list
  1574 0000001A ????????                .FCB:	    resd 1		; FCB chain
  1575 0000001E ????                    .Keep:	    resw 1		; keep count
  1576 00000020 ??                      .NUMIO:	    resb 1		; Number of block devices
  1577 00000021 ??                      .NCDS:	    resb 1		; number of CDS's
  1578 00000022 ????????                .DEV:	    resd 1		; device list
  1579                                  ; 09/07/2018
  1580                                  ; Above parameters are described in MSDOS 3.3 SYSVAR.INC (85/04/10)
  1581                                  ; Following parameters are used with MSDOS 6.0 (Retro DOS v4.0)
  1582 00000026 ????                    .ATTR:	    resw 1		; null device attribute word
  1583 00000028 ????                    .STRAT:	    resw 1		; null device strategy entry point
  1584 0000002A ????                    .INTER:	    resw 1		; null device interrupt entry point
  1585 0000002C ????????????????        .NAME:	    resb 8		; null device name
  1586 00000034 ??                      .SPLICE:    resb 1		; TRUE -> splicees being done
  1587 00000035 ????                    .IBMDOS_SIZE: resw 1		; DOS size in paragraphs
  1588 00000037 ????????                .IFS_DOSCALL@: resd 1		; IFS DOS service routine entry
  1589 0000003B ????????                .IFS:	    resd 1		; IFS header chain
  1590 0000003F ????????                .BUFFERS:   resw 2		; BUFFERS= values (m,n)
  1591 00000043 ??                      .BOOT_DRIVE: resb 1		; boot drive A=1 B=2,..
  1592 00000044 ??                      .DWMOVE:    resb 1		; 1 if 386 machine
  1593 00000045 ????                    .EXT_MEM:   resw 1		; Extended memory size in KB.
  1594                                  endstruc
  1595                                  ;SysInitVars ENDS
  1596                                  
  1597                                  ;This is added for more information exchange between DOS, BIOS.
  1598                                  ;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86
  1599                                  
  1600                                  ;SysInitVars_Ext struc
  1601                                  struc SYSI_EXT
  1602 00000000 ????????                .SysInitVars:	resd 1		; Points to the above structure.
  1603 00000004 ????????                .Country_Tab:	resd 1		; DOS_Country_cdpg_info
  1604                                  endstruc
  1605                                  ;SysInitVars_Ext ends
  1606                                  
  1607                                  ;============================================================================
  1608                                  ; IOCTL.INC - MSDOS 6.0 - 1991
  1609                                  ;============================================================================
  1610                                  ; 09/07/2018 - Retro DOS v3.0
  1611                                  
  1612                                  ;*** J.K.
  1613                                  ;General Guide -
  1614                                  ;Category Code:
  1615                                  ; 0... .... DOS Defined
  1616                                  ; 1... .... User defined
  1617                                  ; .xxx xxxx Code
  1618                                  
  1619                                  ;Function Code:
  1620                                  ; 0... .... Return error if unsupported
  1621                                  ; 1... .... Ignore if unsupported
  1622                                  ; .0.. .... Intercepted by DOS
  1623                                  ; .1.. .... Passed to driver
  1624                                  ; ..0. .... Sends data/commands to device
  1625                                  ; ..1. .... Quries data/info from device
  1626                                  ; ...x .... Subfunction
  1627                                  ;
  1628                                  ; Note that "Sends/queries" data bit is intended only to regularize the
  1629                                  ; function set.  It plays no critical role; some functions may contain both
  1630                                  ; command and query elements. The convention is that such commands are
  1631                                  ; defined as "sends data".
  1632                                  
  1633                                  ;*****************************;*
  1634                                  ; BLOCK DRIVERS 	      ;*
  1635                                  ;*****************************;*
  1636                                  
  1637                                  ; IOCTL SUB-FUNCTIONS
  1638                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1639                                  IOCTL_GET_DEVICE_INFO	EQU	0
  1640                                  IOCTL_SET_DEVICE_INFO	EQU	1
  1641                                  IOCTL_READ_HANDLE	EQU	2
  1642                                  IOCTL_WRITE_HANDLE	EQU	3
  1643                                  IOCTL_READ_DRIVE	EQU	4
  1644                                  IOCTL_WRITE_DRIVE	EQU	5
  1645                                  IOCTL_GET_INPUT_STATUS	EQU	6
  1646                                  IOCTL_GET_OUTPUT_STATUS EQU	7
  1647                                  IOCTL_CHANGEABLE?	EQU	8
  1648                                  IOCTL_DeviceLocOrRem?	EQU	9
  1649                                  IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
  1650                                  IOCTL_SHARING_RETRY	EQU	0Bh   ;11
  1651                                  GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
  1652                                  GENERIC_IOCTL		EQU	0Dh   ;13
  1653                                  ; (MSDOS 6.0 + MSDOS 3.3)
  1654                                  IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
  1655                                  IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
  1656                                  ; (MSDOS 6.0)
  1657                                  IOCTL_QUERY_HANDLE	EQU	10h   ;16
  1658                                  IOCTL_QUERY_BLOCK	EQU	11h   ;17
  1659                                  
  1660                                  ; GENERIC IOCTL CATEGORY CODES
  1661                                  IOC_OTHER		EQU	0	; Other device control J.K. 4/29/86
  1662                                  IOC_SE			EQU	1	; SERIAL DEVICE CONTROL
  1663                                  IOC_TC			EQU	2	; TERMINAL CONTROL
  1664                                  IOC_SC			EQU	3	; SCREEN CONTROL
  1665                                  IOC_KC			EQU	4	; KEYBOARD CONTROL
  1666                                  IOC_PC			EQU	5	; PRINTER CONTROL
  1667                                  IOC_DC			EQU	8	; DISK CONTROL (SAME AS RAWIO)
  1668                                  
  1669                                  ; GENERIC IOCTL SUB-FUNCTIONS
  1670                                  RAWIO			EQU	8
  1671                                  
  1672                                  ; RAWIO SUB-FUNCTIONS
  1673                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1674                                  GET_DEVICE_PARAMETERS	EQU	60H
  1675                                  SET_DEVICE_PARAMETERS	EQU	40H
  1676                                  READ_TRACK		EQU	61H
  1677                                  WRITE_TRACK		EQU	41H
  1678                                  VERIFY_TRACK		EQU	62H
  1679                                  FORMAT_TRACK		EQU	42H
  1680                                  ; (MSDOS 6.0)
  1681                                  GET_MEDIA_ID		EQU	66h	;AN000;AN003;changed from 63h
  1682                                  SET_MEDIA_ID		EQU	46h	;AN000;AN003;changed from 43h
  1683                                  GET_ACCESS_FLAG 	EQU	67h	;AN002;AN003;Unpublished function.Changed from 64h
  1684                                  SET_ACCESS_FLAG 	EQU	47h	;AN002;AN003;Unpublished function.Changed from 44h
  1685                                  SENSE_MEDIA_TYPE	EQU	68H	;Added for 5.00
  1686                                  
  1687                                  ; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
  1688                                  BUILD_DEVICE_BPB	EQU	000000001B
  1689                                  
  1690                                  ; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
  1691                                  INSTALL_FAKE_BPB	EQU	000000001B
  1692                                  ONLY_SET_TRACKLAYOUT	EQU	000000010B
  1693                                  TRACKLAYOUT_IS_GOOD	EQU	000000100B
  1694                                  
  1695                                  ; SPECIAL FUNCTION FOR FORMAT TRACK
  1696                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1697                                  STATUS_FOR_FORMAT	EQU	000000001B
  1698                                  ; (MSDOS 6.0)
  1699                                  DO_FAST_FORMAT		EQU	000000010B ;AN001;
  1700                                  
  1701                                  ; CODES RETURNED FROM FORMAT STATUS CALL
  1702                                  FORMAT_NO_ROM_SUPPORT	EQU	000000001B
  1703                                  FORMAT_COMB_NOT_SUPPORTED EQU	000000010B
  1704                                  
  1705                                  ; DEVICETYPE VALUES
  1706                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1707                                  MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
  1708                                  DEV_5INCH		EQU	0
  1709                                  DEV_5INCH96TPI		EQU	1
  1710                                  DEV_3INCH720KB		EQU	2
  1711                                  DEV_8INCHSS		EQU	3
  1712                                  DEV_8INCHDS		EQU	4
  1713                                  DEV_HARDDISK		EQU	5
  1714                                  DEV_OTHER		EQU	7
  1715                                  ; (MSDOS 6.0)
  1716                                  ;DEV_3INCH1440KB	EQU	7
  1717                                  DEV_3INCH2880KB		EQU	9
  1718                                  ; Retro DOS v2.0 - 26/03/2018
  1719                                  ;;DEV_TAPE		EQU	6
  1720                                  ;;DEV_ERIMO		EQU	8
  1721                                  ;DEV_3INCH2880KB	EQU	9
  1722                                  DEV_3INCH1440KB		EQU	10
  1723                                  
  1724                                  ; (MSDOS 3.3)
  1725                                  ;MAX_DEV_TYPE		EQU	7
  1726                                  
  1727                                  ; (MSDOS 6.0)
  1728                                  MAX_DEV_TYPE		EQU	10	; MAXIMUM DEVICE TYPE THAT WE
  1729                                  					; CURRENTLY SUPPORT.
  1730                                  struc A_SECTORTABLE
  1731 00000000 ????                    .ST_SECTORNUMBER:	resw	1
  1732 00000002 ????                    .ST_SECTORSIZE:		resw	1
  1733                                  .size:
  1734                                  endstruc
  1735                                  
  1736                                  ;============================================================================
  1737                                  ; DEVSYM.INC
  1738                                  ;============================================================================
  1739                                  ; 07/07/2018 - Retro DOS v3.0
  1740                                  ; 30/04/2019 - Retro DOS v4.0 (DEVSYM.INC, MSDOS 6.0, 1991)
  1741                                  
  1742                                  ;**	DevSym.inc - Device Symbols
  1743                                  
  1744                                  ; The device table list has the form:
  1745                                  struc	SYSDEV
  1746 00000000 ????????                .NEXT:		resd 1		;Pointer to next device header
  1747 00000004 ????                    .ATT:		resw 1		;Attributes of the device
  1748 00000006 ????                    .STRAT:		resw 1		;Strategy entry point
  1749 00000008 ????                    .INT:		resw 1		;Interrupt entry point
  1750 0000000A ????????????????        .NAME:		resb 8		;Name of device (only first byte used for block)
  1751                                  .size:
  1752                                  endstruc
  1753                                  
  1754                                  ;
  1755                                  ; ATTRIBUTE BIT MASKS
  1756                                  ;
  1757                                  ; CHARACTER DEVICES:
  1758                                  ;
  1759                                  ; BIT 15 -> MUST BE 1
  1760                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1761                                  ;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
  1762                                  ;     12 -> UNUSED
  1763                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
  1764                                  ;     10 -> MUST BE 0
  1765                                  ;      9 -> MUST BE 0
  1766                                  ;      8 -> UNUSED
  1767                                  ;      7 -> UNUSED
  1768                                  ;      6 -> UNUSED
  1769                                  ;      5 -> UNUSED
  1770                                  ;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
  1771                                  ;      3 -> 1 IF DEVICE IS CLOCK DEVICE
  1772                                  ;      2 -> 1 IF DEVICE IS NULL DEVICE
  1773                                  ;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
  1774                                  ;      0 -> 1 IF DEVICE IS CONSOLE INPUT
  1775                                  ;
  1776                                  ; BLOCK DEVICES:
  1777                                  ;
  1778                                  ; BIT 15 -> MUST BE 0
  1779                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1780                                  ;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
  1781                                  ;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
  1782                                  ;	    THE SAME PLACE.
  1783                                  ;     12 -> UNUSED
  1784                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
  1785                                  ;     10 -> MUST BE 0
  1786                                  ;      9 -> MUST BE 0
  1787                                  ;      8 -> UNUSED
  1788                                  ;      7 -> UNUSED
  1789                                  ;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
  1790                                  ;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
  1791                                  ;      5 -> UNUSED
  1792                                  ;      4 -> UNUSED
  1793                                  ;      3 -> UNUSED
  1794                                  ;      2 -> UNUSED
  1795                                  ;      1 -> UNUSED
  1796                                  ;      0 -> UNUSED
  1797                                  ;
  1798                                  
  1799                                  ;Attribute bit masks
  1800                                  DEVTYP	EQU     8000H           ;Bit 15 - 1 if Char, 0 if block
  1801                                  DEVIOCTL EQU    4000H           ;Bit 14 - CONTROL mode bit
  1802                                  ISFATBYDEV EQU  2000H           ;Bit 13 - Device uses FAT ID bytes, comp media.
  1803                                  
  1804                                  ; 09/07/2018 - Retro DOS (DEVSYM.INC, MSDOS 3.3, 1987) 
  1805                                  
  1806                                  OUTTILBUSY EQU	2000H		; OUTPUT UNTIL BUSY IS ENABLED
  1807                                  ISNET	   EQU	1000H		; BIT 12 - 1 IF A NET DEVICE, 0 IF
  1808                                  				;  NOT.  CURRENTLY BLOCK ONLY.
  1809                                  DEVOPCL    EQU	0800H		; BIT 11 - 1 IF THIS DEVICE HAS
  1810                                  				;  OPEN,CLOSE AND REMOVABLE MEDIA
  1811                                  				;  ENTRY POINTS, 0 IF NOT
  1812                                  
  1813                                  EXTENTBIT  EQU	0400H		; BIT 10 - CURRENTLY 0 ON ALL DEVS
  1814                                  				;  THIS BIT IS RESERVED FOR FUTURE USE
  1815                                  				;  TO EXTEND THE DEVICE HEADER BEYOND
  1816                                  				;  ITS CURRENT FORM.
  1817                                  
  1818                                  ; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
  1819                                  ;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
  1820                                  ;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
  1821                                  ;    MACHINES (FORMAT,CHKDSK,RECOVER,..).
  1822                                  
  1823                                  IOQUERY	EQU	0080H		;Bit 7 - Supports generic IOCtl query
  1824                                  
  1825                                  DEV320	EQU	0040H		;BIT 6 - FOR BLOCK DEVICES, THIS
  1826                                  				;DEVICE SUPPORTS SET/GET MAP OF
  1827                                  				;LOGICAL DRIVES, AND SUPPORTS
  1828                                  				;GENERIC IOCTL CALLS.
  1829                                  				;FOR CHARACTER DEVICES, THIS
  1830                                  				;DEVICE SUPPORTS GENERIC IOCTL.
  1831                                  				;THIS IS A DOS 3.2 DEVICE DRIVER.
  1832                                  
  1833                                  ISSPEC	EQU     0010H		;Bit 4 - This device is special ; 15/03/2018
  1834                                  ;ISIBM	EQU     0010H		;Bit 4 - This device is special
  1835                                  ISCLOCK EQU     0008H           ;Bit 3 - This device is the clock device.
  1836                                  ISNULL  EQU     0004H           ;Bit 2 - This device is the null device.
  1837                                  ISCOUT  EQU     0002H           ;Bit 1 - This device is the console output.
  1838                                  ISCIN   EQU     0001H           ;Bit 0 - This device is the console input.
  1839                                  
  1840                                  EXTDRVR	EQU	0002h		;BIT 1 - BLOCK DEVICE EXTENDED DRIVER
  1841                                  				; (MSDOS 6.0, DEVSYM.INC, 1991) ; 30/04/2019
  1842                                  
  1843                                  ;Static Reguest Header
  1844                                  struc	SRHEAD
  1845 00000000 ??                      .REQLEN:	resb 1		;Length in bytes of request block
  1846 00000001 ??                      .REQUNIT:	resb 1		;Device unit number
  1847 00000002 ??                      .REQFUNC:	resb 1		;Type of request
  1848 00000003 ????                    .REQSTAT:	resw 1		;Status Word
  1849 00000005 ????????????????                	resb 8		;Reserved for queue links
  1850                                  .size:
  1851                                  endstruc
  1852                                  
  1853                                  ;Status word masks
  1854                                  STERR   EQU     8000H           ;Bit 15 - Error
  1855                                  STBUI   EQU     0200H           ;Bit 9 - Buisy
  1856                                  STDON   EQU     0100H           ;Bit 8 - Done
  1857                                  STECODE EQU     00FFH           ;Error code
  1858                                  WRECODE EQU     0
  1859                                  
  1860                                  ;Function codes
  1861                                  DINITHL EQU     26              ;Size of init header
  1862                                  DMEDHL  EQU     15              ;Size of media check header
  1863                                  DBPBHL  EQU     22              ;Size of Get BPB header
  1864                                  DRDWRHL EQU     22              ;Size of RD/WR header
  1865                                  DRDNDHL EQU     14              ;Size of non destructive read header
  1866                                  DSTATHL EQU     13              ;Size of status header
  1867                                  DFLSHL  EQU     15              ;Size of flush header
  1868                                  
  1869                                  DEVINIT EQU     0               ;Initialization
  1870                                  DEVMDCH EQU     1               ;Media check
  1871                                  DEVBPB  EQU     2               ;Get BPB
  1872                                  DEVRDIOCTL EQU  3               ;IOCTL read
  1873                                  DEVRD   EQU     4               ;Read
  1874                                  DEVRDND EQU     5               ;Non destructive read no wait (character devs)
  1875                                  DEVIST  EQU     6               ;Input status
  1876                                  DEVIFL  EQU     7               ;Input flush
  1877                                  DEVWRT  EQU     8               ;Write
  1878                                  DEVWRTV EQU     9               ;Write with verify
  1879                                  DEVOST  EQU     10              ;Output status
  1880                                  DEVOFL  EQU     11              ;Output flush
  1881                                  DEVWRIOCTL EQU  12              ;IOCTL write
  1882                                  
  1883                                  ; 09/07/2018 - Retro DOS v3.0 (DEVSYM.INC, MSDOS 3.3, 1987) 
  1884                                  DEVOPN	EQU	13		;DEVICE OPEN
  1885                                  DEVCLS	EQU	14		;DEVICE CLOSE
  1886                                  DOPCLHL EQU	13		;SIZE OF OPEN/CLOSE HEADER
  1887                                  DEVRMD	EQU	15		;REMOVABLE MEDIA
  1888                                  ; 07/08/2018 - Retro DOS v3.0
  1889                                  REMHL	EQU	13		;SIZE OF REMOVABLE MEDIA HEADER
  1890                                  GENIOCTL EQU	19
  1891                                  
  1892                                  ; THE NEXT THREE ARE USED IN DOS 4.0
  1893                                  ;		     20
  1894                                  ;		     21
  1895                                  ;		     22
  1896                                  
  1897                                  DEVGETOWN      EQU   23		;GET DEVICE OWNER
  1898                                  DEVSETOWN      EQU   24		;SET DEVICE OWNER
  1899                                  ; 18/05/2019 - Retro DOS v4.0
  1900                                  IOCTL_QUERY    EQU   25		;Query generic ioctl support
  1901                                  
  1902                                  OWNHL	       EQU   13		;SIZE OF DEVICE OWNER HEADER
  1903                                  
  1904                                  DEVOUT	       EQU   16		; OUTPUT UNTIL BUSY.
  1905                                  DEVOUTL        EQU   DEVWRT	; LENGTH OF OUTPUT UNTIL BUSY
  1906                                  
  1907                                  ; ADDED FOR DOS 5.00
  1908                                  
  1909                                  ; GENERIC IOCTL REQUEST STRUCTURE
  1910                                  ;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
  1911                                  
  1912                                  struc IOCTL_REQ
  1913 00000000 <res Dh>                .SRHEAD:	resb SRHEAD.size
  1914                                  				; GENERIC IOCTL ADDITION.
  1915 0000000D ??                      .MAJORFUNCTION: resb 1		;FUNCTION CODE
  1916 0000000E ??                      .MINORFUNCTION: resb 1		;FUNCTION CATEGORY
  1917 0000000F ????                    .REG_SI:	resw 1
  1918 00000011 ????                    .REG_DI:	resw 1
  1919 00000013 ????????                .GENERICIOCTL_PACKET: resd 1	; POINTER TO DATA BUFFER
  1920                                  .size: ; 07/08/2018
  1921                                  endstruc
  1922                                  
  1923                                  ; DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
  1924                                  GEN_IOCTL_WRT_TRK EQU	40H
  1925                                  GEN_IOCTL_RD_TRK  EQU	60H
  1926                                  GEN_IOCTL_FN_TST  EQU	20H	; USED TO DIFF. BET READS AND WRTS
  1927                                  
  1928                                  ;; 32-bit absolute read/write input list structure
  1929                                  
  1930                                  struc ABS_32RW
  1931 00000000 ????????                .SECTOR_RBA:	resd 1		; relative block address
  1932 00000004 ????                    .ABS_RW_COUNT:	resw 1		; number of sectors to be transferred
  1933 00000006 ????????                .BUFFER_ADDR:	resd 1		; data addrress
  1934                                  .size:
  1935                                  endstruc
  1936                                  
  1937                                  ;; media ID info
  1938                                  
  1939                                  struc MEDIA_ID_INFO
  1940 00000000 ????                    .MEDIA_level:	resw	1	; info level
  1941 00000002 ????????                .MEDIA_Serial:	resd	1	; serial #
  1942 00000006 <res Bh>                .MEDIA_Label:	resb	11	; volume label
  1943 00000011 ????????????????        .MEDIA_System:	resb	8	; system type
  1944                                  .size:
  1945                                  endstruc
  1946                                  
  1947                                  ; equates for DOS34_FLAG
  1948                                  ; (BUGBUG: why are bits 0,1,3 and 4 not defined.)
  1949                                  
  1950                                  FROM_DISK_RESET       EQU   000000000100b   ;from disk reset
  1951                                  Force_I24_Fail	      EQU   000000100000b   ;form IFS CALL BACK
  1952                                  Disable_EOF_I24       EQU   000001000000b   ;disable EOF int24 for input status
  1953                                  DBCS_VOLID	      EQU   000010000000b   ;indicate from volume id
  1954                                  DBCS_VOLID2	      EQU   000100000000b   ;indicate 8th char is DBCS
  1955                                  CTRL_BREAK_FLAG       EQU   001000000000b   ;indicate control break is input
  1956                                  SEARCH_FASTOPEN       EQU   010000000000b   ;set fastopen flag for search
  1957                                  EXEC_AWARE_REDIR      EQU   100000000000b   ;M018: this bit is set by a redir 
  1958                                  					    ;M018: that knows how to handle 
  1959                                  					    ;M018: open for exec
  1960                                  
  1961                                  NO_FROM_DISK_RESET    EQU   ~FROM_DISK_RESET	;not from disk reset
  1962                                  NO_Force_I24_Fail     EQU   ~Force_I24_Fail	;not form IFS CALL BACK
  1963                                  NO_Disable_EOF_I24    EQU   ~Disable_EOF_I24
  1964                                  
  1965                                  ;============================================================================
  1966                                  ; ERROR.INC (MSDOS 6.0, 1991)
  1967                                  ;============================================================================
  1968                                  ; 16/07/2018 - Retro DOS v3.0 
  1969                                  
  1970                                  ;**	ERROR.INC - DOS Error Codes
  1971                                  ;
  1972                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
  1973                                  ;    return error codes through AX. If an error occurred then
  1974                                  ;    the carry bit will be set and the error code is in AX. If no error
  1975                                  ;    occurred then the carry bit is reset and AX contains returned info.
  1976                                  ;
  1977                                  ;    Since the set of error codes is being extended as we extend the operating
  1978                                  ;    system, we have provided a means for applications to ask the system for a
  1979                                  ;    recommended course of action when they receive an error.
  1980                                  ;
  1981                                  ;    The GetExtendedError system call returns a universal error, an error
  1982                                  ;    location and a recommended course of action. The universal error code is
  1983                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
  1984                                  ;    is issued.
  1985                                  
  1986                                  ;	2.0 error codes
  1987                                  
  1988                                  error_invalid_function		EQU	1
  1989                                  error_file_not_found		EQU	2
  1990                                  error_path_not_found		EQU	3
  1991                                  error_too_many_open_files	EQU	4
  1992                                  error_access_denied		EQU	5
  1993                                  error_invalid_handle		EQU	6
  1994                                  error_arena_trashed		EQU	7
  1995                                  error_not_enough_memory 	EQU	8
  1996                                  error_invalid_block		EQU	9
  1997                                  error_bad_environment		EQU	10
  1998                                  error_bad_format		EQU	11
  1999                                  error_invalid_access		EQU	12
  2000                                  error_invalid_data		EQU	13
  2001                                  ;**** reserved			EQU	14	; *****
  2002                                  error_invalid_drive		EQU	15
  2003                                  error_current_directory 	EQU	16
  2004                                  error_not_same_device		EQU	17
  2005                                  error_no_more_files		EQU	18
  2006                                  
  2007                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
  2008                                  
  2009                                  error_write_protect		EQU	19
  2010                                  error_bad_unit			EQU	20
  2011                                  error_not_ready 		EQU	21
  2012                                  error_bad_command		EQU	22
  2013                                  error_CRC			EQU	23
  2014                                  error_bad_length		EQU	24
  2015                                  error_seek			EQU	25
  2016                                  error_not_DOS_disk		EQU	26
  2017                                  error_sector_not_found		EQU	27
  2018                                  error_out_of_paper		EQU	28
  2019                                  error_write_fault		EQU	29
  2020                                  error_read_fault		EQU	30
  2021                                  error_gen_failure		EQU	31
  2022                                  
  2023                                  ;	the new 3.0 error codes reported through INT 24
  2024                                  
  2025                                  error_sharing_violation 	EQU	32
  2026                                  error_lock_violation		EQU	33
  2027                                  error_wrong_disk		EQU	34
  2028                                  error_FCB_unavailable		EQU	35
  2029                                  error_sharing_buffer_exceeded	EQU	36
  2030                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00  ;AN000;
  2031                                  error_handle_EOF		EQU	38    ; DOS 4.00  ;AN000;
  2032                                  error_handle_Disk_Full		EQU	39    ; DOS 4.00  ;AN000;
  2033                                  
  2034                                  ;	New OEM network-related errors are 50-79
  2035                                  
  2036                                  error_not_supported		EQU	50
  2037                                  
  2038                                  error_net_access_denied		EQU	65	;M028
  2039                                  
  2040                                  ;	End of INT 24 reportable errors
  2041                                  
  2042                                  error_file_exists		EQU	80
  2043                                  error_DUP_FCB			EQU	81	; *****
  2044                                  error_cannot_make		EQU	82
  2045                                  error_FAIL_I24			EQU	83
  2046                                  
  2047                                  ;	New 3.0 network related error codes
  2048                                  
  2049                                  error_out_of_structures 	EQU	84
  2050                                  error_already_assigned		EQU	85
  2051                                  error_invalid_password		EQU	86
  2052                                  error_invalid_parameter 	EQU	87
  2053                                  error_NET_write_fault		EQU	88
  2054                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00  ;AN000;
  2055                                  
  2056                                  ;	BREAK <Interrupt 24 error codes>
  2057                                  
  2058                                  ;**	Int24 Error Codes
  2059                                  
  2060                                  error_I24_write_protect 	EQU	0
  2061                                  error_I24_bad_unit		EQU	1
  2062                                  error_I24_not_ready		EQU	2
  2063                                  error_I24_bad_command		EQU	3
  2064                                  error_I24_CRC			EQU	4
  2065                                  error_I24_bad_length		EQU	5
  2066                                  error_I24_Seek			EQU	6
  2067                                  error_I24_not_DOS_disk		EQU	7
  2068                                  error_I24_sector_not_found	EQU	8
  2069                                  error_I24_out_of_paper		EQU	9
  2070                                  error_I24_write_fault		EQU	0Ah
  2071                                  error_I24_read_fault		EQU	0Bh
  2072                                  error_I24_gen_failure		EQU	0Ch
  2073                                  ; NOTE: Code 0DH is used by MT-DOS.
  2074                                  error_I24_wrong_disk		EQU	0Fh
  2075                                  
  2076                                  ;	THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24
  2077                                  ;
  2078                                  ;	NOTE: ABORT is ALWAYS allowed
  2079                                  
  2080                                  Allowed_FAIL			EQU	00001000B
  2081                                  Allowed_RETRY			EQU	00010000B
  2082                                  Allowed_IGNORE			EQU	00100000B
  2083                                  
  2084                                  I24_operation			EQU	00000001B  ;Z if READ,NZ if Write
  2085                                  I24_area			EQU	00000110B  ; 00 if DOS
  2086                                  						   ; 01 if FAT
  2087                                  						   ; 10 if root DIR
  2088                                  						   ; 11 if DATA
  2089                                  I24_class			EQU	10000000B  ;Z if DISK, NZ if FAT or char
  2090                                  
  2091                                  ;	BREAK <GetExtendedError CLASSes ACTIONs LOCUSs>
  2092                                  
  2093                                  ;**	The GetExtendedError call takes an error code and returns CLASS,
  2094                                  ;	ACTION and LOCUS codes to help programs determine the proper action
  2095                                  ;	to take for error codes that they don't explicitly understand.
  2096                                  
  2097                                  ;	Values for error CLASS
  2098                                  
  2099                                  errCLASS_OutRes 	EQU	1	; Out of Resource
  2100                                  errCLASS_TempSit	EQU	2	; Temporary Situation
  2101                                  errCLASS_Auth		EQU	3	; Permission problem
  2102                                  errCLASS_Intrn		EQU	4	; Internal System Error
  2103                                  errCLASS_HrdFail	EQU	5	; Hardware Failure
  2104                                  errCLASS_SysFail	EQU	6	; System Failure
  2105                                  errCLASS_Apperr 	EQU	7	; Application Error
  2106                                  errCLASS_NotFnd 	EQU	8	; Not Found
  2107                                  errCLASS_BadFmt 	EQU	9	; Bad Format
  2108                                  errCLASS_Locked 	EQU	10	; Locked
  2109                                  errCLASS_Media		EQU	11	; Media Failure
  2110                                  errCLASS_Already	EQU	12	; Collision with Existing Item
  2111                                  errCLASS_Unk		EQU	13	; Unknown/other
  2112                                  
  2113                                  ;	Values for error ACTION
  2114                                  
  2115                                  errACT_Retry		EQU	1	; Retry
  2116                                  errACT_DlyRet		EQU	2	; Delay Retry, retry after pause
  2117                                  errACT_User		EQU	3	; Ask user to regive info
  2118                                  errACT_Abort		EQU	4	; abort with clean up
  2119                                  errACT_Panic		EQU	5	; abort immediately
  2120                                  errACT_Ignore		EQU	6	; ignore
  2121                                  errACT_IntRet		EQU	7	; Retry after User Intervention
  2122                                  
  2123                                  ;	Values for error LOCUS
  2124                                  
  2125                                  errLOC_Unk		EQU	1	; No appropriate value
  2126                                  errLOC_Disk		EQU	2	; Random Access Mass Storage
  2127                                  errLOC_Net		EQU	3	; Network
  2128                                  errLOC_SerDev		EQU	4	; Serial Device
  2129                                  errLOC_Mem		EQU	5	; Memory
  2130                                  
  2131                                  ;============================================================================
  2132                                  ; INT2A.INC (MSDOS 6.0, 1991)
  2133                                  ;============================================================================
  2134                                  ; 04/05/2019 - Retro DOS v4.0
  2135                                  
  2136                                  ;**	Int 2A functions
  2137                                  ; ---------------------------------------------------------------------------
  2138                                  ;	Int 2A is an interface to the network code; it's also overloaded
  2139                                  ;		as a critical section handler since critical sections
  2140                                  ;		were originally created to support the net.
  2141                                  ; ---------------------------------------------------------------------------
  2142                                  
  2143                                  ; ---------------------------------------------------------------------------
  2144                                  ;**	This table was created by examining the source and may not be
  2145                                  ;	complete or completely accurate - JGL
  2146                                  ;
  2147                                  ;	M010	MD	8/31/90 - Added definition for AH = 5
  2148                                  
  2149                                  ;	(ah) = 0	installation check
  2150                                  ;			   (returns ah !=0 if installed)
  2151                                  ;	(ah) = 1	cooked net bios call
  2152                                  ;	(ah) = 3	query drive shared
  2153                                  ;			   (ds:si) = "n:" asciz string
  2154                                  ;	(ah) = 4	net bios
  2155                                  ;	       (al) = 0	   cooked net bios call
  2156                                  ;	       (al) = 1	   raw net bios call
  2157                                  ;	       (al) = 2	   ???
  2158                                  ;
  2159                                  ;	(ah) = 5	Get Net Adaptor Resources. CX returns the number of
  2160                                  ;			NCBs available/outstanding. DX returns the number of
  2161                                  ;			sessions. Supposedly, this is documented in an old
  2162                                  ;			IBM PC-LAN reference. Lotus Notes uses it. DOS LAN
  2163                                  ;			Manager 2.0 Enhanced responds to it. But it should
  2164                                  ;			not be used, as it is a hack, only to get Lotus
  2165                                  ;			Notes running.
  2166                                  ;
  2167                                  ;	(ah) = 80h	enter critical section
  2168                                  ;	(ah) = 81h	leave critical section
  2169                                  ;	(ah) = 82h	free all critical sections (Leave-all)
  2170                                  ;	(ah) = 84h	entering idle loop (don't understand how this works)
  2171                                  ; ---------------------------------------------------------------------------
  2172                                  
  2173                                  ;**	Critical section definitions
  2174                                  ; ---------------------------------------------------------------------------
  2175                                  ;	Although DOS is not designed to be reentrant there are some hacks
  2176                                  ;	which various programs use to make it so, in a limited fashion.
  2177                                  ;	Both WIN386 and some servers block copy a section of the DOS data
  2178                                  ;	area so that DOS can be reentered on behalf of another thread/program.
  2179                                  ;	DOS's global data structures, such as the memory arena, are not
  2180                                  ;	in this area, so critical section indicators are used to protect
  2181                                  ;	those areas.  DOS flags a critical section by issuing an INT_IBM
  2182                                  ;	(int 2Ah) at each critical section entry and exit.  Some clients
  2183                                  ;	(such as WIN386) just don't "context switch" the DOS when one
  2184                                  ;	of these is in effect, others, such as the IBM server, go ahead
  2185                                  ;	and reenter the DOS and if they get an int 2A to reenter the same
  2186                                  ;	critical section they then switch away from that second thread and
  2187                                  ;	let the first one finish and exit the section.
  2188                                  ; ---------------------------------------------------------------------------
  2189                                  
  2190                                  ; These below are subject to leave-all sections
  2191                                  critDisk    EQU     1			; Disk I/O critical section
  2192                                  critShare   EQU     1			; Sharer I/O critical section
  2193                                  critMem     EQU     1			; memory maintenance critical section
  2194                                  critSFT     EQU     1			; sft table allocation
  2195                                  critDevice  EQU     2			; Device I/O critical section
  2196                                  critNet     EQU     5			; network critical section
  2197                                  critIFS     EQU     6			; ifsfunc critical section
  2198                                  ; These below are not subject to leave-all sections
  2199                                  critASSIGN  EQU     8			; Assign has munged a system call
  2200                                  
  2201                                  ;============================================================================
  2202                                  ; MULT.INC (MSDOS 6.0, 1991)
  2203                                  ;============================================================================
  2204                                  ; 04/05/2019 - Retro DOS v4.0
  2205                                  
  2206                                  ;Break <Multiplex channels>
  2207                                  
  2208                                  ; ---------------------------------------------------------------------------
  2209                                  ; The current set of defined multiplex channels is (* means documented):
  2210                                  ;
  2211                                  ;   Channel(h)  Issuer          Receiver    Function
  2212                                  ;      00       server          PSPRINT     print job control
  2213                                  ;     *01       print/apps      PRINT       Queueing of files
  2214                                  ;      02       BIOS            REDIR       signal open/close of printers
  2215                                  ;
  2216                                  ;      05       command         REDIR       obtain text of net int 24 message
  2217                                  ;     *06       server/assign   ASSIGN      Install check
  2218                                  ;
  2219                                  ;      08       external driver IBMBIO      interface to internal routines
  2220                                  ;
  2221                                  ;      10       sharer/server   Sharer      install check
  2222                                  ;      11       DOS/server      Redir       install check/redirection funcs
  2223                                  ;      12       sharer/redir    DOS         dos functions and structure maint
  2224                                  ;      13       MSNET           MSNET       movement of NCBs
  2225                                  ;      13       external driver IBMBIO      Reset_Int_13, allows installation
  2226                                  ;                                           of alternative INT_13 drivers after
  2227                                  ;                                           boot_up
  2228                                  ;      14 (IBM) DOS             NLSFUNC     down load NLS country info,DOS 3.3
  2229                                  ;      14 (MS)  APPS            POPUP       MSDOS 4 popup screen functions
  2230                                  ;      15       APPS            MSCDEX      CD-ROM extensions interface
  2231                                  ;      16       WIN386          WIN386      Windows communications
  2232                                  ;      17       Clipboard       WINDOWS     Clipboard interface
  2233                                  ;     *18       Applications    MS-Manger   Toggle interface to manager
  2234                                  ;      19       Shell
  2235                                  ;      1A       Ansi.sys
  2236                                  ;      1B       Fastopen,Vdisk   IBMBIO     EMS INT 67H stub handler
  2237                                  ;
  2238                                  ;      40h      OS/2
  2239                                  ;      41h      Lanman
  2240                                  ;      42h      Lanman
  2241                                  ;      43h      Himem
  2242                                  ;                               AL = 20h    reserved for Mach 20 Himem support
  2243                                  ;                               AL = 30h    reserved for Himem external A20 code
  2244                                  ;      44h      Dosextender
  2245                                  ;      45H      Windows profiler
  2246                                  ;      46h      Windows/286 DOS extender
  2247                                  ;      47h      Basic Compiler Vn. 7.0
  2248                                  ;      48h      Doskey
  2249                                  ;      49h      DOS 5.x install 
  2250                                  ;      4Ah      Multi Purpose
  2251                                  ;                multMULTSWPDSK         0 - Swap Disk in drive A (BIOS)
  2252                                  ;                multMULTGETHMAPTR      1 - Get available HMA & ptr
  2253                                  ;                multMULTALLOCHMA       2 - Allocate HMA (bx == no of bytes)
  2254                                  ;                multMULTTASKSHELL      5 - Shell/switcher API
  2255                                  ;                multMULTRPLTOM         6 - Top Of Memory for RPL support
  2256                                  ;
  2257                                  ;                multSmartdrv           10h
  2258                                  ;                multMagicdrv           11h
  2259                                  ;      4Bh      Task Switcher API
  2260                                  ;
  2261                                  ;      4Ch      APPS            APM         Advanced power management
  2262                                  ;      4Dh      Kana Kanji Converter, MSKK
  2263                                  ;
  2264                                  ;      51h      ODI real mode support driver (for Chicago)
  2265                                  ;
  2266                                  ;      53h      POWER.EXE - used for broadcasting APM events    ; M036
  2267                                  ;      54h      POWER.EXE - used for POWER API                  ; M036
  2268                                  ;
  2269                                  ;      55h      COMMAND.COM
  2270                                  ;                multCOMFIRST           0 - API to determine whether 1st
  2271                                  ;                                           instance of command.com
  2272                                  ;                multCOMFIRSTROM        1 - API to determine whether 1st
  2273                                  ;                                           instance of ROM COMMAND
  2274                                  ;      56h      Sewell Development
  2275                                  ;               INTERLNK
  2276                                  ;
  2277                                  ;      57h      Iomega Corp.
  2278                                  ;
  2279                                  ;      ABh      Unspecified IBM use
  2280                                  ;      ACh      Graphics
  2281                                  ;      ADh      NLS (toronto)
  2282                                  ;      AEh
  2283                                  ;      AFh      Mode
  2284                                  ;      B0h      GRAFTABL        GRAFTABL
  2285                                  ;
  2286                                  ;      D7h      Banyan VINES
  2287                                  ; ---------------------------------------------------------------------------
  2288                                  
  2289                                  ;MUX 00-3F reserverd for IBM
  2290                                  ;MUX 80-BF reserverd for IBM
  2291                                  
  2292                                  ;MUX 40-7F reserved for Microsoft
  2293                                  
  2294                                  ;MUX C0-FF users
  2295                                  
  2296                                  MultSHARE   EQU     10h 		; sharer
  2297                                      ;	1   MFT_enter
  2298                                      ;	2   MFTClose
  2299                                      ;	3   MFTclU
  2300                                      ;	4   MFTCloseP
  2301                                      ;	5   MFTCloN
  2302                                      ;	6   set_block
  2303                                      ;	7   clr_block
  2304                                      ;	8   chk_block
  2305                                      ;	9   MFT_get
  2306                                      ;	10  ShSave
  2307                                      ;	11  ShChk
  2308                                      ;	12  ShCol
  2309                                      ;	13  ShCloseFile
  2310                                  
  2311                                  MultNET     EQU     11h 		; Network support
  2312                                  MultIFS     EQU     11h                 ; Network support
  2313                                      ;   1   IFS_RMDIR
  2314                                      ;   2   IFS_SEQ_RMDIR
  2315                                      ;   3   IFS_MKDIR
  2316                                      ;   4   IFS_SEQ_MKDIR
  2317                                      ;   5   IFS_CHDIR
  2318                                      ;   6   IFS_CLOSE
  2319                                      ;   7   IFS_COMMIT
  2320                                      ;   8   IFS_READ
  2321                                      ;   9   IFS_WRITE
  2322                                      ;   10  IFS_LOCK
  2323                                      ;   11  IFS_UNLOCK
  2324                                      ;   12  IFS_DISK_INFO
  2325                                      ;   13  IFS_SET_FILE_ATTRIBUTE
  2326                                      ;   14  IFS_SEQ_SET_FILE_ATTRIBUTE
  2327                                      ;   15  IFS_GET_FILE_INFO
  2328                                      ;   16  IFS_SEQ_GET_FILE_INFO
  2329                                      ;   17  IFS_RENAME
  2330                                      ;   18  IFS_SEQ_RENAME
  2331                                      ;   19  IFS_DELETE
  2332                                      ;   20  IFS_SEQ_DELETE
  2333                                      ;   21  IFS_OPEN
  2334                                      ;   22  IFS_SEQ_OPEN
  2335                                      ;   23  IFS_CREATE
  2336                                      ;   24  IFS_SEQ_CREATE
  2337                                      ;   25  IFS_SEQ_SEARCH_FIRST
  2338                                      ;   26  IFS_SEQ_SEARCH_NEXT
  2339                                      ;   27  IFS_SEARCH_FIRST
  2340                                      ;   28  IFS_SEARCH_NEXT
  2341                                      ;   29  IFS_ABORT
  2342                                      ;   30  IFS_ASSOPER
  2343                                      ;   31  Printer_SET_STRING
  2344                                      ;   32  IFSFlushBuf
  2345                                      ;   33  IFSBufWrite
  2346                                      ;   34  IFSResetEnvironment
  2347                                      ;   35  IFSSpoolCheck
  2348                                      ;   36  IFSSpoolClose
  2349                                      ;   37  IFSDeviceOper
  2350                                      ;   38  IFSSpoolEchoCheck
  2351                                      ;   39      - - -   Unused   - - -
  2352                                      ;   40      - - -   Unused   - - -
  2353                                      ;   41      - - -   Unused   - - -
  2354                                      ;   42  SERVER_DOSCALL_CLOSEFILES_FOR_UID
  2355                                      ;   43  DEVICE_IOCTL
  2356                                      ;   44  IFS_UPDATE_CB
  2357                                      ;   45  IFS_FILE_XATTRIBUTES
  2358                                      ;   46  IFS_XOPEN
  2359                                      ;   47  IFS_DEPENDENT_IOCTL
  2360                                  
  2361                                  MultDOS     EQU     12h 		; DOS call back
  2362                                      ;	1   DOS_CLOSE
  2363                                      ;	2   RECSET
  2364                                      ;	3   Get DOSGROUP
  2365                                      ;	4   PATHCHRCMP
  2366                                      ;	5   OUT
  2367                                      ;	6   NET_I24_ENTRY
  2368                                      ;	7   PLACEBUF
  2369                                      ;	8   FREE_SFT
  2370                                      ;	9   BUFWRITE
  2371                                      ;	10  SHARE_VIOLATION
  2372                                      ;	11  SHARE_ERROR
  2373                                      ;	12  SET_SFT_MODE
  2374                                      ;	13  DATE16
  2375                                      ;	14  SETVISIT
  2376                                      ;	15  SCANPLACE
  2377                                      ;	16  SKIPVISIT
  2378                                      ;	17  StrCpy
  2379                                      ;	18  StrLen
  2380                                      ;	19  UCase
  2381                                      ;	20  POINTCOMP
  2382                                      ;	21  CHECKFLUSH
  2383                                      ;	22  SFFromSFN
  2384                                      ;	23  GetCDSFromDrv
  2385                                      ;	24  Get_User_Stack
  2386                                      ;	25  GetThisDrv
  2387                                      ;	26  DriveFromText
  2388                                      ;	27  SETYEAR
  2389                                      ;	28  DSUM
  2390                                      ;	29  DSLIDE
  2391                                      ;	30  StrCmp
  2392                                      ;	31  initcds
  2393                                      ;	32  pjfnfromhandle
  2394                                      ;	33  $NameTrans
  2395                                      ;	34  CAL_LK
  2396                                      ;	35  DEVNAME
  2397                                      ;	36  Idle
  2398                                      ;   37  DStrLen
  2399                                      ;   38  NLS_OPEN      DOS 3.3
  2400                                      ;   39  $CLOSE        DOS 3.3
  2401                                      ;   40  NLS_LSEEK     DOS 3.3
  2402                                      ;   41  $READ         DOS 3.3
  2403                                      ;   42  FastInit      DOS 4.0
  2404                                      ;   43  NLS_IOCTL     DOS 3.3
  2405                                      ;   44  GetDevList    DOS 3.3
  2406                                      ;   45  NLS_GETEXT    DOS 3.3
  2407                                      ;   46  MSG_RETRIEVAL DOS 4.0
  2408                                      ;   47  FAKE_VERSION  DOS 4.0
  2409                                  
  2410                                  NLSFUNC     EQU     14h 		; NLSFUNC CALL , DOS 3.3
  2411                                      ;	0   NLSInstall
  2412                                      ;	1   ChgCodePage
  2413                                      ;	2   GetExtInfo
  2414                                      ;	3   SetCodePage
  2415                                      ;	4   GetCntry
  2416                                  
  2417                                  multANSI    EQU     1Ah                 ; ANSI multiplex number
  2418                                      ;   0   INSTALL_CHECK               ; install check for ANSI
  2419                                      ;   1   IOCTL_2F                    ; 2F interface to IOCTL
  2420                                      ;   2   DA_INFO_2F                  ; J.K. Information passing to ANSI.
  2421                                  
  2422                                  multMULT        EQU     4Ah
  2423                                  multMAGIC       EQU     256*multMULT + 11h
  2424                                  multMULTRPLTOM  EQU     06h
  2425                                  
  2426                                      ;   0   swap disk function for single floppy drive m/cs
  2427                                      ;       BIOS broadcasts with cx==0, and apps who handle
  2428                                      ;       swap disk messaging set cx == -1. BIOS sets dl == requested
  2429                                      ;       drive
  2430                                      ;
  2431                                      ;   1   Get available HMA & pointer to it. Returns in BX & ES:DI
  2432                                      ;   2   Allocate HMA. BX == number of bytes in HMA to be allocated
  2433                                      ;       returns pointer in ES:DI
  2434                                      ;
  2435                                      ;   3-4 currently used by nobody
  2436                                      ;   5   Switcher API
  2437                                      ;   6   Top of Memory for RPL.
  2438                                      ;           BIOS issues INT 2f AX=4a06 & DX = Top of Mem and any RPL
  2439                                      ;           code present in TOM should respond with a new TOM in DX
  2440                                      ;           to protect itself from MSLOAD & SYSINIT tromping over it.
  2441                                      ;           SYSINIT builds an arena with owner type 8 & name 'RPL' to
  2442                                      ;           protect the RPL code from COMMAND.COM transient protion.
  2443                                      ;           It is the responsibility of RPL program to release the mem.
  2444                                      ;   7   Reserved for PROTMAN support.
  2445                                      ;  10   smartdrv 4.0
  2446                                      ;  11   dblspace api
  2447                                      ;  12   MRCI     api
  2448                                      ;  13   dblspace/mrci stealth packet api
  2449                                  
  2450                                  MultAPM     EQU     4ch             ; Obselete ???
  2451                                      ;       00h     APM_VER_CHK
  2452                                      ;       01h     APM_SUS_SYS_REQ
  2453                                      ;       FFh     APM_SUS_RES_BATT_NOTIFY
  2454                                  
  2455                                  MultPWR_BRDCST  EQU     53h     ; Used by POWER.EXE to broadcast      ; M036
  2456                                  				;  APM events                         ; M036
  2457                                  MultPWR_API     EQU     54h     ; Used for accessing POWER.EXE's API  ; M036
  2458                                  
  2459                                  ;FASTOPEN is not chained through INT 2F   ; DOS 3.3 F.C.
  2460                                  ;	  it calls Multdos 42 to set up an entry routine address
  2461                                      ;	0   Install status  (reserved)
  2462                                      ;	1   Lookup
  2463                                      ;	2   Insert
  2464                                      ;	3   Delete
  2465                                      ;	4   Purge	    (reserved)
  2466                                  
  2467                                  ;============================================================================
  2468                                  ; FIND.INC (MSDOS 6.0, 1991)
  2469                                  ;============================================================================
  2470                                  ; 17/05/2019 - Retro DOS v4.0
  2471                                  ; 09/07/2018 - Retro DOS v3.0 (MSDOS 3.3, 1987)
  2472                                  
  2473                                  ;Break	<find first/next buffer>
  2474                                  
  2475                                  struc find_buf
  2476 00000000 ??                      .drive:	    resb 1		; drive of search
  2477 00000001 <res Bh>                .name:	    resb 11		; formatted name
  2478 0000000C ??                      .sattr:	    resb 1		; attribute of search
  2479 0000000D ????                    .LastEnt:   resw 1		; LastEnt
  2480 0000000F ????                    .DirStart:  resw 1		; DirStart
  2481 00000011 ????????                .NETID:	    resb 4 ; MSDOS 6.0 	; Reserved for NET
  2482 00000015 ??                      .attr:	    resb 1		; attribute found
  2483 00000016 ????                    .time:	    resw 1		; time
  2484 00000018 ????                    .date:	    resw 1		; date
  2485 0000001A ????                    .size_l:    resw 1		; low(size)
  2486 0000001C ????                    .size_h:    resw 1		; high(size)
  2487 0000001E <res Dh>                .pname:	    resb 13		; packed name
  2488                                  .size:
  2489                                  endstruc
  2490                                  
  2491                                  ;============================================================================
  2492                                  ; DOSCNTRY.INC (MSDOS 6.0, 1991)
  2493                                  ;============================================================================
  2494                                  ; 29/04/2019 - Retro DOS v4.0
  2495                                  ; 09/07/2018 - Retro DOS v3.0 (MSDOS 3.3, 1987)
  2496                                  
  2497                                  ;Equates for COUNTRY INFORMATION.
  2498                                  SetCountryInfo	EQU	1	;country info
  2499                                  SetUcase	EQU	2	;uppercase table
  2500                                  SetLcase	EQU	3	;lowercase table (Reserved)
  2501                                  SetUcaseFile	EQU	4	;uppercase file spec table
  2502                                  SetFileList	EQU	5	;valid file character list
  2503                                  SetCollate	EQU	6	;collating sequence
  2504                                  SetDBCS 	EQU	7	;double byte character set
  2505                                  SetALL		EQU	-1	;all the entries
  2506                                  
  2507                                  ;DOS country and code page information table structure.
  2508                                  ;Internally, IBMDOS gives a pointer to this table.
  2509                                  ;IBMBIO, MODE and NLSFUNC modules communicate with IBMDOS through
  2510                                  ;this structure.
  2511                                  
  2512                                  struc  DOS_CCDPG	; DOS_country_cdpg_info
  2513 00000000 ????????????????        .ccInfo_reserved: 	resb 8	;reserved for internal use
  2514 00000008 <res 40h>               .ccPath_CountrySys:	resb 64 ;path and filename for country info
  2515 00000048 ????                    .ccSysCodePage:		resw 1	;system code page id
  2516 0000004A ????                    .ccNumber_of_entries:	resw 1  ; (default value = 6)
  2517 0000004C ??                      .ccSetUcase:		resb 1  ; (default value = SetUcase)
  2518 0000004D ????????                .ccUcase_ptr:		resd 1	;pointer to Ucase table
  2519                                  
  2520 00000051 ??                      .ccSetUcaseFile:	resb 1	; (default value = SetUcaseFile)
  2521 00000052 ????????                .ccFileUcase_ptr: 	resd 1	;pointer to File Ucase table
  2522                                  
  2523 00000056 ??                      .ccSetFileList:		resb 1 	; (default value = SetFileList)
  2524 00000057 ????????                .ccFileChar_ptr:	resd 1	;pointer to File char list table
  2525                                  
  2526 0000005B ??                      .ccSetCollate:		resb 1	; (default value = SetCollate)
  2527 0000005C ????????                .ccCollate_ptr:		resd 1	;pointer to collate table
  2528                                  
  2529                                  ; MSDOS 6.0
  2530 00000060 ??                      .ccSetDBCS:		resb 1	; (default value = SetDBCS)
  2531 00000061 ????????                .ccDBCS_ptr:		resd 1	; pointer to DBCS table
  2532                                  
  2533 00000065 ??                      .ccSetCountryInfo:	resb 1  ; (default value = SetCountryInfo)
  2534 00000066 ????                    .ccCountryInfoLen:	resw 1	;length of country info
  2535 00000068 ????                    .ccDosCountry:		resw 1	;system country code id
  2536 0000006A ????                    .ccDosCodePage:		resw 1	;system code page id
  2537 0000006C ????                    .ccDFormat:		resw 1	;date format
  2538 0000006E ??????????              .ccCurSymbol:		resb 5	;5 byte of (currency symbol+0)
  2539 00000073 ????                    .cc1000Sep:		resb 2	;2 byte of (1000 sep. + 0)
  2540 00000075 ????                    .ccDecSep:		resb 2	;2 byte of (Decimal sep. + 0)
  2541 00000077 ????                    .ccDateSep:		resb 2	;2 byte of (date sep. + 0)
  2542 00000079 ????                    .ccTimeSep:		resb 2	;2 byte of (time sep. + 0)
  2543 0000007B ??                      .ccCFormat:		resb 1	;currency format flags
  2544 0000007C ??                      .ccCSigDigits:		resb 1	;# of digits in currency
  2545 0000007D ??                      .ccTFormat:		resb 1	;time format
  2546 0000007E ????????                .ccMono_ptr:		resd 1	;monocase routine entry point
  2547 00000082 ????                    .ccListSep:		resb 2	;data list separator
  2548 00000084 <res Ah>                .ccReserved_area: 	resw 5	;reserved
  2549                                  .size:
  2550                                  endstruc
  2551                                  
  2552                                  ;Ucase table
  2553                                  struc CC_UCASE_TAB
  2554 00000000 ????                    .ccUcase_leng:		resw 1	; (default value = 128)
  2555 00000002 <res 80h>               .ccUcase_data:		resb 128
  2556                                  endstruc
  2557                                  
  2558                                  ;File Ucase table
  2559                                  struc CC_FILE_UCASE_TAB
  2560 00000000 ????                    .ccFileucase_leng:	resw 1	; (default value = 128)
  2561 00000002 <res 80h>               .ccFileucase_data:	resb 128
  2562                                  endstruc
  2563                                  
  2564                                  ;File char list
  2565                                  struc CC_FILE_CHAR_TAB
  2566 00000000 ????                    .ccFilechar_leng:	resw 1
  2567 00000002 <res 2Eh>               .ccFilechar_data:	resb 46
  2568                                  endstruc
  2569                                  
  2570                                  ;collate table
  2571                                  struc CC_COLLATE_TAB
  2572 00000000 ????                    .ccCollate_leng:	resw 1	; (default value = 128)
  2573 00000002 <res 100h>              .ccCollate_data:	resb 256
  2574                                  endstruc
  2575                                  
  2576                                  OLD_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDFormat - 10)
  2577                                  NEW_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDosCountry) ; 38
  2578                                  
  2579                                  ; 06/08/2018
  2580                                  ; DOSCNTRY.INC (MSDOS 6.0, 1991)
  2581                                  
  2582                                  ;CAPITALIZATION equates
  2583                                  CAP_ONE_CHAR	equ	20H
  2584                                  CAP_STRING	equ	21H
  2585                                  CAP_ASCIIZ	equ	22H
  2586                                  CHECK_YES_NO	equ	23H
  2587                                  UPPER_TABLE	equ	80H
  2588                                  
  2589                                  ;NLS_YES	equ	59H  ; 'Y'
  2590                                  ;NLS_yes2	equ	79H  ; 'y' 	
  2591                                  ;NLS_NO		equ	4EH  ; 'N'	
  2592                                  ;NLS_no2	equ	6EH  ; 'n'	
  2593                                  
  2594                                  ;============================================================================
  2595                                  ; CURDIR.INC (MSDOS 6.0, 1991)
  2596                                  ;============================================================================
  2597                                  ; 25/04/2019 - Retro DOS v4.0
  2598                                  ; 09/07/2018 - Retro DOS v3.0 (CURDIR.INC, MSDOS 3.3, 1987)
  2599                                  
  2600                                  ;BREAK <Current directory list structure>
  2601                                  
  2602                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2603                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2604                                  ;									   ;
  2605                                  ; CDS items are used bu the internal routines to store cluster numbers and ;
  2606                                  ; network identifiers for each logical name.  The ID field is used dually, ;
  2607                                  ; both as net ID and for a cluster number for local devices.  In the case  ;
  2608                                  ; of local devices, the cluster number will be -1 if there is a potential  ;
  2609                                  ; of the disk being changed or if the path must be recracked.		   ;
  2610                                  ;
  2611                                  ;	Some pathnames have special preambles, such as
  2612                                  ;
  2613                                  ;		\\machine\sharename\...
  2614                                  ;	For these pathnames we can't allow ".." processing to back us
  2615                                  ;	up into the special front part of the name.  The CURDIR_END field
  2616                                  ;	holds the address of the seperator character which marks
  2617                                  ;	the split between the special preamble and the regular
  2618                                  ;	path list; ".." processing isn't allowed to back us up past
  2619                                  ;	(i.e., before) CURDIR_END
  2620                                  ;	For the root, it points at the leading /.  For net
  2621                                  ;	assignments it points at the end (nul) of the initial assignment:
  2622                                  ;	A:/	\\foo\bar	    \\foo\bar\blech\bozo
  2623                                  ;	  ^		 ^		     ^
  2624                                  
  2625                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
  2626                                  TEMPLEN 	EQU	DIRSTRLEN*2
  2627                                  
  2628                                  struc curdir	; curdir_list
  2629 00000000 <res 43h>               .text:		resb DIRSTRLEN		; text of assignment and curdir
  2630 00000043 ????                    .flags:		resw 1			; various flags
  2631 00000045 ????????                .devptr:	resd 1			; local pointer to DPB or net device
  2632 00000049 ????????                .ID:		resw 2			; cluster of current dir (net ID)
  2633 0000004D ????                    .user_word:	resw 1
  2634 0000004F ????                    .end:		resw 1			; index to ".." backup limit - see above
  2635                                  ; MSDOS 6.0
  2636 00000051 ??                      .type:		resb 1			; IFS drive (2=ifs, 4=netuse)
  2637 00000052 ????????                .ifs_hdr:	resd 1			; Ptr to File System Header
  2638 00000056 ????                    .fsda:		resb 2			; File System Dependent Data Area
  2639                                  .size:
  2640                                  endstruc
  2641                                  
  2642                                  curdirLen	EQU curdir.size	; 88	; Needed for screwed up
  2643                                  
  2644                                  %define curdir_netID curdir_ID  ; dword
  2645                                  
  2646                                  ;**	Flag values for CURDIR_FLAGS
  2647                                  
  2648                                  curdir_isnet	EQU	1000000000000000B
  2649                                  CURDIR_isifs	EQU	1000000000000000B ; MSDOS 6.0	
  2650                                  curdir_inuse	EQU	0100000000000000B
  2651                                  curdir_splice	EQU	0010000000000000B
  2652                                  curdir_local	EQU	0001000000000000B
  2653                                  
  2654                                  ;									   ;
  2655                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2656                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2657                                  
  2658                                  ;============================================================================
  2659                                  ; CPMFCB.INC (MSDOS 3.3, 1987)
  2660                                  ;============================================================================
  2661                                  ; 09/07/2018 - Retro DOS v3.0
  2662                                  
  2663                                  ;BREAK <File Control Block definition>
  2664                                  
  2665                                  ;
  2666                                  ; Field definition for FCBs
  2667                                  ; The FCB has the following structure:
  2668                                  ;
  2669                                  ;	+---------------------------+
  2670                                  ;	|   Drive indicator(byte)   |
  2671                                  ;	+---------------------------+
  2672                                  ;	|    Filename (8 chars)     |
  2673                                  ;	+---------------------------+
  2674                                  ;	|    Extension (3 chars)    |
  2675                                  ;	+---------------------------+
  2676                                  ;	|   Current Extent(word)    |
  2677                                  ;	+---------------------------+
  2678                                  ;	|    Record size (word)     |
  2679                                  ;	+---------------------------+
  2680                                  ;	|    File Size (2 words)    |
  2681                                  ;	+---------------------------+
  2682                                  ;	|	Date of write	    |
  2683                                  ;	+---------------------------+
  2684                                  ;	|	Time of write	    |
  2685                                  ;	+---------------------------+
  2686                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2687                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2688                                  ;									   ;
  2689                                  ;	+---------------------------+
  2690                                  ;	|   8 bytes reserved	    |
  2691                                  ;	+---------------------------+
  2692                                  ;									   ;
  2693                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2694                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2695                                  ;	|    next record number     |
  2696                                  ;	+---------------------------+
  2697                                  ;	|   random record number    |
  2698                                  ;	+---------------------------+
  2699                                  ;
  2700                                  
  2701                                  struc	SYS_FCB
  2702 00000000 ??                      .drive:	resb 1
  2703 00000001 ????????????????        .name:	resb 8
  2704 00000009 ??????                  .ext:	resb 3
  2705 0000000C ????                    .EXTENT: resw 1
  2706 0000000E ????                    .RECSIZ: resw 1			; Size of record (user settable)
  2707 00000010 ????                    .FILSIZ: resw 1			; Size of file in bytes; used with the
  2708                                  				; following word
  2709 00000012 ????                    .DRVBP:	resw 1			; BP for SEARCH FIRST and SEARCH NEXT
  2710 00000014 ????                    .FDATE:	resw 1			; Date of last writing
  2711 00000016 ????                    .FTIME:	resw 1			; Time of last writing
  2712                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2713                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2714                                  ;									   ;
  2715 00000018 ????????????????        .reserved: resb 8		; RESERVED
  2716                                  ;									   ;
  2717                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2718                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2719 00000020 ??                      .NR:	resb 1			; Next record
  2720 00000021 ????????                .RR:	resb 4			; Random record
  2721                                  .size:
  2722                                  endstruc
  2723                                  
  2724                                  FILDIRENT EQU SYS_FCB.FILSIZ	; Used only by SEARCH FIRST and SEARCH
  2725                                  				; NEXT
  2726                                  ; 20/07/2018
  2727                                  %define fcb_sfn	SYS_FCB.reserved ; byte
  2728                                  
  2729                                  ; Note that fcb_net_handle, fcb_nsl_drive, fcb_nsld_drive and fcb_l_drive
  2730                                  ; all must point to the same byte.  Otherwise, the FCBRegen will fail.
  2731                                  ; NOTE about this byte (fcb_nsl_drive)
  2732                                  ;   The high two bits of this byte are used as follows to indicate the FCB type
  2733                                  ;	00 means a local file or device with sharing loaded
  2734                                  ;	10 means a remote (network) file
  2735                                  ;	01 means a local file with no sharing loaded
  2736                                  ;	11 means a local device with no sharing loaded
  2737                                  
  2738                                  ; 20/07/2018
  2739                                  
  2740                                  ;
  2741                                  ; Network FCB
  2742                                  ;
  2743                                  
  2744                                  %define fcb_net_drive	SYS_FCB.reserved+1  ; byte
  2745                                  %define fcb_net_handle	SYS_FCB.reserved+2  ; word
  2746                                  %define fcb_netID	SYS_FCB.reserved+4  ; dword		
  2747                                  
  2748                                  ;
  2749                                  ; No sharing local file FCB
  2750                                  ;
  2751                                  
  2752                                  %define fcb_nsl_drive	SYS_FCB.reserved+1  ; byte
  2753                                  %define fcb_nsl_bits	SYS_FCB.reserved+2  ; byte	
  2754                                  %define fcb_nsl_firclus SYS_FCB.reserved+3  ; word	
  2755                                  %define fcb_nsl_dirsec	SYS_FCB.reserved+5  ; word
  2756                                  %define fcb_nsl_dirpos  SYS_FCB.reserved+7  ; byte
  2757                                  
  2758                                  ;
  2759                                  ; No sharing local device FCB
  2760                                  ;
  2761                                  
  2762                                  %define fcb_nsld_drive	SYS_FCB.reserved+1  ; byte	
  2763                                  %define fcb_nsld_drvptr SYS_FCB.reserved+2  ; dword
  2764                                  
  2765                                  ;
  2766                                  ; Sharing local FCB
  2767                                  ;
  2768                                  
  2769                                  %define fcb_l_drive	SYS_FCB.reserved+1  ; byte
  2770                                  %define fcb_l_firclus	SYS_FCB.reserved+2  ; word
  2771                                  %define fcb_l_mfs	SYS_FCB.reserved+4  ; word
  2772                                  %define fcb_l_attr	SYS_FCB.reserved+6  ; byte
  2773                                  
  2774                                  ;
  2775                                  ; Bogusness:  the four cases are:
  2776                                  ;
  2777                                  ;   local file	    00
  2778                                  ;   local device    40
  2779                                  ;   local sharing   C0
  2780                                  ;   network	    80
  2781                                  ;
  2782                                  ; Since sharing and network collide, we cannot use a test instruction for
  2783                                  ; deciding whether a network or a share check in involved
  2784                                  ;
  2785                                  FCBDEVICE   EQU 040h
  2786                                  FCBNETWORK  EQU 080h
  2787                                  FCBSHARE    EQU 0C0h
  2788                                  
  2789                                  ; FCBSPECIAL must be able to mask off both net and share
  2790                                  FCBSPECIAL  EQU 080h
  2791                                  FCBMASK     EQU 0C0h
  2792                                  
  2793                                  ;============================================================================
  2794                                  ; FASTOPEN.INC, MSDOS 6.0, 1991
  2795                                  ;============================================================================
  2796                                  ; 11/07/2018 - Retro DOS v3.0
  2797                                  ; 25/04/2019 - Retro DOS v4.0
  2798                                  
  2799                                  struc FEI	; FASTOPEN_EXTENDED_INFO
  2800 00000000 ??                      .dirpos:	resb 1
  2801 00000001 ????????                .dirsec:	resd 1 ; MSDOS 6.0
  2802                                  ;.dirsec:	resw 1 ; MSDOS 3.3
  2803 00000005 ????                    .clusnum:	resw 1
  2804 00000007 ????                    .lastent:	resw 1	; for search first ; MSDOS 6.0
  2805 00000009 ????                    .dirstart:	resw 1	; for search first ; MSDOS 6.0
  2806                                  .size:
  2807                                  endstruc
  2808                                  
  2809                                  ; 23/07/2018
  2810                                  ;FASTOPEN NAME CACHING Subfunctions
  2811                                  FONC_Look_up	equ	1
  2812                                  FONC_insert	equ	2
  2813                                  FONC_delete	equ	3
  2814                                  FONC_update	equ	4
  2815                                  FONC_purge	equ	5	;reserved for the future use.
  2816                                  FONC_Rename	equ	6	;AN001
  2817                                  
  2818                                  ; 27/07/2018
  2819                                  ;FastOpen Data Structure
  2820                                  struc fastopen_entry	;Fastopen Entry pointer in DOS
  2821 00000000 ????                    .entry_size:	resw 1	; = 4	; size of the following
  2822 00000002 ????????                .name_caching:	resd 1
  2823                                  ; MSDOS 6.0
  2824                                  ;.fatchain_caching: resd 1	;reserved for future use
  2825                                  .size:
  2826                                  endstruc
  2827                                  
  2828                                  ; 27/07/2018
  2829                                  ;Equates used in DOS.
  2830                                  FastOpen_Set	       equ     00000001b
  2831                                  FastOpen_Reset	       equ     11111110b
  2832                                  Lookup_Success	       equ     00000010b
  2833                                  Lookup_Reset	       equ     11111101b
  2834                                  Special_Fill_Set       equ     00000100b
  2835                                  Special_Fill_Reset     equ     11111011b
  2836                                  No_Lookup	       equ     00001000b
  2837                                  Set_For_Search	       equ     00010000b	;DCR 167
  2838                                  
  2839                                  ; 09/08/2018 
  2840                                  ; (FASTXXXX.INC, MSDOS 6.0, 1991)
  2841                                  ; Fastxxx equates
  2842                                  FastOpen_ID	   equ	   1
  2843                                  FastSeek_ID	   equ	   2
  2844                                  Fast_yes	   equ	   10000000B	 ; fastxxx flag
  2845                                  
  2846                                  ;Structure definitions
  2847                                  ;
  2848                                  struc Fasttable_Entry	 ; Fastxxx  Entry pointer in DOS
  2849 00000000 ????                    .Fast_Entry_Num: resw 1	 ; number of entries
  2850 00000002 ????????                .FastOpen_Seek:	 resd 1	 ; fastopen & fastseek entry address
  2851                                  endstruc
  2852                                  
  2853                                  ;============================================================================
  2854                                  ; LOCK.INC, MSDOS 6.0, 1991
  2855                                  ;============================================================================
  2856                                  ; 14/07/2018 - Retro DOS v3.0
  2857                                  
  2858                                  ;**	LOCK.INC - Definitions for Record Locking
  2859                                  
  2860                                  ;**	LOCK functions
  2861                                  
  2862                                  LOCK_ALL	    equ    0
  2863                                  UNLOCK_ALL	    equ    1
  2864                                  LOCK_MUL_RANGE	    equ    2
  2865                                  UNLOCK_MUL_RANGE    equ    3
  2866                                  LOCK_READ	    equ    4
  2867                                  WRITE_UNLOCK	    equ    5
  2868                                  LOCK_ADD	    equ    6
  2869                                  
  2870                                  ;**	Structure for Lock buffer
  2871                                  
  2872                                  struc LockBuf
  2873 00000000 ????????                .Lock_position:	resd 1		; file position for LOCK
  2874 00000004 ????????                .Lock_length:	resd 1		; number of bytes to LOCK
  2875                                  endstruc
  2876                                  
  2877                                  ;============================================================================
  2878                                  ; DPL.ASM, MSDOS 6.0, 1991
  2879                                  ;============================================================================
  2880                                  ; 04/08/2018 - Retro DOS v3.0
  2881                                  
  2882                                  ; (SRVCALL.ASM)
  2883                                  
  2884                                  struc DPL
  2885 00000000 ????                    .AX:	resw	1	; AX register
  2886 00000002 ????                    .BX:	resw	1	; BX register
  2887 00000004 ????                    .CX:	resw	1	; CX register
  2888 00000006 ????                    .DX:	resw	1	; DX register
  2889 00000008 ????                    .SI:	resw	1	; SI register
  2890 0000000A ????                    .DI:	resw	1	; DI register
  2891 0000000C ????                    .DS:	resw	1	; DS register
  2892 0000000E ????                    .ES:	resw	1	; ES register
  2893 00000010 ????                    .rsrvd: resw	1	; Reserved
  2894 00000012 ????                    .UID:	resw	1	; User (Machine) ID (0 = local macine)
  2895 00000014 ????                    .PID:	resw	1	; Process ID (0 = local user PID)
  2896                                  .size:
  2897                                  endstruc
  2898                                   
  2899                                  ;----------------------------------------------------------------------------
  2900                                  ; DOSDATA
  2901                                  ;----------------------------------------------------------------------------
  2902                                  ;============================================================================
  2903                                  ; 24/04/2019 - Retro DOS v4.0
  2904                                  
  2905                                  DosDataSg equ 3 ; DOS Data Segment address (dw in 'retrodos4.s')
  2906                                  		; ((just after resident IO.SYS code&data))
  2907                                  
  2908                                  ;============================================================================
  2909                                  ; WIN386.INC, MSDOS 6.0, 1991
  2910                                  ;============================================================================
  2911                                  ; 24/04/2019 - Retro DOS 4.0
  2912                                  
  2913                                  ;
  2914                                  ;  Symbols and structures relating to WIN386 support.
  2915                                  ;
  2916                                  ;  Used by files in both the DOS and the BIOS.
  2917                                  ;
  2918                                  ;  Created: 7-13-89 by MRW
  2919                                  ;
  2920                                  
  2921                                  ; WIN386 broadcast int 2fh multiplex number and subfunction numbers
  2922                                  
  2923                                  MultWin386		equ     16h	; Int 2f multiplex number
  2924                                  
  2925                                  Win386_Init		equ	05h	; Win386 initialization
  2926                                  Win386_Exit		equ	06h	; Win386 exit
  2927                                  Win386_Devcall		equ	07h	; Win386 device call out
  2928                                  Win386_InitDone		equ	08h	; Win386 initialization is complete
  2929                                  
  2930                                  ; When Win386_Devcall is broadcast, BX is the Device ID. DOS must 
  2931                                  ; answer call outs from the DOSMGR
  2932                                  
  2933                                  Win386_DOSMGR		equ	15H
  2934                                  
  2935                                  ; The following structures are used to communicate instance data to 
  2936                                  ; Win386 from the DOS and the BIOS. See Win386 API documentation
  2937                                  ; (chapter 3, "Call Out Interfaces") for further description.
  2938                                  
  2939                                  struc Win386_SIS	; Startup Info Structure
  2940 00000000 ????                     .Version:		resb	2	; db 3, 0
  2941 00000002 ????????                 .Next_Dev_Ptr:		resd	1	; pointer to next SIS in list
  2942 00000006 ????????                 .Virt_Dev_File_Ptr:	resd	1
  2943 0000000A ????????                 .Reference_Data:	resd	1
  2944 0000000E ????????                 .Instance_Data_Ptr:	resd	1	; pointer to instance data array
  2945                                  endstruc
  2946                                  
  2947                                  size_of_Win386_SIS equ 18 ; 24/04/2019 - Retro DOS v4.0
  2948                                  
  2949                                  struc Win386_IIS	; Instance Item Structure
  2950 00000000 ????????                .Ptr:			resd	1	; pointer to an instance item
  2951 00000004 ????                    .Size:			resw	1	; size of an instance item
  2952                                  endstruc
  2953                                  
  2954                                  size_of_Win386_IIS equ 6 ; 24/04/2019 - Retro DOS v4.0
  2955                                  
  2956                                  ;Win386 DOSMGR function return values to indicate operation done
  2957                                  
  2958                                  WIN_OP_DONE		equ	0B97Ch	; 
  2959                                  DOSMGR_OP_DONE		equ	0A2ABh	;
  2960                                  
  2961                                  ;M021
  2962                                  ; WInoldap callout multiplex number
  2963                                  
  2964                                  WINOLDAP		equ	46h	;
  2965                                  
  2966                                  ;============================================================================
  2967                                  ;----------------------------------------------------------------------------
  2968                                  ; DOSCODE
  2969                                  ;----------------------------------------------------------------------------
  2970                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  2971                                  
  2972                                  ;============================================================================
  2973                                  ; MSHEAD.ASM (MSDOS 6.0, 1991)
  2974                                  ;============================================================================
  2975                                  ; 16/07/2018 - Retro DOS 3.0
  2976                                  ;----------------------------------------------------------------------------
  2977                                  ; 24/04/2019 - Retro DOS 4.0
  2978                                  
  2979                                  ; MSDOS 6.0
  2980                                  ;----------------------------------------------------------------------------
  2981                                  ; FILE : ORIGIN.INC
  2982                                  ;----------------------------------------------------------------------------
  2983                                  ; This is included in origin.asm and mshead.asm. Contains the equate that
  2984                                  ; is used for ORGing the DOS code.
  2985                                  ;
  2986                                  ; Brief Description of the necessacity of this ORG:
  2987                                  ; -------------------------------------------------
  2988                                  ;
  2989                                  ; A special problem exits when running out of the HMA. The HMA starts at 
  2990                                  ; address FFFF:10. There is no place in the HMA with an offset of zero.
  2991                                  ; This means programs running out off the HMA must use non-zero offset base
  2992                                  ; addresses. It also means that if we're running multiple programs from the
  2993                                  ; HMA, the base offset of each segment must atleast be as big as all of the
  2994                                  ; HMA segments that precede it.
  2995                                  ; 
  2996                                  ; One solution to this problem to ORG each module at 64K minus its size.
  2997                                  ; For instance a code segment 1234h bytes in length would org'd at edcbh.
  2998                                  ; This gives max. flexibility regarding it's location in the HMA. By 
  2999                                  ; selecting segment values between f124h and ffffh it could be located 
  3000                                  ; anywhere in the HMA. The problem with this is that programs with such 
  3001                                  ; high ORGs would not be able to run in low RAM.
  3002                                  ;
  3003                                  ; A compromise solution is to set the ORG address somewhere between 0010h
  3004                                  ; and ffffh - their size. In the particular case of the BIOS and the DOS 
  3005                                  ; the following solution has been implemented:
  3006                                  ;
  3007                                  ; The Bios Code segment will have a very small offset and run at the very
  3008                                  ; front of the HMA, after the VDISK header. THE Dos Code segment will have 
  3009                                  ; a base offset of (700+<min. size off RAM based BIOS>+<min. size of the DOS
  3010                                  ; DATA segment when DOS is running low>). This will reflect the lowest 
  3011                                  ; possible physical address at which DOS code will run, while still providing
  3012                                  ; max. possible flexibility in HMA positioning. This offset MUST NOT be 
  3013                                  ; smaller then that 20+size of Bios Code segment when running high. This is 
  3014                                  ; mostly true.
  3015                                  ;
  3016                                  ; Also this ORG'd value must be communicated to the BIOS. This is done by
  3017                                  ; putting this value after the first jmp instruction in the DOS code in
  3018                                  ; mshead.asm. 
  3019                                  ;
  3020                                  ; In order for the stripz utility to know how many zeroes to be stripped 
  3021                                  ; out, this value is placed at the beginning of the binary in origin.asm.
  3022                                  ;
  3023                                  ; Revision History:
  3024                                  ;
  3025                                  ; Currently this is being done manually. Therefore any change in the DOS DATA
  3026                                  ; Size or the BIOS size should be reflected here. --- Feb 90
  3027                                  ;
  3028                                  ; BDSIZE.INC contains the equates for BIODATASIZE, BIOCODESIZ and DOSDATASIZ.
  3029                                  ; A utility called getsize will obtain the corresponding values from msdos
  3030                                  ; and msbio.map and update the values in BDSIZ.INC if they are different. 
  3031                                  ; DOS should now be built using the batch file makedos.bat which invokes this
  3032                                  ; utility. The FORMAT of BDSIZE.INC should not be changed as getsize is 
  3033                                  ; dependant on that.				  --- Apr 3 '90
  3034                                  ;
  3035                                  ; For ROMDOS, however, there is no need to org the doscode to any location
  3036                                  ; other than zero.  Therefore the stripz utility will not need to be used,
  3037                                  ; so the offset will not need to be included at the beginning of the code
  3038                                  ; segment.  Also, the BIOS can just assume that the resident code begins
  3039                                  ; at offset zero within the segment.
  3040                                  ; 
  3041                                  ;
  3042                                  ;--------------------------------------------------------------------------
  3043                                  
  3044                                  BIODATASTART	EQU	00700h
  3045                                  ;include	bdsize.inc	; this sets the values:
  3046                                  				;	BIODATASIZ
  3047                                  				;	BIOCODESIZ
  3048                                  				;	DOSDATASIZ
  3049                                  
  3050                                  ; 05/12/2022
  3051                                  ;BIODATASIZ EQU 00910H	; 0900h for MSDOS 6.21 IO.SYS
  3052                                  			; 0900h for MSDOS 5.0 IO.SYS
  3053                                  ;BIOCODESIZ EQU 01A70H	; 1A70h for MSDOS 6.21 IO.SYS
  3054                                  			; 1A60h for MSDOS 5.0 IO.SYS
  3055                                  ;DOSDATASIZ EQU 01370H	; 1370h for MSDOS 6.21 IO.SYS
  3056                                  			; 1370h for MSDOS 5.0 IO.SYS
  3057                                  ;ifndef ROMDOS
  3058                                  ;
  3059                                  ;BYTSTART	EQU    	BIODATASTART+BIODATASIZ+BIOCODESIZ+DOSDATASIZ
  3060                                  ;PARASTART	EQU	(BYTSTART + 0FH) AND (NOT 0FH)	
  3061                                  ;
  3062                                  ;else
  3063                                  ;
  3064                                  ;BYTSTART	EQU	0
  3065                                  ;PARASTART	EQU	0
  3066                                  ;
  3067                                  ;endif ; ROMDOS
  3068                                  
  3069                                  ; 24/04/2019 - Retro DOS v4.0 - Modification
  3070                                  ; -----------------------------------------------------------------
  3071                                  ;MSDAT001E equ 136Ah ; 4970 ; for MSDOS 6.21	
  3072                                  ;MSDAT001E equ 1370h ; 4976 ; for Retro DOS v4.0 modif. 25/05/2019	
  3073                                  ;DOSDATASIZE equ MSDAT001E
  3074                                  ; 05/12/2022
  3075                                  ;DOSDATASIZE equ $ ; 29/04/2019 ; -only- for RETRO DOS v4.0 :
  3076                                  ;_PARASTART_ equ DOSDATASIZE ; segment value will point to start of
  3077                                  			    ; of DOSDATA (in low memory) while
  3078                                  			    ; dos/kernel code starts just after 
  3079                                  			    ; this data block ((org = DOSDATASIZE))
  3080                                  			    ; (in low memory or in HMA)	
  3081                                  ; -----------------------------------------------------------------
  3082                                  
  3083                                  ; 04/11/2022	
  3084                                  ; -----------------------------------------------------------------	
  3085                                  ; NOTE:
  3086                                  ; Microsoft dos programmers were calling 'IO.SYS' as dos 'BIOS'
  3087                                  ; (Also, they were calling 'ROMBIOS' as 'ROM' only!)
  3088                                  ; -----------------------------------------------------------------
  3089                                  
  3090                                  ; ----------------------------------------------------------------------------
  3091                                  ; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3092                                  ; ----------------------------------------------------------------------------
  3093                                  
  3094                                  ;segment .code vstart=3DD0h ; 06/12/2022
  3095                                  ; 29/09/2023
  3096                                  segment .code vstart=3DE0h ; 19/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.22)
  3097                                  								
  3098                                  ; ============================================================================
  3099                                  
  3100                                  
  3101                                  ;[ORG 3DE0h]
  3102                                  
  3103                                  ;[ORG _PARASTART_]     ; [org 136Ah]
  3104                                  
  3105                                  ;[ORG 1370h] ; 25/05/2019 - Retro DOS v4.0
  3106                                  
  3107                                  	; 05/12/2022 - RetroDOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3108                                  	;PARASTART equ 3DD0h ; BIOSDATASTART+BIOSDATASIZE
  3109                                  			     ; +BIOSCODESIZE+DOSDATASIZE (rounded up)
  3110                                  	
  3111                                  	; 29/09/2023 
  3112                                  	; 19/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
  3113                                  	PARASTART equ 3DE0h	; (MSDOS 6.22 MSDOS.SYS)
  3114                                  
  3115                                  	[ORG PARASTART]	
  3116                                  
  3117                                  _$STARTCODE:
  3118                                  
  3119                                  ;PARASTART:
  3120 00000000 E9AA74                          JMP     DOSINIT
  3121                                  
  3122                                  	;dw	PARASTART	; PARASTART = 3DE0h for MSDOS 6.0, 6.22
  3123                                  	; 04/11/2022
  3124 00000003 [0000]                  	dw	_$STARTCODE	; PARASTART = 3DD0h for MSDOS 5.0
  3125                                  
  3126                                  BioDataSeg:
  3127 00000005 7000                    	dw	0070h		; Bios data segment fixed at 70h
  3128                                  
  3129                                  ; DosDSeg is a data word in the DOSCODE segment that is loaded with
  3130                                  ; the segment address of DOSDATA. This is purely an optimization, that
  3131                                  ; allows getting the DOS data segment without going through the 
  3132                                  ; BIOS data segment. It is used by the "getdseg" macro.
  3133                                  
  3134                                  DosDSeg:
  3135 00000007 0000                    	dw	0
  3136                                  	
  3137                                  ;============================================================================
  3138                                  ; MSTABLE.ASM (MSDOS 6.0, 1991)
  3139                                  ;============================================================================
  3140                                  ; 16/07/2018 - Retro DOS 3.0
  3141                                  ; 29/04/2019 - Retro DOS 4.0
  3142                                  
  3143                                  	; (MSDOS version)
  3144                                  	; DOSCODE:3DE9h (MSDOS 6.21, MSDOS.SYS)
  3145                                  	;db	6
  3146                                  	;db	20
  3147                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS) 
  3148                                  	; DOSCODE:3DD9h (MSDOS 5.0, MSDOS.SYS)
  3149                                  	;db	5
  3150                                  	;db	0	
  3151                                  
  3152                                  	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
  3153                                  MSVERS:				; MS-DOS version in hex for $GET_VERSION
  3154 00000009 06                      MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  3155 0000000A 16                      MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  3156                                  
  3157                                  ;;hkn YRTAB & MONTAB moved to DOSDATA in ms_data.asm
  3158                                  ;	I_am	YRTAB,8,<200,166,200,165,200,165,200,165>   ; [SYSTEM]
  3159                                  ;	I_am	MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> ; [SYSTEM]
  3160                                  
  3161                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
  3162                                  ; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
  3163                                  ;
  3164                                  ;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
  3165                                  ;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 
  3166                                  
  3167                                  ; This is the error code mapping table for INT 21 errors. This table defines
  3168                                  ; those error codes which are "allowed" for each system call. If the error
  3169                                  ; code ABOUT to be returned is not "allowed" for the call, the correct action
  3170                                  ; is to return the "real" error via Extended error, and one of the allowed
  3171                                  ; errors on the actual call.
  3172                                  ;
  3173                                  ; The table is organized as follows:
  3174                                  ;
  3175                                  ;    Each entry in the table is of variable size, but the first
  3176                                  ;       two bytes are always:
  3177                                  ;
  3178                                  ;       Call#,Cnt of bytes following this byte
  3179                                  ;
  3180                                  ; EXAMPLE:
  3181                                  ;       Call 61 (OPEN)
  3182                                  ;
  3183                                  ;       DB      61,5,12,3,2,4,5
  3184                                  ;
  3185                                  ;       61 is the AH INT 21 call value for OPEN.
  3186                                  ;        5 indicates that there are 5 bytes after this byte (12,3,2,4,5).
  3187                                  ;       Next five bytes are those error codes which are "allowed" on OPEN.
  3188                                  ;       The order of these values is not important EXCEPT FOR THE LAST ONE (in
  3189                                  ;       this case 5).  The last value will be the one returned on the call if
  3190                                  ;       the "real" error is not one of the allowed ones.
  3191                                  ;
  3192                                  ; There are a number of calls (for instance all of the FCB calls) for which
  3193                                  ;   there is NO entry.  This means that NO error codes are returned on this
  3194                                  ;   call, so set up an Extended error and leave the current error code alone.
  3195                                  ;
  3196                                  ; The table is terminated by a call value of 0FFh
  3197                                  
  3198                                  ;PUBLIC I21_MAP_E_TAB
  3199                                  	; 10/08/2018
  3200                                  
  3201                                  ; 29/04/2019
  3202                                  ; DOSCODE:3DE9h (MSDOS 6.21, MSDOS.SYS)
  3203                                  ; 04/11/2022
  3204                                  ; DOSCODE:3DDBh	(MSDOS 5.0 MSDOS.SYS)
  3205                                  
  3206                                  I21_MAP_E_TAB:	; LABEL	BYTE
  3207 0000000B 38020102                    DB  INTERNATIONAL,2,error_invalid_function,error_file_not_found
  3208 0000000F 3903030205                  DB  MKDIR,3,error_path_not_found,error_file_not_found,error_access_denied
  3209 00000014 3A041003                    DB  RMDIR,4,error_current_directory,error_path_not_found
  3210 00000018 0205                        DB          error_file_not_found,error_access_denied
  3211 0000001A 3B020203                    DB  CHDIR,2,error_file_not_found,error_path_not_found
  3212 0000001E 3C040302                    DB  CREAT,4,error_path_not_found,error_file_not_found
  3213 00000022 04                          DB          error_too_many_open_files
  3214 00000023 05                          DB          error_access_denied
  3215                                      ; MSDOS 6.0
  3216 00000024 3D0603020C                  DB	OPEN,6,error_path_not_found,error_file_not_found,error_invalid_access
  3217 00000029 04                          DB          error_too_many_open_files
  3218 0000002A 1A05                        DB          error_not_DOS_disk,error_access_denied
  3219                                      ; MSDOS 3.3
  3220                                      ;DB	OPEN,5,error_path_not_found,error_file_not_found,error_invalid_access
  3221                                      ;DB		error_too_many_open_files,error_access_denied
  3222 0000002C 3E0106                      DB  CLOSE,1,error_invalid_handle
  3223 0000002F 3F020605                    DB  READ,2,error_invalid_handle,error_access_denied
  3224 00000033 40020605                    DB  WRITE,2,error_invalid_handle,error_access_denied
  3225 00000037 4103030205                  DB  UNLINK,3,error_path_not_found,error_file_not_found,error_access_denied
  3226 0000003C 42020601                    DB  LSEEK,2,error_invalid_handle,error_invalid_function
  3227 00000040 4304030201                  DB  CHMOD,4,error_path_not_found,error_file_not_found,error_invalid_function
  3228 00000045 05                          DB          error_access_denied
  3229 00000046 44050F0D01                  DB  IOCTL,5,error_invalid_drive,error_invalid_data,error_invalid_function
  3230 0000004B 0605                        DB          error_invalid_handle,error_access_denied
  3231 0000004D 45020604                    DB  XDUP,2,error_invalid_handle,error_too_many_open_files
  3232 00000051 46020604                    DB  XDUP2,2,error_invalid_handle,error_too_many_open_files
  3233                                      ; MSDOS 6.0	
  3234 00000055 47021A0F                    DB  CURRENT_DIR,2,error_not_DOS_disk,error_invalid_drive
  3235                                      ; MSDOS 3.3	
  3236                                      ;DB  CURRENT_DIR,1,error_invalid_drive
  3237 00000059 48020708                    DB  ALLOC,2,error_arena_trashed,error_not_enough_memory
  3238 0000005D 49020709                    DB  DEALLOC,2,error_arena_trashed,error_invalid_block
  3239 00000061 4A03070908                  DB  SETBLOCK,3,error_arena_trashed,error_invalid_block,error_not_enough_memory
  3240 00000066 4B08030102                  DB  EXEC,8,error_path_not_found,error_invalid_function,error_file_not_found
  3241 0000006B 040B0A                      DB          error_too_many_open_files,error_bad_format,error_bad_environment
  3242 0000006E 0805                        DB          error_not_enough_memory,error_access_denied
  3243 00000070 4E03030212                  DB  FIND_FIRST,3,error_path_not_found,error_file_not_found,error_no_more_files
  3244 00000075 4F0112                      DB  FIND_NEXT,1,error_no_more_files
  3245                                      ; MSDOS 6.0
  3246 00000078 5605110302                  DB  RENAME,5,error_not_same_device,error_path_not_found,error_file_not_found
  3247 0000007D 1005                        DB		error_current_directory,error_access_denied
  3248                                      ; MSDOS 3.3
  3249                                      ;DB  RENAME,4,error_not_same_device,error_path_not_found,error_file_not_found
  3250                                      ;DB		error_access_denied
  3251                                      ; MSDOS 6.0	
  3252 0000007F 57040608                    DB  FILE_TIMES,4,error_invalid_handle,error_not_enough_memory
  3253 00000083 0D01                        DB		error_invalid_data,error_invalid_function
  3254                                      ; MSDOS 3.3	
  3255                                      ;DB  FILE_TIMES,2,error_invalid_handle,error_invalid_function
  3256 00000085 580101                      DB  ALLOCOPER,1,error_invalid_function
  3257 00000088 5A040302                    DB  CREATETEMPFILE,4,error_path_not_found,error_file_not_found
  3258 0000008C 0405                        DB          error_too_many_open_files,error_access_denied
  3259 0000008E 5B055003                    DB  CREATENEWFILE,5,error_file_exists,error_path_not_found
  3260 00000092 020405                      DB          error_file_not_found,error_too_many_open_files,error_access_denied
  3261 00000095 5C040601                    DB  LOCKOPER,4,error_invalid_handle,error_invalid_function
  3262 00000099 2421                        DB          error_sharing_buffer_exceeded,error_lock_violation
  3263 0000009B 65020102                    DB  GETEXTCNTRY,2,error_invalid_function,error_file_not_found	;DOS 3.3
  3264 0000009F 66020102                    DB  GETSETCDPG,2,error_invalid_function,error_file_not_found        ;DOS 3.3
  3265 000000A3 680106                      DB  COMMIT,1,error_invalid_handle                                   ;DOS 3.3
  3266 000000A6 67030408                    DB  EXTHANDLE,3,error_too_many_open_files,error_not_enough_memory
  3267 000000AA 01                          DB              error_invalid_function
  3268                                      ; MSDOS 6.0		
  3269 000000AB 6C0A                        DB	ExtOpen,10
  3270 000000AD 03020C                      DB	  error_path_not_found,error_file_not_found,error_invalid_access
  3271 000000B0 045008                      DB		error_too_many_open_files,error_file_exists,error_not_enough_memory
  3272 000000B3 1A0D                        DB		error_not_DOS_disk,error_invalid_data
  3273 000000B5 0105                        DB		error_invalid_function,error_access_denied
  3274 000000B7 69040F0D                    DB	GetSetMediaID,4,error_invalid_drive,error_invalid_data
  3275 000000BB 0105                        DB		error_invalid_function,error_access_denied
  3276 000000BD FF                          DB  0FFh
  3277                                  
  3278                                  ;19/09/2023
  3279                                  ;22/12/2022
  3280                                  ;04/11/2022	
  3281                                  ;29/04/2019 - Retro DOS v4.0
  3282                                  ;============================================================================
  3283                                  ; 	Retro DOS v4.0
  3284                                  ;============================================================================
  3285 000000BE 00                      	db 	0
  3286                                  RETRODOSMSG:
  3287 000000BF 0D0A                    	db	13,10
  3288                                  	;;;;;db	"Retro DOS v4.0 by Erdogan Tan [2019]"
  3289                                  	;;;;db	"Retro DOS v4.0 by Erdogan Tan [2022]"
  3290                                  	;;;db	"Retro DOS v4.1 by Erdogan Tan [2022]"	; 28/12/2022
  3291                                  	;;db	"Retro DOS v4.2 by Erdogan Tan [2022]"	; 30/12/2022
  3292                                  	;db	"Retro DOS v4.2 by Erdogan Tan [2023]"
  3293 000000C1 526574726F20444F53-     	db	"Retro DOS v4.2 by Erdogan Tan [2024]"	; 05/01/2024
  3293 000000CA 2076342E3220627920-
  3293 000000D3 4572646F67616E2054-
  3293 000000DC 616E205B323032345D 
  3294 000000E5 0D0A2400                	db	13,10,"$", 0 
  3295                                  
  3296                                  ;============================================================================
  3297                                  ; MSTABLE.ASM, MSDOS 6.0, 1991
  3298                                  ;============================================================================
  3299                                  ; 11/07/2018 - Retro DOS v3.0
  3300                                  
  3301                                  	%define short_addr dw  ; 03/03/2018 - Retro DOS v2.0
  3302 000000E9 90                      align 2
  3303                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0E00h
  3304                                  
  3305                                  ; Standard Functions
  3306                                  ;DISPATCH  LABEL WORD
  3307                                  DISPATCH:
  3308                                  	; 16/07/2018 - Retro DOS v3.0
  3309                                  	; (MSDOS 3.3)
  3310                                  
  3311                                  ; 29/04/2019
  3312                                  ; DOSCODE:3E9Eh (MSDOS 6.21, MSDOS.SYS)
  3313                                  
  3314                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3315                                  ; DOSCODE:3E8Eh (MSDOS 5.0, MSDOS.SYS)
  3316                                  
  3317 000000EA [5760]                          short_addr  _$ABORT			    ;  0      0
  3318 000000EC [2A16]                          short_addr  _$STD_CON_INPUT		    ;  1      1
  3319 000000EE [3316]                          short_addr  _$STD_CON_OUTPUT		    ;  2      2
  3320 000000F0 [E516]                          short_addr  _$STD_AUX_INPUT		    ;  3      3
  3321 000000F2 [0017]                          short_addr  _$STD_AUX_OUTPUT		    ;  4      4
  3322 000000F4 [0617]                          short_addr  _$STD_PRINTER_OUTPUT	    ;  5      5
  3323 000000F6 [7115]                          short_addr  _$RAW_CON_IO		    ;  6      6
  3324 000000F8 [9D15]                          short_addr  _$RAW_CON_INPUT		    ;  7      7
  3325 000000FA [4C13]                          short_addr  _$STD_CON_INPUT_NO_ECHO	    ;  8      8
  3326 000000FC [A413]                          short_addr  _$STD_CON_STRING_OUTPUT	    ;  9      9
  3327 000000FE [B013]                          short_addr  _$STD_CON_STRING_INPUT	    ; 10      A
  3328 00000100 [1A17]                          short_addr  _$STD_CON_INPUT_STATUS	    ; 11      B
  3329 00000102 [2417]                          short_addr  _$STD_CON_INPUT_FLUSH	    ; 12      C
  3330 00000104 [790F]                          short_addr  _$DISK_RESET		    ; 13      D
  3331 00000106 [600E]                          short_addr  _$SET_DEFAULT_DRIVE		    ; 14      E
  3332 00000108 [E81D]                          short_addr  _$FCB_OPEN			    ; 15      F
  3333 0000010A [C317]                          short_addr  _$FCB_CLOSE			    ; 16     10
  3334 0000010C [D71E]                          short_addr  _$DIR_SEARCH_FIRST		    ; 17     11
  3335 0000010E [1D1F]                          short_addr  _$DIR_SEARCH_NEXT		    ; 18     12
  3336 00000110 [6917]                          short_addr  _$FCB_DELETE		    ; 19     13
  3337 00000112 [3F1C]                          short_addr  _$FCB_SEQ_READ		    ; 20     14
  3338 00000114 [431C]                          short_addr  _$FCB_SEQ_WRITE	            ; 21     15
  3339 00000116 [C71E]                          short_addr  _$FCB_CREATE		    ; 22     16
  3340 00000118 [2F18]                          short_addr  _$FCB_RENAME		    ; 23     17
  3341                                  	; 16/07/2018
  3342                                          ;short_addr _CPMFUNC			    ; 24     18	
  3343 0000011A [4D06]                          short_addr  NO_OP			    ; 24     18
  3344 0000011C [5B0E]                          short_addr  _$GET_DEFAULT_DRIVE		    ; 25     19
  3345 0000011E [500E]                          short_addr  _$SET_DMA			    ; 26     1A
  3346                                  
  3347                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3348                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3349                                  ;                                                                          ;
  3350 00000120 [080F]                          short_addr  _$SLEAZEFUNC		    ; 27     1B
  3351 00000122 [0A0F]                          short_addr  _$SLEAZEFUNCDL		    ; 28     1C
  3352                                  ;                                                                          ;
  3353                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3354                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3355                                  
  3356                                          ;short_addr  _CPMFUNC			    ; 29     1D
  3357                                          ;short_addr  _CPMFUNC			    ; 30     1E
  3358                                  
  3359                                  ; 08/07/2018 - Retro DOS v3.0
  3360                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3361                                  
  3362 00000124 [4D06]                  	short_addr  NO_OP			    ; 29     1D
  3363 00000126 [4D06]                  	short_addr  NO_OP			    ; 30     1E
  3364                                  
  3365                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3366                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3367                                  ;                                                                          ;
  3368 00000128 [490F]                          short_addr  _$GET_DEFAULT_DPB               ; 31     1F
  3369                                  ;                                                                          ;
  3370                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3371                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3372                                          ;short_addr _CPMFUNC			    ; 32     20
  3373                                  
  3374                                  ; 08/07/2018 - Retro DOS v3.0
  3375                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3376                                  
  3377 0000012A [4D06]                  	short_addr  NO_OP			    ; 32     20
  3378                                  
  3379 0000012C [471C]                          short_addr  _$FCB_RANDOM_READ               ; 33     21
  3380 0000012E [4B1C]                          short_addr  _$FCB_RANDOM_WRITE              ; 34     22
  3381 00000130 [7B17]                          short_addr  _$GET_FCB_FILE_LENGTH	    ; 35     23
  3382 00000132 [5117]                          short_addr  _$GET_FCB_POSITION		    ; 36     24
  3383                                  
  3384                                  ;MAXCALL = ($-DISPATCH)/2 - 1
  3385                                  MAXCALL EQU ($-DISPATCH)/2 - 1
  3386                                  
  3387                                  ; Extended Functions
  3388 00000134 [810E]                          short_addr  _$SET_INTERRUPT_VECTOR	    ; 37     25
  3389                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3390                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3391                                  ;                                                                          ;
  3392 00000136 [8610]                          short_addr  _$CREATE_PROCESS_DATA_BLOCK	    ; 38     26
  3393                                  ;                                                                          ;
  3394                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3395                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3396 00000138 [3B1C]                          short_addr  _$FCB_RANDOM_READ_BLOCK	    ; 39     27
  3397 0000013A [371C]                          short_addr  _$FCB_RANDOM_WRITE_BLOCK        ; 40     28
  3398 0000013C [FD0E]                          short_addr  _$PARSE_FILE_DESCRIPTOR	    ; 41     29
  3399 0000013E [580A]                          short_addr  _$GET_DATE                      ; 42     2A
  3400 00000140 [750A]                          short_addr  _$SET_DATE                      ; 43     2B
  3401 00000142 [940A]                          short_addr  _$GET_TIME                      ; 44     2C
  3402 00000144 [A50A]                          short_addr  _$SET_TIME                      ; 45     2D
  3403 00000146 [410C]                          short_addr  _$SET_VERIFY_ON_WRITE           ; 46     2E
  3404                                  
  3405                                  ; Extended functionality group
  3406 00000148 [3D0E]                          short_addr  _$GET_DMA                       ; 47     2F
  3407 0000014A [1A0C]                          short_addr  _$GET_VERSION                   ; 48     30
  3408 0000014C [FB5F]                          short_addr  _$KEEP_PROCESS		    ; 49     31
  3409                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3410                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3411                                  ;                                                                          ;
  3412 0000014E [4B0F]                          short_addr  _$GET_DPB			    ; 50     32
  3413                                  ;                                                                          ;
  3414                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3415                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3416 00000150 [6702]                          short_addr  _$SET_CTRL_C_TRAPPING           ; 51     33
  3417 00000152 [330F]                          short_addr  _$GET_INDOS_FLAG                ; 52     34
  3418 00000154 [720E]                          short_addr  _$GET_INTERRUPT_VECTOR          ; 53     35
  3419 00000156 [1A0E]                          short_addr  _$GET_DRIVE_FREESPACE           ; 54     36
  3420 00000158 [AE0E]                          short_addr  _$CHAR_OPER                     ; 55     37
  3421 0000015A [480C]                          short_addr  _$INTERNATIONAL                 ; 56     38
  3422                                  ; XENIX CALLS
  3423                                  ;   Directory Group
  3424 0000015C [A221]                          short_addr  _$MKDIR			    ; 57     39
  3425 0000015E [EE20]                          short_addr  _$RMDIR			    ; 58     3A
  3426 00000160 [2921]                          short_addr  _$CHDIR			    ; 59     3B
  3427                                  ;   File Group
  3428 00000162 [ED6D]                          short_addr  _$CREAT			    ; 60     3C
  3429 00000164 [166D]                          short_addr  _$OPEN			    ; 61     3D
  3430 00000166 [5F65]                          short_addr  _$CLOSE		 	    ; 62     3E
  3431 00000168 [6766]                          short_addr  _$READ			    ; 63     3F
  3432 0000016A [C466]                          short_addr  _$WRITE			    ; 64     40
  3433 0000016C [3D6E]                          short_addr  _$UNLINK			    ; 65     41
  3434 0000016E [C966]                          short_addr  _$LSEEK			    ; 66     42
  3435 00000170 [FA6D]                          short_addr  _$CHMOD			    ; 67     43
  3436 00000172 [0322]                          short_addr  _$IOCTL			    ; 68     44
  3437 00000174 [7E67]                          short_addr  _$DUP			    ; 69     45
  3438 00000176 [9C67]                          short_addr  _$DUP2			    ; 70     46
  3439 00000178 [8A20]                          short_addr  _$CURRENT_DIR		    ; 71     47
  3440                                  ;   Memory Group
  3441 0000017A [F460]                          short_addr  _$ALLOC			    ; 72     48
  3442 0000017C [6962]                          short_addr  _$DEALLOC                       ; 73     49
  3443 0000017E [4562]                          short_addr  _$SETBLOCK                      ; 74     4A
  3444                                  ;   Process Group
  3445 00000180 [E159]                          short_addr  _$EXEC			    ; 75     4B
  3446 00000182 [3360]                          short_addr  _$EXIT			    ; 76     4C
  3447 00000184 [D759]                          short_addr  _$WAIT			    ; 77     4D
  3448 00000186 [D41F]                          short_addr  _$FIND_FIRST		    ; 78     4E
  3449                                  ;   Special Group
  3450 00000188 [2820]                          short_addr  _$FIND_NEXT			    ; 79     4F
  3451                                  ; SPECIAL SYSTEM GROUP
  3452                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3453                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3454                                  ;                                                                          ;
  3455 0000018A [B902]                          short_addr  _$SET_CURRENT_PDB		    ; 80     50
  3456 0000018C [C502]                          short_addr  _$GET_CURRENT_PDB               ; 81     51
  3457 0000018E [3F0F]                          short_addr  _$GET_IN_VARS                   ; 82     52
  3458 00000190 [AE0F]                          short_addr  _$SETDPB			    ; 83     53
  3459                                  ;                                                                          ;
  3460                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3461                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3462 00000192 [3C0C]                          short_addr  _$GET_VERIFY_ON_WRITE	    ; 84     54
  3463                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3464                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3465                                  ;                                                                          ;
  3466 00000194 [7510]                          short_addr  _$DUP_PDB                       ; 85     55
  3467                                  ;                                                                          ;
  3468                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3469                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3470 00000196 [636E]                          short_addr  _$RENAME			    ; 86     56
  3471 00000198 [3067]                          short_addr  _$FILE_TIMES                    ; 87     57
  3472 0000019A [9E62]                          short_addr  _$ALLOCOPER                     ; 88     58
  3473                                  
  3474                                  ; 08/07/2018 - Retro DOS v3.0
  3475                                  ; -------------------------------------------------------------------------;
  3476                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3477                                  
  3478                                  ; Network extention system calls
  3479 0000019C [C20E]                          short_addr  _$GetExtendedError              ; 89     59
  3480 0000019E [E96E]                          short_addr  _$CreateTempFile                ; 90     5A
  3481 000001A0 [D16E]                          short_addr  _$CreateNewFile                 ; 91     5B
  3482 000001A2 [9B70]                          short_addr  _$LockOper                      ; 92     5C
  3483 000001A4 [7263]                          short_addr  _$ServerCall                    ; 93     5D
  3484 000001A6 [6668]                          short_addr  _$UserOper                      ; 94     5E
  3485 000001A8 [CB67]                          short_addr  _$AssignOper                    ; 95     5F
  3486 000001AA [B16C]                          short_addr  _$NameTrans                     ; 96     60
  3487 000001AC [4D06]                  	short_addr  NO_OP			    ; 97     61
  3488 000001AE [C502]                          short_addr  _$GET_CURRENT_PDB		    ; 98     62
  3489                                  ; the next call is reserved for hangool sys call
  3490                                  	; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0)
  3491 000001B0 [E20E]                  	short_addr  _$ECS_Call			    ; 99     63
  3492                                  	;short_addr  NO_OP  ;  MSDOS 3.3	    ; 99     63
  3493                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3494                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3495                                  ;                                                                          ;
  3496 000001B2 [D102]                          short_addr  _$SET_PRINTER_FLAG              ; 100    64
  3497                                  ;                                                                          ;
  3498                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3499                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3500 000001B4 [CB0C]                          short_addr  _$GetExtCntry                   ; 101    65
  3501 000001B6 [C80D]                          short_addr  _$GetSetCdPg                    ; 102    66
  3502 000001B8 [AA65]                          short_addr  _$ExtHandle                     ; 103    67
  3503 000001BA [9265]                          short_addr  _$COMMIT                        ; 104    68
  3504                                  
  3505                                  ; 08/07/2018
  3506                                  ; Above system calls are valid for Retro DOS v3.0 (MSDOS 3.3) 
  3507                                  ; Following system calls are valid for Retro DOS v4.0 (MSDOS 6.0)
  3508                                  
  3509                                  ; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0)
  3510 000001BC [7811]                  	short_addr  _$GSetMediaID                   ; 105    69   ;AN000;
  3511 000001BE [9265]                  	short_addr  _$COMMIT                        ; 106    6A   ;AN000;
  3512 000001C0 [4D06]                  	short_addr  NO_OP                           ; 107    6B   
  3513                                  						    ; IFS_IOCTL no longer 
  3514                                  						    ; supported
  3515 000001C2 [836F]                  	short_addr  _$Extended_Open                 ; 108    6C   ;AN000;
  3516                                  
  3517                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3518                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3519                                  ;                                                                          ;
  3520                                  ;ifdef ROMEXEC
  3521                                  ;       short_addr  $ROM_FIND_FIRST	   	    ; 109    6D
  3522                                  ;       short_addr  $ROM_FIND_NEXT	   	    ; 110    6E
  3523                                  ;	short_addr  $ROM_EXCLUDE		    ; 111    6F	  ; M078
  3524                                  ;endif
  3525                                  ;                                                                          ;
  3526                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3527                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3528                                  
  3529                                  ;MAXCOM  = ($-DISPATCH)/2 - 1
  3530                                  
  3531                                  MAXCOM  EQU ($-DISPATCH)/2 - 1
  3532                                  
  3533                                  ; 08/07/2018 - Retro DOS v3.0
  3534                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3535                                  
  3536                                  ;	If 	Installed
  3537                                  
  3538                                  align 2
  3539                                  
  3540                                  ;PUBLIC FOO
  3541                                  
  3542                                  FOO:	; LABEL WORD
  3543 000001C4 [0A07]                          short_addr  Leave2F
  3544                                  
  3545 000001C6 [C801]                  DTab:	DW  DOSTable
  3546                                  
  3547                                  	;PUBLIC FOO,DTAB
  3548                                  
  3549                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0ED6h
  3550                                  
  3551                                  ; 29/04/2019
  3552                                  ; DOSCODE:3F7Ch (MSDOS 6.21, MSDOS.SYS)
  3553                                  
  3554                                  
  3555                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3556                                  ; DOSCODE:3F6Ch (MSDOS 5.0, MSDOS.SYS)
  3557                                         
  3558                                  DOSTable:  ; LABEL  WORD
  3559 000001C8 30                              DB      (DOSTableEnd-DOSTable-1)/2 ; db  48
  3560 000001C9 [2F09]                          short_addr  DOSInstall          ;   0 install check
  3561 000001CB [6B2E]                          short_addr  DOS_CLOSE           ;   1   DOS_CLOSE
  3562 000001CD [A30E]                          short_addr  RECSET              ;   2   RECSET
  3563 000001CF [2909]                          short_addr  DosGetGroup         ;   3   Get DOSGROUP
  3564 000001D1 [124F]                          short_addr  PATHCHRCMP          ;   4   PATHCHRCMP
  3565 000001D3 [3516]                          short_addr  OUTT                ;   5   OUT
  3566 000001D5 [E451]                          short_addr  NET_I24_ENTRY       ;   6   NET_I24_ENTRY
  3567 000001D7 [5857]                          short_addr  PLACEBUF            ;   7   PLACEBUF
  3568 000001D9 [5F2F]                          short_addr  FREE_SFT            ;   8   FREE_SFT
  3569 000001DB [1D59]                          short_addr  BUFWRITE            ;   9   BUFWRITE
  3570 000001DD [4F71]                          short_addr  SHARE_VIOLATION     ;   10  SHARE_VIOLATION
  3571 000001DF [B82B]                          short_addr  SHARE_ERROR         ;   11  SHARE_ERROR
  3572 000001E1 [A22B]                          short_addr  SET_SFT_MODE        ;   12  SET_SFT_MODE
  3573 000001E3 [E00A]                          short_addr  DATE16              ;   13  DATE16
  3574 000001E5 [E411]                          short_addr  Idle		;   14      empty slot
  3575 000001E7 [5157]                          short_addr  SCANPLACE           ;   15  SCANPLACE
  3576 000001E9 [E411]                          short_addr  Idle		;   16      empty slot
  3577 000001EB [B111]                          short_addr  StrCpy              ;   17  StrCpy
  3578 000001ED [C911]                          short_addr  StrLen              ;   18  StrLen
  3579 000001EF [BD4E]                          short_addr  UCase		;   19  UCase
  3580 000001F1 [9557]                          short_addr  POINTCOMP           ;   20  POINTCOMP
  3581 000001F3 [F458]                          short_addr  CHECKFLUSH          ;   21  CHECKFLUSH
  3582 000001F5 [DB64]                          short_addr  SFFromSFN           ;   22  SFFromSFN
  3583 000001F7 [2969]                          short_addr  GetCDSFromDrv       ;   23  GetCDSFromDrv
  3584 000001F9 [8104]                          short_addr  Get_User_Stack      ;   24  Get_User_Stack
  3585 000001FB [D468]                          short_addr  GETTHISDRV          ;   25  GetThisDrv
  3586 000001FD [D66C]                          short_addr  DriveFromText       ;   26  DriveFromText
  3587 000001FF [810B]                          short_addr  SETYEAR             ;   27  SETYEAR
  3588 00000201 [100C]                          short_addr  DSUM                ;   28  DSUM
  3589 00000203 [770B]                          short_addr  DSLIDE              ;   29  DSLIDE
  3590 00000205 [8F11]                          short_addr  StrCmp              ;   30  StrCmp
  3591 00000207 [1968]                          short_addr  InitCDS             ;   31  initcds
  3592 00000209 [A864]                          short_addr  pJFNFromHandle      ;   32  pJfnFromHandle
  3593 0000020B [B16C]                          short_addr  _$NameTrans		;   33  $NameTrans
  3594 0000020D [7406]                          short_addr  CAL_LK              ;   34  CAL_LK
  3595 0000020F [7D40]                          short_addr  DEVNAME             ;   35  DEVNAME
  3596 00000211 [E411]                          short_addr  Idle                ;   36  Idle
  3597 00000213 [D711]                          short_addr  DStrLen             ;   37  DStrLen
  3598 00000215 [8612]                          short_addr  NLS_OPEN            ;   38  NLS_OPEN      DOS 3.3
  3599 00000217 [5F65]                          short_addr  _$CLOSE		;   39  $CLOSE        DOS 3.3
  3600 00000219 [8C12]                          short_addr  NLS_LSEEK           ;   40  NLS_LSEEK     DOS 3.3
  3601 0000021B [6766]                          short_addr  _$READ		;   41  $READ         DOS 3.3
  3602 0000021D [4812]                          short_addr  FastInit            ;   42  FastInit      DOS 3.4  ;AN000;
  3603 0000021F [C912]                          short_addr  NLS_IOCTL           ;   43  NLS_IOCTL     DOS 3.3
  3604 00000221 [B812]                          short_addr  GetDevList          ;   44  GetDevList    DOS 3.3
  3605 00000223 [DD12]                          short_addr  NLS_GETEXT          ;   45  NLS_GETEXT    DOS 3.3
  3606                                          
  3607                                  	; 29/04/2019 - Retro DOS v4.0
  3608 00000225 [E112]                  	short_addr  MSG_RETRIEVAL	;   46  MSG_RETRIEVAL DOS 4.0  ;AN000;
  3609                                  
  3610 00000227 [4D06]                  	short_addr  NO_OP		;   M006: 47  no longer supported
  3611                                  ;*** 	short_addr  Fake_Version	;   47  Fake_Version  DOS 4.0  ;AN006;
  3612                                  
  3613                                  DOSTableEnd:  ; LABEL BYTE
  3614                                  
  3615                                  	;ENDIF
  3616                                  
  3617                                  ; ----------------------------------------------------------------------------
  3618                                  ; BREAK   <Copyright notice and version>
  3619                                  ; ----------------------------------------------------------------------------
  3620                                  
  3621                                  ;CODSTRT EQU	$
  3622                                  
  3623                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
  3624                                  ; (MSTABLE.ASM, MSDOS 6.0, 1991)
  3625                                  
  3626                                  ; NOTE WARNING: This declaration of HEADER must be THE LAST thing in this
  3627                                  ;       module. The reason is so that the data alignments are the same in
  3628                                  ;       IBM-DOS and MS-DOS up through header.
  3629                                  
  3630                                  	;PUBLIC	HEADER
  3631                                  
  3632                                  HEADER:	; LABEL	BYTE
  3633                                          ;IF	DEBUG
  3634                                          ;DB	13,10,"Debugging DOS version "
  3635                                          ;DB	MAJOR_VERSION + "0"
  3636                                          ;DB	"."
  3637                                          ;DB	(MINOR_VERSION / 10) + "0"
  3638                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  3639                                          ;ENDIF
  3640                                  
  3641                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3642                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
  3643                                  %if 0
  3644                                          ;IF	NOT IBM
  3645                                          DB	13,10,"MS-DOS version "
  3646                                          DB	MAJOR_VERSION + "0"
  3647                                          DB	"."
  3648                                          DB	(MINOR_VERSION / 10) + "0"
  3649                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  3650                                          DB	(MINOR_VERSION % 10) + "0"
  3651                                  
  3652                                          ;IF	HIGHMEM
  3653                                          ;DB	"H"
  3654                                          ;ENDIF
  3655                                  
  3656                                  	;DB	13,10,"Copyright 1981,82,83,84,88 Microsoft Corp.",13,10,"$"
  3657                                  	; 30/04/2019 - Retro DOS v4.0
  3658                                  	DB	13,10,"Copyright 1981-1993 Microsoft Corp.",13,10,"$"	
  3659                                  
  3660                                  	;ENDIF
  3661                                  
  3662                                  %endif
  3663                                  
  3664                                  ;IF DEBUG
  3665                                  ;	DB	13,10,"$"
  3666                                  ;ENDIF
  3667                                  
  3668                                  ;include copyrigh.inc
  3669                                  
  3670                                  ; DOSCODE:3FDDh (MSDOS 6.21, MSDOS.SYS)
  3671                                  
  3672                                  	;DB	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
  3673                                  	;DB	"Licensed Material - Property of Microsoft "
  3674                                  	;DB	"All rights reserved "
  3675                                  
  3676                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3677                                  ; DOSCODE:3FCDh (MSDOS 5.0, MSDOS.SYS)
  3678                                  
  3679                                  ; 28/12/2022 - Retro DOS v4.1
  3680                                  %if 0
  3681                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  3682                                  ms_copyright:
  3683                                  	db	'MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp '
  3684                                  	db	'Licensed Material - Property of Microsoft '
  3685                                  	db	'All rights reserved '
  3686                                  
  3687                                  %endif
  3688                                  	;; 28/12/2022 - Retro DOS v4.1
  3689                                  ;ms_copyright:	
  3690                                    	;db	13,10,"MS DOS Version 5.0"
  3691                                  	;db	13,10,"Copyright 1981-1991 Microsoft Corp.",13,10,"$",0	
  3692                                  
  3693                                  ;	; 21/09/2023 - Retro DOS v4.2 MSDOS.SYS
  3694                                  ;	; (MSDOS 6.22 MSDOS.SYS - DOSCODE:3FDDh (File offset: 509))
  3695                                  ;ms_copyright:
  3696                                  ;	db 'MS DOS Version 6 (C)Copyright 1981-1994 Microsoft Corp '
  3697                                  ;	db 'Licensed Material - Property of Microsoft All rights reserved '
  3698                                  
  3699                                  	; 20/09/2023 - Retro DOS v4.2
  3700                                  ms_copyright:	
  3701 00000229 0D0A4D5320444F5320-       	db	13,10,"MS DOS Version 6.22"
  3701 00000232 56657273696F6E2036-
  3701 0000023B 2E3232             
  3702 0000023E 0D0A436F7079726967-     	db	13,10,"Copyright 1981-1994 Microsoft Corp.",13,10,"$",0	
  3702 00000247 687420313938312D31-
  3702 00000250 393934204D6963726F-
  3702 00000259 736F667420436F7270-
  3702 00000262 2E0D0A2400         
  3703                                  
  3704                                  ;============================================================================
  3705                                  ; MSCODE.ASM
  3706                                  ;============================================================================
  3707                                  
  3708                                  ; Retro DOS v2.0 (NASM 2.11) source code modifications by Erdogan Tan
  3709                                  ; 03/03/2018
  3710                                  
  3711                                  ;
  3712                                  ; MSCODE.ASM -- MSDOS code
  3713                                  ;
  3714                                  
  3715                                  ;INCLUDE DOSSEG.ASM
  3716                                  ;INCLUDE STDSW.ASM
  3717                                  
  3718                                  ;CODE    SEGMENT BYTE PUBLIC  'CODE'
  3719                                  ;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  3720                                  
  3721                                  ;.xcref
  3722                                  ;INCLUDE DOSSYM.ASM
  3723                                  ;INCLUDE DEVSYM.ASM
  3724                                  ;.cref
  3725                                  ;.list
  3726                                  
  3727                                  ;IFNDEF  KANJI
  3728                                  ;KANJI   EQU     0       ; FALSE
  3729                                  ;ENDIF
  3730                                  
  3731                                  ;IFNDEF  IBM
  3732                                  ;IBM     EQU     0
  3733                                  ;ENDIF
  3734                                  
  3735                                  ;IFNDEF  HIGHMEM
  3736                                  ;HIGHMEM  EQU     0
  3737                                  ;ENDIF
  3738                                  
  3739                                          ;i_need  USER_SP,WORD
  3740                                          ;i_need  USER_SS,WORD
  3741                                          ;i_need  SAVEDS,WORD
  3742                                          ;i_need  SAVEBX,WORD
  3743                                          ;i_need  INDOS,BYTE
  3744                                          ;i_need  NSP,WORD
  3745                                          ;i_need  NSS,WORD
  3746                                          ;i_need  CURRENTPDB,WORD
  3747                                          ;i_need  AUXSTACK,BYTE
  3748                                          ;i_need  CONSWAP,BYTE
  3749                                          ;i_need  IDLEINT,BYTE
  3750                                          ;i_need  NOSETDIR,BYTE
  3751                                          ;i_need  ERRORMODE,BYTE
  3752                                          ;i_need  IOSTACK,BYTE
  3753                                          ;i_need  WPERR,BYTE
  3754                                          ;i_need  DSKSTACK,BYTE
  3755                                          ;i_need  CNTCFLAG,BYTE
  3756                                          ;i_need  LEAVEADDR,WORD
  3757                                          ;i_need  NULLDEVPT,DWORD
  3758                                  
  3759                                          ;IF NOT IBM
  3760                                          ;i_need  OEM_HANDLER,DWORD
  3761                                          ;ENDIF
  3762                                  
  3763                                          ;EXTRN   DSKSTATCHK:NEAR,GETBP:NEAR,DSKREAD:NEAR,DSKWRITE:NEAR
  3764                                  
  3765                                  ;============================================================================
  3766                                  ; MSDISP.ASM, MSDOS 6.0, 1991
  3767                                  ;============================================================================
  3768                                  ; 11/07/2018 - Retro DOS v3.0
  3769                                  ; 01/05/2019 - Retro DOS v4.0
  3770                                  
  3771                                  ; DosCode SEGMENT
  3772                                  
  3773                                  ; ==========================================================================
  3774                                  ;
  3775                                  ; $Set_CTRL_C_Trapping
  3776                                  ;
  3777                                  ; Function:
  3778                                  ;	Enable disable ^C checking in dispatcher
  3779                                  ;
  3780                                  ; Inputs:
  3781                                  ;		AL = 0 read ^C status
  3782                                  ;		AL = 1 Set ^C status, DL = 0/1 for ^C off/on
  3783                                  ;		AL = 2 Set ^C status to contents of DL.	Output is old state.
  3784                                  ;		AL = 5 get DOS boot drive
  3785                                  ;		AL = 6 Get version number
  3786                                  ;			RETURNS:
  3787                                  ;				BH = Minor version number
  3788                                  ;				BL = Major version number
  3789                                  ;				DL = DOS internal revision
  3790                                  ;				DH = DOS type flags
  3791                                  ;					Bit 3 	- DOS in ROM
  3792                                  ;					Bit 4 	- DOS in HMA
  3793                                  ;					Bit 0-2, 5-7 - Reserved
  3794                                  ; Outputs:
  3795                                  ;		If AL = 0 then DL = 0/1 for ^C off/on
  3796                                  ;
  3797                                  ; History:
  3798                                  ;      removed	AL = 3 Get CPSW state to DL	    DOS 3.4
  3799                                  ;      removed	AL = 4 Set CPSW state from DL	    DOS 3.4
  3800                                  ; ==========================================================================
  3801                                  
  3802                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3803                                  ; DOSCODE:4045h (MSDOS 5.0, MSDOS.SYS)
  3804                                  
  3805                                  ; 01/01/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
  3806                                  ; DOSCODE:4052h (MSDOS 6.21, MSDOS.SYS)
  3807                                  ; DOSCODE:4052h (MSDOS 6.22, MSDOS.SYS)
  3808                                  ; DOSCODE:4123h (PCDOS 7.1, IBMDOS.COM)
  3809                                  
  3810                                  _$SET_CTRL_C_TRAPPING:
  3811                                  	; 01/05/2019 - Retro DOS v4.0
  3812                                  
  3813 00000267 3C06                    	cmp	AL,6			; Is this a valid subfunction?
  3814 00000269 7603                    	jbe	short scct_1		; If yes continue processing
  3815                                  
  3816 0000026B B0FF                    	mov	AL,0FFh			; Else set AL to -1 and
  3817 0000026D CF                      	iret
  3818                                  scct_1:
  3819 0000026E 1E                      	push	DS
  3820                                  
  3821                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3822 0000026F 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3823                                  	
  3824 00000274 50                      	push	AX			; DL only register that can change
  3825 00000275 56                      	push	SI
  3826                                  
  3827 00000276 BE[3703]                	mov	SI,CNTCFLAG		; DS:SI --> Ctrl C Status byte
  3828 00000279 30E4                    	xor	AH,AH			; Clear high byte of AX
  3829 0000027B 09C0                    	or	AX,AX			; Check for subfunction 0
  3830 0000027D 7504                    	jnz	short scct_2		; If not 0 jmp to next check
  3831                                  
  3832 0000027F 8A14                    	mov	DL,[SI]			; Else move current ctrl C status
  3833 00000281 EB30                    	jmp	SHORT scct_9s		; into DL and jmp to exit
  3834                                  scct_2:
  3835 00000283 48                      	dec	AX			; Now dec AX and see if it was 1
  3836 00000284 7507                    	jnz	short scct_3		; If not 0 it wasn't 1 so do next chk
  3837                                  
  3838 00000286 80E201                  	and	DL,1			; Else mask off bit 0 of DL and
  3839 00000289 8814                    	mov	[SI],DL			; save it as new Ctrl C status
  3840 0000028B EB26                    	jmp	SHORT scct_9s		; Jmp to exit
  3841                                  scct_3:
  3842 0000028D 48                      	dec	AX			; Dec AX again to see if it was 2
  3843 0000028E 7507                    	jnz	short scct_4		; If not 0 wasn't 2 so go to next chk
  3844                                  
  3845 00000290 80E201                  	and	DL,1			; Else mask off bit 0 of DL and
  3846 00000293 8614                    	xchg	[SI],DL			; Exchange DL with old status byte
  3847 00000295 EB1C                    	jmp	SHORT scct_9s		; Jump to exit (returning old status)
  3848                                  scct_4:
  3849 00000297 3C03                    	cmp	al,3 ; 01/01/2024 (PCDOS 7.1 IBMDOS.COM)
  3850                                  	;cmp	AX,3 			; Test for 5 after it was dec twice
  3851 00000299 7506                    	jne	short scct_5		; If not equal then not get boot drv
  3852 0000029B 8A16[6900]              	mov	DL,[BOOTDRIVE]		; Else return boot drive in DL
  3853 0000029F EB12                    	jmp	SHORT scct_9s		; Jump to exit (returning boot drive)
  3854                                  scct_5:
  3855 000002A1 3C04                    	cmp	al,4 ; 01/01/2024 (PCDOS 7.1 IBMDOS.COM)
  3856                                  	;cmp	AX,4 			; Test for 6 after it was dec twice
  3857 000002A3 750E                    	jne	short scct_9s		; If not equal then not get version
  3858                                  	
  3859                                  	;mov	BX,(Minor_Version SHL 8) + Major_Version
  3860                                  	;mov	bx,1406h	; DOSCODE:4092h (MSDOS 6.21, MSDOS.SYS)
  3861 000002A5 BB0616                  	mov	bx,(MINOR_VERSION<<8)+MAJOR_VERSION
  3862                                  	
  3863                                  	;mov	dl,0
  3864                                  	;mov	DL,DOSREVNM ; 0
  3865                                  
  3866                                  	;xor	dh,dh			; assume vanilla DOS
  3867                                  	; 01/01/2024
  3868 000002A8 BA0000                  	mov	dx,0
  3869 000002AB 3836[1112]              	cmp	byte [DosHasHMA],dh ; 0
  3870                                  	;cmp	byte [DosHasHMA],0	; is DOS in HMA?  (M021)
  3871                                  	;je	short @F
  3872 000002AF 7402                    	je	short scct_6
  3873                                  	; 01/01/2024
  3874 000002B1 B610                    	mov	dh,10h
  3875                                  	;or	dh,10h
  3876                                  	;;or	DH,DOSINHMA ; 10h
  3877                                  ;@@:
  3878                                  scct_6:
  3879                                  
  3880                                  ;ifdef ROMDOS
  3881                                  ;	or	DH,DOSINROM ; 08h
  3882                                  ;endif ; ROMDOS
  3883                                  
  3884                                  scct_9s:
  3885 000002B3 5E                      	pop	SI
  3886 000002B4 58                      	pop	AX
  3887 000002B5 1F                      	pop	DS
  3888                                  scct_9f:
  3889 000002B6 CF                      	iret
  3890                                  
  3891                                  SetCtrlShortEntry:			; This allows a conditional entry
  3892                                  					; from main dispatch code
  3893 000002B7 EBAE                    	jmp	SHORT _$SET_CTRL_C_TRAPPING
  3894                                  
  3895                                  ; ==========================================================================
  3896                                  ;									   
  3897                                  ; The following two routines are dispatched to directly with ints disabled
  3898                                  ; immediately after the int 21h entry.	no DIS state is set.
  3899                                  ;
  3900                                  ; $Set_current_PDB takes BX and sets it to be the current process
  3901                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  3902                                  ;
  3903                                  ; ==========================================================================
  3904                                  
  3905                                  _$SET_CURRENT_PDB:
  3906 000002B9 1E                      	push	DS
  3907                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3908 000002BA 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3909 000002BF 891E[3003]              	mov	[CurrentPDB],BX		; Set new PSP segment from caller's BX
  3910 000002C3 1F                      	pop	DS
  3911 000002C4 CF                      	iret
  3912                                  
  3913                                  ; ==========================================================================
  3914                                  ;
  3915                                  ; $get_current_PDB returns in BX the current process
  3916                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  3917                                  ;
  3918                                  ; ==========================================================================
  3919                                  
  3920                                  _$GET_CURRENT_PDB:
  3921 000002C5 1E                      	push	DS
  3922                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3923 000002C6 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3924 000002CB 8B1E[3003]              	mov	BX,[CurrentPDB]		; Return current PSP segment in BX
  3925 000002CF 1F                      	pop	DS
  3926 000002D0 CF                      	iret
  3927                                  
  3928                                  ; ==========================================================================
  3929                                  ;
  3930                                  ; Sets the Printer Flag to whatever is in AL.
  3931                                  ; NOTE: THIS PROCEDURE IS SUBJECT TO CHANGE!!!
  3932                                  ;
  3933                                  ; ==========================================================================
  3934                                  
  3935                                  _$SET_PRINTER_FLAG:
  3936 000002D1 1E                      	push	ds
  3937                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3938 000002D2 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3939 000002D7 A2[A00A]                	mov	[PRINTER_FLAG],AL 	; Set printer flag from caller's AL
  3940 000002DA 1F                      	pop	ds
  3941 000002DB CF                      	iret
  3942                                  
  3943                                  ; 01/05/2019 - Retro DOS v4.0
  3944                                  ; 08/07/2018 - Retro DOS v3.0
  3945                                  ; (MSDISP.ASM, MSDOS 6.0, 1991)
  3946                                  
  3947                                  ; ----------------------------------------------------------------------------
  3948                                  ; BREAK   <System call entry points and dispatcher>
  3949                                  ; ----------------------------------------------------------------------------
  3950                                  
  3951                                  ; DOSCODE:40CCh (MSDOS 6.21, MSDOS.SYS)
  3952                                  
  3953                                  ; ==========================================================================
  3954                                  ;
  3955                                  ; The Quit entry point is where all INT 20h's come from. These are old- style
  3956                                  ; exit system calls. The CS of the caller indicates which Process is dying.
  3957                                  ; The error code is presumed to be 0. We simulate an ABORT system call.
  3958                                  ;
  3959                                  ; ==========================================================================
  3960                                  
  3961                                  SYSTEM_CALL:    ; PROC NEAR
  3962                                  
  3963                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3964                                  ; DOSCODE:40BFh (MSDOS 5.0, MSDOS.SYS)
  3965                                  
  3966                                  ;entry	QUIT				
  3967                                  QUIT:				; INT 20H entry point	
  3968                                  	;MOV	AH,0
  3969 000002DC 30E4                    	xor	ah,ah ; 08/07/2018
  3970 000002DE EB36                    	JMP     SHORT SAVREGS
  3971                                  
  3972                                  ; ---------------------------------------------------------------------------
  3973                                  
  3974                                  	; The system call in AH is out of the range that we know how
  3975                                  	; to handle. We arbitrarily set the contents of AL to 0 and
  3976                                  	; IRET. Note that we CANNOT set the carry flag to indicate an
  3977                                  	; error as this may break some programs compatability.
  3978                                  
  3979                                  BADCALL:
  3980                                          ;MOV	AL,0
  3981 000002E0 30C0                    	xor	al,al ; 08/07/2018
  3982                                  IRETT:	; 06/05/2019
  3983                                  _IRET:
  3984 000002E2 CF                              IRET
  3985                                  
  3986                                  ; ---------------------------------------------------------------------------
  3987                                  
  3988                                  ; 01/05/2019 - Retro DOS v4.0
  3989                                  ; DOSCODE:40D3h (MSDOS 6.21 MSDOS.SYS)
  3990                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3991                                  ; DOSCODE:40C6h (MSDOS 5.0 MSDOS.SYS)
  3992                                  
  3993                                  	; An alternative method of entering the system is to perform a
  3994                                  	; CALL 5 in the program segment prefix with the contents of CL
  3995                                  	; indicating what system call the user would like. A subset of
  3996                                  	; the possible system calls is allowed here only the
  3997                                  	; CPM-compatible calls may get dispatched.
  3998                                  
  3999                                  		; System call entry point and dispatcher
  4000                                  CALL_ENTRY:
  4001 000002E3 1E                      	push	DS
  4002                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4003 000002E4 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4004 000002E9 8F06[EC05]              	pop	word [SAVEDS]		; Save original DS
  4005                                  
  4006 000002ED 58                              POP     AX                      ; IP from the long call at 5
  4007 000002EE 58                              POP     AX                      ; Segment from the long call at 5
  4008 000002EF 8F06[8405]              	POP	WORD [USER_SP]		; IP from the CALL 5
  4009                                  
  4010                                  		; Re-order the stack to simulate an interrupt 21.
  4011                                  
  4012 000002F3 9C                      	PUSHF				; Start re-ordering the stack
  4013 000002F4 FA                      	CLI
  4014 000002F5 50                              PUSH    AX                      ; Save segment
  4015 000002F6 FF36[8405]                      PUSH	WORD [USER_SP]		; Stack now ordered as if INT had been used
  4016                                  	; 04/11/2022
  4017                                  	; DOSCODE:40EAh (MSDOS 6.21 MSDOS.SYS)
  4018                                  	; DOSCODE:40DDh (MSDOS 5.0 MSDOS.SYS)
  4019 000002FA FF36[EC05]              	push	word [SAVEDS]
  4020 000002FE 1F                      	pop	ds
  4021                                  	;
  4022                                  	;cmp	cl,36
  4023 000002FF 80F924                          CMP     CL,MAXCALL              ; This entry point doesn't get as many calls
  4024 00000302 77DC                            JA      SHORT BADCALL
  4025 00000304 88CC                            MOV     AH,CL
  4026                                  	; 08/07/2018
  4027 00000306 EB0E                    	jmp	short SAVREGS
  4028                                  
  4029                                  ; ---------------------------------------------------------------------------
  4030                                  
  4031                                  ; 01/05/2019 - Retro DOS v4.0
  4032                                  
  4033                                  	; This is the normal INT 21 entry point. We first perform a
  4034                                  	; quick test to see if we need to perform expensive DOS-entry
  4035                                  	; functions. Certain system calls are done without interrupts
  4036                                  	; being enabled.
  4037                                  
  4038                                  	;entry	COMMAND 		; Interrupt call entry point (int 21h)
  4039                                  
  4040                                  ; DOSCODE:40F8h (MSDOS 6.21, MSDOS.SYS)
  4041                                  ; 04/11/2022
  4042                                  ; DOSCODE:40EBh (MSDOS 5.0, MSDOS.SYS)
  4043                                  
  4044                                  COMMAND:
  4045                                  	; 22/12/2022
  4046 00000308 FA                      	cli
  4047                                  
  4048                                  	; 01/05/2019 - Retro DOS v4.0
  4049                                  	; 08/07/2018 - Retro DOS v3.0
  4050                                  
  4051                                  ; 22/12/2022
  4052                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4053                                  	;IF	NOT IBM
  4054 00000309 80FCF8                  	CMP	AH,SET_OEM_HANDLER
  4055 0000030C 7203                    	JB	SHORT NOTOEM
  4056 0000030E E97A01                  	JMP	_$SET_OEM_HANDLER
  4057                                  
  4058                                  NOTOEM:
  4059                                  	;ENDIF
  4060                                  
  4061                                  ; DOSCODE:40F8h (MSDOS 6.21, MSDOS.SYS)
  4062                                  ; DOSCODE:40EBh (MSDOS 5.0, MSDOS.SYS)
  4063                                  
  4064                                  	; 22/12/2022
  4065                                  	;cli	; 08/07/2018
  4066                                  
  4067                                  _COMMAND: ; MSDOS 3.3 (IBM)
  4068                                  	;cmp	ah,6Ch   ; MSDOS 6.21 ; Max int 21h function call number
  4069                                  	; 04/11/2022
  4070 00000311 80FC6C                  	CMP     AH,MAXCOM  ; 6Ch for MSDOS 6.0 (6.21,6.22) & MSDOS 5.0
  4071                                  	;JBE	SHORT SAVREGS
  4072 00000314 77CA                            JA	SHORT BADCALL ; 08/07/2018
  4073                                  
  4074                                  	; 31/05/2019
  4075                                  
  4076                                  	; The following set of calls are issued by the server at
  4077                                  	; *arbitrary* times and, therefore, must be executed on
  4078                                  	; the user's entry stack and executed with interrupts off.
  4079                                  
  4080                                  SAVREGS:
  4081                                  	; 01/05/2019 - Retro DOS v4.0
  4082                                  	; 10/08/2018
  4083                                  	; 08/07/2018 - Retro DOS v3.0
  4084 00000316 80FC33                  	cmp	ah,33h			; Check Minimum special case #
  4085                                  	;;je	_$SET_CTRL_C_TRAPPING
  4086                                  	;je	short SetCtrlShortEntry ; If equal jmp directly to function
  4087 00000319 7218                    	jb	short SaveAllRegs	; Not special case so continue	
  4088                                  	; 04/11/2022
  4089 0000031B 749A                    	je	short SetCtrlShortEntry ; If equal jmp directly to function
  4090 0000031D 80FC64                  	cmp	ah,64h			; Check Max case number
  4091 00000320 7711                    	ja	short SaveAllRegs	; Not special case so continue
  4092 00000322 74AD                    	je	short _$SET_PRINTER_FLAG ; If equal jmp directly to function
  4093 00000324 80FC51                  	cmp	ah,51h			; Is this a Get PSP call (51h)?
  4094 00000327 749C                    	je	short _$GET_CURRENT_PDB	; Yes, jmp directly to function
  4095 00000329 80FC62                  	cmp	ah,62h			; Is this a Get PSP call (62h)?
  4096 0000032C 7497                    	je	short _$GET_CURRENT_PDB	; Yes, jmp directly to function
  4097 0000032E 80FC50                  	cmp     ah,50h			; Is this a Set PSP call (50h) ?
  4098 00000331 7486                    	je	short _$SET_CURRENT_PDB	; Yes, jmp directly to function
  4099                                  
  4100                                  SaveAllRegs:
  4101                                  	; 01/05/2019 - Retro DOS v4.0
  4102                                  
  4103 00000333 06                              push	ES
  4104 00000334 1E                      	push	DS
  4105 00000335 55                      	push	BP
  4106 00000336 57                      	push	DI
  4107 00000337 56                      	push	SI
  4108 00000338 52                      	push	DX
  4109 00000339 51                      	push	CX
  4110 0000033A 53                      	push	BX
  4111 0000033B 50                      	push	AX
  4112                                  
  4113 0000033C 8CD8                    	mov	AX,DS
  4114                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4115 0000033E 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4116 00000343 A3[EC05]                	mov	[SAVEDS],AX		; save caller's DS
  4117 00000346 891E[EA05]              	mov	[SAVEBX],BX
  4118                                  
  4119                                          ;INC     BYTE [INDOS]		; Flag that we're in the DOS
  4120                                  	
  4121                                  	; 08/07/2018 - Retro DOS v3.0        
  4122                                  	;xor     ax,ax
  4123                                  	;mov     [USER_ID],ax
  4124                                  	;mov     ax,[CurrentPDB]
  4125                                  	;mov     [PROC_ID],ax
  4126                                  
  4127                                  	; 01/05/2019
  4128                                  
  4129                                  	; Note: Nsp and Nss have to be unconditionally initialized here 
  4130                                  	; even if InDOS is zero. Programs like CROSSTALK 3.7 depend on
  4131                                  	; this!!!
  4132                                  
  4133 0000034A A1[8405]                	MOV     AX,[USER_SP]
  4134 0000034D A3[F205]                        MOV     [NSP],AX
  4135 00000350 A1[8605]                        MOV     AX,[USER_SS]
  4136 00000353 A3[F005]                        MOV     [NSS],AX
  4137                                  
  4138 00000356 31C0                    	xor	AX,AX ; 0
  4139 00000358 A2[7205]                	mov	[FSHARING],AL		; allow redirection
  4140                                  
  4141 0000035B F606[3010]01            	test	byte [IsWin386],1	; WIN386 patch. Do not update USER_ID
  4142 00000360 7503                    	jnz	short set_indos_flag	; if win386 present
  4143 00000362 A3[3E03]                	mov	[USER_ID],AX
  4144                                  set_indos_flag:
  4145 00000365 FE06[2103]              	INC     BYTE [INDOS]		; Flag that we're in the DOS
  4146                                  
  4147 00000369 8926[8405]                      MOV     [USER_SP],SP
  4148 0000036D 8C16[8605]                      MOV     [USER_SS],SS
  4149                                  
  4150 00000371 A1[3003]                	mov	AX,[CurrentPDB]
  4151 00000374 A3[3C03]                	mov	[PROC_ID],AX
  4152 00000377 8ED8                    	mov	DS,AX
  4153 00000379 58                      	pop	AX
  4154 0000037A 50                      	push	AX
  4155                                  
  4156                                  	; save user stack in his area for later returns (possibly from EXEC)
  4157                                  
  4158 0000037B 89262E00                        MOV     [PDB.USER_STACK],SP
  4159 0000037F 8C163000                        MOV     [PDB.USER_STACK+2],SS
  4160                                  
  4161                                  	; 18/07/2018
  4162                                  	;mov	byte [CS:FSHARING], 0
  4163                                  
  4164                                  	;MOV     BX,CS			; no holes here.
  4165                                  	;MOV     SS,BX
  4166                                  
  4167                                  	;getdseg <ss>			; ss -> dosdat, already flag is CLI
  4168 00000383 2E8E16[0700]            	mov	ss,[cs:DosDSeg]
  4169                                  					;entry	REDISP
  4170                                  REDISP:
  4171 00000388 BC[A007]                        MOV     SP,AUXSTACK		; Enough stack for interrupts
  4172 0000038B FB                              STI                             ; stack is in our space now...
  4173                                  
  4174 0000038C 8CD3                    	mov	bx,ss
  4175 0000038E 8EDB                    	mov	ds,bx
  4176                                  
  4177 00000390 93                      	xchg	ax,bx
  4178                                  
  4179 00000391 31C0                    	xor	ax,ax ; 0
  4180                                  
  4181                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4182                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:416Eh  (from org 3DD0h)
  4183                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:417Bh (from org 3DE0h)
  4184                                  
  4185                                  	; (Note: ss: segment prefix was not needed here! ds=ss ! -04/11/2022-)
  4186                                  
  4187                                  	;mov	[ss:EXTOPEN_ON],al ; 0	; Clear extended open flag
  4188                                  	;;and	word [ss:DOS34_FLAG],EXEC_AWARE_REDIR
  4189                                  	;and	word [ss:DOS34_FLAG],800h ; clear all bits except bit 11
  4190                                  	;mov	[ss:CONSWAP],al  ; 0	; random clean up of possibly mis-set flags
  4191                                  	;mov	[ss:NoSetDir],al ; 0	; set directories on search
  4192                                  	;mov	[ss:FAILERR],al ; 0	; FAIL not in progress
  4193                                  	;inc	ax
  4194                                  	;;inc	AL			; AL = 1
  4195                                  	;mov	[ss:IDLEINT],al		; presume that we can issue INT 28
  4196                                  
  4197                                  	; 15/12/2022
  4198 00000393 A2[F605]                	mov	[EXTOPEN_ON],al ; 0	; Clear extended open flag
  4199                                  	;and	word [DOS34_FLAG],EXEC_AWARE_REDIR
  4200 00000396 8126[1106]0008          	and	word [DOS34_FLAG],800h	; clear all bits except bit 11
  4201 0000039C A2[5703]                	mov	[CONSWAP],al  ; 0	; random clean up of possibly mis-set flags
  4202                                  	;mov	byte [IDLEINT],1
  4203 0000039F A2[4C03]                	mov	[NoSetDir],al ; 0	; set directories on search
  4204 000003A2 A2[4A03]                	mov	[FAILERR],al ; 0	; FAIL not in progress
  4205 000003A5 40                      	inc	ax
  4206                                  	;inc	al			; AL = 1
  4207 000003A6 A2[5803]                	mov	[IDLEINT],al		; presume that we can issue INT 28
  4208                                  
  4209 000003A9 93                      	XCHG	AX,BX			; Restore AX and BX = 1		
  4210                                  
  4211 000003AA 88E3                    	MOV     BL,AH			
  4212 000003AC D1E3                            SHL     BX,1			; 2 bytes per call in table
  4213                                         
  4214 000003AE FC                      	CLD
  4215                                  		; Since the DOS maintains mucho state information across system
  4216                                  		; calls, we must be very careful about which stack we use.
  4217                                  		; First, all abort operations must be on the disk stack. This
  4218                                  		; is due to the fact that we may be hitting the disk (close
  4219                                  		; operations, flushing) and may need to report an INT 24.
  4220                                          
  4221 000003AF 08E4                    	OR      AH,AH
  4222 000003B1 7416                            JZ      SHORT DSKROUT		; ABORT
  4223                                  
  4224                                          ;CMP	AH,12
  4225                                          ;JBE	SHORT IOROUT		; Character I/O
  4226                                          ;CMP	AH,GET_CURRENT_PDB      ; INT 24 needs GET,SET PDB
  4227                                          ;JZ	SHORT IOROUT
  4228                                          ;CMP	AH,SET_CURRENT_PDB
  4229                                          ;JNZ	SHORT DSKROUT
  4230                                  
  4231                                  		; Second, PRINT and PSPRINT and the server issue
  4232                                  		; GetExtendedError calls at INT 28 and INT 24 time.
  4233                                  		; This call MUST, therefore, use the AUXSTACK.
  4234                                  
  4235                                  	; 10/08/2018
  4236 000003B3 80FC59                  	cmp     ah,GETEXTENDEDERROR ; 59h
  4237 000003B6 7434                    	je      short DISPCALL
  4238                                  	
  4239                                  	; 01/05/2019
  4240                                  	
  4241                                  		; Old 1-12 system calls may be either on the IOSTACK (normal
  4242                                  		; operation) or on the AUXSTACK (at INT 24 time).
  4243                                  
  4244 000003B8 80FC0C                  	cmp     ah,12 ; STD_CON_INPUT_FLUSH ; 0Ch
  4245 000003BB 770C                    	ja      short DSKROUT
  4246                                  
  4247                                  IOROUT:
  4248                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4249                                  	; (ss: prefix was not needed here! ds=ss)
  4250                                  	;cmp	byte [ss:ERRORMODE],0	; Are we in an INT 24? 
  4251                                  	; 15/12/2022
  4252 000003BD 803E[2003]00            	cmp     BYTE [ERRORMODE],0	; Are we in an INT 24?
  4253 000003C2 7528                            JNZ     SHORT DISPCALL		; Stay on AUXSTACK if INT 24
  4254 000003C4 BC[A00A]                        MOV     SP,IOSTACK
  4255 000003C7 EB23                            JMP     SHORT DISPCALL
  4256                                  
  4257                                  		; We are on a system call that is classified as "the rest".
  4258                                  		; We place ourselves onto the DSKSTACK and away we go.
  4259                                  		; We know at this point:
  4260                                  		; *  An INT 24 cannot be in progress. Therefore we reset
  4261                                  		;    ErrorMode and WpErr
  4262                                  		; *  That there can be no critical sections in effect.
  4263                                  		;    We signal the server to remove all the resources.
  4264                                  
  4265                                  DSKROUT:
  4266                                  	; 01/01/2024
  4267                                  	; 15/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4268                                  	; 08/07/2018 - Retro DOS v3.0
  4269 000003C9 A3[3A03]                	mov     [USER_IN_AX],ax		; Remember what user is doing
  4270                                  	; 01/01/2024
  4271                                  	;mov	byte [EXTERR_LOCUS],1	; errLOC_Unk (Default)
  4272                                  	;MOV	BYTE [WPERR],-1		; error mode, so good place to
  4273                                  	                   		; make sure flags are reset
  4274 000003CC C706[2203]FF01          	mov	word [WPERR],1FFh ; (PCDOS 7.1 IBMDOS.COM))
  4275                                  
  4276                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4277                                  	; (ss: prefix was not needed here! ds=ss)
  4278                                  
  4279                                  	;mov	[ss:USER_IN_AX],ax	; Remember what user is doing
  4280                                  	;mov	byte [ss:EXTERR_LOCUS],1 ; errLOC_Unk (Default)
  4281                                  	;mov	byte [ss:ERRORMODE],0	; Cannot make non 1-12 calls in
  4282                                  	;mov	byte [ss:WPERR],-1	; error mode, so good place to
  4283                                                                          ; make sure flags are reset
  4284 000003D2 50                      	push    ax
  4285 000003D3 B482                    	mov     ah,82h			; Release all resource information
  4286 000003D5 CD2A                    	int     2Ah 		; Microsoft Networks 
  4287                                  				; END DOS CRITICAL SECTIONS 0 THROUGH 7
  4288 000003D7 58                      	pop     ax
  4289                                  
  4290                                  		; Since we are going to be running on the DSKStack and since
  4291                                  		; INT 28 people will use the DSKStack, we must turn OFF the
  4292                                  		; generation of INT 28's.
  4293                                  
  4294                                  	; 15/12/2022
  4295                                  	;mov     byte [ss:IDLEINT],0
  4296                                  	;
  4297                                          ;mov	sp,DSKSTACK
  4298                                  	;test	byte [ss:CNTCFLAG],-1  ; 0FFh
  4299                                          ;jz	short DISPCALL
  4300                                  
  4301 000003D8 C606[5803]00            	mov     byte [IDLEINT],0
  4302                                  
  4303 000003DD BC[2009]                	MOV     SP,DSKSTACK
  4304 000003E0 F606[3703]FF            	TEST    BYTE [CNTCFLAG],-1
  4305 000003E5 7405                    	JZ      SHORT DISPCALL
  4306                                  
  4307 000003E7 50                              PUSH    AX
  4308                                          ;invoke	DSKSTATCHK
  4309 000003E8 E8404B                          CALL	DSKSTATCHK
  4310 000003EB 58                      	POP     AX
  4311                                  DISPCALL:
  4312                                  	; 01/05/2019 - Retro DOS v4.0
  4313 000003EC 2E8B9F[EA00]            	mov	bx,[CS:BX+DISPATCH]
  4314                                  
  4315                                  	; 15/12/2022
  4316 000003F1 871E[EA05]              	xchg	bx,[SAVEBX]
  4317 000003F5 8E1E[EC05]              	MOV	DS,[SAVEDS]
  4318                                  
  4319                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4320                                  	; (ss: prefix was not needed here! ds=ss)        
  4321                                  	;xchg	bx,[ss:SAVEBX]
  4322                                  	;mov	ds,[ss:SAVEDS]
  4323                                  
  4324 000003F9 36FF16[EA05]            	call	word [SS:SAVEBX] ; near call
  4325                                  
  4326                                  	; The EXEXA20OFF bit of DOS_FLAG will now be unconditionally cleared
  4327                                  	; here. Please see under M003, M009 and M068 tags in dossym.inc
  4328                                  	; for explanation. Also NOTE that a call to ExecReady (ax=4b05) will
  4329                                  	; return to LeaveDos and hence will not clear this bit. This is 
  4330                                  	; because this bit is used to indicate to the next int 21 call that
  4331                                  	; the previous int 21 was an exec.
  4332                                  	;
  4333                                  	; So do not add any code between the call above and the label 
  4334                                  	; LeaveDOS if it needs to be executed even for ax=4b05
  4335                                  
  4336                                  	;and	byte [ss:DOS_FLAG],~EXECA20OFF
  4337 000003FE 368026[8600]FB          	and	byte [ss:DOS_FLAG],0FBh
  4338                                  
  4339                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4340                                  ; DOSCODE:41F7h
  4341                                  
  4342                                  ; 01/01/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
  4343                                  ; DOSCODE:4204h
  4344                                  
  4345                                  ;entry LEAVE
  4346                                  ;;;_LEAVE:				; Exit from a system call
  4347                                  LeaveDOS: ; 18/07/2018 
  4348                                  ;ASSUME	SS:NOTHING			; User routines may misbehave
  4349 00000404 FA                      	CLI
  4350                                  
  4351                                  	; 01/05/2019
  4352                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4353 00000405 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4354 0000040A 803E[8500]00            	cmp	byte [A20OFF_COUNT],0	; M068: Q: is count 0
  4355 0000040F 7526                    	jne	short disa20		; M068: N: dec count and turn a20 off
  4356                                  
  4357                                  LeaveA20On:
  4358 00000411 FE0E[2103]                      DEC     BYTE [INDOS]
  4359                                          ; 04/11/2022
  4360 00000415 8E16[8605]              	mov	ss,[USER_SS]
  4361 00000419 8B26[8405]              	MOV     SP,[USER_SP]
  4362                                  	;MOV	SS,[USER_SS]
  4363 0000041D 89E5                    	MOV     BP,SP
  4364                                  	;MOV	[BP.user_AX],AL	
  4365                                          ; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4366                                  	;;mov	[bp+0],al ; MSDOS 5.0 MSDOS.SYS - DOSCODE:4212h
  4367                                  	;MOV	[BP+user_env.user_AX],AL  ; user_env.user_AX = 0
  4368                                  
  4369                                  	; 15/12/2022
  4370 0000041F 884600                  	MOV	[BP],AL	; mov [bp+0],al
  4371                                  	
  4372                                  	;MOV	AX,[NSP]
  4373                                          ;MOV	[USER_SP],AX
  4374                                          ;MOV	AX,[NSS]
  4375                                          ;MOV	[USER_SS],AX
  4376                                  	; 01/01/2024
  4377 00000422 C406[F005]              	les	ax,[NSS] ; (PCDOS 7.1 IBMDOS.COM)
  4378 00000426 A3[8605]                	mov	[USER_SS],ax
  4379 00000429 8C06[8405]              	mov	[USER_SP],es
  4380                                  
  4381 0000042D 58                      	pop	AX
  4382 0000042E 5B                      	pop	BX
  4383 0000042F 59                      	pop	CX
  4384 00000430 5A                      	pop	DX
  4385 00000431 5E                      	pop	SI
  4386 00000432 5F                      	pop	DI
  4387 00000433 5D                      	pop	BP
  4388 00000434 1F                      	pop	DS
  4389 00000435 07                      	pop	ES
  4390                                  
  4391 00000436 CF                              IRET
  4392                                  
  4393                                  disa20:	   				; M068 - Start
  4394 00000437 8B1E[6300]              	mov	bx,[A20OFF_PSP]		; bx = PSP for which a20 to be off'd
  4395 0000043B 3B1E[3003]              	cmp	bx,[CurrentPDB]		; Q: do the PSP's match
  4396 0000043F 75D0                    	jne	short LeaveA20On	; N: don't clear bit and don't turn 
  4397                                  					;    a20 off
  4398                                  					; Y: turn a20 off and dec a20off_count
  4399 00000441 FE0E[8500]              	dec	byte [A20OFF_COUNT]	; M068 - End
  4400                                   					; Start - M004
  4401 00000445 1E                      	push	ds			; segment of stub
  4402 00000446 BB[2D11]                	mov	bx,disa20_iret		; offset in stub
  4403 00000449 53                      	push	bx
  4404 0000044A CB                      	retf	  			; go to stub
  4405                                  					; End - M004
  4406                                  ;SYSTEM_CALL ENDP
  4407                                  
  4408                                  ; DOSCODE:424Ch (MSDOS 6.21, MSDOS.SYS)
  4409                                  ; 04/11/2022
  4410                                  ; DOSCODE:423Fh (MSDOS 5.0, MSDOS.SYS)
  4411                                  
  4412                                  ; ==========================================================================
  4413                                  ;
  4414                                  ; Restore_World restores all registers ('cept SS:SP, CS:IP, flags) from
  4415                                  ; the stack prior to giving the user control
  4416                                  ;
  4417                                  ; ==========================================================================
  4418                                  
  4419                                  ; 01/05/2019 - Retro DOS v4.0
  4420                                  
  4421                                          ;procedure restore_world,NEAR
  4422                                  restore_world:
  4423                                  	;getdseg <es>		; es -> dosdata
  4424 0000044B 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4425                                  
  4426 00000450 268F06[EE05]                    POP	WORD [ES:RESTORE_TMP]
  4427                                  
  4428 00000455 58                              POP     AX
  4429 00000456 5B                              POP     BX
  4430 00000457 59                              POP     CX
  4431 00000458 5A                              POP     DX
  4432 00000459 5E                              POP     SI
  4433 0000045A 5F                              POP     DI
  4434 0000045B 5D                              POP     BP
  4435 0000045C 1F                              POP     DS
  4436                                  
  4437 0000045D 26FF26[EE05]                   	jmp	word [ES:RESTORE_TMP]
  4438                                  
  4439                                  ;restore_world	ENDP
  4440                                  
  4441                                  ; 01/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDISP.ASM, 1991)
  4442                                  
  4443                                  ; DOSCODE:4263h (MSDOS 6.21, MSDOS.SYS)
  4444                                  ; 04/11/2022
  4445                                  ; DOSCODE:4256h (MSDOS 5.0, MSDOS.SYS)
  4446                                  
  4447                                  ; ==========================================================================
  4448                                  ;
  4449                                  ; Save_World saves complete registers on the stack
  4450                                  ;
  4451                                  ; ==========================================================================
  4452                                  
  4453                                          ;procedure save_world,NEAR
  4454                                  save_world:
  4455                                  	;getdseg <es>		; es -> dosdata
  4456 00000462 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4457                                  
  4458 00000467 268F06[EE05]                    POP	WORD [ES:RESTORE_TMP]
  4459                                  
  4460                                  	; 12/05/2019
  4461                                          
  4462 0000046C 1E                      	PUSH    DS
  4463 0000046D 55                              PUSH    BP
  4464 0000046E 57                              PUSH    DI
  4465 0000046F 56                              PUSH    SI
  4466 00000470 52                              PUSH    DX
  4467 00000471 51                              PUSH    CX
  4468 00000472 53                              PUSH    BX
  4469 00000473 50                              PUSH    AX
  4470                                  
  4471 00000474 26FF36[EE05]            	push	word [ES:RESTORE_TMP]
  4472                                  
  4473 00000479 55                      	push	BP		
  4474 0000047A 89E5                    	mov	BP,SP
  4475 0000047C 8E4614                  	mov	ES,[BP+20]	; es was pushed before call
  4476 0000047F 5D                      	pop	BP
  4477                                  	
  4478 00000480 C3                      	retn
  4479                                  
  4480                                  ;save_world	ENDP
  4481                                  
  4482                                  ; 01/05/2019
  4483                                  
  4484                                  ; DOSCODE:4282h (MSDOS 6.21, MSDOS.SYS)
  4485                                  ; 04/11/2022
  4486                                  ; DOSCODE:4275h (MSDOS 5.0, MSDOS.SYS)
  4487                                  
  4488                                  ; ==========================================================================
  4489                                  ;
  4490                                  ; Get_User_Stack returns the user's stack (and hence registers) in DS:SI
  4491                                  ;
  4492                                  ; ==========================================================================
  4493                                  
  4494                                          ;procedure get_user_stack,NEAR
  4495                                  Get_User_Stack:
  4496                                          ;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4497 00000481 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4498 00000486 C536[8405]                      lds	si,[USER_SP]
  4499 0000048A C3                      	retn
  4500                                  
  4501                                  ;get_user_stack  ENDP
  4502                                  
  4503                                  ; 22/12/2022
  4504                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
  4505                                  ;%if 0
  4506                                  
  4507                                  ; ---------------------------------------------------------------------------
  4508                                  ;
  4509                                  ; Set_OEM_Handler -- Set OEM sys call address and handle OEM Calls
  4510                                  ; Inputs:
  4511                                  ;	User registers, User Stack, INTS disabled
  4512                                  ;	If CALL F8, DS:DX is new handler address
  4513                                  ; Function:
  4514                                  ;	Process OEM INT 21 extensions
  4515                                  ; Outputs:
  4516                                  ;	Jumps to OEM_HANDLER if appropriate
  4517                                  ;
  4518                                  ; ---------------------------------------------------------------------------
  4519                                  
  4520                                  ;IF	NOT IBM
  4521                                  
  4522                                  _$SET_OEM_HANDLER:
  4523                                  	; 01/05/2019 - Retro DOS v4.0
  4524                                  	
  4525                                  	;(cmp	ah,SET OEM HANDLER  ; 0F8h)
  4526                                  	;(jb	short NOTOOEM)
  4527                                  
  4528 0000048B 06                      	push	es ; *
  4529                                  	;getdseg <es>			; es -> dosdata
  4530 0000048C 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4531                                  
  4532 00000491 750C                    	jne	short check_trueversion_request ; check Retro DOS true version
  4533                                  						; (message) request	
  4534                                  	; AH = 0F8h = SET OEM HANDLER
  4535                                  
  4536 00000493 268916[1400]            	MOV     [es:OEM_HANDLER],DX	; Set Handler
  4537 00000498 268C1E[1600]            	MOV     [es:OEM_HANDLER+2],DS
  4538                                  
  4539 0000049D 07                      	pop	es ; *
  4540                                  
  4541 0000049E CF                      	IRET                            ; Quick return, Have altered no registers
  4542                                  
  4543                                  check_trueversion_request:
  4544                                  	; 18/07/2019 - Retro DOS v3.0
  4545                                  
  4546                                  	; Retro DOS v2.0 - 20/04/2018
  4547 0000049F 83F8FF                  	CMP	AX,0FFFFh
  4548                                  	; 18/07/2018
  4549 000004A2 7520                    	jne	short DO_OEM_FUNC ; 01/05/2019
  4550                                  
  4551                                  	; 01/05/2019
  4552 000004A4 07                      	pop	es ; *
  4553                                  
  4554 000004A5 B40E                    	mov	ah,0Eh
  4555                                  
  4556                                  	; Retro DOS v4.0 feature only!
  4557 000004A7 81FBA101                	cmp	bx,417  ; Signature to bypass
  4558                                  			; Retro DOS true version message	
  4559 000004AB 7414                    	je	short true_version_iret
  4560                                  
  4561 000004AD 56                      	push	si
  4562 000004AE 53                      	push	bx
  4563                                  
  4564 000004AF BE[BF00]                	mov	si,RETRODOSMSG
  4565                                  wrdosmsg:
  4566                                  	;movb	ah,0Eh
  4567 000004B2 BB0700                  	mov	bx,7
  4568                                  wrdosmsg_nxt:
  4569 000004B5 2EAC                    	cs	lodsb
  4570 000004B7 3C24                    	cmp	al,'$'
  4571 000004B9 7404                    	je	short wrdosmsg_ok		
  4572 000004BB CD10                    	int	10h
  4573 000004BD EBF6                    	jmp	short wrdosmsg_nxt
  4574                                  
  4575                                  wrdosmsg_ok:
  4576 000004BF 5B                      	pop	bx
  4577 000004C0 5E                      	pop	si
  4578                                  
  4579                                  true_version_iret:
  4580                                  	; ah = 0Eh
  4581                                  	;mov	al,40h ; Retro DOS v4.0
  4582                                  	; 
  4583                                  	;mov	al,41h ; Retro DOS v4.1 
  4584                                  	; 30/12/2022
  4585 000004C1 B042                    	mov	al,42h ; Retro DOS v4.2
  4586 000004C3 CF                      	iret
  4587                                  
  4588                                  	; If above F8 try to jump to handler
  4589                                  
  4590                                  DO_OEM_FUNC:
  4591                                  	; 01/05/2019
  4592 000004C4 26833E[1400]FF          	cmp     word [es:OEM_HANDLER],-1
  4593 000004CA 7504                    	JNE     short OEM_JMP
  4594 000004CC 07                      	pop	es ; *
  4595 000004CD E910FE                  	JMP     BADCALL                 ; Handler not initialized
  4596                                  OEM_JMP:
  4597 000004D0 06                      	push	es
  4598 000004D1 1F                      	pop	ds ; DOSDATA segment !
  4599 000004D2 07                      	pop	es ; *
  4600                                  
  4601                                  	; 22/12/2022
  4602 000004D3 FB                      	sti	; (enable interrupts before jumping to private handler)  
  4603                                  
  4604 000004D4 FF2E[1400]              	JMP     FAR [OEM_HANDLER]
  4605                                  
  4606                                  ;       ENDIF
  4607                                  
  4608                                  ; ---------------------------------------------------------------------------
  4609                                  
  4610                                  ;%endif
  4611                                  
  4612                                  ;============================================================================
  4613                                  ; MCODE.ASM, MSDOS 6.0, 1991
  4614                                  ;============================================================================
  4615                                  ; 17/07/2018 - Retro DOS v3.0
  4616                                  
  4617                                  ;	TITLE	MISC DOS ROUTINES - Int 25 and 26 handlers and other
  4618                                  ;	NAME	IBMCODE
  4619                                  
  4620                                  ;BREAK <NullDev -- Driver for null device>
  4621                                  
  4622                                  ; ROMDOS note:
  4623                                  ;	NUL device driver used to be here, but it was removed and placed in
  4624                                  ;	DOSDATA, because the entry points have to be in the segment as the
  4625                                  ;	header, which is also in DOSDATA.
  4626                                  
  4627                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>
  4628                                  
  4629                                  ;----------------------------------------------------------------------------
  4630                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
  4631                                  ;----------------------------------------------------------------------------
  4632                                  ; DOSCODE:428Ch (MSDOS 6.21 MSDOS.SYS)
  4633                                  ; DOSCODE:427Fh (MSDOS 5.0 MSDOS.SYS)
  4634                                  
  4635                                  ;Public MSC001S,MSC001E
  4636                                  ;MSC001S label byte
  4637                                  	;IF	IBM
  4638                                  ; Codes returned by BIOS
  4639                                  ERRIN:
  4640 000004D8 02                      	DB	2			; NO RESPONSE
  4641 000004D9 06                      	DB	6			; SEEK FAILURE
  4642 000004DA 0C                      	DB	12			; GENERAL ERROR
  4643 000004DB 04                      	DB	4			; BAD CRC
  4644 000004DC 08                      	DB	8			; SECTOR NOT FOUND
  4645 000004DD 00                      	DB	0			; WRITE ATTEMPT ON WRITE-PROTECT DISK
  4646                                  ERROUT:
  4647                                  ; DISK ERRORS RETURNED FROM INT 25 and 26
  4648 000004DE 80                      	DB	80H			; NO RESPONSE
  4649 000004DF 40                      	DB	40H			; Seek failure
  4650 000004E0 02                      	DB	2			; Address Mark not found
  4651 000004E1 10                      	DB	10H			; BAD CRC
  4652 000004E2 04                      	DB	4			; SECTOR NOT FOUND
  4653 000004E3 03                      	DB	3			; WRITE ATTEMPT TO WRITE-PROTECT DISK
  4654                                  
  4655                                  NUMERR	EQU	$-ERROUT
  4656                                  	;ENDIF
  4657                                  ;MSC001E label byte
  4658                                  ;----------------------------------------------------------------------------
  4659                                  
  4660                                  ;============================================================================
  4661                                  ; MSCODE.ASM - MSDOS 6.0 - 1991
  4662                                  ;============================================================================
  4663                                  ; 18/07/2018 - Retro DOS v3.0
  4664                                  ; 15/05/2019 - Retro DOS v4.0
  4665                                  
  4666                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>>
  4667                                  
  4668                                  ;   AbsSetup - setup for abs disk functions
  4669                                  ;----------------------------------------------------------------------------
  4670                                  
  4671                                  AbsSetup:
  4672                                  	; 02/01/2024
  4673 000004E4 1E                      	push	ds ; *
  4674 000004E5 16                      	push	ss
  4675 000004E6 1F                      	pop	ds
  4676 000004E7 FE06[2103]              	inc	byte [INDOS]
  4677                                  	;INC	byte [SS:INDOS]		; SS override
  4678 000004EB FB                      	STI
  4679 000004EC FC                      	CLD
  4680                                  	; 02/01/2024
  4681                                  	;PUSH	DS
  4682                                  	;push	ss
  4683                                  	;pop	ds
  4684 000004ED E80901                  	CALL	GETBP
  4685                                  	; 02/01/2024
  4686 000004F0 1F                      	pop	ds ; *
  4687 000004F1 7239                    	JC	short errdriv 		; PM. error drive ;AN000;
  4688                                  	;mov	word [es:bp+1Fh]
  4689 000004F3 26C7461FFFFF            	MOV	WORD [ES:BP+DPB.FREE_CNT],-1 ; do not trust user at all.
  4690                                  
  4691                                  	; 02/01/2024
  4692                                  ;errdriv:
  4693                                  ;	POP	DS
  4694                                  ;	jnc	short AbsSetup2
  4695                                  ;AbsSetup_retn:
  4696                                  ;	retn
  4697                                  
  4698                                  AbsSetup2:
  4699                                  	; 15/05/2019 - Retro DOS v4.0
  4700                                  	; MSDOS 6.0
  4701                                  					; SS override
  4702 000004F9 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0 ;>32mb	from API		;AN000;
  4703 00000500 E82F04                  	CALL	RW32_CONVERT		;>32mb convert 32bit format to 16bit ;AN000;
  4704 00000503 7227                    	jc	short AbsSetup_retn
  4705 00000505 E89C54                  	call	SET_RQ_SC_PARMS 	;LB. set up SC parms		;AN000;
  4706                                  
  4707                                  	; MSDOS 3.3 (& MSDOS 6.0)
  4708 00000508 1E                      	PUSH	DS
  4709 00000509 56                      	PUSH	SI
  4710 0000050A 50                      	PUSH	AX
  4711                                  
  4712 0000050B 16                      	push	ss
  4713 0000050C 1F                      	pop	ds
  4714                                  	
  4715 0000050D BE[BE03]                	MOV	SI,OPENBUF
  4716 00000510 8804                    	MOV	[SI],AL
  4717 00000512 800441                  	ADD	BYTE [SI],"A"
  4718 00000515 C744013A00              	MOV	WORD [SI+1],003AH ; ":",0
  4719 0000051A B80003                  	MOV	AX,0300H
  4720 0000051D F8                      	CLC
  4721 0000051E CD2A                    	INT	int_IBM ; int 2Ah	; Will set carry if shared
  4722                                  		
  4723                                  		; 04/11/2022
  4724                                  		; (INT 2Ah - AX = 0300h)
  4725                                  		; Microsoft Networks - CHECK DIRECT I/O
  4726                                  		; DS:SI -> ASCIIZ disk device name (may be full path or
  4727                                  		;    only drive specifier--must include the colon)
  4728                                  		; Return: CF clear if absolute disk access allowed
  4729                                  
  4730 00000520 58                      	POP	AX
  4731 00000521 5E                      	POP	SI
  4732 00000522 1F                      	POP	DS
  4733 00000523 7307                    	jnc	short AbsSetup_retn
  4734                                  
  4735                                  	;mov	word [ss:EXTERR],32h
  4736 00000525 36C706[2403]3200        	MOV	word [ss:EXTERR],error_not_supported
  4737                                  errdriv:	; 02/01/2024
  4738                                  AbsSetup_retn:
  4739 0000052C C3                      	retn
  4740                                  
  4741                                  ;---------------------------------------------------------------------------
  4742                                  ;
  4743                                  ; Procedure Name : ABSDRD
  4744                                  ;
  4745                                  ; Interrupt 25 handler. Performs absolute disk read.
  4746                                  ; Inputs:	AL - 0-based drive number
  4747                                  ;		DS:BX point to destination buffer
  4748                                  ;		CX number of logical sectors to read
  4749                                  ;		DX starting logical sector number (0-based)
  4750                                  ; Outputs:	Original flags still on stack
  4751                                  ;		Carry set
  4752                                  ;		    AH error from BIOS
  4753                                  ;		    AL same as low byte of DI from INT 24
  4754                                  ;
  4755                                  ;---------------------------------------------------------------------------
  4756                                          ;procedure   ABSDRD,FAR
  4757                                  ABSDRD:
  4758                                  	; 15/05/2019 - Retro DOS v4.0
  4759                                  	; MSDOS 6.21 (DOSCODE:42E5h)
  4760                                  	; 04/11/2022
  4761                                  	; MSDOS 5.0 (DOSCODE:42D8h)
  4762                                  	
  4763                                  	; MSDOS 6.0
  4764 0000052D FA                      	CLI
  4765                                  	
  4766                                  ;	set up ds to point to DOSDATA
  4767                                  
  4768 0000052E 50                      	push	ax			; preserve AX value
  4769 0000052F 8CD8                    	mov	ax,ds			; store DS value in AX
  4770                                  	;getdseg <ds>
  4771 00000531 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4772 00000536 A3[0A0D]                	mov	[TEMPSEG],ax		; store DS value in TEMPSEG
  4773 00000539 58                      	pop	ax			; restore AX value
  4774                                  
  4775                                  	; M072:
  4776                                  	; We shall save es on the user stack here. We need to use ES in
  4777                                  	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
  4778                                  	; time in order to restore the user stack.
  4779                                  
  4780 0000053A 06                      	push	es  ; ****		; M072
  4781                                  
  4782 0000053B 8C16[1B06]              	MOV	[AbsRdWr_SS],SS		; M013
  4783 0000053F 8926[1D06]              	MOV	[AbsRdWr_SP],SP		; M013
  4784                                  
  4785                                  ; 	set up ss to point to DOSDATA
  4786                                  ;
  4787                                  ; NOTE! Due to an obscure bug in the 80286, you cannot use the ROMDOS
  4788                                  ; version of the getdseg macro with the SS register! An interrupt will
  4789                                  ; sneak through.
  4790                                  
  4791                                  ;ifndef ROMDOS
  4792                                  	;getdseg <ss>			; cli in entry of routine
  4793 00000543 2E8E16[0700]            	mov     ss,[cs:DosDSeg]
  4794                                  ;else
  4795                                  ;	mov	ds, cs:[BioDataSeg]
  4796                                  ;	assume	ds:bdata
  4797                                  ;
  4798                                  ;	mov	ss, ds:[DosDataSg]
  4799                                  ;	assume	ss:DOSDATA
  4800                                  ;
  4801                                  ;endif ; ROMDOS
  4802                                  
  4803 00000548 BC[2009]                	MOV	SP,DSKSTACK
  4804                                  
  4805 0000054B 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore DS value
  4806                                  
  4807 0000054F 06                      	push	es ; *** (MSDOS 6.21)
  4808 00000550 E80FFF                  	call	save_world		; save all regs
  4809                                  
  4810 00000553 06                      	PUSH	ES ; **
  4811 00000554 E88DFF                  	CALL	AbsSetup
  4812 00000557 723D                    	JC	short ILEAVE
  4813                                  
  4814                                  	; Here is a gross temporary fix to get around a serious design flaw in
  4815                                  	;  the secondary cache. The secondary cache does not check for media
  4816                                  	;  changed (it should). Hence, you can change disks, do an absolute
  4817                                  	;  read, and get data from the previous disk. To get around this,
  4818                                  	;  we just won't use the secondary cache for absolute disk reads.
  4819                                  	;                                                      -mw 8/5/88
  4820                                  
  4821                                  	;EnterCrit critDisk
  4822 00000559 E8860D                  	call	ECritDisk
  4823 0000055C 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ; invalidate SC  ;AN000;
  4824                                  	;LeaveCrit critDisk
  4825 00000562 E8980D                  	call	LCritDisk
  4826                                  
  4827                                          ;invoke	DSKREAD
  4828 00000565 E8E230                  	CALL	DSKREAD
  4829 00000568 7513                            jnz	short ERR_LEAVE		;Jump if read unsuccessful.
  4830                                  
  4831 0000056A 89F9                            mov     cx,di
  4832 0000056C 368C1E[0E06]                    mov     [ss:TEMP_VAR2],ds
  4833 00000571 36891E[0C06]                    mov     [ss:TEMP_VAR],bx
  4834                                  
  4835                                  ;       CX = # of contiguous sectors read. (These constitute a block of
  4836                                  ;            sectors, also termed an "Extent".)
  4837                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
  4838                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
  4839                                  ;       ES:BP -> Drive Parameter Block (DPB).
  4840                                  ;
  4841                                  ;	The Buffer Queue must now be scanned: the contents of any dirty
  4842                                  ;	buffers must be "read" into the transfer memory block, so that the
  4843                                  ;       transfer memory reflects the most recent data.
  4844                                  
  4845                                  	;invoke	DskRdBufScan		;This trashes DS, but don't care.
  4846 00000576 E81533                          call	DskRdBufScan
  4847 00000579 EB1B                    	jmp     short ILEAVE
  4848                                  
  4849                                  TLEAVE:
  4850 0000057B 7419                    	JZ	short ILEAVE
  4851                                  
  4852                                  ERR_LEAVE:				; M039
  4853                                  	; 15/07/2018 - Retro DOS v3.0
  4854                                          ;IF	IBM
  4855                                  ; Translate the error code to ancient 1.1 codes
  4856 0000057D 06                              PUSH    ES ; *
  4857 0000057E 0E                              PUSH    CS
  4858 0000057F 07                              POP     ES
  4859 00000580 30E4                            XOR     AH,AH			; Nul error code
  4860                                  	;mov	cx,6
  4861 00000582 B90600                          MOV     CX,NUMERR		; Number of possible error conditions
  4862 00000585 BF[D804]                        MOV     DI,ERRIN		; Point to error conditions
  4863 00000588 F2AE                            REPNE   SCASB
  4864 0000058A 7504                            JNZ     SHORT LEAVECODE		; Not found
  4865                                  	;mov	ah,[ES:DI+5]
  4866 0000058C 268A6505                        MOV     AH,[ES:DI+NUMERR-1]	; Get translation
  4867                                  LEAVECODE:
  4868 00000590 07                              POP     ES ; *
  4869                                  	; 15/05/2019 - Retro DOS v4.0
  4870 00000591 36A3[B80D]              	mov	[ss:AbsDskErr],ax
  4871                                          ;ENDIF
  4872                                  
  4873 00000595 F9                              STC
  4874                                  ILEAVE:
  4875                                  	; 15/05/2019
  4876 00000596 07                              POP     ES ; **
  4877 00000597 E8B1FE                  	call	restore_world
  4878 0000059A 07                              pop	es ; *** (MSDOS 6.21)
  4879 0000059B FA                      	CLI
  4880 0000059C 36A1[B80D]              	mov     ax,[ss:AbsDskErr]	; restore error
  4881 000005A0 36FE0E[2103]            	DEC	BYTE [SS:INDOS]
  4882 000005A5 16                              push	ss			; M072 - Start
  4883 000005A6 07                      	pop	es			; es - dosdata
  4884 000005A7 268E16[1B06]                    mov	ss,[es:AbsRdWr_SS]	; M013
  4885 000005AC 268B26[1D06]            	mov	sp,[es:AbsRdWr_SP]	; M013
  4886 000005B1 07                      	pop	es  ; ****		; Note es was saved on user
  4887                                  					; stack at entry 
  4888                                  					; M072 - End
  4889 000005B2 FB                              STI
  4890 000005B3 CB                      	RETF   ; ! FAR return !
  4891                                  
  4892                                  ;ABSDRD	ENDP
  4893                                  
  4894                                  ;---------------------------------------------------------------------------
  4895                                  ;
  4896                                  ; Procedure Name : ABSDWRT
  4897                                  ;
  4898                                  ; Interrupt 26 handler. Performs absolute disk write.
  4899                                  ; Inputs:	AL - 0-based drive number
  4900                                  ;		DS:BX point to source buffer
  4901                                  ;		CX number of logical sectors to write
  4902                                  ;		DX starting logical sector number (0-based)
  4903                                  ; Outputs:	Original flags still on stack
  4904                                  ;		Carry set
  4905                                  ;		    AH error from BIOS
  4906                                  ;		    AL same as low byte of DI from INT 24
  4907                                  ;
  4908                                  ;---------------------------------------------------------------------------
  4909                                          ;procedure   ABSDWRT,FAR
  4910                                  ABSDWRT:
  4911                                  	; 15/05/2019 - Retro DOS v4.0
  4912                                  	; MSDOS 6.21 (DOSCODE:436Ch)
  4913                                  	; 04/11/2022
  4914                                  	; MSDOS 5.0 (DOSCODE:435Fh)
  4915                                  
  4916 000005B4 FA                      	CLI
  4917                                  
  4918                                  ;	set up ds to point to DOSDATA
  4919                                  
  4920 000005B5 50                      	push	ax
  4921 000005B6 8CD8                    	mov	ax,ds
  4922                                  	;getdseg <ds>
  4923 000005B8 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4924 000005BD A3[0A0D]                	mov	[TEMPSEG],ax
  4925 000005C0 58                      	pop	ax
  4926                                  
  4927                                  	; M072:
  4928                                  	; We shall save es on the user stack here. We need to use ES in
  4929                                  	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
  4930                                  	; time in order to restore the user stack.
  4931                                  
  4932 000005C1 06                      	push	es ; ****		; M072
  4933                                  
  4934 000005C2 8C16[1B06]              	MOV	[AbsRdWr_SS],SS		; M013
  4935 000005C6 8926[1D06]              	MOV	[AbsRdWr_SP],SP		; M013
  4936                                  
  4937                                  	; set up ss to point to DOSDATA
  4938                                  	;
  4939                                  	; NOTE! Due to an obscure bug in the 80286, you cannot use the 
  4940                                  	; ROMDOS version of the getdseg macro with the SS register!
  4941                                  	; An interrupt will sneak through.
  4942                                  
  4943                                  ;ifndef ROMDOS
  4944                                  	;getdseg <ss>			; cli in entry of routine
  4945 000005CA 2E8E16[0700]            	mov     ss,[cs:DosDSeg]
  4946                                  ;else
  4947                                  ;	mov	ds, cs:[BioDataSeg]
  4948                                  ;	assume	ds:bdata
  4949                                  ;
  4950                                  ;	mov	ss, ds:[DosDataSg]
  4951                                  ;	assume	ss:DOSDATA
  4952                                  ;
  4953                                  ;endif ; ROMDOS
  4954                                  
  4955 000005CF BC[2009]                	MOV	SP,DSKSTACK
  4956                                  		; we are now switched to DOS's disk stack
  4957                                  
  4958 000005D2 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore user's ds
  4959                                  
  4960 000005D6 06                      	push	es ; *** (MSDOS 6.21)
  4961                                  
  4962 000005D7 E888FE                  	call	save_world	      	; save all regs
  4963                                  
  4964 000005DA 06                      	PUSH	ES ; **
  4965 000005DB E806FF                  	CALL	AbsSetup
  4966 000005DE 72B6                    	JC	short ILEAVE
  4967                                  
  4968                                  	;EnterCrit critDisk
  4969 000005E0 E8FF0C                  	call	ECritDisk
  4970 000005E3 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ; invalidate SC ;AN000;
  4971 000005E9 E88B03                  	CALL	Fastxxx_Purge		 ; purge fatopen ;AN000;
  4972                                  	;LeaveCrit critDisk
  4973 000005EC E80E0D                  	call	LCritDisk
  4974                                  
  4975                                  ;M039
  4976                                  ;       DS:BX = transfer address (source data address).
  4977                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
  4978                                  ;	     sectors, also termed an "Extent".)
  4979                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
  4980                                  ;       ES:BP -> Drive Parameter Block (DPB).
  4981                                  ;       [CURSC_DRIVE] = -1 (invalid drive).
  4982                                  ;
  4983                                  ;       Free any buffered sectors which are in Extent; they are being over-
  4984                                  ;       written. Note that all the above registers are preserved for
  4985                                  ;       DSKWRITE.
  4986                                  
  4987 000005EF 1E                              push    ds
  4988                                  	;invoke	DskWrtBufPurge          ;This trashes DS.
  4989 000005F0 E89F35                  	call	DskWrtBufPurge
  4990 000005F3 1F                              pop     ds
  4991                                  ;M039
  4992                                  	;invoke	DSKWRITE
  4993 000005F4 E87730                  	call	DSKWRITE
  4994 000005F7 EB82                    	JMP	short TLEAVE
  4995                                  
  4996                                  ;ABSDWRT ENDP
  4997                                  
  4998                                  ;----------------------------------------------------------------------------
  4999                                  ;
  5000                                  ; Procedure Name : GETBP
  5001                                  ;
  5002                                  ; Inputs:
  5003                                  ;	AL = Logical unit number (A = 0)
  5004                                  ; Function:
  5005                                  ;	Find Drive Parameter Block
  5006                                  ; Outputs:
  5007                                  ;	ES:BP points to DPB
  5008                                  ;	[THISDPB] = ES:BP
  5009                                  ;	Carry set if unit number bad or unit is a NET device.
  5010                                  ;		Later case sets extended error error_I24_not_supported
  5011                                  ; No other registers alteredjjj
  5012                                  ;
  5013                                  ;----------------------------------------------------------------------------
  5014                                  
  5015                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5016                                  GETBP:
  5017                                  	; 15/05/2019 - Retro DOS v4.0
  5018                                  	; 11/07/2018 - Retro DOS v3.0
  5019 000005F9 50                      	PUSH	AX
  5020 000005FA 0401                    	ADD	AL, 1		; No increment; need carry flag
  5021 000005FC 7210                    	JC	SHORT SKIPGET
  5022 000005FE E8D362                  	CALL	GETTHISDRV
  5023                                  	; MSDOS 6.0
  5024 00000601 730B                    	JNC	SHORT SKIPGET		;PM. good drive		;AN000;
  5025                                  	
  5026                                  	; 23/03/2024 - Retro DOS v4.2
  5027                                  	;XOR	AH,AH			;DCR. ax= error code 	;AN000;
  5028                                  	;CMP	AX,error_not_DOS_disk	;DCR. is unknown media ? ;AN000;
  5029                                  	;JZ	SHORT SKIPGET 		;DCR. yes, let it go 	;AN000;
  5030                                  	;STC				;DCR.			;AN000;
  5031 00000603 B400                    	mov	ah,0	
  5032                                  
  5033 00000605 A3[2403]                	MOV	[EXTERR],AX	;PM. invalid drive or Non DOS drive ;AN000;
  5034 00000608 C706[B80D]0102          	MOV	WORD [AbsDskErr],201h
  5035                                  SKIPGET:
  5036 0000060E 58                      	POP	AX
  5037 0000060F 7212                    	JC	SHORT GETBP_RETN ; 15/12/2022
  5038                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  5039                                  	;jnc	short getbp_t
  5040                                  	;retn
  5041                                  getbp_t:
  5042 00000611 C42E[A205]              	LES	BP,[THISCDS]
  5043                                  	; 15/12/2022
  5044 00000615 26F6464480              	test	byte [es:bp+curdir.flags+1],curdir_isnet>>8
  5045                                  	; 07/12/2022
  5046                                  	;TEST	WORD [ES:BP+43H],8000H
  5047                                  	;TEST	WORD [ES:BP+curdir.flags],curdir_isnet ; Clears carry
  5048 0000061A 7408                    	JZ	SHORT GETBP_CDS
  5049 0000061C C706[2403]3200          	MOV	WORD [EXTERR],error_not_supported  ; 32h
  5050 00000622 F9                      	STC
  5051                                  GETBP_RETN:
  5052 00000623 C3                      	RETN
  5053                                  
  5054                                  GETBP_CDS:
  5055                                  	;LES	BP,[ES:BP+45H]
  5056 00000624 26C46E45                	LES	BP,[ES:BP+curdir.devptr]
  5057                                  GOTDPB:
  5058                                  	; Load THISDPB from ES:BP
  5059 00000628 892E[8A05]              	MOV	[THISDPB],BP
  5060 0000062C 8C06[8C05]              	MOV	[THISDPB+2],ES
  5061 00000630 C3                      	RETN
  5062                                  
  5063                                  ;BREAK <SYS_RET_OK SYS_RET_ERR CAL_LK ETAB_LK set system call returns>
  5064                                  
  5065                                  ;----------------------------------------------------------------------------
  5066                                  ;
  5067                                  ; Procedure Name : SYS_RETURN
  5068                                  ;
  5069                                  ; These are the general system call exit mechanisms. All internal system
  5070                                  ; calls will transfer (jump) to one of these at the end. Their sole purpose
  5071                                  ; is to set the user's flags and set his AX register for return.
  5072                                  ;
  5073                                  ;----------------------------------------------------------------------------
  5074                                  
  5075                                          ;procedure   SYS_RETURN,NEAR
  5076                                  SYS_RETURN:        
  5077                                          ;entry	SYS_RET_OK
  5078                                  SYS_RET_OK:   
  5079 00000631 E84DFE                  	call    Get_User_Stack
  5080                                  		; turn off user's carry flag
  5081                                  SYS_RET_OK_clc: ; 25/06/2019 
  5082                                          ;;and	word [SI+16h],0FFFEh 
  5083                                  	;and	word [SI+user_env.user_F],~f_Carry 
  5084                                          ; 25/06/2019
  5085 00000634 806416FE                	and	byte [SI+user_env.user_F],~f_Carry ; 0FEh
  5086 00000638 EB10                    	JMP     SHORT DO_RET
  5087                                  
  5088                                          ;entry   SYS_RET_ERR
  5089                                  SYS_RET_ERR:        
  5090 0000063A 30E4                    	XOR     AH,AH 		; hack to allow for smaller error rets
  5091 0000063C E86C00                  	call	ETAB_LK 	; Make sure code is OK, EXTERR gets set
  5092 0000063F E81A00                  	CALL	ErrorMap
  5093                                  
  5094                                  	;entry	From_GetSet
  5095                                  From_GetSet:
  5096 00000642 E83CFE                          call    Get_User_Stack
  5097                                  		 ; signal carry to user
  5098                                  	;;or	word [SI+16h],1
  5099                                  	;OR	word [SI+user_env.user_F],f_Carry
  5100                                  	; 25/06/2019
  5101 00000645 804C1601                	or	byte [SI+user_env.user_F],f_Carry
  5102 00000649 F9                      	STC			; also, signal internal error
  5103                                  DO_RET:
  5104                                          ;MOV	[SI+user_env.user_AX],AX ; Really only sets AH
  5105 0000064A 8904                    	MOV	[SI],AX
  5106 0000064C C3                      	RETN
  5107                                  
  5108                                  	;entry	FCB_RET_OK
  5109                                  FCB_RET_OK:
  5110                                  	;entry	NO_OP		; obsolete system calls dispatch to here
  5111                                  NO_OP:
  5112 0000064D 30C0                    	XOR	AL,AL
  5113 0000064F C3                      	retn
  5114                                  
  5115                                  	;entry	FCB_RET_ERR
  5116                                  FCB_RET_ERR:
  5117 00000650 30E4                    	XOR	AH,AH
  5118 00000652 36A3[2403]              	mov	[ss:EXTERR],AX
  5119 00000656 E80300                  	CALL	ErrorMap
  5120 00000659 B0FF                    	MOV	AL,-1
  5121 0000065B C3                      	retn
  5122                                  
  5123                                  	;entry	ErrorMap
  5124                                  ErrorMap:
  5125 0000065C 56                      	PUSH	SI
  5126                                  				; ERR_TABLE_21 is now in DOSDATA
  5127 0000065D BE[DB0D]                	MOV	SI,ERR_TABLE_21
  5128                                  				; SS override for FAILERR and EXTERR
  5129 00000660 36803E[4A03]00          	CMP	byte [SS:FAILERR],0 ; Check for SPECIAL case.
  5130 00000666 7407                    	JZ	short EXTENDED_NORMAL ; All is OK.
  5131                                  		 ; Ooops, this is the REAL reason
  5132                                  	;mov	word [SS:EXTERR],53h
  5133 00000668 36C706[2403]5300        	MOV	word [SS:EXTERR],error_FAIL_I24
  5134                                  EXTENDED_NORMAL:
  5135 0000066F E80200                  	call	CAL_LK		; Set CLASS,ACTION,LOCUS for EXTERR
  5136 00000672 5E                      	POP	SI
  5137 00000673 C3                      	retn
  5138                                  
  5139                                  	;EndProc SYS_RETURN
  5140                                  
  5141                                  ;---------------------------------------------------------------------------
  5142                                  ;
  5143                                  ; Procedure Name : CAL_LK
  5144                                  ;
  5145                                  ; Inputs:
  5146                                  ;	SI is OFFSET in DOSDATA of CLASS,ACTION,LOCUS Table to use
  5147                                  ;		(DS NEED not be DOSDATA)
  5148                                  ;	[EXTERR] is set with error
  5149                                  ; Function:
  5150                                  ;	Look up and set CLASS ACTION and LOCUS values for GetExtendedError
  5151                                  ; Outputs:
  5152                                  ;	[EXTERR_CLASS] set
  5153                                  ;	[EXTERR_ACTION] set
  5154                                  ;	[EXTERR_LOCUS] set  (EXCEPT on certain errors as determined by table)
  5155                                  ; Destroys SI, FLAGS
  5156                                  ;
  5157                                  ;---------------------------------------------------------------------------
  5158                                  
  5159                                  	;procedure CAL_LK,NEAR
  5160                                  CAL_LK:
  5161 00000674 1E                      	PUSH	DS
  5162 00000675 50                      	PUSH	AX
  5163 00000676 53                      	PUSH	BX
  5164                                  
  5165                                  ;M048	Context DS		; DS:SI -> Table
  5166                                  ;
  5167                                  ; Since this function can be called thru int 2f we shall not assume that SS
  5168                                  ; is DOSDATA
  5169                                  
  5170                                  	;getdseg  <ds>	; M048: DS:SI -> Table
  5171                                  	; 15/05/2019 - Retro DOS v4.0
  5172 00000677 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5173                                  
  5174                                  	; 18/07/2018
  5175                                  	;push	ss
  5176                                  	;pop	ds
  5177                                  
  5178 0000067C 8B1E[2403]              	MOV	BX,[EXTERR]	; Get error in BL
  5179                                  TABLK1:
  5180 00000680 AC                      	LODSB
  5181                                  
  5182 00000681 3CFF                    	CMP	AL,0FFH
  5183 00000683 7409                    	JZ	short GOT_VALS	; End of table
  5184 00000685 38D8                    	CMP	AL,BL
  5185 00000687 7405                    	JZ	short GOT_VALS	; Got entry
  5186 00000689 83C603                  	ADD	SI,3		; Next table entry
  5187                                  	; 15/08/2018
  5188 0000068C EBF2                    	JMP	short TABLK1
  5189                                  
  5190                                  GOT_VALS:
  5191 0000068E AD                      	LODSW			; AL is CLASS, AH is ACTION
  5192                                  
  5193 0000068F 80FCFF                  	CMP	AH,0FFH
  5194 00000692 7404                    	JZ	short NO_SET_ACT
  5195 00000694 8826[2603]              	MOV	[EXTERR_ACTION],AH ; Set ACTION
  5196                                  NO_SET_ACT:
  5197 00000698 3CFF                    	CMP	AL,0FFH
  5198 0000069A 7403                    	JZ	short NO_SET_CLS
  5199 0000069C A2[2703]                	MOV	[EXTERR_CLASS],AL ; Set CLASS
  5200                                  NO_SET_CLS:
  5201 0000069F AC                      	LODSB			; Get LOCUS
  5202                                  
  5203 000006A0 3CFF                    	CMP	AL,0FFH
  5204 000006A2 7403                    	JZ	short NO_SET_LOC
  5205 000006A4 A2[2303]                	MOV	[EXTERR_LOCUS],AL
  5206                                  NO_SET_LOC:
  5207 000006A7 5B                      	POP	BX
  5208 000006A8 58                      	POP	AX
  5209 000006A9 1F                      	POP	DS
  5210 000006AA C3                      	retn
  5211                                  
  5212                                  	;EndProc CAL_LK
  5213                                  
  5214                                  ;---------------------------------------------------------------------------
  5215                                  ;
  5216                                  ; Procedure Name : ETAB_LK
  5217                                  ;
  5218                                  ; Inputs:
  5219                                  ;	AX is error code
  5220                                  ;	[USER_IN_AX] has AH value of system call involved
  5221                                  ; Function:
  5222                                  ;	Make sure error code is appropriate to this call.
  5223                                  ; Outputs:
  5224                                  ;	AX MAY be mapped error code
  5225                                  ;	[EXTERR] = Input AX
  5226                                  ; Destroys ONLY AX and FLAGS
  5227                                  ;
  5228                                  ;---------------------------------------------------------------------------
  5229                                  
  5230                                  	;procedure ETAB_LK,NEAR
  5231                                  
  5232                                  ETAB_LK: ; 10/08/2018 - Retro DOS v3.0
  5233 000006AB 1E                      	PUSH	DS
  5234 000006AC 56                      	PUSH	SI
  5235 000006AD 51                      	PUSH	CX
  5236 000006AE 53                      	PUSH	BX
  5237                                  
  5238                                  	;Context DS			; SS is DOSDATA
  5239                                  
  5240 000006AF 16                      	push	ss
  5241 000006B0 1F                      	pop	ds
  5242                                  
  5243 000006B1 A3[2403]                	MOV	[EXTERR],AX		; Set EXTERR with "real" error
  5244                                  
  5245                                  					; I21_MAP_E_TAB is now in DOSCODE
  5246 000006B4 BE[0B00]                	MOV	SI,I21_MAP_E_TAB
  5247 000006B7 88C7                    	MOV	BH,AL			; Real code to BH
  5248 000006B9 8A1E[3B03]              	MOV	BL,[USER_IN_AX+1]	; Sys call to BL
  5249                                  TABLK2:
  5250                                  	; 15/05/2019 - Retro DOS v4.0
  5251 000006BD 2E                      	cs
  5252 000006BE AD                      	lodsw	; MSDOS 6.0 (MSDOS 6.21 - MSDOS.SYS, DOSCODE:447Dh)
  5253                                  	
  5254                                  	; 18/07/2018 - Retro DOS v3.0
  5255                                  	;lodsw		; IBMDOS.COM (MSDOS 3.3) - Offset 16F7h
  5256                                  
  5257 000006BF 3CFF                    	CMP	AL,0FFH 		; End of table?
  5258 000006C1 740C                    	JZ	short NOT_IN_TABLE	; Yes
  5259 000006C3 38D8                    	CMP	AL,BL			; Found call?
  5260 000006C5 740C                    	JZ	short GOT_CALL		; Yes
  5261 000006C7 86E0                    	XCHG	AH,AL			; Count to AL
  5262 000006C9 30E4                    	XOR	AH,AH			; Make word for add
  5263 000006CB 01C6                    	ADD	SI,AX			; Next table entry
  5264 000006CD EBEE                    	JMP	short TABLK2
  5265                                  
  5266                                  NOT_IN_TABLE:
  5267 000006CF 88F8                    	MOV	AL,BH			; Restore original code
  5268 000006D1 EB0C                    	JMP	SHORT NO_MAP
  5269                                  
  5270                                  GOT_CALL:
  5271 000006D3 88E1                    	MOV	CL,AH
  5272 000006D5 30ED                    	XOR	CH,CH			; Count of valid err codes to CX
  5273                                  CHECK_CODE:
  5274                                  	; 15/05/2019 - Retro DOS v4.0
  5275 000006D7 2E                      	cs
  5276 000006D8 AC                      	lodsb	; MSDOS 6.0 (MSDOS 6.21 - MSDOS.SYS, DOSCODE:4497h)
  5277                                  
  5278                                  	; 18/07/2018
  5279                                  	;lodsb		; IBMDOS.COM (MSDOS 3.3) - Offset 1710h
  5280                                  
  5281 000006D9 38F8                    	CMP	AL,BH			; Code OK?
  5282 000006DB 7402                    	JZ	short NO_MAP		; Yes
  5283 000006DD E2F8                    	LOOP	CHECK_CODE
  5284                                  NO_MAP:
  5285 000006DF 30E4                    	XOR	AH,AH			; AX is now valid code
  5286 000006E1 5B                      	POP	BX
  5287 000006E2 59                      	POP	CX
  5288 000006E3 5E                      	POP	SI
  5289 000006E4 1F                      	POP	DS
  5290 000006E5 C3                      	retn
  5291                                  
  5292                                  	;EndProc ETAB_LK
  5293                                  
  5294                                  ; 18/07/2018 - Retro DOS v3.0
  5295                                  ;---------------------------------------------------------------------------
  5296                                  ; BREAK <DOS 2F Handler and default NET 2F handler>
  5297                                  
  5298                                  ;IF installed ; (*)
  5299                                  
  5300                                  ;---------------------------------------------------------------------------
  5301                                  ;
  5302                                  ; Procedure Name : SetBad
  5303                                  ;
  5304                                  ; SetBad sets up info for bad functions
  5305                                  ;
  5306                                  ;---------------------------------------------------------------------------
  5307                                  
  5308                                  SetBad:
  5309                                  	;mov	ax,1
  5310 000006E6 B80100                  	MOV	AX,error_invalid_function ; ALL NET REQUESTS get inv func
  5311                                  
  5312                                  	; MSDOS 3.3
  5313                                  	;;mov	byte [cs:EXTERR_LOCUS],1
  5314                                  	;MOV	byte [CS:EXTERR_LOCUS],errLOC_Unk
  5315                                  
  5316                                  ;	set up ds to point to DOSDATA
  5317                                  
  5318                                  	; 15/05/2019 - Retro DOS v4.0
  5319                                  	; MSDOS 6.0
  5320 000006E9 1E                      	push	ds
  5321                                  
  5322                                  	;getdseg <ds>
  5323 000006EA 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5324                                  
  5325 000006EF C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1	
  5326                                  
  5327 000006F4 1F                      	pop	ds	  	;hkn; restore ds
  5328                                  
  5329 000006F5 F9                      	STC
  5330 000006F6 C3                      	retn
  5331                                  
  5332                                  ;--------------------------------------------------------------------------
  5333                                  ;
  5334                                  ; Procedure Name : BadCall
  5335                                  ;
  5336                                  ; BadCall is the initial routine for bad function calls
  5337                                  ;
  5338                                  ;--------------------------------------------------------------------------
  5339                                  
  5340                                  BadCall:
  5341 000006F7 E8ECFF                  	call	SetBad
  5342 000006FA CB                      	retf
  5343                                  
  5344                                  ;--------------------------------------------------------------------------
  5345                                  ;
  5346                                  ; OKCall always sets carry to off.
  5347                                  ;
  5348                                  ;-----------------------------------------------------------------------
  5349                                  
  5350                                  OKCall:
  5351 000006FB F8                      	CLC
  5352 000006FC CB                      	retf
  5353                                  
  5354                                  ;---------------------------------------------------------------------------
  5355                                  ;
  5356                                  ; Procedure Name : INT2F
  5357                                  ;
  5358                                  ; INT 2F handler works as follows:
  5359                                  ;   PUSH    AX
  5360                                  ;   MOV     AX,multiplex:function
  5361                                  ;   INT     2F
  5362                                  ;   POP     ...
  5363                                  ; The handler itself needs to make the AX available for the various routines.
  5364                                  ;
  5365                                  ;----------------------------------------------------------------------------
  5366                                  
  5367                                  ; 15/05/2019 - Retro DOS v4.0
  5368                                  
  5369                                  ;KERNEL_SEGMENT equ 70h
  5370                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5371                                  DOSBIODATASEG equ 70h
  5372                                  
  5373                                  ; retrodos4.s - offset in BIOSDATA
  5374                                  bios_i2f equ 5
  5375                                  
  5376                                  ;PUBLIC	Int2F
  5377                                  ;INT2F	PROC	FAR
  5378                                  
  5379                                  ; 15/05/2019
  5380                                  ; DOSCODE:44BDh (MSDOS 6.21, MSDOS.SYS)
  5381                                  
  5382                                  ; 04/11/2022
  5383                                  ; DOSCODE:44B0h (MSDOS 5.0, MSDOS.SYS)
  5384                                  
  5385                                  	; 05/01/2024
  5386                                  	; 15/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5387                                  	; 18/07/2018 - Retro DOS v3.0
  5388                                  INT2F:
  5389                                  	; Offset 172Fh in IBMDOS.COM (MSDOS 3.3), 1987
  5390                                  INT2FNT:
  5391                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5392 000006FD FB                      	STI
  5393                                  	;cmp	ah,11h
  5394 000006FE 80FC11                  	CMP	AH,MultNET
  5395 00000701 750A                    	JNZ	short INT2FSHR
  5396                                  TestInstall:
  5397 00000703 08C0                    	OR	AL,AL
  5398 00000705 7403                    	JZ	short Leave2F
  5399                                  BadFunc:
  5400 00000707 E8DCFF                  	CALL	SetBad
  5401                                  
  5402                                  	;entry	Leave2F
  5403                                  Leave2F:
  5404 0000070A CA0200                  	RETF	2			; long return + clear flags off stack
  5405                                  
  5406                                  INT2FSHR:
  5407                                  	;cmp	ah,10h
  5408 0000070D 80FC10                  	CMP	AH,MultSHARE		; is this a share request
  5409 00000710 74F1                    	JZ	short TestInstall	; yes, check for installation
  5410                                  INT2FNLS:
  5411                                  	;cmp	ah,14h
  5412 00000712 80FC14                  	CMP	AH,NLSFUNC		; is this a DOS 3.3 NLSFUNC request
  5413 00000715 74EC                    	JZ	short TestInstall	; yes check for installation
  5414                                  INT2FDOS:
  5415                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5416                                  
  5417                                  	; 18/07/2018
  5418                                  	; MSDOS 3.3
  5419                                  	;;cmp	ah,12h	
  5420                                  	;CMP	AH,MultDOS
  5421                                  	;jz	short DispatchDOS
  5422                                  	;iret
  5423                                  
  5424                                  	; 15/05/2019
  5425                                  	; MSDOS 6.0
  5426                                  	;cmp	ah,12h	; 07/12/2022
  5427 00000717 80FC12                  	CMP	AH,MultDOS
  5428 0000071A 7503                    	JNZ	short check_win		;check if win386 broadcast
  5429 0000071C E9F201                  	jmp	DispatchDOS
  5430                                  
  5431                                  	; .... win386 .... 
  5432                                  
  5433                                  check_win:
  5434                                  	;cmp	ah,16h
  5435 0000071F 80FC16                  	cmp	ah,MultWin386		; Is this a broadcast from Win386?
  5436 00000722 7408                    	je	short Win386_Msg
  5437                                  
  5438                                  	; M044
  5439                                  	; Check if the callout is from Winoldap indicating swapping out or in 
  5440                                  	; of Windows. If so, do special action of going and saving last para
  5441                                  	; of the Windows memory arena which Winoldap does not save due to a 
  5442                                  	; bug
  5443                                  
  5444 00000724 80FC46                  	cmp	ah,WINOLDAP ; 46h	; from Winoldap?
  5445                                  	;jne	short next_i2f		; no, chain on
  5446                                  	; 15/12/2022
  5447                                  	;jmp	winold_swap		; yes, do desired action
  5448 00000727 7442                    	je	short winold_swap
  5449 00000729 E90501                  	jmp	next_i2f
  5450                                  
  5451                                  	; 15/12/2022
  5452                                  ;next_i2f:
  5453                                  ;	;;;jmp	bios_i2f
  5454                                  ;	;;jmp	far ptr 70h:5 ; MSDOS 6.21 (MSDOS.SYS, DOSCODE:44F1h)
  5455                                  ;	;jmp	KERNEL_SEGMENT:bios_i2f
  5456                                  ;	; 04/11/2022
  5457                                  ;	jmp	DOSBIODATASEG:bios_i2f
  5458                                  
  5459                                  ;	IRET				; This assume that we are at the head
  5460                                  					; of the list
  5461                                  ;INT2F	ENDP
  5462                                  
  5463                                  ; 15/05/2019 - Retro DOS v4.0
  5464                                  
  5465                                  ; We have received a message from Win386. There are three possible
  5466                                  ; messages we could get from Win386:
  5467                                  ;
  5468                                  ; Init 		- for this, we set the IsWin386 flag and return a pointer
  5469                                  ;		  to the Win386 startup info structure.
  5470                                  ; Exit		- for this, we clear the IsWin386 flag.
  5471                                  ; DOSMGR query 	- for this, we need to indicate that instance data
  5472                                  ;		  has already been handled. this is indicated by setting
  5473                                  ;		  CX to a non-zero value.
  5474                                  
  5475                                  Win386_Msg:
  5476 0000072C 1E                      	push	ds
  5477                                  
  5478                                  	;getdseg <DS>			; ds is DOSDATA
  5479 0000072D 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5480                                  
  5481                                  	; For WIN386 2.xx instance data
  5482                                  
  5483 00000732 3C03                    	cmp	al,3			; win386 2.xx instance data call?
  5484 00000734 7503                    	jne	short Win386_Msg_exit
  5485 00000736 E92A01                  	jmp	OldWin386Init		; yes, return instance data
  5486                                  Win386_Msg_exit:
  5487 00000739 3C06                    	cmp	al,Win386_Exit	 ; 6	; is it an exit call?
  5488 0000073B 7503                    	jne	short Win386_Msg_devcall
  5489 0000073D E92C01                  	jmp	Win386_Leaving
  5490                                  Win386_Msg_devcall:
  5491 00000740 3C07                    	cmp	al,Win386_Devcall ; 7	; is it call from DOSMGR?
  5492 00000742 7503                    	jne	short Win386_Msg_init
  5493 00000744 E96001                  	jmp	Win386_Query
  5494                                  Win386_Msg_init:
  5495 00000747 3C05                    	cmp	al,Win386_Init	; 5	; is it an init call?
  5496 00000749 7403                    	je	short Win386_Starting
  5497 0000074B E9E200                  	jmp	win_nexti2f		; no, return
  5498                                  Win386_Starting:
  5499                                  	; 17/12/2022
  5500 0000074E F6C201                  	test	dl,1
  5501                                  	;test	dx,1			; is this really win386?
  5502 00000751 7403                    	jz	short Win386_vchk	; YES! go and handle it
  5503 00000753 E9DA00                  	jmp	win_nexti2f		; NO! It's win 286 dos extender! M002
  5504                                  Win386_vchk:
  5505                                  	; M018 -- start of block changes
  5506                                  	; The VxD needs to be loaded only for Win 3.0. If version is greater 
  5507                                  	; than 030Ah, we skip the VxD presence check
  5508                                  
  5509                                  ;M067 -- Begin changes
  5510                                  ; If Win 3.0 is run, the VxD ptr has been initialized. If Win 3.1 is now
  5511                                  ;run, it tries to unnecesarily load the VxD even though it is not needed.
  5512                                  ;So, we null out the VxD ptr before the check.
  5513                                  
  5514                                  	;mov	word [Win386_Info+6],0
  5515 00000756 C706[E80F]0000          	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],0
  5516                                  	;mov	word [Win386_Info+8],0
  5517 0000075C C706[EA0F]0000          	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2],0
  5518                                  
  5519                                  ;M067 -- End changes
  5520                                  
  5521                                  ;ifdef JAPAN
  5522                                  ;	cmp	di,0300h		; version >= 300 i.e 3.10 ;M037
  5523                                  ;else
  5524 00000762 81FF0A03                	cmp	di,030Ah		; version >= 30a i.e 3.10 ;M037
  5525                                  ;endif
  5526                                  	;ljae	noVxD31			; yes, VxD not needed 	 ;M037
  5527 00000766 724E                    	jb	short Win386_vxd
  5528 00000768 E9DD00                  	jmp	noVxD31
  5529                                  
  5530                                  	; 15/12/2022
  5531                                  winold_swap:
  5532 0000076B 1E                      	push	ds
  5533 0000076C 06                      	push	es
  5534 0000076D 56                      	push	si
  5535 0000076E 57                      	push	di
  5536 0000076F 51                      	push	cx
  5537                                  
  5538                                  	;getdseg <ds>			;ds = DOSDATA
  5539 00000770 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5540                                  
  5541 00000775 3C01                    	cmp	al,1			;swap Windows out call
  5542 00000777 751B                    	jne	short swapin		;no, check if Swap in call
  5543 00000779 E88801                  	call	getwinlast
  5544 0000077C 1E                      	push	ds
  5545 0000077D 07                      	pop	es
  5546 0000077E 8EDE                    	mov	ds,si			;ds = memory arena of Windows
  5547 00000780 31F6                    	xor	si,si
  5548 00000782 BF[0600]                	mov	di,WinoldPatch1
  5549 00000785 B90800                  	mov	cx,8
  5550 00000788 FC                      	cld
  5551 00000789 51                      	push	cx
  5552 0000078A F3A4                    	rep	movsb			;save first 8 bytes
  5553 0000078C 59                      	pop	cx
  5554 0000078D BF[CD0D]                	mov	di,WinoldPatch2
  5555 00000790 F3A4                    	rep	movsb			;save next 8 bytes
  5556 00000792 EB1B                    	jmp	short winold_done
  5557                                  swapin:
  5558 00000794 3C02                    	cmp	al,2			;swap Windows in call?
  5559 00000796 7517                    	jne	short winold_done	;no, something else, pass it on
  5560 00000798 E86901                  	call	getwinlast
  5561 0000079B 8EC6                    	mov	es,si
  5562 0000079D 31FF                    	xor	di,di
  5563 0000079F BE[0600]                	mov	si,WinoldPatch1
  5564 000007A2 B90800                  	mov	cx,8
  5565 000007A5 FC                      	cld
  5566 000007A6 51                      	push	cx
  5567 000007A7 F3A4                    	rep	movsb			;restore first 8 bytes
  5568 000007A9 59                      	pop	cx
  5569 000007AA BE[CD0D]                	mov	si,WinoldPatch2
  5570 000007AD F3A4                    	rep	movsb			;restore next 8 bytes
  5571                                  winold_done:
  5572 000007AF 59                      	pop	cx
  5573 000007B0 5F                      	pop	di
  5574 000007B1 5E                      	pop	si
  5575 000007B2 07                      	pop	es
  5576 000007B3 1F                      	pop	ds
  5577 000007B4 EB7B                    	jmp	short next_i2f		;chain on
  5578                                  	; 15/12/2022
  5579                                  	;jmp	next_i2f	
  5580                                  
  5581                                  Win386_vxd:
  5582 000007B6 50                      	push	ax
  5583 000007B7 53                      	push	bx
  5584 000007B8 51                      	push	cx
  5585 000007B9 52                      	push	dx
  5586 000007BA 56                      	push	si
  5587 000007BB 57                      	push	di			; save regs !!dont change order!!
  5588                                  
  5589 000007BC 8B1E[8C00]              	mov	bx,[UMB_HEAD]		; M062 - Start
  5590 000007C0 83FBFF                  	cmp	bx,0FFFFh    		; Q: have umbs been initialized
  5591 000007C3 741F                    	je	short Vxd31		; N: continue
  5592                                  					; Y: save arena associated with 
  5593                                  					;    umb_head
  5594                                  
  5595 000007C5 C606[DA0D]01            	mov	byte [UmbSaveFlag],1	; indicate that we're saving 
  5596                                  					; umb_arena
  5597 000007CA 1E                      	push	ds
  5598 000007CB 06                      	push	es
  5599                                  
  5600                                  	;mov	ax,ds
  5601                                  	;mov	es,ax			; es - > dosdata
  5602                                  	; 05/01/2024
  5603 000007CC 1E                      	push	ds
  5604 000007CD 07                      	pop	es
  5605                                  
  5606 000007CE 8EDB                    	mov	ds,bx
  5607 000007D0 31F6                    	xor	si,si			; ds:si -> umb_head
  5608                                  
  5609 000007D2 FC                      	cld
  5610                                  
  5611 000007D3 BF[1F12]                	mov	di,UmbSave1
  5612 000007D6 B90B00                  	mov	cx,11
  5613 000007D9 F3A4                    	rep	movsb
  5614                                  
  5615 000007DB BF[D50D]                	mov	di,UmbSave2
  5616                                  	;mov	cx,5
  5617                                  	; 18/12/2022
  5618 000007DE B105                    	mov	cl,5
  5619 000007E0 F3A4                    	rep	movsb	
  5620                                  
  5621 000007E2 07                      	pop	es
  5622 000007E3 1F                      	pop	ds			; M062 - End
  5623                                  
  5624                                  Vxd31:
  5625                                  	;test	byte [DOS_FLAG],2
  5626 000007E4 F606[8600]02            	test	byte [DOS_FLAG],SUPPRESS_WINA20	; M066
  5627 000007E9 7408                    	jz	short Dont_Supress		; M066
  5628 000007EB 5F                      	pop	di				; M066
  5629 000007EC 5E                      	pop	si				; M066
  5630 000007ED 5A                      	pop	dx				; M066
  5631 000007EE 59                      	pop	cx				; M066
  5632 000007EF 5B                      	pop	bx				; M066
  5633 000007F0 58                      	pop	ax				; M066
  5634 000007F1 EB55                    	jmp	short noVxD31			; M066
  5635                                  
  5636                                  	; We check here if the VxD is available in the root of the boot drive. 
  5637                                  	; We do an extended open to suppress any error messages
  5638                                  	
  5639                                  Dont_Supress:
  5640 000007F3 A0[6900]                	mov	al,[BOOTDRIVE]
  5641 000007F6 0440                    	add	al,'A' - 1		; get drive letter
  5642 000007F8 A2[3110]                	mov	[VxDpath],al		; path is root of bootdrive
  5643                                  	;mov	ah,ExtOpen  ;6Ch	; extended open
  5644                                  	;mov	al,0			; no extended attributes
  5645                                  	; 18/12/2022
  5646 000007FB B8006C                  	mov	ax,ExtOpen<<8 ; 6C00h
  5647 000007FE BB8020                  	mov	bx,2080h		; read access, compatibility mode
  5648                                  					; no inherit, suppress crit err
  5649 00000801 B90700                  	mov	cx,7			; hidden,system,read-only attr
  5650 00000804 BA0100                  	mov	dx,1			; fail if file does not exist
  5651 00000807 BE[3110]                	mov	si,VxDpath	
  5652                                  					; path of VxD file
  5653 0000080A BFFFFF                  	mov	di,0FFFFh		; no extended attributes
  5654                                  
  5655 0000080D CD21                    	int	21h			; do extended open
  5656                                  
  5657 0000080F 5F                      	pop	di
  5658 00000810 5E                      	pop	si
  5659 00000811 5A                      	pop	dx
  5660 00000812 59                      	pop	cx
  5661                                  
  5662 00000813 7321                    	jnc	short VxDthere		; we found the VxD, go ahead
  5663                                  
  5664                                  	; We could not find the VxD. Cannot let windows load. Return cx != 0 
  5665                                  	; to indicate error to Windows after displaying message to user that 
  5666                                  	; VxD needs to be present to run Windows in enhanced mode.
  5667                                  
  5668 00000815 52                      	push	dx
  5669 00000816 1E                      	push	ds
  5670 00000817 56                      	push	si
  5671 00000818 BE[AC09]                	mov	si,NoVxDErrMsg
  5672 0000081B 0E                      	push	cs
  5673 0000081C 1F                      	pop	ds
  5674 0000081D B96300                  	mov	cx,VxDMesLen ; 99	;
  5675 00000820 B402                    	mov	ah,2			; write char to console
  5676 00000822 FC                      	cld
  5677                                  vxdlp:
  5678 00000823 AC                      	lodsb
  5679 00000824 86D0                    	xchg	dl,al			; get char in dl
  5680 00000826 CD21                    	int	21h
  5681 00000828 E2F9                    	loop	vxdlp
  5682                                  
  5683 0000082A 5E                      	pop	si
  5684 0000082B 1F                      	pop	ds
  5685 0000082C 5A                      	pop	dx
  5686 0000082D 5B                      	pop	bx
  5687 0000082E 58                      	pop	ax			;all registers restored
  5688 0000082F 41                      	inc	cx			;cx != 0 to indicate error
  5689                                  	; 15/12/22022
  5690                                  	;jmp	win_nexti2f		;chain on
  5691                                  	;jmp	short win_nexti2f
  5692                                  
  5693                                  	; 15/12/2022
  5694                                  win_nexti2f:
  5695 00000830 1F                      	pop	ds
  5696                                  	;jmp	short next_i2f		; go to BIOS i2f handler
  5697                                  	; 15/12/2022
  5698                                  next_i2f:
  5699                                  	;;;jmp	bios_i2f
  5700                                  	;;jmp	far ptr 70h:5 ; MSDOS 6.21 (MSDOS.SYS, DOSCODE:44F1h)
  5701                                  	;jmp	KERNEL_SEGMENT:bios_i2f
  5702                                  	; 04/11/2022
  5703 00000831 EA05007000              	jmp	DOSBIODATASEG:bios_i2f
  5704                                  
  5705                                  VxDthere:
  5706 00000836 89C3                    	mov	bx,ax
  5707 00000838 B43E                    	mov	ah,CLOSE ; 3Eh
  5708 0000083A CD21                    	int	21h			;close the file
  5709                                  
  5710                                  	; Update the VxD ptr in the instance data structure with path to VxD
  5711                                  
  5712                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  5713                                  	;mov	bx,Win386_Info
  5714                                  	;mov	word [bx+Win386_SIS.Virt_Dev_File_Ptr],VxDpath
  5715                                  	;mov	word [bx+Win386_SIS.Virt_Dev_File_Ptr+2],ds
  5716                                  	; 15/12/2022
  5717 0000083C C706[E80F][3110]        	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],VxDpath
  5718 00000842 8C1E[EA0F]              	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2],ds
  5719                                  
  5720 00000846 5B                      	pop	bx
  5721 00000847 58                      	pop	ax
  5722                                  noVxD31:
  5723                                  	; M018; End of block changes
  5724                                  
  5725 00000848 800E[3010]01            	or	byte [IsWin386],1 	; Indicate WIN386 present
  5726 0000084D 800E[0C0D]01            	or	byte [redir_patch],1	; Enable critical sections; M002
  5727                                  
  5728                                  	; M002;
  5729                                  	; Save the previous es:bx (instance data ptr) into our instance table
  5730                                  
  5731 00000852 52                      	push	dx			; M002
  5732 00000853 89DA                    	mov	dx,bx			; M002
  5733                                  					; point ES:BX to Win386_Info ; M002
  5734 00000855 BB[E20F]                	mov	bx,Win386_Info 
  5735 00000858 895702                  	mov	[bx+2],dx		; M002
  5736 0000085B 8C4704                  	mov	[bx+4],es		; M002
  5737 0000085E 5A                      	pop	dx			; M002
  5738 0000085F 1E                      	push	ds			; M002
  5739 00000860 07                      	pop	es			; M002
  5740                                  	;jmp	win_nexti2f		; M002
  5741                                  	; 15/12/2022
  5742 00000861 EBCD                    	jmp	short win_nexti2f
  5743                                  
  5744                                  	; 15/12/2022
  5745                                  	; Code to return Win386 2.xx instance table
  5746                                  OldWin386Init:
  5747 00000863 58                      	pop	ax			; discard ds pushed on stack
  5748 00000864 BE[E711]                	mov	si,OldInstanceJunk 
  5749                                  					; ds:si = instance table
  5750 00000867 B84852                  	mov	ax,5248h ; 'HR'		; indicate instance data present
  5751                                  	;jmp	next_i2f
  5752                                  	; 15/12/2022
  5753 0000086A EBC5                    	jmp	short next_i2f
  5754                                  
  5755                                  Win386_Leaving:
  5756                                  	; 15/12/2022
  5757 0000086C F6C201                  	test 	dl,1
  5758                                  	;test	dx,1			; is this really win386?
  5759                                  	;jz	short Win386_Leaving_c
  5760                                  	;jmp	win_nexti2f		; NO! It's win 286 dos extender! M002
  5761                                  	; 15/12/2022
  5762 0000086F 75BF                    	jnz	short win_nexti2f	
  5763                                  
  5764                                  Win386_Leaving_c:
  5765                                  					; M062 - Start
  5766 00000871 803E[DA0D]01            	cmp	byte [UmbSaveFlag],1	; Q: was umb_arena saved at win start
  5767                                  					;    up.
  5768 00000876 7523                    	jne	short noumb		; N: not saved 
  5769 00000878 C606[DA0D]00            	mov	byte [UmbSaveFlag],0	; Y: clear UmbSaveFlag and restore 
  5770                                  					;    previously saved umb_head
  5771                                  	; 05/01/2024
  5772                                  	;push	ax ; (not necessary)
  5773 0000087D 06                      	push	es
  5774 0000087E 51                      	push	cx
  5775 0000087F 56                      	push	si
  5776 00000880 57                      	push	di
  5777                                  
  5778                                  	;mov	ax,[UMB_HEAD]
  5779                                  	;mov	es,ax
  5780                                  	; 05/01/2024
  5781 00000881 8E06[8C00]              	mov	es,[UMB_HEAD]
  5782 00000885 31FF                    	xor	di,di			; es:di -> umb_head
  5783                                  
  5784 00000887 FC                      	cld
  5785                                  
  5786 00000888 BE[1F12]                	mov	si,UmbSave1
  5787 0000088B B90B00                  	mov	cx,11
  5788 0000088E F3A4                    	rep	movsb
  5789 00000890 BE[D50D]                	mov	si,UmbSave2
  5790                                  	;mov	cx,5
  5791                                  	; 18/12/2022
  5792 00000893 B105                    	mov	cl,5
  5793 00000895 F3A4                    	rep	movsb
  5794                                  
  5795 00000897 5F                      	pop	di
  5796 00000898 5E                      	pop	si
  5797 00000899 59                      	pop	cx
  5798 0000089A 07                      	pop	es
  5799                                  	; 05/01/2024
  5800                                  	;pop	ax
  5801                                  noumb:					; M062 - End
  5802 0000089B 8026[3010]00            	and	byte [IsWin386],0	; Win386 is gone
  5803 000008A0 8026[0C0D]00            	and	byte [redir_patch],0	; Disable critical sections ; M002
  5804 000008A5 EB89                    	jmp	short win_nexti2f
  5805                                  
  5806                                  ;	; 15/12/2022
  5807                                  ;	; Code to return Win386 2.xx instance table
  5808                                  ;OldWin386Init:
  5809                                  ;	pop	ax			; discard ds pushed on stack
  5810                                  ;	mov	si,OldInstanceJunk 
  5811                                  ;					; ds:si = instance table
  5812                                  ;	mov	ax,5248h ; 'RH'		; indicate instance data present
  5813                                  ;	;jmp	next_i2f
  5814                                  ;	; 15/12/2022
  5815                                  ;	jmp	short _next_i2f
  5816                                  
  5817                                  Win386_Query:
  5818 000008A7 83FB15                  	cmp	bx,Win386_DOSMGR ; 15h	; is this from DOSMGR?
  5819 000008AA 7584                    	jne	short win_nexti2f     	; no, ignore it & chain to next
  5820 000008AC 09C9                    	or	cx,cx			; is it an instance query?
  5821 000008AE 7508                    	jne	short dosmgr_func	; no, some DOSMGR query
  5822 000008B0 41                      	inc	cx			; indicate that data is instanced
  5823                                  ;
  5824                                  ; M001; We were previously returning a null ptr in es:bx. This will not work.
  5825                                  ; M001; WIN386 needs a ptr to a table in es:bx with the following offsets:
  5826                                  ; M001;  
  5827                                  ; M001; OFFSETS STRUC
  5828                                  ; M001; 	Major_version	db	?
  5829                                  ; M001; 	Minor_version	db	?
  5830                                  ; M001; 	SaveDS		dw	?
  5831                                  ; M001; 	SaveBX		dw	?
  5832                                  ; M001; 	Indos		dw	?
  5833                                  ; M001; 	User_id		dw	?
  5834                                  ; M001; 	CritPatch	dw	?
  5835                                  ; M001; OFFSETS	ENDS
  5836                                  ; M001; 
  5837                                  ; M001; User_Id is the only variable really important for proper functioning  
  5838                                  ; M001; of Win386. The other variables are used at init time to patch stuff
  5839                                  ; M001; out. In DOS 5.0, we do the patching ourselves. But we still need to 
  5840                                  ; M001; pass this table because Win386 depends on this table to get the 
  5841                                  ; M001; User_Id offset.
  5842                                  ; M001; 
  5843 000008B1 BB[2210]                	mov	bx,Win386_DOSVars	; M001 
  5844 000008B4 1E                      	push	ds			; M001
  5845 000008B5 07                      	pop	es			; es:bx points at offset table ; M001
  5846 000008B6 EB40                    	jmp	short PopIret		; M001
  5847                                  
  5848                                  ; 15/12/2022
  5849                                  ;	; Code to return Win386 2.xx instance table
  5850                                  ;OldWin386Init:
  5851                                  ;	pop	ax			; discard ds pushed on stack
  5852                                  ;	mov	si,OldInstanceJunk 
  5853                                  ;					; ds:si = instance table
  5854                                  ;	mov	ax,5248h ; 'RH'		; indicate instance data present
  5855                                  ;	;jmp	next_i2f
  5856                                  ;	; 15/12/2022
  5857                                  ;	jmp	short _next_i2f
  5858                                  
  5859                                  dosmgr_func:
  5860 000008B8 49                      	dec	cx
  5861 000008B9 7435                    	jz	short win386_patch	; call to patch DOS
  5862 000008BB 49                      	dec	cx
  5863 000008BC 743A                    	jz	short PopIret		; remove DOS patches, ignore
  5864 000008BE 49                      	dec	cx
  5865 000008BF 7439                    	jz	short win386_size	; get size of DOS data structures
  5866 000008C1 49                      	dec	cx
  5867 000008C2 7428                    	jz	short win386_inst	; instance more data
  5868                                  	;dec	cx
  5869                                  	;jnz	short PopIret		; no functions above this
  5870                                  	; 05/01/2024 (PCDOS 7.1 IBMDOS.COM DOSCODE:4771h)
  5871 000008C4 E232                    	loop	PopIret
  5872                                  
  5873                                  	; Get DOS device driver size -- es:di points at device driver header
  5874                                  	; In DOS 4.x, the para before the device header contains an arena 
  5875                                  	; header for the driver.
  5876                                  
  5877 000008C6 8CC0                    	mov	ax,es			; ax = device header segment
  5878                                  
  5879                                  	; We check to see if we have a memory arena for this device driver. 
  5880                                  	; The way to do this would be to look at the previous para to see if
  5881                                  	; it has a 'D' marking it as an arena and also see if the owner-field 
  5882                                  	; in the arena is the same as the device header segment. These two 
  5883                                  	; checks together should take care of all cases
  5884                                  
  5885 000008C8 48                      	dec	ax			; get arena header
  5886 000008C9 06                      	push	es
  5887 000008CA 8EC0                    	mov	es,ax			; arena header for device driver
  5888                                  
  5889 000008CC 26803D44                	cmp	byte [es:di],'D'	; is it a device arena?
  5890 000008D0 7517                    	jnz	short cantsize		; no, cant size this driver
  5891 000008D2 40                      	inc	ax			; get back device header segment
  5892 000008D3 26394501                	cmp	[es:di+1],ax		; owner field pointing at driver?
  5893 000008D7 7510                    	jnz	short cantsize		; no, not a proper arena
  5894                                  
  5895 000008D9 268B4503                	mov	ax,[es:di+3]		; get arena size in paras
  5896 000008DD 07                      	pop	es
  5897                                  
  5898                                  	; We have to multiply by 16 to get the number of bytes in (bx:cx)
  5899                                  	; Speed is not critical and so we choose the shortest method 
  5900                                  	; -- use "mul"
  5901                                  
  5902 000008DE BB1000                  	mov	bx,16
  5903 000008E1 F7E3                    	mul	bx
  5904 000008E3 89C1                    	mov	cx,ax
  5905 000008E5 89D3                    	mov	bx,dx
  5906 000008E7 EB09                    	jmp	short win386_done	; return with device driver size
  5907                                  cantsize:
  5908 000008E9 07                      	pop	es
  5909 000008EA 31C0                    	xor	ax,ax
  5910                                  win386_inst:	; 05/01/2024
  5911 000008EC 31D2                    	xor	dx,dx			; ask DOSMGR to use its methods
  5912 000008EE EB08                    	jmp	short PopIret		; return
  5913                                  
  5914                                  win386_patch:
  5915                                  	; dx contains bits marking the patches to be applied. We return 
  5916                                  	; the field with all bits set to indicate that all patches have been
  5917                                  	; done
  5918                                  
  5919 000008F0 89D3                    	mov	bx,dx			; move patch bitfield to bx
  5920                                   	;jmp	short win386_done	; done, return
  5921                                  	; 15/12/2022
  5922                                  	; 15/12/2022
  5923                                  win386_done:
  5924 000008F2 B87CB9                  	mov	ax,WIN_OP_DONE		; 0B97Ch
  5925 000008F5 BAABA2                  	mov	dx,DOSMGR_OP_DONE	; 0A2ABh
  5926                                  PopIret:
  5927 000008F8 1F                      	pop	ds
  5928 000008F9 CF                      	iret	
  5929                                  
  5930                                  win386_size:
  5931                                  	; Return the size of DOS data structures -- currently only CDS size
  5932                                  
  5933                                  	; 17/12/2022
  5934 000008FA F6C201                  	test	dl,1
  5935                                  	;test	dx,1			; check for CDS size bit
  5936 000008FD 74F9                    	jz	short PopIret		; no, unknown structure -- return
  5937                                  
  5938 000008FF B95800                  	mov	cx,curdirLen	; 88 	; cx = CDS size
  5939 00000902 EBEE                    	jmp	short win386_done	; return with the size
  5940                                  
  5941                                  ; 05/01/2024
  5942                                  %if 0
  5943                                  win386_inst:
  5944                                  	; WIN386 check to see if DOS has identified the CDS,SFT and device
  5945                                  	; chain as instance data. Currently, we let the WIN386 DOSMGR handle
  5946                                  	; this by returning a status of not previously instanced. The basic
  5947                                  	; structure of these things have not changed and so the current
  5948                                  	; DOSMGR code should be able to work it out
  5949                                  
  5950                                  	xor	dx,dx			; make sure dx has a not done value
  5951                                  	jmp	short PopIret		; skip done indication
  5952                                  %endif
  5953                                  
  5954                                  	; 15/12/2022
  5955                                  ;win386_done:
  5956                                  ;	mov	ax,WIN_OP_DONE		; 0B97Ch
  5957                                  ;	mov	dx,DOSMGR_OP_DONE	; 0A2ABh
  5958                                  ;PopIret:
  5959                                  ;	pop	ds
  5960                                  ;	iret				; return back up the chain
  5961                                  
  5962                                  	; 15/12/2022
  5963                                  ;win_nexti2f:
  5964                                  	;pop	ds
  5965                                  	;jmp	next_i2f		; go to BIOS i2f handler
  5966                                  
  5967                                  ;End WIN386 support
  5968                                  
  5969                                  ; 15/05/2019
  5970                                  
  5971                                  ;M044; Start of changes
  5972                                  ; Winoldap has a bug in that its calculations for the Windows memory image
  5973                                  ; to save is off by 1 para. This para can happen to be a Windows arena if the
  5974                                  ; DOS top of memory happens to be at an odd boundary (as is the case when
  5975                                  ; UMBs are present). This is because Windows builds its arenas only at even
  5976                                  ; para boundaries. This arena now gets trashed when Windows is swapped back
  5977                                  ; in leading to a crash. Winoldap issues callouts when it swaps Windows out
  5978                                  ; and back in. We sit on these callouts. On the Windows swapout, we save the
  5979                                  ; last para of the Windows memory block and then restore this para on the
  5980                                  ; Windows swapin callout. 
  5981                                  
  5982                                  getwinlast:
  5983                                  	; 07/12/2022
  5984 00000904 8B36[3003]              	mov	si,[CurrentPDB]
  5985 00000908 4E                      	dec	si
  5986 00000909 8EC6                    	mov	es,si
  5987 0000090B 2603360300              	add	si,[es:3]
  5988 00000910 C3                      	retn
  5989                                  
  5990                                  ; 15/12/2022
  5991                                  %if 0
  5992                                  winold_swap:
  5993                                  	push	ds
  5994                                  	push	es
  5995                                  	push	si
  5996                                  	push	di
  5997                                  	push	cx
  5998                                  
  5999                                  	;getdseg <ds>			;ds = DOSDATA
  6000                                  	mov	ds,[cs:DosDSeg]
  6001                                  
  6002                                  	cmp	al,1			;swap Windows out call
  6003                                  	jne	short swapin		;no, check if Swap in call
  6004                                  	call	getwinlast
  6005                                  	push	ds
  6006                                  	pop	es
  6007                                  	mov	ds,si			;ds = memory arena of Windows
  6008                                  	xor	si,si
  6009                                  	mov	di,WinoldPatch1
  6010                                  	mov	cx,8
  6011                                  	cld
  6012                                  	push	cx
  6013                                  	rep	movsb			;save first 8 bytes
  6014                                  	pop	cx
  6015                                  	mov	di,WinoldPatch2
  6016                                  	rep	movsb			;save next 8 bytes
  6017                                  	jmp	short winold_done
  6018                                  swapin:
  6019                                  	cmp	al,2			;swap Windows in call?
  6020                                  	jne	short winold_done	;no, something else, pass it on
  6021                                  	call	getwinlast
  6022                                  	mov	es,si
  6023                                  	xor	di,di
  6024                                  	mov	si,WinoldPatch1
  6025                                  	mov	cx,8
  6026                                  	cld
  6027                                  	push	cx
  6028                                  	rep	movsb			;restore first 8 bytes
  6029                                  	pop	cx
  6030                                  	mov	si,WinoldPatch2
  6031                                  	rep	movsb			;restore next 8 bytes
  6032                                  winold_done:
  6033                                  	pop	cx
  6034                                  	pop	di
  6035                                  	pop	si
  6036                                  	pop	es
  6037                                  	pop	ds
  6038                                  	jmp	next_i2f		;chain on
  6039                                  
  6040                                  %endif
  6041                                  
  6042                                  ;M044; End of changes
  6043                                  
  6044                                  ; 15/05/2019
  6045                                  
  6046                                  DispatchDOS:
  6047 00000911 2EFF36[C401]            	PUSH	word [CS:FOO]		; push return address
  6048 00000916 2EFF36[C601]            	PUSH	word [CS:DTab]		; push table address
  6049 0000091B 50                      	PUSH	AX			; push index
  6050 0000091C 55                      	PUSH	BP
  6051 0000091D 89E5                    	MOV	BP,SP
  6052                                  		; stack looks like:
  6053                                  		;   0	BP
  6054                                  		;   2	DISPATCH
  6055                                  		;   4	TABLE
  6056                                  		;   6	RETURN
  6057                                  		;   8	LONG-RETURN
  6058                                  		;   C	FLAGS
  6059                                  		;   E	AX
  6060                                  	
  6061 0000091F 8B460E                  	MOV	AX,[BP+0Eh]		; get AX value
  6062 00000922 5D                      	POP	BP
  6063 00000923 E8D808                  	call	TableDispatch
  6064 00000926 E9DEFD                  	JMP	BadFunc 		; return indicates invalid function
  6065                                  
  6066                                  INT2F_etcetera:
  6067                                  	;entry	DosGetGroup
  6068                                  DosGetGroup:
  6069                                  	; MSDOS 3.3
  6070                                  	;push	cs
  6071                                  	;pop	ds
  6072                                  	;retn
  6073                                  
  6074                                  	; MSDOS 6.0
  6075                                  ;SR; Cannot use CS now
  6076                                  ;
  6077                                  ;	PUSH	CS
  6078                                  ;	POP	DS
  6079                                  
  6080                                  	; 04/11/2022
  6081                                  	; (MSDOS 5.0 MSDOS.SYS - DOSCODE:46FBh)
  6082                                  
  6083                                  	;getdseg <ds>
  6084 00000929 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6085 0000092E C3                      	retn
  6086                                  
  6087                                  	;entry	DOSInstall
  6088                                  DOSInstall:
  6089 0000092F B0FF                    	MOV	AL,0FFh
  6090 00000931 C3                      	retn
  6091                                  
  6092                                  ;ENDIF ; (*)
  6093                                  
  6094                                  
  6095                                  ; 15/05/2019 - Retro DOS v4.0
  6096                                  
  6097                                  ;------------------------------------------------------------------------
  6098                                  ;
  6099                                  ; Procedure Name : RW32_CONVERT
  6100                                  ;
  6101                                  ;Input: same as ABSDRD and ABSDWRT
  6102                                  ;	 ES:BP -> DPB
  6103                                  ;Functions: convert 32bit absolute RW input parms to 16bit input parms
  6104                                  ;Output: carry set when CX=-1 and drive is less then 32mb
  6105                                  ;	 carry clear, parms ok
  6106                                  ;
  6107                                  ;------------------------------------------------------------------------
  6108                                  
  6109                                  	; 06/01/2024
  6110                                  RW32_CONVERT:
  6111                                  	;inc	cx ; *	; 01 -> 0
  6112 00000932 83F9FF                  	CMP	CX,-1			   ;>32mb  new format ?	;AN000;
  6113 00000935 7429                    	JZ	short new32format	   ;>32mb  yes		;AN000;
  6114                                  	;dec	cx ; *
  6115 00000937 50                      	PUSH	AX			   ;>32mb  save ax	;AN000;
  6116 00000938 52                      	PUSH	DX			   ;>32mb  save dx	;AN000;
  6117                                  	;mov	ax,[es:bp+0Dh]
  6118 00000939 268B460D                	MOV	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  get max cluster # ;AN000;
  6119                                  	;mov	dl,[es:bp+4]
  6120 0000093D 268A5604                	MOV	DL,[ES:BP+DPB.CLUSTER_MASK] ;>32mb		;AN000;
  6121 00000941 80FAFE                  	CMP	DL,0FEh ; 254		;>32mb  removable ?	;AN000;
  6122 00000944 7407                    	JZ	short letold		;>32mb  yes		;AN000;
  6123                                  	;INC	DL			;>32mb			;AN000;
  6124                                  	; 17/12/2022
  6125 00000946 42                      	inc	dx
  6126 00000947 30F6                    	XOR	DH,DH			;>32mb  dx = sector/cluster ;AN000;
  6127 00000949 F7E2                    	MUL	DX			;>32mb  dx:ax= max sector # ;AN000;
  6128 0000094B 09D2                    	OR	DX,DX	; (clears CF)	;>32mb  > 32mb ?	;AN000;
  6129                                  letold:
  6130 0000094D 5A                      	POP	DX			;>32mb  restore dx	;AN000;
  6131 0000094E 58                      	POP	AX			;>32mb  restore ax 	;AN000;
  6132 0000094F 7425                    	JZ	short old_style	; cf=0	;>32mb  no 		;AN000;
  6133                                  
  6134 00000951 1E                      	push	ds
  6135                                  	;getdseg <ds>
  6136 00000952 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6137 00000957 C706[B80D]0702          	mov	word [AbsDskErr],207h	;>32mb  bad address mark
  6138 0000095D 1F                      	pop	ds
  6139                                  
  6140 0000095E F9                      	STC				;>32mb			;AN000;
  6141 0000095F C3                      	retn				;>32mb			;AN000;
  6142                                  
  6143                                  new32format:
  6144                                  	;mov	dx,[bx+2]
  6145 00000960 8B5702                  	MOV	DX,[BX+ABS_32RW.SECTOR_RBA+2] ;>32mb		;AN000;
  6146                                  
  6147 00000963 1E                      	push	ds			; set up ds to DOSDATA
  6148                                  	;getdseg <ds>
  6149 00000964 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6150 00000969 8916[0706]              	MOV	[HIGH_SECTOR],DX	;>32mb			;AN000;
  6151 0000096D 1F                      	pop	ds
  6152                                  
  6153 0000096E 8B17                    	mov	dx,[bx]
  6154                                  	;MOV	DX,[BX+ABS_32RW.SECTOR_RBA]  ;>32mb		;AN000;
  6155                                  	;mov	cx,[bx+4]
  6156 00000970 8B4F04                  	MOV	CX,[BX+ABS_32RW.ABS_RW_COUNT] ;>32mb		;AN000;
  6157                                  	;lds	bx,[bx+6]
  6158 00000973 C55F06                  	LDS	BX,[BX+ABS_32RW.BUFFER_ADDR] ;>32mb		;AN000;
  6159                                  old_style:				;>32mb			;AN000;
  6160                                  	; 06/01/2024
  6161                                  	; cf=0
  6162                                  	;CLC				;>32mb			;AN000;
  6163 00000976 C3                      	retn				;>32mb			;AN000;
  6164                                  
  6165                                  ;------------------------------------------------------------------------
  6166                                  ;
  6167                                  ; Procedure Name : Fastxxx_Purge
  6168                                  ;
  6169                                  ; Input: None
  6170                                  ; Functions: Purge Fastopen/ Cache Buffers
  6171                                  ; Output: None
  6172                                  ;
  6173                                  ;------------------------------------------------------------------------
  6174                                  
  6175                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6176                                  
  6177                                  Fastxxx_Purge:
  6178 00000977 50                      	PUSH	AX			; save regs.	;AN000;
  6179 00000978 56                      	PUSH	SI						;AN000;
  6180 00000979 52                      	PUSH	DX						;AN000;
  6181                                  topen:
  6182 0000097A 1E                      	push	ds			; set up ds to DOSDATA
  6183                                  	;getdseg <ds>
  6184 0000097B 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6185                                  
  6186 00000980 F606[3A0D]80            	TEST	byte [FastOpenFlg],Fast_yes ; 80h 
  6187                                  					; fastopen installed ?	;AN000;
  6188 00000985 1F                      	pop	ds
  6189 00000986 740B                    	JZ	short nofast		; no			;AN000;
  6190 00000988 B401                    	MOV	AH,FastOpen_ID	; 1				;AN000;
  6191                                  dofast:
  6192 0000098A B005                    	MOV	AL,FONC_purge  ;5	; purge			;AN000;
  6193                                  	;;mov	dl,[es:bp+0]
  6194                                  	; 05/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  6195                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; set up drive number	;AN000;
  6196                                  	; 15/12/2022
  6197 0000098C 268A5600                	mov	dl,[es:bp]
  6198                                  	;invoke	Fast_Dispatch		; call fastopen/seek	;AN000;
  6199 00000990 E8DB1C                  	call	Fast_Dispatch
  6200                                  nofast:
  6201 00000993 5A                      	POP	DX						;AN000;
  6202 00000994 5E                      	POP	SI			; restore regs		;AN000;
  6203 00000995 58                      	POP	AX			 			;AN000;
  6204 00000996 C3                      	retn				; exit
  6205                                  
  6206                                  ;============================================================================
  6207                                  ; DOSMES.INC (MSDOS 6.0, 1991)
  6208                                  ;============================================================================
  6209                                  ; 29/04/2019 - Retro DOS v4.0
  6210                                  
  6211                                  ;include dossym.inc
  6212                                  ;include dosmac.inc
  6213                                  ;include doscntry.inc
  6214                                  
  6215                                  ; DOSCODE Segment
  6216                                  
  6217                                  ; 17/07/2018 - Retro DOS v3.0  [ DOSMES.INC (MSDOS 3.3, 1987) ]
  6218                                  ; ---------------------------------------------------------------------------
  6219                                  ;include divmes.inc
  6220                                  
  6221                                  ; DOSCODE:4778h (MSDOS 6.21, MSDOS.SYS)
  6222                                  ; -------------------------------------
  6223                                  ; DOSCODE:476Bh (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6224                                  
  6225                                  ; THIS IS THE ONLY DOS "MESSAGE". IT DOES NOT NEED A TERMINATOR.
  6226                                  	;PUBLIC	DIVMES
  6227                                  
  6228 00000997 0D0A44697669646520-     DIVMES:	DB	13,10,"Divide overflow",13,10
  6228 000009A0 6F766572666C6F770D-
  6228 000009A9 0A                 
  6229                                  
  6230                                  	;PUBLIC	DivMesLen
  6231                                  DivMesLen:
  6232 000009AA 1300                    	DW	$-DIVMES  ; 19	; Length of the above message in bytes
  6233                                  
  6234                                  ; DOSCODE:478Dh (MSDOS 6.21, MSDOS.SYS)
  6235                                  ; -------------------------------------
  6236                                  ; DOSCODE:4780h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6237                                  
  6238                                  ; (MSDOS 6.0)
  6239                                  ; VxD not found error message
  6240                                  
  6241                                  NoVxDErrMsg:
  6242 000009AC 596F75206D75737420-     	db  'You must have the file WINA20.386 in the root of your boot drive'
  6242 000009B5 686176652074686520-
  6242 000009BE 66696C652057494E41-
  6242 000009C7 32302E33383620696E-
  6242 000009D0 2074686520726F6F74-
  6242 000009D9 206F6620796F757220-
  6242 000009E2 626F6F742064726976-
  6242 000009EB 65                 
  6243 000009EC 0D0A746F2072756E20-     	db  0Dh,0Ah,'to run Windows in Enhanced Mode',0Dh,0Ah
  6243 000009F5 57696E646F77732069-
  6243 000009FE 6E20456E68616E6365-
  6243 00000A07 64204D6F64650D0A   
  6244                                  
  6245                                  VxDMesLen equ $ - NoVxDErrMsg  ; 99
  6246                                  
  6247                                  ; 13/05/2019 - Retro DOS v4.0
  6248                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6249                                  
  6250                                  ;include yesno.asm  (MNSDOS 6.0)
  6251                                  ; -------------------------------------
  6252                                  ; DOSCODE:47F0h (MSDOS 6.21, MSDOS.SYS)
  6253                                  ; DOSCODE:47E3h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6254                                  
  6255                                  ; This is for country Yes and No
  6256                                  
  6257 00000A0F 59                      NLS_YES:	db 'Y'
  6258 00000A10 4E                      NLS_NO:		db 'N'
  6259 00000A11 79                      NLS_yes2:	db 'y'
  6260 00000A12 6E                      NLS_no2:	db 'n'
  6261                                  
  6262                                  ; ---------------------------------------------------------------------------
  6263                                  
  6264                                  ; DOSCODE:47F4h (MSDOS 6.21, MSDOS.SYS)
  6265                                  ; DOSCODE:47E7h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6266                                  
  6267                                  ;SUBTTL EDIT FUNCTION ASSIGNMENTS AND HEADERS
  6268                                  
  6269                                  ; The following two tables implement the current buffered input editing
  6270                                  ; routines. The tables are pairwise associated in reverse order for ease
  6271                                  ; in indexing. That is; The first entry in ESCTAB corresponds to the last
  6272                                  ; entry in ESCFUNC, and the last entry in ESCTAB to the first entry in ESCFUNC.
  6273                                  
  6274                                  	;PUBLIC	CANCHAR
  6275                                  CANCHAR:
  6276 00000A13 1B                      	DB	CANCEL	; 1Bh	;Cancel line character
  6277                                  	
  6278                                  	;PUBLIC	ESCCHAR
  6279                                  ESCCHAR:
  6280 00000A14 00                      	DB	ESCCH	; 0	;Lead-in character for escape sequences
  6281                                  	
  6282                                  	;IF	NOT Rainbow
  6283                                  
  6284                                  ESCTAB:	; LABEL BYTE
  6285                                  
  6286                                  	;IF	IBM
  6287 00000A15 40                      	DB	64		; Ctrl-Z - F6
  6288 00000A16 4D                      	DB	77		; Copy one char - -->
  6289 00000A17 3B                      	DB	59		; Copy one char - F1
  6290 00000A18 53                      	DB	83		; Skip one char - DEL
  6291 00000A19 3C                      	DB	60		; Copy to char - F2
  6292 00000A1A 3E                      	DB	62		; Skip to char - F4
  6293 00000A1B 3D                      	DB	61		; Copy line - F3
  6294 00000A1C 3D                      	DB	61		; Kill line (no change to template ) - Not used
  6295 00000A1D 3F                      	DB	63		; Reedit line (new template) - F5
  6296 00000A1E 4B                      	DB	75		; Backspace - <--
  6297 00000A1F 52                      	DB	82		; Enter insert mode - INS (toggle)
  6298 00000A20 52                      	DB	82		; Exit insert mode - INS (toggle)
  6299 00000A21 41                      	DB	65		; Escape character - F7
  6300 00000A22 41                      	DB	65		; End of table
  6301                                  	;ENDIF
  6302                                  
  6303                                  ESCEND: ; LABEL BYTE
  6304                                  
  6305                                  ESCTABLEN EQU ESCEND-ESCTAB
  6306                                  
  6307                                  ESCFUNC: ; LABEL WORD
  6308                                  	
  6309 00000A23 [E913]                  	short_addr  GETCH	; Ignore the escape sequence
  6310 00000A25 [6614]                  	short_addr  TWOESC
  6311 00000A27 [5B15]                  	short_addr  EXITINS
  6312 00000A29 [5B15]                  	short_addr  ENTERINS
  6313 00000A2B [6114]                  	short_addr  BACKSP
  6314 00000A2D [4715]                  	short_addr  REEDIT
  6315 00000A2F [4E14]                  	short_addr  KILNEW
  6316 00000A31 [DD14]                  	short_addr  COPYLIN
  6317 00000A33 [0F15]                  	short_addr  SKIPSTR
  6318 00000A35 [E314]                  	short_addr  COPYSTR
  6319 00000A37 [0615]                  	short_addr  SKIPONE
  6320 00000A39 [E814]                  	short_addr  COPYONE
  6321 00000A3B [E814]                  	short_addr  COPYONE
  6322 00000A3D [6215]                  	short_addr  CTRLZ
  6323                                  
  6324                                  	;ENDIF
  6325                                  
  6326                                  ; DOSMES.INC (MSDOS 6.0, 1991)
  6327                                  ; ---------------------------------------------------------------------------
  6328                                  ; DOSMES.ASM (MSDOS 2.11, 1983)
  6329                                  
  6330                                  ; OEMFunction key is expected to process a single function
  6331                                  ;   key input from a device and dispatch to the proper
  6332                                  ;   routines leaving all registers UNTOUCHED.
  6333                                  ;
  6334                                  ; Inputs:   CS, SS are DOSGROUP
  6335                                  ; Outputs:  None. This function is expected to JMP to onw of
  6336                                  ;           the following labels:
  6337                                  ;
  6338                                  ;           GetCh       - ignore the sequence
  6339                                  ;           TwoEsc      - insert an ESCChar in the buffer
  6340                                  ;           ExitIns     - toggle insert mode
  6341                                  ;           EnterIns    - toggle insert mode
  6342                                  ;           BackSp      - move backwards one space
  6343                                  ;           ReEdit      - reedit the line with a new template
  6344                                  ;           KilNew      - discard the current line and start from scratch
  6345                                  ;           CopyLin     - copy the rest of the template into the line
  6346                                  ;           SkipStr     - read the next character and skip to it in the template
  6347                                  ;           CopyStr     - read next char and copy from template to line until char
  6348                                  ;           SkipOne     - advance position in template one character
  6349                                  ;           CopyOne     - copy next character in template into line
  6350                                  ;           CtrlZ       - place a ^Z into the template
  6351                                  ; Registers that are allowed to be modified by this function are:
  6352                                  ;           AX, CX, BP
  6353                                  
  6354                                  ; 13/05/2019 - Retro DOS v4.0
  6355                                  ; -------------------------------------
  6356                                  ; DOSCODE:4820h (MSDOS 6.21, MSDOS.SYS)
  6357                                  
  6358                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6359                                  ; -------------------------------------
  6360                                  ; DOSCODE:4813h (MSDOS 5.0, MSDOS.SYS)
  6361                                  
  6362                                  OEMFunctionKey:
  6363 00000A3F E80A09                  	CALL	_$STD_CON_INPUT_NO_ECHO	; Get the second byte of the sequence
  6364 00000A42 B10E                    	MOV     CL,ESCTABLEN ; 14	; length of table for scan
  6365 00000A44 57                      	PUSH    DI                      ; save DI (cannot change it!)
  6366 00000A45 BF[150A]                	MOV     DI,ESCTAB		; offset of second byte table
  6367 00000A48 06                      	push	es
  6368 00000A49 0E                      	push	cs
  6369 00000A4A 07                      	pop	es
  6370 00000A4B F2AE                    	REPNE   SCASB                   ; Look it up in the table
  6371 00000A4D 07                      	pop	es
  6372 00000A4E 5F                      	POP     DI                      ; restore DI
  6373 00000A4F D1E1                    	SHL     CX,1                    ; convert byte offset to word
  6374 00000A51 89CD                    	MOV     BP,CX                   ; move to indexable register
  6375                                  	;JMP	word [BP+ESCFUNC]	; Go to the right routine
  6376 00000A53 2EFFA6[230A]            	JMP	word [CS:BP+ESCFUNC]
  6377                                  
  6378                                  ;DOSCODE ENDS
  6379                                  	
  6380                                  ;============================================================================
  6381                                  ; TIME.ASM (MSDOS 6.0, 1991)
  6382                                  ;============================================================================
  6383                                  ; Retro DOS v3.0 - 18/07/2018
  6384                                  
  6385                                  ; SYSCALL.ASM (MSDOS 2.11, 1983)
  6386                                  ;----------------------------------------------------------------------------
  6387                                  ; Retro DOS v2.0 - 13/03/2018
  6388                                  
  6389                                  ;**	TIME.ASM - System Calls and low level routines for DATE and TIME
  6390                                  
  6391                                  	;BREAK <DATE AND TIME - SYSTEM CALLS 42,43,44,45>
  6392                                  
  6393                                  ;**	$GET_DATE - Get Current Date
  6394                                  ;----------------------------------------
  6395                                  ;	ENTRY	none
  6396                                  ;	EXIT	(cx:dx) = current date
  6397                                  ;	USES	all
  6398                                  
  6399                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6400                                  
  6401                                  _$GET_DATE:	;System call 42
  6402                                  
  6403 00000A58 16                      	PUSH	SS
  6404 00000A59 1F                      	POP	DS
  6405 00000A5A E8AD00                  	CALL	READTIME	;Check for rollover to next day
  6406 00000A5D A1[5203]                	MOV	AX,[YEAR]
  6407                                  
  6408                                  ;	WARNING!!!! DAY and MONTH must be adjacently allocated!
  6409                                  
  6410 00000A60 8B1E[5003]              	MOV	BX,[DAY]	; fetch both day and month
  6411 00000A64 E81AFA                  	CALL	Get_User_Stack	;Get pointer to user registers
  6412                                  	;MOV	[SI+6],BX	;DH=month, DL=day
  6413 00000A67 895C06                  	MOV	[SI+user_env.user_DX],BX
  6414 00000A6A 05BC07                  	ADD	AX,1980		;Put bias back
  6415                                  	;MOV	[SI+4],AX	;CX=year
  6416 00000A6D 894404                  	MOV	[SI+user_env.user_CX],AX
  6417 00000A70 36A0[5603]              	MOV	AL,[SS:WEEKDAY]	;hkn; SS override
  6418                                  RET20:	; 05/11/2022
  6419                                  RET24:	; 18/12/2022
  6420 00000A74 C3                      	RETN
  6421                                  
  6422                                  ;**	$SET_DATE - Set Current Date
  6423                                  ;----------------------------------------
  6424                                  ;	ENTRY	(cx:dx) = current date
  6425                                  ;	EXIT	(al) = -1 iff bad date
  6426                                  ;		(al) = 0 if ok
  6427                                  ;	USES	all
  6428                                  
  6429                                  _$SET_DATE:	;System call 43
  6430                                  
  6431 00000A75 B0FF                    	MOV	AL,-1		;Be ready to flag error
  6432 00000A77 81E9BC07                	SUB	CX,1980		;Fix bias in year
  6433                                  	;JC	SHORT RET24	;Error if not big enough
  6434                                  	; 05/11/2022
  6435 00000A7B 72F7                    	jc	short RET20
  6436 00000A7D 83F977                  	CMP	CX,119		;Year must be less than 2100
  6437 00000A80 77F2                    	JA	SHORT RET24
  6438 00000A82 08F6                    	OR	DH,DH
  6439                                  	;JZ	SHORT RET24
  6440                                   	; 05/11/2022
  6441 00000A84 74EE                    	jz	short RET20
  6442 00000A86 08D2                    	OR	DL,DL
  6443                                  	;JZ	SHORT RET24	;Error if either month or day is 0
  6444                                  	; 05/11/2022
  6445 00000A88 74EA                    	jz	short RET20
  6446 00000A8A 80FE0C                  	CMP	DH,12		;Check against max. month
  6447 00000A8D 77E5                    	JA	SHORT RET24
  6448 00000A8F 16                      	PUSH	SS
  6449 00000A90 1F                      	POP	DS
  6450                                  	;CALL	DODATE
  6451                                  	; 18/12/2022
  6452 00000A91 E90301                  	jmp	DODATE
  6453                                  ;RET24:  
  6454                                  	;RETN
  6455                                  
  6456                                  ;**	$GET_TIME - Get Current Time
  6457                                  ;----------------------------------------
  6458                                  ;	ENTRY	none
  6459                                  ;	EXIT	(cx:dx) = current time
  6460                                  ;	USES	all
  6461                                  
  6462                                  _$GET_TIME:			;System call 44
  6463                                  
  6464 00000A94 16                      	PUSH	SS
  6465 00000A95 1F                      	POP	DS
  6466 00000A96 E87100                  	CALL	READTIME
  6467 00000A99 E8E5F9                  	CALL	Get_User_Stack	;Get pointer to user registers
  6468                                  	;MOV	[SI+6],DX
  6469 00000A9C 895406                  	MOV	[SI+user_env.user_DX],DX
  6470                                  	;MOV	[SI+4],CX
  6471 00000A9F 894C04                  	MOV	[SI+user_env.user_CX],CX
  6472                                  set_time_ok:	; 06/01/2024
  6473 00000AA2 30C0                    	XOR	AL,AL
  6474                                  RET26:  
  6475 00000AA4 C3                      	RETN
  6476                                  
  6477                                  ;**	$SET_TIME - Set Current Time
  6478                                  ;----------------------------------------
  6479                                  ;	ENTRY	(cx:dx) = time
  6480                                  ;	EXIT	(al) = 0 if 0k
  6481                                  ;		(al) = -1 if invalid
  6482                                  ;	USES	ALL
  6483                                  
  6484                                  _$SET_TIME:			;System call 45
  6485                                  
  6486 00000AA5 B0FF                    	MOV	AL,-1		;Flag in case of error
  6487 00000AA7 80FD18                  	CMP	CH,24		;Check hours
  6488 00000AAA 73F8                    	JAE	SHORT RET26
  6489 00000AAC 80F93C                  	CMP	CL,60		;Check minutes
  6490 00000AAF 73F3                    	JAE	SHORT RET26
  6491 00000AB1 80FE3C                  	CMP	DH,60		;Check seconds
  6492 00000AB4 73EE                    	JAE	SHORT RET26
  6493 00000AB6 80FA64                  	CMP	DL,100		;Check 1/100's
  6494 00000AB9 73E9                    	JAE	SHORT RET26
  6495 00000ABB 51                      	PUSH	CX
  6496 00000ABC 52                      	PUSH	DX
  6497 00000ABD 16                      	PUSH	SS
  6498 00000ABE 1F                      	POP	DS
  6499                                  
  6500                                  ; 07/02/2024
  6501                                  %if 0
  6502                                  	MOV	BX,TIMEBUF
  6503                                  	MOV	CX,6
  6504                                  	; 06/02/2024 ; *
  6505                                  	;;XOR	DX,DX
  6506                                  	;;MOV	AX,DX
  6507                                  	;xor	ax,ax
  6508                                  	;cwd	; 06/01/2024
  6509                                  	PUSH	BX
  6510                                  	;CALL	SETREAD
  6511                                  	; 06/02/2024 ; *
  6512                                  	call	SETREAD_X
  6513                                  %else
  6514 00000ABF E8BE3A                  	call	SETREAD_XT
  6515                                  %endif
  6516                                  
  6517 00000AC2 1E                      	PUSH	DS
  6518 00000AC3 C536[2E00]              	LDS	SI,[BCLOCK]
  6519 00000AC7 E83F3A                  	CALL	DEVIOCALL2	;Get correct day count
  6520 00000ACA 1F                      	POP	DS
  6521 00000ACB 5B                      	POP	BX
  6522 00000ACC E8EE3A                  	CALL	SETWRITE
  6523 00000ACF 8F06[BA03]              	POP	WORD [TIMEBUF+4]
  6524 00000AD3 8F06[B803]              	POP	WORD [TIMEBUF+2]
  6525 00000AD7 C536[2E00]              	LDS	SI,[BCLOCK]
  6526 00000ADB E82B3A                  	CALL	DEVIOCALL2	;Set the time
  6527                                  	; 06/01/2024
  6528                                  	;XOR	AL,AL
  6529                                  	;RETN
  6530 00000ADE EBC2                    	jmp	short set_time_ok
  6531                                  
  6532                                  ; 11/07/2018 - Retro DOS v3.0
  6533                                  ; Retro DOS v2.0 - 14/03/2018
  6534                                  
  6535                                  FOURYEARS EQU 3*365 + 366  ; = 1461 
  6536                                  
  6537                                  ;SUBTTL DATE16, READTIME, DODATE -- GUTS OF TIME AND DATE
  6538                                  ;----------------------------------------------------------
  6539                                  ; Date16 returns the current date in AX, current time in DX
  6540                                  ;   AX - YYYYYYYMMMMDDDDD  years months days
  6541                                  ;   DX - HHHHHMMMMMMSSSSS  hours minutes seconds/2
  6542                                  
  6543                                  DATE16:
  6544                                  	
  6545                                  ;M048	Context DS
  6546                                  ;
  6547                                  ; Since this function can be called thru int 2f we shall not assume that SS
  6548                                  ; is DOSDATA
  6549                                  
  6550                                  	;push	ss
  6551                                  	;pop	ds
  6552                                  
  6553                                  	;getdseg <ds>		; M048
  6554                                  
  6555                                  	; 13/05/2019 - Retro DOS v4.0
  6556 00000AE0 2E8E1E[0700]            	mov	ds, [cs:DosDSeg]	
  6557                                  
  6558 00000AE5 51                      	PUSH	CX
  6559 00000AE6 06                      	PUSH	ES
  6560 00000AE7 E82000                  	CALL	READTIME
  6561 00000AEA 07                      	POP	ES
  6562 00000AEB D0E1                    	SHL	CL,1		;Minutes to left part of byte
  6563 00000AED D0E1                    	SHL	CL,1
  6564 00000AEF D1E1                    	SHL	CX,1		;Push hours and minutes to left end
  6565 00000AF1 D1E1                    	SHL	CX,1
  6566 00000AF3 D1E1                    	SHL	CX,1
  6567 00000AF5 D0EE                    	SHR	DH,1		;Count every two seconds
  6568 00000AF7 08F1                    	OR	CL,DH		;Combine seconds with hours and minutes
  6569 00000AF9 89CA                    	MOV	DX,CX
  6570                                  
  6571                                  ;	WARNING! MONTH and YEAR must be adjacently allocated
  6572                                  
  6573 00000AFB A1[5103]                	MOV	AX,[MONTH]	;Fetch month and year
  6574 00000AFE B104                    	MOV	CL,4
  6575 00000B00 D2E0                    	SHL	AL,CL		;Push month to left to make room for day
  6576 00000B02 D1E0                    	SHL	AX,1
  6577 00000B04 59                      	POP	CX
  6578 00000B05 0A06[5003]              	OR	AL,[DAY]
  6579                                  RET21:
  6580 00000B09 C3                      	RETN
  6581                                  
  6582                                  ;----------------------------------------------------------
  6583                                  
  6584                                  READTIME:
  6585                                  
  6586                                  ;Gets time in CX:DX. Figures new date if it has changed.
  6587                                  ;Uses AX, CX, DX.
  6588                                  
  6589 00000B0A C706[910D]0000          	MOV	word [DATE_FLAG],0 ; reset date flag for CPMIO
  6590 00000B10 56                      	PUSH	SI
  6591 00000B11 53                      	PUSH	BX
  6592                                  
  6593 00000B12 BB[B603]                	MOV	BX,TIMEBUF
  6594                                  ; 07/02/2024
  6595                                  %if 0
  6596                                  	MOV	CX,6
  6597                                  	; 06/02/2024
  6598                                  	;;XOR	DX,DX
  6599                                  	;;MOV	AX,DX
  6600                                  	;; 06/01/2024
  6601                                  	;xor	ax,ax
  6602                                  	;cwd
  6603                                  	;CALL	SETREAD
  6604                                  	; 06/02/2024
  6605                                  	call	SETREAD_X
  6606                                  %else
  6607 00000B15 E86C3A                  	call	SETREAD_XTC
  6608                                  %endif
  6609 00000B18 1E                      	PUSH	DS
  6610 00000B19 C536[2E00]              	LDS	SI,[BCLOCK]
  6611 00000B1D E8E939                  	CALL	DEVIOCALL2	;Get correct date and time
  6612 00000B20 1F                      	POP	DS
  6613 00000B21 5B                      	POP	BX
  6614 00000B22 5E                      	POP	SI
  6615 00000B23 A1[B603]                	MOV	AX,[TIMEBUF]
  6616 00000B26 8B0E[B803]              	MOV	CX,[TIMEBUF+2]
  6617 00000B2A 8B16[BA03]              	MOV	DX,[TIMEBUF+4]
  6618 00000B2E 3B06[5403]              	CMP	AX,[DAYCNT]	;See if day count is the same
  6619                                  	;JZ	SHORT RET22
  6620 00000B32 74D5                    	JZ	SHORT RET21 ; 18/07/2018
  6621                                  	;cmp	ax,43830
  6622 00000B34 3D36AB                  	CMP	AX,FOURYEARS*30 ;Number of days in 120 years
  6623 00000B37 733D                    	JAE	SHORT RET22	;Ignore if too large
  6624 00000B39 A3[5403]                	MOV	[DAYCNT],AX
  6625 00000B3C 56                      	PUSH	SI
  6626 00000B3D 51                      	PUSH	CX
  6627 00000B3E 52                      	PUSH	DX		;Save time
  6628 00000B3F 31D2                    	XOR	DX,DX
  6629                                  	;mov	cx,1461
  6630 00000B41 B9B505                  	MOV	CX,FOURYEARS	;Number of days in 4 years
  6631 00000B44 F7F1                    	DIV	CX		;Compute number of 4-year units
  6632 00000B46 D1E0                    	SHL	AX,1
  6633 00000B48 D1E0                    	SHL	AX,1
  6634 00000B4A D1E0                    	SHL	AX,1		;Multiply by 8 (no. of half-years)
  6635 00000B4C 89C1                    	MOV	CX,AX		;<240 implies AH=0
  6636                                  
  6637 00000B4E BE[140D]                	MOV	SI,YRTAB	;Table of days in each year
  6638                                  
  6639 00000B51 E82300                  	CALL	DSLIDE		;Find out which of four years we're in
  6640 00000B54 D1E9                    	SHR	CX,1		;Convert half-years to whole years
  6641 00000B56 7304                    	JNC	SHORT SK	;Extra half-year?
  6642 00000B58 81C2C800                	ADD	DX,200
  6643                                  SK:
  6644 00000B5C E82200                  	CALL	SETYEAR
  6645 00000B5F B101                    	MOV	CL,1		;At least at first month in year
  6646                                  
  6647 00000B61 BE[1C0D]                	MOV	SI,MONTAB	;Table of days in each month
  6648                                  	
  6649 00000B64 E81000                  	CALL	DSLIDE		;Find out which month we're in
  6650 00000B67 880E[5103]              	MOV	[MONTH],CL
  6651 00000B6B 42                      	INC	DX		;Remainder is day of month (start with one)
  6652 00000B6C 8816[5003]              	MOV	[DAY],DL
  6653 00000B70 E88A00                  	CALL	WKDAY		;Set day of week
  6654 00000B73 5A                      	POP	DX
  6655 00000B74 59                      	POP	CX
  6656 00000B75 5E                      	POP	SI
  6657                                  RET22:  
  6658 00000B76 C3                      	RETN
  6659                                  
  6660                                  ;----------------------------------------------------------
  6661                                  
  6662                                  DSLIDE:
  6663                                  	;MOV	AH,0
  6664                                  	; 06/01/2024
  6665                                  	; (AH=0)
  6666                                  DSLIDE1:
  6667 00000B77 AC                      	LODSB			;Get count of days
  6668 00000B78 39C2                    	CMP	DX,AX		;See if it will fit
  6669                                  	;JB	SHORT RET23	;If not, done
  6670 00000B7A 72FA                    	jb	short RET22 ; 13/05/2019 - Retro DOS v4.0
  6671 00000B7C 29C2                    	SUB	DX,AX
  6672 00000B7E 41                      	INC	CX		;Count one more month/year
  6673 00000B7F EBF6                    	JMP	SHORT DSLIDE1
  6674                                  
  6675                                  ;----------------------------------------------------------
  6676                                  
  6677                                  SETYEAR:
  6678                                  
  6679                                  ;Set year with value in CX. Adjust length of February for this year.
  6680                                  
  6681                                  ; NOTE: This can also be called thru int 2f. If this is called then it will
  6682                                  ;	  set DS to DOSDATA. Since the only guy calling this should be the DOS
  6683                                  ;	redir, DS will be DOSDATA anyway. It is going to be in-efficient to
  6684                                  ;	preserve DS as CHKYR is also called as a routine.
  6685                                  
  6686                                  	; MSDOS 6.0 (18/07/2018) ; *
  6687                                  
  6688                                  	;GETDSEG DS
  6689                                  
  6690                                  	;PUSH	CS  ; *
  6691                                  	;POP	DS  ; *
  6692                                  
  6693                                  	; 13/05/2019 - Retro DOS v4.0
  6694 00000B81 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6695                                  
  6696                                  	; Offset 18CEh in IBMDOS.COM (MSDOS 3.3), 1987
  6697                                  	; 05/11/2022 
  6698                                  	; DOSCODE:4970h in MSDOS.SYS (MSDOS 5.0), 1991 
  6699                                  
  6700 00000B86 880E[5203]              	MOV	[YEAR],CL
  6701                                  CHKYR:
  6702 00000B8A F6C103                  	TEST	CL,3		;Check for leap year
  6703 00000B8D B01C                    	MOV	AL,28
  6704 00000B8F 7502                    	JNZ	SHORT SAVFEB	;28 days if no leap year
  6705 00000B91 FEC0                    	INC	AL		;Add leap day
  6706                                  SAVFEB:
  6707 00000B93 A2[1D0D]                	mov	[february],al
  6708                                  	;MOV	[MONTAB+1],AL	;Store for February
  6709                                  RET23:  
  6710 00000B96 C3                      	RETN
  6711                                  
  6712                                  ;----------------------------------------------------------
  6713                                  
  6714                                  DODATE:
  6715 00000B97 E8F0FF                  	CALL	CHKYR		;Set Feb. up for new year
  6716 00000B9A 88F0                    	MOV	AL,DH
  6717                                  
  6718 00000B9C BB[1B0D]                	MOV	BX,MONTAB-1	;DOSDATA:0D1Bh for MSDOS 6.21
  6719                                  
  6720 00000B9F D7                      	XLAT			;Look up days in month
  6721 00000BA0 38D0                    	CMP	AL,DL
  6722 00000BA2 B0FF                    	MOV	AL,-1		;Restore error flag, just in case
  6723                                  	;JB	SHORT RET25	;Error if too many days
  6724 00000BA4 72F0                    	jb	short RET23 ; 18/07/2018
  6725 00000BA6 E8D8FF                  	CALL	SETYEAR
  6726                                  ;
  6727                                  ; WARNING! DAY and MONTH must be adjacently allocated
  6728                                  ;
  6729 00000BA9 8916[5003]              	MOV	[DAY],DX	;Set both day and month
  6730 00000BAD D1E9                    	SHR	CX,1
  6731 00000BAF D1E9                    	SHR	CX,1
  6732                                  	;mov	ax,1461
  6733 00000BB1 B8B505                  	MOV	AX,FOURYEARS
  6734 00000BB4 89D3                    	MOV	BX,DX
  6735 00000BB6 F7E1                    	MUL	CX
  6736 00000BB8 8A0E[5203]              	MOV	CL,[YEAR]
  6737 00000BBC 80E103                  	AND	CL,3
  6738                                  
  6739 00000BBF BE[140D]                	MOV	SI,YRTAB
  6740                                  
  6741 00000BC2 89C2                    	MOV	DX,AX
  6742 00000BC4 D1E1                    	SHL	CX,1		;Two entries per year, so double count
  6743 00000BC6 E84700                  	CALL	DSUM		;Add up the days in each year
  6744 00000BC9 88F9                    	MOV	CL,BH		;Month of year
  6745                                  
  6746 00000BCB BE[1C0D]                	MOV	SI,MONTAB
  6747                                  
  6748 00000BCE 49                      	DEC	CX		;Account for months starting with one
  6749 00000BCF E83E00                  	CALL	DSUM		;Add up days in each month
  6750 00000BD2 88D9                    	MOV	CL,BL		;Day of month
  6751 00000BD4 49                      	DEC	CX		;Account for days starting with one
  6752 00000BD5 01CA                    	ADD	DX,CX		;Add in to day total
  6753 00000BD7 92                      	XCHG	AX,DX		;Get day count in AX
  6754 00000BD8 A3[5403]                	MOV	[DAYCNT],AX
  6755 00000BDB 56                      	PUSH	SI
  6756 00000BDC 53                      	PUSH	BX
  6757 00000BDD 50                      	PUSH	AX
  6758                                  
  6759                                  ; 07/02/2024
  6760                                  %if 0
  6761                                  	MOV	BX,TIMEBUF
  6762                                  	MOV	CX,6
  6763                                  	; 06/02/2024 ; *
  6764                                  	;;XOR	DX,DX
  6765                                  	;;MOV	AX,DX
  6766                                  	;; 06/01/2024
  6767                                  	;xor	ax,ax
  6768                                  	;cwd
  6769                                  	PUSH	BX
  6770                                  	;CALL	SETREAD
  6771                                  	; 06/02/2024 ; *
  6772                                  	call	SETREAD_X
  6773                                  %else
  6774 00000BDE E89F39                  	call	SETREAD_XT
  6775                                  %endif
  6776                                  
  6777 00000BE1 1E                      	PUSH	DS
  6778 00000BE2 C536[2E00]              	LDS	SI,[BCLOCK]
  6779 00000BE6 E82039                  	CALL	DEVIOCALL2	;Get correct date and time
  6780 00000BE9 1F                      	POP	DS
  6781 00000BEA 5B                      	POP	BX
  6782 00000BEB E8CF39                  	CALL	SETWRITE
  6783 00000BEE 8F06[B603]              	POP	WORD [TIMEBUF]
  6784 00000BF2 1E                      	PUSH	DS
  6785 00000BF3 C536[2E00]              	LDS	SI,[BCLOCK]
  6786 00000BF7 E80F39                  	CALL	DEVIOCALL2	;Set the date
  6787 00000BFA 1F                      	POP	DS
  6788 00000BFB 5B                      	POP	BX
  6789 00000BFC 5E                      	POP	SI
  6790                                  WKDAY:
  6791 00000BFD A1[5403]                	MOV	AX,[DAYCNT]
  6792 00000C00 31D2                    	XOR	DX,DX
  6793 00000C02 B90700                  	MOV	CX,7
  6794 00000C05 40                      	INC	AX
  6795 00000C06 40                      	INC	AX		;First day was Tuesday
  6796 00000C07 F7F1                    	DIV	CX		;Compute day of week
  6797 00000C09 8816[5603]              	MOV	[WEEKDAY],DL
  6798 00000C0D 30C0                    	XOR	AL,AL		;Flag OK
  6799                                  RET25:
  6800 00000C0F C3                      	RETN
  6801                                  
  6802                                  ;----------------------------------------------------------
  6803                                  
  6804                                  ;**	DSUM - Compute the sum of a string of bytes
  6805                                  ;
  6806                                  ;	ENTRY	(cx) = byte count
  6807                                  ;		(ds:si) = byte address
  6808                                  ;		(dx) = sum register, initialized by caller
  6809                                  ;	EXIT	(dx) updated
  6810                                  ;	USES	ax, cx, dx, si, flags
  6811                                  
  6812                                  DSUM:
  6813 00000C10 B400                    	MOV	AH,0
  6814 00000C12 E305                    	JCXZ	DSUM9 ; 13/05/2019 - Retro DOS v4.0
  6815                                  	;JCXZ	RET25 ; 18/07/2018
  6816                                  DSUM1:
  6817 00000C14 AC                      	LODSB
  6818 00000C15 01C2                    	ADD	DX,AX
  6819 00000C17 E2FB                    	LOOP	DSUM1
  6820                                  DSUM9:
  6821 00000C19 C3                      	RETN
  6822                                  
  6823                                  ;============================================================================
  6824                                  ; GETSET.ASM (MSDOS 6.0, 1991)
  6825                                  ;============================================================================
  6826                                  ; 29/04/2019 - Retro DOS v4.0
  6827                                  ; 18/07/2018 - Retro DOS v3.0 (GETSET.ASM, MSDOS 6.0, 1991)
  6828                                  
  6829                                  ; 12/03/2018 - Retro DOS v2.0 
  6830                                  
  6831                                  ;TITLE	GETSET - GETting and SETting MS-DOS system calls
  6832                                  ;NAME	GETSET
  6833                                  
  6834                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
  6835                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
  6836                                  
  6837                                  ;USERNUM:
  6838                                  ;	DW	0			; 24 bit user number
  6839                                  ;       DB      0
  6840                                  ;;	IF      IBM
  6841                                  ;;OEMNUM: DB    0			; 8 bit OEM number
  6842                                  ;;	ELSE
  6843                                  ;OEMNUM: DB     0FFH			; 8 bit OEM number
  6844                                  ;;	ENDIF
  6845                                  
  6846                                  ;MSVERS:		; MS-DOS version in hex for $GET_VERSION
  6847                                  ;; 08/07/2018 - Retro DOS v3.0
  6848                                  ;MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  6849                                  ;MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  6850                                  
  6851                                  ;BREAK <$Get_Version -- Return MSDOS version number>
  6852                                  ;----------------------------------------------------------------------------
  6853                                  
  6854                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6855                                  ; DOSCODE:4A0Fh (MSDOS 5.0 MSDOS.SYS)
  6856                                  
  6857                                  _$GET_VERSION:
  6858                                  
  6859                                  ; Inputs:
  6860                                  ;       None
  6861                                  ; Function:
  6862                                  ;       Return MS-DOS version number
  6863                                  ; Outputs:
  6864                                  ;       OEM number in BH
  6865                                  ;       User number in BL:CX (24 bits)
  6866                                  ;       Version number as AL.AH in binary
  6867                                  ;       NOTE: On pre 1.28 DOSs AL will be zero
  6868                                  
  6869                                  ; MSDOS 6.0
  6870                                  ;
  6871                                  ;	Fake_Count is used to lie about the version numbers to support
  6872                                  ;	old binarys. See ms_table.asm for more info.
  6873                                  ;
  6874                                  ;		if input al = 00
  6875                                  ;		  (bh) = OEM number			
  6876                                  ;		else if input al = 01
  6877                                  ;		  (bh) = version flags
  6878                                  ;		 
  6879                                  ;		       	 bits 0-2 = DOS internal revision
  6880                                  ;		       	 bits 3-7 = DOS type flags
  6881                                  ;		              bit 3    = DOS is in ROM
  6882                                  ;		              bit 4    = DOS in in HMA
  6883                                  ;		              bits 5-7 = reserved
  6884                                  ;               M007 change - only bit 3 is now valid. Other bits
  6885                                  ;               are 0 when AL = 1
  6886                                  
  6887                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
  6888 00000C1A 36C50E[B203]            	lds	cx, [ss:USERNUM]
  6889 00000C1F 8CDB                    	mov	bx, ds
  6890                                  
  6891                                  	; MSDOS 3.3 (IBMDOS.COM, offset 196Dh)
  6892                                  	;--------------------------------------
  6893                                  	; MSDOS 6.21 (MSDOS.SYS, DOSCODE:4A1Ch)
  6894                                  
  6895 00000C21 16                              PUSH    SS
  6896 00000C22 1F                              POP     DS
  6897                                          
  6898                                  	; 06/01/2024
  6899                                  	;MOV	BX,[USERNUM+2]
  6900                                          ;MOV	CX,[USERNUM]
  6901                                  
  6902                                  	; 13/05/2019 - Retro DOS v4.0
  6903                                  
  6904                                  	;If AL == 1, ROMDOS will return BH = dos internal version # &
  6905                                  	;DOS flags
  6906                                  
  6907 00000C23 3C01                    	cmp	AL,1
  6908 00000C25 7502                    	jne	short Norm_Vers
  6909                                  
  6910                                  ;ifdef ROMDOS
  6911                                  ;	mov	BH,DOSINROM 	; Just set the bit for ROM version
  6912                                  ;				(DOSINROM = 8)
  6913                                  ;else
  6914 00000C27 30FF                            xor     bh,bh		; Otherwise return 0
  6915                                  ;endif				;M007 end
  6916                                  
  6917                                  Norm_Vers:
  6918                                  	;MOV	AX,[MSVERS]  ; MSDOS 3.3
  6919                                  
  6920                                          	; MSDOS 6.0	; MSVERS is a label in TABLE segment	
  6921                                  	; 26/06/2024
  6922                                  	; 13/05/2019 - Retro DOS v4.0
  6923                                  	;push	ds		; Get the version number from the
  6924 00000C29 8E1E[3003]              	mov	ds,[CurrentPDB]	; current app's PSP segment
  6925                                  	;mov	ax,[40h]
  6926 00000C2D A14000                  	mov	ax,[PDB.Version] ; AX = DOS version number	
  6927                                  	; 07/12/2022
  6928                                  	;pop	ds
  6929 00000C30 E84EF8                  	call	Get_User_Stack
  6930                                  				; Put values for return registers
  6931                                  				; in the proper place on the user's	 
  6932                                  				; stack addressed by DS:SI
  6933                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
  6934                                  gdrvfspc_ret:
  6935                                          ;MOV	[SI+user_env.user_AX],AX
  6936 00000C33 8904                            MOV	[SI],AX
  6937                                          ;MOV	[SI+4],CX
  6938 00000C35 894C04                  	mov	[SI+user_env.user_CX],CX
  6939                                  set_user_bx:
  6940                                  	;MOV	[SI+2],BX
  6941 00000C38 895C02                  	mov	[SI+user_env.user_BX],BX
  6942                                  
  6943 00000C3B C3                      	RETN
  6944                                  
  6945                                  ; 18/07/2018 - Retro DOS v3.0
  6946                                  
  6947                                  ;BREAK <$Get/Set_Verify_on_Write - return/set verify-after-write flag>
  6948                                  ;----------------------------------------------------------------------------
  6949                                  
  6950                                  ;**	$Get_Verify_On_Write - Get Status of Verify on write flag
  6951                                  ;
  6952                                  ;	ENTRY	none
  6953                                  ;	EXIT	(al) = value of VERIFY flag
  6954                                  ;	USES	all
  6955                                  
  6956                                  
  6957                                  _$GET_VERIFY_ON_WRITE:
  6958                                  
  6959                                  ;hkn; SS override
  6960 00000C3C 36A0[FF02]              	MOV	AL,[SS:VERFLG]	; Retro DOS v2.0 - 12/03/2018
  6961 00000C40 C3                      	retn
  6962                                  
  6963                                  ;**	$Set_Verify_On_Write - Set Status of Verify on write flag
  6964                                  ;
  6965                                  ;	ENTRY	(al) = value of VERIFY flag
  6966                                  ;	EXIT	none
  6967                                  ;	USES	all
  6968                                  
  6969                                  _$SET_VERIFY_ON_WRITE:
  6970                                  
  6971 00000C41 2401                    	AND	AL,1
  6972                                  ;hkn; SS override
  6973 00000C43 36A2[FF02]              	MOV	[SS:VERFLG],AL	; Retro DOS v2.0 - 12/03/2018
  6974                                  RET27:	; 18/07/2018
  6975 00000C47 C3                      	retn
  6976                                  
  6977                                  ; 19/07/2018 - Retro DOS v3.0
  6978                                  
  6979                                  ;BREAK <$International - return country-dependent information>
  6980                                  ;----------------------------------------------------------------------------
  6981                                  ;
  6982                                  ; Procedure Name : $INTERNATIONAL
  6983                                  ;
  6984                                  ; Inputs:
  6985                                  ;	MOV	AH,International
  6986                                  ;	MOV	AL,country	(al = 0 => current country)
  6987                                  ;      [MOV	BX,country]
  6988                                  ;	LDS	DX,block
  6989                                  ;	INT	21
  6990                                  ; Function:
  6991                                  ;	give users an idea of what country the application is running
  6992                                  ; Outputs:
  6993                                  ;	IF DX != -1 on input (get country)
  6994                                  ;	  AL = 0 means return current country table.
  6995                                  ;	  0<AL<0FFH means return country table for country AL
  6996                                  ;	  AL = 0FF means return country table for country BX
  6997                                  ;	  No Carry:
  6998                                  ;	     Register BX will contain the 16-bit country code.
  6999                                  ;	     Register AL will contain the low 8 bits of the country code.
  7000                                  ;	     The block pointed to by DS:DX is filled in with the information
  7001                                  ;	     for the particular country.
  7002                                  ;		BYTE  Size of this table excluding this byte and the next
  7003                                  ;		BYTE  Country code represented by this table
  7004                                  ;			A sequence of n bytes, where n is the number specified
  7005                                  ;			by the first byte above and is not > internat_block_max,
  7006                                  ;			in the correct order for being returned by the
  7007                                  ;			INTERNATIONAL call as follows:
  7008                                  ;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
  7009                                  ;		5 BYTE	Currency symbol null terminated
  7010                                  ;		2 BYTE	thousands separator null terminated
  7011                                  ;		2 BYTE	Decimal point null terminated
  7012                                  ;		2 BYTE	Date separator null terminated
  7013                                  ;		2 BYTE	Time separator null terminated
  7014                                  ;		1 BYTE	Bit field.  Currency format.
  7015                                  ;			Bit 0.	=0 $ before #  =1 $ after #
  7016                                  ;			Bit 1.	no. of spaces between # and $ (0 or 1)
  7017                                  ;		1 BYTE	No. of significant decimal digits in currency
  7018                                  ;		1 BYTE	Bit field.  Time format.
  7019                                  ;			Bit 0.	=0 12 hour clock  =1 24 hour
  7020                                  ;		DWORD	Call address of case conversion routine
  7021                                  ;		2 BYTE	Data list separator null terminated.
  7022                                  ;	  Carry:
  7023                                  ;	     Register AX has the error code.
  7024                                  ;	IF DX = -1 on input (set current country)
  7025                                  ;	  AL = 0 is an error
  7026                                  ;	  0<AL<0FFH means set current country to country AL
  7027                                  ;	  AL = 0FF means set current country to country BX
  7028                                  ;	  No Carry:
  7029                                  ;	    Current country SET
  7030                                  ;	    Register AL will contain the low 8 bits of the country code.
  7031                                  ;	  Carry:
  7032                                  ;	     Register AX has the error code.
  7033                                  ;-----------------------------------------------------------------------------
  7034                                  
  7035                                  ;procedure   $INTERNATIONAL,NEAR   ; DOS 3.3
  7036                                  
  7037                                  ; 13/05/2019 - Retro DOS v4.0
  7038                                  ; DOSCODE:4A4Dh (MSDOS 6.21, MSDOS.SYS)
  7039                                  
  7040                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7041                                  ; DOSCODE:4A40h (MSDOS 5.0, MSDOS.SYS)
  7042                                  
  7043                                  _$INTERNATIONAL:  ; IBMDOS.COM (MSDOS 3.3), offset 1992h
  7044                                  	 
  7045 00000C48 3CFF                    	CMP	AL,0FFH
  7046 00000C4A 7404                    	JZ	short BX_HAS_CODE	; -1 means country code is in BX
  7047 00000C4C 88C3                    	MOV	BL,AL			; Put AL country code in BX
  7048 00000C4E 30FF                    	XOR	BH,BH
  7049                                  BX_HAS_CODE:
  7050 00000C50 1E                      	PUSH	DS
  7051 00000C51 07                      	POP	ES
  7052 00000C52 52                      	PUSH	DX
  7053 00000C53 5F                      	POP	DI			; User buffer to ES:DI
  7054                                  
  7055                                  ;hkn; SS is DOSDATA
  7056                                  ;	context DS
  7057                                  
  7058 00000C54 16                      	push	ss
  7059 00000C55 1F                      	pop	ds
  7060                                  
  7061 00000C56 83FFFF                  	CMP	DI,-1
  7062 00000C59 745D                    	JZ	short international_set
  7063 00000C5B 09DB                    	OR	BX,BX
  7064 00000C5D 7505                    	JNZ	short international_find
  7065                                  
  7066                                  ;hkn; country_cdpg is in DOSDATA segment.
  7067 00000C5F BE[2A12]                	MOV	SI,COUNTRY_CDPG
  7068                                  
  7069 00000C62 EB39                    	JMP	SHORT international_copy
  7070                                  
  7071                                  international_find:
  7072                                  	;MOV	BP,0			 ; flag it for GetCntry only
  7073                                  	; 06/01/2024
  7074 00000C64 31ED                    	xor	bp,bp ; 0
  7075 00000C66 E80A00                  	CALL	international_get
  7076 00000C69 7255                    	JC	short errtn
  7077                                  	;CMP	BX,0			 ; nlsfunc finished it ?
  7078                                  	; 06/01/2024
  7079 00000C6B 09DB                    	or	bx,bx
  7080 00000C6D 752E                    	JNZ	SHORT international_copy ; no, copy by myself
  7081 00000C6F 89D3                    	MOV	BX,DX			 ; put country back
  7082 00000C71 EB3A                    	JMP	SHORT international_ok3
  7083                                  
  7084                                  international_get:
  7085 00000C73 BE[2A12]                	MOV	SI,COUNTRY_CDPG
  7086                                  
  7087                                  ;hkn; country_cdpg is in DOSDATA segment.
  7088                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  7089                                  
  7090                                  	; MSDOS 3.3
  7091                                  	;;cmp	bx,[SI+63h]
  7092                                  	;CMP	BX,[SI+DOS_CCDPG.ccDosCountry]
  7093                                  	;jz	short RET27
  7094                                  
  7095                                  	; 13/05/2019 - Retro DOS v4.0
  7096                                  
  7097                                  	; MSDOS 6.0
  7098                                  	;cmp	bx,[ss:si+68h]
  7099 00000C76 363B5C68                	CMP	BX,[ss:SI+DOS_CCDPG.ccDosCountry] ; = current country id
  7100 00000C7A 74CB                    	jz	short RET27			; return if equal
  7101                                  
  7102 00000C7C 89DA                    	MOV	DX,BX
  7103 00000C7E 31DB                    	XOR	BX,BX			; bx = 0, default code page
  7104                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7105 00000C80 B80014                  	mov	ax,1400h
  7106 00000C83 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7107                                  			; Return: AL = 00h not installed, OK to install
  7108                                  			; 01h not installed, not OK
  7109                                  			; FFh installed
  7110 00000C85 3CFF                    	CMP	AL,0FFH
  7111 00000C87 7510                    	JNZ	short interr		; not in memory
  7112                                  	
  7113                                  	; 06/01/2024
  7114 00000C89 B80314                  	mov	ax,1403h		; set country info
  7115                                  
  7116                                  	;cmp	bp,0
  7117 00000C8C 09ED                    	or	bp,bp			; GetCntry ?
  7118 00000C8E 7501                    	JNZ	short stcdpg
  7119                                  	
  7120                                  	;CallInstall GetCntry,NLSFUNC,4	; get country info
  7121                                  	;mov	ax,1404h
  7122 00000C90 40                      	inc	ax	; AX = 1404h ; get country info
  7123                                  
  7124                                  	; 06/01/2024
  7125                                  	;int	2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  7126                                  	;		; BX = code page, DX = country code,
  7127                                  	;		; DS:SI -> internal code page structure
  7128                                  	;		; ES:DI -> user buffer
  7129                                  	;		; Return: AL = status
  7130                                  	;
  7131                                  	;JMP	short chkok
  7132                                  	
  7133                                  	;nop
  7134                                  
  7135                                  stcdpg:
  7136                                  	;CallInstall SetCodePage,NLSFUNC,3  ; set country info
  7137                                  	; 06/01/2024
  7138                                  	;mov     ax,1403h
  7139                                  gscdpg:
  7140 00000C91 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - SET COUNTRY INFO
  7141                                  			; DS:SI -> internal code page structure
  7142                                  			; BX = code page, DX = country code
  7143                                  			; Return: AL = status
  7144                                  chkok:
  7145 00000C93 08C0                    	or	al,al			; success ?
  7146                                  	;retz				; yes
  7147 00000C95 74B0                    	jz	short RET27
  7148                                  
  7149                                  setcarry:
  7150 00000C97 F9                      	STC				; set carry
  7151 00000C98 C3                      	retn
  7152                                  interr:
  7153 00000C99 B0FF                    	MOV	AL,0FFH			; flag nlsfunc error
  7154 00000C9B EBFA                    	JMP	short setcarry
  7155                                  
  7156                                  international_copy:
  7157                                  
  7158                                  ;hkn; country_cdpg is in DOSDATA segment.
  7159                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  7160                                  
  7161                                  	; MSDOS 3.3
  7162                                  	;;mov	bx,[SI+63h]
  7163                                  	;mov	BX,[SI+DOS_CCDPG.ccDosCountry]
  7164                                  	;mov	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; 08/09/2018
  7165                                  
  7166                                  	; 13/05/2019 - Retro DOS v4.0
  7167                                  
  7168                                  	; MSDOS 6.0
  7169                                  	;mov	bx,[ss:si+68h]
  7170 00000C9D 368B5C68                	MOV	BX,[ss:SI+DOS_CCDPG.ccDosCountry] ; = current country id
  7171 00000CA1 BE[9612]                	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; COUNTRY_CDPG + 108
  7172                                  
  7173                                  	;mov	cx,24
  7174 00000CA4 B91800                  	MOV	CX,OLD_COUNTRY_SIZE
  7175                                  
  7176                                  	; MSDOS 6.0
  7177                                  
  7178                                  ;hkn;	must set up DS to SS so that international info can be copied
  7179                                  	
  7180 00000CA7 1E                      	push	ds
  7181                                  
  7182 00000CA8 16                      	push	ss			; cs -> ss
  7183 00000CA9 1F                      	pop	ds
  7184                                  
  7185 00000CAA F3A4                    	REP	MOVSB			; copy country info
  7186                                  
  7187                                  	; MSDOS 6.0
  7188                                  
  7189 00000CAC 1F                      	pop	ds	;hkn;	restore ds
  7190                                  
  7191                                  international_ok3:
  7192 00000CAD E8D1F7                  	call	Get_User_Stack
  7193                                  ;ASSUME	DS:NOTHING
  7194                                  	;MOV	[SI+2],BX
  7195 00000CB0 895C02                  	MOV	[SI+user_env.user_BX],BX
  7196                                  international_ok:
  7197 00000CB3 89D8                    	MOV	AX,BX			; Return country code in AX too.
  7198                                  ;SYS_RET_OK_jmp:
  7199                                  	; 05/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7200                                  nono:	; 15/12/2022
  7201                                  SYS_RET_OK_jmp:
  7202 00000CB5 E979F9                  	jmp	SYS_RET_OK
  7203                                  
  7204                                  international_set:
  7205                                  
  7206                                  ;hkn; ASSUME	DS:DOSGROUP
  7207                                  ;ASSUME	DS:DOSDATA
  7208                                  
  7209 00000CB8 BD0100                  	MOV	BP,1			; flag it for SetCodePage only
  7210 00000CBB E8B5FF                  	CALL	international_get
  7211 00000CBE 73F3                    	JNC	short international_ok
  7212                                  errtn:
  7213 00000CC0 3CFF                    	CMP	AL,0FFH
  7214 00000CC2 7403                    	JZ	short errtn2
  7215                                  errtn1:
  7216 00000CC4 E973F9                  	jmp	SYS_RET_ERR		; return what we got from NLSFUNC
  7217                                  errtn2:
  7218                                  	;error	error_invalid_function	; NLSFUNC not existent
  7219                                  
  7220                                  	;mov	al,1
  7221 00000CC7 B001                    	mov	al,error_invalid_function 
  7222 00000CC9 EBF9                    	jmp	short errtn1 ; 13/05/2019 - Retro DOS v4.0
  7223                                  ;errtn3:
  7224                                  ;	jmp	SYS_RET_ERR
  7225                                  
  7226                                  ;EndProc $INTERNATIONAL
  7227                                  
  7228                                  ; 19/07/2018
  7229                                  
  7230                                  ;BREAK <$GetExtCntry - return extended country-dependent information>
  7231                                  
  7232                                  ;----------------------------------------------------------------------------
  7233                                  ;
  7234                                  ; Procedure Name : $GetExtCntry
  7235                                  ;
  7236                                  ; Inputs:
  7237                                  ;	if AL >= 20H
  7238                                  ;	  AL= 20H    capitalize single char, DL= char
  7239                                  ;	      21H    capitalize string, CX= string length
  7240                                  ;	      22H    capitalize ASCIIZ string
  7241                                  ;	      23H    YES/NO check, DL=1st char DH= 2nd char (DBCS)
  7242                                  ;	      80H bit 0 = use normal upper case table
  7243                                  ;		      1 = use file upper case table
  7244                                  ;	   DS:DX points to string
  7245                                  ;
  7246                                  ;	else
  7247                                  ;
  7248                                  ;	MOV	AH,GetExtCntry	 ; DOS 3.3
  7249                                  ;	MOV	AL,INFO_ID	( info type,-1 selects all )
  7250                                  ;	MOV	BX,CODE_PAGE	( -1 = active code page )
  7251                                  ;	MOV	DX,COUNTRY_ID	( -1 = active country )
  7252                                  ;	MOV	CX,SIZE 	( amount of data to return )
  7253                                  ;	LES	DI,COUNTRY_INFO ( buffer for returned data )
  7254                                  ;	INT	21
  7255                                  ; Function:
  7256                                  ;	give users extended country dependent information
  7257                                  ;	or capitalize chars
  7258                                  ; Outputs:
  7259                                  ;	  No Carry:
  7260                                  ;	     extended country info is succesfully returned
  7261                                  ;	  Carry:
  7262                                  ;	     Register AX has the error code.
  7263                                  ;	     AX=0, NO	 for YES/NO CHECK
  7264                                  ;		1, YES
  7265                                  ;----------------------------------------------------------------------------
  7266                                  
  7267                                  ;procedure   $GetExtCntry,NEAR	; DOS 3.3
  7268                                  
  7269                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7270                                  
  7271                                  	; MSDOS 6.0
  7272                                  _$GetExtCntry:
  7273 00000CCB 3C20                    	CMP	AL,CAP_ONE_CHAR 	; < 20H ?
  7274 00000CCD 7269                    	JB	short notcap
  7275                                  capcap: 				;
  7276 00000CCF A880                    	TEST	AL,UPPER_TABLE	; 80h	; which upper case table
  7277 00000CD1 7505                    	JNZ	short fileupper		; file upper case
  7278                                  
  7279                                  ;hkn; UCASE_TAB in DOSDATA
  7280 00000CD3 BB[AF0A]                	MOV	BX,UCASE_TAB+2		; get normal upper case
  7281 00000CD6 EB05                    	JMP	SHORT capit
  7282                                  
  7283                                  fileupper:
  7284                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM - DOSCODE:4C57h)
  7285                                  	; ((Note: This must be a bugfix, because bit 7 of AX is 1 here!))
  7286                                  	; AL >= 80h
  7287 00000CD8 247F                    	and	al,7Fh 
  7288                                  
  7289                                  ;hkn; FILE_UCASE_TAB in DOSDATA
  7290 00000CDA BB[310B]                	MOV	BX,FILE_UCASE_TAB+2 ; get file upper case
  7291                                  capit:					;
  7292 00000CDD 3C20                    	CMP	AL,CAP_ONE_CHAR 	; cap one char ?
  7293 00000CDF 750D                    	JNZ	short chkyes		; no
  7294 00000CE1 88D0                    	MOV	AL,DL			; set up AL
  7295 00000CE3 E8FC41                  	call	GETLET3 		; upper case it
  7296 00000CE6 E898F7                  	call	Get_User_Stack		; get user stack
  7297                                  	;mov	[si+6],al
  7298 00000CE9 884406                  	MOV	[SI+user_env.user_DX],AL ; user's DL=AL
  7299 00000CEC EBC7                    	JMP	SHORT nono		; done
  7300                                  chkyes: 				;
  7301 00000CEE 3C23                    	CMP	AL,CHECK_YES_NO	; 23h	; check YES or NO ?
  7302 00000CF0 7522                    	JNZ	short capstring		; no
  7303                                  
  7304 00000CF2 31C0                    	XOR	AX,AX			; presume NO
  7305                                  		      
  7306                                  ;hkn; NLS_YES, NLS_NO, NLS_yes2, NLS_no2 is defined in msdos.cl3 which is
  7307                                  ;hkn; included in yesno.asm in the DOSCODE segment.
  7308                                  
  7309                                  	; 06/08/2018 - Retro DOS v3.0
  7310                                  	; 13/05/2019 - Retro DOS v4.0
  7311                                  	;cmp	dl,'Y'
  7312 00000CF4 2E3A16[0F0A]            	CMP	DL,[cs:NLS_YES]		; is 'Y' ?
  7313 00000CF9 7416                    	JZ	short yesyes		; yes
  7314                                  	;cmp	dl,'y'
  7315 00000CFB 2E3A16[110A]            	CMP	DL,[cs:NLS_yes2]	; is 'y' ?
  7316 00000D00 740F                    	JZ	short yesyes		; yes
  7317                                  	;cmp	dl,'N'
  7318 00000D02 2E3A16[100A]            	CMP	DL,[cs:NLS_NO]		; is  'N'?
  7319 00000D07 74AC                    	JZ	short nono		; no
  7320                                  	;cmp	dl,'n'
  7321 00000D09 2E3A16[120A]            	CMP	DL,[cs:NLS_no2]		; is 'n' ?
  7322 00000D0E 74A5                    	JZ	short nono		; no
  7323                                  ;dbcs_char:				;
  7324 00000D10 40                      	INC	AX			; not YES or NO
  7325                                  yesyes: 				;
  7326 00000D11 40                      	INC	AX			; return 1
  7327                                  	; 15/12/2022
  7328                                  ;nono:	
  7329 00000D12 EBA1                    	jmp	short SYS_RET_OK_jmp	;
  7330                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7331                                  	;jmp	SYS_RET_OK		; done
  7332                                  
  7333                                  capstring:				;
  7334 00000D14 89D6                    	MOV	SI,DX			; si=dx
  7335 00000D16 3C21                    	CMP	AL,CAP_STRING	; 21h	; cap string ?
  7336 00000D18 750D                    	JNZ	short capascii		; no
  7337                                  	;OR	CX,CX			; check count 0
  7338                                  	;JZ	short nono		; yes finished
  7339                                  	; 06/01/2024
  7340 00000D1A E399                    	jcxz	nono
  7341                                  concap: 				;
  7342 00000D1C AC                      	LODSB				; get char
  7343 00000D1D E8C241                  	call	GETLET3 		; upper case it
  7344 00000D20 8844FF                  	MOV	byte [SI-1],AL		; store back
  7345                                  ;next99: 				;
  7346 00000D23 E2F7                    	LOOP	concap			; continue
  7347 00000D25 EB8E                    	JMP	short nono		; done
  7348                                  capascii:				;
  7349 00000D27 3C22                    	CMP	AL,CAP_ASCIIZ	; 22h	; cap ASCIIZ string ?
  7350 00000D29 7545                    	JNZ	short capinval		; no
  7351                                  concap2:				;
  7352 00000D2B AC                      	LODSB				; get char
  7353 00000D2C 08C0                    	or	al,al			; end of string ?
  7354 00000D2E 7485                    	JZ	short nono		; yes
  7355 00000D30 E8AF41                  	call	GETLET3 		; upper case it
  7356 00000D33 8844FF                  	MOV	[SI-1],AL		; store back
  7357 00000D36 EBF3                    	JMP	short concap2 		; continue
  7358                                  
  7359                                  	; MSDOS 3.3 (& MSDOS 6.0)
  7360                                  
  7361                                  ; Offset 1A19h in IBMDOS.COM (MSDOS 3.3), 1987 	
  7362                                  ; _$GetExtCntry:
  7363                                  
  7364                                  notcap:
  7365 00000D38 83F905                  	CMP	CX,5			; minimum size is 5
  7366 00000D3B 7277                    	jb	short sizeerror
  7367                                  
  7368                                  GEC_CONT:
  7369                                  ;hkn; SS is DOSDATA
  7370                                  	;context DS
  7371                                  
  7372 00000D3D 16                      	push	ss
  7373                                  	;pop	es  ; ! (Retro DOS v3.0 BUG) !
  7374 00000D3E 1F                      	pop	ds  ; 13/05/2019 - Retro DOS v4.0	
  7375                                  	
  7376                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  7377 00000D3F BE[2A12]                	MOV	SI,COUNTRY_CDPG
  7378                                  
  7379 00000D42 83FAFF                  	CMP	DX,-1			; active country ?
  7380 00000D45 7503                    	JNZ	short GETCDPG 		; no
  7381                                  
  7382                                  ;hkn; use DS override to accesss country_cdpg fields
  7383                                  	;;mov	dx,[si+63h] ; MSDOS 3.3
  7384                                  	;mov	dx,[si+68h] ; MSDOS 6.0
  7385 00000D47 8B5468                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]
  7386                                  					; get active country id;smr;use DS
  7387                                  GETCDPG:
  7388 00000D4A 83FBFF                  	CMP	BX,-1			; active code page?
  7389 00000D4D 7503                    	JNZ	short CHKAGAIN		; no, check again
  7390                                  
  7391                                  ;hkn; use DS override to accesss country_cdpg fields
  7392                                  	;;mov	bx,[si+65h] ; MSDOS 3.3	
  7393                                  	;mov	bx,[si+6Ah] ; MSDOS 6.0
  7394 00000D4F 8B5C6A                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  7395                                  					; get active code page id;smr;Use DS
  7396                                  CHKAGAIN:
  7397                                  	;cmp	dx,[si+68h] ; MSDOS 6.0
  7398 00000D52 3B5468                  	CMP	DX,[SI+DOS_CCDPG.ccDosCountry]
  7399                                  					; same as active country id?;smr;use DS
  7400 00000D55 7550                    	JNZ	short CHKNLS		; no
  7401                                  	;cmp	bx,[si+6Ah] ; MSDOS 6.0	
  7402 00000D57 3B5C6A                  	CMP	BX,[SI+DOS_CCDPG.ccDosCodePage]	
  7403                                  					; same as active code pg id?;smr;use DS
  7404 00000D5A 754B                    	JNZ	short CHKNLS		; no
  7405                                  CHKTYPE:
  7406                                  	;mov	bx,[si+48h]
  7407 00000D5C 8B5C48                  	MOV	BX,[SI+DOS_CCDPG.ccSysCodePage]	
  7408                                  					; bx = sys code page id;smr;use DS
  7409 00000D5F 51                      	PUSH	CX			; save cx
  7410                                  	;mov	cx,[si+4Ah]
  7411 00000D60 8B4C4A                  	MOV	CX,[SI+DOS_CCDPG.ccNumber_of_entries]  ;smr;use DS
  7412                                  	;mov	si,COUNTRY_CDPG+76
  7413 00000D63 BE[7612]                	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccSetUcase   ;smr;CDPG in DOSDATA
  7414                                  NXTENTRY:
  7415 00000D66 3A04                    	CMP	AL,[SI] 		; compare info type;smr;use DS
  7416 00000D68 740B                    	JZ	short FOUNDIT
  7417 00000D6A 83C605                  	ADD	SI,5			; next entry
  7418 00000D6D E2F7                    	LOOP	NXTENTRY
  7419 00000D6F 59                      	POP	CX
  7420                                  capinval:
  7421                                  	;error	error_invalid_function	; info type not found
  7422                                  	;mov	al,1
  7423 00000D70 B001                    	mov	al,error_invalid_function
  7424                                  ;SYS_RET_ERR_jmp:
  7425                                  	;jmp	SYS_RET_ERR
  7426                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7427                                  SYS_RET_ERR_jmp:
  7428 00000D72 E9C5F8                  	jmp	SYS_RET_ERR	
  7429                                  
  7430                                  FOUNDIT:
  7431 00000D75 A4                      	MOVSB				; move info id byte
  7432 00000D76 59                      	POP	CX			; restore char count
  7433                                  	;cmp	al,1
  7434 00000D77 3C01                    	CMP	AL,SetCountryInfo	; select country info type ?
  7435 00000D79 7415                    	JZ	short setsize
  7436 00000D7B B90400                  	MOV	CX,4			; 4 bytes will be moved
  7437 00000D7E B80500                  	MOV	AX,5			; 5 bytes will be returned in CX
  7438                                  OK_RETN:
  7439 00000D81 F3A4                    	REP	MOVSB			; copy info
  7440 00000D83 89C1                    	MOV	CX,AX			; CX = actual length returned
  7441 00000D85 89D8                    	MOV	AX,BX			; return sys code page in ax
  7442                                  GETDONE:
  7443 00000D87 E8F7F6                  	call	Get_User_Stack		; return actual length to user's CX
  7444                                  	;mov	[si+4],cx 
  7445 00000D8A 894C04                  	MOV	[SI+user_env.user_CX],CX
  7446                                  	;jmp	SYS_RET_OK
  7447                                  	; 15/12/2022
  7448                                  	; 25/06/2019
  7449 00000D8D E9A4F8                  	jmp	SYS_RET_OK_clc
  7450                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7451                                  	; 15/12/2022
  7452                                  ;nono_jmp:
  7453                                  	;jmp	short nono
  7454                                  setsize:
  7455 00000D90 83E903                  	SUB	CX,3			; size after length field
  7456 00000D93 390C                    	CMP	[SI],CX			; less than table size ;smr;use ds
  7457 00000D95 7302                    	JAE	short setsize2		; no
  7458 00000D97 8B0C                    	MOV	CX,[SI]			; truncate to table size ;smr;use ds
  7459                                  setsize2:
  7460 00000D99 26890D                  	MOV	[ES:DI],CX		; copy actual length to user's
  7461                                  	;ADD	DI,2			; update index
  7462                                  	;ADD	SI,2
  7463                                  	; 06/01/2024
  7464 00000D9C 47                      	inc	di
  7465 00000D9D 47                      	inc	di
  7466 00000D9E 46                      	inc	si
  7467 00000D9F 46                      	inc	si
  7468 00000DA0 89C8                    	MOV	AX,CX
  7469 00000DA2 83C003                  	ADD	AX,3			; AX has the actual length
  7470 00000DA5 EBDA                    	JMP	short OK_RETN 		; go move it
  7471                                  CHKNLS:
  7472 00000DA7 30E4                    	XOR	AH,AH
  7473                                  	;PUSH	AX			; save info type
  7474                                  	;POP	BP			; bp = info type
  7475                                  	; 06/01/2024
  7476 00000DA9 89C5                    	mov	bp,ax
  7477                                  	
  7478                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7479 00000DAB B80014                  	mov     ax,1400h
  7480 00000DAE CD2F                    	int     2Fh     ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7481                                  			; Return: AL = 00h not installed, OK to install
  7482                                  			; 01h not installed, not OK
  7483                                  			; FFh installed
  7484 00000DB0 3CFF                    	CMP	AL,0FFH
  7485 00000DB2 7404                    	JZ	short NLSNXT		; in memory
  7486                                  
  7487                                  sizeerror:
  7488                                  	;error	error_invalid_function
  7489                                  	;mov	al,1
  7490 00000DB4 B001                    	mov	al,error_invalid_function
  7491                                  	;jmp	SYS_RET_ERR
  7492                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7493                                  sys_ret_err_jmp2:
  7494 00000DB6 EBBA                    	jmp	short SYS_RET_ERR_jmp
  7495                                  
  7496                                  NLSNXT: 
  7497                                  	;CallInstall GetExtInfo,NLSFUNC,2 ;get extended info
  7498 00000DB8 B80214                  	mov     ax,1402h
  7499 00000DBB CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  7500                                  			; BP = subfunction, BX = code page
  7501                                  			; DX = country code, DS:SI -> internal code page structure
  7502                                  			; ES:DI -> user buffer, CX = size of user buffer
  7503                                  			; Return: AL = status
  7504                                  			; 00h successful
  7505                                  			; else DOS error code
  7506                                  
  7507 00000DBD 3C00                    	CMP	AL,0			; success ?
  7508 00000DBF 7505                    	JNZ	short NLSERROR
  7509                                  	;mov	ax,[si+48h] ; 13/05/2019
  7510 00000DC1 8B4448                  	MOV	AX,[SI+DOS_CCDPG.ccSysCodePage]
  7511                                  			; ax = sys code page id;smr;use ds;
  7512                                  			;BUGBUG;check whether DS is OK after the above calls
  7513 00000DC4 EBC1                    	JMP	short GETDONE
  7514                                  seterr:
  7515                                  	; 15/12/2022
  7516                                  NLSERROR:
  7517                                  	;jmp	SYS_RET_ERR		; return what is got from NLSFUNC
  7518                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7519                                  	;jmp	short sys_ret_err_jmp2
  7520                                  	; 15/12/2022
  7521 00000DC6 EBAA                    	jmp	short SYS_RET_ERR_jmp
  7522                                  
  7523                                  ;EndProc $GetExtCntry
  7524                                  
  7525                                  ; 13/05/2019 - Retro DOS v4.0
  7526                                  ; DOSCODE:4BD6h (MSDOS 6.21, MSDOS.SYS)
  7527                                  
  7528                                  ;BREAK <$GetSetCdPg - get or set global code page>
  7529                                  ;----------------------------------------------------------------------------
  7530                                  ;**	$GetSetCdPg - Get or Set Global Code Page
  7531                                  ;
  7532                                  ;   System call format:
  7533                                  ;
  7534                                  ;	MOV	AH,GetSetCdPg	; DOS 3.3
  7535                                  ;	MOV	AL,n		; n = 1 : get code page, n = 2 : set code page
  7536                                  ;	MOV	BX,CODE_PAGE	(set code page only)
  7537                                  ;	INT	21
  7538                                  ;
  7539                                  ;	ENTRY	(al) = n
  7540                                  ;		(bx) = code page
  7541                                  ;	EXIT	'C' clear
  7542                                  ;		  global code page is set	(set global code page)
  7543                                  ;		  (BX) = active code page id	(get global code page)
  7544                                  ;		  (DX) = system code page id	(get global code page)
  7545                                  ;		'C' set
  7546                                  ;		  (AX) = error code
  7547                                  
  7548                                  ;procedure  $GetSetCdPg,NEAR   ; DOS 3.3
  7549                                  
  7550                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7551                                  	; DOSCODE:4BC9h
  7552                                  
  7553                                  _$GetSetCdPg:
  7554                                  
  7555                                  ;hkn; SS is DOSDATA
  7556                                  	;context DS
  7557                                  
  7558 00000DC8 16                      	push	ss
  7559 00000DC9 1F                      	pop	ds
  7560                                  
  7561                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  7562 00000DCA BE[2A12]                	MOV	SI,COUNTRY_CDPG	  ; (DOSDATA:122Ah for MSDOS 6.21)
  7563                                  
  7564 00000DCD 3C01                    	CMP	AL,1		       ; get global code page
  7565 00000DCF 7512                    	JNZ	short setglpg 	       ; set global code page
  7566                                  	
  7567                                  	;;mov	bx,[si+65h] ; MSDOS 3.3
  7568                                  	;mov	bx,[si+6Ah] ; MSDOS 6.0
  7569 00000DD1 8B5C6A                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  7570                                  					; get active code page id;smr;use ds
  7571                                  	;mov	dx,[si+48h]
  7572 00000DD4 8B5448                  	MOV	DX,[SI+DOS_CCDPG.ccSysCodePage]
  7573                                  				  	; get sys code page id;smr;use ds
  7574 00000DD7 E8A7F6                  	call	Get_User_Stack
  7575                                  ;ASSUME DS:NOTHING
  7576                                  	;;mov	[si+2],bx
  7577                                  	;MOV	[SI+user_env.user_BX],BX ; update returned bx
  7578                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7579 00000DDA E85BFE                  	call    set_user_bx	; MOV [SI+user_env.user_BX],BX 
  7580                                  	;mov	[si+6],dx
  7581 00000DDD 895406                  	MOV	[SI+user_env.user_DX],DX ; update returned dx
  7582                                  OK_RETURN:
  7583                                  	; 15/12/2022
  7584                                  	;transfer SYS_RET_OK
  7585 00000DE0 E94EF8                  	jmp	SYS_RET_OK
  7586                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7587                                  	;jmp	short nono_jmp
  7588                                  
  7589                                  ;hkn; ASSUME DS:DOSGROUP
  7590                                  ;ASSUME	DS:DOSDATA
  7591                                  
  7592                                  setglpg:
  7593 00000DE3 3C02                    	CMP	AL,2
  7594 00000DE5 752F                    	JNZ	short nomem
  7595                                  	
  7596                                  	;;mov	dx,[si+63h] ; MSDOS 3.3
  7597                                  	;mov	dx,[si+68h] ; MSDOS 6.0
  7598 00000DE7 8B5468                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]	;smr;use ds
  7599                                  	
  7600                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7601 00000DEA B80014                  	mov     ax,1400h
  7602 00000DED CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7603                                  			; Return: AL = 00h not installed, OK to install
  7604                                  			; 01h not installed, not OK
  7605                                  			; FFh installed
  7606 00000DEF 3CFF                    	CMP	AL,0FFH
  7607 00000DF1 7523                    	JNZ	short nomem		; not in memory
  7608                                  
  7609                                  	;CallInstall SetCodePage,NLSFUNC,1 ;set the code page
  7610 00000DF3 B80114                  	mov     ax,1401h
  7611 00000DF6 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - CHANGE CODE PAGE
  7612                                  			; DS:SI -> internal code page structure
  7613                                  			; BX = new code page, DX = country code???
  7614                                  			; Return: AL = status
  7615                                  			; 00h successful
  7616                                  			; else DOS error code
  7617                                  	;cmp	al,0
  7618 00000DF8 08C0                    	or	al,al			; success ?
  7619 00000DFA 74E4                    	JZ	short OK_RETURN		; yes
  7620                                  
  7621 00000DFC 3C41                    	CMP	AL,65			; set device code page failed
  7622 00000DFE 75C6                    	JNZ	short seterr
  7623                                  	;MOV	AX,65
  7624                                  	; 06/01/2024
  7625 00000E00 98                      	cbw
  7626 00000E01 A3[2403]                	MOV	[EXTERR],AX
  7627                                  	;mov	byte [EXTERR_ACTION],6
  7628                                  	;mov	byte [EXTERR_CLASS],5
  7629                                  	;mov	byte [EXTERR_LOCUS],4
  7630 00000E04 C606[2603]06            	MOV	byte [EXTERR_ACTION],errACT_Ignore
  7631 00000E09 C606[2703]05            	MOV	byte [EXTERR_CLASS],errCLASS_HrdFail
  7632 00000E0E C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
  7633                                  	;transfer From_GetSet
  7634 00000E13 E92CF8                  	jmp	From_GetSet
  7635                                  
  7636                                  	; 15/12/2022
  7637                                  ;seterr:
  7638                                  	;;;transfer SYS_RET_ERR
  7639                                  	;;jmp	SYS_RET_ERR
  7640                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7641                                  	;jmp	short NLSERROR
  7642                                  
  7643                                  nomem:
  7644                                  	;error	error_invalid_function	; function not defined
  7645                                  	;mov	al,1
  7646 00000E16 B001                    	mov	al,error_invalid_function
  7647 00000E18 EBAC                    	jmp	short seterr
  7648                                  
  7649                                  ;EndProc $GetSetCdPg
  7650                                  
  7651                                  ; 09/01/2024
  7652                                  ; 13/05/2019 - Retro DOS v4.0
  7653                                  ; DOSCODE:4C2Bh (MSDOS 6.21, MSDOS.SYS)
  7654                                  
  7655                                  ;BREAK <$Get_Drive_Freespace -- Return bytes of free disk space on a drive>
  7656                                  ;----------------------------------------------------------------------------
  7657                                  ;**	$Get_Drive_Freespace - Return amount of drive free space
  7658                                  ;
  7659                                  ;	$Get_Drive_Freespace returns the # of free allocation units on a
  7660                                  ;		drive.
  7661                                  ;
  7662                                  ;	This call returns the same info in the same registers (except for the
  7663                                  ;	FAT pointer) as the old FAT pointer calls
  7664                                  ;
  7665                                  ;	ENTRY	DL = Drive number
  7666                                  ;	EXIT	AX = Sectors per allocation unit
  7667                                  ;		   = -1 if bad drive specified
  7668                                  ;		On User Stack
  7669                                  ;		    BX = Number of free allocation units
  7670                                  ;		    DX = Total Number of allocation units on disk
  7671                                  ;		    CX = Sector size
  7672                                  
  7673                                  ;procedure   $GET_DRIVE_FREESPACE,NEAR
  7674                                  
  7675                                  _$GET_DRIVE_FREESPACE:
  7676                                  
  7677                                  ;hkn; SS is DOSDATA
  7678                                  	;context DS
  7679 00000E1A 16                      	push	ss
  7680 00000E1B 1F                      	pop	ds
  7681                                  
  7682 00000E1C 88D0                    	MOV	AL,DL
  7683                                  	;invoke	GetThisDrv		; Get drive
  7684 00000E1E E8B35A                  	call	GETTHISDRV
  7685                                  SET_AX_RET:
  7686 00000E21 7212                    	JC	short BADFDRV
  7687                                  	;invoke	DISK_INFO
  7688 00000E23 E8F81D                  	call	DISK_INFO
  7689 00000E26 87D3                    	XCHG	DX,BX
  7690                                  	;JC	short SET_AX_RET	; User FAILed to I 24
  7691                                  	; 06/01/2024
  7692 00000E28 720B                    	jc	short BADFDRV
  7693 00000E2A 30E4                    	XOR	AH,AH			; Chuck Fat ID byte
  7694                                  DoSt:
  7695 00000E2C E852F6                  	call	Get_User_Stack
  7696                                  ;ASSUME	DS:NOTHING
  7697                                  	;mov	[si+6],dx
  7698                                  	;;mov	[si+4],cx
  7699                                  	;;mov	[si+2],bx
  7700                                  	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7701 00000E2F 895406                  	MOV	[SI+user_env.user_DX],DX ; total clusters
  7702                                  	;MOV	[SI+user_env.user_CX],CX
  7703                                  	;MOV	[SI+user_env.user_BX],BX
  7704                                  	;;MOV	[SI+user_env.user_AX],AX
  7705                                  	;mov	[si],ax
  7706                                  	;;return
  7707                                  	;retn
  7708                                  	; 09/01/2024
  7709 00000E32 E9FEFD                  	jmp     gdrvfspc_ret    ; ax = sectors per cluster (modified)
  7710                                  
  7711                                  BADFDRV:
  7712                                  	; MSDOS 3.3
  7713                                  	;;mov	al,0Fh
  7714                                  	;mov	al,error_invalid_drive	; Assume error
  7715                                  
  7716                                  	; 13/05/2019 - Retro DOS v4.0
  7717                                  
  7718                                  	; MSDOS 6.0 & MSDOS 3.3
  7719                                  	;invoke	FCB_RET_ERR
  7720 00000E35 E818F8                  	call	FCB_RET_ERR
  7721                                  	
  7722 00000E38 B8FFFF                  	MOV	AX,-1
  7723 00000E3B EBEF                    	JMP	short DoSt
  7724                                  
  7725                                  ;EndProc $GET_DRIVE_FREESPACE
  7726                                  
  7727                                  ;	BREAK <$Get_DMA, $Set_DMA -- Get/Set current DMA address>
  7728                                  ;----------------------------------------------------------------------------
  7729                                  ;**	$Get_DMA - Get Disk Transfer Address
  7730                                  ;
  7731                                  ;	ENTRY	none
  7732                                  ;	EXIT	ES:BX is current transfer address
  7733                                  ;	USES	all
  7734                                  
  7735                                  	; 09/01/2024
  7736                                  _$GET_DMA:
  7737 00000E3D 368B1E[2C03]            	MOV	BX,[SS:DMAADD]
  7738 00000E42 368B0E[2E03]            	MOV	CX,[SS:DMAADD+2]
  7739 00000E47 E837F6                  	call	Get_User_Stack
  7740                                  	;mov	[si+2],bx
  7741                                  	;mov	[si+10h],cx
  7742                                  	; 09/01/2024
  7743                                  	;MOV	[SI+user_env.user_BX],BX
  7744 00000E4A 894C10                  	MOV	[SI+user_env.user_ES],CX
  7745                                  	;retn
  7746                                  	; 09/01/2024
  7747 00000E4D E9E8FD                  	jmp	set_user_bx ; (PCDOS 7.1 IBMDOS.COM)
  7748                                  
  7749                                  ;**	$Set_DMA - Set Disk Transfer Address
  7750                                  ;----------------------------------------------------------------------------
  7751                                  ;	ENTRY	DS:DX is current transfer address
  7752                                  ;	EXIT	none
  7753                                  ;	USES	all
  7754                                  
  7755                                  _$SET_DMA:
  7756 00000E50 368916[2C03]            	MOV	[SS:DMAADD],DX
  7757 00000E55 368C1E[2E03]            	MOV	[SS:DMAADD+2],DS
  7758 00000E5A C3                      	retn
  7759                                  
  7760                                  ;	BREAK <$Get_Default_Drive, $Set_Default_Drive -- Set/Get default drive>
  7761                                  ;------------------------------------------------------------------------------
  7762                                  
  7763                                  ;**	$Get_Default_Drive - Get Current Default Drive
  7764                                  ;-----------------------------------------------------
  7765                                  ;	ENTRY	none
  7766                                  ;	EXIT	(AL) = drive number
  7767                                  ;	USES	all
  7768                                  
  7769                                  _$GET_DEFAULT_DRIVE:
  7770 00000E5B 36A0[3603]              	MOV	AL,[SS:CURDRV]
  7771 00000E5F C3                      	retn
  7772                                  
  7773                                  ;**	$Set_Default_Drive - Specify new Default Drive
  7774                                  ;-----------------------------------------------------
  7775                                  ;	ENTRY	(DL) = Drive number for new default drive
  7776                                  ;	EXIT	(AL) = Number of drives, NO ERROR RETURN IF DRIVE NUMBER BAD
  7777                                  
  7778                                  _$SET_DEFAULT_DRIVE:
  7779 00000E60 88D0                    	MOV	AL,DL
  7780 00000E62 FEC0                    	INC	AL			; A=1, B=2...
  7781 00000E64 E8515A                  	call	GetVisDrv		; see if visible drive
  7782 00000E67 7204                    	JC	short SETRET		; errors do not set
  7783 00000E69 36A2[3603]              	MOV	[SS:CURDRV],AL		; no, set
  7784                                  
  7785                                  SETRET:
  7786 00000E6D 36A0[4700]              	MOV	AL,[SS:CDSCOUNT]	; let user see what the count really is
  7787 00000E71 C3                      	retn
  7788                                  
  7789                                  ;BREAK <$Get/Set_Interrupt_Vector - Get/Set interrupt vectors>
  7790                                  ;----------------------------------------------------------------------------
  7791                                  
  7792                                  ;**	$Get_Interrupt_Vector - Get Interrupt Vector
  7793                                  ;---------------------------------------------------
  7794                                  ;	$Get_Interrupt_Vector is the official way for user pgms to get the
  7795                                  ;	contents of an interrupt vector.
  7796                                  ;
  7797                                  ;	ENTRY	(AL) = interrupt number
  7798                                  ;	EXIT	(ES:BX) = current interrupt vector
  7799                                  
  7800                                  _$GET_INTERRUPT_VECTOR:
  7801 00000E72 E82E00                  	CALL	RECSET
  7802 00000E75 26C41F                  	LES	BX,[ES:BX]
  7803 00000E78 E806F6                  	call	Get_User_Stack
  7804                                  set_user_es_bx:
  7805                                  	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7806                                  	;;mov	[si+2],bx
  7807                                  	;mov	[si+10h],es
  7808                                  	;MOV	[SI+user_env.user_BX],BX
  7809 00000E7B 8C4410                  	MOV	[SI+user_env.user_ES],ES
  7810                                  	;retn
  7811 00000E7E E9B7FD                  	jmp	set_user_bx
  7812                                  
  7813                                  ;**	$Set_Interrupt_Vector - Set Interrupt Vector
  7814                                  ;---------------------------------------------------
  7815                                  ;	$Set_Interrupt_Vector is the official way for user pgms to set the
  7816                                  ;	contents of an interrupt vector.
  7817                                  ;
  7818                                  ;	M004, M068: Also set A20OFF_COUNT to 1 if EXECA20OFF bit has been set 
  7819                                  ;	and if A20OFF_COUNT is non-zero. See under tag M003 in inc\dossym.inc 
  7820                                  ;	for explanation.
  7821                                  ;
  7822                                  ;	ENTRY	(AL) = interrupt number
  7823                                  ;		(ds:dx) = desired new vector value
  7824                                  ;	EXIT	none
  7825                                  ;	USES	all
  7826                                  
  7827                                  ; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7828                                  ; 13/05/2019 - Retro DOS v4.0
  7829                                  
  7830                                  _$SET_INTERRUPT_VECTOR:
  7831 00000E81 E81F00                  	CALL	RECSET
  7832 00000E84 FA                      	CLI				; Watch out!!!!! Folks sometimes use
  7833 00000E85 268917                  	MOV	[ES:BX],DX		;   this for hardware ints (like timer).
  7834 00000E88 268C5F02                	MOV	[ES:BX+2],DS
  7835 00000E8C FB                      	STI
  7836                                  					; M004, M068 - Start
  7837                                  	; MSDOS 6.0
  7838 00000E8D 36F606[8600]04          	test	byte [ss:DOS_FLAG],EXECA20OFF ; 4
  7839                                  					; Q: was the previous call an int 21h
  7840                                  					;    exec call
  7841                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7842                                  	;jnz	short siv_1		; Y: go set count
  7843                                  	;retn				; N: return
  7844                                  	; 15/12/2022
  7845 00000E93 740D                    	jz	short siv_2
  7846                                  siv_1:	
  7847 00000E95 36803E[8500]00          	cmp	byte [ss:A20OFF_COUNT],0 ; Q: is count 0
  7848 00000E9B 7505                    	jnz	short siv_2		 ; N: done
  7849                                  	; 20/09/2023
  7850 00000E9D 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]
  7851                                  	;mov	byte [ss:A20OFF_COUNT],1 ; Y: set it to 1 to indicate to dos
  7852                                  					 ; dispatcher to turn A20 Off before
  7853                                  					 ; returning to user.
  7854                                  siv_2:
  7855                                  	; 07/12/2022
  7856 00000EA2 C3                      	retn				; M004, M068 - End
  7857                                  	
  7858                                  RECSET:
  7859 00000EA3 31DB                    	XOR	BX,BX
  7860 00000EA5 8EC3                    	MOV	ES,BX
  7861 00000EA7 88C3                    	MOV	BL,AL
  7862 00000EA9 D1E3                    	SHL	BX,1
  7863 00000EAB D1E3                    	SHL	BX,1
  7864 00000EAD C3                      	retn
  7865                                  
  7866                                  ;	BREAK <$Char_Oper - hack on paths, switches so that xenix can look like PCDOS>
  7867                                  ;-------------------------------------------------------------------------------------
  7868                                  
  7869                                  ;**	$Char_Oper - Manipulate Switch Character
  7870                                  ;
  7871                                  ;	This function was put in to facilitate XENIX path/switch compatibility
  7872                                  ;
  7873                                  ;	ENTRY	AL = function:
  7874                                  ;		    0 - read switch char
  7875                                  ;		    1 - set switch char (char in DL)
  7876                                  ;		    2 - read device availability
  7877                                  ;			Always returns available
  7878                                  ;		    3 - set device availability
  7879                                  ;			No longer supported (NOP)
  7880                                  ;	EXIT	(al) = 0xff iff error
  7881                                  ;		(al) != 0xff if ok
  7882                                  ;		  (dl) = character/flag, if "read switch char" subfunction
  7883                                  ;	USES	AL, DL
  7884                                  ;
  7885                                  ;	NOTE	This already obsolete function has been deactivated in DOS 5.0
  7886                                  ;		The character / is always returned for subfunction 0,
  7887                                  ;		subfunction 2 always returns -1, all other subfunctions are ignored.
  7888                                  
  7889                                  ; 13/05/2019 - Retro DOS v4.0
  7890                                  ; DOSCODE:4CC9h (MSDOS 6.21, MSDOS.SYS)
  7891                                  
  7892                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7893                                  ; DOSCODE:4CBCh (MSDOS 5.0, MSDOS.SYS)
  7894                                  
  7895                                  _$CHAR_OPER:
  7896                                  	; MSDOS 6.0
  7897 00000EAE 08C0                    	or	al,al				; get switch?
  7898 00000EB0 B22F                    	mov	dl,'/'				; assume yes
  7899 00000EB2 7407                    	jz	short chop_1			; jump if yes
  7900 00000EB4 3C02                    	cmp	al,2				; check device availability?
  7901 00000EB6 B2FF                    	mov	dl,-1				; assume yes
  7902 00000EB8 7401                    	jz	short chop_1			; jump if yes
  7903 00000EBA C3                      	retn					; otherwise just quit
  7904                                  
  7905                                  ; subfunctions requiring return of value to user come here. DL holds
  7906                                  ; value to return
  7907                                  
  7908                                  chop_1:
  7909 00000EBB E8C3F5                  	call	Get_User_Stack
  7910 00000EBE 895406                  	mov	[SI+user_env.user_DX],dx	; store value for user
  7911 00000EC1 C3                      	retn
  7912                                  
  7913                                  	; MSDOS 3.3
  7914                                  	; Offset 1B87h in IBMDOS.COM (MSDOS 3.3), 1987
  7915                                  	;push	ss
  7916                                  	;pop	ds
  7917                                  	;cmp	al,1
  7918                                  	;jb	short chop_1
  7919                                  	;jz	short chop_2
  7920                                  	;cmp	al,3
  7921                                  	;jb	short chop_3
  7922                                  	;jz	short chop_5
  7923                                  	;mov	al,0FFh
  7924                                  	;retn
  7925                                  ;chop_1:
  7926                                  	;mov	dl,[chSwitch]
  7927                                  	;jmp	short chop_4
  7928                                  ;chop_2:
  7929                                  	;mov	[chSwitch],dl
  7930                                  	;retn
  7931                                  ;chop_3:
  7932                                  	;mov	dl, FFh
  7933                                  ;chop_4:
  7934                                  	;call	Get_User_Stack
  7935                                  	;mov	[si+6],dx
  7936                                  ;chop_5:
  7937                                  	;retn
  7938                                  
  7939                                  ;**	$GetExtendedError - Return Extended error code
  7940                                  ;----------------------------------------------------------------------------
  7941                                  ;	This function reads up the extended error info from the static
  7942                                  ;	variables where it was stored.
  7943                                  ;
  7944                                  ;	ENTRY	none
  7945                                  ;	EXIT	AX = Extended error code (0 means no extended error)
  7946                                  ;		BL = recommended action
  7947                                  ;		BH = class of error
  7948                                  ;		CH = locus of error
  7949                                  ;		ES:DI = may be pointer
  7950                                  ;	USES	ALL
  7951                                  
  7952                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7953                                  
  7954                                  _$GetExtendedError:
  7955 00000EC2 16                      	push	ss
  7956 00000EC3 1F                      	pop	ds
  7957 00000EC4 A1[2403]                	MOV	AX,[EXTERR]
  7958 00000EC7 C43E[2803]              	LES	DI,[EXTERRPT]
  7959 00000ECB 8B1E[2603]              	MOV	BX,[EXTERR_ACTION]	; BL = Action, BH = Class
  7960 00000ECF 8A2E[2303]              	MOV	CH,[EXTERR_LOCUS]
  7961 00000ED3 E8ABF5                  	call	Get_User_Stack
  7962                                  	;mov	[si+0Ah],di
  7963 00000ED6 897C0A                  	MOV	[SI+user_env.user_DI],DI
  7964                                  
  7965                                  	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7966                                  	;;mov	[si+10h],es
  7967                                  	;MOV	[SI+user_env.user_ES],ES
  7968                                  	;;mov	[si+2],bx
  7969                                  	;MOV	[SI+user_env.user_BX],BX
  7970 00000ED9 E89FFF                  	call	set_user_es_bx
  7971                                  
  7972                                  	;mov	[si+4],cx
  7973 00000EDC 894C04                  	MOV	[SI+user_env.user_CX],CX
  7974                                  jmp_SYS_RET_OK:
  7975                                  	; 15/12/2022
  7976                                  	;jmp	SYS_RET_OK
  7977                                  	; 25/06/2019
  7978 00000EDF E952F7                  	jmp	SYS_RET_OK_clc ; 15/12/2022
  7979                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7980                                  ;jmp_SYS_RET_OK:
  7981                                  	;jmp	SYS_RET_OK
  7982                                  
  7983                                  ; --------------------------------------------------------------------------
  7984                                  ; 09/01/2024
  7985                                  %if 0
  7986                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7987                                  	; DOSCODE:4CF3h
  7988                                  ;patch_or_unknown:
  7989                                  ;get_code_page:
  7990                                  	push    si
  7991                                  	mov     si, COUNTRY_CDPG
  7992                                  	;mov	ax, [si+DOS_CCDPG.ccDosCodePage]
  7993                                  	mov     ax, [ss:si+6Ah]
  7994                                  	pop     si
  7995                                  	retn
  7996                                  %endif
  7997                                  ; --------------------------------------------------------------------------
  7998                                  
  7999                                  ; 29/04/2019 - Retro DOS v4.0
  8000                                  
  8001                                  ;BREAK	<ECS_call - Extended Code System support function>
  8002                                  ;---------------------------------------------------------------------------
  8003                                  ; Inputs:
  8004                                  ;	AL = 0	get lead byte table
  8005                                  ;		on return DS:SI has the table location
  8006                                  ;
  8007                                  ;	AL = 1	set / reset interim console flag
  8008                                  ;		DL = flag (00H or 01H)
  8009                                  ;		no return
  8010                                  ;
  8011                                  ;	AL = 2	get interim console flag
  8012                                  ;		on return DL = current flag value
  8013                                  ;
  8014                                  ;	AL = OTHER then error, and returns with:
  8015                                  ;		AX = error_invalid_function
  8016                                  ;
  8017                                  ;  NOTE: THIS CALL DOES GUARANTEE THAT REGISTER OTHER THAN
  8018                                  ;	 SS:SP WILL BE PRESERVED!
  8019                                  ;---------------------------------------------------------------------------
  8020                                  
  8021                                  _$ECS_Call:
  8022 00000EE2 08C0                    	or	al,al			; AL = 0 (get table)?
  8023                                  	;jnz	short _okok
  8024                                  	; 15/12/2022
  8025 00000EE4 7403                    	jz	short get_lbt
  8026                                  ;_okok:
  8027 00000EE6 E948F7                  	jmp	SYS_RET_OK
  8028                                  get_lbt:
  8029 00000EE9 E895F5                  	call	Get_User_Stack		; *
  8030                                  
  8031                                  ;hkn; dbcs_table moved low to dosdata
  8032                                  	;mov	word [si+8],DBCS_TAB+2
  8033 00000EEC C74408[E50C]            	mov	word [si+user_env.user_SI],DBCS_TAB+2
  8034                                  
  8035 00000EF1 06                      	push	es
  8036                                  	;getdseg <es>			; es = DOSDATA
  8037 00000EF2 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  8038                                  	;mov	[si+14],es
  8039 00000EF7 8C440E                  	mov	[SI+user_env.user_DS],es
  8040 00000EFA 07                      	pop	es
  8041                                  
  8042                                  	; 15/12/2022
  8043 00000EFB EBE2                    	jmp	short jmp_SYS_RET_OK ; jmp SYS_RET_OK_clc ; *
  8044                                  ;_okok:
  8045                                  	; 15/12/2022	
  8046                                  	;;transfer SYS_RET_OK
  8047                                  	;jmp	short jmp_SYS_RET_OK
  8048                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8049                                  	;;jmp	SYS_RET_OK
  8050                                  	;jmp	short jmp_SYS_RET_OK
  8051                                  
  8052                                  ;============================================================================
  8053                                  ; PARSE.ASM, MSDOS 6.0, 1991
  8054                                  ;============================================================================
  8055                                  ; 19/07/2018 - Retro DOS v3.0
  8056                                  ; 15/05/2019 - Retro DOS v4.0
  8057                                  
  8058                                  ; System calls for parsing command lines
  8059                                  ;
  8060                                  ;   $PARSE_FILE_DESCRIPTOR
  8061                                  ;
  8062                                  ;   Modification history:
  8063                                  ;
  8064                                  ;       Created: ARR 30 March 1983
  8065                                  ;               EE PathParse 10 Sept 1983
  8066                                  ;
  8067                                  
  8068                                  ;BREAK <$Parse_File_Descriptor -- Parse an arbitrary string into an FCB>
  8069                                  ;---------------------------------------------------------------------------
  8070                                  ; Inputs:
  8071                                  ;       DS:SI Points to a command line
  8072                                  ;       ES:DI Points to an empty FCB
  8073                                  ;       Bit 0 of AL = 1 At most one leading separator scanned off
  8074                                  ;                   = 0 Parse stops if separator encountered
  8075                                  ;       Bit 1 of AL = 1 If drive field blank in command line - leave FCB
  8076                                  ;                   = 0  "    "    "     "         "      "  - put 0 in FCB
  8077                                  ;       Bit 2 of AL = 1 If filename field blank - leave FCB
  8078                                  ;                   = 0  "       "      "       - put blanks in FCB
  8079                                  ;       Bit 3 of AL = 1 If extension field blank - leave FCB
  8080                                  ;                   = 0  "       "      "        - put blanks in FCB
  8081                                  ; Function:
  8082                                  ;       Parse command line into FCB
  8083                                  ; Returns:
  8084                                  ;       AL = 1 if '*' or '?' in filename or extension, 0 otherwise
  8085                                  ;       DS:SI points to first character after filename
  8086                                  ;---------------------------------------------------------------------------
  8087                                  
  8088                                  _$PARSE_FILE_DESCRIPTOR:
  8089 00000EFD E88A3E                  	call	MAKEFCB
  8090 00000F00 56                      	PUSH    SI
  8091 00000F01 E87DF5                  	call	Get_User_Stack
  8092                                  	;pop	word [si+8]
  8093 00000F04 8F4408                  	POP     word [SI+user_env.user_SI]
  8094 00000F07 C3                      	retn
  8095                                  
  8096                                  ;============================================================================
  8097                                  ; MISC.ASM, MSDOS 6.0, 1991
  8098                                  ;============================================================================
  8099                                  ; 19/07/2018 - Retro DOS v3.0
  8100                                  
  8101                                  ; 29/04/2019 - Retro DOS v4.0
  8102                                  
  8103                                  ;ENTRYPOINTSEG	EQU	0CH
  8104                                  ;MAXDIF		EQU	0FFFH
  8105                                  ;SAVEXIT 	EQU	10
  8106                                  ;WRAPOFFSET	EQU	0FEF0h
  8107                                  
  8108                                  ;
  8109                                  ;----------------------------------------------------------------------------
  8110                                  ;
  8111                                  ;**	$SLEAZEFUNC - Get a Pointer to the Media Byte
  8112                                  ;
  8113                                  ;	Return Stuff sort of like old get fat call
  8114                                  ;
  8115                                  ;	ENTRY	none
  8116                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  8117                                  ;			GOD help anyone who tries to do ANYTHING except
  8118                                  ;			READ this ONE byte.
  8119                                  ;		DX = Total Number of allocation units on disk
  8120                                  ;		CX = Sector size
  8121                                  ;		AL = Sectors per allocation unit
  8122                                  ;		   = -1 if bad drive specified
  8123                                  ;	USES	all
  8124                                  ;
  8125                                  ;**	$SLEAZEFUNCDL - Get a Pointer to the Media Byte
  8126                                  ;
  8127                                  ;	Identical to $SLEAZEFUNC except (dl) = drive
  8128                                  ;
  8129                                  ;	ENTRY	(dl) = drive (0=default, 1=A, 2=B, etc.)
  8130                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  8131                                  ;			GOD help anyone who tries to do ANYTHING except
  8132                                  ;			READ this ONE byte.
  8133                                  ;		DX = Total Number of allocation units on disk
  8134                                  ;		CX = Sector size
  8135                                  ;		AL = Sectors per allocation unit
  8136                                  ;		   = -1 if bad drive specified
  8137                                  ;	USES	all
  8138                                  ;
  8139                                  ;----------------------------------------------------------------------------
  8140                                  ;
  8141                                  
  8142                                  _$SLEAZEFUNC:
  8143                                  	; 10/01/2024
  8144                                  	; 15/05/2019 - Retro DOS v4.0
  8145 00000F08 B200                    	MOV	DL,0
  8146                                  _$SLEAZEFUNCDL:
  8147 00000F0A 16                      	push	ss
  8148 00000F0B 1F                      	pop	ds
  8149                                  	
  8150 00000F0C 88D0                    	MOV	AL,DL
  8151 00000F0E E8C359                  	call	GETTHISDRV		; Get CDS structure
  8152                                  SET_AL_RET:
  8153                                  	; MSDOS 3.3
  8154                                  	;;mov	al, 0Fh
  8155                                  	;MOV	AL,error_invalid_drive	; Assume error	;AC000;
  8156                                  	
  8157                                  	; MSDOS 6.0 & MSDOS 3.3
  8158 00000F11 721D                    	JC	short BADSLDRIVE
  8159                                  
  8160 00000F13 E8081D                  	call	DISK_INFO
  8161                                  	;JC	short SET_AL_RET	; User FAILed to I 24
  8162 00000F16 7218                    	jc	short BADSLDRIVE
  8163 00000F18 8826[9805]              	MOV	[FATBYTE],AH
  8164                                  
  8165                                  ; NOTE THAT A FIXED MEMORY CELL IS USED --> THIS CALL IS NOT
  8166                                  ; RE-ENTRANT. USERS BETTER GET THE ID BYTE BEFORE THEY MAKE THE
  8167                                  ; CALL AGAIN
  8168                                  
  8169                                  	; 10/01/2024
  8170                                  	;MOV	DI,FATBYTE
  8171 00000F1C 30E4                    	XOR	AH,AH			; AL has sectors/cluster
  8172 00000F1E E860F5                  	call	Get_User_Stack
  8173                                  	;mov	[si+4],cx
  8174                                  	;mov	[si+6],bx
  8175                                  	;mov	[si+2],di
  8176 00000F21 894C04                  	MOV	[SI+user_env.user_CX],CX
  8177 00000F24 895C06                  	MOV	[SI+user_env.user_DX],BX
  8178                                  	;MOV	[SI+user_env.user_BX],DI
  8179                                  	; 10/01/2024
  8180 00000F27 C74402[9805]            	MOV	word [SI+user_env.user_BX],FATBYTE
  8181                                  	
  8182                                  	;mov	[si+0Eh],ss
  8183 00000F2C 8C540E                  	MOV     [SI+user_env.user_DS],SS ; stash correct pointer
  8184                                  
  8185 00000F2F C3                      	retn
  8186                                  
  8187                                  BADSLDRIVE:
  8188 00000F30 E91DF7                  	jmp	FCB_RET_ERR
  8189                                  
  8190                                  ;
  8191                                  ;----------------------------------------------------------------------------
  8192                                  ;
  8193                                  ;**	$Get_INDOS_Flag - Return location of DOS Critical Section Flag
  8194                                  ;
  8195                                  ;	Returns location of DOS status for interrupt routines
  8196                                  ;
  8197                                  ;	ENTRY	none
  8198                                  ;	EXIT	(es:bx) = flag location
  8199                                  ;	USES	all
  8200                                  ;
  8201                                  ;----------------------------------------------------------------------------
  8202                                  ;
  8203                                  
  8204                                  _$GET_INDOS_FLAG:
  8205 00000F33 E84BF5                          CALL	Get_User_Stack
  8206                                          ;MOV	WORD [SI+2],INDOS
  8207 00000F36 C74402[2103]            	MOV     word [SI+user_env.user_BX],INDOS
  8208                                  getin_segm:	; 13/01/2024
  8209                                  	;MOV	[SI+10H],SS
  8210 00000F3B 8C5410                  	MOV	[SI+user_env.user_ES],SS
  8211 00000F3E C3                      	RETN 
  8212                                  ;
  8213                                  ;----------------------------------------------------------------------------
  8214                                  ;
  8215                                  ;**	$Get_IN_Vars - Return Pointer to DOS Variables
  8216                                  ;
  8217                                  ;	Return a pointer to interesting DOS variables This call is version
  8218                                  ;	dependent and is subject to change without notice in future versions.
  8219                                  ;	Use at risk.
  8220                                  ;
  8221                                  ;	ENTRY	none
  8222                                  ;	EXIT	(es:bx) = address of SYSINITVAR
  8223                                  ;	uses	ALL
  8224                                  ;
  8225                                  ;----------------------------------------------------------------------------
  8226                                  ;
  8227                                  
  8228                                  	; 13/01/2024
  8229                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:5226h
  8230                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:4D65h
  8231                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:4D58h	
  8232                                  
  8233                                  _$GET_IN_VARS:
  8234 00000F3F E83FF5                  	CALL	Get_User_Stack
  8235                                  	;MOV	WORD [SI+2],SYSINITVAR
  8236                                  	;MOV	word [SI+user_env.user_BX],SYSINITVAR
  8237 00000F42 C74402[2600]            	MOV	word [SI+user_env.user_BX],SYSINITVARS
  8238                                  	; 13/01/2024
  8239                                  	;;MOV	[SI+10H],SS
  8240                                  	;MOV	[SI+user_env.user_ES],SS
  8241                                  	;RETN
  8242 00000F47 EBF2                    	jmp	short getin_segm
  8243                                  
  8244                                  ;
  8245                                  ;----------------------------------------------------------------------------
  8246                                  ;
  8247                                  ;**	$Get_Default_DPB - Return a pointer to the Default DPB
  8248                                  ;
  8249                                  ;	Return pointer to drive parameter table for default drive
  8250                                  ;
  8251                                  ;	ENTRY	none
  8252                                  ;	EXIT	(ds:bx) = DPB address
  8253                                  ;	USES	all
  8254                                  ;
  8255                                  ;**	$Get_DPB - Return a pointer to a specified DPB
  8256                                  ;
  8257                                  ;	Return pointer to a specified drive parameter table
  8258                                  ;
  8259                                  ;	ENTRY	(dl) = drive # (0 = default, 1=A, 2=B, etc.)
  8260                                  ;	EXIT	(al) = 0 iff ok
  8261                                  ;		  (ds:bx) = DPB address
  8262                                  ;		(al) = -1 if bad drive
  8263                                  ;	USES	all
  8264                                  ;
  8265                                  ;----------------------------------------------------------------------------
  8266                                  ;
  8267                                  
  8268                                  ; 15/05/2019 - Retro DOS v4.0
  8269                                  
  8270                                  _$GET_DEFAULT_DPB:
  8271 00000F49 B200                    	MOV	DL,0
  8272                                  _$GET_DPB:
  8273 00000F4B 16                      	push	ss
  8274 00000F4C 1F                      	pop	ds
  8275                                  
  8276 00000F4D 88D0                    	MOV	AL,DL
  8277 00000F4F E88259                  	call	GETTHISDRV		; Get CDS structure
  8278 00000F52 7222                    	JC	short ISNODRV 		; no valid drive
  8279 00000F54 C43E[A205]              	LES	DI,[THISCDS]		; check for net CDS
  8280                                  	;;test	word [es:di+43h],8000h
  8281                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
  8282                                  	;test	byte [es:di+44h],80h
  8283 00000F58 26F6454480              	test	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
  8284 00000F5D 7517                    	JNZ	short ISNODRV 		; No DPB to point at on NET stuff
  8285 00000F5F E88003                  	call	ECritDisk
  8286 00000F62 E8DD45                  	call	FATREAD_CDS		; Force Media Check and return DPB
  8287 00000F65 E89503                  	call	LCritDisk
  8288 00000F68 720C                    	JC	short ISNODRV 		; User FAILed to I 24, only error we
  8289                                  					;   have.
  8290 00000F6A E814F5                  	call	Get_User_Stack
  8291                                  	;mov	[si+2],bp
  8292 00000F6D 896C02                  	MOV	[SI+user_env.user_BX],BP
  8293                                  	;mov	[si+0Eh],es
  8294 00000F70 8C440E                  	MOV	[SI+user_env.user_DS],ES
  8295 00000F73 30C0                    	XOR	AL,AL
  8296 00000F75 C3                      	retn
  8297                                  ISNODRV:
  8298 00000F76 B0FF                    	MOV	AL,-1
  8299 00000F78 C3                      	retn
  8300                                  
  8301                                  ;
  8302                                  ;----------------------------------------------------------------------------
  8303                                  ;
  8304                                  ;**	$Disk_Reset - Flush out Dirty Buffers
  8305                                  ;
  8306                                  ;	$DiskReset flushes and invalidates all buffers.  BUGBUG - do
  8307                                  ;		we really invalidate?  SHould we?  THis screws non-removable
  8308                                  ;		caching.  Maybe CHKDSK relies upon it, though....
  8309                                  ;
  8310                                  ;	ENTRY	none
  8311                                  ;	EXIT	none
  8312                                  ;	USES	all
  8313                                  ;
  8314                                  ;----------------------------------------------------------------------------
  8315                                  ;
  8316                                  
  8317                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8318                                  	; DOSCODE:4D94h
  8319                                  _$DISK_RESET:
  8320                                  	; 15/05/2019 - Retro DOS v4.0
  8321 00000F79 B0FF                    	mov	al,0FFh	; -1
  8322 00000F7B 16                      	push	ss
  8323 00000F7C 1F                      	pop	ds
  8324                                  	; 06/11/2022
  8325                                  	;MOV	AL,-1
  8326 00000F7D E86203                  	call	ECritDisk
  8327                                  	; MSDOS 6.0
  8328                                  	;;or	word [DOS34_FLAG],4
  8329                                  	;or	word [DOS34_FLAG],FROM_DISK_RESET    ;AN000;
  8330 00000F80 800E[1106]04            	or	byte [DOS34_FLAG],FROM_DISK_RESET ; 4 ; 15/05/2019
  8331 00000F85 E82D49                  	call	FLUSHBUF
  8332                                  	; MSDOS 6.0
  8333                                  	;and	word [DOS34_FLAG],0FFFBh
  8334                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8335                                  	;and	word [DOS34_FLAG],NO_FROM_DISK_RESET ;AN000;
  8336                                  	; 15/12/2022
  8337 00000F88 8026[1106]FB            	and	byte [DOS34_FLAG],NO_FROM_DISK_RESET ; 0FBh ; 15/05/2019
  8338 00000F8D C706[B50D]0000          	mov	word [SC_STATUS],0	; Throw out secondary cache M041
  8339                                  ;
  8340                                  ; We will "ignore" any errors on the flush, and go ahead and invalidate. This
  8341                                  ; call doesn't return any errors and it is supposed to FORCE a known state, so
  8342                                  ; let's do it.
  8343                                  ;
  8344                                  ; Invalidate 'last-buffer' used
  8345                                  ;
  8346 00000F93 BBFFFF                  	MOV	BX,-1 ; 0FFFFh	
  8347 00000F96 891E[2000]              	MOV	[LastBuffer+2],BX
  8348 00000F9A 891E[1E00]              	MOV	[LastBuffer],BX
  8349                                  
  8350                                  	; MSDOS 3.3 
  8351                                  	; IBMDOS.COM, Offset 1C66h
  8352                                  	;;;;
  8353                                  	;lds	si,[BUFFHEAD]
  8354                                  	;mov	ax,20FFh	; .buf_ID,    AL = FFh (Free buffer)
  8355                                  				; .buf_flags, AH = 0, reset/clear
  8356                                  ;DRST_1:
  8357                                  	;;mov	[si+4],ax
  8358                                  	;mov	[si+BUFFINFO.buf_ID],ax
  8359                                  	;lds	si,[SI]
  8360                                  	;cmp	si,bx ; -1
  8361                                  	;je	short DRST_2
  8362                                  	;;mov	[si+4],ax
  8363                                  	;mov	[si+BUFFINFO.buf_ID],ax
  8364                                  	;lds	si,[SI]
  8365                                  	;cmp	si,bx
  8366                                  	;jne	short DRST_1
  8367                                  	;;;;
  8368                                  ;DRST_2:
  8369 00000F9E E85C03                  	call	LCritDisk
  8370 00000FA1 B8FFFF                  	MOV	AX,-1
  8371                                  	; 07/12/2022
  8372                                  	;mov	ax,0FFFFh
  8373                                  	;CallInstall NetFlushBuf,MultNET,32,AX,AX
  8374 00000FA4 50                      	push	ax ; * MSDOS 6.0 ; 15/05/2019
  8375 00000FA5 B82011                  	mov     ax,1120h
  8376 00000FA8 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
  8377                                  			; DS = DOS CS
  8378                                  			; Return: CF clear (successful)
  8379 00000FAA 58                      	pop	ax ; * MSDOS 6.0 ; 15/05/2019
  8380                                  	
  8381 00000FAB C3                      	retn
  8382                                  
  8383                                  	; 19/07/2018 - Retro DOS v3.0
  8384                                  
  8385                                  ;
  8386                                  ;	BREAK <$SetDPB - Create a valid DPB from a user-specified BPB>
  8387                                  ;
  8388                                  ;----------------------------------------------------------------------------
  8389                                  ;
  8390                                  ;**	$SetDPB - Create a DPB
  8391                                  ;
  8392                                  ;	SetDPB Creates a valid DPB from a user-specified BPB
  8393                                  ;
  8394                                  ;	ENTRY	ES:BP Points to DPB
  8395                                  ;		DS:SI Points to BPB
  8396                                  ;	EXIT	DPB setup
  8397                                  ;	USES	ALL but BP, DS, ES
  8398                                  ;
  8399                                  ;----------------------------------------------------------------------------
  8400                                  ;
  8401                                  
  8402                                  ; 10/05/2019 - Retro DOS v4.0
  8403                                  
  8404                                  ; DOSCODE:4DD6h (MSDOS 6.21, MSDOS.SYS)
  8405                                  
  8406                                  ; MSDOS 6.0
  8407 00000FAC 0300                    word3:	dw	3			; M008 -- word value for divides
  8408                                  
  8409                                  ; 13/01/2024
  8410                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8411                                  ; DOSCODE:4DC9h (MSDOS 5.0, MSDOS.SYS)
  8412                                  
  8413                                  ;procedure   $SETDPB,NEAR
  8414                                  
  8415                                  _$SETDPB:
  8416 00000FAE 89EF                    	MOV	DI,BP
  8417                                  	;ADD	DI,2			; Skip over dpb_drive and dpb_UNIT
  8418                                  	; 13/01/2024
  8419 00000FB0 47                      	inc	di
  8420 00000FB1 47                      	inc	di
  8421 00000FB2 AD                      	LODSW
  8422 00000FB3 AB                      	STOSW				; dpb_sector_size
  8423                                  	; MSDOS 6.0
  8424                                  	;cmp	byte [si+3],0
  8425 00000FB4 807C0300                	CMP	BYTE [SI+A_BPB.BPB_NUMBEROFFATS-2],0 ; FAT file system drive ;AN000;
  8426 00000FB8 7509                    	JNZ	short yesfat			     ; yes		;AN000;
  8427                                  	;mov	byte [es:di+4],0
  8428 00000FBA 26C6450400              	MOV	BYTE [ES:DI+DPB.FAT_COUNT-4],0
  8429                                  	; 13/01/2024
  8430 00000FBF 89C3                    	mov	bx,ax
  8431 00000FC1 EB70                    	JMP	short setend			     ; NO		;AN000;
  8432                                  
  8433                                  yesfat: ; 10/08/2018
  8434 00000FC3 89C2                    	MOV	DX,AX
  8435 00000FC5 AC                      	LODSB
  8436                                  	;DEC	AL
  8437                                  	; 17/12/2022
  8438 00000FC6 48                      	dec	ax
  8439 00000FC7 AA                      	STOSB				; dpb_cluster_mask
  8440                                  	;INC	AL
  8441 00000FC8 40                      	inc	ax
  8442 00000FC9 30E4                    	XOR	AH,AH
  8443                                  LOG2LOOP:
  8444 00000FCB A801                    	test	AL,1
  8445 00000FCD 7506                    	JNZ	short SAVLOG
  8446 00000FCF FEC4                    	INC	AH
  8447 00000FD1 D0E8                    	SHR	AL,1
  8448 00000FD3 EBF6                    	JMP	SHORT LOG2LOOP
  8449                                  SAVLOG:
  8450 00000FD5 88E0                    	MOV	AL,AH
  8451 00000FD7 AA                      	STOSB				; dpb_cluster_shift
  8452 00000FD8 88C3                    	MOV	BL,AL
  8453 00000FDA A5                      	MOVSW				; dpb_first_FAT Start of FAT (# of reserved sectors)
  8454 00000FDB AC                      	LODSB
  8455 00000FDC AA                      	STOSB				; dpb_FAT_count Number of FATs
  8456                                  ;	OR	AL,AL			; NONFAT ?				;AN000;
  8457                                  ;	JZ	short setend		; yes, don't do anything                ;AN000;
  8458 00000FDD 88C7                    	MOV	BH,AL
  8459 00000FDF AD                      	LODSW
  8460 00000FE0 AB                      	STOSW				; dpb_root_entries Number of directory entries
  8461 00000FE1 B105                    	MOV	CL,5
  8462 00000FE3 D3EA                    	SHR	DX,CL			; Directory entries per sector
  8463 00000FE5 48                      	DEC	AX
  8464 00000FE6 01D0                    	ADD	AX,DX			; Cause Round Up
  8465 00000FE8 89D1                    	MOV	CX,DX
  8466 00000FEA 31D2                    	XOR	DX,DX
  8467 00000FEC F7F1                    	DIV	CX
  8468 00000FEE 89C1                    	MOV	CX,AX			; Number of (root) directory sectors
  8469 00000FF0 47                      	INC	DI
  8470 00000FF1 47                      	INC	DI			; Skip dpb_first_sector
  8471 00000FF2 A5                      	MOVSW			; Total number of sectors in DSKSIZ (temp as dpb_max_cluster)
  8472 00000FF3 AC                      	LODSB
  8473                                  	;mov	[es:bp+17h],al
  8474 00000FF4 26884617                	MOV	[ES:BP+DPB.MEDIA],AL	; Media byte
  8475 00000FF8 AD                      	LODSW				; Number of sectors in a FAT
  8476                                  	
  8477                                  	;;;
  8478                                  	;MSDOS 3.3
  8479                                  	;
  8480                                  	;STOSB		; DPB.FAT_SIZE
  8481                                  	;MUL	BH
  8482                                  	
  8483                                  	;MSDOS 6.0
  8484                                  	;
  8485 00000FF9 AB                      	STOSW		; DPB.FAT_SIZE	;AC000;;>32mb dpb_FAT_size
  8486 00000FFA 88FA                    	MOV	DL,BH			;AN000;;>32mb
  8487 00000FFC 30F6                    	XOR	DH,DH			;AN000;;>32mb
  8488 00000FFE F7E2                    	MUL	DX			;AC000;;>32mb Space occupied by all FATs
  8489                                  	;;;
  8490                                  	
  8491                                  	;add	ax,[es:bp+6]
  8492 00001000 26034606                	ADD	AX,[ES:BP+DPB.FIRST_FAT]
  8493 00001004 AB                      	STOSW				; dpb_dir_sector
  8494 00001005 01C8                    	ADD	AX,CX			; Add number of (root) directory sectors
  8495                                  	;mov	[es:bp+0Bh],ax
  8496 00001007 2689460B                	MOV	[ES:BP+DPB.FIRST_SECTOR],AX
  8497                                  	
  8498                                  	; MSDOS 6.0
  8499 0000100B 88D9                    	MOV	CL,BL			;F.C. >32mb				;AN000;
  8500                                  	;;cmp	word [es:bp+0Dh],0
  8501                                  	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
  8502                                  	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
  8503                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8504                                  	; 15/12/2022
  8505                                  	; 28/07/2019
  8506 0000100D 268B5E0D                	mov	bx,[ES:BP+DSKSIZ]
  8507 00001011 09DB                    	or	bx,bx
  8508 00001013 751A                    	JNZ	short normal_dpb	;F.C. >32mb				;AN000;
  8509                                  	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
  8510                                  	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
  8511                                  	
  8512                                  
  8513 00001015 30ED                    	XOR	CH,CH			;F.C. >32mb				;AN000;
  8514                                  	;mov	bx,[si+8]
  8515 00001017 8B5C08                  	MOV	BX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK]	;AN000;
  8516                                  	;mov	dx,[si+10]
  8517 0000101A 8B540A                  	MOV	DX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK+2]	;AN000;
  8518 0000101D 29C3                    	SUB	BX,AX			;AN000;;F.C. >32mb
  8519 0000101F 83DA00                  	SBB	DX,0			;AN000;;F.C. >32mb
  8520 00001022 09C9                    	OR	CX,CX			;AN000;;F.C. >32mb
  8521 00001024 7407                    	JZ	short norot		;AN000;;F.C. >32mb
  8522                                  rott:					;AN000;;F.C. >32mb
  8523 00001026 F8                      	CLC				;AN000;;F.C. >32mb
  8524 00001027 D1DA                    	RCR	DX,1			;AN000;;F.C. >32mb
  8525 00001029 D1DB                    	RCR	BX,1			;AN000;;F.C. >32mb
  8526 0000102B E2F9                    	LOOP	rott			;AN000;;F.C. >32mb
  8527                                  norot:					;AN000;
  8528                                  	; 15/12/2022
  8529                                  	;MOV	AX,BX			;AN000;;F.C. >32mb
  8530 0000102D EB04                    	JMP	short setend		;AN000;;F.C. >32mb
  8531                                  normal_dpb:
  8532                                  	;;sub	ax,[es:bp+0Dh]
  8533                                  	;SUB	AX,[ES:BP+DSKSIZ]
  8534                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8535                                  	; 15/12/2022
  8536                                  	; bx = [es:bp+DSKSIZ]
  8537                                  	;sub	ax,bx ; 28/07/2019
  8538                                  	;;SUB	AX,[ES:BP+DSKSIZ]
  8539                                  	; 15/12/2022
  8540 0000102F 29C3                    	sub	bx,ax
  8541                                  	;NEG	AX			; Sectors in data area
  8542                                  ;;	MOV	CL,BL			; dpb_cluster_shift
  8543                                  	; 15/12/2022
  8544                                  	; CL = cluster shift
  8545                                  	; BX = number of data sectors 
  8546                                  	;SHR	AX,CL			; Div by sectors/cluster
  8547 00001031 D3EB                    	shr	bx,cl 
  8548                                  setend:
  8549                                  ;	M008 - CAS
  8550                                  ;
  8551                                  	; 15/12/2022
  8552 00001033 43                      	inc	bx
  8553                                  	;INC	AX			; +2 (reserved), -1 (count -> max)
  8554                                  ;
  8555                                  ;	There has been a bug in our fatsize calculation for so long
  8556                                  ;	  that we can't correct it now without causing some user to
  8557                                  ;	  experience data loss. There are even cases where allowing
  8558                                  ;	  the number of clusters to exceed the fats is the optimal
  8559                                  ;	  case -- where adding 2 more fat sectors would make the
  8560                                  ;	  data field smaller so that there's nothing to use the extra
  8561                                  ;	  fat sectors for.
  8562                                  ;
  8563                                  ;	Note that this bug had very minor known symptoms. CHKDSK would
  8564                                  ;	  still report that there was a cluster left when the disk was
  8565                                  ;	  actually full. Very graceful failure for a corrupt system
  8566                                  ;	  configuration. There may be worse cases that were never
  8567                                  ;	  properly traced back to this bug. The problem cases only
  8568                                  ;	  occurred when partition sizes were very near FAT sector
  8569                                  ;	  rounding boundaries, which were rare cases.
  8570                                  ;
  8571                                  ;	Also, it's possible that some third-party partition program might
  8572                                  ;	  create a partition that had a less-than-perfect FAT calculation
  8573                                  ;	  scheme. In this hypothetical case, the number of allocation
  8574                                  ;	  clusters which don't actually have FAT entries to represent
  8575                                  ;	  them might be larger and might create a more catastrophic
  8576                                  ;	  failure. So we'll provide the safeguard of limiting the
  8577                                  ;	  max_cluster to the amount that will fit in the FATs.
  8578                                  ;
  8579                                  ;	ax = maximum legal cluster, ES:BP -> dpb
  8580                                  
  8581                                  ;	make sure the number of fat sectors is actually enough to
  8582                                  ;	  hold that many clusters. otherwise, back the number of
  8583                                  ;	  clusters down
  8584                                  
  8585                                  	; 15/12/2022
  8586                                  	; bx = number of clusters
  8587                                  
  8588                                  	; 19/07/2018 - Retro DOS v3.0
  8589                                  	; MSDOS 6.0
  8590                                  	; 15/12/2022
  8591                                  	;mov	bx,ax			; remember calculated # clusters
  8592                                  
  8593                                  	; 01/08/2018 (MSDOS 3.3)
  8594                                  	;mov	al,[ES:BP+DPB.FAT_SIZE]
  8595                                  	;xor	ah,ah 
  8596                                  
  8597                                  	; 10/05/2019 - Retro DOS v4.0
  8598                                  	;mov	ax,[ES:BP+0Fh]
  8599 00001034 268B460F                	mov	ax,[ES:BP+DPB.FAT_SIZE]
  8600                                  
  8601                                  	;mul	word [es:bp+2]	
  8602 00001038 26F76602                	mul	word [ES:BP+DPB.SECTOR_SIZE] ; how big is the FAT?
  8603 0000103C 81FBF60F                	cmp	bx,4096-10  ; 0FF6h	; test for 12 vs. 16 bit fat
  8604 00001040 720D                    	jb	short setend_fat12
  8605 00001042 D1EA                    	shr	dx,1
  8606                                  
  8607                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8608                                  	; 15/12/2022
  8609                                  ;cs3 7/2/92
  8610 00001044 751C                    	jnz	short setend_faterr	; some bonehead gave us more fatspace
  8611                                  					; than enough for the maximum FAT,
  8612                                  					; so go ahead and use the calculated
  8613                                  					; number of clusters.
  8614                                  ;cs3 7/2/92
  8615                                  
  8616 00001046 D1D8                    	rcr	ax,1			; find number of entries
  8617 00001048 3DF70F                  	cmp	ax,4096-10+1		; would this truncation move us
  8618                                  ;					;  into 12-bit fatland?
  8619 0000104B 7215                    	jb	short setend_faterr	; then go ahead and let the
  8620                                  ;					;  inconsistency pass through
  8621                                  ;					;  rather than lose data by
  8622                                  ;					;  correcting the fat type
  8623 0000104D EB0E                    	jmp	short setend_fat16
  8624                                  
  8625                                  setend_fat12:
  8626 0000104F 01C0                    	add	ax,ax			; (fatsiz*2)/3 = # of fat entries
  8627 00001051 11D2                    	adc	dx,dx
  8628                                  
  8629                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8630                                  ;cs3 7/2/92
  8631                                  	; 15/12/2022
  8632 00001053 83FA03                  	cmp	dx,3			; if our fatspace is WAY more than
  8633 00001056 730A                    	jnb	short setend_faterr	; we need, we may get an overflow
  8634                                  					; here. Check for it and use
  8635                                  					; the calculated size in this case.
  8636                                  ;cs3 7/2/92
  8637                                  
  8638 00001058 2EF736[AC0F]            	div	word [cs:word3]
  8639                                  
  8640                                  setend_fat16:
  8641 0000105D 48                      	dec	ax			; limit at 1
  8642 0000105E 39D8                    	cmp	ax,bx			; is fat big enough?
  8643 00001060 7602                    	jbe	short setend_fat	; use max value that'll fit
  8644                                  
  8645                                  setend_faterr:
  8646 00001062 89D8                    	mov	ax,bx			; use calculated value
  8647                                  
  8648                                  setend_fat:
  8649                                  
  8650                                  ;	now ax = maximum legal cluster
  8651                                  
  8652                                  ;	end M008
  8653                                  
  8654                                  	;mov	[es:bp+0Dh], ax
  8655 00001064 2689460D                	MOV	[ES:BP+DPB.MAX_CLUSTER],AX
  8656                                  	;;mov	word [es:bp+1Ch],0  ; MSDOS 3.3
  8657                                  	;mov	word [es:bp+1Dh],0  ; MSDOS 6.0
  8658 00001068 26C7461D0000            	MOV	word [ES:BP+DPB.NEXT_FREE],0 
  8659                                  					; Init so first ALLOC starts at
  8660                                  					; begining of FAT
  8661                                  	;;mov	word [es:bp+1Eh],-1 ; MSDOS 3.3
  8662                                  	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
  8663 0000106E 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; current count is invalid.
  8664                                  
  8665 00001074 C3                      	retn
  8666                                  
  8667                                  ;EndProc $SETDPB
  8668                                  
  8669                                  ;BREAK <$Create_Process_Data_Block,SetMem -- Set up process data block>
  8670                                  
  8671                                  ;
  8672                                  ;----------------------------------------------------------------------------
  8673                                  ;
  8674                                  ;**	$Dup_PDB
  8675                                  ;
  8676                                  ; Inputs:   DX is new segment address of process
  8677                                  ;	    SI is end of new allocation block
  8678                                  ;
  8679                                  ;----------------------------------------------------------------------------
  8680                                  ;
  8681                                  
  8682                                  _$DUP_PDB:
  8683                                  
  8684                                  ;hkn;	CreatePDB would have a CS override. This is not valid.
  8685                                  ;hkn;	Must set up ds in order to acess CreatePDB. Also SS is 
  8686                                  ;hkn;	has been assumed to be NOTHING. It may not have DOSDATA.
  8687                                  
  8688                                  	; MSDOS 3.3
  8689                                  	;MOV	byte [CS:CreatePDB],0FFh  ; indicate a new process
  8690                                  	;MOV	DS,[CS:CurrentPDB]
  8691                                  
  8692                                  	; 15/05/2019 - Retro DOS v4.0
  8693                                  	; MSDOS 6.0
  8694 00001075 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  8695 0000107A C606[A803]FF            	MOV	byte [CreatePDB],0FFh
  8696 0000107F 8E1E[3003]              	MOV	DS,[CurrentPDB]
  8697                                  
  8698 00001083 56                      	PUSH	SI
  8699 00001084 EB0A                    	JMP	SHORT CreateCopy
  8700                                  
  8701                                  ;
  8702                                  ;----------------------------------------------------------------------------
  8703                                  ;
  8704                                  ; Inputs:
  8705                                  ;	DX = Segment number of new base
  8706                                  ; Function:
  8707                                  ;	Set up program base and copy term and ^C from int area
  8708                                  ; Returns:
  8709                                  ;	None
  8710                                  ; Called at DOS init
  8711                                  ;
  8712                                  ;----------------------------------------------------------------------------
  8713                                  ;
  8714                                  
  8715                                  ; 15/05/2019 - Retro DOS v4.0
  8716                                  ; DOSCODE:4EB6h (MSDOS 6.21, MSDOS.SYS)
  8717                                  
  8718                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8719                                  ; DOSCODE:4EA2h (MSDOS 5.0, MSDOS.SYS)
  8720                                  
  8721                                  _$CREATE_PROCESS_DATA_BLOCK:
  8722                                  			; Offset 1D02h in IBMDOS.COM (MSDOS 3.3), 1987
  8723 00001086 E8F8F3                  	CALL	Get_User_Stack
  8724                                  	;mov	ds,[si+14h]
  8725 00001089 8E5C14                  	MOV	DS,[SI+user_env.user_CS]
  8726                                  	;push	word [2]
  8727 0000108C FF360200                	PUSH	word [PDB.BLOCK_LEN] ;*
  8728                                  CreateCopy:
  8729 00001090 8EC2                    	MOV	ES,DX
  8730                                  
  8731 00001092 31F6                    	XOR	SI,SI			; copy entire PDB
  8732 00001094 89F7                    	MOV	DI,SI
  8733 00001096 B98000                  	MOV	CX,128
  8734 00001099 F3A5                    	REP	MOVSW
  8735                                  
  8736                                  ; DOS 3.3 7/9/86
  8737                                  	;mov	cx,20
  8738                                  	;MOV	CX,FILPERPROC		; copy handles in case of
  8739                                  	; 15/12/2022
  8740 0000109B B114                    	mov	cl,FILPERPROC ; 06/07/2019
  8741                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8742                                  	;mov	cx,FILPERPROC
  8743                                  
  8744                                  	;mov	di,18h
  8745 0000109D BF1800                  	MOV	DI,PDB.JFN_TABLE	; Set Handle Count has been issued
  8746                                  	;;PUSH	DS ; * 15/05/2019
  8747                                  	;;lds	si,[34h]
  8748                                  	;LDS	SI,[PDB.JFN_Pointer]
  8749                                  	;REP	MOVSB
  8750                                  	;;POP	DS ; * 15/05/2019
  8751                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8752                                  	; 05/12/2022
  8753                                  	; (push ds then pop ds is not needed here!)
  8754                                  	;push	ds
  8755                                  	;lds	si,[34h]
  8756 000010A0 C5363400                	lds	si,[PDB.JFN_Pointer]
  8757 000010A4 F3A4                    	rep	movsb
  8758                                  	;pop	ds
  8759                                  
  8760                                  ; DOS 3.3 7/9/86
  8761                                  	;hkn ;CreatePDB would have a CS override. This is not valid.
  8762                                  	;hkn ;Must set up ds in order to access CreatePDB. Also SS is 
  8763                                  	;hkn ;has been assumed to be NOTHING. It may not have DOSDATA.
  8764                                  
  8765 000010A6 2E8E1E[0700]            	mov	ds,[cs:DosDSeg] ; 15/05/2019
  8766                                  
  8767                                  	;;test	byte [cs:CreatePDB],0FFh
  8768                                  	;cmp	byte [CS:CreatePDB],0	; Shall we create a process?
  8769                                  	; 17/12/2022
  8770 000010AB 380E[A803]              	cmp	[CreatePDB],cl ; 0
  8771                                  	;cmp	byte [CreatePDB],0 ; 15/05/2019
  8772 000010AF 744A                    	JZ	short Create_PDB_cont 	; nope, old style call
  8773                                  
  8774                                  ; Here we set up for a new process...
  8775                                  
  8776                                  	;PUSH	CS			; Called at DOSINIT time, NO SS
  8777                                  	;POP	DS
  8778                                  
  8779                                  	; MSDOS 6.0
  8780                                  	;;getdseg <ds>			; ds -> dosdata
  8781                                  	;mov	ds,[cs:DosDSeg] ; 15/05/2019
  8782                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8783                                  	; (nonsense! but i put this for addr compatibility as temporary)
  8784                                  	; 15/12/2022
  8785                                  	;mov	ds,[cs:DosDSeg] ; 15/05/2019
  8786                                  
  8787 000010B1 31DB                    	XOR	BX,BX			; dup all jfns
  8788                                  	;mov	cx,20
  8789                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8790                                  	;MOV	CX,FILPERPROC		; only 20 of them
  8791                                  	; 15/12/2022
  8792 000010B3 B114                    	mov	cl,FILPERPROC ; 06/07/2019
  8793                                  
  8794                                  Create_dup_jfn:
  8795 000010B5 06                      	PUSH	ES ;**			; save new PDB
  8796 000010B6 E80C54                  	call	SFFromHandle		; get sf pointer
  8797 000010B9 B0FF                    	MOV	AL,-1			; unassigned JFN
  8798 000010BB 7224                    	JC	short CreateStash	; file was not really open
  8799                                  	;;test	word [es:di+5],1000h
  8800                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_no_inherit
  8801                                  	; 15/05/2019
  8802                                  	;test	byte [es:di+6],10h
  8803 000010BD 26F6450610              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_no_inherit>>8)
  8804 000010C2 751D                    	JNZ	short CreateStash	; if no-inherit bit is set, skip dup.
  8805                                  
  8806                                  ; We do not inherit network file handles.
  8807                                  
  8808                                  	;mov	ah,[es:di+2]
  8809 000010C4 268A6502                	MOV	AH,[ES:DI+SF_ENTRY.sf_mode]
  8810                                  	;and	ah,0F0h
  8811 000010C8 80E4F0                  	AND	AH,SHARING_MASK
  8812                                  	;cmp	ah,70h
  8813 000010CB 80FC70                  	CMP	AH,SHARING_NET_FCB
  8814 000010CE 7411                    	jz	short CreateStash
  8815                                  
  8816                                  ; The handle we have found is duplicatable (and inheritable). Perform
  8817                                  ; duplication operation.
  8818                                  
  8819 000010D0 893E[9E05]              	MOV	[THISSFT],DI
  8820 000010D4 8C06[A005]              	MOV	[THISSFT+2],ES
  8821 000010D8 E89F18                  	call	DOS_DUP 		; signal duplication
  8822                                  
  8823                                  ; get the old sfn for copy
  8824                                  
  8825 000010DB E8CA53                  	call	pJFNFromHandle		; ES:DI is jfn
  8826 000010DE 268A05                  	MOV	AL,[ES:DI]		; get sfn
  8827                                  
  8828                                  ; Take AL (old sfn or -1) and stash it into the new position
  8829                                  
  8830                                  CreateStash:
  8831 000010E1 07                      	POP	ES ;**
  8832                                  	;mov	[es:bx+18h],al
  8833 000010E2 26884718                	MOV	[ES:BX+PDB.JFN_TABLE],AL ; copy into new place!
  8834 000010E6 43                      	INC	BX			; next jfn...
  8835 000010E7 E2CC                    	LOOP	Create_dup_jfn
  8836                                  
  8837 000010E9 8B1E[3003]              	MOV	BX,[CurrentPDB]		; get current process
  8838                                  	; 06/11/2022
  8839                                  	;mov	[es:16h],bx
  8840 000010ED 26891E1600              	MOV	[ES:PDB.PARENT_PID],BX	; stash in child
  8841 000010F2 8C06[3003]              	MOV	[CurrentPDB],ES
  8842                                  	;MOV	DS,BX ; 28/07/2019
  8843                                  	; 07/12/2022
  8844                                  	;mov	ds,[cs:DosDSeg]
  8845                                  	; 15/12/2022
  8846                                  	; ds = [cs:DosDSeg]
  8847 000010F6 C606[A803]00            	mov	byte [CreatePDB],0	; reset flag
  8848                                  	;mov	ds,bx
  8849                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8850                                  	; 15/12/2022
  8851                                  	;mov	ds,bx
  8852                                  
  8853                                  ; end of new process create
  8854                                  
  8855                                  Create_PDB_cont:
  8856                                  	;MOV	BYTE [CS:CreatePDB],0	; reset flag
  8857                                  
  8858                                  ;hkn; It comes to this point from 2 places. So, change to DOSDATA temporarily	
  8859                                  
  8860                                  	;; 28/07/2019
  8861                                  	;;push	ds
  8862                                  	;;mov	ds,[cs:DosDSeg]
  8863                                  	;mov	byte [CreatePDB],0
  8864                                  	;;pop	ds
  8865                                  
  8866                                  ; 05/12/2022
  8867                                  ;	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8868                                  ;	; (push-pop ds is nonsense here! 
  8869                                  ;	;  but i am using same code with original MSDOS.SYS
  8870                                  ;	;  for address compatibility.)
  8871                                  ;	push	ds
  8872                                  ;	; ds = [cs:DosDSeg] !
  8873                                  ;	mov	ds,[cs:DosDSeg]  ; again !
  8874                                  ;	mov	byte [CreatePDB],0
  8875                                  ;	pop	ds
  8876                                  
  8877 000010FB 58                      	POP	AX ;*
  8878                                  
  8879                                  	;entry	SETMEM
  8880                                  
  8881                                  	; 17/12/2022
  8882                                  	; cx = 0
  8883                                  
  8884                                  ;---------------------------------------------------------------------------
  8885                                  ; Inputs:
  8886                                  ;	AX = Size of memory in paragraphs
  8887                                  ;	DX = Segment
  8888                                  ; Function:
  8889                                  ;	Completely prepares a program base at the
  8890                                  ;	specified segment.
  8891                                  ; Called at DOS init
  8892                                  ; Outputs:
  8893                                  ;	DS = DX
  8894                                  ;	ES = DX
  8895                                  ;	[0] has INT int_abort
  8896                                  ;	[2] = First unavailable segment
  8897                                  ;	[5] to [9] form a long call to the entry point
  8898                                  ;	[10] to [13] have exit address (from int_terminate)
  8899                                  ;	[14] to [17] have ctrl-C exit address (from int_ctrl_c)
  8900                                  ;	[18] to [21] have fatal error address (from int_fatal_abort)
  8901                                  ; DX,BP unchanged. All other registers destroyed.
  8902                                  ;---------------------------------------------------------------------------
  8903                                  
  8904                                  SETMEM:
  8905                                  	;XOR	CX,CX
  8906                                  	; 17/12/2022
  8907                                  	; cx = 0
  8908 000010FC 8ED9                    	MOV	DS,CX
  8909 000010FE 8EC2                    	MOV	ES,DX
  8910                                  	;mov	si,88h
  8911 00001100 BE8800                  	MOV	SI,addr_int_terminate
  8912                                  	;mov	di,10 ; 0Ah
  8913 00001103 BF0A00                  	MOV	DI,SAVEXIT
  8914                                  	;MOV	CX,6
  8915                                  	; 15/12/2022
  8916 00001106 B106                    	mov	cl,6
  8917 00001108 F3A5                    	REP	MOVSW
  8918 0000110A 26A30200                	MOV	[ES:2],AX
  8919 0000110E 29D0                    	SUB	AX,DX
  8920 00001110 3DFF0F                  	CMP	AX,MAXDIF ; 0FFFh
  8921 00001113 7603                    	JBE	short HAVDIF
  8922 00001115 B8FF0F                  	MOV	AX,MAXDIF
  8923                                  HAVDIF:
  8924 00001118 83E810                  	SUB	AX,10h			; Allow for 100h byte "stack"
  8925 0000111B BB0C00                  	MOV	BX,ENTRYPOINTSEG ; 0Ch	;	in .COM files
  8926 0000111E 29C3                    	SUB	BX,AX
  8927 00001120 B104                    	MOV	CL,4
  8928 00001122 D3E0                    	SHL	AX,CL
  8929 00001124 8EDA                    	MOV	DS,DX
  8930                                  
  8931                                  	; (MSDOS 6.0 note)
  8932                                  	;
  8933                                  	; The address in BX:AX will be F01D:FEF0 if there is 64K or more 
  8934                                  	; memory in the system. This is equivalent to 0:c0 if A20 is OFF.
  8935                                  	; If DOS is in HMA this equivalence is no longer valid as A20 is ON.
  8936                                  	; But the BIOS which now resides in FFFF:30 has 5 bytes in FFFF:D0
  8937                                  	; (F01D:FEF0) which is the same as the ones in 0:C0, thereby 
  8938                                  	; making this equvalence valid for this particular case. If however
  8939                                  	; there is less than 64K remaining the address in BX:AX will not 
  8940                                  	; be the same as above. We will then stuff 0:c0, the call 5 address
  8941                                  	; into the PSP.
  8942                                  	;
  8943                                  	; Therefore for the case where there is less than 64K remaining in 
  8944                                  	; the system old CPM Apps that look at PSP:6 to determine memory
  8945                                  	; requirements will not work. Call 5, however will continue to work
  8946                                  	; for all cases.
  8947                                  	;
  8948                                  
  8949                                  	;mov	[6],ax
  8950                                  	;mov	[8],bx
  8951                                  
  8952 00001126 A30600                  	MOV	[PDB.CPM_CALL+1],AX
  8953 00001129 891E0800                	MOV	[PDB.CPM_CALL+3],BX
  8954                                  
  8955                                  	; 06/05/2019 - Retro DOS v4.0
  8956 0000112D 3DF0FE                  	cmp	ax,WRAPOFFSET ; 0FEF0h	; Q: does the system have >= 64k of
  8957                                  					;    memory left
  8958 00001130 740C                    	je	short addr_ok		; Y: the above calculated address is
  8959                                  					;    OK
  8960                                  					; N: 
  8961                                  
  8962 00001132 C7060600C000            	MOV	WORD [PDB.CPM_CALL+1],0C0h
  8963 00001138 C70608000000            	MOV	WORD [PDB.CPM_CALL+3],0
  8964                                  addr_ok:
  8965                                  	;mov	word [0],20CDh
  8966 0000113E C7060000CD20            	MOV	word [PDB.EXIT_CALL],(int_abort*256) + mi_INT
  8967                                  	;mov	byte [5],9Ah
  8968 00001144 C60605009A              	MOV	BYTE [PDB.CPM_CALL],mi_Long_CALL
  8969                                  	;mov	word [50h],21CDh
  8970 00001149 C7065000CD21            	MOV	WORD [PDB.CALL_SYSTEM],(int_command*256) + mi_INT
  8971                                  	;mov	byte [52h],0CBh
  8972 0000114F C6065200CB              	MOV	BYTE [PDB.CALL_SYSTEM+2],mi_Long_RET
  8973                                  	;mov	word [34h],18h
  8974 00001154 C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE
  8975                                  	;mov	word [36h],ds
  8976 0000115A 8C1E3600                	MOV	WORD [PDB.JFN_Pointer+2],DS
  8977                                  	;mov	word [32h],20
  8978 0000115E C70632001400            	MOV	WORD [PDB.JFN_Length],FILPERPROC
  8979                                  ;
  8980                                  ; The server runs several PDB's without creating them VIA EXEC.  We need to
  8981                                  ; enumerate all PDB's at CPS time in order to find all references to a
  8982                                  ; particular SFT.  We perform this by requiring that the server link together
  8983                                  ; for us all sub-PDB's that he creates. The requirement for us, now, is to
  8984                                  ; initialize this pointer.
  8985                                  ;
  8986                                   	;mov	word [38h],-1
  8987 00001164 C7063800FFFF            	MOV	word [PDB.Next_PDB],-1
  8988                                  	;mov	word [3Ah],-1
  8989 0000116A C7063A00FFFF            	MOV	word [PDB.Next_PDB+2],-1
  8990                                  
  8991                                  	; 06/05/2019
  8992                                  	; Set the real version number in the PSP - 5.00
  8993                                  
  8994                                  	;mov	word [es:PDB.Version],1406h ; MSDOS 6.21 (DOSCODE:4FB6h)
  8995                                  	; 07/12/2022
  8996 00001170 26C70640000616          	mov	word [ES:PDB.Version],(MINOR_VERSION*256)+MAJOR_VERSION
  8997                                  
  8998 00001177 C3                      	retn
  8999                                  
  9000                                  ; 29/04/2019 - Retro DOS v4.0
  9001                                  
  9002                                  ;BREAK <$GSetMediaID -- get set media ID>
  9003                                  
  9004                                  ;---------------------------------------------------------------------------
  9005                                  ; Inputs:
  9006                                  ;	BL= drive number as defined in IOCTL
  9007                                  ;	AL= 0 get media ID
  9008                                  ;	    1 set media ID
  9009                                  ;	DS:DX= buffer containing information
  9010                                  ;		DW  0  info level (set on input)
  9011                                  ;		DD  ?  serial #
  9012                                  ;		DB  11 dup(?)  volume id
  9013                                  ;		DB   8 dup(?)  file system type
  9014                                  ; Function:
  9015                                  ;	Get or set media ID
  9016                                  ; Returns:
  9017                                  ;	carry clear, DS:DX is filled
  9018                                  ;	carry set, error
  9019                                  ;---------------------------------------------------------------------------
  9020                                  
  9021                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  9022                                  _$GSetMediaID:
  9023                                  	; RAWIO - GET_MEDIA_ID
  9024 00001178 B96608                  	mov	cx,0866h	      ;AN000;MS.; assume get  for IOCTL
  9025 0000117B 3C00                    	cmp	al,0		      ;AN001;MS.; get ?
  9026 0000117D 7406                    	je	short doioctl 	      ;AN000;MS.; yes
  9027                                  	;cmp	al,1		      ;AN000;MS.; set ?
  9028                                  	;jne	short errorfunc	      ;AN000;MS.; no
  9029                                  	; 15/12/2022
  9030 0000117F FEC8                    	dec	al
  9031 00001181 7507                    	jnz	short errorfunc ; al > 1
  9032                                  	; RAWIO - SET_MEDIA_ID
  9033                                  	;mov	cx,0846h	      ;AN001;MS.;
  9034                                  	; 15/12/2022
  9035 00001183 B146                    	mov	cl,46h	; cx = 0846h 
  9036                                  doioctl:			      ;AN000;
  9037 00001185 B00D                    	mov	al,0Dh		      ;AN000;MS.; generic IOCTL
  9038                                  	;invoke	$IOCTL		      ;AN000;MS.; let IOCTL take care of it
  9039                                  	;call	_$IOCTL
  9040                                  	;retn			      ;AN000;MS.;
  9041                                  	; 15/12/2022
  9042 00001187 E97910                  	jmp	_$IOCTL
  9043                                  errorfunc:			      ;AN000;
  9044                                  	;error	error_invalid_function;AN000;MS. ; invalid function
  9045                                  	;mov	al,1
  9046 0000118A B001                    	mov	al,error_invalid_function
  9047 0000118C E9ABF4                  	jmp	SYS_RET_ERR
  9048                                  
  9049                                  ; 16/05/2019 - Retro DOS v4.0
  9050                                  
  9051                                  ;============================================================================
  9052                                  ; MISC2.ASM, MSDOS 6.0, 1991
  9053                                  ;============================================================================
  9054                                  ; 20/07/2018 - Retro DOS v3.0
  9055                                  ; 29/04/2019 - Retro DOS v4.0
  9056                                  
  9057                                  ; Break <STRCMP - compare two ASCIZ strings DS:SI to ES:DI>
  9058                                  ;----------------------------------------------------------------------------
  9059                                  ;
  9060                                  ;   Strcmp - compare ASCIZ DS:SI to ES:DI. Case INSENSITIVE. '/' = '\'
  9061                                  ;	     Strings of different lengths don't match.
  9062                                  ;   Inputs:  DS:SI - pointer to source string  ES:DI - pointer to dest string
  9063                                  ;   Outputs: Z if strings same, NZ if different
  9064                                  ;   Registers modified: NONE
  9065                                  ;----------------------------------------------------------------------------
  9066                                  
  9067                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  9068                                  StrCmp:
  9069 0000118F 56                      	push	si
  9070 00001190 57                      	push	di
  9071 00001191 50                      	push	ax
  9072                                  Cmplp:
  9073 00001192 AC                      	LODSB
  9074 00001193 E8273D                  	call	UCase			; convert to upper case
  9075 00001196 E8793D                  	call	PATHCHRCMP		; convert '/' to '\' ; 07/12/2022 ('\')
  9076 00001199 88C4                    	MOV	AH,AL
  9077 0000119B 268A05                  	MOV	AL,[ES:DI]
  9078 0000119E 47                      	INC	DI
  9079 0000119F E81B3D                  	call	UCase			; convert to upper case
  9080 000011A2 E86D3D                  	call	PATHCHRCMP		; convert '/' to '\' ; 07/12/2022 ('\')
  9081 000011A5 38C4                    	CMP	AH,AL
  9082 000011A7 7504                    	JNZ	short PopRet		; Strings dif
  9083                                  
  9084 000011A9 08C0                    	OR	AL,AL
  9085 000011AB 75E5                    	JNZ	short Cmplp		; More string
  9086                                  PopRet:
  9087 000011AD 58                      	pop	ax
  9088 000011AE 5F                      	pop	di
  9089 000011AF 5E                      	pop	si
  9090 000011B0 C3                      	retn
  9091                                  
  9092                                  ;Break <STRCPY - copy ASCIZ string from DS:SI to ES:DI>
  9093                                  ;----------------------------------------------------------------------------
  9094                                  ;
  9095                                  ;   Strcpy - copy an ASCIZ string from DS:SI to ES:DI and make uppercase
  9096                                  ;   FStrcpy - copy an ASCIZ string from DS:SI to ES:DI. no modification of
  9097                                  ;	characters.
  9098                                  ;
  9099                                  ;   Inputs:	DS:SI - pointer to source string
  9100                                  ;		ES:DI - pointer to destination string
  9101                                  ;   Outputs:	ES:DI point byte after nul byte at end of dest string
  9102                                  ;		DS:SI point byte after nul byte at end of source string
  9103                                  ;   Registers modified: SI,DI
  9104                                  ;----------------------------------------------------------------------------
  9105                                  
  9106                                  StrCpy:
  9107 000011B1 50                      	push	ax
  9108                                  CPYLoop:
  9109 000011B2 AC                      	LODSB
  9110 000011B3 E8073D                  	call	UCase			; convert to upper case
  9111 000011B6 E8593D                  	call	PATHCHRCMP		; convert / to \ ;
  9112 000011B9 AA                      	STOSB
  9113                                  
  9114 000011BA 08C0                    	OR	AL,AL
  9115 000011BC 75F4                    	JNZ	short CPYLoop
  9116 000011BE 58                      	pop	ax
  9117 000011BF C3                      	retn
  9118                                  
  9119                                  ;----------------------------------------------------------------------------
  9120                                  ; Procedure Name : FStrCpy
  9121                                  ;----------------------------------------------------------------------------
  9122                                  
  9123                                  FStrCpy:
  9124 000011C0 50                      	push	ax
  9125                                  FCPYLoop:
  9126 000011C1 AC                      	LODSB
  9127 000011C2 AA                      	STOSB
  9128 000011C3 08C0                    	OR	AL,AL
  9129 000011C5 75FA                    	JNZ	short FCPYLoop
  9130 000011C7 58                      	pop	ax
  9131 000011C8 C3                      	retn
  9132                                  
  9133                                  ; 20/07/2018 - Retro DOS v3.0
  9134                                  ;----------------------------------------------------------------------------
  9135                                  ; UCase, IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1E2Fh
  9136                                  ;----------------------------------------------------------------------------
  9137                                  ;
  9138                                  ;UCase:	
  9139                                  ;	call	_UCase	 ; Offset 5518h (GetLet, Offset 5517h)
  9140                                  ;	retn
  9141                                  
  9142                                  ;Break <StrLen - compute length of string ES:DI>
  9143                                  ;----------------------------------------------------------------------------
  9144                                  ;**	StrLen - Compute Length of String
  9145                                  ;
  9146                                  ;	StrLen computes the length of a string, including the trailing 00
  9147                                  ;
  9148                                  ;	ENTRY	(es:di) = address of string
  9149                                  ;	EXIT	(cx) = size of string
  9150                                  ;	USES	cx, flags
  9151                                  ;----------------------------------------------------------------------------
  9152                                  
  9153                                  StrLen:
  9154 000011C9 57                      	push	di
  9155 000011CA 50                      	push	ax
  9156                                  	;MOV	CX,-1
  9157 000011CB B9FFFF                  	mov	cx,65535
  9158 000011CE 30C0                    	XOR	AL,AL
  9159 000011D0 F2AE                    	REPNE	SCASB
  9160 000011D2 F7D1                    	NOT	CX
  9161 000011D4 58                      	pop	ax
  9162 000011D5 5F                      	pop	di
  9163 000011D6 C3                      	retn
  9164                                  
  9165                                  ;----------------------------------------------------------------------------
  9166                                  ;**	DStrLen - Compute Length of String
  9167                                  ;
  9168                                  ;	ENTRY	(ds:si) = address of string
  9169                                  ;	EXIT	(cx) = size of string, including trailing NUL
  9170                                  ;	USES	cx, flags
  9171                                  ;----------------------------------------------------------------------------
  9172                                  
  9173                                  DStrLen:	; BUGBUG - this guy is a pig, who uses him?
  9174 000011D7 E80300                  	CALL	XCHGP
  9175 000011DA E8ECFF                  	CALL	StrLen
  9176                                  	;CALL	XCHGP
  9177                                  	;retn
  9178                                  	; 18/12/2022
  9179                                  	;jmp	short XCHGP
  9180                                  
  9181                                  ;----------------------------------------------------------------------------
  9182                                  ;**	XCHGP - Exchange Source and Destination Pointers
  9183                                  ;
  9184                                  ;	XCHGP exchanges (DS:SI) and (ES:DI)
  9185                                  ;
  9186                                  ;	ENTRY	none
  9187                                  ;	EXIT	pairs exchanged
  9188                                  ;	USES	SI, DI, DS, ES
  9189                                  ;----------------------------------------------------------------------------
  9190                                  
  9191                                  XCHGP:
  9192 000011DD 1E                      	push	ds
  9193 000011DE 06                      	push	es
  9194 000011DF 1F                      	pop	ds
  9195 000011E0 07                      	pop	es
  9196 000011E1 87F7                    	XCHG	SI,DI
  9197                                  xchgp_retn:
  9198 000011E3 C3                      	retn
  9199                                  
  9200                                  ;Break	<Idle - wait for a specified amount of time>
  9201                                  ;----------------------------------------------------------------------------
  9202                                  ;
  9203                                  ;   Idle - when retrying an operation due to a lock/sharing violation,
  9204                                  ;   	   we spin until RetryLoop is exhausted.
  9205                                  ;
  9206                                  ;   Inputs:	RetryLoop is the number of times we spin
  9207                                  ;   Outputs:	Wait
  9208                                  ;   Registers modified: none
  9209                                  ;----------------------------------------------------------------------------
  9210                                  
  9211                                  Idle:
  9212                                  	;test	byte [SS:FSHARING],0FFh
  9213 000011E4 36803E[7205]00          	cmp	byte [SS:FSHARING],0	;hkn; SS override
  9214                                  	;retnz
  9215 000011EA 75F7                    	jnz	short xchgp_retn
  9216                                  	;SAVE	<CX>
  9217 000011EC 51                      	push	cx
  9218 000011ED 368B0E[1C00]            	MOV	CX,[ss:RetryLoop]	;hkn; SS override
  9219 000011F2 E308                    	JCXZ	Idle3
  9220                                  Idle1:	
  9221 000011F4 51                      	PUSH	CX
  9222 000011F5 31C9                    	XOR	CX,CX
  9223                                  Idle2:	
  9224 000011F7 E2FE                    	LOOP	Idle2
  9225 000011F9 59                      	POP	CX
  9226 000011FA E2F8                    	LOOP	Idle1
  9227                                  Idle3:	
  9228                                  	;RESTORE <CX>
  9229 000011FC 59                      	pop	cx
  9230 000011FD C3                      	retn
  9231                                  
  9232                                  ;Break	<TableDispatch - dispatch to a table>
  9233                                  ;----------------------------------------------------------------------------
  9234                                  ;
  9235                                  ;   TableDispatch - given a table and an index, jmp to the approptiate
  9236                                  ;   routine. Preserve all input registers to the routine.
  9237                                  ;
  9238                                  ;   Inputs:	Push	return address
  9239                                  ;		Push	Table address
  9240                                  ;		Push	index (byte)
  9241                                  ;   Outputs:	appropriate routine gets jumped to.
  9242                                  ;		return indicates invalid index
  9243                                  ;   Registers modified: none.
  9244                                  ;----------------------------------------------------------------------------
  9245                                  
  9246                                  struc TFrame	 ; TableFrame
  9247 00000000 ????                    .OldBP:	 resw 1  ; 0
  9248 00000002 ????                    .OldRet: resw 1  ; 2
  9249 00000004 ??                      .Index:	 resb 1  ; 4
  9250 00000005 ??                      .Pad:	 resb 1  ; 5  
  9251 00000006 ????                    .Tab:	 resw 1  ; 6
  9252 00000008 ????                    .NewRet: resw 1  ; 8
  9253                                  endstruc
  9254                                  
  9255                                  TableDispatch:
  9256 000011FE 55                      	PUSH	BP
  9257 000011FF 89E5                    	MOV	BP,SP
  9258 00001201 53                      	PUSH	BX			; save BX
  9259                                  	;mov	bx,[bp+6]
  9260 00001202 8B5E06                  	MOV	BX,[BP+TFrame.Tab]	; get pointer to table
  9261 00001205 2E8A1F                  	MOV	BL,[CS:BX]		; maximum index
  9262                                  	;cmp	[bp+4],bl
  9263 00001208 385E04                  	CMP	[BP+TFrame.Index],BL	; table error?
  9264 0000120B 7317                    	JAE	short TableError	; yes
  9265                                  	;mov	bl,[bp+4]
  9266 0000120D 8A5E04                  	MOV	BL,[BP+TFrame.Index]	; get desired table index
  9267 00001210 30FF                    	XOR	BH,BH			; convert to word
  9268 00001212 D1E3                    	SHL	BX,1			; convert to word pointer
  9269 00001214 43                      	INC	BX			; point past first length byte
  9270                                  	; 17/08/2018
  9271                                  	;add	bx,[bp+6]
  9272 00001215 035E06                  	ADD	BX,[BP+TFrame.Tab]	; get real offset
  9273 00001218 2E8B1F                  	MOV	BX,[CS:BX]		; get contents of table entry
  9274                                  	;mov	[bp+6],bx
  9275 0000121B 895E06                  	MOV	[BP+TFrame.Tab],BX	; put table entry into return address
  9276 0000121E 5B                      	POP	BX			; restore BX
  9277 0000121F 5D                      	POP	BP			; restore BP
  9278 00001220 83C404                  	ADD	SP,4			; clean off Index and our return addr
  9279 00001223 C3                      	retn				; do operation
  9280                                  TableError:
  9281 00001224 5B                      	POP	BX			; restore BX
  9282 00001225 5D                      	POP	BP			; restore BP
  9283 00001226 C20600                  	RETN	6			; clean off Index, Table and RetAddr
  9284                                  
  9285                                  ;Break	<TestNet - determine if a CDS is for the network>
  9286                                  ;----------------------------------------------------------------------------
  9287                                  ;
  9288                                  ;   TestNet - examine CDS pointed to by ThisCDS and see if it indicates a
  9289                                  ;	network CDS. This will handle NULL cds also.
  9290                                  ;
  9291                                  ;   Inputs:	ThisCDS points to CDS or NULL
  9292                                  ;   Outputs:	ES:DI = ThisCDS
  9293                                  ;		carry Set => network
  9294                                  ;		carry Clear => local
  9295                                  ;   Registers modified: none.
  9296                                  ;----------------------------------------------------------------------------
  9297                                  
  9298                                  TestNet:
  9299                                  	;LES	DI,[CS:THISCDS]
  9300                                  
  9301                                  	; 16/05/2019 - Retro DOS v4.0
  9302 00001229 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  9303 0000122E 26C43E[A205]            	LES	DI,[ES:THISCDS]
  9304 00001233 83FFFF                  	CMP	DI,-1
  9305 00001236 7408                    	JZ	short CMCRet		; UNC? carry is clear
  9306                                  	;;test	word [es:di+43h],8000h
  9307                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
  9308                                  	;test	byte [es:di+44h],80h
  9309 00001238 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
  9310 0000123D 7501                    	JNZ	short CMCRet		; jump has carry clear
  9311 0000123F C3                      	retn				; carry is clear
  9312                                  CMCRet: 
  9313 00001240 F5                      	CMC
  9314 00001241 C3                      	retn
  9315                                  
  9316                                  ;Break	<IsSFTNet - see if an sft is for the network>
  9317                                  ;----------------------------------------------------------------------------
  9318                                  ;
  9319                                  ;   IsSFTNet - examine SF pointed to by ES:DI and see if it indicates a
  9320                                  ;	network file.
  9321                                  ;
  9322                                  ;   Inputs:	ES:DI point to SFT
  9323                                  ;   Outputs:	Zero set if not network sft
  9324                                  ;		zero reset otherwise
  9325                                  ;		Carry CLEAR!!!
  9326                                  ;   Registers modified: none.
  9327                                  ;----------------------------------------------------------------------------
  9328                                  
  9329                                  IsSFTNet:
  9330                                  	;;test	word [es:di+5],8000h
  9331                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
  9332                                  	; 16/05/2019 
  9333                                  	;test	byte [es:di+6],80h
  9334 00001242 26F6450680              	TEST	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
  9335 00001247 C3                      	retn
  9336                                  
  9337                                  ;Break	<FastInit - Initialize FastTable entries >
  9338                                  ;----------------------------------------------------------------------------
  9339                                  ;   DOS 4.00   2/9/87
  9340                                  ;   FastInit  - initialize the FASTXXX routine entry
  9341                                  ;		  in the FastTable
  9342                                  ;
  9343                                  ;   Inputs:	BX = FASTXXX ID ( 1=fastopen )
  9344                                  ;		DS:SI = address of FASTXXX routine entry
  9345                                  ;		   SI = -1 for query only
  9346                                  ;   Outputs:	Carry flag clear, if success
  9347                                  ;		Carry flag set,   if failure
  9348                                  ;
  9349                                  ;
  9350                                  ;----------------------------------------------------------------------------
  9351                                  
  9352                                  ;Procedure FastInit,NEAR
  9353                                  ;	ASSUME	CS:DOSCODE,SS:NOTHING
  9354                                  
  9355                                  ;	; MSDOS 3.3
  9356                                  ;	; IBMDOS.COM (1987) - Offset 1EB3h
  9357                                  ;FastInit:
  9358                                  ;	mov	di,FastTable ; FastOpenTable
  9359                                  ;	mov	ax,[cs:di+4]		; Entry segment
  9360                                  ;	mov	bx,cs			; get DOS segment
  9361                                  ;	cmp	ax,bx			; first time installed ?	
  9362                                  ;	je	short ok_install	; yes
  9363                                  ;	stc				; set carry
  9364                                  ;	retn				; (cf=1 means) already installed !
  9365                                  ;
  9366                                  ;ok_install:
  9367                                  ;	mov	bx,FastTable ; FastOpenTable
  9368                                  ;	mov	cx,ds
  9369                                  ;	; set address of FASTXXX (FASTOPEN) routine entry
  9370                                  ;	mov	[cs:bx+4],cx
  9371                                  ;	mov	[cs:bx+2],si
  9372                                  ;	retn
  9373                                  
  9374                                  ; 16/05/2019 - Retro DOS v4.0
  9375                                  
  9376                                  FastInit:
  9377                                  	; MSDOS 6.0
  9378                                  	;hkn; set up es to dosdataseg.
  9379 00001248 06                      	push	es
  9380                                  	;getdseg <es>			; es -> dosdata
  9381 00001249 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  9382                                  
  9383                                  	;hkn; FastTable is in DOSDATA
  9384 0000124E BF[320D]                	MOV	DI,FastTable+2		;AN000;FO. points to fastxxx entry
  9385 00001251 4B                      	DEC	BX			;AN000;FO.;; decrement index
  9386 00001252 89DA                    	MOV	DX,BX			;AN000;FO.;; save bx
  9387 00001254 D1E3                    	SHL	BX,1			;AN000;FO.;; times 4, each entry is DWORD
  9388 00001256 D1E3                    	SHL	BX,1			;AN000;FO.
  9389 00001258 01DF                    	ADD	DI,BX			;AN000;FO. index to the entry
  9390 0000125A 268B4502                	MOV	AX,[ES:DI+2]		;AN000;FO. get entry segment
  9391                                  fcheck: 				;AN000;
  9392 0000125E 8CC9                    	MOV	CX,CS			;AN000;FO.;; get DOS segment
  9393 00001260 39C8                    	CMP	AX,CX			;AN000;FO.;; first time installed ?
  9394 00001262 7405                    	JZ	short ok_install	;AN000;FO.;; yes
  9395 00001264 09C0                    	OR	AX,AX			;AN000;FO.;
  9396                                  	;JZ	short ok_install	;AN000;FO.;
  9397                                  	;STC				;AN000;FO.;; already installed !
  9398                                  	;JMP	SHORT FSret		;AN000;FO. set carry
  9399                                  	; 14/01/2024
  9400 00001266 F9                      	stc
  9401 00001267 7517                    	jnz	short FSret
  9402                                  ok_install:				;AN000;
  9403 00001269 83FEFF                  	CMP	SI,-1			;AN000;FO.; Query only ?
  9404 0000126C 7412                    	JZ	short FSret		;AN000;FO.; yes
  9405 0000126E 8CD9                    	MOV	CX,DS			;AN000;FO.; get FASTXXX entry segment
  9406 00001270 26894D02                	MOV	[ES:DI+2],CX		;AN000;FO.; initialize routine entry
  9407 00001274 268935                  	MOV	[ES:DI],SI		;AN000;FO.; initialize routine offset
  9408                                  
  9409                                  ;hkn; FastFlg moved to DOSDATA
  9410 00001277 BF[3A0D]                	MOV	DI,FastFlg		;AN000;FO.; get addr of FASTXXX flags
  9411 0000127A 01D7                    	ADD	DI,DX			;AN000;FO.; index to a FASTXXX flag
  9412                                  	;or	byte [es:di],80h
  9413 0000127C 26800D80                	OR	byte [ES:DI],Fast_yes	;AN000;FO.; indicate installed
  9414                                  FSret:					;AN000;
  9415 00001280 07                      	pop	es
  9416 00001281 C3                      	retn				;AN000;FO.
  9417                                  
  9418                                  ;EndProc FastInit
  9419                                  
  9420                                  ;Break	<FastRet - initial routine in FastOpenTable >
  9421                                  ;----------------------------------------------------------------------------
  9422                                  ;   DOS 3.3   6/10/86
  9423                                  ;   FastRet	- indicate FASTXXXX  not in memory
  9424                                  ;
  9425                                  ;   Inputs:	None
  9426                                  ;   Outputs:	AX = -1 and carry flag set
  9427                                  ;
  9428                                  ;   Registers modified: none.
  9429                                  ;----------------------------------------------------------------------------
  9430                                  
  9431                                  FastRet:
  9432                                  	;mov	ax,-1
  9433                                  	;stc
  9434                                  	;retf
  9435 00001282 F9                      	STC
  9436 00001283 19C0                    	sbb	ax,ax		; (ax) = -1, 'C' set
  9437 00001285 CB                      	RETF
  9438                                  
  9439                                  ;Break	<NLS_OPEN - do $open for NLSFUNC>
  9440                                  ;----------------------------------------------------------------------------
  9441                                  ;   DOS 3.3   6/10/86
  9442                                  ;   NLS_OPEN	- call $OPEN for NLSFUNC
  9443                                  ;
  9444                                  ;   Inputs:	Same input as $OPEN except CL = mode
  9445                                  ;   Outputs:	same output as $OPEN
  9446                                  ;
  9447                                  ;----------------------------------------------------------------------------
  9448                                  
  9449                                  ;hkn; NOTE! SS MUST HAVE BEEN SET UP TO DOSDATA BY THE TIME THESE
  9450                                  ;hkn; NLS FUNCTIONS ARE CALLED!!! THERE FORE WE WILL USE SS OVERRIDES
  9451                                  ;hkn; IN ORDER TO ACCESS DOS DATA VARIABLES!
  9452                                  
  9453                                  NLS_OPEN:
  9454                                  ;	MOV	BL,[CPSWFLAG]	 ; disable code page matching logic
  9455                                  ;	MOV	BYTE [CPSWFLAG],0
  9456                                  ;	PUSH	BX		 ; save current state
  9457                                  
  9458 00001286 88C8                    	MOV	AL,CL		 ; set up correct interface for $OPEN
  9459 00001288 E88B5A                  	call	_$OPEN
  9460                                  
  9461                                  ;	POP	BX		 ; restore current state
  9462                                  ;	MOV	[CPSWFLAG],BL
  9463                                  
  9464 0000128B C3                      	RETN
  9465                                  
  9466                                  ;Break	<NLS_LSEEK - do $LSEEK for NLSFUNC>
  9467                                  ;----------------------------------------------------------------------------
  9468                                  ;   DOS 3.3   6/10/86
  9469                                  ;   NLS_LSEEK	- call $LSEEK for NLSFUNC
  9470                                  ;
  9471                                  ;   Inputs:	BP = open mode
  9472                                  ;   Outputs:	same output as $LSEEK
  9473                                  ;
  9474                                  ;----------------------------------------------------------------------------
  9475                                  
  9476                                  ; 16/05/2019 - Retro DOS v4.0
  9477                                  
  9478                                  NLS_LSEEK:
  9479 0000128C 36FF36[8405]            	PUSH	word [SS:USER_SP] ; save user stack
  9480 00001291 36FF36[8605]            	PUSH	word [SS:USER_SS]
  9481 00001296 E81000                  	CALL	Fake_User_Stack
  9482 00001299 89E8                    	MOV	AX,BP		; set up correct interface for $LSEEK
  9483 0000129B E82B54                  	call	_$LSEEK
  9484                                  NLS_SEEK_RET:	; 26/06/2024
  9485 0000129E 368F06[8605]            	POP	word [SS:USER_SS] ; restore user stack
  9486 000012A3 368F06[8405]            	POP	word [SS:USER_SP]
  9487 000012A8 C3                      	RETN
  9488                                  
  9489                                  ;Break	<Fake_User_Stack - save user stack>
  9490                                  ;----------------------------------------------------------------------------
  9491                                  ;   DOS 3.3   6/10/86
  9492                                  ;   Fake_User_Stack - save user stack pointer
  9493                                  ;
  9494                                  ;----------------------------------------------------------------------------
  9495                                  
  9496                                  Fake_User_Stack:
  9497 000012A9 36A1[6A0D]              	MOV	AX,[SS:USER_SP_2F] ; replace with INT 2F stack
  9498 000012AD 36A3[8405]              	MOV	[SS:USER_SP],AX
  9499 000012B1 8CD0                    	MOV	AX,SS
  9500 000012B3 36A3[8605]              	MOV	[SS:USER_SS],AX
  9501 000012B7 C3                      	RETN
  9502                                  
  9503                                  ;Break	<GetDevList - get device header list pointer>
  9504                                  ;----------------------------------------------------------------------------
  9505                                  ;   DOS 3.3   7/25/86
  9506                                  ;   GetDevList - get device header list pointer
  9507                                  ;
  9508                                  ;   Output: AX:BX points to the device header list
  9509                                  ;----------------------------------------------------------------------------
  9510                                  
  9511                                  GetDevList:
  9512                                  	; 16/05/2019 - Retro DOS v4.0
  9513 000012B8 BE[280D]                	MOV	SI,SysInitTable
  9514 000012BB 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  9515 000012C0 C534                    	LDS	SI,[SI]
  9516                                  	;mov	ax,[si+34]  ; SSYSINITVARS offset 34 = [SI+SYSI.DEV]
  9517 000012C2 8B4422                  	MOV	AX,[SI+SYSI.DEV]
  9518                                  	;mov	bx,[si+36]  ; SSYSINITVARS offset 36 = [SI+SYSI.DEV+2]
  9519 000012C5 8B5C24                  	MOV	BX,[SI+SYSI.DEV+2]
  9520 000012C8 C3                      	RETN
  9521                                  
  9522                                  ;Break	<NLS_IOCTL - do $IOCTL for NLSFUNC>
  9523                                  ;----------------------------------------------------------------------------
  9524                                  ;   DOS 3.3   7/25/86
  9525                                  ;   NLS_IOCTL	- call $IOCTL for NLSFUNC
  9526                                  ;
  9527                                  ;   Inputs:	BP = function code 0CH
  9528                                  ;   Outputs:	same output as generic $IOCTL
  9529                                  ;
  9530                                  ;----------------------------------------------------------------------------
  9531                                  
  9532                                  NLS_IOCTL:
  9533                                  	; 16/05/2019 - Retro DOS v4.0
  9534 000012C9 36FF36[8405]            	PUSH	word [SS:USER_SP] ; save user stack
  9535 000012CE 36FF36[8605]            	PUSH	word [SS:USER_SS]
  9536 000012D3 E8D3FF                  	CALL	Fake_User_Stack
  9537 000012D6 89E8                    	MOV	AX,BP		; set up correct interface for $IOCTL
  9538 000012D8 E8280F                  	call	_$IOCTL
  9539                                  	;POP	word [SS:USER_SS] ; restore user stack
  9540                                  	;POP	word [SS:USER_SP]
  9541                                  	;RETN
  9542                                  	; 26/06/2024 (PCDOS 7.1 IBMDOS.COM)
  9543 000012DB EBC1                    	jmp	short NLS_SEEK_RET
  9544                                  
  9545                                  
  9546                                  ;Break	<NLS_GETEXT- get extended error for NLSFUNC>
  9547                                  ;----------------------------------------------------------------------------
  9548                                  ;   DOS 3.3   7/25/86
  9549                                  ;   NLS_GETEXT	-
  9550                                  ;
  9551                                  ;   Inputs:	none
  9552                                  ;   Outputs:	AX = extended error
  9553                                  ;
  9554                                  ;----------------------------------------------------------------------------
  9555                                  
  9556                                  NLS_GETEXT:
  9557                                  	; 16/05/2019 - Retro DOS v4.0
  9558 000012DD 36A1[2403]              	MOV	AX,[SS:EXTERR]	 ; return extended error
  9559                                  	; 23/09/2023
  9560                                  MSG_RETRIEVAL:
  9561 000012E1 C3                      	RETN
  9562                                  
  9563                                  ; 29/04/2019 - Retro DOS v4.0
  9564                                  
  9565                                  ;Break	<MSG_RETRIEVAL- get beginning addr of system and parser messages>
  9566                                  
  9567                                  ;----------------------------------------------------------------------------
  9568                                  ;   DOS 4.00
  9569                                  ;
  9570                                  ;   Inputs:	DL=0 get extended error message addr
  9571                                  ;		  =1 set extended error message addr
  9572                                  ;		  =2 get parser error message addr
  9573                                  ;		  =3 set parser error message addr
  9574                                  ;		  =4 get critical error message addr
  9575                                  ;		  =5 set critical error message addr
  9576                                  ;		  =6 get file system error message addr
  9577                                  ;		  =7 set file system error message addr
  9578                                  ;		  =8 get address for code reduction
  9579                                  ;		  =9 set address for code reduction
  9580                                  ;   Function:	get/set message address
  9581                                  ;   Outputs:	ES:DI points to addr when get
  9582                                  ;----------------------------------------------------------------------------
  9583                                  
  9584                                  ;Procedure MSG_RETRIEVAL,NEAR
  9585                                  ;	ASSUME	CS:DOSCODE,SS:NOTHING
  9586                                  
  9587                                  ; 23/09/2023
  9588                                  ;MSG_RETRIEVAL:
  9589                                  
  9590                                  ;;	NOTE:  This function lives in command.com resident code now.
  9591                                  ;;	If the int 2F ever gets this far, we'll return registers
  9592                                  ;;	unchanged, which produces the same result as before, if
  9593                                  ;;	command.com wasn't present (and therefore no messages available).
  9594                                  ;;
  9595                                  ;;	I didn't point the entry in the 2F table to No_Op because
  9596                                  ;;	No_Op zeroes AL.
  9597                                  ;;
  9598                                  ;;;hkn; set up ds to point to DOSDATA
  9599                                  ;;	push	ds
  9600                                  ;;	getdseg	<ds>			; ds -> dosdata
  9601                                  ;;
  9602                                  ;;	PUSH	AX		    ;AN000;;MS. save regs
  9603                                  ;;	PUSH	SI		    ;AN000;;MS. save regs
  9604                                  ;;	MOV	AX,DX		    ;AN000;;MS.
  9605                                  ;;	MOV	SI,OFFSET DOSDATA:MSG_EXTERROR ;AN000;;MS.
  9606                                  ;;	test	AL,1		    ;AN000;;MS. get ?
  9607                                  ;;	JZ	toget		    ;AN000;;MS. yes
  9608                                  ;;	DEC	AL		    ;AN000;;MS.
  9609                                  ;;toget:				    ;AN000;
  9610                                  ;;	SHL	AL,1		    ;AN000;;MS. times 2
  9611                                  ;;	XOR	AH,AH		    ;AN000;;MS.
  9612                                  ;;	ADD	SI,AX		    ;AN000;;MS. position to the entry
  9613                                  ;;	test	DL,1		    ;AN000;;MS. get ?
  9614                                  ;;	JZ	getget			     ;AN000;;MS. yes
  9615                                  ;;	MOV	WORD PTR DS:[SI],DI    ;AN000;;MS. set MSG
  9616                                  ;;	MOV	WORD PTR DS:[SI+2],ES  ;AN000;;MS. address to ES:DI
  9617                                  ;;	JMP	SHORT MSGret		     ;AN000;;MS. exit
  9618                                  ;;getget: 				     ;AN000;
  9619                                  ;;	LES	DI,DWORD PTR DS:[SI]	     ;AN000;;MS. get msg addr
  9620                                  ;;MSGret: 				     ;AN000;
  9621                                  ;;	POP	SI			     ;AN000;;MS.
  9622                                  ;;	POP	AX			     ;AN000;;MS.
  9623                                  ;;
  9624                                  ;;	pop	ds
  9625                                  
  9626                                  ;	return				     ;AN000;;MS. exit
  9627                                  
  9628                                  ; 23/09/2023
  9629                                  ;	retn	; 29/04/2019
  9630                                  
  9631                                  ;============================================================================
  9632                                  ; ECritDisk, LCritDisk, ECritDevice, LCritDevice
  9633                                  ; IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1F36h
  9634                                  ;============================================================================
  9635                                  ; 20/07/2018 - Retro DOS v3.0
  9636                                  
  9637                                  ;	; MSDOS 3.3
  9638                                  ;	; 08/08/2018 - Retro DOS v3.0
  9639                                  ;ECritMEM:
  9640                                  ;ECritSFT:
  9641                                  ;	;
  9642                                  ;ECritDisk:
  9643                                  ;	retn
  9644                                  ;	;push	ax
  9645                                  ;	
  9646                                  ;	mov	ax,8001h
  9647                                  ;	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9648                                  ;			; AL = critical section number (00h-0Fh)
  9649                                  ;	pop	ax
  9650                                  ;	retn
  9651                                  ;
  9652                                  ;	; MSDOS 3.3
  9653                                  ;	; 08/08/2018 - Retro DOS v3.0
  9654                                  ;LCritMEM:
  9655                                  ;LCritSFT:
  9656                                  ;	;
  9657                                  ;LCritDisk:
  9658                                  ;	retn
  9659                                  ;	;push	ax
  9660                                  ;	
  9661                                  ;	mov	ax,8101h
  9662                                  ;	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9663                                  ;			; AL = critical section number (00h-0Fh)
  9664                                  ;	pop	ax
  9665                                  ;	retn
  9666                                  ;
  9667                                  ;ECritDevice:
  9668                                  ;	retn
  9669                                  ;	;push	ax
  9670                                  ;	
  9671                                  ;	mov	ax,8002h
  9672                                  ;	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9673                                  ;			; AL = critical section number (00h-0Fh)
  9674                                  ;	pop	ax
  9675                                  ;	retn
  9676                                  ;
  9677                                  ;LCritDevice:
  9678                                  ;	retn
  9679                                  ;	;push	ax
  9680                                  ;	
  9681                                  ;	mov	ax,8102h
  9682                                  ;	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9683                                  ;			; AL = critical section number (00h-0Fh)
  9684                                  ;	pop	ax
  9685                                  ;	retn
  9686                                  
  9687                                  ;============================================================================
  9688                                  ; CRIT.ASM, MSDOS 6.0, 1991
  9689                                  ;============================================================================
  9690                                  ; 12/05/2019 - Retro DOS v4.0
  9691                                  
  9692                                  ; Critical Section Routines
  9693                                  
  9694                                  ; MSDOS 6.21 - MSDOS.SYS - DOSCODE:513Ah
  9695                                  
  9696                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  9697                                  ; DOSCODE:5126h (MSDOS 5.0 MSDOS.SYS)
  9698                                  
  9699                                  ; ---------------------------------------------------------------------------
  9700                                  ; Each handler must leave everything untouched; including flags!
  9701                                  ;
  9702                                  ; Sleaze for time savings: first instruction is a return. This is patched
  9703                                  ; by the sharer to be a PUSH AX to complete the correct routines.
  9704                                  ; ---------------------------------------------------------------------------
  9705                                  
  9706                                  ; (DOSMAC.INC, MSDOS 6.0, 1991)
  9707                                  ; ---------------------------------------------------------------------------
  9708                                  ; Some old versions of the 80286 have a bug in the chip. The popf instruction
  9709                                  ; will enable interrupts. Therefore in a section of code with interrupts
  9710                                  ; disabled and you need a popf instruction use the 'popff' macro instead.
  9711                                  ; ---------------------------------------------------------------------------
  9712                                  
  9713                                  ;%macro POPFF 0
  9714                                  ;	jmp	$+3
  9715                                  ;	iret
  9716                                  ;	push	cs
  9717                                  ;	call	$-2
  9718                                  ;%endmacro
  9719                                  
  9720                                  ; ---------------------------
  9721                                  
  9722                                  ;Procedure  ECritDisk,NEAR
  9723                                  	;public  ECritMEM
  9724                                  	;public  ECritSFT
  9725                                  ECritMEM:
  9726                                  ECritSFT:
  9727                                  ;
  9728                                  ECritDisk:
  9729                                  
  9730                                  ;SR; Check if critical section is to be entered
  9731                                  
  9732 000012E2 9C                      	pushf
  9733 000012E3 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9734 000012E9 740D                    	jz	short ECritDisk_2
  9735                                  
  9736                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9737                                  ;	;popff  ; * (macro)
  9738                                  ;	jmp	short ECritDisk_1 ; *
  9739                                  ;
  9740                                  ;ECritDisk_iret: ; *
  9741                                  ;	iret ; *
  9742                                  
  9743                                  	; 16/12/2022
  9744                                  	; 13/11/2022
  9745                                  	;jmp	short ECritDisk_1
  9746                                  	; 06/11/2022
  9747                                  ;ECritDisk_iret:
  9748                                  ;	iret	
  9749                                  
  9750                                  	; 06/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9751                                  ECritDisk_1:
  9752 000012EB 0E                      	push	cs ; *
  9753 000012EC E80800                  	call	ECritDisk_iret ; *		
  9754                                  	
  9755                                  ECritDisk_0:
  9756 000012EF 50                      	PUSH    AX
  9757                                  	;MOV	AX,8000h+critDisk
  9758                                  	;INT	int_IBM
  9759 000012F0 B80180                  	mov	ax,8001h
  9760 000012F3 CD2A                    	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9761                                  			; AL = critical section number (00h-0Fh)
  9762 000012F5 58                      	POP     AX
  9763 000012F6 C3                      	retn
  9764                                  
  9765                                  	; 16/12/2022
  9766                                  	; 13/11/2022
  9767                                  ECritDisk_iret:  ; 12/05/2019 - Retro DOS v4.0
  9768                                  LCritDisk_iret: 
  9769 000012F7 CF                      	iret
  9770                                  
  9771                                  ECritDisk_2:
  9772                                  	;;popff ; *
  9773                                  	;;retn
  9774                                  ;	jmp	short ECritDisk_3 ; *
  9775                                  ;ECritDisk_iret2: ; *
  9776                                  ;	iret
  9777                                  	
  9778                                  	; 16/12/2022
  9779                                  	; 13/11/2022
  9780                                  	;jmp	short ECritDisk_3
  9781                                  ;ECritDisk_iret2:
  9782                                  	;iret
  9783                                  
  9784                                  ECritDisk_3:
  9785 000012F8 0E                      	push    cs ; *
  9786                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9787                                  	;call	ECritDisk_iret2 ; *
  9788                                  	;retn
  9789                                  	; 16/12/2022
  9790 000012F9 E8FBFF                  	call	ECritDisk_iret
  9791 000012FC C3                      	retn
  9792                                  
  9793                                  ;EndProc ECritDisk
  9794                                  
  9795                                  ; ---------------------------
  9796                                  
  9797                                  ;Procedure   LCritDisk,NEAR
  9798                                  	;public  LCritMEM
  9799                                  	;public  LCritSFT
  9800                                  LCritMEM:
  9801                                  LCritSFT:
  9802                                  ;
  9803                                  LCritDisk:
  9804                                  
  9805                                  ;SR; Check if critical section is to be entered
  9806                                  
  9807 000012FD 9C                      	pushf
  9808 000012FE 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9809 00001304 740C                    	jz	short LCritDisk_2
  9810                                  	;popff  ; * (macro)
  9811                                  ;	jmp	short LCritDisk_1 ; *
  9812                                  ;
  9813                                  ;LCritDisk_iret: ; *
  9814                                  ;	iret ; *
  9815                                  
  9816                                  	; 16/12/2022
  9817                                  	; 13/11/2022
  9818                                  	;jmp	short LCritDisk_1
  9819                                  ;LCritDisk_iret:
  9820                                  	;iret
  9821                                  
  9822                                  LCritDisk_1:
  9823 00001306 0E                      	push	cs ; *
  9824 00001307 E8EDFF                  	call	LCritDisk_iret ; *		
  9825                                  	
  9826                                  LCritDisk_0:
  9827 0000130A 50                      	PUSH	AX
  9828                                  	;MOV	AX,8100h+critDisk
  9829                                  	;INT	int_IBM
  9830 0000130B B80181                  	mov	ax,8101h
  9831 0000130E CD2A                    	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9832                                  			; AL = critical section number (00h-0Fh)
  9833 00001310 58                      	POP	AX
  9834 00001311 C3                      	retn
  9835                                  
  9836                                  ;LCritDisk_iret:  ; 12/05/2019 - Retro DOS v4.0 
  9837                                  ;	iret
  9838                                  
  9839                                  LCritDisk_2:
  9840                                  	;;popff ; *
  9841                                  	;;retn
  9842                                  ;	jmp	short LCritDisk_3 ; *
  9843                                  ;LCritDisk_iret2: ; *
  9844                                  ;	iret
  9845                                  
  9846                                  	; 16/12/2022
  9847                                  	; 13/11/2022
  9848                                  	;jmp	short LCritDisk_3
  9849                                  ;LCritDisk_iret2:
  9850                                  	;iret
  9851                                  
  9852                                  LCritDisk_3:
  9853 00001312 0E                      	push    cs ; *
  9854                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9855                                  	;call	LCritDisk_iret2 ; *
  9856                                  	;retn
  9857                                  	; 16/12/2022
  9858 00001313 E8E1FF                  	call	LCritDisk_iret
  9859 00001316 C3                      	retn
  9860                                  
  9861                                  ;EndProc LCritDisk
  9862                                  
  9863                                  ; ---------------------------
  9864                                  
  9865                                  ;Procedure   ECritDevice,NEAR
  9866                                  
  9867                                  ECritDevice:
  9868                                  
  9869                                  ;SR; Check if critical section is to be entered
  9870                                  
  9871 00001317 9C                      	pushf
  9872 00001318 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9873 0000131E 740D                    	jz	short ECritDevice_2
  9874                                  	;popff  ; * (macro)
  9875                                  ;	jmp	short ECritDevice_1 ; *
  9876                                  ;
  9877                                  ;ECritDevice_iret: ; *
  9878                                  ;	iret ; *
  9879                                  
  9880                                  	; 16/12/2022	
  9881                                  	; 13/11/2022
  9882                                  	;jmp	short ECritDevice_1
  9883                                  ;ECritDevice_iret:
  9884                                  	;iret
  9885                                  
  9886                                  ECritDevice_1:
  9887 00001320 0E                      	push	cs ; *
  9888 00001321 E80800                  	call	ECritDevice_iret ; *		
  9889                                  	
  9890                                  ECritDevice_0:
  9891 00001324 50                      	PUSH	AX
  9892                                  	;MOV	AX,8000h+critDevice
  9893                                  	;INT	int_IBM
  9894 00001325 B80280                  	mov	ax,8002h
  9895 00001328 CD2A                    	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9896                                  			; AL = critical section number (00h-0Fh)
  9897 0000132A 58                      	POP     AX
  9898 0000132B C3                      	retn
  9899                                  
  9900                                  	; 16/12/2022
  9901                                  	; 06/12/2022
  9902                                  ECritDevice_iret:  ; 12/05/2019 - Retro DOS v4.0
  9903                                  LCritDevice_iret: 
  9904 0000132C CF                      	iret
  9905                                  
  9906                                  ECritDevice_2:
  9907                                  	;;popff ; *
  9908                                  	;;retn
  9909                                  ;	jmp	short ECritDevice_3 ; *
  9910                                  ;ECritDevice_iret2: ; *
  9911                                  ;	iret
  9912                                  
  9913                                  	; 16/12/2022
  9914                                  	; 13/11/2022
  9915                                  	;jmp	short ECritDevice_3
  9916                                  ;ECritDevice_iret2:
  9917                                  	;iret
  9918                                  
  9919                                  ECritDevice_3:
  9920 0000132D 0E                      	push    cs ; *
  9921                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9922                                  	;call	ECritDevice_iret2 ; *
  9923                                  	;retn
  9924                                  	; 16/12/2022
  9925 0000132E E8FBFF                  	call	ECritDevice_iret
  9926 00001331 C3                      	retn
  9927                                  
  9928                                  ;EndProc ECritDevice
  9929                                  
  9930                                  ; ---------------------------
  9931                                  
  9932                                  ;Procedure   LCritDevice,NEAR
  9933                                  
  9934                                  LCritDevice:
  9935                                  
  9936                                  ;SR; Check if critical section is to be entered
  9937                                  
  9938 00001332 9C                      	pushf
  9939 00001333 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9940 00001339 740C                    	jz	short LCritDevice_2
  9941                                  	;popff  ; * (macro)
  9942                                  ;	jmp	short LCritDevice_1 ; *
  9943                                  ;
  9944                                  ;LCritDevice_iret: ; *
  9945                                  ;	iret ; *
  9946                                  
  9947                                  	; 16/12/2022
  9948                                  	; 13/11/2022
  9949                                  	;jmp	short LCritDevice_1
  9950                                  ;LCritDevice_iret:
  9951                                  	;iret
  9952                                  
  9953                                  LCritDevice_1:
  9954 0000133B 0E                      	push	cs ; *
  9955 0000133C E8EDFF                  	call	LCritDevice_iret ; *		
  9956                                  	
  9957                                  LCritDevice_0:
  9958 0000133F 50                      	PUSH	AX
  9959                                  	;MOV	AX,8100h+critDevice
  9960                                  	;INT	int_IBM
  9961 00001340 B80281                  	mov	ax,8102h
  9962 00001343 CD2A                    	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9963                                  			; AL = critical section number (00h-0Fh)
  9964 00001345 58                      	POP     AX
  9965 00001346 C3                      	retn
  9966                                  
  9967                                  ;LCritDevice_iret:  ; 12/05/2019 - Retro DOS v4.0 
  9968                                  ;	iret
  9969                                  
  9970                                  LCritDevice_2:
  9971                                  	;;popff ; *
  9972                                  	;;retn
  9973                                  ;	jmp	short LCritDevice_3 ; *
  9974                                  ;LCritDevice_iret2: ; *
  9975                                  ;	iret
  9976                                  
  9977                                  	; 16/12/2022
  9978                                  	; 13/11/2022
  9979                                  	;jmp	short LCritDevice_3
  9980                                  ;LCritDevice_iret2:
  9981                                  	;iret
  9982                                  
  9983                                  LCritDevice_3:
  9984 00001347 0E                      	push    cs ; *
  9985                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9986                                  	;call	LCritDevice_iret2 ; *
  9987                                  	;retn
  9988                                  	; 16/12/2022
  9989 00001348 E8E1FF                  	call	LCritDevice_iret
  9990 0000134B C3                      	retn
  9991                                  
  9992                                  ;EndProc LCritDevice
  9993                                  
  9994                                  ;============================================================================
  9995                                  ; CPMIO.ASM, MSDOS 6.0, 1991
  9996                                  ;============================================================================
  9997                                  ; 20/07/2018 - Retro DOS v3.0
  9998                                  
  9999                                  ;============================================================================
 10000                                  ; STDIO.ASM - (MSDOS 2.0)
 10001                                  ;============================================================================
 10002                                  
 10003                                  ;
 10004                                  ; Standard device IO for MSDOS (first 12 function calls)
 10005                                  ;
 10006                                  
 10007                                  ;.xlist
 10008                                  ;.xcref
 10009                                  ;INCLUDE STDSW.ASM
 10010                                  ;INCLUDE DOSSEG.ASM
 10011                                  ;.cref
 10012                                  ;.list
 10013                                  
 10014                                  ;TITLE   STDIO - device IO for MSDOS
 10015                                  ;NAME    STDIO
 10016                                  
 10017                                  ;INCLUDE IO.ASM
 10018                                  
 10019                                  ; ---------------------------------------------------------------------------
 10020                                  ;
 10021                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
 10022                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
 10023                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
 10024                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
 10025                                  ;			    to restore MSDOS 2.0 device IO source code 
 10026                                  ;
 10027                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)	
 10028                                  	
 10029                                  ;============================================================================
 10030                                  ; STDIO.ASM - (MSDOS 2.0)
 10031                                  ;============================================================================
 10032                                  
 10033                                  ;
 10034                                  ; Standard device IO for MSDOS (first 12 function calls)
 10035                                  ;
 10036                                  
 10037                                  ;.xlist
 10038                                  ;.xcref
 10039                                  ;INCLUDE STDSW.ASM
 10040                                  ;INCLUDE DOSSEG.ASM
 10041                                  ;.cref
 10042                                  ;.list
 10043                                  
 10044                                  ;TITLE   STDIO - device IO for MSDOS
 10045                                  ;NAME    STDIO
 10046                                  
 10047                                  ;INCLUDE IO.ASM
 10048                                  
 10049                                  ; ---------------------------------------------------------------------------
 10050                                  ;
 10051                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
 10052                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
 10053                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
 10054                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
 10055                                  ;			    to restore MSDOS 2.0 device IO source code 
 10056                                  ;
 10057                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)		
 10058                                  ;
 10059                                  ;============================================================================
 10060                                  ; IO.ASM (MSDOS 2.0) (IBMDOS.COM 2.0) - STRIN.ASM (MSDOS 2.0, 19/08/1983)
 10061                                  ;============================================================================
 10062                                  ; Retro DOS v2.0 by Erdogan Tan, 13/03/2018 - 14/03/2018
 10063                                  
 10064                                  ; (Disassembled code of IBMDOS.COM, 08/03/1983) - Dissassembler: IDA Pro Free
 10065                                  ; (Comments are from CPMIO.ASM - 1991, MSDOS 6.0) 
 10066                                  
 10067                                  ;============================================================================
 10068                                  ; CPMIO.ASM (MSDOS 6.0, 1991)
 10069                                  ;============================================================================
 10070                                  ; Retro DOS v4.0 by Erdogan Tan, 04/05/2019
 10071                                  
 10072                                  	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10073                                  
 10074                                  ;**	Standard device IO for MSDOS (first 12 function calls)
 10075                                  ;
 10076                                  ;	TITLE	IBMCPMIO - device IO for MSDOS
 10077                                  ;	NAME	IBMCPMIO
 10078                                  
 10079                                  ;	Old style CP/M 1-12 system calls to talk to reserved devices
 10080                                  ;
 10081                                  ;	$Std_Con_Input_No_Echo
 10082                                  ;	$Std_Con_String_Output
 10083                                  ;	$Std_Con_String_Input
 10084                                  ;	$RawConIO
 10085                                  ;	$RawConInput
 10086                                  ;	RAWOUT
 10087                                  ;	RAWOUT2
 10088                                  ;
 10089                                  
 10090                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
 10091                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
 10092                                  ; references to be SS or CS relative which is desired.
 10093                                  
 10094                                  ; ---------------------------------------------------------------------------
 10095                                  
 10096                                  ;	TITLE	CPMIO2 - device IO for MSDOS
 10097                                  ;	NAME	CPMIO2
 10098                                  
 10099                                  ;
 10100                                  ;	Microsoft Confidential
 10101                                  ;	Copyright (C) Microsoft Corporation 1991
 10102                                  ;	All Rights Reserved.
 10103                                  ;
 10104                                  
 10105                                  ;**	Old style CP/M 1-12 system calls to talk to reserved devices
 10106                                  ;
 10107                                  ;	$Std_Con_Input
 10108                                  ;	$Std_Con_Output
 10109                                  ;	OUTT
 10110                                  ;	TAB
 10111                                  ;	BUFOUT
 10112                                  ;	$Std_Aux_Input
 10113                                  ;	$Std_Aux_Output
 10114                                  ;	$Std_Printer_Output
 10115                                  ;	$Std_Con_Input_Status
 10116                                  ;	$Std_Con_Input_Flush
 10117                                  ;
 10118                                  ;	Revision History:
 10119                                  ;
 10120                                  ;	  AN000	 version 4.00 - Jan. 1988
 10121                                  
 10122                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
 10123                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
 10124                                  ; references to be SS or CS relative which is desired.
 10125                                  
 10126                                  ;DOSCODE SEGMENT
 10127                                  ;	ASSUME	SS:DOSDATA,CS:DOSCODE
 10128                                  
 10129                                  
 10130                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
 10131                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
 10132                                  ;hkn;	not valid. 
 10133                                  
 10134                                  ; DOSCODE:51BAh (MSDOS 6.21, MSDOS.SYS)
 10135                                  ; 08/11/2022
 10136                                  ; DOSCODE:51A6h (MSDOS 5.0, MSDOS.SYS)
 10137                                  
 10138                                  ;
 10139                                  ;----------------------------------------------------------------------------
 10140                                  ;
 10141                                  ; Procedure : $Std_Con_Input_No_Echo
 10142                                  ;
 10143                                  ;----------------------------------------------------------------------------
 10144                                  ;
 10145                                  
 10146                                  _$STD_CON_INPUT_NO_ECHO:   ;System call 8
 10147                                  
 10148                                  ; Inputs:
 10149                                  ;	None
 10150                                  ; Function:
 10151                                  ;	Input character from console, no echo
 10152                                  ; Returns:
 10153                                  ;	AL = character
 10154                                  
 10155 0000134C 1E                      	push	ds
 10156 0000134D 56                      	push	si
 10157                                  INTEST:
 10158 0000134E E8893C                  	call	STATCHK
 10159 00001351 753A                    	jnz	short GET ; 08/09/2018
 10160                                  ;*************************************************************************
 10161                                  ;hkn; SS override
 10162 00001353 36803E[A00A]00          	cmp	byte [SS:PRINTER_FLAG],0  ; is printer idle?
 10163 00001359 7505                    	jnz	short no_sys_wait
 10164 0000135B B405                    	mov	ah,5			; get input status with system wait
 10165 0000135D E8DC2F                  	call	IOFUNC
 10166                                  no_sys_wait:
 10167                                  ;**************************************************************************
 10168 00001360 B484                    	MOV	AH,84h
 10169 00001362 CD2A                    	INT	int_IBM	 ; int 2Ah
 10170                                  
 10171                                  ;;; 7/15/86  update the date in the idle loop
 10172                                  ;;; Dec 19, 1986 D.C.L. changed following CMP to Byte Ptr from Word Ptr
 10173                                  ;;;;		 to shorten loop in consideration of the PC Convertible
 10174                                  
 10175                                  ;hkn; SS override
 10176 00001364 36803E[910D]FF          	CMP	byte [SS:DATE_FLAG],-1	; date is updated may be every
 10177 0000136A 751A                    	JNZ	short NoUpdate		; 65535 x ? ms if no one calls
 10178                                  
 10179 0000136C 50                      	PUSH	AX
 10180 0000136D 53                      	PUSH	BX			; following is tricky,
 10181 0000136E 51                      	PUSH	CX			; it may be called by critical handler
 10182 0000136F 52                      	PUSH	DX			; at that time, DEVCALL is used by
 10183                                  					; other's READ or WRITE
 10184 00001370 1E                      	PUSH	DS			; save DS = SFT's segment
 10185                                  
 10186                                  ;hkn; READTIME must use ds = DOSDATA
 10187                                  ;hkn;	PUSH	CS			; READTIME must use DS=CS
 10188                                  
 10189 00001371 16                      	PUSH	SS ; 04/05/2019
 10190 00001372 1F                      	POP	DS
 10191                                  
 10192                                  	;MOV	AX,0			; therefore, we save DEVCALL
 10193                                  	; 26/06/2024
 10194 00001373 31C0                    	xor	ax,ax
 10195 00001375 E89102                  	CALL	Save_Restore_Packet	; save DEVCALL packet
 10196                                  	;invoke	READTIME		; readtime
 10197 00001378 E88FF7                  	call	READTIME
 10198 0000137B B80100                  	MOV	AX,1
 10199 0000137E E88802                  	CALL	Save_Restore_Packet	; restore DEVCALL packet
 10200                                  
 10201                                  ;	; MSDOS 3.3 (IBMDOS.COM, Offset 1F8Ch)
 10202                                  ;	; (MSDOS 6.0 code does not contain IBM DOS FETCHI_TAG check)
 10203                                  ;	push	bx
 10204                                  ;	mov	bx,DATE_FLAG
 10205                                  ;	add	bx,2  ; mov bx,FETCHI_FLAG
 10206                                  ;	cmp	word [cs:bx],5872h
 10207                                  ;	jz	short FETCHI_TAG_chk_ok
 10208                                  ;	call	DOSINIT
 10209                                  ;FETCHI_TAG_chk_ok:
 10210                                  ;	pop	bx
 10211                                  
 10212 00001381 1F                      	POP	DS			; restore DS
 10213 00001382 5A                      	POP	DX
 10214 00001383 59                      	POP	CX
 10215 00001384 5B                      	POP	BX
 10216 00001385 58                      	POP	AX
 10217                                  NoUpdate:
 10218                                  
 10219                                  ;hkn; SS override
 10220 00001386 36FF06[910D]            	INC	word [SS:DATE_FLAG]
 10221                                  
 10222                                  ;;; 7/15/86 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 10223 0000138B EBC1                    	JMP	short INTEST
 10224                                  GET:
 10225 0000138D 30E4                    	XOR	AH,AH
 10226 0000138F E8AA2F                  	call	IOFUNC
 10227 00001392 5E                      	POP	SI
 10228 00001393 1F                      	POP	DS
 10229                                  ;;; 7/15/86
 10230                                  
 10231                                  ;hkn; SS override
 10232                                  	; MSDOS 6.0
 10233 00001394 36C606[900D]00          	MOV	BYTE [SS:SCAN_FLAG],0
 10234                                  	;
 10235 0000139A 3C00                    	CMP	AL,0	    ; extended code ( AL )
 10236 0000139C 7505                    	JNZ	short noscan
 10237                                  
 10238                                  ;hkn; SS override
 10239                                  	;MOV	BYTE [SS:SCAN_FLAG],1 ; set this flag for ALT_Q key
 10240                                  	; 20/06/2023
 10241 0000139E 36FE06[900D]            	inc	byte [SS:SCAN_FLAG]
 10242                                  noscan:
 10243 000013A3 C3                      	retn
 10244                                  ;
 10245                                  ;----------------------------------------------------------------------------
 10246                                  ;
 10247                                  ;**	$STD_CON_STRING_OUTPUT - Console String Output
 10248                                  ;
 10249                                  ;
 10250                                  ;	ENTRY	(DS:DX) Point to output string '$' terminated
 10251                                  ;	EXIT	none
 10252                                  ;	USES	ALL
 10253                                  ;
 10254                                  ;----------------------------------------------------------------------------
 10255                                  ;
 10256                                  
 10257                                  _$STD_CON_STRING_OUTPUT:	;System call 9
 10258                                  
 10259 000013A4 89D6                    	mov	si,dx
 10260                                  STRING_OUT1:	
 10261 000013A6 AC                      	lodsb
 10262 000013A7 3C24                    	cmp	al,'$'
 10263 000013A9 74F8                    	je	short noscan
 10264                                  NEXT_STR1:
 10265 000013AB E88702                  	call	OUTT
 10266 000013AE EBF6                    	jmp	short STRING_OUT1
 10267                                  
 10268                                  ;----------------------------------------------------------------------------
 10269                                  ;
 10270                                  ;**	$STD_CON_STRING_INPUT - Input Line from Console
 10271                                  ;
 10272                                  ;	$STD_CON_STRING_INPUT Fills a buffer from console input until CR
 10273                                  ;
 10274                                  ;	ENTRY	(ds:dx) = input buffer
 10275                                  ;	EXIT	none
 10276                                  ;	USES	ALL
 10277                                  ;
 10278                                  ;----------------------------------------------------------------------------
 10279                                  
 10280                                  	; 15/01/2024
 10281                                  
 10282                                  _$STD_CON_STRING_INPUT:		;System call 10
 10283                                  
 10284                                  	; 15/01/2024
 10285                                  	;mov	ax,ss
 10286                                  	;mov	es,ax
 10287 000013B0 16                      	push	ss
 10288 000013B1 07                      	pop	es
 10289                                  
 10290 000013B2 89D6                    	mov	si,dx
 10291 000013B4 30ED                    	xor	ch,ch
 10292 000013B6 AD                      	lodsw
 10293                                  
 10294                                  ;	(AL) = the buffer length
 10295                                  ;	(AH) = the template length
 10296                                  
 10297 000013B7 08C0                            or	al,al
 10298 000013B9 74E8                            jz	short noscan	;Buffer is 0 length!!?
 10299 000013BB 88E3                    	mov	bl,ah		;Init template counter
 10300 000013BD 88EF                            mov	bh,ch		;Init template counter
 10301                                  
 10302                                  ;	(BL) = the number of bytes in the template
 10303                                  
 10304 000013BF 38D8                            cmp	al,bl
 10305 000013C1 7605                            jbe	short NOEDIT	;If length of buffer inconsistent with contents
 10306 000013C3 80380D                          cmp	byte [bx+si],c_CR ; 0Dh
 10307 000013C6 7402                            jz	short EDITON	;If CR correctly placed EDIT is OK
 10308                                  
 10309                                  ; The number of chars in the template is >= the number of chars in buffer or
 10310                                  ; there is no CR at the end of the template. This is an inconsistant state
 10311                                  ; of affairs. Pretend that the template was empty:
 10312                                  ;
 10313                                  
 10314                                  NOEDIT:	
 10315 000013C8 88EB                    	mov	bl,ch		;Reset buffer
 10316                                  EDITON: 
 10317 000013CA 88C2                    	mov	dl,al
 10318 000013CC 4A                      	dec	dx		;DL is # of bytes we can put in the buffer
 10319                                  
 10320                                  ;	Top level. We begin to read a line in.
 10321                                  
 10322                                  NEWLIN: 
 10323 000013CD 36A0[F901]              	mov	al,[SS:CARPOS]
 10324 000013D1 36A2[FA01]              	mov	[SS:STARTPOS],al ;Remember position in raw buffer
 10325                                  
 10326 000013D5 56                      	push	si
 10327 000013D6 BF[FB01]                	mov	di,INBUF ;Build the new line here
 10328 000013D9 36882E[7905]            	mov	byte [SS:INSMODE],ch ;Insert mode off
 10329 000013DE 88EF                    	mov	bh,ch		;No chars from template yet
 10330 000013E0 88EE                    	mov	dh,ch		;No chars to new line yet
 10331 000013E2 E867FF                  	call	_$STD_CON_INPUT_NO_ECHO ;Get first char
 10332 000013E5 3C0A                    	cmp	al,c_LF		; 0Ah	;Linefeed 
 10333 000013E7 7503                    	jnz	short GOTCH
 10334                                  
 10335                                  ;	This is the main loop of reading in a character and processing it.
 10336                                  ;
 10337                                  ;	(BH) = the index of the next byte in the template
 10338                                  ;	(BL) = the length of the template
 10339                                  ;	(DH) = the number of bytes in the buffer
 10340                                  ;	(DL) = the length of the buffer
 10341                                  
 10342                                  GETCH:
 10343 000013E9 E860FF                  	call	_$STD_CON_INPUT_NO_ECHO
 10344                                  GOTCH:
 10345                                  ;
 10346                                  ; Brain-damaged Tim Patterson ignored ^F in case his BIOS did not flush the
 10347                                  ; input queue.
 10348                                  ;
 10349 000013EC 3C06                            cmp	al,"F"-"@"  ; CMP AL, 6  ; Ignore ^F
 10350 000013EE 74F9                    	jz	short GETCH
 10351                                  
 10352                                  ;	If the leading char is the function-key lead byte
 10353                                  
 10354                                  	;cmp	al,[SS:ESCCHAR]
 10355                                  
 10356                                  	; 04/05/2019 - Retro DOS v4.0
 10357                                  
 10358                                  ;hkn; 	ESCCHAR is in TABLE seg (DOSCODE)
 10359                                  
 10360 000013F0 2E3A06[140A]            	CMP	AL,[cs:ESCCHAR]
 10361 000013F5 7439                            jz	short ESCAPE	;change reserved keyword DBM 5-7-87
 10362                                  
 10363                                  ;	Rubout and ^H are both destructive backspaces.
 10364                                  
 10365 000013F7 3C7F                            cmp	al,c_DEL ; 7FH
 10366                                          ;jz	short BACKSPJ
 10367                                          ; 15/01/2024
 10368 000013F9 7466                    	je	short BACKSP
 10369 000013FB 3C08                    	cmp	al,c_BS  ; 8
 10370                                          ;jz	short BACKSPJ
 10371                                          ; 15/01/2024
 10372 000013FD 7462                    	je	short BACKSP
 10373                                  
 10374                                  	; 04/05/2019 -	MSDOS 6.0, also MSDOS 6.21 has bug (bullshit) here. 
 10375                                  	;		Two NOPs -instead of a JMP short, as two bytes-
 10376                                  	;	   	after CMP and a CMP again!
 10377                                  	;		
 10378                                  	;		-It would be better if they use a 'JMP short' to 
 10379                                  	;	      	DOSCODE:5279h from DOSCODE:5271h and leave NOPs
 10380                                  	;		between them. Then, they would be able use a patch
 10381                                  	;		between 5271h and 5279h when if it will be required.
 10382                                  	;		I think Tim Patterson would not do this CMP mistake!-
 10383                                  	;	
 10384                                  	; (MSDOS.SYS, from DOSCODE:5271h to DOSCODE:5279h)
 10385                                  
 10386                                  	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10387                                  	;
 10388                                  	; (Note: nops below might be used for patching code for Windows 3.1)
 10389                                  
 10390                                  ;DOSCODE:526D	cmp     al, 8
 10391                                  ;DOSCODE:526F	jz      short BACKSPJ
 10392                                  ;DOSCODE:5271	cmp     al, 17h
 10393                                  ;DOSCODE:5273	nop
 10394                                  ;DOSCODE:5274	nop
 10395                                  ;DOSCODE:5275	cmp     al, 15h
 10396                                  ;DOSCODE:5277	nop
 10397                                  ;DOSCODE:5278	nop
 10398                                  ;DOSCODE:5279	cmp     al, 0Dh
 10399                                  ;DOSCODE:527B	jz      short ENDLIN
 10400                                  ;DOSCODE:527D	cmp     al, 0Ah
 10401                                  ;DOSCODE:527F	jz      short PHYCRLF
 10402                                  	
 10403                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10404                                  	; DOSCODE:525Dh
 10405                                  
 10406                                  ; 16/12/2022
 10407                                  %if 0
 10408                                  	; MSDOS 6.0
 10409                                  ;	^W deletes backward once and then backs up until a letter is before the
 10410                                  ;	cursor
 10411                                  
 10412                                  	CMP     AL,"W"-"@" ; 17h
 10413                                  
 10414                                  ;	The removal of the comment characters before the jump statement will
 10415                                  ;	cause ^W to backup a word.
 10416                                  
 10417                                  ;***	JZ	short WordDel
 10418                                  	NOP
 10419                                  	NOP
 10420                                  
 10421                                  	CMP     AL,"U"-"@" ; 15h
 10422                                  
 10423                                  ;	The removal of the comment characters before the jump statement will
 10424                                  ;	cause ^U to clear a line.
 10425                                  
 10426                                  ;***	JZ	short LineDel
 10427                                  	NOP
 10428                                  	NOP
 10429                                  
 10430                                  %endif
 10431                                  
 10432                                  ;	CR terminates the line.
 10433                                  
 10434 000013FF 3C0D                            cmp	al,c_CR ; 0Dh
 10435 00001401 7430                            jz	short ENDLIN
 10436                                  
 10437                                  ;	LF goes to a new line and keeps on reading.
 10438                                  
 10439 00001403 3C0A                            cmp	al,c_LF ; 0Ah
 10440 00001405 7442                    	jz	short PHYCRLF
 10441                                  
 10442                                  ;	^X (or ESC) deletes the line and starts over
 10443                                  
 10444                                  	; MSDOS 3.3
 10445                                  	;cmp	al,[ss:CANCHAR] ; 1Bh
 10446                                  	;jz	short KILNEW
 10447                                  
 10448                                  	; MSDOS 6.0 (& MSDOS 6.21)
 10449                                  
 10450                                  ;hkn; 	CANCHAR is in TABLE seg (DOSCODE), so CS override
 10451                                  
 10452 00001407 2E3A06[130A]            	cmp	al,[cs:CANCHAR] ; 1Bh
 10453 0000140C 7440                    	jz	short KILNEW
 10454                                  	
 10455                                  	;cmp	al,CANCEL ; 1Bh	; Retro DOS v3.0
 10456                                  	;jz	short KILNEW
 10457                                  
 10458                                  ; Otherwise, we save the input character.
 10459                                  
 10460                                  SAVCH:	
 10461 0000140E 38D6                    	cmp	dh,dl
 10462 00001410 7317                    	jnb	short BUFFUL		; buffer is full.
 10463 00001412 AA                              stosb
 10464 00001413 FEC6                    	inc	dh                      ; increment count in buffer.
 10465 00001415 E8B102                  	call	BUFOUT			; Print control chars nicely
 10466                                  
 10467 00001418 36803E[7905]00                  cmp	byte [SS:INSMODE], 0
 10468 0000141E 75C9                    	jnz	short GETCH		; insertmode => don't advance template
 10469 00001420 38DF                            cmp	bh,bl
 10470 00001422 73C5                            jnb	short GETCH		; no more characters in template
 10471 00001424 46                              inc	si                      ; Skip to next char in template
 10472 00001425 FEC7                            inc	bh                      ; remember position in template
 10473 00001427 EBC0                            jmp	short GETCH
 10474                                  
 10475                                  	; 15/01/2024
 10476                                  ;BACKSPJ: 
 10477                                  	;jmp	short BACKSP
 10478                                  
 10479                                  BUFFUL: 
 10480 00001429 B007                    	mov	al, 7			; Bell to signal full buffer
 10481 0000142B E80702                  	call	OUTT
 10482 0000142E EBB9                    	jmp	short GETCH
 10483                                  
 10484                                  ESCAPE: 
 10485                                  	;transfer OEMFunctionKey
 10486 00001430 E90CF6                  	JMP	OEMFunctionKey		; let the OEM's handle the key dispatch
 10487                                  
 10488                                  ENDLIN:
 10489 00001433 AA                              stosb				; Put the CR in the buffer
 10490 00001434 E8FE01                  	call	OUTT                    ; Echo it
 10491 00001437 5F                              pop	di                      ; Get start of user buffer
 10492 00001438 8875FF                          mov	[di-1], dh		; Tell user how many bytes
 10493 0000143B FEC6                            inc	dh			; DH is length including CR
 10494                                  
 10495                                  COPYNEW:
 10496                                  	; (IBMDOS.COM, MSDOS 2.0, STRIN.ASM)
 10497                                  	;mov	bp, es
 10498                                  	;mov	bx, ds
 10499                                  	;mov	es, bx
 10500                                  	;mov	ds, bp
 10501                                  	;mov	si, INBUF
 10502                                  	;mov	cl, dh
 10503                                  	;rep	movsb
 10504                                  	;retn
 10505                                  
 10506                                  	; CPMIO.ASM (MSDOS 6.0)
 10507                                  	; (IBMDOS.COM, MSDOS 3.3, Offset 2061h) 
 10508                                  	;SAVE	<DS,ES>
 10509 0000143D 1E                      	PUSH	DS
 10510 0000143E 06                      	PUSH	ES
 10511                                  	;RESTORE <DS,ES>		; XCHG ES,DS
 10512 0000143F 1F                      	POP	DS
 10513 00001440 07                      	POP	ES
 10514                                  
 10515                                  ;;hkn; INBUF is in DOSDATA
 10516 00001441 BE[FB01]                        MOV     SI,INBUF
 10517 00001444 88F1                            MOV     CL,DH                   ; set up count
 10518 00001446 F3A4                            REP     MOVSB                   ; Copy final line to user buffer
 10519                                  OLDBAK_RETN:
 10520 00001448 C3                              RETN
 10521                                  
 10522                                  ;	Output a CRLF to the user screen and do NOT store it into the buffer
 10523                                  
 10524                                  PHYCRLF:
 10525 00001449 E81B01                  	CALL	CRLF
 10526 0000144C EB9B                            JMP	short GETCH
 10527                                  
 10528                                  	; MSDOS 6.0 (& MSDOS 3.3, IBMDOS.COM, 1987)
 10529                                  
 10530                                  ; DOSCODE:52CAh (MSDOS 621, MSDOS.SYS)
 10531                                  
 10532                                  	; Note: Following routines were not used in IBMDOS.COM
 10533                                  	;	-CRTL+W, CRTL+U is not activated-
 10534                                  	;	but they were in the kernel code!?)
 10535                                  
 10536                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10537                                  	; DOSCODE:52B6h
 10538                                  
 10539                                  ;;;;;;;;
 10540                                  
 10541                                  ; 16/12/2022
 10542                                  %if 0
 10543                                  ;
 10544                                  ; Delete the previous line
 10545                                  ;
 10546                                  LineDel:
 10547                                  	OR      DH,DH
 10548                                  	JZ	short GETCH	 ; 06/12/2022
 10549                                  	Call    BackSpace
 10550                                  	JMP	short LineDel
 10551                                  
 10552                                  %endif
 10553                                  
 10554                                  ;
 10555                                  ; delete the previous word.
 10556                                  ;
 10557                                  WordDel:
 10558                                  WordLoop:
 10559                                  ;	Call    BackSpace               ; backspace the one spot
 10560                                  ;	OR      DH,DH
 10561                                  ;	JZ	short GetChj
 10562                                  ;	MOV     AL,[ES:DI-1]
 10563                                  ;	cmp     al,'0'
 10564                                  ;	jb	short GetChj
 10565                                  ;	cmp     al,'9'
 10566                                  ;	jbe	short WordLoop
 10567                                  ;	OR      AL,20h
 10568                                  ;	CMP     AL,'a'
 10569                                  ;	JB	short GetChj
 10570                                  ;	CMP     AL,'z'
 10571                                  ;	JBE	short WordLoop
 10572                                  ;GetChj: 
 10573                                  ;	JMP	GETCH
 10574                                  
 10575                                  ; 16/12/2022
 10576                                  %if 0
 10577                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10578                                  	; (Worddel is not called or jumped from anywhere!)
 10579                                  WordDel:
 10580                                  WordLoop:
 10581                                  	Call    BackSpace               ; backspace the one spot
 10582                                  	OR      DH,DH
 10583                                  	JZ	short GetChj
 10584                                  	MOV     AL,[ES:DI-1]
 10585                                  	cmp     al,'0'
 10586                                  	jb	short GetChj
 10587                                  	cmp     al,'9'
 10588                                  	jbe	short WordLoop
 10589                                  	OR      AL,20h
 10590                                  	CMP     AL,'a'
 10591                                  	JB	short GetChj
 10592                                  	CMP     AL,'z'
 10593                                  	JBE	short WordLoop
 10594                                  GetChj: 
 10595                                  	JMP	GETCH
 10596                                  
 10597                                  %endif
 10598                                  
 10599                                  ;;;;;;;;
 10600                                  
 10601                                  ; DOSCODE:52F3h (MSDOS 621, MSDOS.SYS)
 10602                                  
 10603                                  ; The user wants to throw away what he's typed in and wants to start over.
 10604                                  ; We print the backslash and then go to the next line and tab to the correct
 10605                                  ; spot to begin the buffered input.
 10606                                  
 10607                                  KILNEW:
 10608 0000144E B05C                            mov	al,'\'
 10609 00001450 E8E201                          call	OUTT            ;Print the CANCEL indicator
 10610 00001453 5E                              pop	si		;Remember start of edit buffer
 10611                                  PUTNEW:
 10612 00001454 E81001                  	call	CRLF            ;Go to next line on screen
 10613 00001457 36A0[FA01]              	mov	al,[SS:STARTPOS]
 10614 0000145B E84B02                  	call	TAB             ;Tab over
 10615 0000145E E96CFF                          JMP     NEWLIN		;Start over again
 10616                                  
 10617                                  ;	Destructively back up one character position
 10618                                  
 10619                                  BACKSP:
 10620                                  	; 09/09/2018
 10621 00001461 E80800                  	Call    BackSpace
 10622 00001464 EB83                    	JMP     short GETCH	; 15/01/2024
 10623                                  
 10624                                  	; 15/01/2024
 10625                                  ;User really wants an ESC character in his line
 10626                                  TWOESC:	
 10627 00001466 2EA0[140A]              	mov	al,[cs:ESCCHAR] ; 10/06/2019
 10628 0000146A EBA2                    	jmp	short SAVCH
 10629                                  
 10630                                  BackSpace:
 10631 0000146C 08F6                    	or	dh,dh
 10632 0000146E 7419                    	jz	short OLDBAK	;No chars in line, do nothing to line
 10633 00001470 E85800                  	call	BACKUP          ;Do the backup
 10634 00001473 268A05                  	mov	al,[es:di]	;Get the deleted char
 10635 00001476 3C20                            cmp	al,20h	; ' '
 10636 00001478 730F                    	jnb	short OLDBAK	;Was a normal char
 10637 0000147A 3C09                            cmp	al,c_HT ; 9
 10638 0000147C 741B                    	jz	short BAKTAB	;Was a tab, fix up users display
 10639                                  ;; 9/27/86 fix for ctrl-U backspace
 10640 0000147E 3C15                    	CMP     AL,"U"-"@" ; 15h ; ctrl-U is a section symbol not ^U
 10641 00001480 7407                    	JZ	short OLDBAK
 10642 00001482 3C14                           	CMP     AL,"T"-"@" ; 14h ; ctrl-T is a paragraphs symbol not ^T
 10643 00001484 7403                    	JZ	short OLDBAK
 10644                                  ;; 9/27/86 fix for ctrl-U backspace
 10645 00001486 E84500                          call	BACKMES         ;Was a control char, zap the '^'
 10646                                  OLDBAK:
 10647 00001489 36803E[7905]00                  cmp	byte [SS:INSMODE], 0
 10648 0000148F 75B7                    	jnz	short OLDBAK_RETN ;In insert mode, done
 10649 00001491 08FF                    	or	bh,bh
 10650 00001493 74B3                            jz	short OLDBAK_RETN 
 10651                                  				;Not advanced in template, stay where we are
 10652 00001495 FECF                    	dec	bh		;Go back in template
 10653 00001497 4E                              dec	si
 10654 00001498 C3                      	retn
 10655                                  BAKTAB:
 10656 00001499 57                              push	di
 10657 0000149A 4F                              dec	di		;Back up one char
 10658 0000149B FD                              std			;Go backward
 10659 0000149C 88F1                            mov	cl,dh		;Number of chars currently in line
 10660 0000149E B020                            mov	al,20h	; ' '
 10661 000014A0 53                              push	bx
 10662 000014A1 B307                            mov	bl,7		;Max
 10663 000014A3 E30E                            jcxz	FIGTAB		;At start, do nothing
 10664                                  FNDPOS:
 10665 000014A5 AE                              scasb			;Look back
 10666 000014A6 7609                    	jbe	short CHKCNT
 10667 000014A8 26807D0109              	cmp	byte [es:di+1],9
 10668 000014AD 7409                    	jz	short HAVTAB	;Found a tab
 10669 000014AF FECB                    	dec	bl		;Back one char if non tab control char
 10670                                  CHKCNT:
 10671 000014B1 E2F2                            loop	FNDPOS
 10672                                  FIGTAB:		
 10673 000014B3 362A1E[FA01]            	sub	bl,[SS:STARTPOS]
 10674                                  HAVTAB:
 10675 000014B8 28F3                    	sub	bl,dh
 10676 000014BA 00D9                    	add	cl,bl
 10677 000014BC 80E107                  	and	cl,7		;CX has correct number to erase
 10678 000014BF FC                      	cld			;Back to normal
 10679 000014C0 5B                      	pop	bx
 10680 000014C1 5F                      	pop	di
 10681 000014C2 74C5                    	jz	short OLDBAK	;Nothing to erase
 10682                                  TABBAK:
 10683 000014C4 E80700                  	call	BACKMES
 10684 000014C7 E2FB                    	loop	TABBAK		;Erase correct number of chars
 10685 000014C9 EBBE                    	jmp	short OLDBAK
 10686                                  
 10687                                  BACKUP:
 10688 000014CB FECE                            dec	dh		;Back up in line
 10689 000014CD 4F                              dec	di
 10690                                  BACKMES:
 10691 000014CE B008                            mov	al,c_BS ; 8	;Backspace
 10692 000014D0 E86201                          call	OUTT
 10693 000014D3 B020                            mov	al,20h ; ' '	;Erase
 10694 000014D5 E85D01                          call	OUTT
 10695 000014D8 B008                            mov	al,c_BS ; 8	;Backspace
 10696 000014DA E95801                  	jmp	OUTT		;Done
 10697                                  
 10698                                  	; 15/01/2024
 10699                                  ;User really wants an ESC character in his line
 10700                                  ;TWOESC:	
 10701                                  ;	mov	al,[cs:ESCCHAR] ; 10/06/2019
 10702                                  ;	jmp	SAVCH
 10703                                  
 10704                                  ;Copy the rest of the template
 10705                                  COPYLIN:
 10706 000014DD 88D9                            mov	cl,bl		;Total size of template
 10707 000014DF 28F9                    	sub	cl,bh		;Minus position in template, is number to move
 10708 000014E1 EB07                            jmp	short COPYEACH
 10709                                  
 10710                                  COPYSTR:
 10711 000014E3 E83200                  	call	FINDOLD         ;Find the char
 10712 000014E6 EB02                    	jmp	short COPYEACH  ;Copy up to it
 10713                                  
 10714                                  ;Copy one char from template to line
 10715                                  COPYONE:
 10716 000014E8 B101                            mov	cl,1
 10717                                  ;Copy CX chars from template to line
 10718                                  COPYEACH:
 10719 000014EA 36C606[7905]00                  mov	byte [SS:INSMODE],0	;All copies turn off insert mode
 10720 000014F0 38D6                    	cmp	dh,dl
 10721 000014F2 740F                            jz	short GETCH2		;At end of line, can't do anything
 10722 000014F4 38DF                            cmp	bh,bl
 10723 000014F6 740B                            jz	short GETCH2		;At end of template, can't do anything
 10724 000014F8 AC                              lodsb
 10725 000014F9 AA                              stosb
 10726 000014FA E8CC01                  	call	BUFOUT
 10727 000014FD FEC7                            inc	bh			;Ahead in template
 10728 000014FF FEC6                            inc	dh			;Ahead in line
 10729 00001501 E2E7                            loop	COPYEACH
 10730                                  GETCH2:
 10731 00001503 E9E3FE                          jmp	GETCH
 10732                                  
 10733                                  ;Skip one char in template
 10734                                  SKIPONE:
 10735 00001506 38DF                    	cmp	bh,bl
 10736 00001508 74F9                    	jz	short GETCH2		;At end of template
 10737 0000150A FEC7                    	inc	bh			;Ahead in template
 10738 0000150C 46                      	inc	si
 10739                                          ;jmp	GETCH
 10740                                  	; 15/01/2024
 10741 0000150D EBF4                    	jmp	short GETCH2
 10742                                  
 10743                                  SKIPSTR:
 10744 0000150F E80600                  	call	FINDOLD                 ;Find out how far to go
 10745 00001512 01CE                            add	si,cx			;Go there
 10746 00001514 00CF                            add	bh,cl
 10747                                          ;jmp	GETCH
 10748                                  	; 15/01/2024
 10749 00001516 EBEB                    	jmp	short GETCH2
 10750                                  
 10751                                  ;Get the next user char, and look ahead in template for a match
 10752                                  ;CX indicates how many chars to skip to get there on output
 10753                                  ;NOTE: WARNING: If the operation cannot be done, the return
 10754                                  ;       address is popped off and a jump to GETCH is taken.
 10755                                  ;       Make sure nothing extra on stack when this routine
 10756                                  ;       is called!!! (no PUSHes before calling it).
 10757                                  
 10758                                  FINDOLD:
 10759 00001518 E831FE                          call	_$STD_CON_INPUT_NO_ECHO
 10760                                  
 10761                                  	; STRIN.ASM (MSDOS 2.11, 19/07/2018) 
 10762                                  
 10763                                  	;CMP	AL,[SS:ESCCHAR]	
 10764                                  	;JNZ	SHORT FINDSETUP
 10765                                  
 10766                                  	; CPMIO.ASM (MSDOS 6.0, 04/05/2019 - Retro DOS v4.0)
 10767                                  
 10768                                  ;hkn; ESCCHAR is in TABLE seg (DOSCODE), so CS override
 10769                                  
 10770 0000151B 2E3A06[140A]            	CMP	AL,[CS:ESCCHAR]		; did he type a function key?
 10771 00001520 7505                    	JNZ	SHORT FINDSETUP		; no, set up for scan
 10772                                  
 10773 00001522 E827FE                  	CALL	_$STD_CON_INPUT_NO_ECHO	; eat next char
 10774 00001525 EB1D                            JMP	SHORT NOTFND		; go try again
 10775                                  FINDSETUP:
 10776 00001527 88D9                    	mov	cl,bl
 10777 00001529 28F9                            sub	cl,bh		;CX is number of chars to end of template
 10778 0000152B 7417                    	jz	short NOTFND	;At end of template
 10779 0000152D 49                              dec	cx		;Cannot point past end, limit search
 10780 0000152E 7414                            jz	short NOTFND	;If only one char in template, forget it
 10781 00001530 06                      	push	es
 10782 00001531 1E                      	push	ds
 10783 00001532 07                      	pop	es
 10784 00001533 57                      	push	di
 10785 00001534 89F7                    	mov	di,si		;Template to ES:DI
 10786 00001536 47                      	inc	di
 10787 00001537 F2AE                    	repne	scasb		;Look
 10788 00001539 5F                      	pop	di
 10789 0000153A 07                      	pop	es
 10790 0000153B 7507                    	jnz	short NOTFND	;Didn't find the char
 10791 0000153D F6D1                            not	cl		;Turn how far to go into how far we went
 10792 0000153F 00D9                            add	cl,bl		;Add size of template
 10793 00001541 28F9                            sub	cl,bh		;Subtract current pos, result distance to skip
 10794                                  FINDOLD_RETN:
 10795 00001543 C3                      	retn
 10796                                  
 10797                                  NOTFND:
 10798 00001544 5D                      	pop	bp              ;Chuck return address
 10799                                  	;jmp	GETCH
 10800                                  	; 15/01/2024
 10801                                  GETCH2_j:
 10802 00001545 EBBC                    	jmp	short GETCH2
 10803                                  
 10804                                  REEDIT:
 10805 00001547 B040                    	mov	al,'@'		;Output re-edit character
 10806 00001549 E8E900                  	call	OUTT
 10807 0000154C 5F                      	pop	di
 10808 0000154D 57                      	push	di
 10809 0000154E 06                      	push	es
 10810 0000154F 1E                      	push	ds
 10811 00001550 E8EAFE                  	call	COPYNEW		;Copy current line into template
 10812 00001553 1F                      	pop	ds
 10813 00001554 07                      	pop	es
 10814 00001555 5E                      	pop	si
 10815 00001556 88F3                    	mov	bl,dh		;Size of line is new size template
 10816 00001558 E9F9FE                  	jmp	PUTNEW		;Start over again
 10817                                  
 10818                                  EXITINS:
 10819                                  ENTERINS:
 10820 0000155B 36F616[7905]            	not	byte [SS:INSMODE]
 10821                                  	;jmp	GETCH
 10822                                  	; 15/01/2024
 10823 00001560 EBE3                    	jmp	short GETCH2_j
 10824                                  
 10825                                  ;Put a real live ^Z in the buffer (embedded)
 10826                                  CTRLZ:
 10827 00001562 B01A                    	mov	al,"Z"-"@" ; 1Ah
 10828 00001564 E9A7FE                          jmp	SAVCH
 10829                                  
 10830                                  ;Output a CRLF
 10831                                  CRLF:
 10832 00001567 B00D                    	mov	al,c_CR ; 0Dh 
 10833 00001569 E8C900                  	call	OUTT
 10834 0000156C B00A                    	mov	al,c_LF ; 0Ah
 10835 0000156E E9C400                  	jmp	OUTT
 10836                                  
 10837                                  ;
 10838                                  ;----------------------------------------------------------------------------
 10839                                  ;
 10840                                  ;**	$RAW_CON_IO - Do Raw Console I/O
 10841                                  ;
 10842                                  ;	Input or output raw character from console, no echo
 10843                                  ;
 10844                                  ;	ENTRY	DL = -1 if input
 10845                                  ;		   =  output character if output
 10846                                  ;	EXIT	(AL) = input character if input
 10847                                  ;	USES	all
 10848                                  ;
 10849                                  ;----------------------------------------------------------------------------
 10850                                  ; 20/07/2018 - Retro DOS v3.0
 10851                                  
 10852                                  ; 04/05/2019 - Retro DOS v4.0
 10853                                  ; DOSCODE:541Ch (MSDOS 6.21, MSDOS.SYS)
 10854                                  
 10855                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10856                                  ; DOSCODE:5408h (MSDOS 5.0, MSDOS.SYS)
 10857                                  
 10858                                  _$RAW_CON_IO:			; System call 6
 10859 00001571 88D0                    	MOV	AL,DL
 10860 00001573 3CFF                    	CMP	AL,-1
 10861 00001575 7541                    	JNZ	SHORT RAWOUT ; 16/12/2022
 10862                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10863                                  	;jz	short rci1
 10864                                  	;jmp	short RAWOUT
 10865                                  	; 16/12/202
 10866                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10867                                  	;nop
 10868                                  rci1:
 10869                                  			; Get pointer to register save area
 10870 00001577 36C43E[8405]            	LES	DI,[SS:USER_SP] ; 12/03/2018
 10871 0000157C 31DB                    	XOR	BX,BX
 10872                                      	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10873 0000157E E8C11F                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10874                                          ;JC	SHORT RET17
 10875 00001581 72C0                            jc	short FINDOLD_RETN
 10876 00001583 B401                    	MOV	AH,1
 10877 00001585 E8B42D                  	CALL	IOFUNC
 10878 00001588 750B                    	JNZ	SHORT RESFLG
 10879 0000158A E81F3A                  	CALL	SPOOLINT
 10880                                  	;OR	BYTE [ES:DI+16H],40H
 10881 0000158D 26804D1640              	OR	BYTE [ES:DI+user_env.user_F],40H ; Set user's zero flag
 10882 00001592 30C0                    	XOR	AL,AL
 10883                                  RET17:
 10884 00001594 C3                      	RETN
 10885                                  
 10886                                  RESFLG:
 10887                                  	;AND	BYTE [ES:DI+16H],0FFH-40H  ; 0BFh
 10888 00001595 26806516BF              	AND	BYTE [ES:DI+user_env.user_F],0FFH-40H
 10889                                  				; Reset user's zero flag
 10890                                  ;RILP:
 10891                                  rci0:
 10892 0000159A E80F3A                  	CALL	SPOOLINT
 10893                                  ;
 10894                                  ;----------------------------------------------------------------------------
 10895                                  ;
 10896                                  ;**	$Raw_CON_INPUT - Raw Console Input
 10897                                  ;
 10898                                  ;	Input raw character from console, no echo
 10899                                  ;
 10900                                  ;	ENTRY	none
 10901                                  ;	EXIT	(al) = character
 10902                                  ;	USES	all
 10903                                  ;
 10904                                  ;----------------------------------------------------------------------------
 10905                                  ;
 10906                                  
 10907                                  ;rci0:	invoke	SPOOLINT
 10908                                  
 10909                                  	;entry	$RAW_CON_INPUT
 10910                                  
 10911                                  	; 04/05/2019 - Retro DOS v4.0
 10912                                  
 10913                                  ; DOSCODE:544Bh (MSDOS 6.21, MSDOS.SYS)
 10914                                  
 10915                                  _$RAW_CON_INPUT:		; System call 7
 10916 0000159D 53                      	push	bx
 10917 0000159E 31DB                    	XOR	BX,BX
 10918                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10919 000015A0 E89F1F                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10920 000015A3 5B                      	pop	bx
 10921 000015A4 72EE                    	JC	SHORT RET17
 10922 000015A6 B401                    	MOV	AH,1
 10923 000015A8 E8912D                  	CALL	IOFUNC
 10924                                  	;JZ	SHORT RILP	; MSDOS 2.11
 10925                                  	;XOR	AH,AH
 10926                                          ;CALL	IOFUNC
 10927                                          ;RETN
 10928 000015AB 7506                    	jnz	short rci5	; MSDOS 3.3 & MSDOS 6.0
 10929 000015AD B484                    	MOV	AH,84h
 10930 000015AF CD2A                    	INT	int_IBM  ; int 2Ah
 10931 000015B1 EBE7                    	JMP	short rci0
 10932                                  rci5:	
 10933 000015B3 30E4                    	XOR	AH,AH
 10934                                  	;CALL	IOFUNC
 10935                                  	;RETN
 10936                                  	; 18/12/2022
 10937 000015B5 E9842D                  	jmp	IOFUNC
 10938                                  
 10939                                  ;       Output the character in AL to stdout
 10940                                  ;
 10941                                  	;entry	RAWOUT
 10942                                  RAWOUT:
 10943 000015B8 53                      	PUSH    BX
 10944 000015B9 BB0100                  	MOV     BX,1
 10945                                  
 10946                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10947 000015BC E8831F                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10948 000015BF 721B                    	JC	SHORT RAWRET1
 10949                                  
 10950                                  	;
 10951                                  	; MSDOS 2.11
 10952                                          ;TEST	BYTE [SI+18H],080H	; output to file?
 10953                                          ;JZ	SHORT RAWNORM		; if so, do normally
 10954                                          ;PUSH	DS
 10955                                          ;PUSH	SI
 10956                                          ;LDS	SI,[SI+19H]		; output to special?
 10957                                  	;TEST	BYTE [SI+4],ISSPEC
 10958                                  	;POP	SI
 10959                                  	;
 10960                                          
 10961                                  	; MSDOS 3.3 & MSDOS 6.0
 10962                                  	;mov	bx,[si+5]
 10963 000015C1 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags] ;hkn; DS set up by get_io_sft
 10964                                   ;
 10965                                   ; If we are a network handle OR if we are not a local device then go do the
 10966                                   ; output the hard way.
 10967                                   ;	
 10968                                  	;and	bx,8080h
 10969 000015C4 81E38080                	AND	BX,sf_isnet+devid_device
 10970                                  	;cmp	bx,80h
 10971 000015C8 81FB8000                	CMP	BX,devid_device
 10972 000015CC 7510                    	jnz     short RAWNORM
 10973 000015CE 1E                      	push    ds
 10974                                  	;lds	bx,[si+7]
 10975 000015CF C55C07                  	LDS	BX,[SI+SF_ENTRY.sf_devptr] ; output to special?
 10976                                  	;test	byte [bx+4],10h
 10977 000015D2 F6470410                	TEST	BYTE [BX+SYSDEV.ATT],ISSPEC
 10978                                  	;
 10979                                  
 10980 000015D6 1F                      	POP	DS
 10981 000015D7 7405                    	JZ	SHORT RAWNORM		; if not, do normally
 10982                                  
 10983 000015D9 CD29                    	INT	int_fastcon  ; int 29h	; quickly output the char
 10984                                  
 10985                                  	;JMP	SHORT RAWRET
 10986                                  ;RAWNORM:
 10987                                  ;	CALL    RAWOUT3
 10988                                  RAWRET: 
 10989 000015DB F8                      	CLC
 10990                                  RAWRET1:
 10991 000015DC 5B                      	POP     BX
 10992                                  RAWRET2:
 10993 000015DD C3                      	RETN
 10994                                  RAWNORM:
 10995 000015DE E80700                  	CALL    RAWOUT3
 10996 000015E1 EBF8                    	jmp	short RAWRET
 10997                                  
 10998                                  ;	Output the character in AL to handle in BX
 10999                                  ;
 11000                                  ;	entry	RAWOUT2
 11001                                  
 11002                                  RAWOUT2:
 11003                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 11004                                  	;JC	SHORT RET18
 11005 000015E3 E85C1F                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 11006 000015E6 72F5                    	JC	SHORT RAWRET2
 11007                                  RAWOUT3:
 11008 000015E8 50                      	PUSH	AX
 11009 000015E9 EB0C                    	JMP	SHORT RAWOSTRT
 11010                                  ROLP:
 11011 000015EB E8BE39                  	CALL	SPOOLINT
 11012                                  
 11013                                  	; 01/05/2019 - Retro DOS v4.0
 11014                                  
 11015                                  	; MSDOS 6.0
 11016                                  	;OR	word [ss:DOS34_FLAG],CTRL_BREAK_FLAG ; 001000000000b
 11017                                  	; 17/12/2022
 11018 000015EE 36800E[1206]02          	or	byte [ss:DOS34_FLAG+1],(CTRL_BREAK_FLAG>>8) ; 02h
 11019                                  	;or	word [ss:DOS34_FLAG],200h
 11020                                  				;AN002; set control break
 11021                                  	;invoke DSKSTATCHK
 11022 000015F4 E83439                  	call	DSKSTATCHK	;AN002; check control break
 11023                                  RAWOSTRT:
 11024 000015F7 B403                    	MOV	AH,3
 11025 000015F9 E8402D                  	CALL	IOFUNC
 11026 000015FC 74ED                    	JZ	SHORT ROLP
 11027                                  
 11028                                  	; MSDOS 6.0
 11029                                  ;SR;
 11030                                  ; IOFUNC now returns ax = 0ffffh if there was an I24 on a status call and
 11031                                  ;the user failed. We do not send a char if this happens. We however return
 11032                                  ;to the caller with carry clear because this DOS call does not return any
 11033                                  ;status. 
 11034                                  ;
 11035 000015FE 40                      	inc	ax		;fail on I24 if ax = -1
 11036 000015FF 58                      	POP	AX
 11037 00001600 7405                    	jz	short nosend	;yes, do not send char
 11038 00001602 B402                    	MOV	AH,2
 11039 00001604 E8352D                  	call	IOFUNC
 11040                                  nosend:
 11041 00001607 F8                      	CLC			; Clear carry indicating successful
 11042 00001608 C3                      	retn
 11043                                  
 11044                                  	; MSDOS 3.3 & MSDOS 2.11
 11045                                  	;POP	AX
 11046                                  	;MOV	AH,2
 11047                                          ;CALL	IOFUNC
 11048                                  	;CLC			; Clear carry indicating successful
 11049                                  ;RET18:    
 11050                                  	;RETN
 11051                                  
 11052                                  ;;10/08/2018
 11053                                  ; 20/07/2018 - Retro DOS v3.0
 11054                                  ; ---------------------------------------------------------------------------
 11055                                  ; Retro DOS v2.0 (MSDOS 2.11) - OUTMES
 11056                                  ; ---------------------------------------------------------------------------
 11057                                  
 11058                                  ; This routine is called at DOS init
 11059                                  
 11060                                  ;;	;procedure OUTMES,NEAR ; String output for internal messages
 11061                                  ;;OUTMES:
 11062                                  ;;	;LODS	CS:BYTE PTR [SI]
 11063                                  ;;	CS	LODSB
 11064                                  ;;	CMP     AL,"$" ; 24h
 11065                                  ;;	JZ	SHORT RET18
 11066                                  ;;	CALL	OUTT
 11067                                  ;;	JMP     SHORT OUTMES
 11068                                  
 11069                                  ; ---------------------------------------------------------------------------
 11070                                  
 11071                                  ; 20/07/2018 - Retro DOS v3.0
 11072                                  
 11073                                  ; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 2252h
 11074                                  
 11075                                  ;
 11076                                  ;----------------------------------------------------------------------------
 11077                                  ;
 11078                                  ; Inputs:
 11079                                  ;	AX=0 save the DEVCALL request packet
 11080                                  ;	  =1 restore the DEVCALL request packet
 11081                                  ; Function:
 11082                                  ;	save or restore the DEVCALL packet
 11083                                  ; Returns:
 11084                                  ;	none
 11085                                  ;
 11086                                  ;----------------------------------------------------------------------------
 11087                                  ;
 11088                                  
 11089                                  ; 04/05/2019 - Retro DOS v4.0
 11090                                  ; DOSCODE:54B9h (MSDOS 6.21, MSDOS.SYS)
 11091                                  
 11092                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11093                                  ; DOSCODE:54A5h (MSDOS 5.0, MSDOS.SYS)
 11094                                  
 11095                                  ; 12/05/2019
 11096                                  
 11097                                  	; 15/01/2024
 11098                                  
 11099                                  Save_Restore_Packet:
 11100 00001609 1E                      	PUSH	DS
 11101 0000160A 06                      	PUSH	ES
 11102 0000160B 56                      	PUSH	SI
 11103 0000160C 57                      	PUSH	DI
 11104                                  
 11105                                  	; 16/12/2022
 11106                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11107                                  	; 09/09/2018
 11108 0000160D BF[6C0D]                	mov	di,FAKE_STACK_2F
 11109 00001610 BE[5A03]                	mov	si,DEVCALL
 11110 00001613 BE[5A03]                	mov	si,DEVCALL
 11111                                  	;
 11112                                  	; 21/09/2023
 11113 00001616 09C0                    	or	ax,ax 
 11114                                  	;CMP	AX,0		; save packet
 11115 00001618 7402                    	JZ	short save_packet ; 16/12/2022
 11116                                  	;je	short set_seg
 11117                                  
 11118                                  	; MSDOS 6.0
 11119                                  restore_packet:
 11120                                  ;	MOV	SI,OFFSET DOSDATA:Packet_Temp	;source
 11121                                  ;	MOV	DI,OFFSET DOSDATA:DEVCALL	;destination
 11122                                  	; MSDOS 3.3
 11123                                  	;mov	si,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 11124                                  	;mov	di,DEVCALL  ; 09/09/2018
 11125                                  	;
 11126                                  	;JMP	short set_seg
 11127                                  
 11128                                  	; 16/12/2022	
 11129                                  	; 09/09/2018
 11130 0000161A 87F7                    	xchg	si,di  ; DI = offset DEVCALL, SI = offset FAKE_STACK_2F
 11131                                  
 11132                                  ; 16/12/2022
 11133                                  %if 0
 11134                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11135                                  	cmp	ax,0		; save packet
 11136                                  	jz	short save_packet
 11137                                  	mov	si,FAKE_STACK_2F ; 07/12/2022
 11138                                  	mov	di,DEVCALL 
 11139                                  	jmp	short set_seg
 11140                                  
 11141                                  	; MSDOS 6.0
 11142                                  save_packet:
 11143                                  ;	MOV	DI,OFFSET DOSDATA:Packet_Temp	;destination
 11144                                  ;	MOV	SI,OFFSET DOSDATA:DEVCALL	;source
 11145                                  	; 09/09/2018
 11146                                  	; MSDOS 3.3
 11147                                  	;mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 11148                                  	;mov	si,DEVCALL ; 09/09/2018
 11149                                  
 11150                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11151                                  	mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 11152                                  	mov	si,DEVCALL
 11153                                  %endif
 11154                                  
 11155                                  ; 15/01/2024
 11156                                  ; 16/12/2022
 11157                                  save_packet:
 11158                                  ;set_seg:
 11159                                  	; MSDOS 3.3
 11160                                  	;mov	ax,cs
 11161                                  
 11162                                  	; MSDOS 6.0
 11163                                  	;MOV	AX,SS		; set DS,ES to DOSDATA
 11164                                  	;MOV	DS,AX
 11165                                  	;MOV	ES,AX
 11166                                  	; 15/01/2024
 11167 0000161C 16                      	push	ss
 11168 0000161D 1F                      	pop	ds
 11169 0000161E 1E                      	push	ds
 11170 0000161F 07                      	pop	es
 11171                                  
 11172 00001620 B90B00                  	MOV	CX,11		; 11 words to move
 11173 00001623 F3A5                    	REP	MOVSW
 11174                                  
 11175 00001625 5F                      	POP	DI
 11176 00001626 5E                      	POP	SI
 11177 00001627 07                      	POP	ES
 11178 00001628 1F                      	POP	DS
 11179 00001629 C3                      	retn
 11180                                  
 11181                                  ;============================================================================
 11182                                  ; CPMIO2.ASM, MSDOS 6.0, 1991
 11183                                  ;============================================================================
 11184                                  ; 20/07/2018 - Retro DOS v3.0
 11185                                  ; 01/05/2019 - Retro DOS v4.0
 11186                                  
 11187                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
 11188                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
 11189                                  ;hkn;	not valid. 
 11190                                  
 11191                                  ;
 11192                                  ;----------------------------------------------------------------------------
 11193                                  ;
 11194                                  ;**	$STD_CON_INPUT - System Call 1
 11195                                  ;
 11196                                  ;	Input character from console, echo
 11197                                  ;
 11198                                  ;	ENTRY	none
 11199                                  ;	EXIT	(al) = character
 11200                                  ;	USES	ALL
 11201                                  ;
 11202                                  ;----------------------------------------------------------------------------
 11203                                  ;
 11204                                  
 11205                                  _$STD_CON_INPUT:	;System call 1
 11206                                  	
 11207 0000162A E81FFD                  	CALL	_$STD_CON_INPUT_NO_ECHO
 11208 0000162D 50                      	PUSH	AX
 11209 0000162E E80400                  	CALL	OUTT
 11210 00001631 58                      	POP	AX
 11211                                  CON_INPUT_RETN:	
 11212 00001632 C3                      	RETN
 11213                                  
 11214                                  ;
 11215                                  ;----------------------------------------------------------------------------
 11216                                  ;
 11217                                  ;**	$STD_CON_OUTPUT - System Call 2
 11218                                  ;
 11219                                  ;	Output character to console
 11220                                  ;
 11221                                  ;	ENTRY	(dl) = character
 11222                                  ;	EXIT	none
 11223                                  ;	USES	all
 11224                                  ;
 11225                                  ;----------------------------------------------------------------------------
 11226                                  ;
 11227                                  
 11228                                  ; DOSCODE:54E9h (MSDOS 6.21, MSDOS.SYS)
 11229                                  
 11230                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11231                                  ; DOSCODE:54D5h (MSDOS 5.0, MSDOS.SYS)
 11232                                  
 11233                                  _$STD_CON_OUTPUT:	;System call 2
 11234                                  
 11235 00001633 88D0                    	MOV	AL,DL
 11236                                  OUTT:
 11237 00001635 3C20                    	CMP	AL,20H ; " "
 11238 00001637 725C                    	JB	SHORT CTRLOUT
 11239 00001639 3C7F                    	CMP	AL,c_DEL ; 7Fh
 11240 0000163B 7405                    	JZ	SHORT OUTCH
 11241                                  OUTCHA:	
 11242                                  	;INC	BYTE PTR [CARPOS]
 11243 0000163D 36FE06[F901]            	INC	BYTE [SS:CARPOS]
 11244                                  OUTCH:
 11245 00001642 1E                      	PUSH	DS
 11246 00001643 56                      	PUSH	SI
 11247                                  	;INC	BYTE PTR [CHARCO]		;invoke statchk...
 11248                                  	;AND	BYTE PTR [CHARCO],00111111B	;AN000; every 64th char
 11249 00001644 36FE06[0003]            	INC	BYTE [SS:CHARCO]	
 11250                                  	;AND	BYTE [SS:CHARCO],00111111B
 11251                                  	; 01/05/2019 - Retro DOS v4.0
 11252 00001649 368026[0003]3F          	and	byte [SS:CHARCO],3Fh
 11253 0000164F 7505                    	JNZ	SHORT OUTSKIP
 11254                                  
 11255 00001651 50                      	PUSH	AX
 11256 00001652 E88539                  	CALL	STATCHK
 11257 00001655 58                      	POP	AX
 11258                                  OUTSKIP:
 11259 00001656 E85FFF                  	CALL	RAWOUT				;output the character
 11260                                  
 11261 00001659 5E                      	POP	SI
 11262 0000165A 1F                      	POP	DS
 11263                                  
 11264                                  	;TEST	BYTE PTR [PFLAG],-1
 11265                                  	;retz
 11266 0000165B 36F606[FE02]FF          	TEST	BYTE [SS:PFLAG],0FFh
 11267 00001661 74CF                    	JZ	SHORT CON_INPUT_RETN
 11268                                  
 11269 00001663 53                      	PUSH	BX
 11270 00001664 1E                      	PUSH	DS
 11271 00001665 56                      	PUSH	SI
 11272 00001666 BB0100                  	MOV	BX,1
 11273                                  	; 20/07/2018 - Retro DOS v3.0
 11274                                  	; MSDOS 3.3
 11275                                  	; MSDOS 6.0 (CPMIO2.ASM)
 11276 00001669 E8D61E                  	CALL	GET_IO_SFT		;hkn; GET_IO_SFT will set up DS:SI
 11277                                  					;hkn; to sft entry
 11278 0000166C 7224                    	JC	SHORT TRIPOPJ
 11279                                  
 11280                                  	; 01/05/2019 - Retro DOS v4.0
 11281                                  
 11282                                  	;mov	bx,[si+5]
 11283 0000166E 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags]
 11284                                  	;test	bx,8000h
 11285                                  	;TEST	BX,sf_isnet	; 8000h		; output to NET?
 11286 00001671 F6C780                  	test	bh,(sf_isnet>>8) ; 80h
 11287 00001674 751C                    	JNZ	short TRIPOPJ 			; if so, no echo
 11288                                  	;;test	bx,80h
 11289                                  	;TEST	BX,devid_device 		; output to file?
 11290 00001676 F6C380                  	test	bl,devid_device ; 80h
 11291 00001679 7417                    	JZ	SHORT TRIPOPJ 			; if so, no echo
 11292                                  	; 14/03/2018
 11293                                  	;call	GET_IO_FCB	 	; IBMDOS.COM, MSDOS 2.11
 11294                                  	;jc	short TRIPOPJ
 11295                                  	; MSDOS 2.11
 11296                                  	;test	byte [SI+18H], 80h
 11297                                  	;jz	short TRIPOPJ
 11298 0000167B BB0400                  	MOV	BX,4
 11299 0000167E E8C11E                  	CALL	GET_IO_SFT
 11300 00001681 720F                    	JC	SHORT TRIPOPJ
 11301                                  	;;test	word [si+5], 800h
 11302                                  	;TEST	word [SI+SF_ENTRY.sf_flags],sf_net_spool ; 800H
 11303                                  	;test	byte [si+6],8 ; 08/11/2022
 11304 00001683 F6440608                	test	byte [SI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8) ; 8 
 11305                                  						; StdPrn redirected?
 11306                                  	;;JZ	SHORT LISSTRT2J			; No, OK to echo
 11307                                  	;jz	LISSTRT2 ; 10/08/2018 
 11308                                  	; 16/12/2022
 11309 00001687 7503                    	jnz	short outch1
 11310 00001689 E98700                  	jmp	LISSTRT2
 11311                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11312                                  	;jz	short LISSTRT2J
 11313                                  outch1:
 11314                                  	;MOV	BYTE [PFLAG],0
 11315 0000168C 36C606[FE02]00          	MOV	BYTE [SS:PFLAG],0		; If a spool, NEVER echo
 11316                                  	; MSDOS 2.11
 11317                                  	;mov	bx,4
 11318                                  	;jmp	short LISSTRT2
 11319                                  	
 11320                                  TRIPOPJ:
 11321                                  	; 20/07/2018
 11322 00001692 E98100                  	JMP	TRIPOP
 11323                                  
 11324                                  	; 16/12/2022
 11325                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11326                                  ;LISSTRT2J:
 11327                                  ;	JMP	LISSTRT2
 11328                                  
 11329                                  CTRLOUT:
 11330 00001695 3C0D                    	CMP	AL,c_CR ; 0Dh
 11331 00001697 7420                    	JZ	SHORT ZERPOS
 11332 00001699 3C08                    	CMP	AL,c_BS ; 8
 11333 0000169B 7424                    	JZ	SHORT BACKPOS
 11334 0000169D 3C09                    	CMP	AL,c_HT ; 9
 11335 0000169F 75A1                    	JNZ	SHORT OUTCH
 11336                                  	;MOV	AL,[CARPOS]
 11337 000016A1 36A0[F901]              	MOV	AL,[SS:CARPOS]
 11338 000016A5 0CF8                    	OR	AL,0F8H
 11339 000016A7 F6D8                    	NEG	AL
 11340                                  TAB:
 11341 000016A9 51                      	PUSH	CX
 11342 000016AA 88C1                    	MOV	CL,AL
 11343 000016AC B500                    	MOV	CH,0
 11344 000016AE E307                    	JCXZ	POPTAB
 11345                                  TABLP:
 11346 000016B0 B020                    	MOV	AL," "
 11347 000016B2 E880FF                  	CALL	OUTT
 11348 000016B5 E2F9                    	LOOP	TABLP
 11349                                  POPTAB:
 11350 000016B7 59                      	POP	CX
 11351                                  
 11352 000016B8 C3                      	RETN
 11353                                  
 11354                                  ZERPOS:
 11355                                  	;MOV	BYTE PTR [CARPOS],0
 11356 000016B9 36C606[F901]00          	MOV	BYTE [SS:CARPOS],0
 11357                                  	; 10/08/2018
 11358 000016BF EB81                    	JMP	short OUTCH ; 04/05/2019
 11359                                  	
 11360                                  	; 18/12/2022
 11361                                  ;OUTJ:	
 11362                                  	;JMP	OUTT
 11363                                  
 11364                                  BACKPOS:
 11365                                  	;DEC	BYTE PTR [CARPOS]
 11366 000016C1 36FE0E[F901]            	DEC	BYTE [SS:CARPOS]
 11367 000016C6 E979FF                  	JMP	OUTCH
 11368                                  
 11369                                  BUFOUT:
 11370 000016C9 3C20                    	CMP	AL," "
 11371 000016CB 7315                    	JAE	SHORT OUTJ		;Normal char
 11372 000016CD 3C09                    	CMP	AL,9
 11373 000016CF 7411                    	JZ	SHORT OUTJ		;OUT knows how to expand tabs
 11374                                  	;DOS 3.3  7/14/86
 11375 000016D1 3C15                    	CMP	AL,"U"-"@" ; 15h	; turn ^U to section symbol
 11376 000016D3 740D                    	JZ	short CTRLU
 11377 000016D5 3C14                    	CMP	AL,"T"-"@" ; 14h	; turn ^T to paragraph symbol
 11378 000016D7 7409                    	JZ	short CTRLU
 11379                                  NOT_CTRLU:
 11380                                  	;DOS 3.3  7/14/86
 11381 000016D9 50                      	PUSH	AX
 11382 000016DA B05E                    	MOV	AL,"^"
 11383 000016DC E856FF                  	CALL	OUTT		;Print '^' before control chars
 11384 000016DF 58                      	POP	AX
 11385 000016E0 0C40                    	OR	AL,40H		;Turn it into Upper case mate
 11386                                  CTRLU:
 11387                                  	;CALL	OUTT
 11388                                  	; 18/12/2022
 11389                                  OUTJ:
 11390 000016E2 E950FF                  	jmp	OUTT
 11391                                  ;BUFOUT_RETN:
 11392                                  	;RETN
 11393                                  
 11394                                  ;
 11395                                  ;----------------------------------------------------------------------------
 11396                                  ;
 11397                                  ;**	$STD_AUX_INPUT - System Call 3
 11398                                  ;
 11399                                  ;	$STD_AUX_INPUT returns a character from Aux Input
 11400                                  ;
 11401                                  ;	ENTRY	none
 11402                                  ;	EXIT	(al) = character
 11403                                  ;	USES	all
 11404                                  ;
 11405                                  ;----------------------------------------------------------------------------
 11406                                  ;
 11407                                  
 11408                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11409                                  
 11410                                  _$STD_AUX_INPUT:	;System call 3
 11411                                  
 11412 000016E5 E8F238                  	CALL	STATCHK
 11413 000016E8 BB0300                  	MOV	BX,3
 11414 000016EB E8541E                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 11415                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 11416                                  	;retc
 11417                                  	; 16/12/2022
 11418                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11419                                  	;JC	SHORT BUFOUT_RETN
 11420                                  	;JMP	SHORT TAISTRT
 11421                                  	; 07/12/2022
 11422 000016EE 7304                    	jnc	SHORT TAISTRT
 11423 000016F0 C3                      	retn	
 11424                                  
 11425                                  AUXILP:
 11426 000016F1 E8B838                  	CALL	SPOOLINT
 11427                                  TAISTRT:
 11428 000016F4 B401                    	MOV	AH,1
 11429 000016F6 E8432C                  	CALL	IOFUNC
 11430 000016F9 74F6                    	JZ	SHORT AUXILP
 11431 000016FB 30E4                    	XOR	AH,AH
 11432                                  	; 16/12/2022
 11433                                  	;CALL	IOFUNC
 11434                                  	;RETN
 11435                                  	; 07/12/2022
 11436 000016FD E93C2C                  	jmp	IOFUNC
 11437                                  
 11438                                  ;
 11439                                  ;----------------------------------------------------------------------------
 11440                                  ;
 11441                                  ;**	$STD_AUX_OUTPUT - Output character to AUX
 11442                                  ;
 11443                                  ;	ENTRY	(dl) = character
 11444                                  ;	EXIT	none
 11445                                  ;	USES	all
 11446                                  ;
 11447                                  ;----------------------------------------------------------------------------
 11448                                  ;
 11449                                  
 11450                                  _$STD_AUX_OUTPUT:	;System call 4
 11451                                  
 11452 00001700 53                      	PUSH	BX
 11453 00001701 BB0300                  	MOV	BX,3
 11454 00001704 EB04                    	JMP	SHORT SENDOUT
 11455                                  
 11456                                  ;
 11457                                  ;----------------------------------------------------------------------------
 11458                                  ;
 11459                                  ;**	$STD_PRINTER_OUTPUT - Output character to printer
 11460                                  ;
 11461                                  ;	ENTRY	(dl) = character
 11462                                  ;	EXIT	none
 11463                                  ;	USES	all
 11464                                  ;
 11465                                  ;----------------------------------------------------------------------------
 11466                                  ;
 11467                                  
 11468                                  _$STD_PRINTER_OUTPUT:	;System call 5
 11469                                  
 11470 00001706 53                      	PUSH	BX
 11471 00001707 BB0400                  	MOV	BX,4
 11472                                  
 11473                                  SENDOUT:
 11474 0000170A 88D0                    	MOV	AL,DL
 11475 0000170C 50                      	PUSH	AX
 11476 0000170D E8CA38                  	CALL	STATCHK
 11477 00001710 58                      	POP	AX
 11478 00001711 1E                      	PUSH	DS
 11479 00001712 56                      	PUSH	SI
 11480                                  LISSTRT2:
 11481 00001713 E8CDFE                  	CALL	RAWOUT2
 11482                                  TRIPOP:
 11483 00001716 5E                      	POP	SI
 11484 00001717 1F                      	POP	DS
 11485 00001718 5B                      	POP	BX
 11486                                  SCIS_RETN:	; 20/07/2018
 11487 00001719 C3                      	RETN
 11488                                  ;
 11489                                  ;----------------------------------------------------------------------------
 11490                                  ;
 11491                                  ;**	$STD_CON_INPUT_STATUS - System Call 11
 11492                                  ;
 11493                                  ;	Check console input status
 11494                                  ;
 11495                                  ;	ENTRY	none
 11496                                  ;	EXIT	AL = -1 character available, = 0 no character
 11497                                  ;	USES	all
 11498                                  ;
 11499                                  ;----------------------------------------------------------------------------
 11500                                  ;
 11501                                  
 11502                                  _$STD_CON_INPUT_STATUS:		;System call 11
 11503                                  
 11504 0000171A E8BD38                  	CALL	STATCHK
 11505 0000171D B000                    	MOV	AL,0		; no xor!!
 11506                                  	;retz
 11507 0000171F 74F8                    	JZ	SHORT SCIS_RETN ; 15/04/2018
 11508 00001721 0CFF                    	OR	AL,-1
 11509                                  ;SCIS_RETN:
 11510 00001723 C3                      	RETN
 11511                                  
 11512                                  ;
 11513                                  ;----------------------------------------------------------------------------
 11514                                  ;
 11515                                  ;**	$STD_CON_INPUT_FLUSH - System Call 12
 11516                                  ;
 11517                                  ;	Flush console input buffer and perform call in AL
 11518                                  ;
 11519                                  ;	ENTRY	(AL) = DOS function to be called after flush (1,6,7,8,10)
 11520                                  ;	EXIT	(al) = 0 iff (al) was not one of the supported fcns
 11521                                  ;		return arguments for the fcn supplied in (AL)
 11522                                  ;	USES	all
 11523                                  ;
 11524                                  ;----------------------------------------------------------------------------
 11525                                  ;
 11526                                  
 11527                                  _$STD_CON_INPUT_FLUSH:		;System call 12
 11528                                  
 11529 00001724 50                      	PUSH	AX
 11530 00001725 52                      	PUSH	DX
 11531 00001726 31DB                    	XOR	BX,BX
 11532 00001728 E8171E                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 11533                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 11534 0000172B 7205                    	JC	SHORT BADJFNCON
 11535 0000172D B404                    	MOV	AH,4
 11536 0000172F E80A2C                  	CALL	IOFUNC
 11537                                  
 11538                                  BADJFNCON:
 11539 00001732 5A                      	POP	DX
 11540 00001733 58                      	POP	AX
 11541 00001734 88C4                    	MOV	AH,AL
 11542 00001736 3C01                    	CMP	AL,1
 11543 00001738 7413                    	JZ	SHORT REDISPJ
 11544 0000173A 3C06                    	CMP	AL,6
 11545 0000173C 740F                    	JZ	SHORT REDISPJ
 11546 0000173E 3C07                    	CMP	AL,7
 11547 00001740 740B                    	JZ	SHORT REDISPJ
 11548 00001742 3C08                    	CMP	AL,8
 11549 00001744 7407                    	JZ	SHORT REDISPJ
 11550 00001746 3C0A                    	CMP	AL,10
 11551 00001748 7403                    	JZ	SHORT REDISPJ
 11552 0000174A B000                    	MOV	AL,0
 11553 0000174C C3                      	RETN
 11554                                  
 11555                                  REDISPJ:
 11556 0000174D FA                      	CLI
 11557                                  	;transfer REDISP
 11558 0000174E E937EC                  	JMP	REDISP
 11559                                  
 11560                                  ;============================================================================
 11561                                  ; FCBIO.ASM, MSDOS 6.0, 1991
 11562                                  ;============================================================================
 11563                                  ; 20/07/2018 - Retro DOS v3.0
 11564                                  ; 17/05/2019 - Retro DOS v4.0
 11565                                  
 11566                                  ;**	FCBIO.ASM - Ancient 1.0 1.1 FCB system calls
 11567                                  ;
 11568                                  ;	$GET_FCB_POSITION
 11569                                  ;	$FCB_DELETE
 11570                                  ;	$GET_FCB_FILE_LENGTH
 11571                                  ;	$FCB_CLOSE
 11572                                  ;	$FCB_RENAME
 11573                                  ;	SaveFCBInfo
 11574                                  ;	ResetLRU
 11575                                  ;	SetOpenAge
 11576                                  ;	LRUFCB
 11577                                  ;	FCBRegen
 11578                                  ;	BlastSFT
 11579                                  ;	CheckFCB
 11580                                  ;	SFTFromFCB
 11581                                  ;	FCBHardErr
 11582                                  ;
 11583                                  ;	Revision history:
 11584                                  ;
 11585                                  ;		Created: ARR 4 April 1983"
 11586                                  ;			 MZ  6 June  1983 completion of functions
 11587                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 11588                                  ;					  times.  Change so successive closes work by
 11589                                  ;					  always returning OK.	Also, detect I/O to
 11590                                  ;					  already closed FCB and return EOF.
 11591                                  ;			 MZ 16 Jan   1984 More braindamage.  Need to separate info
 11592                                  ;					  out of sft into FCB for reconnection
 11593                                  ;
 11594                                  ;		A000	 version 4.00  Jan. 1988
 11595                                  
 11596                                  ;Break <$Get_FCB_Position - set random record fields to current pos>
 11597                                  ;----------------------------------------------------------------------------
 11598                                  ;
 11599                                  ;   $Get_FCB_Position - look at an FCB, retrieve the current position from the
 11600                                  ;	extent and next record field and set the random record field to point
 11601                                  ;	to that record
 11602                                  ;
 11603                                  ;   Inputs:	DS:DX point to a possible extended FCB
 11604                                  ;   Outputs:	The random record field of the FCB is set to the current record
 11605                                  ;   Registers modified: all
 11606                                  ;
 11607                                  ;----------------------------------------------------------------------------
 11608                                  ;
 11609                                  
 11610                                  _$GET_FCB_POSITION:
 11611 00001751 E8C904                  	call	GetExtended		; point to FCB
 11612 00001754 E89A04                  	call	GetExtent		; DX:AX is current record
 11613                                  	;mov	[si+21h],ax
 11614 00001757 894421                  	MOV	[SI+SYS_FCB.RR],AX 	; drop in low order piece
 11615                                  	;mov	[si+23h],dl
 11616 0000175A 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; drop in high order piece
 11617                                  	;cmp	word [si+0Eh],64
 11618 0000175D 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 11619 00001761 7303                    	JAE	short GetFCBBye
 11620                                  	;mov	[si+24h],dh
 11621 00001763 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 11622                                  GoodPath:	; 16/12/2022
 11623                                  GetFCBBye:
 11624 00001766 E9E4EE                  	jmp	FCB_RET_OK
 11625                                  
 11626                                  ;Break <$FCB_Delete - remove several files that match the input FCB>
 11627                                  ;----------------------------------------------------------------------------
 11628                                  ;
 11629                                  ;**	$FCB_Delete - Delete from FCB Template
 11630                                  ;
 11631                                  ;	given an FCB, remove all directory entries in the current
 11632                                  ;	directory that have names that match the FCB's ?  marks.
 11633                                  ;
 11634                                  ;	ENTRY	(DS:DX) = address of FCB
 11635                                  ;	EXIT	entries matching the FCB are deleted
 11636                                  ;		(al) = ff iff no entries were deleted
 11637                                  ;	USES	all
 11638                                  ;
 11639                                  ;----------------------------------------------------------------------------
 11640                                  ;
 11641                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11642                                  
 11643                                  _$FCB_DELETE:		; System call 19
 11644                                  					; OpenBuf is in DOSDATA
 11645 00001769 BF[BE03]                	MOV	DI,OPENBUF 		; appropriate place 
 11646                                  
 11647 0000176C E8DA51                  	call	TransFCB		; convert FCB to path
 11648 0000176F 7207                    	JC	short BadPath 		; signal no deletions
 11649                                  
 11650 00001771 16                      	push	SS
 11651 00001772 1F                      	pop	DS			; SS is DOSDATA
 11652                                  
 11653 00001773 E82B0D                  	call	DOS_DELETE		; wham
 11654                                  	;JC	short BadPath
 11655                                  	; 16/12/2022
 11656 00001776 73EE                    	jnc 	short GoodPath
 11657                                  ;GoodPath:
 11658                                  ;	;jmp	FCB_RET_OK		; do a good return
 11659                                  ;	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11660                                  ;	jmp	short GetFCBBye
 11661                                  
 11662                                  BadPath:
 11663                                  	; Error code is in AX
 11664                                  
 11665 00001778 E9D5EE                  	jmp	FCB_RET_ERR		; let someone else signal the error
 11666                                  
 11667                                  ;Break <$Get_FCB_File_Length - return the length of a file>
 11668                                  ;----------------------------------------------------------------------------
 11669                                  ;
 11670                                  ;   $Get_FCB_File_Length - set the random record field to the length of the
 11671                                  ;	file in records (rounded up if partial).
 11672                                  ;
 11673                                  ;   Inputs:	DS:DX - point to a possible extended FCB
 11674                                  ;   Outputs:	Random record field updated to reflect the number of records
 11675                                  ;   Registers modified: all
 11676                                  ;
 11677                                  ;----------------------------------------------------------------------------
 11678                                  ;
 11679                                  	; 15/01/2024
 11680                                  
 11681                                  _$GET_FCB_FILE_LENGTH:
 11682                                  
 11683 0000177B E89F04                  	call	GetExtended		; get real FCB pointer
 11684                                  					; DX points to Input FCB
 11685                                  
 11686                                  					; OpenBuf is in DOSDATA
 11687 0000177E BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 11688                                  
 11689 00001781 1E                      	push	ds			; save pointer to true FCB
 11690 00001782 56                      	push	si
 11691 00001783 E8C351                  	call	TransFCB		; Trans name DS:DX, sets SATTRIB
 11692 00001786 5E                      	pop	si
 11693 00001787 1F                      	pop	ds
 11694 00001788 72EE                    	JC	short BadPath
 11695 0000178A 1E                      	push	ds			; save pointer
 11696 0000178B 56                      	push	si
 11697 0000178C 16                      	push	ss		
 11698 0000178D 1F                      	pop	ds
 11699 0000178E E8F610                  	call	GET_FILE_INFO		; grab the info
 11700 00001791 5E                      	pop	si			; get pointer back
 11701 00001792 1F                      	pop	ds
 11702 00001793 72E3                    	JC	short BadPath 		; invalid something
 11703                                  	; 15/01/2024
 11704                                  	;MOV	DX,BX (*)		; get high order size
 11705                                  	;MOV	AX,DI (**)		; get low order size
 11706 00001795 89D8                    	mov	ax,bx ; hw of file size
 11707                                  	;
 11708                                  	;mov	bx,[si+0Eh]
 11709 00001797 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 11710 0000179A 09DB                    	OR	BX,BX			; empty record => 0 size for file
 11711 0000179C 7502                    	JNZ	short GetSize 		; not empty
 11712                                  	;MOV	BX,128
 11713 0000179E B380                    	mov	bl,128	; 15/01/2024
 11714                                  GetSize:
 11715                                  	; 15/01/2024
 11716                                  	;MOV	DI,AX			; save low order word
 11717                                  	;MOV	AX,DX			; move high order for divide
 11718                                  	;xchg	ax,dx ; (*)
 11719                                  	; ax = hw of file size
 11720                                  
 11721 000017A0 31D2                    	XOR	DX,DX			; clear out high
 11722 000017A2 F7F3                    	DIV	BX			; wham
 11723 000017A4 50                      	PUSH	AX			; save dividend
 11724 000017A5 89F8                    	MOV	AX,DI ; (**)		; get low order piece
 11725 000017A7 F7F3                    	DIV	BX			; wham
 11726 000017A9 89D1                    	MOV	CX,DX			; save remainder
 11727 000017AB 5A                      	POP	DX			; get high order dividend
 11728 000017AC E306                    	JCXZ	LengthStore		; no roundup
 11729 000017AE 83C001                  	ADD	AX,1
 11730 000017B1 83D200                  	ADC	DX,0			; 32-bit increment
 11731                                  LengthStore:
 11732                                  	;mov	[si+21h],ax
 11733 000017B4 894421                  	MOV	[SI+SYS_FCB.RR],AX	; store low order
 11734                                  	;mov	[si+23h],dl
 11735 000017B7 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; store high order
 11736 000017BA 08F6                    	OR	DH,DH
 11737 000017BC 74A8                    	JZ	short GoodPath		; not storing insignificant zero
 11738                                  	;mov	[si+24h],dh
 11739 000017BE 887424                  	MOV	[SI+SYS_FCB.RR+3],DH	; save that high piece
 11740                                  	; 16/12/2022
 11741                                  GoodRet:
 11742                                  	;jmp	FCB_RET_OK
 11743 000017C1 EBA3                    	jmp	short GoodPath
 11744                                  
 11745                                  ;Break <$FCB_Close - close a file>
 11746                                  ;----------------------------------------------------------------------------
 11747                                  ;
 11748                                  ;   $FCB_Close - given an FCB, look up the SFN and close it. Do not free it
 11749                                  ;	as the FCB may be used for further I/O
 11750                                  ;
 11751                                  ;   Inputs:	DS:DX point to FCB
 11752                                  ;   Outputs:	AL = FF if file was not found on disk
 11753                                  ;   Registers modified: all
 11754                                  ;
 11755                                  ;----------------------------------------------------------------------------
 11756                                  ;
 11757                                  
 11758                                  	; 16/01/2024
 11759                                  
 11760                                  _$FCB_CLOSE:		; System call 16
 11761                                  
 11762 000017C3 30C0                    	XOR	AL,AL			; default search attributes
 11763 000017C5 E85504                  	call	GetExtended		; DS:SI point to real FCB
 11764 000017C8 7403                    	JZ	short NoAttr		; not extended
 11765 000017CA 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 11766                                  NoAttr:
 11767                                  					; SS override
 11768 000017CD 36A2[6B05]              	MOV	[SS:ATTRIB],AL		; stash away found attributes
 11769 000017D1 E8B803                  	call	SFTFromFCB
 11770 000017D4 72EB                    	JC	short GoodRet 		; MZ 16 Jan Assume death
 11771                                  
 11772                                  	; If the sharer is present, then the SFT is not regenable. Thus, 
 11773                                  	; there is no need to set the SFT's attribute.
 11774                                  
 11775                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 11776                                  	;;; done
 11777                                  
 11778                                  	;mov	al,[es:di+4]
 11779 000017D6 268A4504                	MOV	AL,[ES:DI+SF_ENTRY.sf_attr]
 11780 000017DA 30E4                    	XOR	AH,AH
 11781 000017DC 50                      	PUSH	AX
 11782                                  
 11783                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 11784                                  	;;; done
 11785                                  
 11786 000017DD E85D59                  	call	CheckShare
 11787 000017E0 7508                    	JNZ	short NoStash
 11788 000017E2 36A0[6B05]              	MOV	AL,[SS:ATTRIB]
 11789                                  	;mov	[es:di+4],al
 11790 000017E6 26884504                	MOV	[ES:DI+SF_ENTRY.sf_attr],AL ; attempted attribute for close
 11791                                  NoStash:
 11792                                  
 11793                                  ; 16/01/2024
 11794                                  %if 0
 11795                                  	;mov	ax,[si+14h]
 11796                                  	MOV	AX,[SI+SYS_FCB.FDATE] ; move in the time and date
 11797                                  	;mov	[es:di+0Fh],ax
 11798                                  	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 11799                                  	;mov	ax,[si+16h]
 11800                                  	MOV	AX,[SI+SYS_FCB.FTIME]
 11801                                  	;mov	[es:di+0Dh],ax
 11802                                  	MOV	[ES:DI+SF_ENTRY.sf_time],AX
 11803                                  	;mov	ax,[si+10h]
 11804                                  	MOV	AX,[SI+SYS_FCB.FILSIZ]
 11805                                  	;mov	[es:di+11h],ax
 11806                                  	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 11807                                  	;mov	ax,[si+12h]
 11808                                  	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 11809                                  	;mov	[es:di+13h],ax
 11810                                  	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 11811                                  	;or	word [es:di+5],4000h
 11812                                  	; 17/12/2022
 11813                                  	or	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8) ; 40h
 11814                                  	;OR	word [ES:DI+SF_ENTRY.sf_flags],sf_close_nodate
 11815                                  %else
 11816                                  	; 16/01/2024 (PCDOS 7.1 IBMDOS.COM)
 11817 000017EA 1E                      	push	ds
 11818                                  	;lds	ax,[si+14h]
 11819 000017EB C54414                  	lds	ax,[si+SYS_FCB.FDATE]	; move in the time and date
 11820                                  	;mov	[es:di+0Fh],ax
 11821 000017EE 2689450F                	mov	[es:di+SF_ENTRY.sf_date],ax
 11822                                  	;mov	[es:di+0Dh],ds		
 11823 000017F2 268C5D0D                	mov	[es:di+SF_ENTRY.sf_time],ds
 11824 000017F6 1F                      	pop	ds
 11825                                  	;lds	ax,[si+10h]
 11826 000017F7 C54410                  	lds	ax,[si+SYS_FCB.FILSIZ]
 11827                                  	;mov	[es:di+11h],ax
 11828 000017FA 26894511                	mov	[es:di+SF_ENTRY.sf_size],ax
 11829                                  	;mov	[es:di+13h],ds
 11830 000017FE 268C5D13                	mov	[es:di+SF_ENTRY.sf_size+2],ds
 11831                                  	; 16/01/2024
 11832                                  	;;or	word [es:di+5],4000h
 11833                                  	;or	word [es:di+SF_ENTRY.sf_flags],sf_close_nodate
 11834 00001802 26804D0640              	or	byte [es:di+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8) ; 40h
 11835                                  %endif
 11836                                  
 11837 00001807 16                      	push	ss
 11838 00001808 1F                      	pop	ds
 11839 00001809 E85F16                  	call	DOS_CLOSE	; wham
 11840 0000180C C43E[9E05]              	LES	DI,[THISSFT]
 11841                                  
 11842                                  	;;; 9/8/86 F.C. restore SFT attribute
 11843 00001810 59                      	POP	CX
 11844                                  	;mov	[es:di+4],cl
 11845 00001811 26884D04                	MOV	[ES:DI+SF_ENTRY.sf_attr],CL
 11846                                  	;;; 9/8/86 F.C. restore SFT attribute
 11847                                  
 11848 00001815 9C                      	PUSHF
 11849                                  	;test	word [es:di],0FFFFh
 11850                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],0
 11851                                  				; zero ref count gets blasted
 11852 00001816 26833D00                	cmp	word [ES:DI],0
 11853 0000181A 7507                    	jnz     short CloseOK
 11854 0000181C 50                      	PUSH	AX
 11855 0000181D B04D                    	MOV	AL,'M' ; 4Dh
 11856 0000181F E8E802                  	call	BlastSFT
 11857 00001822 58                      	POP	AX
 11858                                  CloseOK:
 11859 00001823 9D                      	POPF
 11860 00001824 739B                    	JNC	short GoodRet
 11861                                  	;cmp	al,6
 11862 00001826 3C06                    	CMP	AL,error_invalid_handle
 11863 00001828 7497                    	JZ	short GoodRet
 11864                                  	;mov	al,2
 11865 0000182A B002                    	MOV	AL,error_file_not_found
 11866                                  fren90:
 11867                                  	; 16/12/2022
 11868                                  fcb_close_err:
 11869 0000182C E921EE                  	jmp	FCB_RET_ERR
 11870                                  
 11871                                  ;
 11872                                  ;----------------------------------------------------------------------------
 11873                                  ;
 11874                                  ;**	$FCB_Rename - Rename a File
 11875                                  ;
 11876                                  ;	$FCB_Rename - rename a file in place within a directory. Renames
 11877                                  ;	multiple files copying from the meta characters.
 11878                                  ;
 11879                                  ;	ENTRY	DS:DX point to an FCB. The normal name field is the source
 11880                                  ;		    name of the files to be renamed. Starting at offset 11h
 11881                                  ;		    in the FCB is the destination name.
 11882                                  ;	EXIT	AL = 0 -> no error occurred and all files were renamed
 11883                                  ;		AL = FF -> some files may have been renamed but:
 11884                                  ;			rename to existing file or source file not found
 11885                                  ;	USES	ALL
 11886                                  ;
 11887                                  ;----------------------------------------------------------------------------
 11888                                  ;
 11889                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11890                                  
 11891                                  _$FCB_RENAME:		; System call 23
 11892                                  
 11893 0000182F E8EB03                  	call	GetExtended		; get pointer to real FCB
 11894 00001832 52                      	push	dx
 11895 00001833 8A04                    	MOV	AL,[SI] 		; get drive byte
 11896 00001835 83C610                  	ADD	SI,10h			; point to destination
 11897                                  
 11898                                  					; RenBuf is in DOSDATA
 11899 00001838 BF[3E04]                	MOV	DI,RENBUF		; point to destination buffer
 11900 0000183B FF34                    	push	word [SI]
 11901 0000183D 1E                      	push	ds
 11902                                  	;push	di			; save source pointer for TransFCB
 11903                                  	; 16/01/2024 - BugFix !
 11904 0000183E 56                      	push	si
 11905 0000183F 8804                    	MOV	[SI],AL			; drop in real drive
 11906 00001841 89F2                    	MOV	DX,SI			; let TransFCB know where the FCB is
 11907 00001843 E80351                  	call	TransFCB		; munch this pathname
 11908 00001846 5E                      	pop	si
 11909 00001847 1F                      	pop	ds	
 11910 00001848 8F04                    	pop	WORD [SI]		; get path back
 11911 0000184A 5A                      	pop	dx			; Original FCB pointer
 11912 0000184B 72DF                    	JC	short fren90		; bad path -> error
 11913                                  
 11914                                  					; SS override for WFP_Start & Ren_WFP
 11915 0000184D 368B36[B205]            	MOV	SI,[ss:WFP_START]	; get pointer
 11916 00001852 368936[B405]            	MOV	[ss:REN_WFP],SI		; stash it
 11917                                  
 11918                                  					; OpenBuf is in DOSDATA
 11919 00001857 BF[BE03]                	MOV	DI,OPENBUF		; appropriate spot
 11920 0000185A E8EC50                  	call	TransFCB		; wham
 11921                                  					; NOTE that this call is pointing
 11922                                  					;  back to the ORIGINAL FCB so
 11923                                  					;  SATTRIB gets set correctly
 11924 0000185D 72CD                    	JC	short fren90		; error
 11925 0000185F E8130E                  	call	DOS_RENAME
 11926 00001862 72C8                    	JC	short fren90
 11927                                  	; 16/12/2022
 11928 00001864 E9E6ED                  	jmp	FCB_RET_OK
 11929                                  	
 11930                                  ;	Error -
 11931                                  ;
 11932                                  ;	(al) = error code
 11933                                  
 11934                                  	; 16/12/2022
 11935                                  ;fren90:	
 11936                                  ;	;jmp	FCB_RET_ERR
 11937                                  ;	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11938                                  ;	jmp	short fcb_close_err
 11939                                  
 11940                                  ;Break <Misbehavior fixers>
 11941                                  ;
 11942                                  ;   FCBs suffer from several problems. First, they are maintained in the
 11943                                  ;   user's space so he may move them at will. Second, they have a small
 11944                                  ;   reserved area that may be used for system information. Third, there was
 11945                                  ;   never any "rules for behavior" for FCBs; there was no protocol for their
 11946                                  ;   usage.
 11947                                  ;
 11948                                  ;   This results in the following misbehavior:
 11949                                  ;
 11950                                  ;	infinite opens of the same file:
 11951                                  ;
 11952                                  ;	While (TRUE) {			While (TRUE) {
 11953                                  ;	    FCBOpen (FCB);		    FCBOpen (FCB);
 11954                                  ;	    Read (FCB); 		    Write (FCB);
 11955                                  ;	    }				    }
 11956                                  ;
 11957                                  ;	infinite opens of different files:
 11958                                  ;
 11959                                  ;	While (TRUE) {			While (TRUE) {
 11960                                  ;	    FCBOpen (FCB[i++]); 	    FCBOpen (FCB[i++]);
 11961                                  ;	    Read (FCB); 		    Write (FCB);
 11962                                  ;	    }				    }
 11963                                  ;
 11964                                  ;	multiple closes of the same file:
 11965                                  ;
 11966                                  ;	FCBOpen (FCB);
 11967                                  ;	while (TRUE)
 11968                                  ;	    FCBClose (FCB);
 11969                                  ;
 11970                                  ;	I/O after closing file:
 11971                                  ;
 11972                                  ;	FCBOpen (FCB);
 11973                                  ;	while (TRUE) {
 11974                                  ;	    FCBWrite (FCB);
 11975                                  ;	    FCBClose (FCB);
 11976                                  ;	    }
 11977                                  ;
 11978                                  ;   The following is am implementation of a methodology for emulating the
 11979                                  ;   above with the exception of I/O after close. We are NOT attempting to
 11980                                  ;   resolve that particular misbehavior. We will enforce correct behaviour in
 11981                                  ;   FCBs when they refer to a network file or when there is file sharing on
 11982                                  ;   the local machine.
 11983                                  ;
 11984                                  ;   The reserved fields of the FCB (10 bytes worth) is divided up into various
 11985                                  ;   structures depending on the file itself and the state of operations of the
 11986                                  ;   OS. The information contained in this reserved field is enough to
 11987                                  ;   regenerate the SFT for the local non-shared file. It is assumed that this
 11988                                  ;   regeneration procedure may be expensive. The SFT for the FCB is
 11989                                  ;   maintained in a LRU cache as the ONLY performance inprovement.
 11990                                  ;
 11991                                  ;   No regeneration of SFTs is attempted for network FCBs.
 11992                                  ;
 11993                                  ;   To regenerate the SFT for a local FCB, it is necessary to determine if the
 11994                                  ;   file sharer is working. If the file sharer is present then the SFT is not
 11995                                  ;   regenerated.
 11996                                  ;
 11997                                  ;   Finally, if there is no local sharing, the full name of the file is no
 11998                                  ;   longer available. We can make up for this by using the following
 11999                                  ;   information:
 12000                                  ;
 12001                                  ;	The Drive number (from the DPB).
 12002                                  ;	The physical sector of the directory that contains the entry.
 12003                                  ;	The relative position of the entry in the sector.
 12004                                  ;	The first cluster field.
 12005                                  ;	The last used SFT.
 12006                                  ;      OR In the case of a device FCB
 12007                                  ;	The low 6 bits of sf_flags (indicating device type)
 12008                                  ;	The pointer to the device header
 12009                                  ;
 12010                                  ;   We read in the particular directory sector and examine the indicated
 12011                                  ;   directory entry. If it matches, then we are kosher; otherwise, we fail.
 12012                                  ;
 12013                                  ;   Some key items need to be remembered:
 12014                                  ;
 12015                                  ;	Even though we are caching SFTs, they may contain useful sharing
 12016                                  ;	information. We enforce good behavior on the FCBs.
 12017                                  ;
 12018                                  ;	Network support must not treat FCBs as impacting the ref counts on
 12019                                  ;	open VCs. The VCs may be closed only at process termination.
 12020                                  ;
 12021                                  ;	If this is not an installed version of the DOS, file sharing will
 12022                                  ;	always be present.
 12023                                  ;
 12024                                  ;	We MUST always initialize lstclus to = firclus when regenerating a
 12025                                  ;	file. Otherwise we start allocating clusters up the wazoo.
 12026                                  ;
 12027                                  ;	Always initialize, during regeneration, the mode field to both isFCB
 12028                                  ;	and open_for_both. This is so the FCB code in the sharer can find the
 12029                                  ;	proper OI record.
 12030                                  ;
 12031                                  ;   The test bits are:
 12032                                  ;
 12033                                  ;	00 -> local file
 12034                                  ;	40 -> sharing local
 12035                                  ;	80 -> network
 12036                                  ;	C0 -> local device
 12037                                  
 12038                                  ;Break	<SaveFCBInfo - store pertinent information from an SFT into the FCB>
 12039                                  ;----------------------------------------------------------------------------
 12040                                  ;
 12041                                  ;   SaveFCBInfo - given an FCB and its associated SFT, copy the relevant
 12042                                  ;	pieces of information into the FCB to allow for subsequent
 12043                                  ;	regeneration. Poke LRU also.
 12044                                  ;
 12045                                  ;   Inputs:	ThisSFT points to a complete SFT.
 12046                                  ;		DS:SI point to the FCB (not an extended one)
 12047                                  ;   Outputs:	The relevant reserved fields in the FCB are filled in.
 12048                                  ;		DS:SI preserved
 12049                                  ;		ES:DI point to sft
 12050                                  ;   Registers modified: All
 12051                                  ;
 12052                                  ;
 12053                                  ;----------------------------------------------------------------------------
 12054                                  ;
 12055                                  
 12056                                  	; 20/01/2024
 12057                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12058                                  
 12059                                  SaveFCBInfo:
 12060                                  
 12061 00001867 36C43E[9E05]            	LES	DI,[SS:THISSFT]		; SS override
 12062 0000186C E8D3F9                  	call	IsSFTNet
 12063 0000186F 740B                    	JZ	short SaveLocal		; if not network then save local info
 12064                                  ;
 12065                                  ;----- In net support -----
 12066                                  ;
 12067                                  	; 17/05/2019 - Retro DOS v4.0
 12068                                  
 12069                                  	; MSDOS 3.3
 12070                                  	;;mov	ax,[es:di+1Dh]
 12071                                  	;mov	ax,[es:di+SF_ENTRY.sf_dirsec]
 12072                                  	;;mov	[si+1Ah],ax
 12073                                  	;mov	[si+fcb_net_handle],ax
 12074                                  	;push	es
 12075                                  	;push	di
 12076                                  	;;les	di,[es:di+19h]
 12077                                  	;LES	DI,[ES:DI+sf_netid]
 12078                                  	;;mov	[si+1Ch],di
 12079                                  	;MOV	[SI+fcb_netID],DI	; save net ID
 12080                                  	;;mov 	[si+1Eh],es
 12081                                  	;MOV	[SI+fcb_netID+2],ES
 12082                                  	;pop	di
 12083                                  	;pop	es
 12084                                  
 12085                                  	; MSDOS 6.0
 12086                                  	;mov	ax,[es:di+0Bh]
 12087 00001871 268B450B                	MOV	AX,[ES:DI+sf_serial_ID] ;AN000;;IFS. save IFS ID
 12088                                  	;mov	[si+1Ch],ax
 12089 00001875 89441C                  	MOV	[SI+fcb_netID],ax	;AN000;;IFS.
 12090                                  	
 12091                                  	;mov	bl,80h
 12092 00001878 B380                    	MOV	BL,FCBNETWORK
 12093                                  ;
 12094                                  ;----- END In net support -----
 12095                                  ;
 12096 0000187A EB63                    	jmp	SHORT SaveSFN
 12097                                  
 12098                                  SaveLocal:
 12099                                  	;IF	Installed
 12100 0000187C E8BE58                  	call	CheckShare
 12101                                  	;JZ	short SaveNoShare	; no sharer
 12102                                  	;JMP	short SaveShare		; sharer present
 12103                                  	; 16/12/2022
 12104                                  	; 28/07/2019
 12105 0000187F 7559                    	jnz	short SaveShare
 12106                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12107                                  	;JZ	short SaveNoShare	; no sharer
 12108                                  	;JMP	short SaveShare		; sharer present
 12109                                  
 12110                                  SaveNoShare:
 12111                                  	;;test 	word [es:di+5],80h
 12112                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 12113 00001881 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; 80h	
 12114 00001886 7542                    	JNZ	short SaveNoShareDev	; Device
 12115                                  
 12116                                  	; Save no sharing local file information
 12117                                  
 12118                                  	;;mov	ax,[es:di+1Dh]  ; MSDOS 3.3
 12119                                  	;mov	ax,[es:di+1Bh]  ; MSDOS 6.0
 12120 00001888 268B451B                	MOV	AX,[ES:DI+SF_ENTRY.sf_dirsec] ; get directory sector F.C.
 12121                                  	;mov	[si+1Dh],ax
 12122 0000188C 89441D                  	MOV	[SI+fcb_nsl_dirsec],AX
 12123                                  
 12124                                  	; MSDOS 6.0
 12125                                  
 12126                                  	;SR; Store high byte of directory sector
 12127                                  	;mov	ax,[es:di+1Dh]
 12128 0000188F 268B451D                	mov	ax,[es:di+SF_ENTRY.sf_dirsec+2] ; get high word
 12129                                  	
 12130                                  	; SR;
 12131                                  	; We have to store the read-only and archive attributes of the file.
 12132                                  	; We extract it from the SFT and store it in the top two bits of the 
 12133                                  	; sector number ( sector number == 22 bits only )
 12134                                  
 12135                                  	;mov	bl,[es:di+4]
 12136 00001893 268A5D04                	mov	bl,[es:di+SF_ENTRY.sf_attr]
 12137 00001897 88DF                    	mov	bh,bl
 12138 00001899 D0CB                    	ror	bl,1
 12139 0000189B D0E7                    	shl	bh,1
 12140 0000189D 08FB                    	or	bl,bh
 12141 0000189F 80E3C0                  	and	bl,0C0h
 12142 000018A2 08D8                    	or	al,bl
 12143                                  	;mov	[si+18h],al ; 08/11/2022
 12144 000018A4 884418                  	mov	[si+fcb_sfn],al	; sector number = 22 bits
 12145                                  
 12146                                  	; MSDOS 6.0 (& MSDOS 3.3)
 12147                                  	;mov	al,[es:di+1Fh]
 12148 000018A7 268A451F                	MOV	AL,[ES:DI+SF_ENTRY.sf_dirpos] ; location in sector
 12149                                  	;mov	[si+1Fh],al
 12150 000018AB 88441F                  	MOV	[SI+fcb_nsl_dirpos],AL
 12151                                  	;mov	ax,[es:di+0Bh]
 12152 000018AE 268B450B                	MOV	AX,[ES:DI+SF_ENTRY.sf_firclus] ; first cluster
 12153                                  	;mov	[si+1Bh],ax
 12154 000018B2 89441B                  	MOV	[SI+fcb_nsl_firclus],AX
 12155 000018B5 B300                    	MOV	BL,0
 12156                                  
 12157                                  	; Create the bits field from the dirty/device bits of the flags word 
 12158                                  	; and the mode byte
 12159                                  
 12160                                  SetFCBBits:
 12161                                  	;mov	ax,[es:di+5]
 12162 000018B7 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 12163 000018BB 24C0                    	AND	AL,0C0h 		; mask off drive bits
 12164                                  	;or	al,[es:di+2]
 12165 000018BD 260A4502                	OR	AL,[ES:DI+SF_ENTRY.sf_mode] ; stick in open mode
 12166                                  	;mov	[si+1Ah], al
 12167 000018C1 88441A                  	MOV	[SI+fcb_nsl_bits],AL	; save dirty info
 12168                                  
 12169                                  	; MSDOS 6.0
 12170                                  	
 12171                                  	; SR;
 12172                                  	; Check if we came here for local file or device. If for local file, 
 12173                                  	; skip setting of SFT index
 12174                                  	
 12175 000018C4 08DB                    	or	bl,bl
 12176 000018C6 7428                    	jz	short SaveNoSFN		; do not save SFN if local file
 12177                                  
 12178 000018C8 EB15                    	JMP	short SaveSFN 		; go and save SFN
 12179                                  
 12180                                  	; Save no sharing local device information
 12181                                  
 12182                                  SaveNoShareDev:
 12183                                  	; 20/01/2024
 12184                                  	;;mov	ax,[es:di+7]
 12185                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_devptr]
 12186                                  	;;mov	[si+1Ah],ax
 12187                                  	;MOV	[SI+fcb_nsld_drvptr],AX
 12188                                  	;;mov	ax,[es:di+9]
 12189                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_devptr+2]
 12190                                  	;MOV	[SI+fcb_nsld_drvptr+2],AX
 12191                                  	; 20/01/2024 (PCDOS 7.1 IBMDOS.COM)
 12192 000018CA 06                      	push	es
 12193 000018CB 26C44507                	les	ax,[es:di+SF_ENTRY.sf_devptr]
 12194 000018CF 89441A                  	mov	[si+fcb_nsld_drvptr],ax
 12195 000018D2 8C441C                  	mov	[si+fcb_nsld_drvptr+2],es
 12196 000018D5 07                      	pop	es
 12197                                  	
 12198                                  	;mov	bl,40h
 12199 000018D6 B340                    	MOV	BL,FCBDEVICE
 12200                                  	; 28/12/2022
 12201 000018D8 EBDD                    	JMP	short SetFCBBits	; go and save SFN
 12202                                  
 12203                                  SaveShare:
 12204                                  	;ENDIF
 12205                                  
 12206                                  ;----- In share support -----
 12207                                  
 12208                                  	;call	far [ss:ShSave]
 12209 000018DA 36FF1E[B800]            	Call	far [ss:JShare+(10*4)] ; 10 = ShSave ; SS Override
 12210                                  
 12211                                  ;----- end in share support -----
 12212                                  
 12213                                  	; 17/05/2019
 12214                                  
 12215                                  SaveSFN:
 12216                                  	;lea	ax,[di-6]
 12217 000018DF 8D45FA                  	LEA	AX,[DI-SFT.SFTable]
 12218                                  	
 12219                                  	; Adjust for offset to table.
 12220                                  	
 12221 000018E2 362B06[4000]            	SUB	AX,[SS:SFTFCB]		; SS override for SftFCB
 12222                                  
 12223 000018E7 53                      	push	bx			;bx = FCB type (net/Share or local)
 12224                                  	;;mov	bl,53 ; MSDOS 3.3
 12225                                  	;mov	bl,59 ; MSDOS 6.0
 12226 000018E8 B33B                    	MOV	BL,SF_ENTRY.size
 12227 000018EA F6F3                    	DIV	BL
 12228                                  	;mov	[si+18h],al
 12229 000018EC 884418                  	MOV	[SI+fcb_sfn],AL		; last used SFN
 12230 000018EF 5B                      	pop	bx			;restore bx
 12231                                  
 12232                                  SaveNoSFN:
 12233                                  	;mov	ax,[es:di+5]
 12234 000018F0 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 12235 000018F4 243F                    	AND	AL,3Fh			; get real drive
 12236 000018F6 08D8                    	OR	AL,BL
 12237                                  	;mov	[si+19h],al
 12238 000018F8 884419                  	MOV	[SI+fcb_l_drive],AL
 12239                                  
 12240 000018FB 36A1[1000]              	MOV	AX,[SS:FCBLRU]		; get lru count
 12241 000018FF 40                      	INC	AX
 12242                                  	;mov	[es:di+15h],ax
 12243 00001900 26894515                	MOV	[ES:DI+sf_LRU],AX
 12244 00001904 7506                    	JNZ	short SimpleStuff
 12245                                  	
 12246                                  	; lru flag overflowed. Run through all FCB sfts and adjust:  
 12247                                  	; LRU < 8000H get set to 0. Others -= 8000h. This LRU = 8000h
 12248                                  	
 12249                                  	;mov	bx,15h
 12250 00001906 BB1500                  	MOV	BX,SF_ENTRY.sf_position
 12251 00001909 E80500                  	call	ResetLRU
 12252                                  
 12253                                  	; Set new LRU to AX
 12254                                  SimpleStuff:
 12255 0000190C 36A3[1000]              	MOV	[SS:FCBLRU],AX
 12256 00001910 C3                      	retn
 12257                                  
 12258                                  ;Break	<ResetLRU - reset overflowed lru counts>
 12259                                  ;----------------------------------------------------------------------------
 12260                                  ;
 12261                                  ;   ResetLRU - during lru updates, we may wrap at 64K. We must walk the
 12262                                  ;   entire set of SFTs and subtract 8000h from their lru counts and truncate
 12263                                  ;   at 0.
 12264                                  ;
 12265                                  ;   Inputs:	BX is offset into SFT field where lru firld is kept
 12266                                  ;		ES:DI point to SFT currently being updated
 12267                                  ;   Outputs:	All FCB SFTs have their lru fields truncated
 12268                                  ;		AX has 8000h
 12269                                  ;   Registers modified: none
 12270                                  ;
 12271                                  ;----------------------------------------------------------------------------
 12272                                  ;
 12273                                  
 12274                                  	; 17/05/2019 - Retro DOS v4.0
 12275                                  ResetLRU:
 12276                                  	; ResetLRU is only called from fcbio.asm. So SS can be assumed to be 
 12277                                  	; DOSDATA
 12278                                  
 12279 00001911 B80080                  	MOV	AX,8000h
 12280 00001914 06                      	push	es
 12281 00001915 57                      	push	di
 12282                                  	;LES	DI,[CS:SFTFCB]		; get pointer to head
 12283 00001916 36C43E[4000]            	LES	DI,[SS:SFTFCB] ; MSDOS 6.0
 12284                                  	;mov	cx,[es:di+4]
 12285 0000191B 268B4D04                	MOV	CX,[ES:DI+SFT.SFCount]
 12286                                  	;lea	di,[di+6]
 12287 0000191F 8D7D06                  	LEA	DI,[DI+SFT.SFTable] 	; point at table
 12288                                  ovScan:
 12289 00001922 262901                  	SUB	[ES:DI+BX],AX		; decrement lru count
 12290 00001925 7703                    	JA	short ovLoop
 12291 00001927 268901                  	MOV	[ES:DI+BX],AX		; truncate at 0
 12292                                  ovLoop:
 12293                                  	;;add	di,53	; MSDOS 3.3
 12294                                  	;add	di,59	; MSDOS 6.0	
 12295 0000192A 83C73B                  	ADD	DI,SF_ENTRY.size	; advance to next
 12296 0000192D E2F3                    	LOOP	ovScan
 12297 0000192F 5F                      	pop	di
 12298 00001930 07                      	pop	es
 12299 00001931 268901                  	MOV	[ES:DI+BX],AX
 12300 00001934 C3                      	retn
 12301                                  
 12302                                  ;IF  0  ; We dont need this routine any more.
 12303                                  ;
 12304                                  ;Break	<SetOpenAge - update the open age of a SFT>
 12305                                  ;----------------------------------------------------------------------------
 12306                                  ;
 12307                                  ;   SetOpenAge - In order to maintain the first N open files in the FCB cache,
 12308                                  ;   we keep the 'open age' or an LRU count based on opens. We update the
 12309                                  ;   count here and fill in the appropriate field.
 12310                                  ;
 12311                                  ;   Inputs:	ES:DI point to SFT
 12312                                  ;   Outputs:	ES:DI has the open age field filled in.
 12313                                  ;		If open age has wraparound, we will have subtracted 8000h
 12314                                  ;		    from all open ages.
 12315                                  ;   Registers modified: AX
 12316                                  ;
 12317                                  ;----------------------------------------------------------------------------
 12318                                  ;
 12319                                  ;SetOpenAge:
 12320                                  ;	; 20/07/2018 - Retro DOS v3.0
 12321                                  ;	; MSDOS 3.3 - IBMDOS.COM, Offset 2597h 
 12322                                  ;	; (& MSDOS 6.0, FCBIO.ASM)
 12323                                  ;
 12324                                  ;	; SetOpenAge is called from fcbio2.asm. SS can be assumed to be valid.
 12325                                  ;
 12326                                  ;	MOV	AX,[CS:OpenLRU]	; SS override
 12327                                  ;	INC	AX
 12328                                  ;	;mov	[es:di+17h],ax
 12329                                  ;	MOV	[ES:DI+sf_OpenAge],AX
 12330                                  ;	JNZ	short SetDone
 12331                                  ;	;mov	bx,17h
 12332                                  ;	MOV	BX,SF_ENTRY.sf_position+2 ; mov bx,sf_OpenAge
 12333                                  ;	call	ResetLRU
 12334                                  ;SetDone:
 12335                                  ;	MOV	[CS:OpenLRU],AX
 12336                                  ;	retn
 12337                                  ;
 12338                                  ;ENDIF	; SetOpenAge no longer needed
 12339                                  
 12340                                  ; 21/07/2018 - Retro DOS v3.0
 12341                                  ; LRUFCB for MSDOS 6.0 !
 12342                                  
 12343                                  ;Break	<LRUFCB - perform LRU on FCB sfts>
 12344                                  ;----------------------------------------------------------------------------
 12345                                  ;
 12346                                  ;   LRUFCB - find LRU fcb in cache. Set ThisSFT and return it. We preserve
 12347                                  ;	the first keepcount sfts if they are network sfts or if sharing is
 12348                                  ;	loaded.  If carry is set then NO BLASTING is NECESSARY.
 12349                                  ;
 12350                                  ;   Inputs:	none
 12351                                  ;   Outputs:	ES:DI point to SFT
 12352                                  ;		ThisSFT points to SFT
 12353                                  ;		SFT is zeroed
 12354                                  ;		Carry set of closes failed
 12355                                  ;   Registers modified: none
 12356                                  ;
 12357                                  ;----------------------------------------------------------------------------
 12358                                  ;
 12359                                  ; MSDOS 6.0
 12360                                  ;IF 0	; rewritten this routine
 12361                                  ;
 12362                                  ;LRUFCB: ; MSDOS 3.3 - IBMDOS.COM (1987) - Offset 25ADh
 12363                                  ;	call	save_world
 12364                                  ;	
 12365                                  ; Find nth oldest NET/SHARE FCB. We want to find its age for the second scan
 12366                                  ; to find the lease recently used one that is younger than the open age.  We
 12367                                  ; operate be scanning the list n times finding the least age that is greater
 12368                                  ; or equal to the previous minimum age.
 12369                                  ;
 12370                                  ;   BP is the count of times we need to go through this loop.
 12371                                  ;   AX is the current acceptable minimum age to consider
 12372                                  ;
 12373                                  ;	mov	bp,[CS:KEEPCOUNT]	; k = keepcount;
 12374                                  ;	XOR	AX,AX			; low = 0;
 12375                                  ;
 12376                                  ; If we've scanned the table n times, then we are done.
 12377                                  ;
 12378                                  ;lru1:
 12379                                  ;	CMP	bp,0			; while (k--) {
 12380                                  ;	JZ	short lru75
 12381                                  ;	DEC	bp
 12382                                  ;
 12383                                  ; Set up for scan.
 12384                                  ;
 12385                                  ;   AX is the minimum age for consideration
 12386                                  ;   BX is the minimum age found during the scan
 12387                                  ;   SI is the position of the entry that corresponds to BX
 12388                                  ;
 12389                                  ;	MOV	BX,-1			;     min = 0xffff;
 12390                                  ;	MOV	si,BX			;     pos = 0xffff;
 12391                                  ;	LES	DI,[CS:SFTFCB]		;     for (CX=FCBCount; CX>0; CX--)
 12392                                  ;	;mov	cx,[es:di+4]
 12393                                  ;	MOV	CX,[ES:DI+SFT.SFCount]
 12394                                  ;	;lea	di,[di+6]
 12395                                  ;	LEA	DI,[DI+SFT.SFTable]
 12396                                  ;
 12397                                  ; Innermost loop.  If the current entry is free, then we are done.  Or, if the
 12398                                  ; current entry is busy (indicating a previous aborted allocation), then we
 12399                                  ; are done.  In both cases, we use the found entry.
 12400                                  ;
 12401                                  ;lru2:
 12402                                  ;	cmp	word [es:di],0
 12403                                  ;	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0
 12404                                  ;	jz	short lru25
 12405                                  ;	;cmp	word [es:di],-1
 12406                                  ;	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy
 12407                                  ;	cmp	word [es:di],sf_busy
 12408                                  ;	jnz	short lru3
 12409                                  ;
 12410                                  ; The entry is usable without further scan.  Go and use it.
 12411                                  ;
 12412                                  ;lru25:
 12413                                  ;	MOV	si,DI			;	      pos = i;
 12414                                  ;	JMP	short lru11		;	      goto got;
 12415                                  ;
 12416                                  ; See if the entry is for the network or for the sharer.
 12417                                  ;
 12418                                  ;  If for the sharer or network then
 12419                                  ;	if the age < current minimum AND >= allowed minimum then
 12420                                  ;	    this entry becomes current minimum
 12421                                  ;
 12422                                  ;lru3:
 12423                                  ;	;test	word [es:di+5],8000h
 12424                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet 
 12425                                  ;					;	  if (!net[i]
 12426                                  ;	JNZ	short lru35
 12427                                  ;if installed
 12428                                  ;	call	CheckShare		;		&& !sharing)
 12429                                  ;	JZ	short lru5		;	  else
 12430                                  ;ENDIF
 12431                                  ;
 12432                                  ; This SFT is for the net or is for the sharer. See if it less than the
 12433                                  ; current minimum.
 12434                                  ;
 12435                                  ;lru35:
 12436                                  ;	;mov	dx,[es:di+17h]
 12437                                  ;	MOV	DX,[ES:DI+sf_OpenAge]
 12438                                  ;	CMP	DX,AX			;	  if (age[i] >= low &&
 12439                                  ;	JB	short lru5
 12440                                  ;	CMP	DX,BX
 12441                                  ;	JAE	short lru5		;	      age[i] < min) {
 12442                                  ;
 12443                                  ; entry is new minimum.  Remember his age.
 12444                                  ;
 12445                                  ;	mov	bx,DX			;	      min = age[i];
 12446                                  ;	mov	si,di			;	      pos = i;
 12447                                  ;
 12448                                  ; End of loop.	gp back for more
 12449                                  ;
 12450                                  ;lru5:
 12451                                  ;	;add	di,53
 12452                                  ;	add	di,SF_ENTRY.size
 12453                                  ;	loop	lru2			;	      }
 12454                                  ;
 12455                                  ; The scan is complete. If we have successfully found a new minimum (pos != -1)
 12456                                  ; set then threshold value to this new minimum + 1. Otherwise, the scan is
 12457                                  ; complete.  Go find LRU.
 12458                                  ;
 12459                                  ;lru6:	
 12460                                  ;	cmp	si,-1			; position not -1?
 12461                                  ;	jz	short lru75		; no, done with everything
 12462                                  ;	lea	ax,[bx+1]		; set new threshold age
 12463                                  ;	jmp	short lru1		; go and loop for more
 12464                                  ;lru65:	
 12465                                  ;	stc
 12466                                  ;	jmp	short LRUDead		;	  return -1;
 12467                                  ;
 12468                                  ; Main loop is done. We have AX being the age+1 of the nth oldest sharer or
 12469                                  ; network entry. We now make a second pass through to find the LRU entry
 12470                                  ; that is local-no-share or has age >= AX
 12471                                  ;
 12472                                  ;lru75:
 12473                                  ;	mov	bx,-1			; min = 0xffff;
 12474                                  ;	mov	si,bx			; pos = 0xffff;
 12475                                  ;	LES	DI,[CS:SFTFCB]		; for (CX=FCBCount; CX>0; CX--)
 12476                                  ;	;mov	cx,[es:di+4]
 12477                                  ;	MOV	CX,[ES:DI+SFT.SFCount]
 12478                                  ;	;lea	di,[di+6]
 12479                                  ;	LEA	DI,[DI+SFT.SFTable]
 12480                                  ;
 12481                                  ; If this is is local-no-share then go check for LRU else if age >= threshold
 12482                                  ; then check for lru.
 12483                                  ;
 12484                                  ;lru8:
 12485                                  ;	;test	word [es:di+5],8000h
 12486                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 12487                                  ;	jnz	short lru85		; is for network, go check age
 12488                                  ;	call	CheckShare		; sharer here?
 12489                                  ;	jz	short lru86		; no, go check lru
 12490                                  ;
 12491                                  ; Network or sharer.  Check age
 12492                                  ;
 12493                                  ;lru85:
 12494                                  ;	;cmp	[es:di+17h],ax
 12495                                  ;	cmp	[es:di+sf_OpenAge],ax
 12496                                  ;	jb	short lru9		; age is before threshold, skip it
 12497                                  ;
 12498                                  ; Check LRU
 12499                                  ;
 12500                                  ;lru86:
 12501                                  ;	;cmp	[es:di+15h],bx
 12502                                  ;	cmp	[es:di+sf_LRU],bx	; is LRU less than current LRU?
 12503                                  ;	jae	short lru9		; no, skip this
 12504                                  ;	mov	si,di			; remember position
 12505                                  ;	;mov	bx,[es:di+15h]
 12506                                  ;	mov	bx,[es:di+sf_LRU]	; remember new minimum LRU
 12507                                  ;
 12508                                  ; Done with this entry, go back for more.
 12509                                  ;
 12510                                  ;lru9:
 12511                                  ;	;add	di, 53
 12512                                  ;	add	di,SF_ENTRY.size
 12513                                  ;	loop	lru8
 12514                                  ;
 12515                                  ; Scan is complete. If we found NOTHING that satisfied us then we bomb
 12516                                  ; out. The conditions here are:
 12517                                  ;
 12518                                  ;  No local-no-shares AND all net/share entries are older than threshold
 12519                                  ;
 12520                                  ;lru10:
 12521                                  ;	cmp	si,-1			; if no one f
 12522                                  ;	jz	short lru65		;     return -1;
 12523                                  ;lru11:
 12524                                  ;	mov	di,si
 12525                                  ;	MOV	[CS:THISSFT],DI		; set thissft
 12526                                  ;	MOV	[CS:THISSFT+2],ES
 12527                                  ;
 12528                                  ; If we have sharing or thisSFT is a net sft, then close it until ref count
 12529                                  ; is 0.
 12530                                  ;
 12531                                  ;	;test	word [es:di+5],8000h
 12532                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 12533                                  ;	JNZ	short LRUClose
 12534                                  ;IF INSTALLED
 12535                                  ;	call	CheckShare
 12536                                  ;	JZ	short LRUDone
 12537                                  ;ENDIF
 12538                                  ;
 12539                                  ; Repeat close until ref count is 0
 12540                                  ;
 12541                                  ;LRUClose:
 12542                                  ;	push	ss
 12543                                  ;	pop	ds
 12544                                  ;	LES	DI,[THISSFT]
 12545                                  ;	cmp     word [es:di],0
 12546                                  ;	;CMP	word [ES:DI+SFT.sf_ref_count],0 ; is ref count still <> 0?
 12547                                  ;	JZ	short LRUDone 		; nope, all done
 12548                                  ;	call	DOS_CLOSE
 12549                                  ;	jnc	short LRUClose		; no error => clean up
 12550                                  ;	;cmp	al,6
 12551                                  ;	cmp	al,error_invalid_handle
 12552                                  ;	jz	short LRUClose
 12553                                  ;	stc
 12554                                  ;	JMP	short LRUDead
 12555                                  ;LRUDone:
 12556                                  ;	XOR	AL,AL
 12557                                  ;	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
 12558                                  ;
 12559                                  ;LRUDead:
 12560                                  ;	call	restore_world
 12561                                  ;	LES     DI,[CS:THISSFT]
 12562                                  ;	jnc	short LRUFCB_retn
 12563                                  ;LRUFCB_err:
 12564                                  ;	; mov	al, 23h	
 12565                                  ;	MOV	AL,error_FCB_unavailable
 12566                                  ;LRUFCB_retn:	
 12567                                  ;	retn:
 12568                                  ;
 12569                                  ;ENDIF	; LRUFCB has been rewritten below.
 12570                                  
 12571                                  ; 17/05/2019 - Retro DOS v4.0
 12572                                  ; LRUFCB for MSDOS 6.0 !
 12573                                  ;----------------------------------------------------------------------------
 12574                                  ;
 12575                                  ; LruFCB -- allocate the LRU SFT from the SFT Table. The LRU scheme
 12576                                  ; maintains separate counts for net/Share and local SFTs. We allocate a 
 12577                                  ; net/Share SFT only if we do not find a local SFT. This helps keep
 12578                                  ; net/Share SFTs which cannot be regenerated for as long as possible. We
 12579                                  ; optimize regeneration operations by keeping track of the current local
 12580                                  ; SFT. This avoids scanning of the SFTs as long as we have at least one 
 12581                                  ; local SFT in the SFT Block.
 12582                                  ;
 12583                                  ; Inputs: al = 0 => Regenerate SFT operation
 12584                                  ;	    = 1 => Allocate new SFT for Open/Create
 12585                                  ;
 12586                                  ; Outputs: Carry clear
 12587                                  ;	 	es:di = Address of allocated SFT
 12588                                  ;	  	ThisSFT = Address of allocated SFT
 12589                                  ;
 12590                                  ;	  carry set if closes of net/Share files failed 
 12591                                  ;		al = error_FCB_unavailable
 12592                                  ;
 12593                                  ; Registers affected: None
 12594                                  ;
 12595                                  ;----------------------------------------------------------------------------
 12596                                  
 12597                                  ;LruFCB	PROC	NEAR
 12598                                  LRUFCB:
 12599                                  	; 17/05/2019 - Retro DOS v4.0
 12600                                  	; DOSCODE:5805h (MSDOS 6.21, MSDOS.SYS)
 12601                                  
 12602                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12603                                  	; DOSCODE:57F1h (MSDOS 5.0, MSDOS.SYS)
 12604                                  
 12605                                  	; 20/01/2024
 12606                                  
 12607 00001935 06                      	push	es	; * (MSDOS 6.21)
 12608                                  	
 12609 00001936 E829EB                  	call	save_world
 12610                                  	
 12611                                  	;getdseg <ds>		;ds = DOSDATA
 12612 00001939 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 12613                                  
 12614 0000193E 08C0                    	or	al,al		;Check if regenerate allocation
 12615 00001940 7516                    	jnz	short lru1	;Try to find SFT to use
 12616                                  
 12617                                  	; This is a regen call. If LocalSFT contains the address of a valid
 12618                                  	; local SFT, just return that SFT to reuse
 12619                                  
 12620                                  	; 20/01/2024
 12621                                  	;mov	di,[LocalSFT]
 12622                                  	;or	di,[LocalSFT+2]	;is address == 0?
 12623                                  	;jz	short lru1	;invalid local SFT, find one
 12624                                  
 12625                                  	; We have found a valid local SFT. Recycle this SFT
 12626                                  
 12627 00001942 C43E[5D10]              	les	di,[LocalSFT]
 12628                                  
 12629                                  	; 20/01/2024 (PCDOS 7.1 IBMDOS.COM)
 12630 00001946 8CC1                    	mov	cx,es
 12631 00001948 09F9                    	or	cx,di		; is address == 0?
 12632 0000194A 740C                    	jz	short lru1	; invalid local SFT, find one
 12633                                  
 12634                                  gotlocalSFT:
 12635 0000194C 893E[9E05]              	mov	[THISSFT],di
 12636 00001950 8C06[A005]              	mov	[THISSFT+2],es
 12637 00001954 F8                      	clc
 12638 00001955 E9A900                  	jmp	LRUDone		;clear up SFT and return
 12639                                  
 12640                                  lru1:
 12641 00001958 C43E[4000]              	les	di,[SFTFCB]	;es:di = SF Table for FCBs
 12642                                  	;mov	cx,[es:di+4]
 12643 0000195C 268B4D04                	mov	cx,[es:di+SFT.SFCount]	;cx = number of SFTs
 12644                                  	;lea	di,[di+6]
 12645 00001960 8D7D06                  	lea	di,[di+SFT.SFTable]	;es:di = first SFT
 12646                                  
 12647                                  	; We scan through all the SFTs scanning for a free one. It also 
 12648                                  	; remembers the LRU SFT for net/Share SFTs and local SFTs separately.
 12649                                  	; bx = min. LRU for local SFTs
 12650                                  	; si = pos. of local SFT with min. LRU
 12651                                  	; dx = min. LRU for net/Share SFTs
 12652                                  	; bp = pos. of net/Share SFT with min. LRU
 12653                                  
 12654 00001963 BBFFFF                  	mov	bx,-1		; init. to 0xffff ( max. LRU value )
 12655 00001966 89DE                    	mov	si,bx
 12656 00001968 89DA                    	mov	dx,bx
 12657 0000196A 89DD                    	mov	bp,bx
 12658                                  
 12659                                  findSFT:
 12660                                  	;See if this SFT is a free one. If so, return it
 12661 0000196C 26830D00                	or	word [es:di],0
 12662                                  	;or	word [es:di+SF_ENTRY.sf_ref_count],0 ;reference count = 0 ?
 12663 00001970 744C                    	jz	short gotSFT	;yes, SFT is free
 12664                                  	;;cmp	word [es:di],-1
 12665                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy ;Is it busy?
 12666 00001972 26833DFF                	cmp	word [es:di],sf_busy ; -1 
 12667 00001976 7446                    	jz	short gotSFT	;no, can use it
 12668                                  
 12669                                  	; Check if this SFT is local and store its address in LocalSFT. Can be
 12670                                  	; used for a later regen.
 12671                                  
 12672                                  	; 16/12/2022
 12673                                  	; 08/11/2022
 12674                                  	;test	byte [es:di+6],80h
 12675 00001978 26F6450680              	test	byte [es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8) ; 80h
 12676                                  	; 08/11/2022 Retro DOS v4.0 (MSDOS 5.0 MSDOS.SYS compatibility)
 12677                                  	;;test	word [es:di+5],8000h
 12678                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet ; network SFT?
 12679 0000197D 7531                    	jnz	short lru5	;yes, get net/Share LRU
 12680                                  
 12681                                  ;IF installed
 12682 0000197F E8BB57                  	call	CheckShare	;Share present?
 12683                                  ;ENDIF
 12684 00001982 752C                    	jnz	short lru5	;yes, get net/Share LRU
 12685                                  
 12686                                  	;Local SFT, register its address
 12687                                  
 12688                                  	; !!HACK!!!
 12689                                  	; There is a slightly dirty hack out here in a desperate bid to save
 12690                                  	; code space. There is similar code duplicated at label 'gotSFT'. We
 12691                                  	; enter from there if al = 0, update the LocalSFT variable, and since
 12692                                  	; al = 0, we jump out of the loop to the exit point. I have commented
 12693                                  	; out the code that previously existed at label 'gotSFT'
 12694                                  
 12695                                  hackpoint:
 12696 00001984 893E[5D10]              	mov	[LocalSFT],di
 12697 00001988 8C06[5F10]              	mov	[LocalSFT+2],es	;store local SFT address
 12698                                  
 12699 0000198C 08C0                    	or	al,al		;Is operation = REGEN?
 12700 0000198E 74BC                    	jz	short gotlocalSFT ;yes, return this SFT for reuse
 12701                                  
 12702                                  	;Get LRU for local files
 12703                                  	
 12704                                  	;cmp	[es:di+15h],bx
 12705 00001990 26395D15                	cmp	[es:di+sf_LRU],bx ;SFT.LRU < min?
 12706 00001994 7306                    	jae	short lru4	;no, skip 
 12707                                  
 12708                                  	;mov	bx,[es:di+15h]
 12709 00001996 268B5D15                	mov	bx,[es:di+sf_LRU] ;yes, store new minimum
 12710 0000199A 89FE                    	mov	si,di		;store SFT position
 12711                                  lru4:
 12712                                  	;add	di,59
 12713 0000199C 83C73B                  	add	di,SF_ENTRY.size ;go to next SFT
 12714 0000199F E2CB                    	loop	findSFT
 12715                                  	
 12716                                  	; 20/01/2024
 12717 000019A1 49                      	dec	cx ; -1
 12718                                  
 12719                                  	; Check whether we got a net/Share or local SFT. If local SFT
 12720                                  	; available, we will reuse it instead of net/Share LRU
 12721                                  
 12722 000019A2 89F7                    	mov	di,si
 12723                                  	;cmp	si,-1		;local SFT available?
 12724 000019A4 39CE                    	cmp	si,cx ; 20/01/2024
 12725 000019A6 7516                    	jnz	short gotSFT	;yes, return it
 12726                                  
 12727                                  	;No local SFT, see if we got a net/Share SFT
 12728                                  
 12729 000019A8 89EF                    	mov	di,bp
 12730                                  
 12731 000019AA 39CD                    	cmp	bp,cx ; -1 ; 20/01/2024
 12732                                  	;cmp	bp,-1		;net/Share SFT available?
 12733 000019AC 752D                    	jnz	short gotnetSFT	;yes, return it
 12734                                  noSFT:
 12735                                  	; NB: This error should never occur. We always must have an LRU SFT.
 12736                                  	; This error can occur only if the SFT has been corrupted or the LRU
 12737                                  	; count is not maintained properly.
 12738                                  
 12739 000019AE EB4E                    	jmp	short errorbadSFT ;error, no FCB available.
 12740                                  
 12741                                  	; Handle the LRU for net/Share SFTs
 12742                                  lru5:
 12743                                  	;cmp	[es:di+15h],dx
 12744 000019B0 26395515                	cmp	[es:di+sf_LRU],dx ;SFT.LRU < min?
 12745 000019B4 73E6                    	jae	short lru4	;no, skip
 12746                                  
 12747                                  	;mov	dx,[es:di+15h]
 12748 000019B6 268B5515                	mov	dx,[es:di+sf_LRU] ;yes, store new minimum
 12749                                  
 12750 000019BA 89FD                    	mov	bp,di		;store SFT position
 12751 000019BC EBDE                    	jmp	short lru4	;continue with next SFT
 12752                                  
 12753                                  gotSFT:
 12754 000019BE 08C0                    	or	al,al
 12755 000019C0 74C2                    	jz	short hackpoint	;save es:di in LocalSFT
 12756                                  
 12757                                  	; HACK!!!
 12758                                  	; The code here differs from the code at 'hackpoint' only in the
 12759                                  	; order of the check for al. If al = 0, we can jump to 'hackpoint'
 12760                                  	; and then from there jump out to 'gotlocalSFT'. The original code
 12761                                  	; has been commented out below and replaced by the code just above.
 12762                                  
 12763                                  ;If regen, then this SFT can be registered as a local one ( even if free ).
 12764                                  ;
 12765                                  ;	or	al,al		  ;Regen?
 12766                                  ;	jnz	short notlocaluse ;yes, register it and return
 12767                                  ;
 12768                                  ;Register this SFT as a local one
 12769                                  ;
 12770                                  ;	mov	[LocalSFT],di
 12771                                  ;	mov	[LocalSFT+2],es
 12772                                  ;	jmp	gotlocalSFT	;return to caller
 12773                                  ;
 12774                                  ;notlocaluse:
 12775                                  
 12776                                  	; The caller is probably going to use this SFT for a net/Share file.
 12777                                  	; We will come here only on a Open/Create when the caller($FCB_OPEN)
 12778                                  	; does not really know whether it is a local file or not. We
 12779                                  	; invalidate LocalSFT if the SFT we are going to use was previously
 12780                                  	; registered as a local SFT that can be recycled.
 12781                                  
 12782 000019C2 8CC0                    	mov	ax,es
 12783 000019C4 393E[5D10]              	cmp	[LocalSFT],di		;Offset same?
 12784 000019C8 750E                    	jne	short notinvalid
 12785 000019CA 3906[5F10]              	cmp	[LocalSFT+2],ax		;Segments same?
 12786                                  	;je	short zerolocalSFT	;no, no need to invalidate
 12787                                  	; 20/01/2024 (PCDOS 7.1 IBMDOS.COM)
 12788 000019CE 7508                    	jne	short notinvalid
 12789                                  zerolocalSFT:	
 12790 000019D0 31C0                    	xor	ax,ax ; 0
 12791 000019D2 A3[5D10]                	mov	[LocalSFT],ax
 12792 000019D5 A3[5F10]                	mov	[LocalSFT+2],ax
 12793                                  	
 12794                                  notinvalid:
 12795 000019D8 E971FF                  	jmp	gotlocalSFT
 12796                                  
 12797                                  	; The SFT we are going to use was registered in the LocalSFT variable.
 12798                                  	; Invalidate this variable i.e LocalSFT = NULL
 12799                                  
 12800                                  ;zerolocalSFT:
 12801                                  	;xor	ax,ax ; 0
 12802                                  	;mov	[LocalSFT],ax
 12803                                  	;mov	[LocalSFT+2],ax
 12804                                  	;
 12805                                  	;jmp	gotlocalSFT
 12806                                  
 12807                                  gotnetSFT:
 12808                                  	; We have an SFT that is currently net/Share. If it is going to be
 12809                                  	; used for a regen, we know it has to be a local SFT. Update the
 12810                                  	; LocalSFT variable
 12811                                  
 12812 000019DB 08C0                    	or	al,al
 12813 000019DD 7508                    	jnz	short closenet
 12814                                  
 12815 000019DF 893E[5D10]              	mov	[LocalSFT],di
 12816 000019E3 8C06[5F10]              	mov	[LocalSFT+2],es	;store local SFT address
 12817                                  closenet:
 12818 000019E7 893E[9E05]              	mov	[THISSFT],di	; set thissft
 12819 000019EB 8C06[A005]              	mov	[THISSFT+2],es
 12820                                  
 12821                                  	; If we have sharing or thisSFT is a net sft, then close it until ref
 12822                                  	; count is 0.
 12823                                  	; NB: We come here only if it is a net/Share SFT that is going to be
 12824                                  	; recycled -- no need to check for this.
 12825                                  
 12826                                  LRUClose:
 12827 000019EF 26833D00                	cmp	word [es:di],0
 12828                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0 ; is ref count still <> 0?
 12829 000019F3 740C                    	jz	short LRUDone	; nope, all done
 12830                                  
 12831 000019F5 E87314                  	call	DOS_CLOSE
 12832 000019F8 73F5                    	jnc	short LRUClose	; no error => clean up
 12833                                  
 12834                                  	; Bugbug: I dont know why we are trying to close after we get an
 12835                                  	; error closing. Seems like we could have a potential infinite loop
 12836                                  	; here. This has to be verified.
 12837                                  
 12838 000019FA 3C06                    	cmp	al,error_invalid_handle ; 6
 12839 000019FC 74F1                    	je	short LRUClose
 12840                                  errorbadSFT:
 12841 000019FE F9                      	stc
 12842 000019FF EB05                    	JMP	short LRUDead
 12843                                  LRUDone:
 12844 00001A01 30C0                    	XOR	AL,AL
 12845 00001A03 E80401                  	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
 12846                                  
 12847                                  LRUDead:
 12848 00001A06 E842EA                  	call	restore_world		; use macro
 12849                                  	
 12850 00001A09 07                      	pop	es ; * (MSDOS 6.21)
 12851                                  
 12852                                  	;getdseg <es>
 12853 00001A0A 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 12854 00001A0F 26C43E[9E05]            	les	di,[es:THISSFT]		;es:di points at allocated SFT
 12855                                  
 12856                                  	;;retnc
 12857                                  	;jc	short LruFCB_err
 12858                                  	;retn
 12859                                  
 12860                                  	; 16/12/2022
 12861                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12862 00001A14 7302                    	jnc	short LruFCB_retn
 12863                                  	;jc	short LruFCB_err
 12864                                  	;retn
 12865                                  		
 12866                                  LruFCB_err:
 12867 00001A16 B023                    	MOV	AL,error_FCB_unavailable ; 23h
 12868                                  LruFCB_retn:
 12869 00001A18 C3                      	retn
 12870                                  	
 12871                                  ;LruFCB	ENDP
 12872                                  
 12873                                  ; 17/05/2019 - Retro DOS v4.0
 12874                                  
 12875                                  ; DOSCODE:58F3h (MSDOS 6.21, MSDOS.SYS)
 12876                                  
 12877                                  ; 26/06/2024
 12878                                  %if 0
 12879                                  
 12880                                  ; --------------------------------------------------------------------------
 12881                                  ;**** RegenCopyName -- This function copies the filename from the FCB to
 12882                                  ; SFT and also to DOS local buffers. There was duplicate code in FCBRegen
 12883                                  ; to copy the name to different destinations
 12884                                  ;
 12885                                  ; Inputs: ds:si = source string
 12886                                  ;	 es:di = destination string
 12887                                  ;	 cx = length of string
 12888                                  ;
 12889                                  ; Outputs: String copied to destination
 12890                                  ;
 12891                                  ; Registers affected: cx,di,si
 12892                                  ; --------------------------------------------------------------------------
 12893                                  
 12894                                  RegenCopyName:
 12895                                  CopyName:
 12896                                  	lodsb			;load character
 12897                                  	call	UCase		; convert char to upper case
 12898                                  StuffChar2:
 12899                                  	STOSB			;store converted character
 12900                                  	LOOP	CopyName	;
 12901                                  DoneName:
 12902                                  	retn
 12903                                  
 12904                                  %endif
 12905                                  ; --------------------------------------------------------------------------
 12906                                  
 12907                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12908                                  FCBRegen:
 12909                                  	; called from SFTFromFCB. SS already DOSDATA
 12910                                  
 12911                                  	; General data filling. Mode is sf_isFCB + open_for_both, date/time 
 12912                                  	; we do not fill, size we do no fill, position we do not fill,
 12913                                  	; bit 14 of flags = TRUE, other bits = FALSE
 12914                                  
 12915                                  	;mov	al,[si+19h]
 12916 00001A19 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 12917                                  
 12918                                  	; We discriminate based on the first two bits in the reserved field.
 12919                                  	
 12920                                  	;test	al,80h
 12921 00001A1C A880                    	test	AL,FCBSPECIAL		; check for no sharing test
 12922 00001A1E 741C                    	JZ	short RegenNoSharing	; yes, go regen from no sharing
 12923                                  
 12924                                  	; The FCB is for a network or a sharing based system. At this point 
 12925                                  	; we have already closed the SFT for this guy and reconnection is 
 12926                                  	; impossible.
 12927                                  	;
 12928                                  	; Remember that he may have given us a FCB with bogus information in
 12929                                  	; it. Check to see if sharing is present or if the redir is present.
 12930                                  	; If either is around, presume that we have cycled out the FCB and 
 12931                                  	; give the hard error. Otherwise, just return with carry set.
 12932                                  
 12933 00001A20 E81A57                  	call	CheckShare		; test for sharer
 12934 00001A23 7509                    	JNZ	short RegenFail		; yep, fail this.
 12935                                  	
 12936                                  	;mov	ax,1100h
 12937 00001A25 B80011                  	MOV	AX,MultNET<<8		; install check on multnet
 12938 00001A28 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - INSTALLATION CHECK
 12939                                  			; Return: AL = 00h  not installed, OK to install
 12940                                  			; 01h  not installed, not OK to install
 12941                                  			; FFh  installed
 12942 00001A2A 08C0                    	OR	AL,AL			; is it there?
 12943 00001A2C 740C                    	JZ	short RegenDead		; no, just fail the operation
 12944                                  RegenFail:
 12945                                  	; 17/05/2019 - Retro DOS v4.0
 12946                                  	;MOV	AX,[CS:USER_IN_AX]	; SS override
 12947 00001A2E 36A1[3A03]              	mov	ax,[SS:USER_IN_AX] ; MSDOS 6.0
 12948                                  
 12949                                  	;cmp	ah,10h
 12950 00001A32 80FC10                  	cmp	AH,FCB_CLOSE
 12951 00001A35 7403                    	jz	short RegenDead
 12952 00001A37 E88801                  	call	FCBHardErr		; massive hard error.
 12953                                  RegenDead:
 12954 00001A3A F9                      	STC				; carry set
 12955                                  FCBRegen_retn:
 12956 00001A3B C3                      	retn
 12957                                  
 12958                                  	; Local FCB without sharing. Check to see if sharing is loaded. If 
 12959                                  	; so fail the operation.
 12960                                  
 12961                                  RegenNoSharing:
 12962 00001A3C E8FE56                  	call	CheckShare		; Sharing around?
 12963 00001A3F 75ED                    	JNZ	short RegenFail
 12964                                  	
 12965                                  	; Find an SFT for this guy.
 12966                                  	
 12967                                  	; 17/05/2019 - Retro DOS v4.0
 12968                                  
 12969                                  	; MSDOS 3.3
 12970                                  	;call	LRUFCB
 12971                                  	;jc	short FCBRegen_retn
 12972                                  	
 12973                                  	; MSDOS 6.0
 12974 00001A41 50                      	push	ax
 12975 00001A42 B000                    	mov	al,0			;indicate it is a regen operation
 12976 00001A44 E8EEFE                  	call	LRUFCB
 12977 00001A47 58                      	pop	ax
 12978 00001A48 72F1                    	jc	short FCBRegen_retn
 12979                                  
 12980                                  	;mov	word [es:di+2],8002h
 12981 00001A4A 26C745020280            	MOV	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB+open_for_both+SHARING_COMPAT
 12982 00001A50 243F                    	AND	AL,3Fh			; get drive number for flags
 12983 00001A52 98                      	CBW
 12984                                  	;or	ax,4000h
 12985 00001A53 0D0040                  	OR	AX,sf_close_nodate	; normal FCB operation
 12986                                  
 12987                                  	; The bits field consists of the upper two bits (dirty and device) 
 12988                                  	; from the SFT and the low 4 bits from the open mode.
 12989                                  
 12990                                  	;mov	cl,[si+1Ah]
 12991 00001A56 8A4C1A                  	MOV	CL,[SI+fcb_nsl_bits]	; stick in dirty bits.
 12992 00001A59 88CD                    	MOV	CH,CL
 12993 00001A5B 80E5C0                  	AND	CH,0C0h 		; mask off the dirty/device bits
 12994 00001A5E 08E8                    	OR	AL,CH
 12995                                  	;and	cl,0Fh
 12996 00001A60 80E10F                  	AND	CL,access_mask		; get the mode bits
 12997                                  	;mov	[es:di+2],cl
 12998 00001A63 26884D02                	MOV	[ES:DI+SF_ENTRY.sf_mode],CL
 12999                                  	;mov	[es:di+5],ax
 13000 00001A67 26894505                	MOV	[ES:DI+SF_ENTRY.sf_flags],AX ; initial flags
 13001                                  	;MOV	AX,[CS:PROC_ID]		; SS override
 13002 00001A6B 36A1[3C03]              	mov	ax,[ss:PROC_ID] ; MSDOS 6.0
 13003                                  	;mov	[es:di+31h],ax
 13004 00001A6F 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX
 13005 00001A73 1E                      	push	ds
 13006 00001A74 56                      	push	si
 13007 00001A75 06                      	push	es
 13008 00001A76 57                      	push	di
 13009 00001A77 16                      	push	ss
 13010 00001A78 07                      	pop	es
 13011 00001A79 BF[4B05]                	MOV	DI,NAME1		; NAME1 is in DOSDATA
 13012                                  
 13013 00001A7C B90800                  	MOV	CX,8
 13014 00001A7F 46                      	INC	SI			; Skip past drive byte to name in FCB
 13015                                  
 13016                                  	; MSDOS 3.3
 13017                                  ;RegenCopyName:
 13018                                  	;lodsb
 13019                                  	;call	UCase
 13020                                  	;stosb
 13021                                  	;loop	RegenCopyName
 13022                                  
 13023                                  	; MSDOS 6.0
 13024 00001A80 E87F00                  	call	RegenCopyName		;copy the name to NAME1
 13025                                  
 13026 00001A83 16                      	push	ss	; SS is DOSDATA
 13027 00001A84 1F                      	pop	ds
 13028                                  
 13029                                  	;mov	byte [ATTRIB],16h
 13030 00001A85 C606[6B05]16            	MOV	byte [ATTRIB],attr_hidden+attr_system+attr_directory
 13031                                  					; Must set this to something interesting
 13032                                  					; to call DEVNAME.
 13033 00001A8A E8F025                  	call	DEVNAME 		; check for device
 13034 00001A8D 5E                      	pop	si
 13035 00001A8E 07                      	pop	es
 13036 00001A8F 5E                      	pop	si
 13037 00001A90 1F                      	pop	ds
 13038 00001A91 7219                    	JC	short RegenFileNoSharing ; not found on device list => file
 13039                                  
 13040                                  	; Device found. We can ignore disk-specific info
 13041                                  
 13042                                  	;mov	[es:di+5],bh
 13043 00001A93 26887D05                	MOV	[ES:DI+SF_ENTRY.sf_flags],BH ; device parms
 13044                                  	;mov	byte [es:di+4],0
 13045 00001A97 26C6450400              	MOV	byte [ES:DI+SF_ENTRY.sf_attr],0 ; attribute
 13046                                  					; SS override
 13047                                  	;LDS	SI,[CS:DEVPT]		; get device driver
 13048 00001A9C 36C536[9A05]            	lds	si,[ss:DEVPT] ; MSDOS 6.0
 13049                                  regen_save_dpb:	; 26/06/2024
 13050                                  	;mov	[es:di+7],si
 13051 00001AA1 26897507                	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 13052                                  	;mov	[es:di+9],ds
 13053 00001AA5 268C5D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 13054 00001AA9 C3                      	retn				; carry is clear
 13055                                  
 13056                                  RegenDeadJ:
 13057 00001AAA EB8E                    	JMP	short RegenDead
 13058                                  
 13059                                  	; File found. Just copy in the remaining pieces.
 13060                                  
 13061                                  RegenFileNoSharing:
 13062                                  	;mov	ax,[es:di+5]
 13063 00001AAC 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 13064 00001AB0 83E03F                  	AND	AX,03Fh
 13065 00001AB3 1E                      	push	ds
 13066 00001AB4 56                      	push	si
 13067 00001AB5 E84C4D                  	call	FIND_DPB
 13068                                  	;;mov	[es:di+7],si
 13069                                  	;MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 13070                                  	;;mov	[es:di+9],ds
 13071                                  	;MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 13072                                  	; 26/06/2024 (PCDOS 7.1 IBMDOS.COM)
 13073 00001AB8 E8E6FF                  	call	regen_save_dpb
 13074 00001ABB 5E                      	pop	si
 13075 00001ABC 1F                      	pop	ds
 13076 00001ABD 72EB                    	jc	short RegenDeadJ	; if find DPB fails, then drive
 13077                                  					; indicator was bogus
 13078                                  	;mov	ax,[si+1Dh]
 13079 00001ABF 8B441D                  	MOV	AX,[SI+fcb_nsl_dirsec]
 13080                                  	;;mov	[es:di+1Dh],ax ; MSDOS 3.3
 13081                                  	;mov	[es:di+1Bh],ax ; MSDOS 6.0
 13082 00001AC2 2689451B                	MOV	[ES:DI+SF_ENTRY.sf_dirsec],AX
 13083                                  
 13084                                  	; MSDOS 6.0
 13085                                  
 13086                                  	; SR;
 13087                                  	; Extract the read-only and archive bits from the top 2 bits of the sector
 13088                                  	; number
 13089                                  
 13090                                  	;mov	al,[si+18h]
 13091 00001AC6 8A4418                  	mov	al,[si+fcb_sfn]
 13092 00001AC9 24C0                    	and	al,0C0h		;get the 2 attribute bits
 13093 00001ACB 88C4                    	mov	ah,al
 13094 00001ACD D0C4                    	rol	ah,1
 13095 00001ACF D0E8                    	shr	al,1
 13096 00001AD1 08E0                    	or	al,ah
 13097 00001AD3 243F                    	and	al,03Fh		;mask off unused bits
 13098                                  	;mov	[es:di+4],al
 13099 00001AD5 26884504                	mov	[es:di+SF_ENTRY.sf_attr],al
 13100                                  
 13101                                  	; SR;
 13102                                  	; Update the higher word of the directory sector from the FCB
 13103                                  
 13104                                  	;;mov	al,[si+18h]
 13105 00001AD9 8A4418                  	mov	al,[si+fcb_sfn]
 13106 00001ADC 243F                    	and	al,03Fh		;mask off top 2 bits -- attr bits
 13107 00001ADE 28E4                    	sub	ah,ah
 13108                                  	;mov	[es:di+1Dh],ax
 13109 00001AE0 2689451D                	mov	[es:di+SF_ENTRY.sf_dirsec+2],ax ;update high word
 13110                                  
 13111                                  	; MSDOS 6.0 (& MSDOS 3.3)
 13112                                  	;mov	ax,[si+1Bh]
 13113 00001AE4 8B441B                  	MOV	AX,[SI+fcb_nsl_firclus]
 13114                                  	;mov	[es:di+0Bh],ax
 13115 00001AE7 2689450B                	MOV	[ES:DI+SF_ENTRY.sf_firclus],AX
 13116                                  	;;mov	[es:di+1Bh],ax ; MSDOS 3.3
 13117                                  	;mov	[es:di+35h],ax ; MSDOS 6.0
 13118 00001AEB 26894535                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 13119                                  	;mov	al,[si+1Fh]
 13120 00001AEF 8A441F                  	MOV	AL,[SI+fcb_nsl_dirpos]
 13121                                  	;mov  	[es:di+1Fh],al
 13122 00001AF2 2688451F                	MOV	[ES:DI+SF_ENTRY.sf_dirpos],AL
 13123                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 13124 00001AF6 26FF05                  	inc	word [ES:DI]		; Increment reference count.
 13125                                  					; Existing FCB entries would be
 13126                                  					; flushed unnecessarily because of
 13127                                  					; check in CheckFCB of the ref_count.
 13128                                  					; July 22/85 - BAS
 13129                                  	;lea	si,[si+1]
 13130 00001AF9 8D7401                  	LEA	SI,[SI+SYS_FCB.name]
 13131                                  	;lea	di,[di+20h]
 13132 00001AFC 8D7D20                  	LEA	DI,[DI+SF_ENTRY.sf_name]
 13133                                  	;mov	cx,11
 13134 00001AFF B90B00                  	MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 13135                                  	
 13136                                  	; 26/06/2024
 13137                                  	; MSDOS 6.0
 13138                                  	;call	RegenCopyName	;copy name to SFT
 13139                                  	; 26/06/2024
 13140                                  	; cf = 0 (at the result of the 'test' instruction) 
 13141                                  	
 13142                                  	; MSDOS 3.3
 13143                                  ;RegenCopyName2:
 13144                                  	;lodsb
 13145                                  	;call    UCase
 13146                                  	;stosb
 13147                                  	;loop    RegenCopyName2
 13148                                  
 13149                                  	; 26/06/2024
 13150                                  	; cf = 0
 13151                                  	;clc
 13152                                  	;retn
 13153                                  
 13154                                  ; 26/06/2024
 13155                                  %if 1
 13156                                  
 13157                                  ; --------------------------------------------------------------------------
 13158                                  ;**** RegenCopyName -- This function copies the filename from the FCB to
 13159                                  ; SFT and also to DOS local buffers. There was duplicate code in FCBRegen
 13160                                  ; to copy the name to different destinations
 13161                                  ;
 13162                                  ; Inputs: ds:si = source string
 13163                                  ;	 es:di = destination string
 13164                                  ;	 cx = length of string
 13165                                  ;
 13166                                  ; Outputs: String copied to destination
 13167                                  ;
 13168                                  ; Registers affected: cx,di,si
 13169                                  ; --------------------------------------------------------------------------
 13170                                  
 13171                                  RegenCopyName:
 13172                                  CopyName:
 13173 00001B02 AC                      	lodsb			;load character
 13174 00001B03 E8B733                  	call	UCase ; *	; convert char to upper case
 13175                                  StuffChar2:
 13176 00001B06 AA                      	STOSB			;store converted character
 13177 00001B07 E2F9                    	LOOP	CopyName	;
 13178                                  	; 26/06/2024
 13179                                  	; cf= 0 ; *
 13180                                  DoneName:
 13181 00001B09 C3                      	retn
 13182                                  
 13183                                  %endif
 13184                                  
 13185                                  ; 17/05/2019 - Retro DOS v4.0
 13186                                  
 13187                                  ;**	BlastSFT - FIll SFT with Garbage
 13188                                  ; --------------------------------------------------------------------------
 13189                                  ;	BlastSFT is used when an SFT is no longer needed; it's called with
 13190                                  ;	various garbage values to put into the SFT.  I don't know why,
 13191                                  ;	presumably to help with debugging (jgl).  We clear the few fields
 13192                                  ;	necessary to show that the SFT is free after filling it.
 13193                                  ;
 13194                                  ;	ENTRY	(es:di) = address of SFT
 13195                                  ;		(al) = fill character
 13196                                  ;	EXIT	(ax) = -1
 13197                                  ;		'C' clear
 13198                                  ;	USES	AX, CX, Flags
 13199                                  
 13200                                  BlastSFT:
 13201 00001B0A 57                      	push	di
 13202                                  	;mov	cx,53 ; MSDOS 3.3
 13203                                  	;mov	cx,59 ; MSDOS 6.0
 13204 00001B0B B93B00                  	mov	cx,SF_ENTRY.size
 13205 00001B0E F3AA                    	rep	stosb
 13206 00001B10 5F                      	pop	di
 13207 00001B11 29C0                    	sub	ax,ax	; 0		; clear 'C'-----------------;
 13208 00001B13 268905                  	mov	[es:di],ax
 13209                                  	;mov	[es:di+SF_ENTRY.sf_ref_count],ax ; set ref count    ;
 13210                                  	;mov	[es:di+15h],ax
 13211 00001B16 26894515                	mov	[es:di+sf_LRU],ax	; set lru		    ;
 13212 00001B1A 48                      	dec	ax	; -1					    ;
 13213                                  	;mov	[es:di+17h],ax ; 0FFFFh ; -1
 13214 00001B1B 26894517                	mov	[es:di+sf_OpenAge],ax	; set open age to -1	    ;
 13215                                  BlastSFT_retn:
 13216 00001B1F C3                      	retn				; return with 'C' clear     ;
 13217                                  
 13218                                  ;Break	<CheckFCB - see if the SFT pointed to by the FCB is still OK>
 13219                                  ; --------------------------------------------------------------------------
 13220                                  ;
 13221                                  ;   CheckFCB - examine an FCB and its contents to see if it needs to be
 13222                                  ;   regenerated.
 13223                                  ;
 13224                                  ;   Inputs:	DS:SI point to FCB (not extended)
 13225                                  ;		AL is SFT index
 13226                                  ;   Outputs:	Carry Set - FCB needs to be regened
 13227                                  ;		Carry clear - FCB is OK. ES:DI point to SFT
 13228                                  ;   Registers modified: AX and BX
 13229                                  ;
 13230                                  ; --------------------------------------------------------------------------
 13231                                  
 13232                                  	; 21/01/2024
 13233                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13234                                  	; DOSCODE:59F0h (MSDOS 5.0, MSDOS.SYS)
 13235                                  CheckFCB:
 13236                                  		
 13237                                  	; called from $fcb_open and sftfromfcb. SS already set up to DOSDATA
 13238                                  
 13239                                  	; MSDOS 3.3
 13240                                  
 13241                                  	; LES	DI,[CS:SFTFCB]
 13242                                  
 13243                                  	; MSDOS 6.0
 13244                                  	
 13245                                  	; SR;
 13246                                  	; We check if the given FCB is for a local file. If so, we return a 
 13247                                  	; bad SFT status forcing the caller to regenerate the SFT.
 13248                                  
 13249                                  	;test	byte [si+19h],0C0h
 13250 00001B20 F64419C0                	test	byte [si+fcb_l_drive],FCBNETWORK|FCBSHARE|FCBDEVICE
 13251 00001B24 7464                    	jz	short BadSFT		;Local file, return bad SFT
 13252 00001B26 36C43E[4000]            	LES     DI,[SS:SFTFCB]		; SS override
 13253                                  
 13254                                  	; MSDOS 6.0 (& MSDOS 3.3)
 13255                                  	;cmp	[es:di+4],al
 13256 00001B2B 26384504                	CMP	[ES:DI+SFT.SFCount],AL
 13257 00001B2F 7259                    	JC	short BadSFT
 13258                                  	;;mov	bl,53 ; MSDOS 3.3
 13259                                  	;mov	bl,59 ; MSDOS 6.0
 13260 00001B31 B33B                    	MOV	BL,SF_ENTRY.size
 13261 00001B33 F6E3                    	MUL	BL
 13262                                  	;lea	di,[di+6]
 13263 00001B35 8D7D06                  	LEA	DI,[DI+SFT.SFTable]
 13264 00001B38 01C7                    	ADD	DI,AX
 13265                                  	;MOV	AX,[CS:PROC_ID]	; MSDOS 3.3
 13266 00001B3A 36A1[3C03]              	mov	ax,[SS:PROC_ID] ; MSDOS 6.0  ; SS override
 13267                                  	;cmp	[es:di+31h],ax
 13268 00001B3E 26394531                	CMP	[ES:DI+SF_ENTRY.sf_PID],AX
 13269 00001B42 7546                    	JNZ	short BadSFT		; must match process
 13270 00001B44 26833D00                	cmp	word [es:di],0
 13271                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],0
 13272 00001B48 7440                    	JZ	short BadSFT		; must also be in use
 13273                                  	;mov	al,[si+19h]
 13274 00001B4A 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 13275                                  	;test	al,80h
 13276 00001B4D A880                    	test	AL,FCBSPECIAL		; a special FCB?
 13277 00001B4F 7427                    	JZ	short CheckNoShare	; No. try local or device
 13278                                  
 13279                                  	; Since we are a special FCB, try NOT to use a bogus test instruction.
 13280                                  	; FCBSHARE is a superset of FCBNETWORK.
 13281                                  
 13282 00001B51 50                      	PUSH	AX
 13283                                  	;and	al,0C0h
 13284 00001B52 24C0                    	AND	AL,FCBMASK
 13285                                  	;cmp	al,0C0h
 13286 00001B54 3CC0                    	CMP	AL,FCBSHARE		; net FCB?
 13287 00001B56 58                      	POP	AX
 13288 00001B57 7515                    	JNZ	short CheckNet		; yes
 13289                                  ;
 13290                                  ;----- In share support -----
 13291                                  ;
 13292                                  	;call	far [cs:JShare+(11*4)]
 13293 00001B59 36FF1E[BC00]            	Call    far [ss:JShare+(11*4)] ; 11 = ShChk ; SS Override
 13294 00001B5E 722A                    	JC	short BadSFT
 13295                                  
 13296                                  ; 21/01/2024
 13297                                  %if 0
 13298                                  	JMP	SHORT CheckD
 13299                                  ;
 13300                                  ;----- End in share support -----
 13301                                  ;
 13302                                  	; 09/11/2022
 13303                                  	; (There is not any procedure/sub
 13304                                  	;  which calls or jumps to CheckFirClus here)
 13305                                  	;;;
 13306                                  CheckFirClus:
 13307                                  	;cmp     bx,[es:di+0Bh]
 13308                                  	; 07/12/2022
 13309                                  	CMP	BX,[ES:DI+SF_ENTRY.sf_firclus]
 13310                                  	JNZ	short BadSFT
 13311                                  	;;;
 13312                                  %endif
 13313                                  
 13314                                  CheckD:
 13315 00001B60 243F                    	AND	AL,3Fh
 13316                                  	;mov	ah,[es:di+5]
 13317 00001B62 268A6505                	MOV	AH,[ES:DI+SF_ENTRY.sf_flags]
 13318 00001B66 80E43F                  	AND	AH,3Fh
 13319 00001B69 38C4                    	CMP	AH,AL
 13320                                  	; 26/06/2024
 13321                                  	; 16/12/2022
 13322                                  	;jz	short BlastSFT_retn	; carry is clear
 13323                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13324 00001B6B 751D                    	jnz	short BadSFT
 13325                                  CheckD_retn:
 13326 00001B6D C3                      	retn
 13327                                  
 13328                                  ; 26/06/2024
 13329                                  ;BadSFT: 
 13330                                  ;	STC
 13331                                  ;	retn
 13332                                  
 13333                                  CheckNet:
 13334                                  	; 17/05/2019 - Retro DOS v4.0
 13335                                  	
 13336                                  ;----- In net support -----
 13337                                  
 13338                                  	; MSDOS 3.3
 13339                                  	;;mov	ax,[si+1Ah]
 13340                                  	;mov	ax,[si+fcb_net_handle]
 13341                                  	;;cmp	ax,[es:di+1Dh]
 13342                                  	;cmp	ax,[ES:DI+SF_ENTRY.sf_dirsec]
 13343                                  	;jnz	short BadSFT
 13344                                  	;;cmp	ax,[es:di+19h]
 13345                                  	;cmp	ax,[ES:DI+sf_netid]
 13346                                  	;jnz     short BadSFT
 13347                                  	;;mov	ax,[si+1Eh]
 13348                                  	;mov	ax,[si+fcb_l_attr]
 13349                                  	;;cmp	ax,[es:di+1Bh]
 13350                                  	;cmp	ax,[es:di+SF_ENTRY.sf_lstclus]
 13351                                  	;jnz     short BadSFT
 13352                                  
 13353                                  	; MSDOS 6.0
 13354                                  	;mov	ax,[si+1Ch]
 13355 00001B6E 8B441C                  	MOV	AX,[SI+fcb_netID]	;AN000;IFS.DOS 4.00
 13356                                  	; 09/11/2022
 13357                                  	;cmp	ax,[es:di+0Bh] 
 13358 00001B71 263B450B                	CMP	AX,[ES:DI+sf_serial_ID]	;AN000;IFS.DOS 4.00
 13359 00001B75 7513                    	JNZ	short BadSFT
 13360                                  
 13361                                  ;----- END In net support -----
 13362                                  
 13363                                  CheckNet_retn:
 13364 00001B77 C3                      	retn
 13365                                  
 13366                                  CheckNoShare:
 13367                                  
 13368                                  ; 16/12/2022
 13369                                  ;	; 09/11/2022 (following test instruction is nonsense!)
 13370                                  ;	; (I am leaving it here for MSDOS 5.0 MSDOS.SYS compatibility)
 13371                                  ;	;test	al,40h
 13372                                  ;	test	AL,FCBDEVICE		; Device?
 13373                                  ;	;jnz	short $+2 ; 09/11/2022
 13374                                  ;	JNZ	short CheckNoShareDev 	; Yes
 13375                                  
 13376                                  	; MSDOS 3.3 - IBMDOS.COM - Offset 27EFh
 13377                                  	;;mov	bx,[si+1Dh]
 13378                                  	;MOV	BX,[SI+fcb_nsl_dirsec]
 13379                                  	;;cmp	bx,[es:di+1Dh]
 13380                                  	;cmp	bx,[ES:DI+SF_ENTRY.sf_dirsec]
 13381                                  	;jnz	short BadSFT
 13382                                  	;;mov	bl,[si+1Fh]
 13383                                  	;MOV	bl,[SI+fcb_nsl_dirpos]
 13384                                  	;;cmp	bl,[es:di+1Fh]
 13385                                  	;cmp	bl,[ES:DI+SF_ENTRY.sf_dirpos]
 13386                                  	;jnz	short BadSFT
 13387                                  	;;mov	bl,[si+1Ah]
 13388                                  	;MOV	bl,[SI+fcb_nsl_bits]
 13389                                  	;;mov	bh,[es:di+5]
 13390                                  	;MOV	bh,[ES:DI+SF_ENTRY.sf_flags]
 13391                                  	;xor	bh,bl
 13392                                  	;and	bh,0C0h
 13393                                  	;jnz	short BadSFT
 13394                                  	;;xor	bl,[es:di+2]
 13395                                  	;xor	bl,[ES:DI+SF_ENTRY.sf_mode]
 13396                                  	;and	bl,0Fh
 13397                                  	;jnz	short BadSFT
 13398                                  	;push	di
 13399                                  	;push	si
 13400                                  	;;lea	di,[di+20h]  ; MSDOS 3.3
 13401                                  	;LEA	DI,[DI+SF_ENTRY.sf_name]
 13402                                  	;;lea	si,[si+1]
 13403                                  	;LEA	SI,[SI+SYS_FCB.name]
 13404                                  	;;mov	cx,11
 13405                                  	;MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 13406                                  	;repe	cmpsb
 13407                                  	;pop	si
 13408                                  	;pop	di
 13409                                  	;jnz	short BadSFT
 13410                                  	;;mov	bx,[si+1Bh]
 13411                                  	;MOV	bX,[SI+fcb_nsl_firclus]
 13412                                  	;jmp	short CheckFirClus
 13413                                  
 13414                                  	; MSDOS 6.0
 13415                                  
 13416                                  	; SR;
 13417                                  	; The code below to match a local FCB with its SFT can no longer be
 13418                                  	; used. We just return a no-match status. This check is done right
 13419                                  	; at the top.
 13420                                  
 13421                                  CheckNoShareDev:
 13422                                  	;mov	bx,[si+1Ah]
 13423 00001B78 8B5C1A                  	MOV	BX,[SI+fcb_nsld_drvptr]
 13424                                  	;cmp	bx,[es:di+7]
 13425 00001B7B 263B5D07                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr]
 13426 00001B7F 7509                    	JNZ	short BadSFT
 13427                                  	;mov	bx,[si+1Ch]
 13428 00001B81 8B5C1C                  	MOV	BX,[SI+fcb_nsld_drvptr+2]
 13429                                  	;cmp	bx,[es:di+9]
 13430 00001B84 263B5D09                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr+2]
 13431                                  	;JNZ	short BadSFT
 13432                                  	;JMP	short CheckD
 13433                                  	; 26/06/2024
 13434 00001B88 74D6                    	jz	short CheckD
 13435                                  
 13436                                  ; 26/06/2024
 13437                                  BadSFT: 
 13438 00001B8A F9                      	STC
 13439 00001B8B C3                      	retn
 13440                                  
 13441                                  ;Break	<SFTFromFCB - take a FCB and obtain a SFT from it>
 13442                                  ;----------------------------------------------------------------------------
 13443                                  ;
 13444                                  ;   SFTFromFCB - the workhorse of this compatability crap. Check to see if
 13445                                  ;	the SFT for the FCB is Good. If so, make ThisSFT point to it. If not
 13446                                  ;	good, get one from the cache and regenerate it. Overlay the LRU field
 13447                                  ;	with PID
 13448                                  ;
 13449                                  ;   Inputs:	DS:SI point to FCB
 13450                                  ;   Outputs:	ThisSFT point to appropriate SFT
 13451                                  ;		Carry clear -> OK ES:DI -> SFT
 13452                                  ;		Carry set -> error in ax
 13453                                  ;   Registers modified: ES,DI, AX
 13454                                  ;
 13455                                  ;----------------------------------------------------------------------------
 13456                                  
 13457                                  SFTFromFCB:
 13458                                  	; called from fcbio and $fcb_close. SS already set up to DOSDATA
 13459                                  
 13460                                  	; 17/05/2019 - Retro DOS v4.0
 13461                                  
 13462 00001B8C 50                      	push	ax
 13463 00001B8D 53                      	push	bx
 13464                                  	;mov	al,[si+18h]
 13465 00001B8E 8A4418                  	MOV	AL,[SI+fcb_sfn] 	; set SFN for check
 13466 00001B91 E88CFF                  	call	CheckFCB
 13467 00001B94 5B                      	pop	bx
 13468 00001B95 58                      	pop	ax
 13469                                  	;MOV	[CS:THISSFT],DI		; SS override
 13470                                  	;MOV	[CS:THISSFT+2],ES
 13471 00001B96 36893E[9E05]            	MOV	[SS:THISSFT],DI		; SS override
 13472 00001B9B 368C06[A005]            	MOV	[SS:THISSFT+2],ES
 13473 00001BA0 7311                    	JNC	short Set_SFT		; no problems, just set thissft
 13474                                  	
 13475                                  	; 09/11/2022 (MSDOS 5.0)
 13476                                  	; 31/05/2019
 13477 00001BA2 06                      	push	es ; * (MSDOS 6.21) & (MSDOS 5.0)
 13478 00001BA3 E8BCE8                  	call	save_world
 13479 00001BA6 E870FE                  	call	FCBRegen
 13480 00001BA9 E89FE8                  	call	restore_world		; use macro restore world
 13481 00001BAC 07                      	pop	es ; * (MSDOS 6.21) ; 31/05/2019 ; 09/11/2022 (MSDOS 5.0)	
 13482                                  
 13483                                  	;MOV	AX,[CS:EXTERR]		; SS override
 13484 00001BAD 36A1[2403]              	MOV	AX,[SS:EXTERR]		; SS override
 13485 00001BB1 72C4                    	jc	short CheckNet_retn
 13486                                  
 13487                                  Set_SFT: 
 13488                                  	;LES	DI,[CS:THISSFT]		; SS override for THISSFT & PROC_ID
 13489 00001BB3 36C43E[9E05]            	les	di,[ss:THISSFT]
 13490                                  	;PUSH	word [CS:PROC_ID]	; set process id
 13491 00001BB8 36FF36[3C03]            	push	word [ss:PROC_ID]
 13492                                  	;pop	word [es:di+31h]
 13493 00001BBD 268F4531                	POP     word [ES:DI+SF_ENTRY.sf_PID]
 13494 00001BC1 C3                      	retn				; carry is clear
 13495                                  
 13496                                  ;Break	<FCBHardErr - generate INT 24 for hard errors on FCBS>
 13497                                  ;----------------------------------------------------------------------------
 13498                                  ;
 13499                                  ;   FCBHardErr - signal to a user app that he is trying to use an
 13500                                  ;	unavailable FCB.
 13501                                  ;
 13502                                  ;   Inputs:	none.
 13503                                  ;   Outputs:	none.
 13504                                  ;   Registers modified: all
 13505                                  ;
 13506                                  ;----------------------------------------------------------------------------
 13507                                  
 13508                                  FCBHardErr:
 13509                                  	; 17/05/2019 - Retro DOS v4.0
 13510 00001BC2 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 13511                                  	;
 13512                                  	;mov	ax,23h
 13513 00001BC7 B82300                  	MOV	AX,error_FCB_unavailable
 13514                                  	;;mov	byte [cs:ALLOWED],8
 13515                                  	;MOV	byte [CS:ALLOWED],Allowed_FAIL
 13516 00001BCA 26C606[4B03]08          	mov	byte [es:ALLOWED],Allowed_FAIL	
 13517                                  	
 13518                                  	;LES	BP,[CS:THISDPB]
 13519 00001BD0 26C42E[8A05]            	les	bp,[es:THISDPB]
 13520                                  	
 13521 00001BD5 BF0100                  	MOV	DI,1			; Fake some registers
 13522 00001BD8 89F9                    	MOV	CX,DI
 13523                                  	;mov	dx,[es:bp+0Bh]
 13524 00001BDA 268B560B                	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 13525 00001BDE E89635                  	call	HARDERR
 13526 00001BE1 F9                      	STC
 13527 00001BE2 C3                      	retn
 13528                                  
 13529                                  ;============================================================================
 13530                                  ; FCBIO2.ASM, MSDOS 6.0, 1991
 13531                                  ;============================================================================
 13532                                  ; 21/07/2018 - Retro DOS v3.0
 13533                                  ; 17/05/2019 - Retro DOS v4.0
 13534                                  
 13535                                  ;**	FCBIO2.ASM - Ancient 1.0 1.1 FCB system calls
 13536                                  ;
 13537                                  ;	GetRR
 13538                                  ;	GetExtent
 13539                                  ;	SetExtent
 13540                                  ;	GetExtended
 13541                                  ;	GetRecSize
 13542                                  ;	FCBIO
 13543                                  ;	$FCB_OPEN
 13544                                  ;	$FCB_CREATE
 13545                                  ;	$FCB_RANDOM_WRITE_BLOCK
 13546                                  ;	$FCB_RANDOM_READ_BLOCK
 13547                                  ;	$FCB_SEQ_READ
 13548                                  ;	$FCB_SEQ_WRITE
 13549                                  ;	$FCB_RANDOM_READ
 13550                                  ;	$FCB_RANDOM_WRITE
 13551                                  ;
 13552                                  ;	Revision history:
 13553                                  ;
 13554                                  ;		Created: ARR 4 April 1983
 13555                                  ;			 MZ  6 June  1983 completion of functions
 13556                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 13557                                  ;				  times.  Change so successive closes work by
 13558                                  ;				  always returning OK.	Also, detect I/O to
 13559                                  ;				  already closed FCB and return EOF.
 13560                                  ;		 MZ 16 Jan   1984 More braindamage.  Need to separate info
 13561                                  ;				  out of sft into FCB for reconnection
 13562                                  ;
 13563                                  ;	    A000   version 4.00	Jan. 1988
 13564                                  
 13565                                  ; Defintions for FCBOp flags
 13566                                  
 13567                                  RANDOM	equ 2				; random operation
 13568                                  FCBREAD equ 4				; doing a read
 13569                                  BLOCK	equ 8				; doing a block I/O
 13570                                  
 13571                                  ;Break <GetRR - return the random record field in DX:AX>
 13572                                  ;---------------------------------------------------------------------------
 13573                                  ;
 13574                                  ;   GetRR - correctly load DX:AX with the random record field (3 or 4 bytes)
 13575                                  ;	from the FCB pointed to by DS:SI
 13576                                  ;
 13577                                  ;   Inputs:	DS:SI point to an FCB
 13578                                  ;		BX has record size
 13579                                  ;   Outputs:	DX:AX contain the contents of the random record field
 13580                                  ;   Registers modified: none
 13581                                  ;---------------------------------------------------------------------------
 13582                                  
 13583                                  GetRR:
 13584                                  	;mov	ax,[si+21h]
 13585 00001BE3 8B4421                  	MOV	AX,[SI+SYS_FCB.RR]	; get low order part
 13586                                  	;mov	dx,[si+23h]
 13587 00001BE6 8B5423                  	MOV	DX,[SI+SYS_FCB.RR+2]	; get high order part
 13588 00001BE9 83FB40                  	CMP	BX,64			; ignore MSB of RR if recsiz > 64
 13589 00001BEC 7202                    	JB	short GetRRBye
 13590                                  GetExtent_bye:	; 21/01/2024
 13591 00001BEE 30F6                    	XOR	DH,DH
 13592                                  GetRRBye:
 13593 00001BF0 C3                      	retn
 13594                                  
 13595                                  ;Break <GetExtent - retrieve next location for sequential IO>
 13596                                  ;---------------------------------------------------------------------------
 13597                                  ;
 13598                                  ;   GetExtent - Construct the next record to perform I/O from the EXTENT and
 13599                                  ;	NR fields in the FCB.
 13600                                  ;
 13601                                  ;   Inputs:	DS:SI - point to FCB
 13602                                  ;   Outputs:	DX:AX contain the contents of the random record field
 13603                                  ;   Registers modified: none
 13604                                  ;---------------------------------------------------------------------------
 13605                                  
 13606                                  GetExtent:
 13607                                  	;mov	al,[si+20h]
 13608 00001BF1 8A4420                  	MOV	AL,[SI+SYS_FCB.NR]	; get low order piece
 13609                                  	;mov	dx,[si+0Ch]
 13610 00001BF4 8B540C                  	MOV	DX,[SI+SYS_FCB.EXTENT]	; get high order piece
 13611 00001BF7 D0E0                    	SHL	AL,1
 13612 00001BF9 D1EA                    	SHR	DX,1
 13613 00001BFB D0D8                    	RCR	AL,1	; move low order bit of DL to high order of AH
 13614 00001BFD 88D4                    	MOV	AH,DL
 13615 00001BFF 88F2                    	MOV	DL,DH
 13616                                  	; 21/01/2024
 13617                                  	;XOR	DH,DH
 13618                                  	;retn
 13619 00001C01 EBEB                    	jmp	short GetExtent_bye
 13620                                  
 13621                                  ;Break <SetExtent - update the extent/NR field>
 13622                                  ;---------------------------------------------------------------------------
 13623                                  ;
 13624                                  ;   SetExtent - change the position of an FCB by filling in the extent/NR
 13625                                  ;	fields
 13626                                  ;
 13627                                  ;   Inputs:	DS:SI point to FCB
 13628                                  ;		DX:AX is a record location in file
 13629                                  ;   Outputs:	Extent/NR fields are filled in
 13630                                  ;   Registers modified: CX
 13631                                  ;---------------------------------------------------------------------------
 13632                                  
 13633                                  SetExtent:
 13634 00001C03 50                      	push	ax
 13635 00001C04 52                      	push	dx
 13636 00001C05 89C1                    	MOV	CX,AX
 13637 00001C07 247F                    	AND	AL,7FH			; next rec field
 13638                                  	;mov	[si+20h],al
 13639 00001C09 884420                  	MOV	[SI+SYS_FCB.NR],AL
 13640 00001C0C 80E180                  	AND	CL,80H			; save upper bit
 13641 00001C0F D1E1                    	SHL	CX,1
 13642 00001C11 D1D2                    	RCL	DX,1			; move high bit of CX to low bit of DX
 13643 00001C13 88E8                    	MOV	AL,CH
 13644 00001C15 88D4                    	MOV	AH,DL
 13645                                  	;mov	[si+0Ch], ax
 13646 00001C17 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; all done
 13647 00001C1A 5A                      	pop	dx
 13648 00001C1B 58                      	pop	ax
 13649 00001C1C C3                      	retn
 13650                                  
 13651                                  ;Break <GetExtended - find FCB in potential extended fcb>
 13652                                  ;---------------------------------------------------------------------------
 13653                                  ;
 13654                                  ;   GetExtended - Make DS:SI point to FCB from DS:DX
 13655                                  ;
 13656                                  ;   Inputs:	DS:DX point to a possible extended FCB
 13657                                  ;   Outputs:	DS:SI point to the FCB part
 13658                                  ;		zeroflag set if not extended fcb
 13659                                  ;   Registers modified: SI
 13660                                  ;---------------------------------------------------------------------------
 13661                                  
 13662                                  GetExtended:
 13663 00001C1D 89D6                    	MOV	SI,DX			; point to Something
 13664 00001C1F 803CFF                  	CMP	BYTE [SI],-1		; look for extention
 13665 00001C22 7503                    	JNZ	short GetBye		; not there
 13666 00001C24 83C607                  	ADD	SI,7			; point to FCB
 13667                                  GetBye:
 13668 00001C27 39D6                    	CMP	SI,DX			; set condition codes
 13669                                  getextd_retn:
 13670 00001C29 C3                      	retn
 13671                                  
 13672                                  ;Break <GetRecSize - return in BX the FCB record size>
 13673                                  ;---------------------------------------------------------------------------
 13674                                  ;
 13675                                  ;   GetRecSize - return in BX the record size from the FCB at DS:SI
 13676                                  ;
 13677                                  ;   Inputs:	DS:SI point to a non-extended FCB
 13678                                  ;   Outputs:	BX contains the record size
 13679                                  ;   Registers modified: None
 13680                                  ;---------------------------------------------------------------------------
 13681                                  
 13682                                  	; 22/01/2024
 13683                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13684                                  GetRecSize:
 13685                                  	;mov	bx,[si+0Eh]
 13686 00001C2A 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 13687 00001C2D 09DB                    	OR	BX,BX			; is it nul?
 13688                                  	;jz	short getextd_retn
 13689                                  	; 22/01/2024 (BugFix)
 13690 00001C2F 75F8                    	jnz	short getextd_retn
 13691                                  	;MOV	BX,128			; use default size
 13692 00001C31 B380                    	mov	bl,128
 13693                                  	;mov	[si+0Eh],bx
 13694 00001C33 895C0E                  	MOV	[SI+SYS_FCB.RECSIZ],BX	; stuff it back
 13695 00001C36 C3                      	retn
 13696                                  ; 23/01/2024 - Retro DOS v5.0
 13697                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:61B3h
 13698                                  ; 23/01/2024 - Retro DOS v4.2
 13699                                  ; MSDOS 6.22 MSDOS.SYS - DOSCODE:5DC1h
 13700                                  ; 23/01/2024 - Retro DOS v4.1
 13701                                  ; MSDOS 5.0 MSDOS.SYS - DOSCODE:5DADh
 13702                                  
 13703                                  ; 22/07/2018 - Retro DOS v3.0
 13704                                  
 13705                                  ;BREAK <$FCB_Random_write_Block - write a block of records to a file >
 13706                                  ;----------------------------------------------------------------------------
 13707                                  ;
 13708                                  ;   $FCB_Random_Write_Block - retrieve a location from the FCB, seek to it
 13709                                  ;	and write a number of blocks from it.
 13710                                  ;
 13711                                  ;   Inputs:	DS:DX point to an FCB
 13712                                  ;   Outputs:	AL = 0 write was successful and the FCB position is updated
 13713                                  ;		AL <> 0 Not enough room on disk for the output
 13714                                  ;
 13715                                  ;----------------------------------------------------------------------------
 13716                                  
 13717                                  _$FCB_RANDOM_WRITE_BLOCK:
 13718                                  	;mov	AL,0Ah
 13719 00001C37 B00A                    	MOV	AL,RANDOM+BLOCK
 13720 00001C39 EB12                    	JMP	short FCBIO	; 23/01/2024
 13721                                  
 13722                                  ;BREAK <$FCB_Random_Read_Block - read a block of records to a file >
 13723                                  ;----------------------------------------------------------------------------
 13724                                  ;
 13725                                  ;   $FCB_Random_Read_Block - retrieve a location from the FCB, seek to it
 13726                                  ;	and read a number of blocks from it.
 13727                                  ;
 13728                                  ;   Inputs:	DS:DX point to an FCB
 13729                                  ;   Outputs:	AL = error codes defined above
 13730                                  ;
 13731                                  ;----------------------------------------------------------------------------
 13732                                  
 13733                                  _$FCB_RANDOM_READ_BLOCK:
 13734                                  	;mov	AL,0Eh
 13735 00001C3B B00E                    	MOV	AL,RANDOM+FCBREAD+BLOCK
 13736 00001C3D EB0E                    	JMP	short FCBIO	; 23/01/2024
 13737                                  
 13738                                  ;BREAK <$FCB_Seq_Read - read the next record from a file >
 13739                                  ;----------------------------------------------------------------------------
 13740                                  ;
 13741                                  ;   $FCB_Seq_Read - retrieve the next record from an FCB and read it into
 13742                                  ;	memory
 13743                                  ;
 13744                                  ;   Inputs:	DS:DX point to an FCB
 13745                                  ;   Outputs:	AL = error codes defined above
 13746                                  ;
 13747                                  ;----------------------------------------------------------------------------
 13748                                  
 13749                                  _$FCB_SEQ_READ:
 13750                                  	;mov	AL,4
 13751 00001C3F B004                    	MOV	AL,FCBREAD
 13752 00001C41 EB0A                    	JMP	short FCBIO	; 23/01/2024
 13753                                  
 13754                                  ;BREAK <$FCB_Seq_Write - write the next record to a file >
 13755                                  ;----------------------------------------------------------------------------
 13756                                  ;
 13757                                  ;   $FCB_Seq_Write - retrieve the next record from an FCB and write it to the
 13758                                  ;	file
 13759                                  ;
 13760                                  ;   Inputs:	DS:DX point to an FCB
 13761                                  ;   Outputs:	AL = error codes defined above
 13762                                  ;
 13763                                  ;----------------------------------------------------------------------------
 13764                                  
 13765                                  _$FCB_SEQ_WRITE:
 13766 00001C43 B000                    	MOV	AL,0
 13767 00001C45 EB06                    	JMP	short FCBIO	; 23/01/2024
 13768                                  
 13769                                  ;BREAK <$FCB_Random_Read - Read a single record from a file >
 13770                                  ;----------------------------------------------------------------------------
 13771                                  ;
 13772                                  ;   $FCB_Random_Read - retrieve a location from the FCB, seek to it and read a
 13773                                  ;	record from it.
 13774                                  ;
 13775                                  ;   Inputs:	DS:DX point to an FCB
 13776                                  ;   Outputs:	AL = error codes defined above
 13777                                  ;
 13778                                  ;----------------------------------------------------------------------------
 13779                                  
 13780                                  _$FCB_RANDOM_READ:
 13781                                  	;mov	AL,6
 13782 00001C47 B006                    	MOV	AL,RANDOM+FCBREAD
 13783                                  	; 23/01/2024
 13784                                  	;jmp	FCBIO 		; single block
 13785 00001C49 EB02                    	jmp	short FCBIO
 13786                                  
 13787                                  ;BREAK <$FCB_Random_Write - write a single record to a file >
 13788                                  ;----------------------------------------------------------------------------
 13789                                  ;
 13790                                  ;   $FCB_Random_Write - retrieve a location from the FCB, seek to it and write
 13791                                  ;	a record to it.
 13792                                  ;
 13793                                  ;   Inputs:	DS:DX point to an FCB
 13794                                  ;   Outputs:	AL = error codes defined above
 13795                                  ;
 13796                                  ;----------------------------------------------------------------------------
 13797                                  
 13798                                  _$FCB_RANDOM_WRITE:
 13799                                  	;mov	AL,2
 13800 00001C4B B002                    	MOV	AL,RANDOM
 13801                                  	; 23/01/2024
 13802                                  	;;jmp	FCBIO
 13803                                  	;jmp	short FCBIO
 13804                                  
 13805                                  ;BREAK <FCBIO - do internal FCB I/O>
 13806                                  ;---------------------------------------------------------------------------
 13807                                  ;
 13808                                  ;   FCBIO - look at FCBOP and merge all FCB operations into a single routine.
 13809                                  ;
 13810                                  ;   Inputs:	FCBOP flags which operations need to be performed
 13811                                  ;		DS:DX point to FCB
 13812                                  ;		CX may have count of number of records to xfer
 13813                                  ;   Outputs:	AL has error code
 13814                                  ;   Registers modified: all
 13815                                  ;---------------------------------------------------------------------------
 13816                                  
 13817                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13818                                  	; DOSCODE:5B17h (MSDOS 5.0 MSDOS.SYS)
 13819                                  
 13820                                  	; 23/01/2024
 13821                                  	; DOSCODE:5B2Bh (MSDOS 6.22 MSDOS.SYS)
 13822                                  
 13823                                  	; 23/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 13824                                  	; DOSCODE:61C9h (PCDOS 7.1 IBMDOS.COM)
 13825                                  
 13826                                  FCBIO:
 13827                                  
 13828                                  FEOF	EQU	1
 13829                                  FTRIM	EQU	2
 13830                                  
 13831                                  %define	FCBErr	byte [bp-1]  ; byte
 13832                                  %define	cRec	word [bp-3]  ; word
 13833                                  ;%define RecPos	word [bp-7]  ; dword
 13834                                  %define RecPosL	word [bp-7]  ; word
 13835                                  %define RecPosH	word [bp-5]  ; word
 13836                                  %define	RecSize	word [bp-9]  ; word
 13837                                  ;%define bPos	word [bp-13] ; dword
 13838                                  %define bPosL	word [bp-13] ; word
 13839                                  %define bPosH	word [bp-11] ; word
 13840                                  %define cByte	word [bp-15] ; word
 13841                                  %define cResult word [bp-17] ; word
 13842                                  %define	cRecRes	word [bp-19] ; word
 13843                                  %define	FCBOp	byte [bp-20] ; byte
 13844                                  ; 23/01/2024
 13845                                  %define bPos bp-13
 13846                                  
 13847                                  	;Enter
 13848                                  
 13849 00001C4D 55                      	push	bp
 13850 00001C4E 89E5                    	mov	bp,sp
 13851 00001C50 83EC14                  	sub	sp,20
 13852                                  	;mov	[bp-20],al
 13853 00001C53 8846EC                  	MOV	FCBOp,AL
 13854                                  	;mov	byte [bp-1],0
 13855 00001C56 C646FF00                	MOV	FCBErr,0		;   FCBErr = 0;
 13856 00001C5A E8C0FF                  	call	GetExtended		;   FCB = GetExtended ();
 13857                                  	;test	byte [bp-20],8
 13858 00001C5D F646EC08                	TEST	FCBOp,BLOCK		;   if ((OP&BLOCK) == 0)
 13859 00001C61 7503                    	JNZ	short GetPos
 13860 00001C63 B90100                  	MOV	CX,1			;	cRec = 1;
 13861                                  GetPos:
 13862                                  	;mov	[bp-3],cx
 13863 00001C66 894EFD                  	MOV	cRec,CX 		;*Tail coalesce
 13864 00001C69 E885FF                  	call	GetExtent		;   RecPos = GetExtent ();
 13865 00001C6C E8BBFF                  	call	GetRecSize		;   RecSize = GetRecSize ();
 13866                                  	;mov	[bp-9],bx
 13867 00001C6F 895EF7                  	MOV	RecSize,BX
 13868                                  	;test	byte [bp-20],2
 13869 00001C72 F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&RANDOM) <> 0)
 13870 00001C76 7403                    	JZ	short GetRec
 13871 00001C78 E868FF                  	call	GetRR			;	RecPos = GetRR ();
 13872                                  GetRec:
 13873                                  	;mov	[bp-7],ax
 13874 00001C7B 8946F9                  	MOV	RecPosL,AX		;*Tail coalesce
 13875                                  	;mov	[bp-5],dx
 13876 00001C7E 8956FB                  	MOV	RecPosH,DX
 13877 00001C81 E87FFF                  	call	SetExtent		;   SetExtent (RecPos);
 13878                                  	;mov	ax,[bp-5]
 13879 00001C84 8B46FB                  	MOV	AX,RecPosH		;   bPos = RecPos * RecSize;
 13880 00001C87 F7E3                    	MUL	BX
 13881 00001C89 89C7                    	MOV	DI,AX
 13882                                  	;mov	ax,[bp-7]
 13883 00001C8B 8B46F9                  	MOV	AX,RecPosL
 13884 00001C8E F7E3                    	MUL	BX
 13885 00001C90 01FA                    	ADD	DX,DI
 13886                                  	;mov	[bp-13],ax
 13887 00001C92 8946F3                  	MOV	bPosL,AX
 13888                                  	;mov	[bp-11],dx
 13889 00001C95 8956F5                  	MOV	bPosH,DX
 13890                                  	;mov	ax,[bp-3]
 13891 00001C98 8B46FD                  	MOV	AX,cRec 		;   cByte = cRec * RecSize;
 13892 00001C9B F7E3                    	MUL	BX
 13893                                  	;mov	[bp-15],ax
 13894 00001C9D 8946F1                  	MOV	cByte,AX
 13895                                  
 13896                                  ;hkn; 	SS override
 13897 00001CA0 360306[2C03]            	ADD	AX,[SS:DMAADD]		;   if (cByte+DMA > 64K) {
 13898 00001CA5 83D200                  	ADC	DX,0
 13899 00001CA8 7419                    	JZ	short DoOper
 13900                                  	;mov	byte [bp-1],2
 13901 00001CAA C646FF02                	MOV	FCBErr,FTRIM		;	FCBErr = FTRIM;
 13902                                  
 13903                                  ;hkn; 	SS override
 13904 00001CAE 36A1[2C03]              	MOV	AX,[SS:DMAADD]		;	cRec = (64K-DMA)/RecSize;
 13905 00001CB2 F7D8                    	NEG	AX
 13906 00001CB4 7501                    	JNZ	short DoDiv
 13907 00001CB6 48                      	DEC	AX
 13908                                  DoDiv:
 13909 00001CB7 31D2                    	XOR	DX,DX
 13910 00001CB9 F7F3                    	DIV	BX
 13911                                  	;mov	[bp-3],ax
 13912 00001CBB 8946FD                  	MOV	cRec,AX
 13913 00001CBE F7E3                    	MUL	BX			;	cByte = cRec * RecSize;
 13914                                  	;mov	[bp-15],ax
 13915 00001CC0 8946F1                  	MOV	cByte,AX		;	}
 13916                                  DoOper:
 13917 00001CC3 31DB                    	XOR	BX,BX
 13918                                  	;mov	[bp-17],bx
 13919 00001CC5 895EEF                  	MOV	cResult,BX		;   cResult = 0;
 13920                                  	;cmp	[bp-15],bx
 13921 00001CC8 395EF1                  	CMP	cByte,BX		;   if (cByte <> 0 ||
 13922 00001CCB 7506                    	JNZ	short DoGetExt
 13923                                  	;test	byte [bp-1],2
 13924 00001CCD F646FF02                	TEST	FCBErr,FTRIM		;	(FCBErr&FTRIM) == 0) {
 13925                                  	;JZ	short DoGetExt
 13926                                  	;JMP	short SkipOp
 13927                                  	; 16/12/2022
 13928 00001CD1 7572                    	jnz	short SkipOp
 13929                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13930                                  	;JZ	short DoGetExt
 13931                                  	;JMP	short SkipOp
 13932                                  DoGetExt:
 13933 00001CD3 E8B6FE                  	call	SFTFromFCB		;	if (!SFTFromFCB (SFT,FCB))
 13934 00001CD6 730F                    	JNC	short ContinueOp
 13935                                  FCBDeath:
 13936 00001CD8 E875E9                  	call	FCB_RET_ERR		; signal error, map for extended
 13937                                  	;mov	word [bp-19],0
 13938 00001CDB C746ED0000              	MOV	cRecRes,0		; no bytes transferred
 13939                                  	;mov	byte [bp-1],1
 13940 00001CE0 C646FF01                	MOV	FCBErr,FEOF		;	    return FTRIM;
 13941 00001CE4 E9EB00                  	JMP	FCBSave 		; bam!
 13942                                  ContinueOp:
 13943                                  	; 23/01/2024
 13944                                  	; (PCDOS 7.1 IBMDOS.COM)
 13945                                  	;
 13946                                  	;;mov	ax,[si+10h]
 13947                                  	;MOV	AX,[SI+SYS_FCB.FILSIZ]
 13948                                  	;;mov	[es:di+11h],ax
 13949                                  	;MOV	[ES:DI+SF_ENTRY.sf_size],AX
 13950                                  	;;mov	ax,[si+12h]
 13951                                  	;MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 13952                                  	;;mov	[es:di+13h],ax
 13953                                  	;MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 13954                                  	;;;
 13955 00001CE7 1E                      	push	ds
 13956 00001CE8 C54410                  	lds	ax,[si+SYS_FCB.FILSIZ]
 13957 00001CEB 26894511                	mov	[es:di+SF_ENTRY.sf_size],ax
 13958 00001CEF 268C5D13                	mov	[es:di+SF_ENTRY.sf_size+2],ds
 13959 00001CF3 C546F3                  	lds	ax,[bPos] ; lds ax,[bp-13]
 13960 00001CF6 8CDA                    	mov	dx,ds
 13961 00001CF8 1F                      	pop	ds
 13962                                  	;;;
 13963                                  	;;mov	ax,[bp-13]
 13964                                  	;MOV	AX,bPosL
 13965                                  	;;mov	dx,[bp-11]
 13966                                  	;MOV	DX,bPosH
 13967                                  
 13968                                  	;mov	[es:di+15h],ax
 13969 00001CF9 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 13970                                  	;xchg	dx,[es:di+17h]
 13971 00001CFD 26875517                	XCHG	[ES:DI+SF_ENTRY.sf_position+2],DX
 13972 00001D01 52                      	PUSH	DX			; save away Open age.
 13973                                  	;mov	cx,[bp-15]
 13974 00001D02 8B4EF1                  	MOV	CX,cByte		;	cResult =
 13975                                  
 13976                                  ;hkn; DOS_Read is in DOSCODE
 13977 00001D05 BF[F031]                	MOV	DI,DOS_READ		;	    *(OP&FCBRead ? DOS_Read
 13978                                  	;test	byte [bp-20],4
 13979 00001D08 F646EC04                	TEST	FCBOp,FCBREAD		;		 : DOS_Write)(cRec);
 13980 00001D0C 7503                    	JNZ	short DoContext
 13981                                  
 13982                                  ;hkn; DOS_Write is in DOSCODE
 13983 00001D0E BF[F033]                	MOV	DI,DOS_WRITE
 13984                                  DoContext:
 13985 00001D11 55                      	push	bp
 13986 00001D12 1E                      	push	ds
 13987 00001D13 56                      	push	si
 13988                                  
 13989                                  ;hkn; SS is DOSDATA
 13990 00001D14 16                      	push	ss
 13991 00001D15 1F                      	pop	ds
 13992                                  
 13993                                  ;; Fix for disk full
 13994 00001D16 FFD7                    	CALL	DI	; DOS_READ or DOS_WRITE
 13995                                  	
 13996 00001D18 5E                      	pop	si
 13997 00001D19 1F                      	pop	ds
 13998 00001D1A 5D                      	pop	bp
 13999 00001D1B 72BB                    	JC	short FCBDeath
 14000                                  	
 14001 00001D1D 36803E[0B06]00          	CMP	BYTE [SS:DISK_FULL],0	; treat disk full as error
 14002 00001D23 740A                    	JZ	short NODSKFULL
 14003 00001D25 36C606[0B06]00          	MOV	BYTE [SS:DISK_FULL],0	; clear the flag
 14004                                  
 14005                                  	; (MSDOS 5.0-6.22 MSDOS.SYS) ; 23/01/2024
 14006                                  	;mov	byte [bp-1],1 
 14007 00001D2B C646FF01                	MOV	FCBErr,FEOF		; set disk full flag
 14008                                  
 14009                                  	; 23/01/2024
 14010                                  	; (PCDOS 7.1 IBMDOS.COM)
 14011                                  	;;mov	byte [bp-1],1 
 14012                                  	;MOV	FCBErr,FEOF		; set disk full flag
 14013                                  
 14014                                  NODSKFULL:
 14015                                  ;; Fix for disk full
 14016                                  	;mov	[bp-17],cx
 14017 00001D2F 894EEF                  	MOV	cResult,CX
 14018 00001D32 E832FB                  	call	SaveFCBInfo		;	SaveFCBInfo (FCB);
 14019                                  	;pop	word [es:di+17h]	
 14020 00001D35 268F4517                	POP	WORD [ES:DI+SF_ENTRY.sf_position+2] ; restore open age
 14021                                  			       ; (sf_OpenAge = SF_ENTRY.sf_position+2)
 14022                                  
 14023                                  	; 23/01/2024
 14024                                  	; (PCDOS 7.1 IBMDOS.COM)
 14025                                  	;
 14026                                  	;;mov	ax,[es:di+11h]
 14027                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 14028                                  	;;mov	[si+10h],ax
 14029                                  	;MOV	[SI+SYS_FCB.FILSIZ],AX
 14030                                  	;;mov	ax,[es:di+13h]
 14031                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 14032                                  	;;mov	[si+12h],ax
 14033                                  	;MOV	[SI+SYS_FCB.FILSIZ+2],AX
 14034                                  	;;;
 14035 00001D39 06                      	push	es
 14036 00001D3A 26C44511                	les	ax,[es:di+SF_ENTRY.sf_size]
 14037 00001D3E 894410                  	mov	[si+SYS_FCB.FILSIZ],ax
 14038 00001D41 8C4412                  	mov	[si+SYS_FCB.FILSIZ+2],es
 14039 00001D44 07                      	pop	es
 14040                                  	;;;
 14041                                  					;	}
 14042                                  SkipOp:
 14043                                  	;mov	ax,[bp-17]
 14044 00001D45 8B46EF                  	MOV	AX,cResult		;   cRecRes = cResult / RecSize;
 14045 00001D48 31D2                    	XOR	DX,DX
 14046                                  	;div	word [bp-9]
 14047 00001D4A F776F7                  	DIV	RecSize
 14048                                  	;mov	[bp-19],ax
 14049 00001D4D 8946ED                  	MOV	cRecRes,AX
 14050                                  	;add	[bp-7],ax
 14051 00001D50 0146F9                  	ADD	RecPosL,AX		;   RecPos += cRecResult;
 14052                                  	;adc	word [bp-5],0
 14053 00001D53 8356FB00                	ADC	RecPosH,0
 14054                                  
 14055                                  ; If we have not gotten the expected number of records, we signal an EOF
 14056                                  ; condition. On input, this is EOF. On output this is usually disk full.
 14057                                  ; BUT... Under 2.0 and before, all device output IGNORED this condition. So
 14058                                  ; do we.
 14059                                  
 14060                                  	;cmp	ax,[bp-3]
 14061 00001D57 3B46FD                  	CMP	AX,cRec 		;   if (cRecRes <> cRec)
 14062 00001D5A 7411                    	JZ	short TryBlank
 14063                                  	;test	byte [bp-20],4
 14064 00001D5C F646EC04                	TEST	FCBOp,FCBREAD		;	if (OP&FCBRead || !DEVICE)
 14065 00001D60 7507                    	JNZ	short SetEOF
 14066                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14067                                  	; MSDOS 3.3
 14068                                  	;;test	word [es:di+5],80h
 14069                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 14070                                  	;JNZ	short TryBlank
 14071                                  	; MSDOS 5.0 & MSDOS 6.0
 14072                                  	;test	byte [es:di+5],80h
 14073 00001D62 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 14074 00001D67 7504                    	jnz	short TryBlank
 14075                                  
 14076                                  SetEOF:
 14077                                  	;mov	byte [bp-1],1
 14078 00001D69 C646FF01                	MOV	FCBErr,FEOF		;	FCBErr = FEOF;
 14079                                  TryBlank:				;
 14080 00001D6D 09D2                    	OR	DX,DX			;   if (cResult%RecSize <> 0) {
 14081 00001D6F 7426                    	JZ	short SetExt
 14082                                  	;add	word [bp-7],1
 14083 00001D71 8346F901                	ADD	RecPosL,1		;	RecPos++;
 14084                                  	;adc	word [bp-5],0
 14085 00001D75 8356FB00                	ADC	RecPosH,0
 14086                                  	;test	byte [bp-20],4
 14087 00001D79 F646EC04                	TEST	FCBOp,FCBREAD		;	if(OP&FCBRead) <> 0) {
 14088 00001D7D 7418                    	JZ	short SetExt
 14089                                  	;inc	word [bp-19]
 14090 00001D7F FF46ED                  	INC	cRecRes 		;	cRecRes++;
 14091                                  	;mov	byte [bp-1],3
 14092 00001D82 C646FF03                	MOV	FCBErr,FTRIM+FEOF	;	FCBErr = FTRIM | FEOF;
 14093                                  	;mov	cx,[bp-9]
 14094 00001D86 8B4EF7                  	MOV	CX,RecSize		;	Blank (RecSize-cResult%RecSize,
 14095 00001D89 29D1                    	SUB	CX,DX			;	       DMA+cResult);
 14096 00001D8B 30C0                    	XOR	AL,AL
 14097                                  ;hkn; 	SS override
 14098 00001D8D 36C43E[2C03]            	les     di,[ss:DMAADD]
 14099                                  	;add	di,[bp-17]
 14100 00001D92 037EEF                  	ADD	DI,cResult
 14101 00001D95 F3AA                    	REP	STOSB			;   }	}
 14102                                  SetExt:
 14103                                  	;mov	dx,[bp-5]
 14104 00001D97 8B56FB                  	MOV	DX,RecPosH
 14105                                  	;mov	ax,[bp-7]
 14106 00001D9A 8B46F9                  	MOV	AX,RecPosL
 14107                                  	;test	byte [bp-20],2
 14108 00001D9D F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&Random) == 0 ||
 14109 00001DA1 7406                    	JZ	short DoSetExt
 14110                                  	;test	byte [bp-20],8
 14111 00001DA3 F646EC08                	TEST	FCBOp,BLOCK		;	(OP&BLOCK) <> 0)
 14112 00001DA7 7403                    	JZ	short TrySetRR
 14113                                  DoSetExt:
 14114 00001DA9 E857FE                  	call	SetExtent		;	SetExtent (RecPos, FCB);
 14115                                  TrySetRR:
 14116                                  	;test	byte [bp-20],8
 14117 00001DAC F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 14118 00001DB0 740F                    	JZ	short TryReturn
 14119                                  	;mov	[si+21h],ax
 14120 00001DB2 894421                  	MOV	[SI+SYS_FCB.RR],AX	;	FCB->RR = RecPos;
 14121                                  	;mov	[si+23h],dl
 14122 00001DB5 885423                  	MOV	[SI+SYS_FCB.RR+2],DL
 14123                                  	;cmp	word [si+0Eh],64
 14124 00001DB8 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 14125 00001DBC 7303                    	JAE	short TryReturn
 14126                                  	;mov	[si+24h],dh
 14127 00001DBE 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 14128                                  TryReturn: 
 14129                                  	;test	byte [bp-20],4
 14130 00001DC1 F646EC04                	TEST	FCBOp,FCBREAD		;   if (!(FCBOP & FCBREAD)) {
 14131 00001DC5 750B                    	JNZ	short FCBSave
 14132 00001DC7 1E                      	push	ds			;	FCB->FDate = date;
 14133 00001DC8 E815ED                  	call	DATE16			;	FCB->FTime = time;
 14134 00001DCB 1F                      	pop	ds
 14135                                  	;mov	[si+14h],ax
 14136 00001DCC 894414                  	MOV	[SI+SYS_FCB.FDATE],AX
 14137                                  	;mov	[si+16h],dx
 14138 00001DCF 895416                  	MOV	[SI+SYS_FCB.FTIME],DX	;	}
 14139                                  FCBSave: 
 14140                                  	;test	byte [bp-20],8
 14141 00001DD2 F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 14142 00001DD6 7409                    	jz	short DoReturn
 14143                                  	;mov	cx,[bp-19]
 14144 00001DD8 8B4EED                  	MOV	CX,cRecRes		;	user_CX = cRecRes;
 14145 00001DDB E8A3E6                  	call    Get_User_Stack
 14146                                  	;mov	[si+4],cx
 14147 00001DDE 894C04                  	MOV	[SI+user_env.user_CX],CX
 14148                                  DoReturn:
 14149                                  	;mov	al,[bp-1]
 14150 00001DE1 8A46FF                  	MOV	AL,FCBErr		;   return (FCBERR);
 14151                                  	;Leave	
 14152 00001DE4 89EC                    	mov     sp,bp
 14153 00001DE6 5D                      	pop     bp
 14154 00001DE7 C3                      	retn
 14155                                  
 14156                                  ; 22/07/2018 - Retro DOS v3.0
 14157                                  
 14158                                  ;Break <$FCB_Open - open an old-style FCB>
 14159                                  ;---------------------------------------------------------------------------
 14160                                  ;
 14161                                  ;   $FCB_Open - CPM compatability file open. The user has formatted an FCB
 14162                                  ;	for us and asked to have the rest filled in.
 14163                                  ;
 14164                                  ;   Inputs:	DS:DX point to an unopenned FCB
 14165                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 14166                                  ;		FCB has the following fields filled in:
 14167                                  ;		    Time/Date Extent/NR Size
 14168                                  ;---------------------------------------------------------------------------
 14169                                  
 14170                                  _$FCB_OPEN:			; System call 15
 14171                                  
 14172 00001DE8 B80200                  	MOV	AX,SHARING_COMPAT+open_for_both
 14173                                  
 14174                                  ;hkn; DOS_Open is in DOSCODE
 14175 00001DEB B9[B62A]                	MOV	CX,DOS_OPEN
 14176                                  
 14177                                  ; The following is common code for Creation and openning of FCBs. AX is
 14178                                  ; either attributes (for create) or open mode (for open)... DS:DX points to
 14179                                  ; the FCB
 14180                                  
 14181                                  DoAccess:
 14182 00001DEE 1E                      	push	ds
 14183 00001DEF 52                      	push	dx
 14184 00001DF0 51                      	push	cx
 14185 00001DF1 50                      	push	ax			; save FCB pointer away
 14186                                  
 14187                                  ;hkn; 	OpenBuf is in DOSDATA
 14188 00001DF2 BF[BE03]                	MOV	DI,OPENBUF
 14189 00001DF5 E8514B                  	call	TransFCB		; crunch the fcb
 14190 00001DF8 58                      	pop	ax
 14191 00001DF9 59                      	pop	cx
 14192 00001DFA 5A                      	pop	dx
 14193 00001DFB 1F                      	pop	ds			; get fcb
 14194 00001DFC 7303                    	JNC	short FindFCB		; everything seems ok
 14195                                  FCBOpenErr:
 14196                                  	; AL has error code
 14197 00001DFE E94FE8                  	jmp	FCB_RET_ERR
 14198                                  FindFCB:
 14199 00001E01 E819FE                  	call	GetExtended		; DS:SI will point to FCB
 14200                                  
 14201                                  	; 17/05/2019 - Retro DOS v4.0
 14202                                  
 14203                                  	; MSDOS 3.3
 14204                                  	;call	LRUFCB
 14205                                  	;jc	short HardMessage
 14206                                  
 14207                                  	; MSDOS 6.0
 14208 00001E04 50                      	push	ax
 14209 00001E05 B001                    	mov	al,1			;indicate Open/Create operation
 14210 00001E07 E82BFB                  	call	LRUFCB			; get a sft entry (no error)
 14211 00001E0A 58                      	pop	ax
 14212 00001E0B 722A                    	jc	short HardMessage
 14213                                  	
 14214                                  	;mov	word [es:di+2],8000h
 14215 00001E0D 26C745020080            	mov	word [es:di+SF_ENTRY.sf_mode],sf_isFCB
 14216 00001E13 1E                      	push	ds
 14217 00001E14 56                      	push	si	
 14218 00001E15 53                      	push	bx			; save fcb pointer
 14219 00001E16 89CE                    	MOV	SI,CX
 14220                                  
 14221                                  ;hkn; SS is DOSDATA
 14222 00001E18 16                      	push	ss
 14223 00001E19 1F                      	pop	ds			    ; let DOS_Open see variables
 14224 00001E1A FFD6                    	CALL	SI ; DOS_OPEN or DOS_CREATE ; go open the file
 14225 00001E1C 5B                      	pop	bx
 14226 00001E1D 5E                      	pop	si
 14227 00001E1E 1F                      	pop	ds			; get fcb
 14228                                  
 14229                                  ;hkn; SS override
 14230 00001E1F 36C43E[9E05]            	LES	DI,[SS:THISSFT]		; get sf pointer
 14231 00001E24 7318                    	JNC	short FCBOK		; operation succeeded
 14232                                  failopen:
 14233 00001E26 50                      	PUSH	AX
 14234 00001E27 B052                    	MOV	AL,"R"	; 52h		; clear out field (free sft)
 14235 00001E29 E8DEFC                  	call	BlastSFT
 14236 00001E2C 58                      	POP	AX
 14237                                  	;cmp	ax,4
 14238 00001E2D 83F804                  	CMP	AX,error_too_many_open_files
 14239 00001E30 7405                    	JZ	short HardMessage
 14240                                  	;cmp	ax,24h
 14241 00001E32 83F824                  	CMP	AX,error_sharing_buffer_exceeded
 14242 00001E35 7505                    	jnz	short DeadFCB
 14243                                  HardMessage:
 14244 00001E37 50                      	PUSH	AX
 14245 00001E38 E887FD                  	call	FCBHardErr
 14246 00001E3B 58                      	POP	AX
 14247                                  DeadFCB:
 14248                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14249                                  	;jmp	FCB_RET_ERR
 14250 00001E3C EBC0                    	jmp	short FCBOpenErr
 14251                                  FCBOK:
 14252                                  	; MSDOS 6.0
 14253 00001E3E E801F4                  	call	IsSFTNet		;AN007;F.C. >32mb  Non Fat file?
 14254 00001E41 750F                    	JNZ	short FCBOK2		;AN007;F.C. >32mb  yes
 14255 00001E43 E8F752                  	call	CheckShare		;AN000;F.C. >32mb  share around?
 14256 00001E46 750A                    	JNZ	short FCBOK2		;AN000;F.C. >32mb  yes
 14257                                  ;SR;
 14258                                  ; If we reach here, we know we have got a local SFT. Let's update the 
 14259                                  ; LocalSFT variable to reflect this.
 14260                                  
 14261 00001E48 36893E[5D10]            	mov	[ss:LocalSFT],di
 14262 00001E4D 368C06[5F10]            	mov	[ss:LocalSFT+2],es; Store the SFT address
 14263                                  ;;SR;
 14264                                  ;; The check below is not valid anymore since we regenerate for media > 32M.
 14265                                  ;;
 14266                                  ;;	CMP	WORD [ES:DI+SF_ENTRY.sf_dirsec+2],0 
 14267                                  ;;					       ;AN000;F.C. >32mb  if dirsec >32mb
 14268                                  ;;	JZ	short FCBOK2		       ;AN000;F.C. >32mb    then error
 14269                                  ;;	MOV	AX,error_sys_comp_not_loaded   ;AN000;F.C. >32mb
 14270                                  ;;	JMP	short failopen		       ;AN000;F.C. >32mb
 14271                                  
 14272                                  FCBOK2:
 14273                                  	; MSDOS 6.0 (& MSDOS 3.3)
 14274 00001E52 26FF05                  	inc	word [es:di]
 14275                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count] ; increment reference count
 14276 00001E55 E80FFA                  	call	SaveFCBInfo
 14277                                  	; MSDOS 3.3
 14278                                  	;call	SetOpenAge
 14279                                  	; MSDOS 6.0 (& MSDOS 3.3)
 14280                                  	;test	word [es:di+5],80h
 14281                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 14282 00001E58 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device  ; 28/07/2019
 14283 00001E5D 7508                    	JNZ	short FCBNoDrive	; do not munge drive on devices
 14284 00001E5F 8A04                    	MOV	AL,[SI]			; get drive byte
 14285 00001E61 E8704A                  	call	GETTHISDRV		; convert
 14286                                  	;INC	AL
 14287                                  	; 17/12/2022
 14288 00001E64 40                      	inc	ax
 14289 00001E65 8804                    	MOV	[SI],AL			; stash in good drive letter
 14290                                  
 14291                                  FCBNoDrive:
 14292                                  	;mov	word [si+0Eh],128
 14293 00001E67 C7440E8000              	MOV	word [SI+SYS_FCB.RECSIZ],80h ; stuff in default record size
 14294                                  
 14295                                  	; 23/01/2024
 14296                                  	; (PCDOS 7.1 IBMDOS.COM)
 14297                                  	;;;
 14298                                  	;;mov	ax,[es:di+0Dh]
 14299                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_time] ; set time
 14300                                  	;;mov	[si+16h],ax
 14301                                  	;MOV	[SI+SYS_FCB.FTIME],AX
 14302                                  	;;mov	ax,[es:di+0Fh]
 14303                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_date] ; set date
 14304                                  	;;mov	[si+14h],ax
 14305                                  	;MOV	[SI+SYS_FCB.FDATE],AX
 14306                                  	;;mov	ax,[es:di+11h]
 14307                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_size] ; set sizes
 14308                                  	;;mov	[si+10h],ax
 14309                                  	;MOV	[SI+SYS_FCB.FILSIZ],AX
 14310                                  	;;mov	ax,[es:di+13h]
 14311                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 14312                                  	;;mov	[si+12h],ax
 14313                                  	;MOV	[SI+SYS_FCB.FILSIZ+2],AX
 14314                                  	;
 14315 00001E6C 06                      	push	es
 14316                                  	;les	ax,[es:di+0Dh]
 14317 00001E6D 26C4450D                	les	ax,[es:di+SF_ENTRY.sf_time]
 14318                                  	;mov	[si+16h],ax
 14319 00001E71 894416                  	mov	[si+SYS_FCB.FTIME],ax	; set time
 14320                                  	;mov	[si+14h],es
 14321 00001E74 8C4414                  	mov	[si+SYS_FCB.FDATE],es	; set date
 14322 00001E77 07                      	pop	es
 14323 00001E78 06                      	push	es
 14324                                  	;les	ax,[es:di+11h]
 14325 00001E79 26C44511                	les	ax,[es:di+SF_ENTRY.sf_size] ; set size
 14326                                  	;mov	[si+10h],ax
 14327 00001E7D 894410                  	mov	[si+SYS_FCB.FILSIZ],ax
 14328                                  	;mov	[si+12h],ax
 14329 00001E80 8C4412                  	mov	[si+SYS_FCB.FILSIZ+2],es
 14330 00001E83 07                      	pop	es
 14331                                  	;;;
 14332                                  	
 14333 00001E84 31C0                    	XOR	AX,AX			; convenient zero
 14334                                  	;mov	[si+0Ch],ax
 14335 00001E86 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; point to beginning of file
 14336                                  
 14337                                  ; We must scan the set of FCB SFTs for one that appears to match the current
 14338                                  ; one.	We cheat and use CheckFCB to match the FCBs.
 14339                                  
 14340                                  ;hkn; 	SS override
 14341 00001E89 36C43E[4000]            	LES	DI,[SS:SFTFCB]		; get the pointer to head of the list
 14342                                  	;mov	ah,[es:di+4]
 14343 00001E8E 268A6504                	MOV	AH,[ES:DI+SFT.SFCount]	; get number of SFTs to scan
 14344                                  OpenScan:
 14345                                  	;cmp	al,[si+18h]
 14346 00001E92 3A4418                  	CMP	AL,[SI+fcb_sfn]		; don't compare ourselves
 14347 00001E95 7407                    	JZ	short SkipCheck
 14348 00001E97 50                      	push	ax			; preserve count
 14349 00001E98 E885FC                  	call	CheckFCB		; do they match
 14350 00001E9B 58                      	pop	ax			; get count back
 14351 00001E9C 7309                    	JNC	short OpenFound		; found a match!
 14352                                  SkipCheck:
 14353 00001E9E FEC0                    	INC	AL			; advance to next FCB
 14354 00001EA0 38E0                    	CMP	AL,AH			; table full?
 14355 00001EA2 75EE                    	JNZ	short OpenScan		; no, go for more
 14356                                  OpenDone:
 14357 00001EA4 30C0                    	xor	al,al			; return success
 14358 00001EA6 C3                      	retn
 14359                                  
 14360                                  ; The SFT at ES:DI is the one that is already in use for this FCB. We set the
 14361                                  ; FCB to use this one. We increment its ref count. We do NOT close it at all.
 14362                                  ; Consider:
 14363                                  ;
 14364                                  ;   open (foo)	delete (foo) open (bar)
 14365                                  ;
 14366                                  ; This causes us to recycle (potentially) bar through the same local SFT as
 14367                                  ; foo even though foo is no longer needed; this is due to the server closing
 14368                                  ; foo for us when we delete it. Unfortunately, we cannot see this closure.
 14369                                  ; If we were to CLOSE bar, the server would then close the only reference to
 14370                                  ; bar and subsequent I/O would be lost to the redirector.
 14371                                  ;
 14372                                  ; This gets solved by NOT closing the sft, but zeroing the ref count
 14373                                  ; (effectively freeing the SFT) and informing the sharer (if relevant) that
 14374                                  ; the SFT is no longer in use. Note that the SHARER MUST keep its ref counts
 14375                                  ; around. This will allow us to access the same file through multiple network
 14376                                  ; connections and NOT prematurely terminate when the ref count on one
 14377                                  ; connection goes to zero.
 14378                                  
 14379                                  OpenFound:
 14380                                  	;mov	[si+18h],al
 14381 00001EA7 884418                  	MOV	[SI+fcb_sfn],AL 	; assign with this
 14382 00001EAA 26FF05                  	inc	word [es:di]
 14383                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 14384                                  					; remember this new invocation
 14385                                  	; 24/01/2024
 14386 00001EAD 16                      	push	ss
 14387 00001EAE 1F                      	pop	ds
 14388                                  	
 14389                                  	;MOV	AX,[SS:FCBLRU]		; update LRU counts
 14390 00001EAF A1[1000]                	mov	ax,[FCBLRU] ; 24/01/2024
 14391                                  	;mov	[es:di+15h],ax
 14392 00001EB2 26894515                	MOV	[ES:DI+sf_LRU],AX
 14393                                  ;
 14394                                  ; We have an FCB sft that is now of no use. We release sharing info and then
 14395                                  ; blast it to prevent other reuse.
 14396                                  ;
 14397                                  	;push	ss
 14398                                  	;pop	ds
 14399                                  
 14400 00001EB6 C43E[9E05]              	LES	DI,[THISSFT]
 14401 00001EBA 26FF0D                  	dec	word [es:di]
 14402                                  	;DEC	word [ES:DI+SF_ENTRY.sf_ref_count]
 14403                                  					; free the newly allocated SFT
 14404 00001EBD E8AE52                  	call	ShareEnd
 14405 00001EC0 B043                    	MOV	AL,'C'	 ; 43h
 14406 00001EC2 E845FC                  	call	BlastSFT
 14407 00001EC5 EBDD                    	JMP	short OpenDone
 14408                                  
 14409                                  ;BREAK	<$FCB_Create - create a new directory entry>
 14410                                  ;----------------------------------------------------------------------------
 14411                                  ;
 14412                                  ;   $FCB_Create - CPM compatability file create. The user has formatted an
 14413                                  ;	FCB for us and asked to have the rest filled in.
 14414                                  ;
 14415                                  ;   Inputs:	DS:DX point to an unopenned FCB
 14416                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 14417                                  ;		FCB has the following fields filled in:
 14418                                  ;		    Time/Date Extent/NR Size
 14419                                  ;----------------------------------------------------------------------------
 14420                                  
 14421                                  _$FCB_CREATE:		; System call 22
 14422                                  
 14423                                  ;hkn; DOS_Create is in DOSCODE
 14424 00001EC7 B9[9029]                	MOV	CX,DOS_CREATE		; routine to call
 14425 00001ECA 31C0                    	XOR	AX,AX			; attributes to create
 14426 00001ECC E84EFD                  	call	GetExtended		; get extended FCB
 14427 00001ECF 7403                    	JZ	short DoAccessJ		; not an extended FCB
 14428 00001ED1 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 14429                                  DoAccessJ:
 14430 00001ED4 E917FF                  	JMP	DoAccess		; do dirty work
 14431                                  
 14432                                  ;============================================================================
 14433                                  ; SEARCH.ASM, MSDOS 6.0, 1991
 14434                                  ;============================================================================
 14435                                  ; 22/07/2018 - Retro DOS v3.0
 14436                                  ; 17/05/2019 - Retro DOS v4.0
 14437                                  
 14438                                  ; DOSCODE:5DDFh (MSDOS 6.21, MSDOS.SYS)
 14439                                  
 14440                                  ; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14441                                  ; DOSCODE:5DCBh (MSDOS 5.0, MSDOS.SYS)
 14442                                  
 14443                                  ;**	Search.asm
 14444                                  ;----------------------------------------------------------------------------
 14445                                  ;	Directory search system calls.
 14446                                  ;	These will be passed direct text of the pathname from the user. 
 14447                                  ;	They will need to be passed through the macro expander prior to
 14448                                  ;	being sent through the low-level stuff. 
 14449                                  ;	I/O specs are defined in DISPATCH. The system calls are:
 14450                                  ;
 14451                                  ;	$Dir_Search_First	  written
 14452                                  ;	$Dir_Search_Next	  written
 14453                                  ;	$Find_First	  written
 14454                                  ;	$Find_Next		  written
 14455                                  ;	PackName		  written
 14456                                  ;
 14457                                  ;	Modification history:
 14458                                  ;
 14459                                  ;	  Created: ARR 4 April 1983
 14460                                  
 14461                                  ;----------------------------------------------------------------------------
 14462                                  ; Procedure Name : $DIR_SEARCH_FIRST
 14463                                  ;
 14464                                  ; Inputs:
 14465                                  ;	DS:DX Points to unopenned FCB
 14466                                  ; Function:
 14467                                  ;	Directory is searched for first matching entry and the directory
 14468                                  ;	entry is loaded at the disk transfer address
 14469                                  ; Returns:
 14470                                  ;	AL = -1 if no entries matched, otherwise 0
 14471                                  ;----------------------------------------------------------------------------
 14472                                  
 14473                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 2B88h
 14474                                  
 14475                                  	; 24/01/2024
 14476                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:5DCBh
 14477                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:5DDFh
 14478                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:647Bh
 14479                                  
 14480                                  _$DIR_SEARCH_FIRST:
 14481 00001ED7 368916[A605]            	MOV	[SS:THISFCB],DX
 14482 00001EDC 368C1E[A805]            	MOV	[SS:THISFCB+2],DS
 14483 00001EE1 89D6                    	MOV	SI,DX
 14484 00001EE3 803CFF                  	CMP	BYTE [SI],0FFH
 14485 00001EE6 7503                    	JNZ	short NORMFCB4
 14486 00001EE8 83C607                  	ADD	SI,7			; Point to drive select byte
 14487                                  NORMFCB4:
 14488 00001EEB FF34                    	push	word [SI]		; Save original drive byte for later
 14489                                  
 14490 00001EED 16                      	push	ss
 14491 00001EEE 07                      	pop	es			; get es to address DOSGroup
 14492                                  
 14493 00001EEF BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 14494 00001EF2 E8544A                  	call	TransFCB		; convert the FCB, set SATTRIB EXTFCB
 14495 00001EF5 7304                    	JNC	short SearchIt		; no error, go and look
 14496 00001EF7 5B                      	pop	bx			; Clean stack
 14497                                  
 14498                                  ; Error code is in AX
 14499                                  
 14500                                  	; 09/11/2022
 14501                                  dcf_errj:
 14502 00001EF8 E955E7                  	jmp	FCB_RET_ERR		; error
 14503                                  
 14504                                  SearchIt:
 14505 00001EFB 16                      	push	ss
 14506 00001EFC 1F                      	pop	ds			; get ready for search
 14507                                  	;push	word [DMAADD]
 14508                                  	;push	word [DMAADD+2]
 14509                                  	; 24/01/2024
 14510 00001EFD C43E[2C03]              	les	di,[DMAADD]
 14511 00001F01 57                      	push	di
 14512 00001F02 06                      	push	es
 14513 00001F03 C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14514 00001F09 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14515                                  	; MSDOS 3.3
 14516                                  	;call	DOS_SEARCH_FIRST
 14517                                  	; MSDOS 6.0
 14518 00001F0D E86E0D                  	call	GET_FAST_SEARCH		; search
 14519 00001F10 8F06[2E03]              	pop	word [DMAADD+2]
 14520 00001F14 8F06[2C03]              	pop	word [DMAADD]
 14521 00001F18 735C                    	JNC	short SearchSet		; no error, transfer info
 14522 00001F1A 5B                      	pop	bx			; Clean stack
 14523                                  
 14524                                  ; Error code is in AX
 14525                                  
 14526                                  	; 09/11/2022
 14527                                  	;jmp	FCB_RET_ERR
 14528 00001F1B EBDB                    	jmp	short dcf_errj
 14529                                  
 14530                                  ;----------------------------------------------------------------------------
 14531                                  ;
 14532                                  ; Procedure Name : $DIR_SEARCH_NEXT
 14533                                  ;
 14534                                  ; Inputs:
 14535                                  ;	DS:DX points to unopenned FCB returned by $DIR_SEARCH_FIRST
 14536                                  ; Function:
 14537                                  ;	Directory is searched for the next matching entry and the directory
 14538                                  ;	entry is loaded at the disk transfer address
 14539                                  ; Returns:
 14540                                  ;	AL = -1 if no entries matched, otherwise 0
 14541                                  ;----------------------------------------------------------------------------
 14542                                  
 14543                                  	; 24/01/2024
 14544                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:5E5Fh
 14545                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:5E73h
 14546                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6517h
 14547                                  
 14548                                  _$DIR_SEARCH_NEXT:
 14549 00001F1D 368916[A605]            	MOV	[SS:THISFCB],DX
 14550 00001F22 368C1E[A805]            	MOV	[SS:THISFCB+2],DS
 14551 00001F27 36C606[6D05]00          	MOV	byte [SS:SATTRIB],0
 14552 00001F2D 36C606[6C05]00          	MOV	byte [SS:EXTFCB],0
 14553                                  
 14554 00001F33 16                      	push	ss
 14555 00001F34 07                      	pop	es
 14556                                  
 14557 00001F35 BF[BE04]                	MOV	DI,SEARCHBUF
 14558                                  
 14559 00001F38 89D6                    	MOV	SI,DX
 14560 00001F3A 803CFF                  	CMP	BYTE [SI],0FFh
 14561 00001F3D 750D                    	JNZ	short NORMFCB6
 14562 00001F3F 83C606                  	ADD	SI,6
 14563 00001F42 AC                      	LODSB
 14564                                  
 14565 00001F43 36A2[6D05]              	MOV	[SS:SATTRIB],AL
 14566 00001F47 36FE0E[6C05]            	DEC	byte [SS:EXTFCB]
 14567                                  NORMFCB6:
 14568 00001F4C AC                      	LODSB				; Get original user drive byte
 14569 00001F4D 50                      	push	ax			; Put it on stack
 14570 00001F4E 8A4414                  	MOV	AL,[SI+20]		; Get correct search contin drive byte
 14571 00001F51 AA                      	STOSB				; Put in correct place
 14572 00001F52 B90A00                  	MOV	CX,20/2
 14573 00001F55 F3A5                    	REP	MOVSW			; Transfer in rest of search contin info
 14574                                  
 14575 00001F57 16                      	push	ss
 14576 00001F58 1F                      	pop	ds
 14577                                  
 14578                                  	;push	word [DMAADD]
 14579                                  	;push	word [DMAADD+2]
 14580                                  	; 24/01/2024
 14581 00001F59 C43E[2C03]              	les	di,[DMAADD]
 14582 00001F5D 57                      	push	di
 14583 00001F5E 06                      	push	es
 14584 00001F5F C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14585 00001F65 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14586 00001F69 E80D0E                  	call	DOS_SEARCH_NEXT 	; Find it
 14587 00001F6C 8F06[2E03]              	pop	word [DMAADD+2]
 14588 00001F70 8F06[2C03]              	pop	word [DMAADD]
 14589 00001F74 7249                    	JC	short SearchNoMore
 14590                                  	; 24/01/2024
 14591                                  	;JMP	SearchSet		; Ok set return
 14592                                  
 14593                                  ;;;	; 24/01/2024
 14594                                  
 14595                                  ; The search was successful (or the search-next). We store the information
 14596                                  ; into the user's FCB for continuation.
 14597                                  
 14598                                  SearchSet:
 14599 00001F76 BE[BE04]                	MOV	SI,SEARCHBUF
 14600 00001F79 C43E[A605]              	LES	DI,[THISFCB]		; point to the FCB
 14601 00001F7D F606[6C05]FF            	TEST	byte [EXTFCB],0FFh
 14602 00001F82 7403                    	JZ	short NORMFCB1
 14603 00001F84 83C707                  	ADD	DI,7			; Point past the extension
 14604                                  NORMFCB1:
 14605 00001F87 5B                      	pop	bx			; Get original drive byte
 14606 00001F88 08DB                    	OR	BL,BL
 14607 00001F8A 7506                    	JNZ	short SearchDrv
 14608 00001F8C 8A1E[3603]              	MOV	BL,[CURDRV]
 14609 00001F90 FEC3                    	INC	BL
 14610                                  SearchDrv:
 14611 00001F92 AC                      	LODSB				; Get correct search contin drive byte
 14612 00001F93 86C3                    	XCHG	AL,BL			; Search byte to BL, user byte to AL
 14613 00001F95 47                      	INC	DI
 14614                                  	;STOSB				; Store the correct "user" drive byte
 14615                                  					;  at the start of the search info
 14616 00001F96 B90A00                  	MOV	CX,20/2
 14617 00001F99 F3A5                    	REP	MOVSW			; Rest of search cont info, SI -> entry
 14618 00001F9B 86C3                    	XCHG	AL,BL			; User drive byte back to BL, search
 14619                                  					;   byte to AL
 14620 00001F9D AA                      	STOSB				; Search contin drive byte at end of
 14621                                  					;   contin info
 14622 00001F9E C43E[2C03]              	LES	DI,[DMAADD]
 14623 00001FA2 F606[6C05]FF            	TEST	byte [EXTFCB],0FFh
 14624 00001FA7 740C                    	JZ	short NORMFCB2
 14625 00001FA9 B0FF                    	MOV	AL,0FFh
 14626 00001FAB AA                      	STOSB
 14627 00001FAC FEC0                    	INC	AL
 14628                                  	;MOV	CX,5
 14629                                  	; 17/12/2022
 14630                                  	;mov	cl,5
 14631                                  	;REP	STOSB
 14632                                  	; 03/07/2024
 14633 00001FAE AB                      	stosw
 14634 00001FAF AB                      	stosw
 14635 00001FB0 AA                      	stosb
 14636 00001FB1 A0[6D05]                	MOV	AL,[SATTRIB]
 14637 00001FB4 AA                      	STOSB
 14638                                  NORMFCB2:
 14639 00001FB5 88D8                    	MOV	AL,BL			; User Drive byte
 14640 00001FB7 AA                      	STOSB
 14641                                  	;MOV	CX,16			; 32 / 2 words of dir entry
 14642                                  	; 17/12/2022
 14643 00001FB8 B110                    	mov	cl,16
 14644 00001FBA F3A5                    	REP	MOVSW
 14645 00001FBC E98EE6                  	jmp	FCB_RET_OK
 14646                                  ;;;
 14647                                  
 14648                                  SearchNoMore:
 14649 00001FBF C43E[A605]              	LES	DI,[THISFCB]
 14650 00001FC3 F606[6C05]FF            	TEST	byte [EXTFCB],0FFh
 14651 00001FC8 7403                    	JZ	short NORMFCB8
 14652 00001FCA 83C707                  	ADD	DI,7			; Point past the extension
 14653                                  NORMFCB8:
 14654 00001FCD 5B                      	pop	bx			; Get original drive byte
 14655 00001FCE 26881D                  	MOV	[ES:DI],BL		; Store the correct "user" drive byte
 14656                                  					;  at the right spot
 14657                                  ; error code is in AX
 14658                                  
 14659 00001FD1 E97CE6                  	jmp	FCB_RET_ERR
 14660                                  
 14661                                  ; 17/05/2019 - Retro DOS v4.0
 14662                                  
 14663                                  ; DOSCODE:5EE6h (MSDOS 6.21, MSDOS.SYS)
 14664                                  
 14665                                  ;---------------------------------------------------------------------------
 14666                                  ;
 14667                                  ;   Procedure Name : $FIND_FIRST
 14668                                  ; 
 14669                                  ;   Assembler usage:
 14670                                  ;	    MOV AH, FindFirst
 14671                                  ;	    LDS DX, name
 14672                                  ;	    MOV CX, attr
 14673                                  ;	    INT 21h
 14674                                  ;	; DMA address has datablock
 14675                                  ;
 14676                                  ;   Error Returns:
 14677                                  ;	    AX = error_path_not_found
 14678                                  ;	       = error_no_more_files
 14679                                  ;---------------------------------------------------------------------------
 14680                                  
 14681                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14682                                  	; DOSCODE:5ED2h (MSDOS 5.0, MSDOS.SYS)
 14683                                  
 14684                                  	; 24/01/2024
 14685                                  	; DOSCODE:5EE6h (MSDOS 6.22, MSDOS.SYS)
 14686                                  
 14687                                  _$FIND_FIRST:
 14688 00001FD4 89D6                    	MOV	SI,DX			; get name in appropriate place
 14689 00001FD6 36880E[6D05]            	MOV	[SS:SATTRIB],CL		; Search attribute to correct loc
 14690                                  
 14691 00001FDB BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 14692                                  
 14693 00001FDE E8CE49                  	call	TransPathSet		; convert the path
 14694 00001FE1 7305                    	JNC	short Find_it 		; no error, go and look
 14695                                  FindError:
 14696                                  	;mov	al,3
 14697 00001FE3 B003                    	mov	al,error_path_not_found	; error and map into one.
 14698                                  	; 09/11/2022
 14699                                  FF_errj:
 14700 00001FE5 E952E6                  	jmp	SYS_RET_ERR
 14701                                  Find_it:
 14702 00001FE8 16                      	push	ss
 14703 00001FE9 1F                      	pop	ds
 14704                                  
 14705                                  	;push	word [DMAADD]
 14706                                  	;push	word [DMAADD+2]
 14707                                  	; 24/01/2024 (PCDOS 7.1 IBMDOS.COM)
 14708 00001FEA C43E[2C03]              	les	di,[DMAADD]
 14709 00001FEE 57                      	push	di
 14710 00001FEF 06                      	push	es
 14711 00001FF0 C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14712 00001FF6 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14713                                  	; MSDOS 3.3
 14714                                  	;call	DOS_SEARCH_FIRST
 14715                                  	; MSDOS 6.0
 14716 00001FFA E8810C                  	call	GET_FAST_SEARCH 	; search
 14717 00001FFD 8F06[2E03]              	pop	word [DMAADD+2]
 14718 00002001 8F06[2C03]              	pop	word [DMAADD]
 14719                                  	
 14720                                  	; 16/12/2022
 14721                                  	;JNC	short FindSet 		; no error, transfer info
 14722 00002005 72DE                    	jc	short FF_errj	; jmp SYS_RET_ERR
 14723                                  	;
 14724                                  	;jmp	SYS_RET_ERR
 14725                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14726                                  ;FFF_errj:
 14727                                  	;jmp	short FF_errj	; jmp SYS_RET_ERR
 14728                                  
 14729                                  FindSet:
 14730 00002007 BE[BE04]                	MOV	SI,SEARCHBUF
 14731 0000200A C43E[2C03]              	LES	DI,[DMAADD]
 14732 0000200E B91500                  	MOV	CX,21
 14733 00002011 F3A4                    	REP	MOVSB
 14734 00002013 56                      	PUSH	SI			; Save pointer to start of entry
 14735                                  	;mov	al,[si+0Bh]
 14736 00002014 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 14737 00002017 AA                      	STOSB
 14738                                  	;add	si,16h ; 22
 14739 00002018 83C616                  	ADD	SI,dir_entry.dir_time
 14740 0000201B A5                      	MOVSW				; dir_time
 14741 0000201C A5                      	MOVSW				; dir_date
 14742 0000201D 46                      	INC	SI
 14743 0000201E 46                      	INC	SI			; Skip dir_first
 14744 0000201F A5                      	MOVSW				; dir_size (2 words)
 14745 00002020 A5                      	MOVSW
 14746 00002021 5E                      	POP	SI			; Point back to dir_name
 14747 00002022 E83300                   	CALL	PackName
 14748 00002025 E909E6                  	jmp	SYS_RET_OK		; bye with no errors
 14749                                  
 14750                                  ;---------------------------------------------------------------------------
 14751                                  ;
 14752                                  ;   Procedure Name : $FIND_NEXT
 14753                                  ;
 14754                                  ;   Assembler usage:
 14755                                  ;	; dma points at area returned by find_first
 14756                                  ;	    MOV AH, findnext
 14757                                  ;	    INT 21h
 14758                                  ;	; next entry is at dma
 14759                                  ;
 14760                                  ;   Error Returns:
 14761                                  ;	    AX = error_no_more_files
 14762                                  ;---------------------------------------------------------------------------
 14763                                  
 14764                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14765                                  
 14766                                  	; 24/01/2024
 14767                                  	; DOSCODE:5F3Eh (MSDOS 6.22, MSDOS.SYS)
 14768                                  
 14769                                  _$FIND_NEXT:
 14770 00002028 16                      	push	ss
 14771 00002029 07                      	pop	es
 14772                                  
 14773 0000202A BF[BE04]                	MOV	DI,SEARCHBUF
 14774                                  
 14775 0000202D 36C536[2C03]            	LDS	SI,[SS:DMAADD]
 14776                                  
 14777 00002032 B91500                  	MOV	CX,21
 14778 00002035 F3A4                    	REP	MOVSB			; Put the search continuation info
 14779                                  					;  in the right place
 14780 00002037 16                      	push	ss
 14781 00002038 1F                      	pop	ds			; get ready for search
 14782                                  	
 14783                                  	;push	word [DMAADD]
 14784                                  	;push	word [DMAADD+2]
 14785                                  	; 24/01/2024
 14786 00002039 C43E[2C03]              	les	di,[DMAADD]
 14787 0000203D 57                      	push	di
 14788 0000203E 06                      	push	es
 14789 0000203F C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14790 00002045 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14791 00002049 E82D0D                  	call	DOS_SEARCH_NEXT 	; Find it
 14792 0000204C 8F06[2E03]              	pop	word [DMAADD+2]
 14793 00002050 8F06[2C03]              	pop	word [DMAADD]
 14794 00002054 73B1                    	JNC	short FindSet 		; No error, set info
 14795                                  	;jmp	SYS_RET_ERR
 14796                                  	; 16/12/2022
 14797 00002056 EB8D                    	jmp	short FF_errj	; jmp SYS_RET_ERR
 14798                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14799                                  	;jmp	short FFF_errj	; jmp SYS_RET_ERR
 14800                                  
 14801                                  ;---------------------------------------------------------------------------
 14802                                  ;**	PackName - Convert file names from FCB to ASCIZ format.
 14803                                  ;
 14804                                  ;	PackName transfers a file name from DS:SI to ES:DI and converts it to
 14805                                  ;	the ASCIZ format.
 14806                                  ;
 14807                                  ;	ENTRY	(DS:SI) = 11 character FCB or dir entry name
 14808                                  ;		(ES:DI) = destination area (13 bytes)
 14809                                  ;	EXIT	(ds:SI) and (es:DI) advanced
 14810                                  ;	USES	al, CX, SI, DI, Flags  (BUGBUG - not verified - jgl)
 14811                                  ;---------------------------------------------------------------------------
 14812                                  
 14813                                  	; 25/01/2024 - Retro DOS v4.2
 14814                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:5F70h
 14815                                  
 14816                                  PackName:
 14817                                  ;	Move over 8 characters to cover the name component, then trim it's
 14818                                  ;	trailing blanks.
 14819                                  
 14820                                  	;MOV	CX,8			; Pack the name
 14821                                  	;REP	MOVSB			; Move all of it
 14822                                  	; 25/01/2024
 14823 00002058 B90400                  	mov	cx,4
 14824 0000205B F3A5                    	rep	movsw
 14825                                  main_kill_tail:
 14826 0000205D 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 14827 00002062 7507                    	JNZ	short find_check_dot
 14828 00002064 4F                      	DEC	DI			; Back up over trailing space
 14829 00002065 41                      	INC	CX
 14830 00002066 83F908                  	CMP	CX,8
 14831 00002069 72F2                    	JB	short main_kill_tail
 14832                                  find_check_dot:
 14833                                  	;CMP	WORD [SI],(" " << 8) | " "
 14834 0000206B 813C2020                	cmp     word [si],2020h 
 14835 0000206F 7506                    	JNZ	short got_ext 		; Some chars in extension
 14836 00002071 807C0220                	CMP	BYTE [SI+2]," "
 14837 00002075 740F                    	JZ	short find_done		; No extension
 14838                                  got_ext:
 14839 00002077 B02E                    	MOV	AL,"."	; 2Eh
 14840 00002079 AA                      	STOSB
 14841                                  	;MOV	CX,3
 14842                                  	;; 18/12/2022
 14843                                  	;;mov	cl,3
 14844                                  	;;REP	MOVSB
 14845                                  	;movsb
 14846                                  	;movsb
 14847                                  	;movsb
 14848                                  	; 25/01/2024
 14849 0000207A A5                      	movsw
 14850 0000207B A4                      	movsb
 14851                                  ext_kill_tail:
 14852 0000207C 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 14853 00002081 7503                    	JNZ	short find_done
 14854 00002083 4F                      	DEC	DI			; Back up over trailing space
 14855 00002084 EBF6                    	JMP	short ext_kill_tail
 14856                                  find_done:
 14857 00002086 31C0                    	XOR	AX,AX
 14858 00002088 AA                      	STOSB				; NUL terminate
 14859 00002089 C3                      	retn
 14860                                  
 14861                                  ;---------------------------------------------------------------------------
 14862                                  
 14863                                  ; 24/01/2024
 14864                                  %if 0
 14865                                  	; 17/05/2019 - Retro DOS v4.0
 14866                                  GET_FAST_SEARCH:
 14867                                  	; 22/07/2018
 14868                                  	; MSDOS 6.0
 14869                                  	; 17/12/2022
 14870                                  	OR	byte [ss:DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)  ; 04h
 14871                                  	;OR	word [ss:DOS34_FLAG],SEARCH_FASTOPEN  ; 400h
 14872                                  					;FO.trigger fastopen ;AN000;
 14873                                  	;call	DOS_SEARCH_FIRST
 14874                                  	;retn
 14875                                  	; 17/12/2022
 14876                                  	jmp	DOS_SEARCH_FIRST
 14877                                  %endif
 14878                                  
 14879                                  ;============================================================================
 14880                                  ; PATH.ASM, MSDOS 6.0, 1991
 14881                                  ;============================================================================
 14882                                  ; 06/08/2018 - Retro DOS v3.0
 14883                                  ; 17/05/2019 - Retro DOS v4.0
 14884                                  
 14885                                  ; DOSCODE:5FB0h (MSDOS 6.21, MSDOS.SYS)
 14886                                  
 14887                                  ;**	Directory related system calls. These will be passed direct text of the
 14888                                  ;	pathname from the user. They will need to be passed through the macro
 14889                                  ;	expander prior to being sent through the low-level stuff. I/O specs are
 14890                                  ;	defined in DISPATCH. The system calls are:
 14891                                  ;
 14892                                  ;	$CURRENT_DIR  Written
 14893                                  ;	$RMDIR	  Written
 14894                                  ;	$CHDIR	  Written
 14895                                  ;	$MKDIR	  Written
 14896                                  ;
 14897                                  ;
 14898                                  ;	Modification history:
 14899                                  ;
 14900                                  ;	    Created: ARR 4 April 1983
 14901                                  ;		 MZ 10 May 1983     CurrentDir implemented
 14902                                  ;		 MZ 11 May 1983     RmDir, ChDir, MkDir implemented
 14903                                  ;		 EE 19 Oct 1983     RmDir no longer allows you to delete a
 14904                                  ;				    current directory.
 14905                                  ;		 MZ 19 Jan 1983     Brain damaged applications rely on success
 14906                                  
 14907                                  ;	I_Need	ThisCDS,DWORD		; pointer to Current CDS
 14908                                  ;	I_Need	WFP_Start,WORD		; pointer to beginning of directory text
 14909                                  ;	I_Need	Curr_Dir_End,WORD	; offset to end of directory part
 14910                                  ;	I_Need	OpenBuf,128		; temp spot for translated name
 14911                                  ;	I_need	fSplice,BYTE		; TRUE => do splice
 14912                                  ;	I_Need	NoSetDir,BYTE		; TRUE => no exact match on splice
 14913                                  ;	I_Need	cMeta,BYTE
 14914                                  ;	I_Need	DrvErr,BYTE					;AN000;
 14915                                  
 14916                                  ;BREAK <$CURRENT_DIR - dump the current directory into user space>
 14917                                  ;----------------------------------------------------------------------------
 14918                                  ;
 14919                                  ;   Procedure Name : $CURRENT_DIR
 14920                                  ;
 14921                                  ;   Assembler usage:
 14922                                  ;		LDS	SI,area
 14923                                  ;		MOV	DL,drive
 14924                                  ;		INT	21h
 14925                                  ;	    ; DS:SI is a pointer to 64 byte area that contains drive
 14926                                  ;	    ; current directory.
 14927                                  ;   Error returns:
 14928                                  ;	    AX = error_invalid_drive
 14929                                  ;
 14930                                  ;----------------------------------------------------------------------------
 14931                                  
 14932                                  	; 06/08/2018 - Retro DOS v3.0
 14933                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 2D4Eh
 14934                                  
 14935                                  	; 25/01/2024 - Retro DOS v4.2
 14936                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:5F9Ch
 14937                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:5FB0h
 14938                                  	; Windows ME IO.SYS - BIOSCODE:6393h
 14939                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6664h
 14940                                  
 14941                                  _$CURRENT_DIR:
 14942 0000208A E855F2                  	call	ECritDisk
 14943 0000208D 88D0                    	MOV	AL,DL			; get drive number (0=def, 1=A)
 14944 0000208F E82648                  	call	GetVisDrv		; grab it
 14945 00002092 7310                    	JNC	short CurrentValidate 	; no error -> go and validate dir
 14946                                  CurdirErr:
 14947 00002094 E866F2                  	call	LCritDisk
 14948                                  
 14949                                  	; MSDOS 3.3
 14950                                  	;mov	al,0Fh
 14951                                  	
 14952                                  	; MSDOS 6.0
 14953 00002097 1E                      	push	ds
 14954 00002098 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 14955 0000209D A0[1006]                	mov	al,[DrvErr]		;IFS.			;AN000;
 14956 000020A0 1F                      	pop	ds
 14957                                  
 14958                                  curdir_errj:
 14959 000020A1 E996E5                  	jmp	SYS_RET_ERR		;IFS. make noise	;AN000;
 14960                                  
 14961                                  CurrentValidate:
 14962 000020A4 1E                      	push	ds			; save destination
 14963 000020A5 56                      	push	si
 14964                                  	
 14965                                  	;LDS	SI,[CS:THISCDS] ; MSDOS 3.3
 14966                                  	
 14967                                  	; MSDOS 6.0
 14968 000020A6 2E8E1E[0700]            	mov     ds,[cs:DosDSeg]
 14969                                  	; 25/01/2024 (PCDOS 7.1 IBMDOS.COM)
 14970 000020AB C606[4C03]00            	mov	byte [NoSetDir],0 ; *
 14971                                  	
 14972                                  	; 25/01/2024
 14973                                  	;lds     si,[THISCDS]
 14974                                  
 14975                                  ; 16/12/2022
 14976                                  %if 0
 14977                                  	; 09/11/2022 (following test instruction is nonsense!)
 14978                                  	; (I am leaving it here for MSDOS 5.0 MSDOS.SYS compatibility)
 14979                                  
 14980                                  	;test	word [si+43h],8000h
 14981                                  	TEST	word [SI+curdir.flags],curdir_isnet
 14982                                  	;jnz	short $+2  ; 09/11/2022	
 14983                                  	jnz	short DoCheck
 14984                                  %endif
 14985                                  
 14986                                  ; Random optimization nuked due to some utilities using GetCurrentDir to do
 14987                                  ; media check.
 14988                                  ;	CMP	word [SI+curdir.ID],0
 14989                                  ;	JZ	short GetDst
 14990                                  DoCheck:
 14991                                  	;MOV	byte [cs:NoSetDir],0	; interested only in contents
 14992                                  
 14993                                  	; 25/01/2024
 14994                                  	; MSDOS 6.0
 14995                                  	;push	ds
 14996                                  	;mov	ds,[cs:DosDSeg]
 14997                                  	;mov	byte [NoSetDir],0 ; *
 14998                                  	;pop	ds
 14999                                  
 15000 000020B0 BF[BE03]                	MOV	DI,OPENBUF
 15001 000020B3 E85320                  	call	ValidateCDS		; output is ES:DI -> CDS
 15002                                  
 15003 000020B6 06                      	push	es	 		; swap source and destination
 15004 000020B7 57                      	push	di
 15005 000020B8 5E                      	pop	si
 15006 000020B9 1F                      	pop	ds
 15007                                  GetDst:
 15008 000020BA 5F                      	pop	di
 15009 000020BB 07                      	pop	es			; get real destination
 15010 000020BC 72D6                    	JC	short CurdirErr
 15011                                  	;ADD	SI,curdir.text ; add si,0 ; 09/08/2018
 15012                                  	;
 15013                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15014                                  	; DOSCODE:5FE2h (MSDOS 5.0, MSDOS.SYS)
 15015                                  	; 16/12/2022
 15016                                  	;add	si,0  ; add si,curdir.text
 15017                                  	;
 15018                                  	;add	si,[si+4Fh] ; 17/05/2019
 15019 000020BE 03744F                  	ADD	SI,[SI+curdir.end]
 15020 000020C1 803C5C                  	CMP	BYTE [SI],'\'	; 5Ch	; root or subdirs present?
 15021 000020C4 7501                    	JNZ	short CurrentCopy
 15022 000020C6 46                      	INC	SI
 15023                                  CurrentCopy:
 15024                                  ;	call	FStrCpy
 15025                                  ;; 10/29/86 E5 char
 15026 000020C7 50                      	PUSH	AX
 15027 000020C8 AC                      	LODSB				; get char
 15028 000020C9 08C0                    	OR	AL,AL
 15029 000020CB 7413                    	JZ	short FOK
 15030 000020CD 3C05                    	CMP	AL,05H
 15031 000020CF 740D                    	JZ	short FCHANGE
 15032 000020D1 EB01                    	JMP	short FFF
 15033                                  FCPYNEXT:
 15034 000020D3 AC                      	LODSB				; get char
 15035                                  FFF:
 15036 000020D4 3C5C                    	CMP	AL,'\'			; beginning of directory
 15037 000020D6 7508                    	JNZ	short FOK		; no
 15038 000020D8 AA                      	STOSB				; put into user's buffer
 15039 000020D9 AC                      	LODSB				; 1st char of dir is 05?
 15040 000020DA 3C05                    	CMP	AL,05H
 15041 000020DC 7502                    	JNZ	short FOK		; no
 15042                                  FCHANGE:
 15043 000020DE B0E5                    	MOV	AL,0E5H			; make it E5
 15044                                  FOK:
 15045 000020E0 AA                      	STOSB				; put into user's buffer
 15046 000020E1 08C0                    	OR	AL,AL			; final char
 15047 000020E3 75EE                    	JNZ	short FCPYNEXT		; no
 15048 000020E5 58                      	POP	AX
 15049                                  
 15050                                  ;; 10/29/86 E5 char
 15051 000020E6 30C0                    	xor	AL,AL			; MZ 19 Jan 84
 15052 000020E8 E812F2                  	call	LCritDisk
 15053 000020EB E943E5                  	jmp	SYS_RET_OK		; no more, bye!
 15054                                  
 15055                                  ; 17/05/2019 - Retro DOS v4.0
 15056                                  
 15057                                  ; DOSCODE:6029h (MSDOS 6.21, MSDOS.SYS)
 15058                                  
 15059                                  ;BREAK <$RmDir -- Remove a directory>
 15060                                  ;----------------------------------------------------------------------------
 15061                                  ;
 15062                                  ; Procedure Name : $RmDir
 15063                                  ;
 15064                                  ; Inputs:
 15065                                  ;	DS:DX Points to asciz name
 15066                                  ; Function:
 15067                                  ;	Delete directory if empty
 15068                                  ; Returns:
 15069                                  ;	STD XENIX Return
 15070                                  ;	AX = error_path_not_found If path bad
 15071                                  ;	AX = error_access_denied If
 15072                                  ;		Directory not empty
 15073                                  ;		Path not directory
 15074                                  ;		Root directory specified
 15075                                  ;		Directory malformed (. and .. not first two entries)
 15076                                  ;		User tries to delete a current directory
 15077                                  ;	AX = error_current_directory
 15078                                  ;
 15079                                  ;----------------------------------------------------------------------------
 15080                                  
 15081                                  	; 10/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15082                                  	; DOSCODE:6015h (MSDOS 5.0, MSDOS.SYS)
 15083                                  
 15084                                  _$RMDIR:
 15085 000020EE 52                      	push	dx			; Save ptr to name
 15086 000020EF 1E                      	push	ds
 15087 000020F0 89D6                    	mov	si,dx			; Load ptr into si
 15088 000020F2 BF[BE03]                	mov	di,OPENBUF		; di = ptr to buf for trans name
 15089 000020F5 57                      	push	di
 15090 000020F6 E8BE48                  	call	TransPathNoSet		; Translate the name
 15091 000020F9 5F                      	pop	di			; di = ptr to buf for trans name
 15092 000020FA 7306                    	jnc	short rmlset		; If transpath succeeded, continue
 15093 000020FC 1F                      	pop	ds
 15094 000020FD 5A                      	pop	dx			; Restore the name
 15095                                  	;mov	al,3
 15096 000020FE B003                    	mov	al,error_path_not_found ; Otherwise, return an error
 15097                                  	; 16/12/2022
 15098                                  rmdir_errj: ; 10/08/2018
 15099                                  chdir_errj:
 15100 00002100 EB9F                    	jmp	short curdir_errj
 15101                                  	;jmp	SYS_RET_ERR
 15102                                  rmlset:
 15103 00002102 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1	;   if (cMeta >= 0)
 15104 00002108 7512                    	Jnz	short rmerr		;	return (-1);
 15105 0000210A 16                      	push	ss
 15106 0000210B 07                      	pop	es
 15107 0000210C 30C0                    	xor	al,al			; al = 0 , ie drive a:
 15108                                  rmloop: 
 15109 0000210E E81848                  	call	GetCDSFromDrv		; Get curdir for drive in al
 15110 00002111 720F                    	jc	short rmcont		; If error, exit loop & cont normally
 15111 00002113 E879F0                  	call	StrCmp			; Are the 2 paths the same?
 15112 00002116 7404                    	jz	short rmerr		; Yes, report error.
 15113 00002118 FEC0                    	inc	al			; No, inc al to next drive number
 15114 0000211A EBF2                    	jmp	short rmloop		; Go check next drive.
 15115                                  rmerr:
 15116 0000211C 1F                      	pop	ds
 15117 0000211D 5A                      	pop	dx			; Restore the name
 15118                                  	;mov	al,10h
 15119 0000211E B010                    	mov	al,error_current_directory ; error
 15120                                  	; 16/12/2022
 15121                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15122                                  ;chdir_errj:
 15123 00002120 EBDE                    	jmp	short rmdir_errj
 15124                                  rmcont:
 15125 00002122 1F                      	pop	ds
 15126 00002123 5A                      	pop	dx			; Restore the name
 15127 00002124 BE[1A31]                	MOV	SI,DOS_RMDIR
 15128 00002127 EB7C                    	JMP	DoDirCall
 15129                                  
 15130                                  ; 17/05/2019 - Retro DOS v4.0
 15131                                  
 15132                                  ; DOSCODE:6065h (MSDOS 6.21, MSDOS.SYS)
 15133                                  
 15134                                  ;BREAK <$ChDir -- Change current directory on a drive>
 15135                                  ;----------------------------------------------------------------------------
 15136                                  ;
 15137                                  ; $ChDir - Top-level change directory system call.  This call is responsible
 15138                                  ; for setting up the CDS for the specified drive appropriately.  There are
 15139                                  ; several cases to consider:
 15140                                  ;
 15141                                  ;   o	Local, simple CDS.  In this case, we take the input path and convert
 15142                                  ;	it into a WFP.	We verify the existance of this directory and then
 15143                                  ;	copy the WFP into the CDS and set up the ID field to point to the
 15144                                  ;	directory cluster.
 15145                                  ;   o	Net CDS.  We form the path from the root (including network prefix)
 15146                                  ;	and verify its existance (via DOS_Chdir).  If successful, we copy the
 15147                                  ;	WFP back into the CDS.
 15148                                  ;   o	SUBST'ed CDS.  This is no different than the local, simple CDS.
 15149                                  ;   o	JOIN'ed CDS.  This is trouble as there are two CDS's at work.  If we
 15150                                  ;	call TransPath, we will get the PHYSICAL CDS that the path refers to
 15151                                  ;	and the PHYSICAL WFP that the input path refers to.  This is perfectly
 15152                                  ;	good for the validation but not for currency.  We call TransPathNoSet
 15153                                  ;	to process the path but to return the logical CDS and the logical
 15154                                  ;	path.  We then copy the logical path into the logical CDS.
 15155                                  ;
 15156                                  ; Inputs:
 15157                                  ;	DS:DX Points to asciz name
 15158                                  ; Returns:
 15159                                  ;	STD XENIX Return
 15160                                  ;	AX = chdir_path_not_found if error
 15161                                  ;
 15162                                  ;----------------------------------------------------------------------------
 15163                                  
 15164                                  _$CHDIR:
 15165 00002129 BF[BE03]                	MOV	DI,OPENBUF		; spot for translated name
 15166 0000212C 89D6                    	MOV	SI,DX			; get source
 15167 0000212E E87A48                  	call	TransPath		; go munge the path and get real CDS
 15168 00002131 7304                    	JNC	short ChDirCrack	; no errors, try path
 15169                                  ChDirErrP:
 15170                                  	;mov	al,3
 15171 00002133 B003                    	MOV	AL,error_path_not_found
 15172                                  ChDirErr:
 15173                                  	;jmp	SYS_RET_ERR 	; oops!
 15174                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15175 00002135 EBC9                    	jmp	short chdir_errj
 15176                                  
 15177                                  ChDirCrack:
 15178 00002137 803E[7A05]FF            	CMP	byte [CMETA],-1		; No meta chars allowed.
 15179 0000213C 75F5                    	JNZ	short ChDirErrP
 15180                                  
 15181                                  ; We cannot do a ChDir (yet) on a raw CDS. This is treated as a path not
 15182                                  ; found.
 15183                                  
 15184 0000213E C43E[A205]              	LES	DI,[THISCDS]
 15185 00002142 83FFFF                  	CMP	DI,-1			;   if (ThisCDS == NULL)
 15186 00002145 74EC                    	JZ	short ChDirErrP		;	error ();
 15187                                  
 15188                                  ; Find out if the directory exists.
 15189                                  
 15190 00002147 E88E0F                  	call	DOS_CHDIR
 15191                                  	;Jc	short ChDirErr
 15192                                  	; 16/12/2022
 15193 0000214A 72B4                    	jc	short chdir_errj
 15194                                  ;
 15195                                  ; Get back CDS to see if a join as seen. Set the currency pointer (only if
 15196                                  ; not network). If one was seen, all we need to do is copy in the text
 15197                                  ;
 15198 0000214C C43E[A205]              	LES	DI,[THISCDS]
 15199                                  	;test	word [es:di+43h],2000h
 15200                                  	; 17/12/2022
 15201 00002150 26F6454420              	test	byte [ES:DI+curdir.flags+1],curdir_splice>>8
 15202                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice
 15203 00002155 7425                    	JZ	short GotCDS
 15204                                  
 15205                                  ; The CDS was joined. Let's go back and grab the logical CDS.
 15206                                  
 15207 00002157 06                      	push	es	
 15208 00002158 57                      	push	di
 15209 00002159 51                      	push	cx			; save CDS and cluster...
 15210 0000215A E824E3                  	call	Get_User_Stack		; get original text
 15211                                  	
 15212                                  	;mov	di,[si+6]
 15213 0000215D 8B7C06                  	MOV	DI,[SI+user_env.user_DX]
 15214                                  	;mov	ds,[si+0Eh]
 15215 00002160 8E5C0E                  	MOV	DS,[SI+user_env.user_DS]
 15216                                  	
 15217 00002163 BE[BE03]                	MOV	SI,OPENBUF		; spot for translated name
 15218 00002166 87F7                    	XCHG	SI,DI
 15219 00002168 30C0                    	XOR	AL,AL			; do no splicing
 15220 0000216A 57                      	push	di
 15221 0000216B E84948                  	call	TransPathNoSet		; Munge path
 15222 0000216E 5E                      	pop	si
 15223                                  
 15224                                  ; There should NEVER be an error here.
 15225                                  
 15226                                  ;IF FALSE
 15227                                  ;	JNC SKipErr
 15228                                  ;	fmt <>,<>,<"$p: Internal CHDIR error\n">
 15229                                  ;SkipErr:
 15230                                  ;ENDIF
 15231 0000216F C43E[A205]              	LES	DI,[THISCDS]		; get new CDS
 15232                                  	;mov	word [es:di+49h],-1
 15233 00002173 26C74549FFFF            	MOV	word [ES:DI+curdir.ID],-1
 15234                                  					; no valid cluster here...
 15235 00002179 59                      	pop	cx
 15236 0000217A 5F                      	pop	di
 15237 0000217B 07                      	pop	es
 15238                                  
 15239                                  ; ES:DI point to the physical CDS, CX is the ID (local only)
 15240                                  
 15241                                  GotCDS:
 15242                                  
 15243                                  ; wfp_start points to the text. See if it is long enough
 15244                                  
 15245                                  	; MSDOS 3.3
 15246                                  	;push	ss
 15247                                  	;pop	ds
 15248                                  	;mov	si,[WFP_START]
 15249                                  	;push	cx
 15250                                  	;call	DStrLen
 15251                                  	;cmp	cx,67 ; cmp cx,DIRSTRLEN
 15252                                  	;pop	cx
 15253                                  	;ja	short ChDirErrP
 15254                                  
 15255                                  	; MSDOS 6.0
 15256 0000217C E85000                  	CALL	Check_PathLen		;PTM.		;AN000;
 15257 0000217F 77B2                    	JA	short ChDirErrP
 15258                                  	; MSDOS 3.3 & MSDOS 6.0
 15259                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet ; 8000h
 15260                                  	; 17/12/2022
 15261 00002181 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8
 15262 00002186 7512                    	JNZ	short SkipRecency
 15263                                  	; MSDOS 6.0
 15264                                  	;test	word [es:di+43h],2000h
 15265                                  	; 17/12/2022
 15266 00002188 26F6454420              	test	byte [ES:DI+curdir.flags+1],curdir_splice>>8
 15267                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice 
 15268                                  					;PTM. for Join and Subst ;AN000;
 15269 0000218D 7403                    	JZ	short setdirclus	;PTM.		;AN000;
 15270 0000218F B9FFFF                  	MOV	CX,-1			;PTM.		;AN000;
 15271                                  setdirclus:
 15272                                  	;mov	[es:di+49h],cx
 15273 00002192 26894D49                	MOV	[ES:DI+curdir.ID],CX
 15274 00002196 C43E[A205]              	LES	DI,[THISCDS]		; get logical CDS
 15275                                  SkipRecency:
 15276 0000219A E823F0                  	call	FStrCpy
 15277 0000219D 30C0                    	XOR	AL,AL
 15278                                  mkdir_ok:
 15279 0000219F E98FE4                  	jmp	SYS_RET_OK
 15280                                  
 15281                                  ; 17/05/2019 - Retro DOS v4.0
 15282                                  
 15283                                  ; DOSCODE:60E1h (MSDOS 6.21, MSDOS.SYS)
 15284                                  
 15285                                  ;BREAK <$MkDir - Make a directory entry>
 15286                                  ;---------------------------------------------------------------------------
 15287                                  ;
 15288                                  ; Procedure Name : $MkDir
 15289                                  ; Inputs:
 15290                                  ;	DS:DX Points to asciz name
 15291                                  ; Function:
 15292                                  ;	Make a new directory
 15293                                  ; Returns:
 15294                                  ;	STD XENIX Return
 15295                                  ;	AX = mkdir_path_not_found if path bad
 15296                                  ;	AX = mkdir_access_denied  If
 15297                                  ;		Directory cannot be created
 15298                                  ;		Node already exists
 15299                                  ;		Device name given
 15300                                  ;		Disk or directory(root) full
 15301                                  ;---------------------------------------------------------------------------
 15302                                  
 15303                                  	; 10/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15304                                  
 15305                                  _$MKDIR:
 15306 000021A2 BE[F72F]                	MOV	SI,DOS_MKDIR
 15307                                  DoDirCall:
 15308 000021A5 BF[BE03]                	MOV	DI,OPENBUF		; spot for translated name
 15309                                  
 15310 000021A8 56                      	push	si
 15311 000021A9 89D6                    	MOV	SI,DX			; get source
 15312 000021AB E8FD47                  	call	TransPath		; go munge the path
 15313 000021AE 5E                      	pop	si
 15314 000021AF 7305                    	JNC	short MkDirCrack	; no errors, try path
 15315                                  MkErrP:
 15316 000021B1 B003                    	MOV	AL,error_path_not_found	; oops!
 15317                                  MkErr:
 15318 000021B3 E984E4                  	jmp	SYS_RET_ERR
 15319                                  MkDirCrack:
 15320 000021B6 36803E[7A05]FF          	CMP	byte [SS:CMETA],-1
 15321 000021BC 75F3                    	JNZ	short MkErrP
 15322                                  
 15323                                  	; MSDOS 3.3
 15324                                  	;push	ss
 15325                                  	;pop	ds
 15326                                  	;call	si
 15327                                  	;jb	short MkErr
 15328                                  	;;jmp	short mkdir_ok
 15329                                  	;jmp	SYS_RET_OK
 15330                                  
 15331                                  	; MSDOS 6.0
 15332 000021BE 56                      	PUSH	SI			;PTM.			;AN000;
 15333 000021BF E80D00                  	CALL	Check_PathLen		;PTM. check path len > 67 ? ;AN000;
 15334 000021C2 5E                      	POP	SI			;PTM.			;AN000;
 15335 000021C3 7604                    	JBE	short pathok		;PTM.			;AN000;
 15336                                  	;mov	al,5
 15337 000021C5 B005                    	MOV	AL,error_access_denied	;PTM. ops!
 15338                                  	;jmp	SYS_RET_ERR		;PTM.
 15339 000021C7 EBEA                    	jmp	short MkErr
 15340                                  pathok:
 15341 000021C9 FFD6                    	CALL	SI			; go get file
 15342 000021CB 72E6                    	JC	short MkErr		; no errors
 15343                                  	; 16/12/2022
 15344                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15345 000021CD EBD0                    	jmp	short mkdir_ok
 15346                                  	;jmp	SYS_RET_OK
 15347                                  
 15348                                  ;----------------------------------------------------------------------------
 15349                                  ;
 15350                                  ; Procedure Name : Check_PathLen
 15351                                  ;
 15352                                  ; Inputs:
 15353                                  ;	nothing
 15354                                  ; Function:
 15355                                  ;	check if final path length greater than 67
 15356                                  ; Returns:
 15357                                  ;	Above flag set if > 67
 15358                                  ;
 15359                                  ;---------------------------------------------------------------------------
 15360                                  
 15361                                  Check_PathLen:
 15362                                  	; 09/09/2018
 15363                                  	;mov	SI,[WFP_START]
 15364 000021CF 368B36[B205]            	MOV	SI,[SS:WFP_START] ; MSDOS 6.0
 15365                                  Check_PathLen2:
 15366 000021D4 16                      	push	ss
 15367 000021D5 1F                      	pop	ds
 15368                                  	;mov	SI,[WFP_START]	  ; MSDOS 3.3
 15369 000021D6 51                      	push	CX	
 15370 000021D7 E8FDEF                  	CALL	DStrLen
 15371 000021DA 83F943                  	CMP	CX,DIRSTRLEN ; 67
 15372 000021DD 59                      	POP	CX
 15373 000021DE C3                      	retn
 15374                                  
 15375                                  ;============================================================================
 15376                                  ; IOCTL.ASM, MSDOS 6.0, 1991
 15377                                  ;============================================================================
 15378                                  ; 07/08/2018 - Retro DOS v3.0
 15379                                  ; 17/05/2019 - Retro DOS v4.0
 15380                                  
 15381                                  ;**	IOCTL system call.
 15382                                  ;----------------------------------------------------------------------------
 15383                                  ;	$IOCTL
 15384                                  ;
 15385                                  ;	  Revision history:
 15386                                  ;
 15387                                  ;		Created: ARR 4 April 1983
 15388                                  ;
 15389                                  ;		GenericIOCTL added:		KGS	22 April 1985
 15390                                  ;
 15391                                  ;		A000	version 4.00	Jan. 1988
 15392                                  ;
 15393                                  ;		Used jump table to dispatch IOCTL functions. HKN 3/12/90
 15394                                  ;
 15395                                  
 15396                                  ;BREAK <IOCTL - munge on a handle to do device specific stuff>
 15397                                  ;---------------------------------------------------------------------------
 15398                                  ;
 15399                                  ;   Assembler usage:
 15400                                  ;	    MOV     BX, Handle
 15401                                  ;	    MOV     DX, Data
 15402                                  ;
 15403                                  ;	(or LDS     DX,BUF
 15404                                  ;	    MOV     CX,COUNT)
 15405                                  ;
 15406                                  ;	    MOV     AH, Ioctl
 15407                                  ;	    MOV     AL, Request
 15408                                  ;	    INT     21h
 15409                                  ;
 15410                                  ;   AH = 0  Return a combination of low byte of sf_flags and device driver
 15411                                  ;	    attribute word in DX, handle in BX:
 15412                                  ;	    DH = high word of device driver attributes
 15413                                  ;	    DL = low byte of sf_flags
 15414                                  ;	 1  Set the bits contained in DX to sf_flags.  DH MUST be 0.  Handle
 15415                                  ;	    in BX.
 15416                                  ;	 2  Read CX bytes from the device control channel for handle in BX
 15417                                  ;	    into DS:DX.  Return number read in AX.
 15418                                  ;	 3  Write CX bytes to the device control channel for handle in BX from
 15419                                  ;	    DS:DX.  Return bytes written in AX.
 15420                                  ;	 4  Read CX bytes from the device control channel for drive in BX
 15421                                  ;	    into DS:DX.  Return number read in AX.
 15422                                  ;	 5  Write CX bytes to the device control channel for drive in BX from
 15423                                  ;	    DS:DX.  Return bytes written in AX.
 15424                                  ;	 6  Return input status of handle in BX. If a read will go to the
 15425                                  ;	    device, AL = 0FFh, otherwise 0.
 15426                                  ;	 7  Return output status of handle in BX. If a write will go to the
 15427                                  ;	    device, AL = 0FFh, otherwise 0.
 15428                                  ;	 8  Given a drive in BX, return 1 if the device contains non-
 15429                                  ;	    removable media, 0 otherwise.
 15430                                  ;	 9  Return the contents of the device attribute word in DX for the
 15431                                  ;	    drive in BX.  0200h is the bit for shared.	1000h is the bit for
 15432                                  ;	    network. 8000h is the bit for local use.
 15433                                  ;	 A  Return 8000h if the handle in BX is for the network or not.
 15434                                  ;	 B  Change the retry delay and the retry count for the system. BX is
 15435                                  ;	    the count and CX is the delay.
 15436                                  ;
 15437                                  ;   Error returns:
 15438                                  ;	    AX = error_invalid_handle
 15439                                  ;	       = error_invalid_function
 15440                                  ;	       = error_invalid_data
 15441                                  ;
 15442                                  ;-------------------------------------------------------------------------------
 15443                                  ;
 15444                                  ;   This is the documentation copied from DOS 4.0 it is much better
 15445                                  ;   than the above
 15446                                  ;
 15447                                  ;	There are several basic forms of IOCTL calls:
 15448                                  ;
 15449                                  ;
 15450                                  ;	** Get/Set device information:	**
 15451                                  ;
 15452                                  ;	ENTRY	(AL) = function code
 15453                                  ;		  0 - Get device information
 15454                                  ;		  1 - Set device information
 15455                                  ;		(BX) = file handle
 15456                                  ;		(DX) = info for "Set Device Information"
 15457                                  ;	EXIT	'C' set if error
 15458                                  ;		  (AX) = error code
 15459                                  ;		'C' clear if OK
 15460                                  ;		  (DX) = info for "Get Device Information"
 15461                                  ;	USES	ALL
 15462                                  ;
 15463                                  ;
 15464                                  ;	**  Read/Write Control Data From/To Handle  **
 15465                                  ;
 15466                                  ;	ENTRY	(AL) = function code
 15467                                  ;		  2 - Read device control info
 15468                                  ;		  3 - Write device control info
 15469                                  ;		(BX) = file handle
 15470                                  ;		(CX) = transfer count
 15471                                  ;		(DS:DX) = address for data
 15472                                  ;	EXIT	'C' set if error
 15473                                  ;		  (AX) = error code
 15474                                  ;		'C' clear if OK
 15475                                  ;		  (AX) = count of bytes transfered
 15476                                  ;	USES	ALL
 15477                                  ;
 15478                                  ;
 15479                                  ;	**  Read/Write Control Data From/To Block Device  **
 15480                                  ;
 15481                                  ;	ENTRY	(AL) = function code
 15482                                  ;		  4 - Read device control info
 15483                                  ;		  5 - Write device control info
 15484                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 15485                                  ;		(CX) = transfer count
 15486                                  ;		(DS:DX) = address for data
 15487                                  ;	EXIT	'C' set if error
 15488                                  ;		  (AX) = error code
 15489                                  ;		'C' clear if OK
 15490                                  ;		  (AX) = count of bytes transfered
 15491                                  ;	USES	ALL
 15492                                  ;
 15493                                  ;
 15494                                  ;	**  Get Input/Output Status  **
 15495                                  ;
 15496                                  ;	ENTRY	(AL) = function code
 15497                                  ;		  6 - Get Input status
 15498                                  ;		  7 - Get Output Status
 15499                                  ;		(BX) = file handle
 15500                                  ;	EXIT	'C' set if error
 15501                                  ;		  (AX) = error code
 15502                                  ;		'C' clear if OK
 15503                                  ;		  (AL) = 00 if not ready
 15504                                  ;		  (AL) = FF if ready
 15505                                  ;	USES	ALL
 15506                                  ;
 15507                                  ;
 15508                                  ;	**  Get Drive Information  **
 15509                                  ;
 15510                                  ;	ENTRY	(AL) = function code
 15511                                  ;		  8 - Check for removable media
 15512                                  ;		  9 - Get device attributes
 15513                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 15514                                  ;	EXIT	'C' set if error
 15515                                  ;		  (AX) = error code
 15516                                  ;		'C' clear if OK
 15517                                  ;		  (AX) = 0/1 media is removable/fixed (func. 8)
 15518                                  ;		  (DX) = device attribute word (func. 9)
 15519                                  ;	USES	ALL
 15520                                  ;
 15521                                  ;
 15522                                  ;	**  Get Redirected bit	**
 15523                                  ;
 15524                                  ;	ENTRY	(AL) = function code
 15525                                  ;		  0Ah - Network stuff
 15526                                  ;		(BX) = file handle
 15527                                  ;	EXIT	'C' set if error
 15528                                  ;		  (AX) = error code
 15529                                  ;		'C' clear if OK
 15530                                  ;		  (DX) = SFT flags word, 8000h set if network file
 15531                                  ;	USES	ALL
 15532                                  ;
 15533                                  ;
 15534                                  ;	**  Change sharer retry parameters  **
 15535                                  ;
 15536                                  ;	ENTRY	(AL) = function code
 15537                                  ;		  0Bh - Set retry parameters
 15538                                  ;		(CX) = retry loop count
 15539                                  ;		(DX) = number of retries
 15540                                  ;	EXIT	'C' set if error
 15541                                  ;		  (AX) = error code
 15542                                  ;		'C' clear if OK
 15543                                  ;	USES	ALL
 15544                                  ;
 15545                                  ;
 15546                                  ;   =================================================================
 15547                                  ;
 15548                                  ;	**  New Standard Control  **
 15549                                  ;
 15550                                  ;	ALL NEW IOCTL FACILITIES SHOULD USE THIS FORM.	THE OTHER
 15551                                  ;	FORMS ARE OBSOLETE.
 15552                                  ;
 15553                                  ;   =================================================================
 15554                                  ;
 15555                                  ;	ENTRY	(AL) = function code
 15556                                  ;		  0Ch - Control Function subcode
 15557                                  ;		(BX) = File Handle
 15558                                  ;		(CH) = Category Indicator
 15559                                  ;		(CL) = Function within category
 15560                                  ;		(DS:DX) = address for data, if any
 15561                                  ;		(SI) = Passed to device as argument, use depends upon function
 15562                                  ;		(DI) = Passed to device as argument, use depends upon function
 15563                                  ;	EXIT	'C' set if error
 15564                                  ;		  (AX) = error code
 15565                                  ;		'C' clear if OK
 15566                                  ;		  (SI) = Return value, meaning is function dependent
 15567                                  ;		  (DI) = Return value, meaning is function dependent
 15568                                  ;		  (DS:DX) = Return address, use is function dependent
 15569                                  ;	USES	ALL
 15570                                  ;
 15571                                  ;    ============== Generic IOCTL Definitions for DOS 3.2 ============
 15572                                  ;     (See inc\ioctl.inc for more info)
 15573                                  ;
 15574                                  ;	ENTRY	(AL) = function code
 15575                                  ;		  0Dh - Control Function subcode
 15576                                  ;		(BL) = Drive Number (0 = Default, 1= 'A')
 15577                                  ;		(CH) = Category Indicator
 15578                                  ;		(CL) = Function within category
 15579                                  ;		(DS:DX) = address for data, if any
 15580                                  ;		(SI) = Passed to device as argument, use depends upon function
 15581                                  ;		(DI) = Passed to device as argument, use depends upon function
 15582                                  ;
 15583                                  ;	EXIT	'C' set if error
 15584                                  ;		  (AX) = error code
 15585                                  ;		'C' clear if OK
 15586                                  ;		  (DS:DX) = Return address, use is function dependent
 15587                                  ;	USES	ALL
 15588                                  ;
 15589                                  ;---------------------------------------------------------------------------
 15590                                  	
 15591                                  	; 17/05/2019 - Retro DOS v4.0
 15592                                  	; DOSCODE:611Eh (MSDOS 6.21, MSDOS.SYS)
 15593                                  
 15594                                  	; 11/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15595                                  	; DOSCODE:610Ah (MSDOS 5.0, MSDOS.SYS)
 15596                                  
 15597                                  IOCTLJMPTABLE:	;label	word
 15598                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15599 000021DF [1B22]                  	dw	ioctl_getset_data	; 0
 15600 000021E1 [1B22]                  	dw	ioctl_getset_data   	; 1
 15601 000021E3 [6B22]                  	dw	ioctl_control_string	; 2
 15602 000021E5 [6B22]                  	dw	ioctl_control_string	; 3
 15603 000021E7 [B923]                  	dw	ioctl_get_dev		; 4
 15604 000021E9 [B923]                  	dw	ioctl_get_dev		; 5
 15605 000021EB [8522]                  	dw	ioctl_status		; 6
 15606 000021ED [8522]                  	dw	ioctl_status		; 7
 15607 000021EF [2623]                  	dw	ioctl_rem_media		; 8
 15608 000021F1 [6123]                  	dw	ioctl_drive_attr	; 9
 15609 000021F3 [AB23]                  	dw	ioctl_handle_redir	; A
 15610 000021F5 [A122]                  	dw	Set_Retry_Parameters	; B
 15611 000021F7 [AF22]                  	dw	GENERICIOCTLHANDLE	; C
 15612 000021F9 [C622]                  	dw	GENERICIOCTL		; D
 15613                                  	; MSDOS 6.0 (& MSDOS 3.3)
 15614 000021FB [5C24]                  	dw	ioctl_drive_owner	; E
 15615 000021FD [5C24]                  	dw	ioctl_drive_owner	; F
 15616                                  	; MSDOS 6.0
 15617 000021FF [AF22]                  	dw	query_handle_support	; 10h
 15618 00002201 [C622]                  	dw	query_device_support	; 11h
 15619                                  
 15620                                  	; 11/11/2022
 15621                                  _$IOCTL:
 15622 00002203 8CDE                    	MOV	SI,DS			; Stash DS for calls 2,3,4 and 5
 15623 00002205 16                      	push	ss
 15624 00002206 1F                      	pop	ds			;hkn; SS is DOSDATA
 15625                                  
 15626                                  	; MSDOS 3.3
 15627                                  	;cmp	al,0Fh 
 15628                                  	; MSDOS 6.0
 15629 00002207 3C11                    	cmp	al,11h			; al must be between 0 & 11h
 15630 00002209 770D                    	ja	short ioctl_bad_funj2	; if not bad function #
 15631                                  
 15632                                  	; 14/01/2024
 15633                                  	; 28/05/2019
 15634                                  	;push	AX	; 14/01/2024	; Need to save AL for generic IOCTL
 15635 0000220B 89C7                    	mov	di,ax			; di NOT a PARM
 15636 0000220D 81E7FF00                	and	di,0FFh			; di = al
 15637 00002211 D1E7                    	shl	di,1			; di = index into jmp table
 15638                                  	;pop	AX			; Restore AL for generic IOCTL
 15639                                  
 15640 00002213 2EFFA5[DF21]            	jmp	word [CS:DI+IOCTLJMPTABLE]
 15641                                  
 15642                                  ioctl_bad_funj2:
 15643 00002218 E90301                  	JMP	ioctl_bad_fun  ; 10/08/2018
 15644                                  
 15645                                  ;--------------------------------------------------------------------------
 15646                                  ;
 15647                                  ; IOCTL: AL = 0,1
 15648                                  ;
 15649                                  ; ENTRY: DS = DOSDATA
 15650                                  ;
 15651                                  ;--------------------------------------------------------------------------
 15652                                  
 15653                                  ioctl_getset_data:
 15654                                  	; MSDOS 6.0
 15655 0000221B E8A742                  	call	SFFromHandle		; ES:DI -> SFT
 15656 0000221E 7305                    	JNC	short ioctl_check_permissions ; have valid handle
 15657                                  ioctl_bad_handle:
 15658                                  	;mov	al,6
 15659 00002220 B006                    	mov	al,error_invalid_handle
 15660                                  ioctl_error:
 15661 00002222 E915E4                  	jmp	SYS_RET_ERR
 15662                                  
 15663                                  ioctl_check_permissions:
 15664 00002225 3C00                    	CMP	AL,0
 15665                                  	;mov	al,[es:di+5]
 15666 00002227 268A4505                	MOV	AL,[ES:DI+SF_ENTRY.sf_flags]; Get low byte of flags
 15667 0000222B 741B                    	JZ	short ioctl_read	; read the byte
 15668                                  
 15669 0000222D 08F6                    	or	dh,dh
 15670 0000222F 7404                    	JZ	short ioctl_check_device ; can I set with this data?
 15671                                  	;mov	al,0Dh
 15672 00002231 B00D                    	mov	al,error_invalid_data	; no DH <> 0
 15673                                  	;jmp	SYS_RET_ERR
 15674 00002233 EBED                    	jmp	short ioctl_error
 15675                                  
 15676                                  ioctl_check_device:
 15677 00002235 A880                    	test	AL,devid_device  ; 80h	; can I set this handle?
 15678 00002237 74DF                    	jz	short ioctl_bad_funj2
 15679 00002239 80CA80                  	OR	DL,devid_device 	; Make sure user doesn't turn off the
 15680                                  					;   device bit!! He can muck with the
 15681                                  					;   others at will.
 15682 0000223C C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 15683 00002241 26885505                	MOV	BYTE [ES:DI+SF_ENTRY.sf_flags],DL  ;AC000;MS.; Set flags
 15684                                  ioctl_ok:
 15685 00002245 E9E9E3                  	jmp	SYS_RET_OK
 15686                                  
 15687                                  ioctl_read:
 15688 00002248 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk  ; 2
 15689 0000224D 30E4                    	XOR	AH,AH
 15690 0000224F A880                    	test	AL,devid_device 	; Should I set high byte
 15691 00002251 740D                    	JZ	short ioctl_no_high	; no
 15692 00002253 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 15693                                  	;les	di,[es:di+7]
 15694 00002258 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 15695                                  	;mov	ah,[es:di+5]
 15696 0000225C 268A6505                	MOV	AH,[ES:DI+SYSDEV.ATT+1] ; Get high byte
 15697                                  ioctl_no_high:
 15698 00002260 89C2                    	MOV	DX,AX
 15699                                  ioctl_set_dx:	; 16/12/2022
 15700 00002262 E81CE2                  	call	Get_User_Stack
 15701                                  	;mov	[si+6],dx
 15702 00002265 895406                  	MOV	[SI+user_env.user_DX],DX
 15703                                  	;;jmp	SYS_RET_OK
 15704                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15705                                  ioctl_ok_j:
 15706                                  	; 16/12/2022
 15707 00002268 E9C9E3                  	jmp	SYS_RET_OK_clc	 ; (after 'Get_User_Stack') 
 15708                                  	;jmp	short ioctl_ok
 15709                                  	; 26/07/2019
 15710                                  	;jmp	SYS_RET_OK_clc
 15711                                  
 15712                                  ;--------------------------------------------------------------------------
 15713                                  ;
 15714                                  ; IOCTL: AL = 2,3
 15715                                  ;
 15716                                  ; ENTRY: DS = DOSDATA
 15717                                  ;	 SI = user's DS
 15718                                  ;
 15719                                  ;--------------------------------------------------------------------------
 15720                                  
 15721                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15722                                  ioctl_control_string:
 15723 0000226B E85742                  	call	SFFromHandle		; ES:DI -> SFT
 15724 0000226E 72B0                    	JC	short ioctl_bad_handle	; invalid handle
 15725                                  	; 07/12/2022
 15726                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
 15727                                  	;jz	short ioctl_bad_funj2			; No it is a file
 15728                                  	; MSDOS 5.0 & MSDOS 6.0
 15729 00002270 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
 15730 00002275 74A1                    	jz	short ioctl_bad_funj2			; No it is a file
 15731 00002277 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 15732 0000227C 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 15733 00002280 30DB                    	XOR	BL,BL			; Unit number of char dev = 0
 15734 00002282 E93C01                  	JMP	ioctl_do_string
 15735                                  
 15736                                  ;--------------------------------------------------------------------------
 15737                                  ;
 15738                                  ; IOCTL: AL = 6,7
 15739                                  ;
 15740                                  ; ENTRY: DS = DOSDATA
 15741                                  ;
 15742                                  ;--------------------------------------------------------------------------
 15743                                  
 15744                                  ioctl_status:
 15745 00002285 B401                    	MOV	AH,1
 15746 00002287 2C06                    	SUB	AL,6			; 6=0,7=1
 15747 00002289 7402                    	JZ	short ioctl_get_status
 15748 0000228B B403                    	MOV	AH,3
 15749                                  ioctl_get_status:
 15750 0000228D 50                      	PUSH	AX
 15751 0000228E E8B112                  	call	GET_IO_SFT
 15752 00002291 58                      	POP	AX
 15753                                  	;JNC	short DO_IOFUNC
 15754                                  	;JMP	short ioctl_bad_handle	; invalid SFT
 15755                                  	; 16/12/2022
 15756 00002292 728C                    	jc	short ioctl_bad_handle
 15757                                  DO_IOFUNC:
 15758 00002294 E8A520                  	call	IOFUNC
 15759 00002297 88C4                    	MOV	AH,AL
 15760 00002299 B0FF                    	MOV	AL,0FFH
 15761                                  	;JNZ	short ioctl_status_ret
 15762                                  	; 29/01/2024
 15763 0000229B 75A8                    	jnz	short ioctl_ok
 15764 0000229D FEC0                    	INC	AL
 15765                                  ioctl_status_ret:
 15766                                  	;jmp	SYS_RET_OK
 15767                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15768                                  	;jmp	short ioctl_ok_j
 15769                                  	; 16/12/2022
 15770 0000229F EBA4                    	jmp	short ioctl_ok
 15771                                  
 15772                                  ;--------------------------------------------------------------------------
 15773                                  ;
 15774                                  ; IOCTL: AL = B
 15775                                  ;
 15776                                  ; ENTRY: DS = DOSDATA
 15777                                  ;
 15778                                  ;--------------------------------------------------------------------------
 15779                                  
 15780                                  Set_Retry_Parameters:
 15781                                  	; 09/09/2018
 15782 000022A1 890E[1C00]              	MOV	[RetryLoop],CX		; 0 retry loop count allowed
 15783 000022A5 09D2                    	OR	DX,DX			; zero retries not allowed
 15784 000022A7 7475                    	JZ	short ioctl_bad_fun
 15785 000022A9 8916[1A00]              	MOV	[RetryCount],DX		; Set new retry count
 15786                                  doneok:
 15787                                  	;jmp	SYS_RET_OK		; Done
 15788                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15789                                  	;jmp	short ioctl_status_ret
 15790                                  	; 16/12/2022
 15791 000022AD EB96                    	jmp	short ioctl_ok	 ; jmp SYS_RET_OK
 15792                                  
 15793                                  ;--------------------------------------------------------------------------
 15794                                  ;
 15795                                  ; Generic IOCTL entry point. AL = C, D, 10h, 11h
 15796                                  ;
 15797                                  ;	here we invoke the Generic IOCTL using the IOCTL_Req structure.
 15798                                  ;	SI:DX -> Users Device Parameter Table
 15799                                  ;	IOCALL -> IOCTL_Req structure
 15800                                  ;
 15801                                  ; 	If on entry AL >= IOCTL_QUERY_HANDLE the function is a
 15802                                  ;	QueryIOCtlSupport call ELSE it's a standard generic IOCtl
 15803                                  ;	call.
 15804                                  ;
 15805                                  ; BUGBUG: Don't push anything on the stack between GENERIOCTL: and 
 15806                                  ;         the call to Check_If_Net because Check_If_Net gets our
 15807                                  ;         return address off the stack if the drive is invalid.
 15808                                  ;
 15809                                  ;--------------------------------------------------------------------------
 15810                                  
 15811                                  query_handle_support:	; Entry point for handles
 15812                                  GENERICIOCTLHANDLE:
 15813 000022AF E81342                  	call	SFFromHandle		; Get SFT for device.
 15814 000022B2 726F                    	jc	short ioctl_bad_handlej
 15815                                  
 15816                                  	;test	word [es:di+5],8000h
 15817                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet	; M031;
 15818                                  	;test	byte [es:di+6],80h
 15819 000022B4 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 15820 000022B9 7563                    	jnz	short ioctl_bad_fun	; Cannot do this over net.
 15821                                  
 15822 000022BB C606[2303]04            	mov	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 15823                                  	;les	di,[es:di+7]
 15824 000022C0 26C47D07                	les	di,[es:di+SF_ENTRY.sf_devptr]	; Get pointer to device.
 15825 000022C4 EB0F                    	jmp	short Do_GenIOCTL
 15826                                  
 15827                                  query_device_support:	; Entry point for devices:
 15828                                  GENERICIOCTL:
 15829 000022C6 C606[2303]02            	mov	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 15830 000022CB 80FD08                  	cmp	ch,IOC_DC ; 8		; Only disk devices are allowed to use
 15831 000022CE 754E                    	jne	short ioctl_bad_fun	; no handles with Generic IOCTL.
 15832                                  
 15833 000022D0 E87A01                  	CALL	Check_If_Net		; ES:DI := Get_hdr_block of device in BL
 15834 000022D3 7549                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 15835                                  
 15836                                  Do_GenIOCTL:
 15837                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320 
 15838                                  					; Can device handle Generic IOCTL funcs
 15839                                  	; 09/09/2018
 15840                                  	;test	byte [es:di+4],40h
 15841 000022D5 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 15842 000022DA 7442                    	jz	short ioctl_bad_fun
 15843                                  
 15844                                  	; 17/05/2019 - Retro DOS v4.0
 15845                                  
 15846                                  	; MSDOS 6.0
 15847                                  	;mov	byte [IOCALL_REQFUNC],19 ; 13h
 15848 000022DC C606[7E03]13            	mov	byte [IOCALL_REQFUNC],GENIOCTL ; Assume real Request
 15849                                  	;cmp	al,10h
 15850 000022E1 3C10                    	cmp	AL,IOCTL_QUERY_HANDLE	; See if this is just a query
 15851 000022E3 7C0C                    	jl	short SetIOCtlBlock
 15852                                  	
 15853                                  	;TEST	word [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
 15854                                  	;test	byte [es:di+4],80h 
 15855 000022E5 26F6450480              	TEST	byte [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
 15856 000022EA 7432                    	jz	short ioctl_bad_fun	; No support for query 
 15857                                  	;
 15858                                  	;mov	byte [IOCALL_REQFUNC],19h	
 15859 000022EC C606[7E03]19            	mov	byte [IOCALL_REQFUNC],IOCTL_QUERY ; Just a query (5.00)
 15860                                  
 15861                                  SetIOCtlBlock:
 15862 000022F1 06                      	PUSH	ES			; DEVIOCALL2 expects Device header block
 15863 000022F2 57                      	PUSH	DI			; in DS:SI
 15864                                  					; Setup Generic IOCTL Request Block
 15865                                  	;mov	byte [IOCALL_REQLEN],23
 15866 000022F3 C606[7C03]17            	mov	byte [IOCALL_REQLEN],IOCTL_REQ.size
 15867                                  	; 07/09/2018 (MSDOS 3.3)
 15868                                  	;;mov	byte [IOCALL_REQFUNC],19
 15869                                  	;mov	byte [IOCALL_REQFUNC],GENIOCTL ; 07/09/2018
 15870                                  	;
 15871 000022F8 881E[7D03]              	MOV	[IOCALL_REQUNIT],BL
 15872 000022FC 882E[8903]              	MOV	[IOCALL+IOCTL_REQ.MAJORFUNCTION],CH
 15873 00002300 880E[8A03]              	MOV	[IOCALL+IOCTL_REQ.MINORFUNCTION],CL
 15874 00002304 8936[8B03]              	MOV	[IOCALL+IOCTL_REQ.REG_SI],SI
 15875 00002308 893E[8D03]              	MOV	[IOCALL+IOCTL_REQ.REG_DI],DI
 15876 0000230C 8916[8F03]              	MOV	[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET],DX
 15877 00002310 8936[9103]              	MOV	[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET+2],SI
 15878                                  
 15879                                  ;hkn; IOCALL is in DOSDATA
 15880 00002314 BB[7C03]                	MOV	BX,IOCALL
 15881                                  
 15882 00002317 16                      	PUSH	SS
 15883 00002318 07                      	POP	ES
 15884                                  					; DS:SI -> Device header.
 15885 00002319 5E                      	POP	SI
 15886 0000231A 1F                      	POP	DS
 15887                                  	; 10/08/2018
 15888 0000231B E9DC00                  	jmp	ioctl_do_IO		; Perform Call to device driver
 15889                                  
 15890                                  ioctl_bad_fun:
 15891 0000231E B001                    	mov	al, error_invalid_function  ; 1
 15892 00002320 E917E3                  	jmp	SYS_RET_ERR	
 15893                                  
 15894                                  ioctl_bad_handlej:
 15895 00002323 E9FAFE                  	jmp	ioctl_bad_handle
 15896                                  
 15897                                  ;---------------------------------------------------------------------------
 15898                                  ;
 15899                                  ; IOCTL: AL = 8
 15900                                  ;
 15901                                  ; ENTRY: DS = DOSDATA
 15902                                  ;
 15903                                  ; BUGBUG: Don't push anything on the stack between ioctl_rem_media: and 
 15904                                  ;         the call to Check_If_Net because Check_If_Net gets our
 15905                                  ;         return address off the stack if the drive is invalid.
 15906                                  ;
 15907                                  ;-------------------------------------------------------------------------
 15908                                  
 15909                                  	; 30/01/2024
 15910                                  ioctl_rem_media:
 15911                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15912 00002326 E82401                  	CALL	Check_If_Net
 15913 00002329 75F3                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 15914                                  					;   certainly don't know how to do this
 15915                                  					;   call.
 15916                                  	;test	word [es:di+4],800h
 15917                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL ; See if device can
 15918                                  	;test	byte [es:di+5],8
 15919 0000232B 26F6450508              	TEST	byte [es:di+SYSDEV.ATT+1],(DEVOPCL>>8)
 15920 00002330 74EC                    	JZ	short ioctl_bad_fun		; NO
 15921                                  
 15922                                  ;hkn; SS override for IOCALL
 15923                                  	; 30/01/2024
 15924                                  	; ds = ss = DOSDATA segment ('Get_Driver_BL' in 'Check_If_Net')
 15925                                  	;MOV	byte [SS:IOCALL_REQFUNC],DEVRMD ; 15
 15926 00002332 C606[7E03]0F            	mov	byte [IOCALL_REQFUNC],DEVRMD ; 15
 15927 00002337 B00D                    	MOV	AL,REMHL  ; 13
 15928 00002339 88DC                    	MOV	AH,BL			; Unit number
 15929                                  	;MOV	[SS:IOCALL_REQLEN],AX
 15930 0000233B A3[7C03]                	mov	[IOCALL_REQLEN],ax	
 15931 0000233E 31C0                    	XOR	AX,AX
 15932                                  	;MOV	[SS:IOCALL_REQSTAT],AX
 15933 00002340 A3[7F03]                	mov	[IOCALL_REQSTAT],ax ; 0
 15934                                  	
 15935 00002343 06                      	PUSH	ES
 15936 00002344 1F                      	POP	DS
 15937 00002345 89FE                    	MOV	SI,DI			; DS:SI -> driver
 15938 00002347 16                      	PUSH	SS
 15939 00002348 07                      	POP	ES
 15940                                  
 15941                                  ;hkn; IOCALL is in DOSDATA (msconst.asm)
 15942                                  	; 30/01/2024
 15943                                  	; (ds <> ss, ss = DOSDATA segment)
 15944 00002349 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 15945 0000234C 1E                      	push	ds
 15946 0000234D 56                      	push	si
 15947 0000234E E8B821                  	call	DEVIOCALL2
 15948 00002351 5E                      	pop	si
 15949 00002352 1F                      	pop	ds
 15950                                  
 15951                                  ;hkn; SS override
 15952 00002353 36A1[7F03]              	MOV	AX,[SS:IOCALL_REQSTAT]	; Get Status word
 15953                                  	;AND	AX,STBUI ; 200h		; Mask to busy bit
 15954                                  	; 29/01/2024
 15955 00002357 80E402                  	and	ah,STBUI>>8
 15956 0000235A B109                    	MOV	CL,9
 15957 0000235C D3E8                    	SHR	AX,CL			; Busy bit to bit 0
 15958                                  ioctl_da_ok_j:	; 11/11/2022
 15959 0000235E E9D0E2                  	jmp	SYS_RET_OK
 15960                                  
 15961                                  ;-------------------------------------------------------------------------
 15962                                  ;
 15963                                  ; IOCTL: AL = 9
 15964                                  ;
 15965                                  ; ENTRY: DS = DOSDATA
 15966                                  ;
 15967                                  ;-------------------------------------------------------------------------
 15968                                  
 15969                                  ioctl_drive_attr:
 15970                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15971 00002361 88D8                    	mov	al,bl
 15972 00002363 E86E45                  	call	GETTHISDRV
 15973 00002366 723E                    	jc	short ioctl_drv_err
 15974 00002368 E8B500                  	call	Get_Driver_BL
 15975                                  	; MSDOS 6.0
 15976 0000236B 7239                    	JC	short ioctl_drv_err	; drive not valid
 15977                                  
 15978                                  	;mov	dx,[es:di+4]
 15979 0000236D 268B5504                	mov	dx,[es:di+SYSDEV.ATT]	
 15980                                  					; get device attribute word
 15981 00002371 88C3                    	MOV	BL,AL			; Phys letter to BL (A=0)
 15982                                  
 15983                                  ;hkn; SS override
 15984                                  	;LES	DI,[SS:THISCDS]
 15985                                  	; 30/01/2024
 15986 00002373 C43E[A205]              	les	di,[THISCDS] ; (Get_Driver_BL)
 15987                                  
 15988                                  	;test	word [es:di+43h],8000h
 15989                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 15990                                  	;test	byte [es:di+44h],80h
 15991 00002377 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 15992 0000237C 7403                    	JZ	short IOCTLShare
 15993                                  
 15994                                  	;or	dx,1000h ; (MSDOS 3.3)
 15995                                  
 15996                                  ;	Net devices don't return a device attribute word.
 15997                                  ;	Bit 12 = 1, meaning net device, all others = 0.
 15998                                  
 15999 0000237E BA0010                  	MOV	DX,1000h ; MSDOS 6.0
 16000                                  
 16001                                  IOCTLShare:
 16002                                  	; 30/01/2024
 16003                                  	; ds = ss = DOSDATA segment
 16004                                  	;push	ss
 16005                                  	;pop	ds
 16006                                  
 16007 00002381 BE[BE03]                	MOV	SI,OPENBUF
 16008 00002384 80C341                  	ADD	BL,"A"	; 41h
 16009 00002387 881C                    	MOV	[SI],BL
 16010 00002389 C744013A00              	MOV	WORD [SI+1],003AH ; ":",0
 16011 0000238E B80003                  	MOV	AX,0300h
 16012 00002391 F8                      	CLC
 16013                                  	;INT	int_IBM
 16014 00002392 CD2A                    	int     2Ah	; Microsoft Networks - CHECK DIRECT I/O
 16015                                  			; DS:SI -> ASCIZ disk device name 
 16016                                  			; (may be full path or only drive
 16017                                  			; specifier--must include the colon)
 16018                                  			; Return: CF clear if absolute disk access allowed
 16019 00002394 7303                    	JNC	short IOCTLLocal	; Not shared
 16020                                  	;OR	DX,0200H		; Shared, bit 9
 16021                                  	; 17/12/2022
 16022 00002396 80CE02                  	or	dh,02h
 16023                                  IOCTLLocal:
 16024                                  	;test	word [es:di+43h],1000h
 16025                                  	;TEST	word [ES:DI+curdir.flags],curdir_local
 16026                                  	;test	byte [es:di+44h],10h
 16027 00002399 26F6454410              	TEST	byte [ES:DI+curdir.flags+1],(curdir_local>>8)
 16028                                  	;JZ	short ioctl_set_DX
 16029                                  	; 16/12/2022
 16030 0000239E 7403                    	jz	short _ioctl_set_DX
 16031                                  	;OR	DX,8000h
 16032                                  	; 17/12/2022
 16033 000023A0 80CE80                  	or	dh,80h
 16034                                  ;ioctl_set_DX:
 16035                                  _ioctl_set_DX:
 16036                                  	; 16/12/2022
 16037 000023A3 E9BCFE                  	jmp	ioctl_set_dx
 16038                                  ; 16/12/2022
 16039                                  %if 0	
 16040                                  	call	Get_User_Stack
 16041                                  	MOV	[SI+user_env.user_DX],DX
 16042                                  	;;jmp	SYS_RET_OK
 16043                                  	;; 25/06/2019
 16044                                  	;jmp	SYS_RET_OK_clc
 16045                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16046                                  ioctl_gd_ok_j:
 16047                                  	jmp	short ioctl_da_ok_j
 16048                                  %endif
 16049                                  
 16050                                  ioctl_drv_err:
 16051 000023A6 B00F                    	mov	al,error_invalid_drive ; 0Fh
 16052                                  ioctl_gd_err_j:	; 11/11/2022
 16053 000023A8 E98FE2                  	jmp	SYS_RET_ERR
 16054                                  
 16055                                  ;--------------------------------------------------------------------------
 16056                                  ;
 16057                                  ; IOCTL: AL = A
 16058                                  ;
 16059                                  ; ENTRY: DS = DOSDATA
 16060                                  ;
 16061                                  ;--------------------------------------------------------------------------
 16062                                  
 16063                                  ioctl_handle_redir:
 16064 000023AB E81741                  	call	SFFromHandle		; ES:DI -> SFT
 16065 000023AE 7303                    	JNC	short ioctl_got_sft	; have valid handle
 16066 000023B0 E96DFE                  	jmp	ioctl_bad_handle ; 10/08/2018
 16067                                  
 16068                                  ioctl_got_sft:
 16069                                  	;mov	dx,[es:di+5]
 16070 000023B3 268B5505                	MOV	DX,[ES:DI+SF_ENTRY.sf_flags] ; Get flags
 16071                                  	;JMP	short ioctl_set_DX	; pass dx to user and return
 16072                                  	; 16/12/2022
 16073 000023B7 EBEA                    	jmp	short _ioctl_set_DX
 16074                                  
 16075                                  	; 16/12/2022
 16076                                  ;ioctl_bad_funj:
 16077                                  	;JMP	ioctl_bad_fun
 16078                                  
 16079                                  ;--------------------------------------------------------------------------
 16080                                  ;
 16081                                  ; IOCTL: AL= 4,5
 16082                                  ;
 16083                                  ; ENTRY: DS = DOSDATA
 16084                                  ;	 SI = user's DS
 16085                                  ;
 16086                                  ;
 16087                                  ; BUGBUG: Don't push anything on the stack between ioctl_get_dev: and 
 16088                                  ;         the call to Check_If_Net because Check_If_Net gets our
 16089                                  ;         return address off the stack if the drive is invalid.
 16090                                  ;
 16091                                  ;-------------------------------------------------------------------------
 16092                                  
 16093                                  ioctl_get_dev:
 16094 000023B9 E89100                  	CALL	Check_If_Net
 16095                                  	;JNZ	short ioctl_bad_funj	; There are no "net devices", and they
 16096                                  					; certainly don't know how to do this
 16097                                  					; call.
 16098                                  	; 16/12/2022
 16099 000023BC 7403                    	jz	short ioctl_do_string
 16100                                  ioctl_bad_funj:
 16101 000023BE E95DFF                  	JMP	ioctl_bad_fun
 16102                                  
 16103                                  ioctl_do_string:
 16104                                  	;test	word [es:di+4],4000h
 16105                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVIOCTL; See if device accepts control
 16106                                  	;test	byte [es:di+5],40h
 16107 000023C1 26F6450540              	TEST	byte [ES:DI+SYSDEV.ATT+1],(DEVIOCTL>>8)
 16108 000023C6 74F6                    	JZ	short ioctl_bad_funj		; NO
 16109                                  					; assume IOCTL read
 16110 000023C8 C606[7E03]03            	MOV	byte [IOCALL_REQFUNC],DEVRDIOCTL  ; 3
 16111                                  
 16112 000023CD A801                    	TEST	AL,1			; is it func. 4/5 or 2/3
 16113 000023CF 7405                    	JZ	short ioctl_control_call ; it is read. goto ioctl_control_call
 16114                                  
 16115                                  					; it is an IOCTL write
 16116 000023D1 C606[7E03]0C            	MOV	byte [IOCALL_REQFUNC],DEVWRIOCTL ; 12
 16117                                  
 16118                                  ioctl_control_call:
 16119 000023D6 B016                    	MOV	AL,DRDWRHL ; 22
 16120                                  ioctl_setup_pkt:
 16121 000023D8 88DC                    	MOV	AH,BL			; Unit number
 16122 000023DA A3[7C03]                	MOV	[IOCALL_REQLEN],AX
 16123 000023DD 31C0                    	XOR	AX,AX
 16124 000023DF A3[7F03]                	MOV	[IOCALL_REQSTAT],AX
 16125 000023E2 A2[8903]                	MOV	[IOMED],AL
 16126 000023E5 890E[8E03]              	MOV	[IOSCNT],CX
 16127 000023E9 8916[8A03]              	MOV	[IOXAD],DX
 16128 000023ED 8936[8C03]              	MOV	[IOXAD+2],SI
 16129 000023F1 06                      	PUSH	ES
 16130 000023F2 1F                      	POP	DS
 16131 000023F3 89FE                    	MOV	SI,DI			; DS:SI -> driver
 16132 000023F5 16                      	PUSH	SS
 16133 000023F6 07                      	POP	ES
 16134                                  
 16135 000023F7 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 16136                                  ioctl_do_IO:
 16137 000023FA E80C21                  	call	DEVIOCALL2
 16138                                  
 16139                                  ;hkn; SS override for IOCALL
 16140                                  	;test	word [SS:IOCALL_REQSTAT],8000h
 16141                                  	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
 16142                                  	;test	byte [SS:IOCALL_REQSTAT+1],80h
 16143 000023FD 36F606[8003]80          	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
 16144 00002403 7507                    	JNZ	short ioctl_string_err
 16145                                  
 16146                                  ;hkn; SS override
 16147 00002405 36A1[8E03]              	MOV	AX,[SS:IOSCNT]		; Get actual bytes transferred
 16148                                  	; 16/12/2022
 16149 00002409 E925E2                  	jmp	SYS_RET_OK
 16150                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16151                                  	;jmp	short ioctl_gd_ok_j
 16152                                  
 16153                                  ioctl_string_err:
 16154 0000240C 368B3E[7F03]            	MOV	DI,[SS:IOCALL_REQSTAT]	;Get Error
 16155                                  device_err:
 16156 00002411 81E7FF00                	AND	DI,STECODE ; 00FFh	; mask out irrelevant bits
 16157 00002415 89F8                    	MOV	AX,DI
 16158 00002417 E8552F                  	call	SET_I24_EXTENDED_ERROR
 16159                                  
 16160                                  ;hkn; use SS override
 16161                                  ;hkn;	mov	ax,[CS:EXTERR]
 16162 0000241A 36A1[2403]              	mov	ax,[SS:EXTERR]
 16163                                  	;jmp	SYS_RET_ERR
 16164                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16165 0000241E EB88                    	jmp	short ioctl_gd_err_j
 16166                                  
 16167                                  ; 17/05/2019 - Retro DOS v4.0
 16168                                  
 16169                                  ;--------------------------------------------------------------------------
 16170                                  ; Proc name : Get_Driver_BL
 16171                                  ;
 16172                                  ;	DS is DOSDATA
 16173                                  ;	BL is drive number (0=default)
 16174                                  ;	Returns pointer to device in ES:DI, unit number in BL if carry clear
 16175                                  ;	No regs modified
 16176                                  ;
 16177                                  ;---------------------------------------------------------------------------
 16178                                  
 16179                                  	; 30/01/2024
 16180                                  Get_Driver_BL:
 16181 00002420 50                      	PUSH	AX
 16182 00002421 88D8                    	MOV	AL,BL			; Drive
 16183 00002423 E8AE44                  	call	GETTHISDRV
 16184 00002426 7223                    	jc	short ioctl_bad_drv
 16185 00002428 30DB                    	XOR	BL,BL			; Unit zero on Net device
 16186 0000242A C606[2303]03            	MOV	byte [EXTERR_LOCUS],errLOC_Net ; 3
 16187 0000242F C43E[A205]              	LES	DI,[THISCDS]
 16188                                  	;test	word [es:di+43h],8000h
 16189                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 16190                                  	;test	byte [es:di+44h],80h
 16191 00002433 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 16192                                  	;les	di,[es:di+45h]
 16193 00002438 26C47D45                	LES	DI,[ES:DI+curdir.devptr] ; ES:DI -> Dpb or net dev
 16194 0000243C 750D                    	JNZ	short got_dev_ptr	 ; Is net
 16195 0000243E C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 16196                                  	;mov	bl,[es:di+1]
 16197 00002443 268A5D01                	MOV	BL,[ES:DI+DPB.UNIT]	; Unit number
 16198                                  	;les	di,[es:di+13h]
 16199 00002447 26C47D13                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Driver addr
 16200                                  got_dev_ptr:
 16201                                  	; 30/01/2024
 16202                                  	; cf=0
 16203                                  	;CLC
 16204                                  ioctl_bad_drv:
 16205 0000244B 58                      	POP	AX
 16206 0000244C C3                      	retn
 16207                                  
 16208                                  ;-------------------------------------------------------------------------
 16209                                  ; Proc Name : Check_If_Net:
 16210                                  ;
 16211                                  ;
 16212                                  ; Checks if the device is over the net or not. Returns result in ZERO flag.
 16213                                  ; If no device is found, the return address is popped off the stack, and a
 16214                                  ; jump is made to ioctl_drv_err.
 16215                                  ;
 16216                                  ; On Entry:
 16217                                  ; Registers same as those for Get_Driver_BL
 16218                                  ;
 16219                                  ; On Exit:
 16220                                  ; ZERO flag	- set if not a net device
 16221                                  ;		- reset if net device
 16222                                  ; ES:DI -> the device
 16223                                  ;
 16224                                  ;
 16225                                  ; BUGBUG: This function assumes the following stack setup on entry
 16226                                  ;
 16227                                  ;	  SP+2 -> Error return address
 16228                                  ;	  SP   -> Normal return address
 16229                                  ;
 16230                                  ;-------------------------------------------------------------------------
 16231                                  
 16232                                  	; 30/01/2024 - Retro DOS v5.0
 16233                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:639Ch
 16234                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6A91h
 16235                                  	; Windows ME IO.SYS - BIOSCODE:68E1h
 16236                                  
 16237                                  Check_If_Net:
 16238                                  	; MSDOS 3.3 (& MSDOS 6.0)
 16239 0000244D E8D0FF                  	CALL	Get_Driver_BL
 16240 00002450 7201                    	JC	short ioctl_drv_err_pop	; invalid drive letter
 16241                                  
 16242                                  ; 30/01/2024 ('Get_Driver_BL' returns with
 16243                                  ;	      'curdir_isnet' condition/ZF, no need to a second test)
 16244                                  %if 0
 16245                                  	;;;
 16246                                  	; (PCDOS 7.1 IBMDOS.COM, Windows ME IO.SYS)
 16247                                  	PUSH	ES
 16248                                  	PUSH	DI
 16249                                  	LES	DI,[THISCDS]
 16250                                  	;test	word [es:di+43h],8000h
 16251                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 16252                                  	;test	byte [es:di+44h],80h
 16253                                  	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 16254                                  	POP	DI
 16255                                  	POP	ES
 16256                                  	;;;
 16257                                  %endif
 16258 00002452 C3                      	retn
 16259                                  
 16260                                  ioctl_drv_err_pop:
 16261 00002453 58                      	pop	ax			; pop off return address
 16262 00002454 E94FFF                  	jmp	ioctl_drv_err
 16263                                  
 16264                                  ioctl_bad_funj3:
 16265 00002457 E9C4FE                  	jmp	ioctl_bad_fun
 16266                                  
 16267                                  ioctl_string_errj:
 16268 0000245A EBB0                    	jmp	short ioctl_string_err  ; 25/05/2019
 16269                                  
 16270                                  ;--------------------------------------------------------------------------
 16271                                  ;
 16272                                  ; IOCTL: AL = E, F
 16273                                  ;
 16274                                  ; ENTRY: DS = DOSDATA
 16275                                  ;
 16276                                  ;
 16277                                  ; BUGBUG: Don't push anything on the stack between ioctl_drive_owner: and 
 16278                                  ;         the call to Check_If_Net because Check_If_Net gets our
 16279                                  ;         return address off the stack if the drive is invalid.
 16280                                  ;
 16281                                  ;--------------------------------------------------------------------------
 16282                                  
 16283                                  ioctl_drive_owner:
 16284                                  	; MSDOS 3.3 (& MSDOS 6.0)
 16285 0000245C E8EEFF                  	Call	Check_If_Net
 16286 0000245F 75F6                    	JNZ	short ioctl_bad_funj3 	; There are no "net devices", and they
 16287                                  					;   certainly don't know how to do this
 16288                                  					;   call.
 16289                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320	; See if device can handle this
 16290                                  	; 09/09/2018
 16291                                  	;test	byte [es:di+4],40h
 16292 00002461 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 16293 00002466 74EF                    	JZ	short ioctl_bad_funj3 	; NO
 16294                                  	;mov	byte [IOCALL_REQFUNC],23
 16295 00002468 C606[7E03]17            	mov	byte [IOCALL_REQFUNC],DEVGETOWN	; default to get owner
 16296 0000246D 3C0E                    	cmp	al,0Eh			; Get Owner ?
 16297 0000246F 7405                    	jz	short GetOwner
 16298                                  SetOwner:
 16299 00002471 C606[7E03]18            	MOV	byte [IOCALL_REQFUNC],DEVSETOWN ; 24
 16300                                  GetOwner:
 16301 00002476 B00D                    	MOV	AL,OWNHL ; 13
 16302 00002478 88DC                    	MOV	AH,BL			; Unit number
 16303 0000247A A3[7C03]                	MOV	[IOCALL_REQLEN],AX
 16304 0000247D 31C0                    	XOR	AX,AX
 16305 0000247F A3[7F03]                	MOV	[IOCALL_REQSTAT],AX
 16306 00002482 06                      	PUSH	ES
 16307 00002483 1F                      	POP	DS
 16308 00002484 89FE                    	MOV	SI,DI			; DS:SI -> driver
 16309 00002486 16                      	PUSH	SS
 16310 00002487 07                      	POP	ES
 16311 00002488 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 16312 0000248B 1E                      	push	ds
 16313 0000248C 56                      	push	si
 16314 0000248D E87920                  	call	DEVIOCALL2
 16315 00002490 5E                      	pop	si
 16316 00002491 1F                      	pop	ds
 16317                                  ;hkn; SS override
 16318                                  	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
 16319                                  	;test	byte [SS:IOCALL_REQSTAT+1],80h
 16320 00002492 36F606[8003]80          	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
 16321 00002498 75C0                    	jnz	short ioctl_string_errj
 16322 0000249A 36A0[7D03]              	MOV	AL,[SS:IOCALL_REQUNIT]	; Get owner returned by device
 16323                                  					; owner returned is 1-based.
 16324 0000249E E990E1                  	jmp	SYS_RET_OK
 16325                                  
 16326                                  ;============================================================================
 16327                                  ; DELETE.ASM, MSDOS 6.0, 1991
 16328                                  ;============================================================================
 16329                                  ; 07/08/2018 - Retro DOS v3.0
 16330                                  ; 17/05/2019 - Retro DOS v4.0
 16331                                  
 16332                                  ;	TITLE	DOS_DELETE - Internal DELETE call for MS-DOS
 16333                                  ;	NAME	DOS_DELETE
 16334                                  
 16335                                  ;
 16336                                  ;	Microsoft Confidential
 16337                                  ;	Copyright (C) Microsoft Corporation 1991
 16338                                  ;	All Rights Reserved.
 16339                                  ;
 16340                                  
 16341                                  ;**	DELETE.ASM - Low level routine for deleting files
 16342                                  ;----------------------------------------------------------------------------
 16343                                  ;		DOS_DELETE
 16344                                  ;		REN_DEL_Check
 16345                                  ;		FastOpen_Delete	       ; DOS 3.3
 16346                                  ;		FastOpen_Update	       ; DOS 3.3
 16347                                  
 16348                                  ;   Revision history:
 16349                                  ;
 16350                                  ;   A000  version 4.00	Jan. 1988
 16351                                  ;   A001  Fastopen Rename fix	April 1989
 16352                                  
 16353                                  ;Installed = TRUE
 16354                                  
 16355                                  ;	i_need	NoSetDir,BYTE
 16356                                  ;	i_need	Creating,BYTE
 16357                                  ;	i_need	DELALL,BYTE
 16358                                  ;	i_need	THISDPB,DWORD
 16359                                  ;	i_need	THISSFT,DWORD
 16360                                  ;	i_need	THISCDS,DWORD
 16361                                  ;	i_need	CURBUF,DWORD
 16362                                  ;	i_need	ATTRIB,BYTE
 16363                                  ;	i_need	SATTRIB,BYTE
 16364                                  ;	i_need	WFP_START,WORD
 16365                                  ;	i_need	REN_WFP,WORD			 ;BN001
 16366                                  ;	i_need	NAME1,BYTE			 ;BN001
 16367                                  ;	i_need	FoundDel,BYTE
 16368                                  ;	i_need	AUXSTACK,BYTE
 16369                                  ;	i_need	VOLCHNG_FLAG,BYTE
 16370                                  ;	i_need	JShare,DWORD
 16371                                  ;	i_need	FastOpenTable,BYTE		  ; DOS 3.3
 16372                                  ;	i_need	FastTable,BYTE			  ; DOS 4.00
 16373                                  ;
 16374                                  ;	i_need	Del_ExtCluster,WORD		  ; DOS 4.00
 16375                                  ;
 16376                                  ;	i_need	SAVE_BX,WORD			  ; DOS 4.00
 16377                                  ;	i_need	DMAADD,DWORD
 16378                                  ;	i_need	RENAMEDMA,BYTE
 16379                                  
 16380                                  ;----------------------------------------------------------------------------
 16381                                  ;
 16382                                  ; Procedure Name : DOS_DELETE
 16383                                  ;
 16384                                  ; Inputs:
 16385                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 16386                                  ;		terminated)
 16387                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 16388                                  ;		( = -1 if current dir not involved, else
 16389                                  ;		 Points to first char after last "/" of current dir part)
 16390                                  ;	[THISCDS] Points to CDS being used
 16391                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 16392                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 16393                                  ; Function:
 16394                                  ;	Delete the specified file(s)
 16395                                  ; Outputs:
 16396                                  ;	CARRY CLEAR
 16397                                  ;		OK
 16398                                  ;	CARRY SET
 16399                                  ;	    AX is error code
 16400                                  ;		error_file_not_found
 16401                                  ;			Last element of path not found
 16402                                  ;		error_path_not_found
 16403                                  ;			Bad path (not in curr dir part if present)
 16404                                  ;		error_bad_curr_dir
 16405                                  ;			Bad path in current directory part of path
 16406                                  ;		error_access_denied
 16407                                  ;			Attempt to delete device or directory
 16408                                  ;		***error_sharing_violation***
 16409                                  ;			Deny both access required, generates an INT 24.
 16410                                  ;			This error is NOT returned. The INT 24H is generated,
 16411                                  ;			  and the file is ignored (not deleted). Delete will
 16412                                  ;			  simply continue on looking for more files.
 16413                                  ;			  Carry will NOT be set in this case.
 16414                                  ; DS preserved, others destroyed
 16415                                  ;
 16416                                  ;----------------------------------------------------------------------------
 16417                                  
 16418                                  FILEFOUND   equ 01h
 16419                                  FILEDELETED equ 10h
 16420                                  
 16421                                  
 16422                                  	; 12/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16423                                  	; DOSCODE:63E9h (MSDOS 5.0, MSDOS.SYS)
 16424                                  
 16425                                  	; 30/01/2024
 16426                                  
 16427                                  DOS_DELETE:
 16428                                  
 16429                                  ;hkn; DOS_Delete is called from file.asm and fcbio.asm. DS has been set up 
 16430                                  ;hkn; appropriately at this point.
 16431                                  
 16432 000024A1 E885ED                  	call	TestNet
 16433 000024A4 7306                    	JNC	short LOCAL_DELETE
 16434                                  
 16435                                  ;IF NOT Installed
 16436                                  ;	transfer NET_DELETE
 16437                                  ;ELSE
 16438                                  	;MOV	AX,(MultNET SHL 8) | 19
 16439                                  	;INT	2FH
 16440                                  	;return
 16441                                  
 16442 000024A6 B81311                  	mov	ax,1113h
 16443 000024A9 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
 16444                                  			; SS = DS = DOS CS, SDA first filename pointer -> 
 16445                                  			;		fully-qualified filename in DOS CS
 16446                                  			; SDA CDS pointer -> current directory structure for drive with file
 16447                                  			; Return: CF set on error
 16448 000024AB C3                      	retn
 16449                                  ;ENDIF
 16450                                  
 16451                                  LOCAL_DELETE:
 16452 000024AC C606[6F05]00            	MOV	byte [FOUNDDEL],0	; No files found and no files deleted
 16453 000024B1 E82EEE                  	call	ECritDisk
 16454                                  	;mov	word [CREATING],0E500h
 16455 000024B4 C706[7E05]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Assume not del *.*
 16456 000024BA 8B36[B205]              	MOV	SI,[WFP_START]
 16457                                  SKPNUL:
 16458 000024BE AC                      	LODSB
 16459 000024BF 08C0                    	OR	AL,AL
 16460 000024C1 75FB                    	JNZ	short SKPNUL		; go to end
 16461 000024C3 83EE04                  	SUB	SI,4			; Back over possible "*.*"
 16462 000024C6 813C2A2E                	CMP	WORD [SI],2E2Ah ; "*."
 16463 000024CA 7506                    	JNZ	short TEST_QUEST
 16464 000024CC 807C022A                	CMP	BYTE [SI+2],"*"
 16465 000024D0 741F                    	JZ	short CHECK_ATTS
 16466                                  TEST_QUEST:
 16467 000024D2 83EE09                  	SUB	SI,9		; Back over possible "????????.???"
 16468 000024D5 87FE                    	XCHG	DI,SI
 16469                                  
 16470 000024D7 16                      	push	ss
 16471                                  	;pop	ds ; ! Retro DOS v3.0 BUG !
 16472 000024D8 07                      	pop	es ; 17/05/2019
 16473                                  
 16474 000024D9 B83F3F                  	MOV	AX,"??" ; 3F3Fh
 16475 000024DC B90400                  	MOV	CX,4		; four sets of "??"
 16476 000024DF F3AF                    	REPE	SCASW
 16477 000024E1 751C                    	JNZ	short NOT_ALL
 16478 000024E3 87FE                    	XCHG	DI,SI
 16479 000024E5 AD                      	LODSW
 16480 000024E6 3D2E3F                  	CMP	AX,3F2Eh ; ".?"
 16481 000024E9 7514                    	JNZ	short NOT_ALL
 16482 000024EB AD                      	LODSW
 16483 000024EC 3D3F3F                  	CMP	AX,"??"
 16484 000024EF 750E                    	JNZ	short NOT_ALL
 16485                                  CHECK_ATTS:
 16486 000024F1 A0[6D05]                	MOV	AL,[SATTRIB]
 16487                                  	;and	al,1Fh
 16488 000024F4 241F                    	AND	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 16489                                  					; Look only at hidden bits
 16490                                  	;cmp	al,1Fh
 16491 000024F6 3C1F                    	CMP	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 16492                                  					; All must be set
 16493 000024F8 7505                    	JNZ	short NOT_ALL
 16494                                  
 16495                                  ; NOTE WARNING DANGER-----
 16496                                  ;    This DELALL stuff is not safe. It allows directories to be deleted.
 16497                                  ;	It should ONLY be used by FORMAT in the ROOT directory.
 16498                                  
 16499 000024FA C606[7F05]00            	MOV	byte [DELALL],0		; DEL *.* - flag deleting all
 16500                                  NOT_ALL:
 16501 000024FF C606[4C03]01            	MOV	byte [NoSetDir],1
 16502 00002504 E8E418                  	call	GetPathNoSet
 16503 00002507 7312                    	JNC	short Del_found
 16504 00002509 750B                    	JNZ	short _bad_path
 16505 0000250B 08C9                    	OR	CL,CL
 16506 0000250D 7407                    	JZ	short _bad_path
 16507                                  No_file:
 16508 0000250F B80200                  	MOV	AX,error_file_not_found
 16509                                  ErrorReturn:
 16510 00002512 F9                      	STC
 16511                                  	;call	LCritDisk
 16512                                  	;retn
 16513                                  	; 18/12/2022
 16514 00002513 E9E7ED                  	jmp	LCritDisk
 16515                                  
 16516                                  _bad_path:
 16517 00002516 B80300                  	MOV	AX,error_path_not_found
 16518 00002519 EBF7                    	JMP	short ErrorReturn
 16519                                  
 16520                                  Del_found:
 16521 0000251B 750C                    	JNZ	short NOT_DIR		; Check for dir specified
 16522 0000251D 803E[7F05]00            	CMP	byte [DELALL],0		; DelAll = 0 allows delete of dir.
 16523 00002522 7405                    	JZ	short NOT_DIR
 16524                                  Del_access_err:
 16525 00002524 B80500                  	MOV	AX,error_access_denied
 16526 00002527 EBE9                    	JMP	short ErrorReturn
 16527                                  
 16528                                  NOT_DIR:
 16529 00002529 08E4                    	OR	AH,AH			; Check if device name
 16530 0000252B 78F7                    	JS	short Del_access_err	; Can't delete I/O devices
 16531                                  
 16532                                  ; Main delete loop. CURBUF+2:BX points to a matching directory entry.
 16533                                  
 16534                                  DELFILE:
 16535 0000252D 800E[6F05]01            	OR	byte [FOUNDDEL],FILEFOUND ; file found, not deleted yet
 16536                                  
 16537                                  ; If we are deleting the Volume ID, then we set VOLUME_CHNG flag to make
 16538                                  ; DOS issue a build BPB call the next time this drive is accessed.
 16539                                  
 16540 00002532 1E                      	PUSH	DS
 16541 00002533 8A26[7F05]              	MOV	AH,[DELALL]
 16542 00002537 C53E[E205]              	LDS	DI,[CURBUF]
 16543                                  	
 16544                                  ;hkn; SS override
 16545 0000253B 36F606[6B05]01          	TEST	byte [SS:ATTRIB],attr_read_only ; are we deleting RO files too?
 16546 00002541 7509                    	JNZ	short DoDelete		; yes
 16547                                  
 16548 00002543 F6470B01                	TEST	byte [BX+dir_entry.dir_attr],attr_read_only
 16549 00002547 7403                    	JZ	short DoDelete		; not read only
 16550                                  
 16551                                  	; 30/01/2024 (PCDOS 7.1 IBMDOS.COM)
 16552                                  Skip_it:
 16553 00002549 1F                      	POP	DS
 16554 0000254A EB2F                    	JMP	SHORT DELNXT		; Skip it (Note ES:BP not set)
 16555                                  
 16556                                  DoDelete:
 16557 0000254C E88100                  	call	REN_DEL_Check		; Sets ES:BP = [THISDPB]
 16558                                  	;JNC	short DEL_SHARE_OK
 16559                                  	;POP	DS
 16560                                  	;JMP	SHORT DELNXT		; Skip it
 16561                                  	; 30/01/2024
 16562 0000254F 72F8                    	jc	short Skip_it
 16563                                  
 16564                                  DEL_SHARE_OK:
 16565                                  	; 17/05/2019 - Retro DOS v4.0
 16566                                  	; MSDOS 6.0
 16567                                  	;test	byte [di+5],40h
 16568 00002551 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 16569                                  					;LB. if already dirty		  ;AN000;
 16570 00002555 7507                    	JNZ	short yesdirty		;LB.  don't increment dirty count ;AN000;
 16571 00002557 E86934                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 16572                                  	;or	byte [di+5],40h
 16573 0000255A 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty
 16574                                  yesdirty:
 16575 0000255E 8827                    	mov	[bx],ah 
 16576                                  	;MOV	[BX+dir_entry.dir_name],AH ; Put in E5H or 0
 16577 00002560 8B1C                    	MOV	BX,[SI] 		; Get firclus pointer
 16578 00002562 1F                      	POP	DS
 16579 00002563 800E[6F05]10            	OR	byte [FOUNDDEL],FILEDELETED ; 10h ; Deleted file
 16580                                  
 16581 00002568 83FB02                  	CMP	BX,2
 16582 0000256B 720E                    	JB	short DELNXT		; File has invalid FIRCLUS (too small)
 16583                                  	;cmp	bx,[es:bp+0Dh]
 16584 0000256D 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 16585 00002571 7708                    	JA	short DELNXT		; File has invalid FIRCLUS (too big)
 16586                                  
 16587 00002573 E8C727                  	call	RELEASE 		; Free file data
 16588 00002576 7252                    	JC	short No_fileJ
 16589                                  
 16590                                  ; DOS 3.3  FastOpen
 16591                                  
 16592 00002578 E8C200                  	CALL	FastOpen_Delete 	; delete the dir info in fastopen
 16593                                  
 16594                                  ; DOS 3.3  FastOpen
 16595                                  
 16596                                  DELNXT:
 16597 0000257B C42E[8A05]              	LES	BP,[THISDPB]		; Possible to get here without this set
 16598 0000257F E8D617                  	call	GETENTRY		; Registers need to be reset
 16599 00002582 7246                    	JC	short No_fileJ
 16600 00002584 E81117                  	call	NEXTENT
 16601 00002587 73A4                    	JNC	short DELFILE
 16602 00002589 C42E[8A05]              	LES	BP,[THISDPB]		; NEXTENT sets ES=DOSGROUP
 16603                                  	; 12/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16604                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 16605                                  	;;mov	al,[es:bp+0]
 16606                                  	; 15/12/2022
 16607 0000258D 268A4600                	MOV	AL,[ES:BP]
 16608 00002591 E82133                  	call	FLUSHBUF
 16609 00002594 7234                    	JC	short No_fileJ
 16610                                  ;
 16611                                  ; Now we need to test FoundDel for our flags. The cases to consider are:
 16612                                  ;
 16613                                  ;   not found not deleted		file not found
 16614                                  ;   not found	  deleted		*** impossible ***
 16615                                  ;	found not deleted		access denied (read-only)
 16616                                  ;	found	  deleted		no error
 16617                                  ;
 16618 00002596 F606[6F05]10            	TEST	byte [FOUNDDEL],FILEDELETED ; did we delete a file?
 16619 0000259B 7426                    	JZ	short DelError		; no, figure out what's wrong.
 16620                                  ; We set VOLCHNG_FLAG to indicate that we have changed the volume label
 16621                                  ; and to force the DOS to issue a media check.
 16622 0000259D F606[6B05]08            	TEST	byte [ATTRIB],attr_volume_id ; 8
 16623 000025A2 741C                    	jz	short No_Set_Flag
 16624 000025A4 50                      	PUSH	AX
 16625 000025A5 06                      	PUSH	ES
 16626 000025A6 57                      	PUSH	DI
 16627 000025A7 C43E[A205]              	LES	DI,[THISCDS]
 16628 000025AB 268A25                  	MOV	AH,[ES:DI]		; Get drive
 16629 000025AE 80EC41                  	SUB	AH,'A'                  ; Convert to 0-based
 16630 000025B1 8826[A10A]              	mov	[VOLCHNG_FLAG],AH
 16631                                  	
 16632                                  	; MSDOS 6.0
 16633 000025B5 30FF                    	XOR	BH,BH			;>32mb delete volume id from boot record ;AN000;
 16634 000025B7 E8A404                  	call	Set_Media_ID		;>32mb set volume id to boot record	 ;AN000;
 16635                                  	 
 16636 000025BA E8852F                  	call	FATREAD_CDS		; force media check
 16637 000025BD 5F                      	POP	DI
 16638 000025BE 07                      	POP	ES
 16639 000025BF 58                      	POP	AX
 16640                                  No_Set_Flag:
 16641                                  	;call	LCritDisk		; carry is clear
 16642                                  	;retn
 16643                                  	; 18/12/2022
 16644 000025C0 E93AED                  	jmp	LCritDisk
 16645                                  DelError:
 16646 000025C3 F606[6F05]01            	TEST	byte [FOUNDDEL],FILEFOUND ; not deleted. Did we find file?
 16647 000025C8 7503                    	JNZ	short Del_access_errJ 	; yes. Access denied
 16648                                  No_fileJ:
 16649 000025CA E942FF                  	JMP	No_file ; 10/08/2018 		; Nope
 16650                                  Del_access_errJ:
 16651 000025CD E954FF                  	JMP	Del_access_err ; 10/08/2018
 16652                                  
 16653                                  ; 08/08/2018 - Retro DOS v3.0
 16654                                  
 16655                                  ;Break	<REN_DEL_Check - check for access for rename and delete>
 16656                                  ;---------------------------------------------------------------------------
 16657                                  ; Procedure Name : REN_DEL_Check
 16658                                  ;
 16659                                  ; Inputs:
 16660                                  ;	[THISDPB] set
 16661                                  ;	[CURBUF+2]:BX points to entry
 16662                                  ;	[CURBUF+2]:SI points to firclus field of entry
 16663                                  ;	[WFP_Start] points to name
 16664                                  ; Function:
 16665                                  ;	Check for Exclusive access on given file.
 16666                                  ;	  Used by RENAME, SET_FILE_INFO, and DELETE.
 16667                                  ; Outputs:
 16668                                  ;	ES:BP = [THISDPB]
 16669                                  ;	NOTE: The WFP string pointed to by [WFP_Start] Will be Modified.  The
 16670                                  ;		last element will be loaded from the directory entry.  This is
 16671                                  ;		so the name given to the sharer doesn't have any meta chars in
 16672                                  ;		it.
 16673                                  ;	Carry set if sharing violation, INT 24H generated
 16674                                  ;	    NOTE THAT AX IS NOT error_sharing_violation.
 16675                                  ;		This is because input AX is preserved.
 16676                                  ;		Caller must set the error if needed.
 16677                                  ;	Carry clear
 16678                                  ;		OK
 16679                                  ; AX,DS,BX,SI,DI preserved
 16680                                  ;---------------------------------------------------------------------------
 16681                                  
 16682                                  REN_DEL_Check:
 16683                                  
 16684 000025D0 1E                      	PUSH	DS
 16685 000025D1 57                      	PUSH	DI
 16686 000025D2 50                      	PUSH	AX
 16687 000025D3 53                      	PUSH	BX
 16688 000025D4 56                      	PUSH	SI		; Save CURBUF pointers
 16689                                  	
 16690 000025D5 16                      	push	ss
 16691 000025D6 07                      	pop	es
 16692                                  
 16693                                  ;hkn; context ES will assume ES to DOSDATA
 16694                                  ;hkn; ASSUME	ES:DOSGROUP
 16695                                  
 16696                                  ;hkn; SS override
 16697 000025D7 368B3E[B205]            	MOV	DI,[SS:WFP_START] ; ES:DI -> WFP
 16698 000025DC 89DE                    	MOV	SI,BX
 16699                                  
 16700                                  ;hkn; SS override
 16701 000025DE 368E1E[E405]            	MOV	DS,[SS:CURBUF+2] ; DS:SI -> entry (FCB style name)
 16702 000025E3 89FB                    	MOV	BX,DI		; Set backup limit for skipback
 16703                                  	;ADD	BX,2		; Skip over d: to point to leading '\'
 16704                                  	; 31/01/2024
 16705 000025E5 43                      	inc	bx
 16706 000025E6 43                      	inc	bx
 16707 000025E7 E8DFEB                  	call	StrLen		; CX is length of ES:DI including NUL
 16708 000025EA 49                      	DEC	CX		; Don't include nul in count
 16709 000025EB 01CF                    	ADD	DI,CX		; Point to NUL at end of string
 16710 000025ED E89C45                  	call	SkipBack	; Back up one element
 16711 000025F0 47                      	INC	DI		; Point to start of last element
 16712                                  
 16713                                  	; 17/05/2019 - Retro DOS v4.0
 16714                                  ;hkn; SS override
 16715                                  	; MSDOS 6.0
 16716 000025F1 36893E[0106]            	MOV	[SS:SAVE_BX],DI	;IFS. save for DOS_RENAME   ;AN000;
 16717                                  	;
 16718 000025F6 E85FFA                  	call	PackName	; Transfer name from entry to ASCIZ tail.
 16719 000025F9 5E                      	POP	SI		; Get back entry pointers
 16720 000025FA 5B                      	POP	BX
 16721 000025FB 53                      	PUSH	BX
 16722 000025FC 56                      	PUSH	SI		; Back on stack
 16723                                  	
 16724 000025FD 16                      	push	ss
 16725 000025FE 1F                      	pop	ds
 16726                                  
 16727                                  ;hkn; context DS will assume ES to DOSDATA
 16728                                  ;hkn; ASSUME	DS:DOSGROUP
 16729                                  
 16730                                  ; Close the file if possible by us.
 16731                                  ;
 16732                                  ;if installed
 16733 000025FF FF1E[C400]              	Call	far [JShare+(13*4)] ; 13 = ShCloseFile
 16734                                  ;else
 16735                                  ;	Call	ShCloseFile
 16736                                  ;endif
 16737 00002603 8C1E[A005]              	MOV	[THISSFT+2],DS
 16738                                  
 16739                                  ;hkn; AUXSTACK is in DOSDATA
 16740 00002607 C706[9E05][6507]        	MOV	word [THISSFT],AUXSTACK-SF_ENTRY.size  ; RENAMEDMA+(384-59)
 16741                                  				; Scratch space
 16742 0000260D 30E4                    	XOR	AH,AH		; Indicate file to DOOPEN (high bit off)
 16743 0000260F E8BE23                  	call	DOOPEN		; Fill in SFT for share check
 16744 00002612 C43E[9E05]              	LES	DI,[THISSFT]
 16745                                  	;mov	word [es:di+2],10h
 16746 00002616 26C745021000            	MOV	word [ES:DI+SF_ENTRY.sf_mode],SHARING_DENY_BOTH ; 10h
 16747                                  				; requires exclusive access
 16748                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],1 ; Pretend open
 16749 0000261C 26C7050100              	mov	word [ES:DI],1
 16750 00002621 E84F4B                  	call	ShareEnter
 16751 00002624 720D                    	jc	short CheckDone
 16752 00002626 C43E[9E05]              	LES	DI,[THISSFT]
 16753                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],0
 16754 0000262A 26C7050000              	mov	word [ES:DI],0	; Pretend closed and free
 16755                                  	
 16756 0000262F E83C4B                  	call	ShareEnd	; Tell sharer we're done with THISSFT
 16757 00002632 F8                      	CLC
 16758                                  CheckDone:
 16759 00002633 C42E[8A05]              	LES	BP,[THISDPB]
 16760 00002637 5E                      	POP	SI
 16761 00002638 5B                      	POP	BX
 16762 00002639 58                      	POP	AX
 16763 0000263A 5F                      	POP	DI
 16764 0000263B 1F                      	POP	DS
 16765 0000263C C3                      	retn
 16766                                  
 16767                                  ;Break	<FastOpen_Delete - delete dir info in fastopen>
 16768                                  ;---------------------------------------------------------------------------
 16769                                  ; Procedure Name : FastOpen_Delete
 16770                                  ; Inputs:
 16771                                  ;	None
 16772                                  ; Function:
 16773                                  ;	Call FastOpen to delete the dir info.
 16774                                  ; Outputs:
 16775                                  ;	None
 16776                                  ;---------------------------------------------------------------------------
 16777                                  
 16778                                  	; 31/01/2024
 16779                                  
 16780                                  FastOpen_Delete:
 16781 0000263D 9C                      	PUSHF			; save flag
 16782 0000263E 56                      	PUSH	SI		; save registers
 16783 0000263F 57                      	push	di ; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 16784 00002640 53                      	PUSH	BX
 16785 00002641 50                      	PUSH	AX
 16786                                  	;mov	si,[WFP_START] ; MSDOS 3.3
 16787                                  ;hkn; SS override
 16788                                  	; 17/05/2019 - Retro DOS v4.0
 16789                                  	; MSDOS 6.0
 16790 00002642 368B36[B205]            	MOV	SI,[ss:WFP_START] ; ds:si points to path name
 16791                                  	
 16792 00002647 B003                    	MOV	AL,FONC_delete	; al = 3
 16793                                  
 16794                                  ; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 16795                                  %if 0 
 16796                                  fastinvoke:
 16797                                  ;hkn; FastTable is in DOSDATA
 16798                                  	MOV	BX,FastTable+2
 16799                                  	CALL	far [BX]	; call fastopen
 16800                                  	POP	AX		; restore registers
 16801                                  	POP	BX
 16802                                  	;pop	di ; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 16803                                  	POP	SI
 16804                                  	POPF			; restore flag
 16805                                  	retn
 16806                                  %else
 16807 00002649 EB0F                    	jmp	short fastinvoke ; 31/01/2024
 16808                                  %endif
 16809                                  
 16810                                  	; 13/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16811                                  	; DOSCODE:65A0h (MSDOS 5.0 MSDOS.SYS)
 16812                                  
 16813                                  	; 31/01/2024 Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 16814                                  	; DOSCODE:65B4h (MSDOS 6.22 MSDOS.SYS)
 16815                                  	; DOSCODE:6D07h (PCDOS 7.1 IBMDOS.COM)
 16816                                  
 16817                                  ;Break	<FastOpen_Rename - Rename directory>	   ; PTR 5622
 16818                                  ;---------------------------------------------------------------------------
 16819                                  ; PROCEDURE Name : FastOpen_Rename
 16820                                  ;
 16821                                  ; Inputs:
 16822                                  ;	 REN_WFP   = Path Name
 16823                                  ;	 NAME1	   = New Name
 16824                                  ; Function:
 16825                                  ;	Call FastOpen to rename the dir entry in the cache
 16826                                  ; Outputs:
 16827                                  ;	None
 16828                                  ;---------------------------------------------------------------------------
 16829                                  
 16830                                  FastOpen_Rename:
 16831                                  	; 17/05/2019 - Retro DOS v4.0
 16832                                  	; 08/08/2018 - Retro DOS v3.0
 16833                                  	; MSDOS 6.0
 16834 0000264B 9C                      	PUSHF			;AN001 save flag
 16835 0000264C 56                      	PUSH	SI		;AN001 save registers
 16836 0000264D 57                      	PUSH	DI		;AN001
 16837 0000264E 53                      	PUSH	BX		;AN001
 16838 0000264F 50                      	PUSH	AX		;AN001
 16839                                  	;
 16840                                  ;hkn; SS override
 16841 00002650 368B36[B405]            	MOV	SI,[SS:REN_WFP]	;AN001	;;AN001  ds:si-->Path name addrs
 16842                                  
 16843                                  ;hkn; NAME1 is in DOSDATA
 16844 00002655 BF[4B05]                	MOV	DI,NAME1	;;AN001  ds:di-->New name addrs
 16845                                  	;mov	al,6
 16846 00002658 B006                    	MOV	AL,FONC_Rename	;;AN001  al = 6
 16847                                  
 16848                                  fastinvoke:	; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 16849                                  	
 16850                                  ;hkn; FastTable is in DOSDATA
 16851 0000265A BB[320D]                	MOV	BX,FastTable+2
 16852 0000265D FF1F                    	CALL	far [BX]	;;AN001  call fastopen
 16853                                  	
 16854 0000265F 58                      	POP	AX		; restore registers  ;AN001
 16855 00002660 5B                      	POP	BX				     ;AN001
 16856 00002661 5F                      	POP	DI				     ;AN001
 16857 00002662 5E                      	POP	SI				     ;AN001
 16858 00002663 9D                      	POPF			; restore flag	     ;AN001
 16859 00002664 C3                      	retn					     ;AN001
 16860                                  
 16861                                  ;Break	<FastOpen_Update - update dir info in fastopen>
 16862                                  ;---------------------------------------------------------------------------
 16863                                  ; Procedure Name : FastOpen_Update
 16864                                  ;
 16865                                  ; Inputs:
 16866                                  ;	DL     drive number (A=0,B=1,,,)
 16867                                  ;	CX     first cluster #
 16868                                  ;	AH     0 updates dir entry
 16869                                  ;	       1 updates CLUSNUM , BP = new CLUSNUM
 16870                                  ;	ES:DI  directory entry
 16871                                  ; Function:
 16872                                  ;	Call FastOpen to update the dir info.
 16873                                  ; Outputs:
 16874                                  ;	None
 16875                                  ;---------------------------------------------------------------------------
 16876                                  
 16877                                  FastOpen_Update:
 16878 00002665 9C                      	PUSHF			; save flag
 16879 00002666 56                      	PUSH	SI
 16880 00002667 57                      	push	di ; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 16881 00002668 53                      	PUSH	BX		; save regs
 16882 00002669 50                      	PUSH	AX
 16883 0000266A B004                    	MOV	AL,FONC_update	; al = 4
 16884 0000266C EBEC                    	JMP	short fastinvoke
 16885                                  
 16886                                  	; 17/05/2019
 16887                                  
 16888                                  	; MSDOS 6.0
 16889                                  ;entry Fast_Dispatch		; future fastxxxx entry	;AN000;
 16890                                  ;---------------------------------------------------------------------------
 16891                                  Fast_Dispatch:
 16892                                  ;hkn; FastTable is in DOSDATA
 16893 0000266E BE[320D]                	MOV	SI,FastTable+2	; index to the	     ;AN000;
 16894                                  ;hkn; use SS override
 16895 00002671 36FF1C                  	CALL	far [SS:SI]	; RMFD call fastopen
 16896 00002674 C3                      	retn
 16897                                  
 16898                                  ;============================================================================
 16899                                  ; RENAME.ASM, MSDOS 6.0, 1991
 16900                                  ;============================================================================
 16901                                  ; 08/08/2018 - Retro DOS v3.0
 16902                                  ; 17/05/2019 - Retro DOS v4.0
 16903                                  
 16904                                  ;	TITLE	DOS_RENAME - Internal RENAME call for MS-DOS
 16905                                  ;	NAME	DOS_RENAME
 16906                                  
 16907                                  ;**	Low level routine for renaming files
 16908                                  ;----------------------------------------------------------------------------
 16909                                  ;	DOS_RENAME
 16910                                  ;
 16911                                  ;	Modification history:
 16912                                  ;
 16913                                  ;	    Created: ARR 30 March 1983
 16914                                  
 16915                                  ;----------------------------------------------------------------------------
 16916                                  ;
 16917                                  ; Procedure Name : DOS_RENAME
 16918                                  ;
 16919                                  ; Inputs:
 16920                                  ;	[WFP_START] Points to SOURCE WFP string ("d:/" must be first 3
 16921                                  ;		chars, NUL terminated)
 16922                                  ;	[CURR_DIR_END] Points to end of Current dir part of string [SOURCE]
 16923                                  ;		( = -1 if current dir not involved, else
 16924                                  ;		 Points to first char after last "/" of current dir part)
 16925                                  ;	[REN_WFP] Points to DEST WFP string ("d:/" must be first 3
 16926                                  ;		chars, NUL terminated)
 16927                                  ;	[THISCDS] Points to CDS being used
 16928                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 16929                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 16930                                  ; Function:
 16931                                  ;	Rename the specified file(s)
 16932                                  ;	NOTE: This routine uses most of AUXSTACK as a temp buffer.
 16933                                  ; Outputs:
 16934                                  ;	CARRY CLEAR
 16935                                  ;	    OK
 16936                                  ;	CARRY SET
 16937                                  ;	    AX is error code
 16938                                  ;		error_file_not_found
 16939                                  ;			No match for source, or dest path invalid
 16940                                  ;		error_not_same_device
 16941                                  ;			Source and dest are on different devices
 16942                                  ;		error_access_denied
 16943                                  ;			Directory specified (not simple rename),
 16944                                  ;			Device name given, Destination exists.
 16945                                  ;			NOTE: In third case some renames may have
 16946                                  ;			 been done if metas.
 16947                                  ;		error_path_not_found
 16948                                  ;			Bad path (not in curr dir part if present)
 16949                                  ;			SOURCE ONLY
 16950                                  ;		error_bad_curr_dir
 16951                                  ;			Bad path in current directory part of path
 16952                                  ;			SOURCE ONLY
 16953                                  ;		error_sharing_violation
 16954                                  ;			Deny both access required, generates an INT 24.
 16955                                  ; DS preserved, others destroyed
 16956                                  ;
 16957                                  ;----------------------------------------------------------------------------
 16958                                  
 16959                                  	; 14/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16960                                  
 16961                                  	; 31/01/2024
 16962                                  
 16963                                  DOS_RENAME:
 16964                                  
 16965                                  ;hkn; DOS_RENAME is called from file.asm and fcbio.asm. DS has been set up
 16966                                  ;hkn; at this point to DOSDATA.
 16967                                  
 16968 00002675 E8B1EB                  	call	TestNet
 16969 00002678 7306                    	JNC	short LOCAL_RENAME
 16970                                  
 16971                                  ;IF NOT Installed
 16972                                  ;	transfer NET_RENAME
 16973                                  ;ELSE
 16974                                  	;MOV	AX,(MultNET SHL 8) OR 17
 16975                                  	;INT	2FH
 16976                                  	;return
 16977                                  
 16978 0000267A B81111                  	mov     ax, 1111h
 16979 0000267D CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
 16980                                  			; SS = DS = DOS CS, 
 16981                                  			; SDA first filename pointer = offset of fully-qualified old name
 16982                                  			; SDA CDS pointer -> current directory
 16983                                  			; Return: CF set on error
 16984 0000267F C3                      	retn
 16985                                  ;ENDIF
 16986                                  
 16987                                  LOCAL_RENAME:
 16988 00002680 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 16989 00002685 8B36[B205]              	MOV	SI,[WFP_START]
 16990 00002689 8B3E[B405]              	MOV	DI,[REN_WFP]
 16991 0000268D 8A04                    	MOV	AL,[SI]
 16992 0000268F 8A25                    	MOV	AH,[DI]
 16993 00002691 0D2020                  	OR	AX,2020H		; Lower case
 16994 00002694 38E0                    	CMP	AL,AH
 16995 00002696 7405                    	JZ	short SAMEDRV
 16996 00002698 B81100                  	MOV	AX,error_not_same_device ; 11h
 16997 0000269B F9                      	STC
 16998 0000269C C3                      	retn
 16999                                  
 17000                                  SAMEDRV:
 17001 0000269D FF36[2E03]              	PUSH	WORD [DMAADD+2]
 17002 000026A1 FF36[2C03]              	PUSH	WORD [DMAADD]
 17003 000026A5 8C1E[2E03]              	MOV	[DMAADD+2],DS
 17004                                  
 17005                                  ;hkn; RENAMEDMA is in DOSDATA
 17006 000026A9 C706[2C03][2006]        	MOV	WORD [DMAADD],RENAMEDMA
 17007 000026AF C606[7005]00            	MOV	byte [FOUND_DEV],0	; Rename fails on DEVS, assume not a dev
 17008 000026B4 E82BEC                  	call	ECritDisk
 17009 000026B7 E8CA05                  	call	DOS_SEARCH_FIRST	; Sets [NoSetDir] to 1, [CURBUF+2]:BX
 17010                                  					;    points to entry
 17011 000026BA 7314                    	JNC	short Check_Dev
 17012 000026BC 83F812                  	CMP	AX,error_no_more_files ; 12h
 17013 000026BF 7503                    	JNZ	short GOTERR
 17014 000026C1 B80200                  	MOV	AX,error_file_not_found ; 2
 17015                                  GOTERR:
 17016 000026C4 F9                      	STC
 17017                                  RENAME_POP:
 17018 000026C5 8F06[2C03]              	POP	WORD [DMAADD]
 17019 000026C9 8F06[2E03]              	POP	WORD [DMAADD+2]
 17020                                  	;call	LCritDisk
 17021                                  	;retn
 17022                                  	; 16/12/2022
 17023 000026CD E92DEC                  	jmp	LCritDisk
 17024                                  
 17025                                  Check_Dev:
 17026                                  	; 17/05/2019 - Retro DOS v4.0
 17027                                  	;mov	ax,5
 17028 000026D0 B80500                  	MOV	AX,error_access_denied	; Assume error
 17029                                  	
 17030                                  	; MSDOS 6.0
 17031 000026D3 1E                      	PUSH	DS			      ;PTM.			    ;AN000;
 17032 000026D4 C536[2C03]              	LDS	SI,[DMAADD]		      ;PTM.  check if source a dir  ;AN000;
 17033                                  	;add	si,21
 17034 000026D8 83C615                  	ADD	SI,find_buf.attr	      ;PTM.			    ;AN000;
 17035                                  	;test	byte [si+11],10h
 17036 000026DB F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;PTM.	    ;AN000;
 17037 000026DF 7407                    	JZ	short notdir		      ;PTM.			    ;AN000;
 17038 000026E1 8B36[B405]              	MOV	SI,[REN_WFP]		      ;PTM.  if yes, make sure path ;AN000;
 17039 000026E5 E8ECFA                  	call	Check_PathLen2		      ;PTM.   length < 67	    ;AN000;
 17040                                  notdir:
 17041 000026E8 1F                      	POP	DS			      ;PTM.			    ;AN000;
 17042 000026E9 77D9                    	JA	short GOTERR		      ;PTM.			    ;AN000;
 17043                                  
 17044                                  	; MSDOS 3.3 & MSDOS 6.0
 17045 000026EB 803E[7005]00            	CMP	byte [FOUND_DEV],0
 17046 000026F0 75D2                    	JNZ	short GOTERR
 17047                                  
 17048                                  ; At this point a source has been found. There is search continuation info (a
 17049                                  ; la DOS_SEARCH_NEXT) for the source at RENAMEDMA, together with the first
 17050                                  ; directory entry found.
 17051                                  ; [THISCDS], [THISDPB], and [THISDRV] are set and will remain correct
 17052                                  ; throughout the RENAME since it is known at this point that the source and
 17053                                  ; destination are both on the same device.
 17054                                  ; [SATTRIB] is also set.
 17055                                  
 17056 000026F2 89DE                    	MOV	SI,BX
 17057                                  	;add	si,26
 17058 000026F4 83C61A                  	ADD	SI,dir_entry.dir_first
 17059 000026F7 E8D6FE                  	call	REN_DEL_Check
 17060 000026FA 7305                    	JNC	short REN_OK1
 17061 000026FC B82000                  	MOV	AX,error_sharing_violation  ; 20h
 17062 000026FF EBC4                    	JMP	short RENAME_POP
 17063                                  
 17064                                  ;------------------------------------------------------------------------------
 17065                                  ; Check if the source is a file or directory. If file, delete the entry
 17066                                  ; from the Fastopen cache. If directory, rename it later
 17067                                  ;------------------------------------------------------------------------------
 17068                                  
 17069                                  REN_OK1:				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 17070                                  	; MSDOS 6.0
 17071                                  	; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 17072                                  	;PUSH	SI
 17073 00002701 C536[2C03]              	LDS	SI,[DMAADD]		;BN00X; PTM. check if source a dir ;AN000;
 17074                                  	;add	si,21
 17075 00002705 83C615                  	ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
 17076                                  	;test	byte [si+11],10h
 17077 00002708 F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM. ;AN000;
 17078                                  	;JZ	short NOT_DIR1		;;BN00XPTM.			;AN000;
 17079 0000270C 7503                    	jnz	short SWAP_SOURCE ; 31/01/2024
 17080                                  	;POP	SI			;BN00X
 17081                                  	;JMP	SHORT SWAP_SOURCE	;BN00X
 17082                                  ;NOT_DIR1:				;;BN00X it is a file, delete the entry
 17083                                  	;POP	SI
 17084                                  
 17085                                  	; MSDOS 3.3 (& MSDOS 6.0)
 17086 0000270E E82CFF                  	call	FastOpen_Delete 	; delete dir info in fastopen DOS 3.3
 17087                                  SWAP_SOURCE:
 17088                                  	; MSDOS 3.3
 17089                                  	;MOV	SI,[REN_WFP]
 17090                                  	;MOV	[WFP_START],SI
 17091                                  	; MSDOS 6.0
 17092 00002711 A1[B205]                	MOV	AX,[WFP_START]		; Swap source and destination
 17093 00002714 8B36[B405]              	MOV	SI,[REN_WFP]		; Swap source and destination
 17094 00002718 8936[B205]              	MOV	[WFP_START],SI		; WFP_START = Destination path
 17095 0000271C A3[B405]                	MOV	[REN_WFP],AX		; REN_WFP   = Source path
 17096                                  	; MSDOS 3.3 (& MSDOS 6.0)
 17097 0000271F C706[B605]FFFF          	MOV	word [CURR_DIR_END],-1	; No current dir on dest
 17098                                  	;mov	word [CREATING],0E5FFh
 17099 00002725 C706[7E05]FFE5          	MOV	WORD [CREATING],DIRFREE*256+0FFh  ; Creating, not DEL *.*
 17100                                  					; A rename is like a CREATE_NEW as far
 17101                                  					; as the destination is concerned.
 17102 0000272B E8BD16                  	call	GetPathNoSet
 17103                                  
 17104                                  ;   If this GETPATH fails due to file not found, we know all renames will work
 17105                                  ;   since no files match the destination name. If it fails for any other
 17106                                  ;   reason, the rename fails on a path not found, or whatever (also fails if
 17107                                  ;   we find a device or directory). If the GETPATH succeeds, we aren't sure
 17108                                  ;   if the rename should fail because we haven't built an explicit name by
 17109                                  ;   substituting for the meta chars in it. In this case the destination file
 17110                                  ;   spec with metas is in [NAME1] and the explicit source name is at RENAMEDMA
 17111                                  ;   in the directory entry part.
 17112                                  	
 17113 0000272E 7223                    	JC	short NODEST
 17114                                  	
 17115                                  	; MSDOS 6.0
 17116                                  	;JZ	short BAD_ACC 		; Dest string is a directory	;AC000;
 17117                                  	; !! MSDOS 3.3 !!
 17118                                  	;JZ	short BAD_ACC ; !!	; Dest string is a directory
 17119                                  
 17120 00002730 08E4                    	OR	AH,AH			; Device?
 17121 00002732 792C                    	JNS	short SAVEDEST		; No, continue
 17122                                  BAD_ACC:
 17123 00002734 B80500                  	MOV	AX,error_access_denied
 17124 00002737 F9                      	STC
 17125                                  RENAME_CLEAN:
 17126 00002738 9C                      	PUSHF				; Save carry state
 17127 00002739 50                      	PUSH	AX			; and error code (if carry set)
 17128 0000273A A0[7605]                	MOV	AL,[THISDRV]
 17129 0000273D E87531                  	call	FLUSHBUF
 17130 00002740 58                      	POP	AX
 17131 00002741 803E[4A03]00            	CMP	byte [FAILERR],0
 17132 00002746 7504                    	JNZ	short BAD_ERR		; User FAILed to I 24
 17133 00002748 9D                      	POPF
 17134 00002749 E979FF                  	JMP	RENAME_POP
 17135                                  
 17136                                  BAD_ERR:
 17137 0000274C 58                      	POP	AX			; Saved flags
 17138                                  	; 16/12/202
 17139                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17140                                  BAD_PATH: ; *
 17141 0000274D B80300                  	MOV	AX,error_path_not_found
 17142 00002750 E971FF                  	JMP	GOTERR
 17143                                  
 17144                                  NODEST:
 17145 00002753 75F8                    	JNZ	short BAD_PATH
 17146 00002755 803E[4A03]00            	CMP	byte [FAILERR],0
 17147 0000275A 75F1                    	JNZ	short BAD_PATH		; Search for dest failed 
 17148                                  					; because user FAILed on I 24
 17149                                  	; 14/11/2022
 17150 0000275C 08C9                    	OR	CL,CL
 17151                                  	;JNZ	short SAVEDEST
 17152                                  	; 17/05/2019
 17153 0000275E 74ED                    	jz	short BAD_PATH ; *
 17154                                  ;BAD_PATH: ; *
 17155                                  ;	MOV	AX,error_path_not_found
 17156                                  ;	;STC
 17157                                  ;	;JMP	RENAME_POP
 17158                                  ;	; 17/05/2019
 17159                                  ;	jmp	GOTERR 
 17160                                  
 17161                                  ; 16/12/2022
 17162                                  %if 0
 17163                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17164                                  	or	cl,cl
 17165                                  	jnz	short SAVEDEST
 17166                                  	;jz	short BAD_PATH ; *
 17167                                  BAD_PATH: ; *
 17168                                  	;mov	ax,3
 17169                                  	mov	ax,error_path_not_found
 17170                                  	stc
 17171                                  	jmp	RENAME_POP
 17172                                  %endif
 17173                                  
 17174                                  SAVEDEST:
 17175 00002760 16                      	push	ss
 17176 00002761 07                      	pop	es
 17177                                  
 17178                                  ;hkn; NAME1 & NAME2 is in DOSDATA
 17179 00002762 BF[5705]                	MOV	DI,NAME2
 17180 00002765 BE[4B05]                	MOV	SI,NAME1
 17181                                  
 17182 00002768 B90B00                  	MOV	CX,11
 17183 0000276B F3A4                    	REP	MOVSB			; Save dest with metas at NAME2
 17184 0000276D A1[C205]                	MOV	AX,[DIRSTART]
 17185 00002770 A3[6405]                	MOV	[DESTSTART],AX
 17186                                  BUILDDEST:
 17187                                  	; 31/01/2024
 17188                                  	;push	ss
 17189                                  	;pop	es			; needed due to JMP BUILDDEST below
 17190                                  
 17191                                  ;hkn; RENAMEDMA, NAME1, NAME2 in DOSDATA
 17192 00002773 BB[3506]                	MOV	BX,RENAMEDMA+21		; Source of replace chars
 17193 00002776 BF[4B05]                	MOV	DI,NAME1		; Real dest name goes here
 17194 00002779 BE[5705]                	MOV	SI,NAME2		; Raw dest
 17195                                  
 17196 0000277C B90B00                  	MOV	CX,11
 17197                                  
 17198                                  	; 17/05/2019 - Retro DOS v4.0
 17199                                  	
 17200                                  	; MSDOS 6.0
 17201 0000277F E8F900                  	CALL	NEW_RENAME		;IFS. replace ? chars	;AN000;
 17202                                  
 17203                                  	; MSDOS 3.3
 17204                                  
 17205                                  ; 08/08/2018 - Retro DOS v3.0
 17206                                  ; MSDOS 6.0 
 17207                                  ;---------------------------------------------------------------------------
 17208                                  ;Procedure: NEW_RENAME
 17209                                  ;
 17210                                  ;Input: DS:SI -> raw string with ?
 17211                                  ;	ES:DI -> destination string
 17212                                  ;	DS:BX -> source string
 17213                                  ;Function: replace ? chars of raw string with chars in source string and
 17214                                  ;	   put in destination string
 17215                                  ;Output: ES:DI-> new string
 17216                                  ;---------------------------------------------------------------------------
 17217                                  ;
 17218                                  ;NEW_RENAME:
 17219                                  ;NEWNAM:
 17220                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 341Ah
 17221                                  ;	LODSB
 17222                                  ;	CMP	AL,"?"
 17223                                  ;	JNZ	short NOCHG
 17224                                  ;	MOV	AL,[BX] 		; Get replace char
 17225                                  ;NOCHG:
 17226                                  ;	STOSB
 17227                                  ;	INC	BX			; Next replace char
 17228                                  ;	LOOP	NEWNAM
 17229                                  ;	; MSDOS 6.0
 17230                                  ;	;retn
 17231                                  
 17232                                  	; MSDOS 3.3 & MSDOS 6.0
 17233                                  	;mov	byte [ATTRIB],16h
 17234 00002782 C606[6B05]16            	MOV	byte [ATTRIB],attr_all	; Stop duplicates with any attributes
 17235 00002787 C606[7E05]FF            	MOV	byte [CREATING],0FFH
 17236 0000278C E8EE18                  	call	DEVNAME 		; Check if we built a device name
 17237 0000278F 73A3                    	JNC	short BAD_ACC
 17238 00002791 8B1E[6405]              	MOV	BX,[DESTSTART]
 17239 00002795 C42E[8A05]              	LES	BP,[THISDPB]
 17240 00002799 E8EC15                  	call	SETDIRSRCH		; Reset search to start of dir
 17241 0000279C 7296                    	JC	short BAD_ACC 		; Screw up
 17242 0000279E E8AD14                  	call	FINDENTRY		; See if new name already exists
 17243 000027A1 7391                    	JNC	short BAD_ACC 		; Error if found
 17244 000027A3 803E[4A03]00            	CMP	byte [FAILERR],0
 17245 000027A8 752A                    	JNZ	short BAD_ACCJ		; Find failed because user FAILed to I 24
 17246 000027AA A1[6405]                	MOV	AX,[DESTSTART]		; DIRSTART of dest
 17247 000027AD 3B06[2F06]              	CMP	AX,[RENAMEDMA+15]	; DIRSTART of source
 17248 000027B1 7451                    	JZ	short SIMPLE_RENAME	; If =, just give new name
 17249                                  
 17250                                  	;mov	al,[RENAMEDMA+32]
 17251 000027B3 A0[4006]                	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr]
 17252 000027B6 A810                    	TEST	AL,attr_directory ; 10h
 17253 000027B8 751A                    	JNZ	short BAD_ACCJ		; Can only do a simple rename on dirs,
 17254                                  					; otherwise the . and .. entries get
 17255                                  					; wiped.
 17256 000027BA A2[6B05]                	MOV	[ATTRIB],AL
 17257 000027BD 8C1E[A005]              	MOV	[THISSFT+2],DS
 17258                                  
 17259                                  ;hkn; AUXSTACK is in DOSDATA
 17260                                  	;mov	si,RENAMEDMA+145h
 17261 000027C1 BE[6507]                	MOV	SI,AUXSTACK-SF_ENTRY.size  ; RENAMEDMA+325
 17262 000027C4 8936[9E05]              	MOV	[THISSFT],SI
 17263                                  	;mov	word [SI+2],2
 17264 000027C8 C744020200              	MOV	word [SI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 17265 000027CD 31C9                    	XOR	CX,CX			; Set "device ID" for call into makenode
 17266 000027CF E87320                  	call	RENAME_MAKE		; This is in mknode
 17267 000027D2 7303                    	JNC	short GOT_DEST
 17268                                  BAD_ACCJ:
 17269 000027D4 E95DFF                  	JMP	BAD_ACC
 17270                                  
 17271                                  GOT_DEST:
 17272 000027D7 53                      	push	bx
 17273 000027D8 C43E[9E05]              	LES	DI,[THISSFT]		; RENAME_MAKE entered this into sharing
 17274 000027DC E88F49                  	call	ShareEnd		; we need to remove it.
 17275 000027DF 5B                      	pop	bx
 17276                                  
 17277                                  ; A zero length entry with the correct new name has now been made at
 17278                                  ;   [CURBUF+2]:BX.
 17279                                  
 17280 000027E0 C43E[E205]              	LES	DI,[CURBUF]
 17281                                  
 17282                                  ; 07/07/2024 - Retro DOS v4.2
 17283                                  %if 0
 17284                                  	; MSDOS 6.0
 17285                                  	;test	byte [es:di+5],40h
 17286                                  	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 17287                                  					;LB. if already dirty		  ;AN000;
 17288                                  	JNZ	short yesdirty1		;LB.  don't increment dirty count ;AN000;
 17289                                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 17290                                  	;or	byte [es:di+5],40h
 17291                                  	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 17292                                  yesdirty1:
 17293                                  %else
 17294                                  	; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 17295 000027E4 E8D031                  	call	SET_BUF_DIRTY
 17296                                  %endif
 17297 000027E7 89DF                    	MOV	DI,BX
 17298                                  	;add	di,11
 17299 000027E9 83C70B                  	ADD	DI,dir_entry.dir_attr	; Skip name
 17300                                  
 17301                                  ;hkn; RENAMEDMA is in DOSDATA
 17302                                  	;mov	si,RENAMEDMA+32 ; 05/07/2024
 17303 000027EC BE[4006]                	MOV	SI,RENAMEDMA+21+dir_entry.dir_attr
 17304                                  	;mov	cx,21
 17305 000027EF B91500                  	MOV	CX,dir_entry.size-dir_entry.dir_attr
 17306 000027F2 F3A4                    	REP	MOVSB
 17307 000027F4 E86E00                  	CALL	GET_SOURCE
 17308 000027F7 7269                    	JC	short RENAME_OVER
 17309 000027F9 89DF                    	MOV	DI,BX
 17310 000027FB 8E06[E405]              	MOV	ES,[CURBUF+2]
 17311 000027FF B0E5                    	MOV	AL,DIRFREE ; 0E5h
 17312 00002801 AA                      	STOSB				; "free" the source
 17313 00002802 EB13                    	JMP	SHORT DIRTY_IT
 17314                                  
 17315                                  SIMPLE_RENAME:
 17316 00002804 E85E00                  	CALL	GET_SOURCE		; Get the source back
 17317 00002807 7259                    	JC	short RENAME_OVER
 17318 00002809 89DF                    	MOV	DI,BX
 17319 0000280B 8E06[E405]              	MOV	ES,[CURBUF+2]
 17320                                  
 17321                                  ;hkn; NAME1 is in DOSDATA
 17322 0000280F BE[4B05]                	MOV	SI,NAME1		; New Name
 17323 00002812 B90B00                  	MOV	CX,11
 17324 00002815 F3A4                    	REP	MOVSB
 17325                                  DIRTY_IT:
 17326 00002817 8B3E[E205]              	MOV	DI,[CURBUF]
 17327                                  
 17328                                  ; 07/07/2024 - Retro DOS v4.2
 17329                                  %if 0
 17330                                  	; MSDOS 6.0
 17331                                  	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 17332                                  					;LB. if already dirty		  ;AN000;
 17333                                  	JNZ	short yesdirty2		;LB.  don't increment dirty count ;AN000;
 17334                                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 17335                                  	
 17336                                  	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 17337                                  %else
 17338                                  	; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 17339 0000281B E89931                  	call	SET_BUF_DIRTY
 17340                                  %endif
 17341                                  
 17342                                  ;------------------------------------------------------------------------------
 17343                                  ; Check if the source is a directory of file. If directory rename it to the
 17344                                  ; the new name in the Fastopen cache buffer. If file name it has been
 17345                                  ; previously deleted.
 17346                                  ;------------------------------------------------------------------------------
 17347                                  
 17348                                  ;yesdirty2:
 17349                                  	; MSDOS 6.0
 17350 0000281E 56                      	PUSH	SI
 17351 0000281F C536[2C03]              	LDS	SI,[DMAADD]		;;BN00XPTM. chek if source a dir ;AN000;
 17352 00002823 83C615                  	ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
 17353 00002826 F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM.	;AN000;
 17354 0000282A 7403                    	JZ	short NOT_DIR2		;;BN00XPTM.			;AN000;
 17355 0000282C E81CFE                  	call	FastOpen_Rename		;;BN00X rename dir entry in fastopen
 17356                                  	; 31/01/2024
 17357                                  	;POP	SI
 17358                                  	;JMP	SHORT NOT_DIRTY1
 17359                                  NOT_DIR2:				;;BN00X it is a file, delete the entry
 17360 0000282F 5E                      	POP	SI
 17361                                  NOT_DIRTY1:				;;BN00X
 17362                                  NEXT_SOURCE:
 17363                                  ;hkn; RENAMEDMA is in DOSDATA
 17364 00002830 BE[2106]                	MOV	SI,RENAMEDMA+1		;Name
 17365                                  
 17366                                  ; WARNING! Rename_Next leaves the disk critical section *ALWAYS*. We need
 17367                                  ; to enter it before going to RENAME_Next.
 17368                                  
 17369 00002833 E8ACEA                  	call	ECritDisk
 17370 00002836 C606[7E05]00            	MOV	byte [CREATING],0 ; Correct setting for search (we changed it
 17371                                  				  ;  to FF when we made the prev new file).
 17372 0000283B E88705                  	call	RENAME_NEXT
 17373                                  
 17374                                  ; Note, now, that we have exited the previous ENTER and so are back to where
 17375                                  ; we were before.
 17376                                  
 17377 0000283E 7222                    	JC	short RENAME_OVER
 17378                                  
 17379                                  	;lea	si,[bx+26]
 17380 00002840 8D771A                  	LEA	SI,[BX+dir_entry.dir_first]
 17381 00002843 E88AFD                  	call	REN_DEL_Check
 17382 00002846 7306                    	JNC	short REN_OK2
 17383 00002848 B82000                  	MOV	AX,error_sharing_violation ; 20h
 17384                                  jmp_to_rename_clean: ; 28/12/2022
 17385 0000284B E9EAFE                  	JMP	RENAME_CLEAN ; 10/08/2018
 17386                                  
 17387                                  ;------------------------------------------------------------------------------
 17388                                  ; Check if file or directory. If file, delete file from the Fastopen cache,
 17389                                  ; if directory, rename directory name in the Fastopen cache.
 17390                                  ;-----------------------------------------------------------------------------
 17391                                  
 17392                                  REN_OK2:
 17393                                  	; MSDOS 6.0
 17394                                  	;mov	al,[RENAMEDMA+32]
 17395 0000284E A0[4006]                	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr] ; PTR P5622
 17396                                  	;test	al,10h
 17397 00002851 A810                    	TEST	AL,attr_directory	;;BN00X directory
 17398 00002853 7408                    	JZ	short Ren_Directory	;;BN00X no - file, delete it
 17399                                  	
 17400                                  	; MSDOS 3.3 & MSDOS 6.0
 17401 00002855 E8E5FD                  	call	FastOpen_Delete 	;;BN00X delete dir info in fastopen DOS 3.3
 17402                                  jmp_to_builddest: ; 28/12/2022
 17403                                  	; 31/01/2024
 17404 00002858 16                      	push	ss
 17405 00002859 07                      	pop	es
 17406 0000285A E916FF                  	JMP	BUILDDEST		;;BN00X
 17407                                  
 17408                                  	; MSDOS 6.0
 17409                                  Ren_Directory:
 17410 0000285D E8EBFD                  	call	FastOpen_Rename 	;;BN00X delete dir info in fastopen DOS 3.3
 17411                                  	;JMP	BUILDDEST
 17412                                  	; 28/12/2022
 17413 00002860 EBF6                    	jmp	short jmp_to_builddest
 17414                                  
 17415                                  RENAME_OVER:
 17416 00002862 F8                      	CLC
 17417                                  	;JMP	RENAME_CLEAN ; 10/08/2018
 17418                                  	; 28/12/2022
 17419 00002863 EBE6                    	jmp	short jmp_to_rename_clean
 17420                                  
 17421                                  ;----------------------------------------------------------------------------
 17422                                  ; Procedure: GET_SOURCE
 17423                                  ;
 17424                                  ; Inputs:
 17425                                  ;	RENAMEDMA has source info
 17426                                  ; Function:
 17427                                  ;	Re-find the source
 17428                                  ; Output:
 17429                                  ;	[CURBUF] set
 17430                                  ;	[CURBUF+2]:BX points to entry
 17431                                  ;	Carry set if error (currently user FAILed to I 24)
 17432                                  ; DS preserved, others destroyed
 17433                                  ;----------------------------------------------------------------------------
 17434                                  
 17435                                  GET_SOURCE:
 17436 00002865 8B1E[2F06]              	MOV	BX,[RENAMEDMA+15]	; DirStart
 17437 00002869 C42E[8A05]              	LES	BP,[THISDPB]
 17438 0000286D E81815                  	call	SETDIRSRCH
 17439 00002870 7214                    	JC	short gs_ret_label	; retc
 17440 00002872 E8E717                  	call	STARTSRCH
 17441 00002875 A1[2D06]                	MOV	AX,[RENAMEDMA+13]	; Lastent
 17442                                  	;call	GETENT
 17443                                  	; 18/12/2022
 17444 00002878 E9E014                  	jmp	GETENT
 17445                                  ;gs_ret_label:
 17446                                  	;retn
 17447                                  
 17448                                  ; MSDOS 6.0 
 17449                                  ;---------------------------------------------------------------------------
 17450                                  ;Procedure: NEW_RENAME
 17451                                  ;
 17452                                  ;Input: DS:SI -> raw string with ?
 17453                                  ;	ES:DI -> destination string
 17454                                  ;	DS:BX -> source string
 17455                                  ;Function: replace ? chars of raw string with chars in source string and
 17456                                  ;	   put in destination string
 17457                                  ;Output: ES:DI-> new string
 17458                                  ;---------------------------------------------------------------------------
 17459                                  
 17460                                  NEW_RENAME:
 17461                                  	; 17/05/2019 - Retro DOS v4.0
 17462                                  NEWNAM:
 17463                                  	; DOSCODE:680Eh (MSDOS 6.21, MSDOS.SYS)
 17464 0000287B AC                      	LODSB
 17465 0000287C 3C3F                    	CMP	AL,"?" ; 3Fh
 17466 0000287E 7502                    	JNZ	short NOCHG
 17467 00002880 8A07                    	MOV	AL,[BX] 		; Get replace char
 17468                                  NOCHG:
 17469 00002882 AA                      	STOSB
 17470 00002883 43                      	INC	BX			; Next replace char
 17471 00002884 E2F5                    	LOOP	NEWNAM
 17472                                  	; MSDOS 6.0
 17473                                  gs_ret_label:	; 18/12/2022
 17474 00002886 C3                      	retn
 17475                                  
 17476                                  ;============================================================================
 17477                                  ; FINFO.ASM, MSDOS 6.0, 1991
 17478                                  ;============================================================================
 17479                                  ; 08/08/2018 - Retro DOS v3.0
 17480                                  ; 17/05/2019 - Retro DOS v4.0
 17481                                  
 17482                                  ;**	Low level routines for returning file information and setting file
 17483                                  ;	attributes
 17484                                  ;
 17485                                  ;	GET_FILE_INFO
 17486                                  ;	SET_FILE_ATTRIBUTE
 17487                                  ;
 17488                                  ;	Modification history:
 17489                                  ;
 17490                                  ;	    Created: ARR 30 March 1983
 17491                                  ;
 17492                                  ;	M025: Return access_denied if attempting to set
 17493                                  ;	      attribute of root directory.
 17494                                  ;
 17495                                  
 17496                                  ;SUBTTL GET_FILE_INFO -- Get File Information
 17497                                  
 17498                                  ;---------------------------------------------------------------------------
 17499                                  ; Procedure Name : GET_FILE_INFO
 17500                                  ;
 17501                                  ; Inputs:
 17502                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17503                                  ;		terminated)
 17504                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17505                                  ;		( = -1 if current dir not involved, else
 17506                                  ;		 Points to first char after last "/" of current dir part)
 17507                                  ;	[THISCDS] Points to CDS being used
 17508                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 17509                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 17510                                  ; Function:
 17511                                  ;	Get Information about a file
 17512                                  ; Returns:
 17513                                  ;	CARRY CLEAR
 17514                                  ;	    AX = Attribute of file
 17515                                  ;	    CX = Time stamp of file
 17516                                  ;	    DX = Date stamp of file
 17517                                  ;	    BX:DI = Size of file (32 bit)
 17518                                  ;	CARRY SET
 17519                                  ;	    AX is error code
 17520                                  ;		error_file_not_found
 17521                                  ;			Last element of path not found
 17522                                  ;		error_path_not_found
 17523                                  ;			Bad path (not in curr dir part if present)
 17524                                  ;		error_bad_curr_dir
 17525                                  ;			Bad path in current directory part of path
 17526                                  ; DS preserved, others destroyed
 17527                                  ;---------------------------------------------------------------------------
 17528                                  
 17529                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17530                                  
 17531                                  GET_FILE_INFO:
 17532                                  
 17533                                  ;hkn; get_file_info is called from file.asm and fcbio.asm. DS has been set 
 17534                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 17535                                  
 17536 00002887 E89FE9                  	call	TestNet
 17537 0000288A 7306                    	JNC	short LOCAL_INFO
 17538                                  
 17539                                  ;IF NOT Installed
 17540                                  ;	transfer NET_GET_FILE_INFO
 17541                                  ;ELSE
 17542                                  ;	MOV	AX,(MultNET SHL 8) OR 15
 17543                                  ;	INT	2FH
 17544                                  ;	return
 17545                                  
 17546 0000288C B80F11                  	mov     ax, 110Fh
 17547 0000288F CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
 17548                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 17549                                  			; SDA CDS pointer -> current directory
 17550                                  			; Return: CF set on error, AX = file attributes
 17551 00002891 C3                      	retn
 17552                                  ;ENDIF
 17553                                  
 17554                                  LOCAL_INFO:
 17555 00002892 E84DEA                  	call	ECritDisk
 17556 00002895 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 17557                                  	; MSDOS 3.3
 17558                                  	;call	GETPATH
 17559                                  	; MSDOS 6.0
 17560 0000289A E8CB00                  	call	GET_FAST_PATH
 17561                                  	; MSDOS 3.3 & MSDOS 6.0
 17562 0000289D 7312                    	JNC	short info_check_dev
 17563                                  NO_PATH:
 17564 0000289F 750B                    	JNZ	short bad_path1
 17565 000028A1 08C9                    	OR	CL,CL
 17566 000028A3 7407                    	JZ	short bad_path1
 17567                                  info_no_file:
 17568 000028A5 B80200                  	MOV	AX,error_file_not_found
 17569                                  BadRet:
 17570 000028A8 F9                      	STC
 17571                                  JustRet:
 17572                                  	;call	LCritDisk
 17573                                  	;retn
 17574                                  	; 18/12/2022
 17575 000028A9 E951EA                  	jmp	LCritDisk
 17576                                  
 17577                                  bad_path1:
 17578 000028AC B80300                  	MOV	AX,error_path_not_found
 17579 000028AF EBF7                    	jmp	short BadRet
 17580                                  
 17581                                  info_check_dev:
 17582 000028B1 08E4                    	OR	AH,AH
 17583 000028B3 78F0                    	JS	short info_no_file	; device
 17584                                  
 17585                                  	; MSDOS 6.0
 17586                                  ;SR;
 17587                                  ; If root dir then CurBuf == -1. Check for this case and return subdir attr
 17588                                  ;for a root dir
 17589                                  
 17590 000028B5 833E[E205]FF            	cmp	word [CURBUF],-1	;is it a root dir?
 17591 000028BA 7506                    	jne	short not_root		;no, CurBuf ptr is valid
 17592                                  
 17593 000028BC 30E4                    	xor	ah,ah
 17594 000028BE B010                    	mov	al,attr_directory ; 10h
 17595                                  	;clc
 17596                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17597                                  	; (DOSCODE:683Eh)
 17598                                  	; 16/12/2022
 17599                                  	;clc
 17600 000028C0 EBE7                    	jmp	short JustRet
 17601                                  
 17602                                  not_root:
 17603                                  	; MSDOS 3.3 (& MSDOS 6.0)
 17604 000028C2 1E                      	PUSH	DS
 17605 000028C3 8E1E[E405]              	MOV	DS,[CURBUF+2]
 17606 000028C7 89DE                    	MOV	SI,BX
 17607 000028C9 31DB                    	XOR	BX,BX			; Assume size=0 (dir)
 17608 000028CB 89DF                    	MOV	DI,BX
 17609                                  	;mov	cx,[si+16h]
 17610 000028CD 8B4C16                  	MOV	CX,[SI+dir_entry.dir_time]
 17611                                  	;mov	dx,[si+18h]
 17612 000028D0 8B5418                  	MOV	DX,[SI+dir_entry.dir_date]
 17613 000028D3 30E4                    	XOR	AH,AH
 17614                                  	;mov	al,[si+0Bh]
 17615 000028D5 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 17616                                  	;test	al,10h
 17617 000028D8 A810                    	TEST	AL,attr_directory
 17618 000028DA 7506                    	JNZ	short NO_SIZE
 17619                                  	;mov	di,[si+1Ch]
 17620 000028DC 8B7C1C                  	MOV	DI,[SI+dir_entry.dir_size_l]
 17621                                  	;mov	bx,[si+1Eh]
 17622 000028DF 8B5C1E                  	MOV	BX,[SI+dir_entry.dir_size_h]
 17623                                  NO_SIZE:
 17624 000028E2 1F                      	POP	DS
 17625                                  	;CLC
 17626                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17627                                  	; (DOSCODE:6864h)
 17628                                  	; 16/12/2022
 17629                                  	;clc
 17630 000028E3 EBC4                    	jmp	short JustRet
 17631                                  
 17632                                  ;Break	<SET_FILE_ATTRIBUTE -- Set File Attribute>
 17633                                  ;-------------------------------------------------------------------------------
 17634                                  ; Procedure Name : SET_FILE_ATTRIBUTE
 17635                                  ; Inputs:
 17636                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17637                                  ;		terminated)
 17638                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17639                                  ;		( = -1 if current dir not involved, else
 17640                                  ;		 Points to first char after last "/" of current dir part)
 17641                                  ;	[THISCDS] Points to CDS being used
 17642                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 17643                                  ;	[SATTRIB] is attribute of search (determines what files may be found)
 17644                                  ;	AX is new attributes to give to file
 17645                                  ; Function:
 17646                                  ;	Set File Attributes
 17647                                  ; Returns:
 17648                                  ;	CARRY CLEAR
 17649                                  ;	    No error
 17650                                  ;	CARRY SET
 17651                                  ;	    AX is error code
 17652                                  ;		error_file_not_found
 17653                                  ;			Last element of path not found
 17654                                  ;		error_path_not_found
 17655                                  ;			Bad path (not in curr dir part if present)
 17656                                  ;		error_bad_curr_dir
 17657                                  ;			Bad path in current directory part of path
 17658                                  ;		error_access_denied
 17659                                  ;			Attempt to set an attribute which cannot be set
 17660                                  ;			(attr_directory, attr_volume_ID)
 17661                                  ;		error_sharing_violation
 17662                                  ;			Sharing mode of file did not allow the change
 17663                                  ;			(this request requires exclusive write/read access)
 17664                                  ;			(INT 24H generated)
 17665                                  ; DS preserved, others destroyed
 17666                                  ;----------------------------------------------------------------------------
 17667                                  
 17668                                  SET_FILE_ATTRIBUTE:
 17669                                  
 17670                                  ;hkn; set_file_attr is called from file.asm. DS has been set 
 17671                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 17672                                  
 17673 000028E5 A9D8FF                  	TEST	AX,~attr_changeable ; 0FFD8h
 17674 000028E8 7414                    	JZ	short set_look
 17675                                  _BAD_ACC:
 17676 000028EA C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1
 17677 000028EF C606[2703]07            	MOV	byte [EXTERR_CLASS],errCLASS_Apperr ; 7
 17678 000028F4 C606[2603]04            	MOV	byte [EXTERR_ACTION],errACT_Abort ; 4
 17679 000028F9 B80500                  	MOV	AX,error_access_denied ; 5
 17680 000028FC F9                      	STC
 17681 000028FD C3                      	retn
 17682                                  
 17683                                  set_look:
 17684 000028FE E828E9                  	call	TestNet
 17685 00002901 7308                    	JNC	short LOCAL_SET
 17686                                  
 17687                                  ;IF NOT Installed
 17688                                  ;	transfer NET_SEQ_SET_FILE_ATTRIBUTE
 17689                                  ;ELSE
 17690 00002903 50                      	PUSH	AX
 17691                                  	
 17692                                  	;MOV	AX,(MultNET SHL 8) OR 14
 17693                                  	;INT	2FH
 17694                                  
 17695 00002904 B80E11                  	mov     ax, 110Eh
 17696 00002907 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
 17697                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 17698                                  			; SDA CDS pointer -> current directory
 17699                                  			; STACK: WORD new file attributes
 17700                                  			; Return: CF set on error
 17701                                  
 17702 00002909 5B                      	POP	BX			; clean stack
 17703 0000290A C3                      	retn
 17704                                  ;ENDIF
 17705                                  
 17706                                  LOCAL_SET:
 17707 0000290B E8D4E9                  	call	ECritDisk
 17708 0000290E 50                      	PUSH	AX			; Save new attributes
 17709 0000290F C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 17710 00002914 E8CE14                  	call	GETPATH 		; get path through fastopen if there	;AC000;
 17711 00002917 7308                    	JNC	short set_check_device
 17712 00002919 5B                      	POP	BX			; Clean stack (don't zap AX)
 17713 0000291A EB83                    	JMP	short NO_PATH
 17714                                  
 17715                                  	; MSDOS 6.0
 17716                                  cannot_set_root:			; M025:
 17717 0000291C B80500                  	mov	ax,error_access_denied	; M025: return error is attempting
 17718                                  	;stc				; M025: to set attr. of root
 17719                                  	;jmp	short OK_BYE		; M025:
 17720                                  	; 01/02/2024
 17721 0000291F EB87                    	jmp	short BadRet
 17722                                  
 17723                                  set_check_device:
 17724 00002921 08E4                    	OR	AH,AH
 17725 00002923 7906                    	JNS	short set_check_share
 17726 00002925 58                      	POP	AX
 17727 00002926 E8D4E9                  	call	LCritDisk
 17728 00002929 EBBF                    	JMP	short _BAD_ACC 		; device
 17729                                  
 17730                                  set_check_share:
 17731 0000292B 58                      	POP	AX			; Get new attributes
 17732                                  
 17733                                  	; MSDOS 6.0
 17734 0000292C 833E[E205]FF            	cmp	word [CURBUF], -1	; M025: Q: is this the root dir
 17735 00002931 74E9                    	je	short cannot_set_root	; M025: Y: return error
 17736                                  
 17737                                  	; MSDOS 3.3 & MSDOS 6.0
 17738 00002933 E89AFC                  	call	REN_DEL_Check
 17739 00002936 7305                    	JNC	short set_do
 17740 00002938 B82000                  	MOV	AX,error_sharing_violation ; 32
 17741 0000293B EB28                    	jmp	short OK_BYE
 17742                                  
 17743                                  set_do:
 17744                                  	; MSDOS 3.3 & MSDOS 6.0
 17745 0000293D C43E[E205]              	LES	DI,[CURBUF]
 17746 00002941 2680670BD8              	AND	BYTE [ES:BX+dir_entry.dir_attr],~attr_changeable ; 0D8h
 17747 00002946 2608470B                	OR	BYTE [ES:BX+dir_entry.dir_attr],AL
 17748                                  
 17749                                  ; 07/07/2024 - Retro DOS v4.2
 17750                                  %if 0
 17751                                  	; MSDOS 6.0
 17752                                  	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 17753                                  					;LB. if already dirty		  ;AN000;
 17754                                  	JNZ	short yesdirty3		;LB.  don't increment dirty count ;AN000;
 17755                                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 17756                                  	
 17757                                  	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 17758                                  yesdirty3:
 17759                                  %else
 17760                                  	; 01/02/2024
 17761                                  	; (PCDOS 7.1 IBMDOS.COM)
 17762 0000294A E86A30                  	call	SET_BUF_DIRTY
 17763                                  %endif
 17764 0000294D A0[7605]                	MOV	AL,[THISDRV]
 17765                                  ;;;; 10/1/86 F.C update fastopen cache
 17766 00002950 52                      	PUSH	DX
 17767 00002951 57                      	PUSH	DI
 17768 00002952 B400                    	MOV	AH,0		  ; dir entry update
 17769 00002954 88C2                    	MOV	DL,AL		  ; drive number A=0,B=1,,
 17770 00002956 89DF                    	MOV	DI,BX		  ; ES:DI -> dir entry
 17771 00002958 E80AFD                  	call	FastOpen_Update
 17772 0000295B 5F                      	POP	DI
 17773 0000295C 5A                      	POP	DX
 17774                                  ;;;; 9/11/86 F.C update fastopen cache
 17775 0000295D E8552F                  	call	FLUSHBUF
 17776 00002960 7303                    	JNC	short OK_BYE
 17777 00002962 B80200                  	MOV	AX,error_file_not_found
 17778                                  OK_BYE:
 17779                                  	;call	LCritDisk
 17780                                  	;retn
 17781                                  	; 16/12/2022
 17782 00002965 E995E9                  	jmp	LCritDisk
 17783                                  
 17784                                  	; 17/05/2019 - Retro DOS v4.0
 17785                                  
 17786                                  	; MSDOS 6.0
 17787                                  GET_FAST_PATH:
 17788                                  ;hkn; use SS override for FastOpenFlg
 17789 00002968 36800E[3A0D]01          	OR	byte [ss:FastOpenFlg],FastOpen_Set
 17790                                  					;FO. trigger fastopen	;AN000;
 17791 0000296E E87414                  	call	GETPATH
 17792 00002971 9C                      	PUSHF			 	;FO.			;AN000;
 17793 00002972 368026[3A0D]80          	AND	byte [ss:FastOpenFlg],Fast_yes 
 17794                                  					;FO. clear all fastopen flags ;AN000;
 17795 00002978 9D                      	POPF				;FO.			;AN000;
 17796 00002979 C3                      	retn
 17797                                  
 17798                                  ;============================================================================
 17799                                  ; DUP.ASM, MSDOS 6.0, 1991
 17800                                  ;============================================================================
 17801                                  ; 08/08/2018 - Retro DOS v3.0
 17802                                  ; 17/05/2019 - Retro DOS v4.0
 17803                                  
 17804                                  ;** 	Low level DUP routine for use by EXEC when creating a new process.
 17805                                  ;   	Exports the DUP to the server machine and increments the SFT ref count
 17806                                  ;
 17807                                  ;	DOS_DUP
 17808                                  ;
 17809                                  ;	Modification history:
 17810                                  ;
 17811                                  ;	  Created: ARR 30 March 1983
 17812                                  
 17813                                  ;BREAK <DOS_DUP -- DUP SFT across network>
 17814                                  ;---------------------------------------------------------------------------
 17815                                  ; Procedure Name : DOS_DUP
 17816                                  ;
 17817                                  ; Inputs:
 17818                                  ;	[THISSFT] set to the SFT for the file being DUPed
 17819                                  ;		(a non net SFT is OK, in this case the ref
 17820                                  ;		 count is simply incremented)
 17821                                  ; Function:
 17822                                  ;	Signal to the devices that a logical open is occurring
 17823                                  ; Returns:
 17824                                  ;	ES:DI point to SFT
 17825                                  ;    Carry clear
 17826                                  ;	SFT ref_count is incremented
 17827                                  ; Registers modified: None.
 17828                                  ; NOTE:
 17829                                  ;	This routine is called from $CREATE_PROCESS_DATA_BLOCK at DOSINIT
 17830                                  ;	time with SS NOT DOSGROUP. There will be no Network handles at
 17831                                  ;	that time.
 17832                                  ;---------------------------------------------------------------------------
 17833                                  
 17834                                  DOS_DUP:
 17835                                  	;LES	DI,[CS:THISSFT]  ; MSDOS 3.3
 17836                                  
 17837                                  	; MSDOS 6.0
 17838 0000297A 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 17839 0000297F 26C43E[9E05]            	les	di,[es:THISSFT]
 17840                                  
 17841                                  	;Entry	Dos_Dup_Direct
 17842                                  DOS_Dup_Direct:
 17843 00002984 E8BBE8                  	call	IsSFTNet
 17844 00002987 7503                    	JNZ	short DO_INC
 17845 00002989 E8FC1A                  	call	DEV_OPEN_SFT
 17846                                  DO_INC:
 17847                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 17848 0000298C 26FF05                  	inc	word [ES:DI]		; Clears carry (if this ever wraps
 17849                                  					;   we're in big trouble anyway)
 17850 0000298F C3                      	retn
 17851                                  
 17852                                  ;============================================================================
 17853                                  ; CREATE.ASM, MSDOS 6.0, 1991
 17854                                  ;============================================================================
 17855                                  ; 08/08/2018 - Retro DOS v3.0
 17856                                  ; 18/05/2019 - Retro DOS v4.0
 17857                                  
 17858                                  ;TITLE	DOS_CREATE/DOS_CREATE_NEW - Internal CREATE calls for MS-DOS
 17859                                  ;NAME	DOS_CREATE
 17860                                  ;----------------------------------------------------------------------------
 17861                                  ;**	Internal Create and Create new to create a local or NET file and SFT.
 17862                                  ;
 17863                                  ;	DOS_CREATE
 17864                                  ;	DOS_CREATE_NEW
 17865                                  ;	SET_MKND_ERR
 17866                                  ;	SET_Media_ID
 17867                                  ;	SET_EXT_Mode
 17868                                  ;
 17869                                  ;	Revision history:
 17870                                  ;
 17871                                  ;	    A000 version 4.00	  Jan. 1988
 17872                                  ;	    A001  D490 -- Change IOCTL subfunctios from 63h,43h to 66h, 46h
 17873                                  
 17874                                  ;Installed = TRUE
 17875                                  
 17876                                  ;	i_need	THISSFT,DWORD
 17877                                  ;	i_need	THISCDS,DWORD
 17878                                  ;	I_need	EXTERR,WORD
 17879                                  ;	I_Need	ExtErr_locus,BYTE
 17880                                  ;	I_need	JShare,DWORD
 17881                                  ;	I_need	VOLCHNG_FLAG,BYTE
 17882                                  ;	I_need	SATTRIB,BYTE
 17883                                  ;	I_need	CALLVIDM,DWORD
 17884                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000; extended open
 17885                                  ;	I_need	NAME1,BYTE			  ;AN000;
 17886                                  ;	I_need	NO_NAME_ID,BYTE 		  ;AN000;
 17887                                  ;	I_need	Packet_Temp,WORD		  ;AN000;
 17888                                  ;	I_need	DOS34_FLAG,WORD 		  ;AN000;
 17889                                  ;	I_need	SAVE_BX,WORD			  ;AN000;
 17890                                  
 17891                                  ;***	DOS_CREATE - Create a File
 17892                                  ;----------------------------------------------------------------------------
 17893                                  ;	DOS_Create is called to create the specified file, truncating
 17894                                  ;	the old one if it exists.
 17895                                  ;
 17896                                  ;	ENTRY	AX is Attribute to create
 17897                                  ;		(ds) = DOSDATA
 17898                                  ;		[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17899                                  ;			terminated)
 17900                                  ;		[CURR_DIR_END] Points to end of Current dir part of string
 17901                                  ;			( = -1 if current dir not involved, else
 17902                                  ;			 Points to first char after last "/" of current dir part)
 17903                                  ;		[THISCDS] Points to CDS being used
 17904                                  ;			(Low word = -1 if NUL CDS (Net direct request))
 17905                                  ;		[THISSFT] Points to SFT to fill in if file created
 17906                                  ;			(sf_mode field set so that FCB may be detected)
 17907                                  ;		[SATTRIB] Is attribute of search, determines what files can be found
 17908                                  ;
 17909                                  ;	EXIT	sf_ref_count is NOT altered
 17910                                  ;		CARRY CLEAR
 17911                                  ;		    THISSFT filled in.
 17912                                  ;			sf_mode = unchanged for FCB, sharing_compat + open_for_both
 17913                                  ;		CARRY SET
 17914                                  ;		    AX is error code
 17915                                  ;			error_path_not_found
 17916                                  ;				Bad path (not in curr dir part if present)
 17917                                  ;			error_bad_curr_dir
 17918                                  ;				Bad path in current directory part of path
 17919                                  ;			error_access_denied
 17920                                  ;				Attempt to re-create read only file , or
 17921                                  ;				create a second volume id or create a dir
 17922                                  ;			error_sharing_violation
 17923                                  ;				The sharing mode was correct but not allowed
 17924                                  ;				generates an INT 24
 17925                                  ;	USES	all but DS
 17926                                  ;----------------------------------------------------------------------------
 17927                                  
 17928                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17929                                  	; DOSCODE:6920h (MSDOS 5.0, MSDOS.SYS)
 17930                                  
 17931                                  DOS_CREATE:
 17932                                  	; 18/05/2019 - Retro DOS v4.0
 17933                                  	; DOSCODE:6934h (MSDOS 6.21, MSDOS.SYS)
 17934                                  
 17935                                  ;hkn; dispatched to from file.asm and fcbio.asm. DS set up to DOSDATA at 
 17936                                  ;hkn; this point.
 17937                                  
 17938 00002990 30E4                    	XOR	AH,AH		; Truncate is OK
 17939                                  
 17940                                  ;	Enter here from Dos_Create_New
 17941                                  ;
 17942                                  ;	(ah) = 0 iff truncate OK
 17943                                  
 17944                                  Create_inter:
 17945 00002992 A8C0                    	TEST	AL,~(attr_all+attr_ignore+attr_volume_id) ; 80h
 17946                                  				; Mask out any meaningless bits
 17947 00002994 7511                    	JNZ	short AttErr
 17948 00002996 A808                    	TEST	AL,attr_volume_id
 17949 00002998 7407                    	JZ	short NoReset
 17950                                  	
 17951                                  	; MSDOS 6.0
 17952                                  	; 16/12/2022
 17953 0000299A 800E[1106]80            	OR	byte [DOS34_FLAG],DBCS_VOLID ; 80h ;AN000;FOR dbcs volid
 17954                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17955                                  	;or	word [DOS34_FLAG],DBCS_VOLID ; 80h 
 17956                                  	
 17957 0000299F B008                    	MOV	AL,attr_volume_id ; 8
 17958                                  NoReset:
 17959 000029A1 0C20                    	OR	AL,attr_archive ; File changed  ; 20h
 17960 000029A3 A850                    	TEST	AL,attr_directory+attr_device ; 50h
 17961 000029A5 740A                    	JZ	short ATT_OK
 17962                                  AttErr:
 17963 000029A7 B80500                  	MOV	AX,5		; Attribute problem
 17964 000029AA C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1
 17965 000029AF EB62                    	JMP	SHORT SET_MKND_ERR ; Gotta use MKDIR to make dirs, NEVER allow
 17966                                  				   ;	attr_device to be set.
 17967                                  ATT_OK:
 17968 000029B1 C43E[9E05]              	LES	DI,[THISSFT]
 17969 000029B5 06                      	PUSH	ES
 17970 000029B6 C436[A205]              	LES	SI,[THISCDS]
 17971 000029BA 83FEFF                  	CMP	SI,-1
 17972 000029BD 751B                    	JNE	short TEST_RE_NET
 17973                                  
 17974                                  ;	No CDS, it must be redirected.
 17975                                  
 17976 000029BF 07                      	POP	ES
 17977                                  
 17978                                  	; MSDOS 6.0
 17979                                  ;Extended open hooks
 17980                                  	;test	byte [EXTOPEN_ON],1
 17981 000029C0 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 17982 000029C5 740D                    	JZ	short NOEXTOP 		    ;AN000;EO. no, do normal
 17983                                  IFS_extopen:				    ;AN000;EO.
 17984 000029C7 50                      	PUSH	AX			    ;AN000;EO. pass create attr
 17985                                  	;MOV	AX,(MultNET SHL 8) OR 46    ;AN000;EO. issue extended open verb
 17986 000029C8 B82E11                  	mov	ax,112Eh
 17987                                  NOEXTOP2:	; 01/02/2024 (PCDOS 7.1 IBMDOS.COM)
 17988 000029CB CD2F                    	INT	2FH			    ;AN000;EO.
 17989 000029CD 5B                      	POP	BX			    ;AN000;EO. trash bx
 17990 000029CE C606[F605]00            	MOV	byte [EXTOPEN_ON],0	    ;AN000;EO.
 17991 000029D3 C3                      	retn				    ;AN000;EO.
 17992                                  NOEXTOP:				    ;AN000;
 17993                                  ;Extended open hooks
 17994                                  
 17995                                  ;IF NOT Installed
 17996                                  ;	transfer NET_SEQ_CREATE
 17997                                  ;ELSE
 17998 000029D4 50                      	PUSH	AX
 17999                                  
 18000                                  	;MOV	AX,(MultNET SHL 8) OR 24
 18001                                  	;INT	2FH
 18002                                  
 18003 000029D5 B81811                  	mov	ax,1118h
 18004                                  	; 01/02/2024
 18005                                  	;int	2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
 18006                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 18007                                  			; SDA first filename pointer -> fully-qualified name of file
 18008                                  			; STACK: WORD file creation mode???
 18009                                  
 18010                                  	;POP	BX			; BX is trashed anyway
 18011                                  	;retn
 18012 000029D8 EBF1                    	jmp	short NOEXTOP2 ; 01/02/2024
 18013                                  ;ENDIF
 18014                                  
 18015                                  ;	We have a CDS. See if it's network
 18016                                  
 18017                                  TEST_RE_NET:
 18018                                  	;;test	word [es:si+43h],8000h
 18019                                  	;TEST	word [ES:SI+curdir.flags],curdir_isnet
 18020                                  	; 07/12/2022
 18021                                  	;test	byte [es:si+44h],80h
 18022                                  	; 17/12/2022
 18023 000029DA 26F6444480              	test	byte [ES:SI+curdir.flags+1],curdir_isnet>>8
 18024 000029DF 07                      	POP	ES
 18025 000029E0 7417                    	JZ	short LOCAL_CREATE
 18026                                  
 18027                                  	; MSDOS 6.0
 18028 000029E2 E8BD00                  	CALL	Set_EXT_mode		    ;AN000;EO.
 18029 000029E5 7205                    	JC	SHORT dochk		    ;AN000;EO.
 18030                                  	;;or	word [es:di+2],2
 18031                                  	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.
 18032                                  	; 17/12/2022
 18033 000029E7 26804D0202              	or	byte [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.
 18034                                  
 18035                                  ;Extended open hooks
 18036                                  dochk:
 18037 000029EC F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 18038 000029F1 75D4                    	JNZ	short IFS_extopen	    ;AN000;EO. yes, issue extended open
 18039                                  ;Extended open hooks
 18040                                  
 18041                                  ;IF NOT Installed
 18042                                  ;	transfer NET_CREATE
 18043                                  ;ELSE
 18044 000029F3 50                      	PUSH	AX
 18045                                  	
 18046                                  	;MOV	AX,(MultNET SHL 8) OR 23
 18047                                  	;INT	2FH
 18048                                  	
 18049 000029F4 B81711                  	mov	ax,1117h
 18050                                  	
 18051                                  	; 01/02/2024
 18052                                  	;int	2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
 18053                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 18054                                  			; SDA first filename pointer -> fully-qualified name of file to open
 18055                                  			; SDA CDS pointer -> current directory
 18056                                  			; Return: CF set on error
 18057                                  
 18058                                  	;POP	BX			; BX is trashed anyway
 18059                                  ;nomore:
 18060                                  	;retn
 18061 000029F7 EBD2                    	jmp	short NOEXTOP2 ; 01/02/2024
 18062                                  ;ENDIF
 18063                                  
 18064                                  ;**	It's a local create. We have a local CDS for it.
 18065                                  
 18066                                  LOCAL_CREATE:
 18067                                  	; MSDOS 6.0
 18068 000029F9 E8A600                  	CALL	Set_EXT_mode	;AN000;EO. set mode if from extended open
 18069 000029FC 7205                    	JC	short setdone	;AN000;EO.
 18070                                  	
 18071                                  	; MSDOS 3.3 & MSDOS 6.0
 18072                                  	; 17/12/2022
 18073                                  	;;or	word [es:di+2],2
 18074                                  	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 18075                                  	;or	byte [es:di+2],2
 18076 000029FE 26804D0202              	or	byte [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both	
 18077                                  setdone:
 18078 00002A03 E8DCE8                  	call	ECritDisk
 18079 00002A06 E8181E                  	call	MakeNode
 18080 00002A09 7317                    	JNC	short Create_ok
 18081 00002A0B C606[A10A]FF            	mov	byte [VOLCHNG_FLAG],-1	; indicate no change in volume label
 18082 00002A10 E8EAE8                  	call	LCritDisk
 18083                                  
 18084                                  	;entry	SET_MKND_ERR
 18085                                  SET_MKND_ERR:
 18086                                  
 18087                                  ;	Looks up MakeNode errors and converts them. AL is MakeNode
 18088                                  ;	error, SI is GETPATH bad spot return if path_not_found error.
 18089                                  
 18090                                  ;hkn; CRTERRTAB is in TABLE seg (DOSCODE)
 18091 00002A13 BB[1A2A]                	MOV     BX,CRTERRTAB
 18092                                  	;XLAT  ; MSDOS 3.3
 18093                                  	; 18/05/2019 - Retro DOS v4.0
 18094 00002A16 2E                      	CS
 18095 00002A17 D7                      	XLAT
 18096                                  CreatBadRet:
 18097 00002A18 F9                      	STC
 18098 00002A19 C3                      	retn
 18099                                  
 18100                                  ; 13/05/2019 - Retro DOS v4.0
 18101                                  ; DOSCODE:69C4h (MSDOS 6.21, MSDOS.SYS)
 18102                                  ; ---------------------------------------------------------------------------
 18103                                  
 18104                                  ;** Internal Create and Create new to create a local or NET file and SFT.
 18105                                  
 18106                                  ; 17/07/2018 - Retro DOS v3.0
 18107                                  ; Offset 12B1h of IBMDOS.COM (MSDOS 3.3), 1987
 18108                                  
 18109                                  ;CRTERRTAB: ; 19/07/2018 - MSDOS 3.3	
 18110                                  ;	db	0,5,52h,50h,3,5,20h
 18111                                  
 18112                                  ;CRTERRTAB: ; 18/05/2019 - MSDOS 6.0	
 18113                                  ;	db	0,5,52h,50h,3,5,20h,2
 18114                                  
 18115                                  ; 08/08/2018
 18116                                  
 18117                                  CRTERRTAB:	;LABEL BYTE	; Lookup table for MakeNode returns
 18118 00002A1A 00                      	DB	0			; none
 18119 00002A1B 05                      	DB	error_access_denied	; MakeNode error 1
 18120 00002A1C 52                      	DB	error_cannot_make	; MakeNode error 2
 18121 00002A1D 50                      	DB	error_file_exists	; MakeNode error 3
 18122 00002A1E 03                      	DB	error_path_not_found	; MakeNode error 4
 18123 00002A1F 05                      	DB	error_access_denied	; MakeNode error 5
 18124 00002A20 20                      	DB	error_sharing_violation ; MakeNode error 6
 18125                                  	; MSDOS 6.0
 18126 00002A21 02                      	DB	error_file_not_found	; MakeNode error 7
 18127                                  
 18128                                  ; ---------------------------------------------------------------------------
 18129                                  
 18130                                  ; We have just created a new file. This results in the truncation of old
 18131                                  ; files. We must inform the sharer to slash all the open SFT's for this
 18132                                  ; file to the current size.
 18133                                  
 18134                                  ; If we created a volume id on the diskette, set the VOLCHNG_FLAG to logical
 18135                                  ; drive number to force a Build BPB after Media Check.
 18136                                  
 18137                                  ;;; FASTOPEN 8/29/86
 18138                                  Create_ok:
 18139 00002A22 E818FC                  	call	FastOpen_Delete
 18140                                  ;;; FASTOPEN 8/29/86
 18141 00002A25 A0[6D05]                	mov	al,[SATTRIB]
 18142 00002A28 A808                    	test	al,attr_volume_id
 18143 00002A2A 741C                    	jz	short NoVolLabel
 18144 00002A2C C43E[A205]              	LES	DI,[THISCDS]
 18145                                  	;mov	ah,[ES:DI+curdir.text]	; get drive letter
 18146 00002A30 268A25                  	mov	ah,[ES:DI] ; 09/08/2018
 18147 00002A33 80EC41                  	sub	ah,'A'	; 41h		; convert to drive number
 18148 00002A36 8826[A10A]              	mov	[VOLCHNG_FLAG],ah	;Set flag to indicate volid change
 18149                                  	
 18150                                  	; 18/05/2019 - Retro DOS v4.0
 18151                                  
 18152                                  	; MSDOS 6.0
 18153 00002A3A B701                    	MOV	BH,1			;AN000;>32mb set volume id to boot record
 18154 00002A3C E81F00                  	CALL	Set_Media_ID		;AN000;>32mb
 18155                                  	
 18156 00002A3F E8A0E8                  	call	ECritDisk
 18157 00002A42 E8FD2A                  	call	FATREAD_CDS		; force a media check
 18158 00002A45 E8B5E8                  	call	LCritDisk
 18159                                  
 18160                                  NoVolLabel:
 18161 00002A48 B80200                  	MOV	ax,2
 18162 00002A4B C43E[9E05]              	LES	DI,[THISSFT]
 18163                                  ;if installed
 18164                                  	;call	JShare + 14 * 4
 18165 00002A4F FF1E[C800]              	call	far [JShare+(14*4)] ; 14 = ShSU
 18166                                  ;else
 18167                                  ;	Call	ShSU
 18168                                  ;endif
 18169 00002A53 E8A7E8                  	call	LCritDisk
 18170 00002A56 E94901                  	jmp	SET_SFT_MODE
 18171                                  
 18172                                  ;---------------------------------------------------------------------------
 18173                                  ; Procedure Name : Dos_Create_New
 18174                                  ;
 18175                                  ; Inputs:
 18176                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 18177                                  ;		terminated)
 18178                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 18179                                  ;		( = -1 if current dir not involved, else
 18180                                  ;		 Points to first char after last "/" of current dir part)
 18181                                  ;	[THISCDS] Points to CDS being used
 18182                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 18183                                  ;	[THISSFT] Points to SFT to fill in if file created
 18184                                  ;		(sf_mode field set so that FCB may be detected)
 18185                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 18186                                  ;	AX is Attribute to create
 18187                                  ; Function:
 18188                                  ;	Try to create the specified file truncating an old one that exists
 18189                                  ; Outputs:
 18190                                  ;	sf_ref_count is NOT altered
 18191                                  ;	CARRY CLEAR
 18192                                  ;	    THISSFT filled in.
 18193                                  ;		sf_mode = sharing_compat + open_for_both for Non-FCB SFT
 18194                                  ;	CARRY SET
 18195                                  ;	    AX is error code
 18196                                  ;		error_path_not_found
 18197                                  ;			Bad path (not in curr dir part if present)
 18198                                  ;		error_bad_curr_dir
 18199                                  ;			Bad path in current directory part of path
 18200                                  ;		error_access_denied
 18201                                  ;			Create a second volume id or create a dir
 18202                                  ;		error_file_exists
 18203                                  ;			Already a file by this name
 18204                                  ; DS preserved, others destroyed
 18205                                  ;---------------------------------------------------------------------------
 18206                                  
 18207                                  DOS_Create_New:
 18208 00002A59 B401                    	MOV	AH,1		; Truncate is NOT OK
 18209 00002A5B E934FF                  	JMP	Create_inter
 18210                                  
 18211                                  ; MSDOS 6.0
 18212                                  ;---------------------------------------------------------------------------
 18213                                  ; Procedure Name : Set_Media_ID
 18214                                  ;
 18215                                  ; Inputs:
 18216                                  ;	NAME1= Volume ID
 18217                                  ;	BH= 0, delete volume id
 18218                                  ;	    1, set new volume id
 18219                                  ;	DS= DOSGROUP
 18220                                  ; Function:
 18221                                  ;	Set Volume ID to DOS 4.00 Boot record.
 18222                                  ; Outputs:
 18223                                  ;	CARRY CLEAR
 18224                                  ;	    volume id set
 18225                                  ;	CARRY SET
 18226                                  ;	    AX is error code
 18227                                  ;---------------------------------------------------------------------------
 18228                                  
 18229                                  	; 18/05/2019 - Retro DOS v4.0
 18230                                  Set_Media_ID:
 18231 00002A5E 50                      	PUSH	AX		;AN000;;>32mb
 18232 00002A5F 06                      	PUSH	ES		;AN000;;>32mb
 18233 00002A60 57                      	PUSH	DI		;AN000;;>32mb
 18234                                  
 18235 00002A61 FEC4                    	INC	AH		;AN000;;>32mb  bl=drive #
 18236 00002A63 88E3                    	MOV	BL,AH		;AN000;;>32mb  bl=drive # (A=1,B=2,,,)
 18237 00002A65 B00D                    	MOV	AL,0DH		;AN000;;>32mb  generic IOCTL
 18238 00002A67 B96608                  	MOV	CX,0866H	;AN001;;>32mb  get media id
 18239                                  
 18240                                  ;hkn; PACKET_TEMP is in DOSDATA
 18241 00002A6A BA[6C0D]                	MOV	DX,Packet_Temp	;AN000;>32mb
 18242                                  
 18243 00002A6D 53                      	PUSH	BX		;AN000;;>32mb
 18244 00002A6E 52                      	PUSH	DX		;AN000;;>32mb
 18245 00002A6F 30FF                    	XOR	BH,BH		;AN000;;>32mb
 18246                                  
 18247                                  	;invoke	$IOCTL		;AN000;;>32mb
 18248 00002A71 E88FF7                  	call	_$IOCTL	
 18249                                  
 18250 00002A74 5A                      	POP	DX		;AN000;;>32mb
 18251 00002A75 5B                      	POP	BX		;AN000;;>32mb
 18252 00002A76 7224                    	JC	short geterr	;AN000;;>32mb
 18253                                  
 18254 00002A78 08FF                    	OR	BH,BH		;AN000;;>32mb delete volume id
 18255 00002A7A 7405                    	JZ	short NoName	;AN000;>32mb yes
 18256                                  
 18257                                  ;hkn; NAME1 is in DOSDATA
 18258 00002A7C BE[4B05]                	MOV	SI,NAME1	;AN000;>32mb
 18259                                  
 18260 00002A7F EB03                    	JMP	SHORT doset	;AN000;>32mb yes
 18261                                  NoName: 			;AN000;
 18262                                  
 18263                                  ;hkn; NO_NAME_ID is in DOSDATA
 18264 00002A81 BE[BA0D]                	MOV	SI,NO_NAME_ID	;AN000;>32mb
 18265                                  
 18266                                  doset:				;AN000;
 18267 00002A84 89D7                    	MOV	DI,DX		;AN000;;>32mb
 18268                                  	;add	di,6
 18269 00002A86 83C706                  	ADD	DI,MEDIA_ID_INFO.MEDIA_Label ;AN000;;>32mb
 18270                                  
 18271                                  ;hkn; ES & DS must point to SS
 18272                                  ;hkn;	PUSH	CS		;AN000;;>32mb  move new volume id to packet
 18273 00002A89 16                      	PUSH	SS		;AN000;;>32mb  move new volume id to packet
 18274                                  
 18275 00002A8A 1F                      	POP	DS		;AN000;;>32mb
 18276                                  
 18277                                  ;hkn;	PUSH	CS		;AN000;;>32mb
 18278 00002A8B 16                      	PUSH	SS		;AN000;;>32mb
 18279                                  
 18280 00002A8C 07                      	POP	ES		;AN000;;>32mb
 18281 00002A8D B90B00                  	MOV	CX,11		;AN000;;>32mb
 18282 00002A90 F3A4                    	REP	MOVSB		;AN000;;>32mb
 18283 00002A92 B94608                  	MOV	CX,0846H	;AN001;;>32mb
 18284 00002A95 B00D                    	MOV	AL,0DH		;AN000;;>32mb
 18285 00002A97 30FF                    	XOR	BH,BH		;AN000;;>32mb
 18286                                  	;invoke	$IOCTL		;AN000;;>32mb  set volume id
 18287 00002A99 E867F7                  	call	_$IOCTL	
 18288                                  geterr: 			;AN000;
 18289                                  ;hkn;	PUSH	CS		;AN000;>32mb
 18290 00002A9C 16                      	PUSH	SS		;AN000;>32mb
 18291                                  
 18292 00002A9D 1F                      	POP	DS		;AN000;>32mb   ds= dosgroup
 18293                                  
 18294 00002A9E 5F                      	POP	DI		;AN000;;>32mb
 18295 00002A9F 07                      	POP	ES		;AN000;;>32mb
 18296 00002AA0 58                      	POP	AX		;AN000;;>32mb
 18297 00002AA1 C3                      	retn			;AN000;>32mb
 18298                                  
 18299                                  ; MSDOS 6.0
 18300                                  ;---------------------------------------------------------------------------
 18301                                  ; Procedure Name : Set_EXT_mode
 18302                                  ;
 18303                                  ; Inputs:
 18304                                  ;	[EXTOPEN_ON]= flag for extended open
 18305                                  ;	SAVE_BX= mode specified in Extended Open
 18306                                  ; Function:
 18307                                  ;	Set mode in ThisSFT
 18308                                  ; Outputs:
 18309                                  ;	carry set,mode is set if from Extended Open
 18310                                  ;	carry clear, mode not set yet
 18311                                  ;---------------------------------------------------------------------------
 18312                                  
 18313                                  ; 13/05/2019 - Retro DOS v4.0
 18314                                  
 18315                                  Set_EXT_mode:
 18316                                  
 18317                                  ;hkn; SS override
 18318 00002AA2 36F606[F605]01          	TEST	byte [ss:EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 18319 00002AA8 740B                    	JZ	short NOTEX		    ;AN000;EO. no, do normal
 18320 00002AAA 50                      	PUSH	AX			    ;AN000;EO.
 18321                                  
 18322                                  ;hkn; SS override
 18323 00002AAB 36A1[0106]              	MOV	AX,[ss:SAVE_BX]		    ;AN000;EO.
 18324                                  	;or	[es:di+2],ax
 18325 00002AAF 26094502                	OR	[ES:DI+SF_ENTRY.sf_mode],AX ;AN000;EO.
 18326 00002AB3 58                      	POP	AX			    ;AN000;EO.
 18327 00002AB4 F9                      	STC				    ;AN000;EO.
 18328                                  NOTEX:					    ;AN000;
 18329 00002AB5 C3                      	retn				    ;AN000;EO.
 18330                                  
 18331                                  ;============================================================================
 18332                                  ; OPEN.ASM, MSDOS 6.0, 1991
 18333                                  ;============================================================================
 18334                                  ; 08/08/2018 - Retro DOS v3.0
 18335                                  ; 18/05/2019 - Retro DOS v4.0
 18336                                  
 18337                                  ;	TITLE	DOS_OPEN - Internal OPEN call for MS-DOS
 18338                                  ;	NAME	DOS_OPEN
 18339                                  
 18340                                  ;**	OPEN.ASM - File Open
 18341                                  ;----------------------------------------------------------------------------
 18342                                  ;	Low level routines for openning a file from a file spec.
 18343                                  ;	Also misc routines for sharing errors
 18344                                  ;
 18345                                  ;	DOS_Open
 18346                                  ;	Check_Access_AX
 18347                                  ;	SHARE_ERROR
 18348                                  ;	SET_SFT_MODE
 18349                                  ;	Code_Page_Mismatched_Error		   ; DOS 4.00
 18350                                  ;
 18351                                  ;	Revision history:
 18352                                  ;
 18353                                  ;	    Created: ARR 30 March 1983
 18354                                  ;	    A000	version 4.00   Jan. 1988
 18355                                  ;
 18356                                  ;	M034 - The value in save_bx must be pushed on to the stack for
 18357                                  ; 	       remote extended opens and not save_cx.
 18358                                  ;
 18359                                  ;	M035 - if open made from exec then we must set the appropriate bits
 18360                                  ;	       on the stack before calling off to the redir.
 18361                                  ;	M042 - Bit 11 of DOS34_FLAG set indicates that the redir knows how 
 18362                                  ;	       to handle open from exec. In this case set the appropriate bit
 18363                                  ;	       else do not.
 18364                                  ;----------------------------------------------------------------------------	
 18365                                  
 18366                                  ;Installed = TRUE
 18367                                  
 18368                                  ;	i_need	NoSetDir,BYTE
 18369                                  ;	i_need	THISSFT,DWORD
 18370                                  ;	i_need	THISCDS,DWORD
 18371                                  ;	i_need	CURBUF,DWORD
 18372                                  ;	i_need	CurrentPDB,WORD
 18373                                  ;	i_need	CURR_DIR_END,WORD
 18374                                  ;	I_need	RetryCount,WORD
 18375                                  ;	I_need	Open_Access,BYTE
 18376                                  ;	I_need	fSharing,BYTE
 18377                                  ;	i_need	JShare,DWORD
 18378                                  ;	I_need	FastOpenFlg,byte
 18379                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000;; DOS 4.00
 18380                                  ;	I_need	ALLOWED,BYTE			  ;AN000;; DOS 4.00
 18381                                  ;	I_need	EXTERR,WORD			  ;AN000;; DOS 4.00
 18382                                  ;	I_need	EXTERR_LOCUS,BYTE		  ;AN000;; DOS 4.00
 18383                                  ;	I_need	EXTERR_ACTION,BYTE		  ;AN000;; DOS 4.00
 18384                                  ;	I_need	EXTERR_CLASS,BYTE		  ;AN000;; DOS 4.00
 18385                                  ;	I_need	CPSWFLAG,BYTE			  ;AN000;; DOS 4.00
 18386                                  ;	I_need	EXITHOLD,DWORD			  ;AN000;; DOS 4.00
 18387                                  ;	I_need	THISDPB,DWORD			  ;AN000;; DOS 4.00
 18388                                  ;	I_need	SAVE_CX,WORD			  ;AN000;; DOS 4.00
 18389                                  ;	I_need	SAVE_BX,WORD			  ;M034
 18390                                  ;
 18391                                  ;	I_need	DOS_FLAG,BYTE
 18392                                  ;	I_need	DOS34_FLAG,WORD			  ;M042
 18393                                  
 18394                                  ;Break	<DOS_Open - internal file access>
 18395                                  ;---------------------------------------------------------------------------
 18396                                  ; Procedure Name : DOS_Open
 18397                                  ;
 18398                                  ; Inputs:
 18399                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 18400                                  ;		terminated)
 18401                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 18402                                  ;		( = -1 if current dir not involved, else
 18403                                  ;		 Points to first char after last "/" of current dir part)
 18404                                  ;	[THISCDS] Points to CDS being used
 18405                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 18406                                  ;	[THISSFT] Points to SFT to fill in if file found
 18407                                  ;		(sf_mode field set so that FCB may be detected)
 18408                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 18409                                  ;	AX is Access and Sharing mode
 18410                                  ;	  High NIBBLE of AL (Sharing Mode)
 18411                                  ;		sharing_compat	   file is opened in compatibility mode
 18412                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 18413                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 18414                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 18415                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 18416                                  ;	  Low NIBBLE of AL (Access Mode)
 18417                                  ;		open_for_read	file is opened for reading
 18418                                  ;		open_for_write	file is opened for writing
 18419                                  ;		open_for_both	file is opened for both reading and writing.
 18420                                  ;
 18421                                  ;	  For FCB SFTs AL should = sharing_compat + open_for_both
 18422                                  ;		(not checked)
 18423                                  ; Function:
 18424                                  ;	Try to open the specified file
 18425                                  ; Outputs:
 18426                                  ;	sf_ref_count is NOT altered
 18427                                  ;	CARRY CLEAR
 18428                                  ;	    THISSFT filled in.
 18429                                  ;	CARRY SET
 18430                                  ;	    AX is error code
 18431                                  ;		error_file_not_found
 18432                                  ;			Last element of path not found
 18433                                  ;		error_path_not_found
 18434                                  ;			Bad path (not in curr dir part if present)
 18435                                  ;		error_bad_curr_dir
 18436                                  ;			Bad path in current directory part of path
 18437                                  ;		error_invalid_access
 18438                                  ;			Bad sharing mode or bad access mode or bad combination
 18439                                  ;		error_access_denied
 18440                                  ;			Attempt to open read only file for writting, or
 18441                                  ;			open a directory
 18442                                  ;		error_sharing_violation
 18443                                  ;			The sharing mode was correct but not allowed
 18444                                  ;			generates an INT 24 on compatibility mode SFTs
 18445                                  ; DS preserved, others destroyed
 18446                                  ;----------------------------------------------------------------------------
 18447                                  
 18448                                  ; 18/05/2019 - Retro DOS v4.0
 18449                                  ; DOSCODE:6A60h (MSDOS 6.21, MSDOS.SYS)
 18450                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 18451                                  ; DOSCODE:6A4Ch (MSDOS 5.0, MSDOS.SYS)
 18452                                  
 18453                                  DOS_OPEN:
 18454                                  	; DS has been set up to DOSDATA in file.asm and fcbio2.asm. 
 18455                                  
 18456 00002AB6 C606[4C03]00            	MOV	byte [NoSetDir],0
 18457 00002ABB E83301                  	CALL	Check_Access_AX
 18458 00002ABE 722B                    	JC	short do_ret_label	    ; retc
 18459                                  
 18460 00002AC0 C43E[9E05]              	LES	DI,[THISSFT]
 18461 00002AC4 30E4                    	XOR	AH,AH
 18462                                  
 18463                                  	; sleaze! move only access/sharing mode in. Leave sf_isFCB unchanged
 18464                                  
 18465 00002AC6 26884502                	MOV	[ES:DI+SF_ENTRY.sf_mode],AL ; For moment do this on FCBs too
 18466 00002ACA 06                      	PUSH	ES
 18467 00002ACB C436[A205]              	LES	SI,[THISCDS]
 18468                                  	; 18/08/2018
 18469 00002ACF 83FEFF                  	CMP	SI,-1
 18470 00002AD2 7530                    	JNZ	short TEST_RE_NET1
 18471 00002AD4 07                      	POP	ES
 18472                                  
 18473                                  	; MSDOS 6.0
 18474                                  ;Extended open hooks
 18475 00002AD5 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;FT. from extnded open		;AN000;
 18476 00002ADA 7410                    	JZ	short _NOEXTOP 		    ;FT. no, do normal			;AN000;
 18477                                  _IFS_extopen:									;AN000;
 18478 00002ADC A0[0106]                	MOV	AL,[SAVE_BX]		    ; M034 - save_bx has original bx  
 18479                                  					    ; with which call was made. This
 18480                                  					    ; has the open access bits. 
 18481                                  	;;MOV	AL,[SAVE_CX]		    ; M034 - FT. al= create attribute
 18482                                  	
 18483 00002ADF 50                      	PUSH	AX			    ;FT. pass create attr to IFS	;AN000;
 18484                                  	;mov	ax,112Eh
 18485                                  	;MOV	AX,(MultNET SHL 8) OR 46    ;FT. issue extended open verb	;AN000;
 18486 00002AE0 B82E11                  	mov	ax,(MultNET*256)+46 
 18487 00002AE3 CD2F                    	INT	2FH			    ;FT.				;AN000;
 18488 00002AE5 5B                      	POP	BX			    ;FT. trash bx			;AN000;
 18489 00002AE6 C606[F605]00            	MOV	byte [EXTOPEN_ON],0	    ;FT.				;AN000;
 18490                                  
 18491                                  do_ret_label:
 18492 00002AEB C3                      	retn				    ;FT.				;AN000;
 18493                                  _NOEXTOP:
 18494                                  ;Extended open hooks
 18495                                  	;
 18496                                  ;IF NOT Installed
 18497                                  	;transfer NET_SEQ_OPEN
 18498                                  ;ELSE
 18499                                  	
 18500                                  do_net_int2f:
 18501 00002AEC F606[8600]01            	test	byte [DOS_FLAG],EXECOPEN ; Q: was this open call made from exec
 18502 00002AF1 7409                    	jz	short not_exec_open	; N: just do net open
 18503                                  					; Y: check to see if redir is aware
 18504                                  					;    of this 
 18505                                  	
 18506                                  					; M042 - start
 18507                                  	;test	word [DOS34_FLAG],EXEC_AWARE_REDIR ; 800h
 18508 00002AF3 F606[1206]08            	test	byte [DOS34_FLAG+1],(EXEC_AWARE_REDIR>>8)
 18509                                  					; Q: does this redir know how to 
 18510                                  					;    this
 18511 00002AF8 7402                    	jz	short not_exec_open	; N: just do net open
 18512                                  					; Y: set bit 3 of access byte and 
 18513                                  					;    set sharing mode to DENY_WRITE
 18514                                  					; M042 - end
 18515                                  	
 18516                                  	; NOTE: This specific mode has not been set for the code assembled
 18517                                  	; under the "NOT Installed" conditional. Currently Installed is 
 18518                                  	; always one.
 18519                                  					; M035 - set the bits on the stack
 18520                                  	;mov	al,23h
 18521 00002AFA B023                    	mov	AL,SHARING_DENY_WRITE+EXEC_OPEN
 18522                                  	
 18523                                  not_exec_open:
 18524                                  	; MSDOS 3.3 & MSDOS 6.0
 18525 00002AFC 50                      	PUSH	AX
 18526                                  
 18527                                  	;MOV	AX,(MultNET SHL 8) OR 22
 18528                                  	;INT	2FH
 18529                                  
 18530 00002AFD B81611                  	mov     ax,1116h
 18531 00002B00 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE
 18532                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 18533                                  			; SDA first filename pointer -> fully-qualified name of file to open
 18534                                  			; STACK: WORD file open mode
 18535                                  			; Return: CF set on error
 18536                                  
 18537 00002B02 5B                      	POP	BX			; clean stack
 18538                                  ;do_ret_label: ; 09/08/2018
 18539 00002B03 C3                      	retn
 18540                                  ;ENDIF
 18541                                  
 18542                                  TEST_RE_NET1:
 18543                                  	;TEST	word [ES:SI+curdir.flags],curdir_isnet
 18544                                  	; 17/12/2022
 18545 00002B04 26F6444480              	test	byte [ES:SI+curdir.flags+1],curdir_isnet>>8
 18546 00002B09 07                      	POP	ES
 18547                                  	; 18/05/2019
 18548 00002B0A 7409                    	JZ	short LOCAL_OPEN
 18549                                  
 18550                                  ;Extended open hooks
 18551                                  	; MSDOS 6.0
 18552 00002B0C F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;FT. from extended open	;AN000;
 18553 00002B11 75C9                    	JNZ	short _IFS_extopen	      ;FT. isuue extended open	;AN000;
 18554                                  ;Extended open hooks
 18555                                  
 18556                                  ;IF NOT Installed
 18557                                  ;	transfer NET_OPEN
 18558                                  ;ELSE
 18559 00002B13 EBD7                    	jmp	short do_net_int2f
 18560                                  ;ENDIF
 18561                                  
 18562                                  LOCAL_OPEN:
 18563                                  	; MSDOS 3.3 & MSDOS 6.0
 18564 00002B15 E8CAE7                  	call	ECritDisk
 18565                                  
 18566                                  ; DOS 3.3 FastOPen 6/16/86
 18567                                  
 18568                                  	;or	byte [FastOpenFlg],5
 18569 00002B18 800E[3A0D]05            	OR	byte [FastOpenFlg],FastOpen_Set+Special_Fill_Set ; only open can
 18570                                  
 18571 00002B1D E8C512                  	call	GETPATH
 18572                                  
 18573                                  ; DOS 3.3 FastOPen 6/16/86
 18574                                  
 18575 00002B20 731D                    	JNC	short Open_found
 18576 00002B22 7511                    	JNZ	short bad_path2
 18577 00002B24 08C9                    	OR	CL,CL
 18578 00002B26 740D                    	JZ	short bad_path2
 18579                                  OpenFNF:
 18580 00002B28 B80200                  	MOV	AX,error_file_not_found	; 2
 18581                                  OpenBadRet:
 18582                                  ;hkn; FastOpenFlg is in DOSDATA use SS override
 18583                                  	; 12/08/2018
 18584                                  	;mov	byte [cs:FastOpenFlg],0 ; IBMDOS.COM (MSDOS 3.3) offset 36CAh
 18585                                  	; MSDOS 6.0
 18586 00002B2B 368026[3A0D]80          	AND	BYTE [SS:FastOpenFlg],Fast_yes    ;; DOS 3.3
 18587 00002B31 F9                      	STC
 18588                                  	;call	LCritDisk
 18589                                  	; 16/12/2022
 18590 00002B32 E9C8E7                  	jmp	LCritDisk
 18591                                  	;;JMP	Clear_FastOpen ; 10/08/2018
 18592                                  	;retn 	; 08/09/2018
 18593                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18594                                  	;jmp	Clear_FastOpen
 18595                                  
 18596                                  bad_path2:
 18597 00002B35 B80300                  	MOV	AX,error_path_not_found	; 3
 18598 00002B38 EBF1                    	JMP	short OpenBadRet
 18599                                  
 18600                                  Open_Bad_Access:
 18601 00002B3A B80500                  	MOV	AX,error_access_denied	; 5
 18602 00002B3D EBEC                    	JMP	short OpenBadRet
 18603                                  
 18604                                  Open_found:
 18605 00002B3F 74F9                    	JZ	short Open_Bad_Access 	; test for directories
 18606 00002B41 08E4                    	OR	AH,AH
 18607 00002B43 783E                    	JS	short open_ok		; Devices don't have attributes
 18608 00002B45 8E06[E405]              	MOV	ES,[CURBUF+2]		; get buffer location
 18609                                  	;mov	al,[es:bx+0Bh]
 18610 00002B49 268A470B                	MOV	AL,[ES:BX+dir_entry.dir_attr]
 18611 00002B4D A808                    	TEST	AL,attr_volume_id	; can't open volume ids
 18612 00002B4F 75E9                    	JNZ	short Open_Bad_Access
 18613 00002B51 A801                    	TEST	AL,attr_read_only	; check write on read only
 18614 00002B53 742E                    	JZ	short open_ok
 18615                                  
 18616                                  ; The file is marked READ-ONLY. We verify that the open mode allows access to
 18617                                  ; the read-only file. Unfortunately, with FCB's and net-FCB's we cannot
 18618                                  ; determine at the OPEN time if such access is allowed. Thus, we defer such
 18619                                  ; processing until the actual write operation:
 18620                                  ;
 18621                                  ; If FCB, then we change the mode to be read_only.
 18622                                  ; If net_FCB, then we change the mode to be read_only.
 18623                                  ; If not open for read then error.
 18624                                  
 18625 00002B55 1E                      	push	ds
 18626 00002B56 56                      	push	si
 18627 00002B57 C536[9E05]              	LDS	SI,[THISSFT]
 18628                                  	;mov	cx,[si+2]
 18629 00002B5B 8B4C02                  	MOV	CX,[SI+SF_ENTRY.sf_mode]
 18630                                  	; 17/12/2022
 18631                                  	;test	ch,80h
 18632 00002B5E F6C580                  	test	ch,sf_isFCB>>8
 18633                                  	;TEST	CX,sf_isFCB ; 8000h	; is it FCB?
 18634 00002B61 750A                    	JNZ	short ResetAccess	; yes, reset the access
 18635 00002B63 88CA                    	MOV	DL,CL
 18636 00002B65 80E2F0                  	AND	DL,SHARING_MASK	; 0F0h
 18637 00002B68 80FA70                  	CMP	DL,SHARING_NET_FCB ; 70h ; is it net FCB?
 18638 00002B6B 7508                    	JNZ	short NormalOpen	; no
 18639                                  ResetAccess:
 18640                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)	
 18641                                  	;AND	CX,~access_mask	; 0FFF0h ; clear access
 18642                                  	; 16/12/2022
 18643 00002B6D 80E1F0                  	and	cl,0F0h ; 18/05/2019
 18644                                  ;	OR	CX,open_for_read ; 0	; stick in open_for_read
 18645 00002B70 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],CX
 18646 00002B73 EB0C                    	JMP	SHORT FillSFT
 18647                                  
 18648                                  ; The SFT is normal. See if the requested access is open_for_read
 18649                                  
 18650                                  NormalOpen:
 18651 00002B75 80E10F                  	AND	CL,access_mask	;0Fh	; remove extras
 18652 00002B78 80F900                  	CMP	CL,open_for_read ; 0	; is it open for read?
 18653 00002B7B 7404                    	JZ	short FillSFT
 18654 00002B7D 5E                      	pop	si
 18655 00002B7E 1F                      	pop	ds
 18656 00002B7F EBB9                    	JMP	short Open_Bad_Access
 18657                                  ;
 18658                                  ; All done, restore registers and fill the SFT.
 18659                                  ;
 18660                                  FillSFT:
 18661 00002B81 5E                      	pop	si
 18662 00002B82 1F                      	pop	ds
 18663                                  open_ok:
 18664 00002B83 E84A1E                  	call	DOOPEN			; Fill in SFT
 18665                                  
 18666                                  ;hkn; FastOpenFlg is in DOSDATA. use SS override
 18667                                  	; 18/05/2019
 18668                                  	;and	byte [ss:FastOpenFlag],80h
 18669 00002B86 368026[3A0D]80          	AND	BYTE [SS:FastOpenFlg],Fast_yes	;; DOS 3.3
 18670                                  	; 12/08/2018
 18671                                  	;and	byte [FastOpenFlg],Fast_yes	
 18672                                  
 18673                                  	; MSDOS 6.0
 18674 00002B8C E84300                  	CALL	DO_SHARE_CHECK
 18675 00002B8F 7303                    	JNC	short SHARE_OK
 18676                                  	;call	LCritDisk
 18677                                  	; 16/12/2022
 18678 00002B91 E969E7                  	jmp	LCritDisk
 18679                                  	;;JMP	short Clear_FastOpen
 18680                                  	;retn	; 18/05/2019
 18681                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18682                                  	;jmp	short Clear_FastOpen	
 18683                                  
 18684                                  	; MSDOS 3.3
 18685                                  ;DO_SHARE_CHECK:
 18686                                  ;	MOV	CX,[RetryCount]		; Get # tries to do
 18687                                  ;OpenShareRetry:
 18688                                  ;	push	cx			; Save number left to do
 18689                                  ;	call	SHARE_CHECK		; Final Check
 18690                                  ;	pop	cx			; CX = # left
 18691                                  ;	JNC	short SHARE_OK		; No problem with access
 18692                                  ;	call	Idle
 18693                                  ;	LOOP	OpenShareRetry		; One more retry used up
 18694                                  ;OpenShareFail:
 18695                                  ;	LES	DI,[THISSFT]
 18696                                  ;	call	SHARE_ERROR
 18697                                  ;	JNC	short DO_SHARE_CHECK	; User wants more retry
 18698                                  	
 18699                                  	;12/08/2018
 18700                                  	;mov	byte [ss:FastOpenFlg],0
 18701                                  	;08/09/2018
 18702                                  	;mov	byte [FastOpenFlg],0
 18703                                  	;call	LCritDisk
 18704                                  	;JMP	short Clear_FastOpen
 18705                                  	;retn
 18706                                  
 18707                                  SHARE_OK:
 18708                                  	; MSDOS 3.3 & MSDOS 6.0
 18709 00002B94 B80300                  	MOV	AX,3
 18710 00002B97 C43E[9E05]              	LES	DI,[THISSFT]
 18711                                  ;if installed
 18712                                  	;call	JShare + 14 * 4
 18713 00002B9B FF1E[C800]              	call	far [JShare+(14*4)]  ; 14 = ShSU
 18714                                  ;else
 18715                                  ;	Call	ShSU
 18716                                  ;endif
 18717 00002B9F E85BE7                  	call	LCritDisk
 18718                                  	
 18719                                  	;FallThru Set_SFT_Mode
 18720                                  
 18721                                  ;----------------------------------------------------------------------------
 18722                                  ; Procedure Name : SET_SFT_MODE
 18723                                  ;
 18724                                  ; Finish SFT initialization for new reference. Set the correct mode.
 18725                                  ;
 18726                                  ;   Inputs:
 18727                                  ;	ThisSFT points to SFT
 18728                                  ;
 18729                                  ;   Outputs:
 18730                                  ;	Carry clear
 18731                                  ;   Registers modified: AX.
 18732                                  ;---------------------------------------------------------------------------
 18733                                  
 18734                                  ;hkn; called from create. DS already set up to DOSDATA.
 18735                                  
 18736                                  SET_SFT_MODE:
 18737 00002BA2 C43E[9E05]              	LES	DI,[THISSFT]
 18738 00002BA6 E8DF18                  	call	DEV_OPEN_SFT
 18739                                  	;test	word [es:di+2],8000h
 18740                                  	; 17/12/2022
 18741                                  	;test	byte [es:di+3],80h
 18742 00002BA9 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],sf_isFCB>>8
 18743                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; Clears carry
 18744 00002BAE 7407                    	JZ	short Clear_FastOpen	; sf_mode correct (retz)
 18745 00002BB0 A1[3003]                	MOV	AX,[CurrentPDB]
 18746                                  	;mov	[es:di+31h],ax
 18747 00002BB3 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX ; For FCB sf_PID=PDB
 18748                                  
 18749                                  Clear_FastOpen:
 18750 00002BB7 C3                      	retn			       ;;;;; DOS 3.3
 18751                                  
 18752                                  ;----------------------------------------------------------------------------
 18753                                  ; Procedure Name : SHARE_ERROR
 18754                                  ;
 18755                                  ; Called on sharing violations. ES:DI points to SFT. AX has error code
 18756                                  ; If SFT is FCB or compatibility mode gens INT 24 error.
 18757                                  ; Returns carry set AX=error_sharing_violation if user says ignore (can't
 18758                                  ; really ignore). Carry clear if user wants a retry. ES, DI, DS preserved
 18759                                  ;---------------------------------------------------------------------------
 18760                                  
 18761                                  SHARE_ERROR:
 18762                                  	; 17/12/2022
 18763                                  	;test	byte [es:di+3],80h
 18764 00002BB8 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],sf_isFCB>>8 ; 80h
 18765                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; 8000h
 18766 00002BBD 7509                    	JNZ	short _HARD_ERR
 18767 00002BBF 268A4D02                	MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 18768 00002BC3 80E1F0                  	AND	CL,SHARING_MASK  ; 0F0h
 18769                                  	;CMP	CL,SHARING_COMPAT ; 0
 18770                                  	;JNE	short _NO_HARD_ERR
 18771                                  	; 21/09/2023
 18772 00002BC6 7505                    	jnz	short _NO_HARD_ERR
 18773                                  _HARD_ERR:
 18774 00002BC8 E88445                  	call	SHARE_VIOLATION
 18775                                  	;retnc				; User wants retry
 18776 00002BCB 73EA                    	jnc	short Clear_FastOpen
 18777                                  _NO_HARD_ERR:
 18778 00002BCD B82000                  	MOV	AX,error_sharing_violation  ; 20h
 18779 00002BD0 F9                      	STC
 18780 00002BD1 C3                      	retn
 18781                                  
 18782                                  ; MSDOS 6.0
 18783                                  ;----------------------------------------------------------------------------
 18784                                  ; Procedure Name : DO_SHARE_CHECK
 18785                                  ;
 18786                                  ; Input: THISDPB, WFP_Start, THISSFT set
 18787                                  ; Functions: check file sharing mode is valid
 18788                                  ; Output: carry set, error
 18789                                  ;	  carry clear, share ok
 18790                                  ;----------------------------------------------------------------------------
 18791                                  
 18792                                  	; 18/05/2019 - Retro DOS v4.0
 18793                                  DO_SHARE_CHECK:
 18794 00002BD2 E80DE7                  	call	ECritDisk		; enter critical section
 18795                                  OPN_RETRY:
 18796 00002BD5 8B0E[1A00]              	MOV	CX,[RetryCount]		; Get # tries to do
 18797                                  OpenShareRetry:
 18798 00002BD9 51                      	push	cx			; Save number left to do
 18799 00002BDA E86D45                  	call	SHARE_CHECK		; Final Check
 18800 00002BDD 59                      	pop	cx			; CX = # left
 18801 00002BDE 730E                    	JNC	short Share_Ok2		; No problem with access
 18802 00002BE0 E801E6                  	call	Idle
 18803 00002BE3 E2F4                    	LOOP	OpenShareRetry		; One more retry used up
 18804                                  OpenShareFail:
 18805 00002BE5 C43E[9E05]              	LES	DI,[THISSFT]
 18806 00002BE9 E8CCFF                  	call	SHARE_ERROR
 18807 00002BEC 73E7                    	JNC	short OPN_RETRY		; User wants more retry
 18808                                  Share_Ok2:
 18809                                  	;call	LCritDisk		; leave critical section
 18810                                  	;retn
 18811                                  	; 18/12/2022
 18812 00002BEE E90CE7                  	jmp	LCritDisk
 18813                                  
 18814                                  ;-----------------------------------------------------------------------------
 18815                                  ; Procedure Name : Check_Access
 18816                                  ;
 18817                                  ; Inputs:
 18818                                  ;	AX is mode
 18819                                  ;	  High NIBBLE of AL (Sharing Mode)
 18820                                  ;		sharing_compat	   file is opened in compatibility mode
 18821                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 18822                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 18823                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 18824                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 18825                                  ;	  Low NIBBLE of AL (Access Mode)
 18826                                  ;		open_for_read	file is opened for reading
 18827                                  ;		open_for_write	file is opened for writing
 18828                                  ;		open_for_both	file is opened for both reading and writing.
 18829                                  ; Function:
 18830                                  ;	Check this access mode for correctness
 18831                                  ; Outputs:
 18832                                  ;	[open_access] = AL input
 18833                                  ;	Carry Clear
 18834                                  ;		Mode is correct
 18835                                  ;		AX unchanged
 18836                                  ;	Carry Set
 18837                                  ;		Mode is bad
 18838                                  ;		AX = error_invalid_access
 18839                                  ; No other registers effected
 18840                                  ;----------------------------------------------------------------------------
 18841                                  
 18842                                  Check_Access_AX:
 18843 00002BF1 A2[6E05]                	MOV	[OPEN_ACCESS],AL
 18844 00002BF4 53                      	PUSH	BX
 18845                                  
 18846                                  ;	If sharing, then test for special sharing mode for FCBs
 18847                                  
 18848 00002BF5 88C3                    	MOV	BL,AL
 18849 00002BF7 80E3F0                  	AND	BL,SHARING_MASK ; 0F0h
 18850 00002BFA 803E[7205]FF            	CMP	byte [FSHARING],-1
 18851 00002BFF 7505                    	JNZ	short CheckShareMode	; not through server call, must be ok
 18852 00002C01 80FB70                  	CMP	BL,SHARING_NET_FCB
 18853 00002C04 7405                    	JZ	short CheckAccessMode	; yes, we have an FCB
 18854                                  CheckShareMode:
 18855 00002C06 80FB40                  	CMP	BL,40h			; is this a good sharing mode?
 18856 00002C09 770D                    	JA	short Make_Bad_Access
 18857                                  CheckAccessMode:
 18858 00002C0B 88C3                    	MOV	BL,AL
 18859 00002C0D 80E30F                  	AND	BL,access_mask
 18860 00002C10 80FB02                  	CMP	BL,2
 18861 00002C13 7703                    	JA	short Make_Bad_Access
 18862 00002C15 5B                      	POP	BX
 18863 00002C16 F8                      	CLC
 18864 00002C17 C3                      	retn
 18865                                  
 18866                                  Make_Bad_Access:
 18867 00002C18 B80C00                  	MOV	AX,error_invalid_access ; 0Ch
 18868 00002C1B 5B                      	POP	BX
 18869 00002C1C F9                      	STC
 18870 00002C1D C3                      	retn
 18871                                  
 18872                                  ;============================================================================
 18873                                  ; DINFO.ASM, MSDOS 6.0, 1991
 18874                                  ;============================================================================
 18875                                  ; 08/08/2018 - Retro DOS v3.0
 18876                                  ; 18/05/2019 - Retro DOS v4.0
 18877                                  
 18878                                  ;**	Low level routine for returning disk drive information from a local
 18879                                  ;	  or NET device
 18880                                  ;
 18881                                  ;	DISK_INFO
 18882                                  ;
 18883                                  ;	  Modification history:
 18884                                  ;
 18885                                  ;		Created: ARR 30 March 1983
 18886                                  
 18887                                  ;	Break	<DISK_INFO -- Get Disk Drive Information>
 18888                                  ;---------------------------------------------------------------------------
 18889                                  ; Procedure Name : DISK_INFO
 18890                                  ;
 18891                                  ; Inputs:
 18892                                  ;	[THISCDS] Points to the Macro List Structure of interest
 18893                                  ;		(It MAY NOT be NUL, error not detected)
 18894                                  ; Function:
 18895                                  ;	Get Interesting Drive Information
 18896                                  ; Returns:
 18897                                  ;	DX = Number of free allocation units
 18898                                  ;	BX = Total Number of allocation units on disk
 18899                                  ;	CX = Sector size
 18900                                  ;	AL = Sectors per allocation unit
 18901                                  ;	AH = FAT ID BYTE
 18902                                  ;	Carry set if error (currently user FAILed to I 24)
 18903                                  ; Segs except ES preserved, others destroyed
 18904                                  ;----------------------------------------------------------------------------
 18905                                  
 18906                                  ;hkn; called from getset.asm and misc.asm. DS has already been set up to 
 18907                                  ;hkn; DOSDATA. 
 18908                                  
 18909                                  DISK_INFO:
 18910                                  	; 08/08/2018 - Retro DOS v3.0
 18911                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 37C5h
 18912                                  
 18913 00002C1E E808E6                  	call	TestNet
 18914 00002C21 7306                    	JNC	short LOCAL_DSK_INFO
 18915                                  
 18916                                  ;IF NOT Installed
 18917                                  ;	transfer NET_DISK_INFO
 18918                                  ;ELSE
 18919                                  	;MOV	AX,(MultNET SHL 8) OR 12
 18920                                  	;INT	2FH
 18921                                  	;return
 18922                                  
 18923 00002C23 B80C11                  	mov     ax,110Ch
 18924 00002C26 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
 18925                                  			; ES:DI -> current directory
 18926                                  			; Return: AL = sectors per cluster, BX = total clusters
 18927                                  			; CX = bytes per sector, DX = number of available clusters
 18928 00002C28 C3                      	retn
 18929                                  ;ENDIF
 18930                                  
 18931                                  LOCAL_DSK_INFO:
 18932 00002C29 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 18933 00002C2E E8B1E6                  	call	ECritDisk
 18934 00002C31 E80E29                  	call	FATREAD_CDS		; perform media check.
 18935 00002C34 7241                    	JC	short CRIT_LEAVE
 18936 00002C36 BB0200                  	MOV	BX,2
 18937 00002C39 E87127                  	call	UNPACK			; Get first FAT sector into CURBUF
 18938 00002C3C 7239                    	JC	short CRIT_LEAVE
 18939 00002C3E C536[E205]              	LDS	SI,[CURBUF]
 18940                                  	;mov	ah,[si+20]
 18941 00002C42 8A6414                  	MOV	AH,[SI+BUFINSIZ]	; get FAT ID BYTE
 18942                                  
 18943                                  ;hkn; SS is DOSDATA
 18944 00002C45 16                      	push	ss
 18945 00002C46 1F                      	pop	ds
 18946                                  	;mov	cx,[es:bp+0Dh]
 18947 00002C47 268B4E0D                	MOV	CX,[ES:BP+DPB.MAX_CLUSTER]
 18948                                  
 18949                                  ; Examine the current free count. If it indicates that we have an invalid
 18950                                  ; count, do the expensive calculation.
 18951                                  
 18952                                  	;mov	dx,[es:bp+1Fh]
 18953 00002C4B 268B561F                	MOV	DX,[ES:BP+DPB.FREE_CNT] ; get free count
 18954 00002C4F 83FAFF                  	CMP	DX,-1			; is it valid?
 18955 00002C52 7404                    	JZ	short DoScan
 18956                                  
 18957                                  ; Check to see if it is in a reasonable range. If so, trust it and return.
 18958                                  ; Otherwise, we need to blast out an internal error message and then recompute
 18959                                  ; the count.
 18960                                  
 18961 00002C54 39CA                    	CMP	DX,CX			; is it in a reasonable range?
 18962 00002C56 7222                    	JB	short GotVal		; yes, trust it.
 18963                                  DoScan:
 18964 00002C58 31D2                    	XOR	DX,DX
 18965 00002C5A 49                      	DEC	CX
 18966                                  SCANFREE:
 18967 00002C5B E84F27                  	call	UNPACK
 18968 00002C5E 7217                    	JC	short CRIT_LEAVE
 18969 00002C60 7501                    	JNZ	short NOTFREECLUS
 18970 00002C62 42                      	INC	DX			; A free one
 18971                                  NOTFREECLUS:
 18972 00002C63 43                      	INC	BX			; Next cluster
 18973 00002C64 E2F5                    	LOOP	SCANFREE
 18974 00002C66 4B                      	DEC	BX			; BX was next cluster. Convert to
 18975                                  ReturnVals:
 18976 00002C67 4B                      	DEC	BX			; count
 18977                                  	;mov	al,[es:bp+4]
 18978 00002C68 268A4604                	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
 18979 00002C6C FEC0                    	INC	AL			; Sectors/cluster
 18980                                  	;mov	cx,[es:bp+2]
 18981 00002C6E 268B4E02                	MOV	CX,[ES:BP+DPB.SECTOR_SIZE] ; Bytes/sector
 18982                                  	;mov	[es:bp+1Fh],dx
 18983 00002C72 2689561F                	MOV	[ES:BP+DPB.FREE_CNT],DX
 18984 00002C76 F8                      	CLC
 18985                                  CRIT_LEAVE:
 18986                                  	;call	LCritDisk
 18987                                  	;retn
 18988                                  	; 17/12/2022
 18989 00002C77 E983E6                  	jmp	LCritDisk
 18990                                  
 18991                                  ; We have correctly computed everything previously. Load up registers for
 18992                                  ; return.
 18993                                  
 18994                                  GotVal: 
 18995 00002C7A 89CB                    	MOV	BX,CX			; get cluster count
 18996 00002C7C EBE9                    	JMP	short ReturnVals
 18997                                  
 18998                                  ;============================================================================
 18999                                  ; ISEARCH.ASM, MSDOS 6.0, 1991
 19000                                  ;============================================================================
 19001                                  ; 22/07/2018 - Retro DOS v3.0
 19002                                  
 19003                                  ;	TITLE	DOS_SEARCH - Internal SEARCH calls for MS-DOS
 19004                                  ;	NAME	DOS_SEARCH
 19005                                  
 19006                                  ;**	Low level routines for doing local and NET directory searches
 19007                                  ;
 19008                                  ;	DOS_SEARCH_FIRST
 19009                                  ;	DOS_SEARCH_NEXT
 19010                                  ;	RENAME_NEXT
 19011                                  ;
 19012                                  ;	Revision history:
 19013                                  ;
 19014                                  ;	    Created: ARR 30 March 1983
 19015                                  ;	    A000	version 4.00  Jan. 1988
 19016                                  ;	    A001	PTM 3564 -- search for fastopen
 19017                                  
 19018                                  ;Installed = TRUE
 19019                                  
 19020                                  ;--------------------------------------------------------------------------
 19021                                  ;
 19022                                  ; Procedure Name : DOS_SEARCH_FIRST
 19023                                  ;
 19024                                  ; Inputs:
 19025                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 19026                                  ;		terminated)
 19027                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 19028                                  ;		( = -1 if current dir not involved, else
 19029                                  ;		 Points to first char after last "/" of current dir part)
 19030                                  ;	[THISCDS] Points to CDS being used
 19031                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 19032                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 19033                                  ;	[DMAADD] Points to 53 byte buffer
 19034                                  ; Function:
 19035                                  ;	Initiate a search for the given file spec
 19036                                  ; Outputs:
 19037                                  ;	CARRY CLEAR
 19038                                  ;	    The 53 bytes ot DMAADD are filled in as follows:
 19039                                  ;
 19040                                  ;	LOCAL
 19041                                  ;	    Drive Byte (A=1, B=2, ...) High bit clear
 19042                                  ;		NEVER STORE DRIVE BYTE AFTER  found_it
 19043                                  ;	    11 byte search name with Meta chars in it
 19044                                  ;	    Search Attribute Byte, attribute of search
 19045                                  ;	    WORD LastEnt value
 19046                                  ;	    WORD DirStart
 19047                                  ;	    4 byte pad
 19048                                  ;	    32 bytes of the directory entry found
 19049                                  ;	NET
 19050                                  ;	    21 bytes First byte has high bit set
 19051                                  ;	    32 bytes of the directory entry found
 19052                                  ;
 19053                                  ;	CARRY SET
 19054                                  ;	    AX = error code
 19055                                  ;		error_no_more_files
 19056                                  ;			No match for this file
 19057                                  ;		error_path_not_found
 19058                                  ;			Bad path (not in curr dir part if present)
 19059                                  ;		error_bad_curr_dir
 19060                                  ;			Bad path in current directory part of path
 19061                                  ; DS preserved, others destroyed
 19062                                  ;---------------------------------------------------------------------------
 19063                                  
 19064                                  ; 24/01/2024
 19065                                  %if 1
 19066                                  	; 17/05/2019 - Retro DOS v4.0
 19067                                  GET_FAST_SEARCH:
 19068                                  	; 22/07/2018
 19069                                  	; MSDOS 6.0
 19070                                  	; 17/12/2022
 19071 00002C7E 36800E[1206]04          	OR	byte [ss:DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)  ; 04h
 19072                                  	;OR	word [ss:DOS34_FLAG],SEARCH_FASTOPEN  ; 400h
 19073                                  					;FO.trigger fastopen ;AN000;
 19074                                  	;call	DOS_SEARCH_FIRST
 19075                                  	;retn
 19076                                  	; 24/01/2024
 19077                                  	; 17/12/2022
 19078                                  	;jmp	DOS_SEARCH_FIRST
 19079                                  %endif
 19080                                  
 19081                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19082                                  	; DOSCODE:6C22h (MSDOS 5.0, MSDOS.SYS)
 19083                                  
 19084                                  DOS_SEARCH_FIRST:
 19085                                  	; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 3826h
 19086                                  
 19087 00002C84 C43E[A205]              	LES	DI,[THISCDS]
 19088 00002C88 83FFFF                  	CMP	DI,-1
 19089 00002C8B 7506                    	JNZ	short TEST_RE_NET2
 19090                                  
 19091                                  ;IF NOT Installed
 19092                                  ;	transfer NET_SEQ_SEARCH_FIRST
 19093                                  ;ELSE
 19094                                  	;mov	ax,1119h
 19095 00002C8D B81911                  	MOV	AX,(MultNET<<8)|25
 19096 00002C90 CD2F                    	INT	2Fh
 19097 00002C92 C3                      	retn
 19098                                  ;ENDIF
 19099                                  
 19100                                  TEST_RE_NET2:
 19101                                  	;test	word [es:di+43h],8000h
 19102                                  	; 17/12/2022
 19103                                  	;test	byte [es:di+44h],80h
 19104                                  	; 28/12/2022
 19105 00002C93 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8
 19106                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 19107 00002C98 7406                    	JZ	short LOCAL_SEARCH_FIRST
 19108                                  
 19109                                  ;IF NOT Installed
 19110                                  ;	transfer NET_SEARCH_FIRST
 19111                                  ;ELSE
 19112                                  	;mov	ax,111Bh
 19113 00002C9A B81B11                  	MOV	AX,(MultNET<<8)|27
 19114 00002C9D CD2F                    	INT	2FH
 19115 00002C9F C3                      	retn
 19116                                  ;ENDIF
 19117                                  	; 18/05/2019 - Retro DOS v4.0
 19118                                  LOCAL_SEARCH_FIRST:
 19119 00002CA0 E83FE6                  	call	ECritDisk
 19120                                  	; MSDOS 6.0
 19121                                  	;;test	word [DOS34_FLAG],400h
 19122                                  	; 17/12/2022
 19123                                  	;test	byte [DOS34_FLAG+1],04h
 19124 00002CA3 F606[1206]04            	test	byte [DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)
 19125                                  	;TEST	word [DOS34_FLAG],SEARCH_FASTOPEN ;AN000;
 19126 00002CA8 7405                    	JZ	short NOFN			;AN000;
 19127                                  	;or	byte [FastOpenFlg],1
 19128 00002CAA 800E[3A0D]01            	OR	byte [FastOpenFlg],FastOpen_Set	;AN000;
 19129                                  NOFN:						;AN000;
 19130 00002CAF C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 19131                                  
 19132                                  ; 03/02/2024
 19133                                  %if 0
 19134                                  	; MSDOS 6.0
 19135                                  	CALL	CHECK_QUESTION		;AN000;;FO. is '?' in path
 19136                                  	JNC	short norm_GETPATH	;AN000;;FO. no
 19137                                  %else
 19138                                  	; 03/02/2024
 19139 00002CB4 16                      	push	ss
 19140 00002CB5 1F                      	pop	ds			;AN000;;FO. ds:si -> final path
 19141 00002CB6 8B36[B205]              	mov	si,[WFP_START]		;AN000;;FO.
 19142                                  getnext:				;AN000;
 19143 00002CBA AC                      	lodsb				;AN000;;FO. get char
 19144 00002CBB 08C0                    	or	al,al			;AN000;;FO. is it null
 19145 00002CBD 7409                    	jz	short NO_Question	;AN000;;FO. yes
 19146 00002CBF 3C3F                    	cmp	al,'?'                  ;AN000;;FO. is '?'
 19147 00002CC1 75F7                    	jne	short getnext 		;AN000;;FO. no
 19148                                  %endif
 19149                                  	;and	byte [FastOpenFlg],80h
 19150 00002CC3 8026[3A0D]80            	AND	byte [FastOpenFlg],Fast_yes ;AN000;;FO. reset fastopen
 19151                                  NO_Question:	; 03/02/2024
 19152                                  norm_GETPATH:
 19153 00002CC8 E81A11                  	call	GETPATH
 19154                                  	; BX = offset NAME1
 19155                                  ;_getdone:
 19156 00002CCB 7318                    	JNC	short find_check_dev
 19157 00002CCD 7511                    	JNZ	short bad_path3
 19158 00002CCF 08C9                    	OR	CL,CL
 19159 00002CD1 740D                    	JZ	short bad_path3
 19160                                  find_no_more:
 19161                                  	;mov	ax,12h
 19162 00002CD3 B81200                  	MOV	AX,error_no_more_files
 19163                                  BadBye:
 19164                                  	; MSDOS 6.0
 19165 00002CD6 368026[3A0D]80          	AND	byte [SS:FastOpenFlg],Fast_yes  ;AN000;;FO. reset fastopen
 19166                                  
 19167 00002CDC F9                      	STC
 19168                                  	;call	LCritDisk
 19169                                  	;retn
 19170                                  	; 18/12/2022
 19171 00002CDD E91DE6                  	jmp	LCritDisk
 19172                                  
 19173                                  bad_path3:
 19174                                  	;mov	ax,3
 19175 00002CE0 B80300                  	MOV	AX,error_path_not_found
 19176 00002CE3 EBF1                    	JMP	short BadBye
 19177                                  
 19178                                  find_check_dev:
 19179 00002CE5 08E4                    	OR	AH,AH
 19180 00002CE7 790A                    	JNS	short found_entry
 19181 00002CE9 C706[4803]FFFF          	MOV	word [LASTENT],-1	; Cause DOS_SEARCH_NEXT to fail
 19182 00002CEF FE06[7005]              	INC	byte [FOUND_DEV]	; Tell DOS_RENAME we found a device
 19183                                  found_entry:
 19184                                  
 19185                                  ; We set the physical drive byte here Instead of after found_it; Doing
 19186                                  ; a search-next may not have wfp_start set correctly
 19187                                  
 19188 00002CF3 C43E[2C03]              	LES	DI,[DMAADD]
 19189 00002CF7 8B36[B205]              	MOV	SI,[WFP_START]		; get pointer to beginning
 19190 00002CFB AC                      	LODSB
 19191 00002CFC 2C40                    	SUB	AL,'A'-1                ; logical drive
 19192 00002CFE AA                      	STOSB				; High bit not set (local)
 19193                                  found_it:
 19194 00002CFF C43E[2C03]              	LES	DI,[DMAADD]
 19195 00002D03 47                      	INC	DI
 19196                                  
 19197                                  	; MSDOS 6.0
 19198 00002D04 1E                      	PUSH	DS				  ;FO.;AN001; save ds
 19199                                  	;test	byte [FastOpenFlg],10h
 19200 00002D05 F606[3A0D]10            	TEST	byte [FastOpenFlg],Set_For_Search ;FO.;AN001; from fastopen
 19201 00002D0A 7408                    	JZ	short notfast			  ;FO.;AN001;
 19202 00002D0C 89DE                    	MOV	SI,BX				  ;FO.;AN001;
 19203 00002D0E 8E1E[E405]              	MOV	DS,[CURBUF+2]			  ;FO.;AN001;
 19204 00002D12 EB03                    	JMP	SHORT movmov			  ;FO.;AN001;
 19205                                  
 19206                                  notfast:
 19207 00002D14 BE[4B05]                	MOV	SI,NAME1		; find_buf 2 = formatted name
 19208                                  movmov:
 19209                                  ; Special E5 code
 19210 00002D17 A4                      	MOVSB
 19211 00002D18 26807DFF05              	CMP	BYTE [ES:DI-1],5
 19212 00002D1D 7505                    	JNZ	short NOTKANJB
 19213 00002D1F 26C645FFE5              	MOV	BYTE [ES:DI-1],0E5H
 19214                                  NOTKANJB:
 19215                                  	;MOV	CX,10
 19216                                  	;REP	MOVSB
 19217                                  	; 03/02/2024
 19218 00002D24 B90500                  	mov	cx,5
 19219 00002D27 F3A5                    	rep	movsw
 19220                                  
 19221                                  	; 08/09/2018
 19222 00002D29 1F                      	POP	DS			;FO.;AN001; restore ds
 19223                                  
 19224 00002D2A A0[6B05]                	MOV	AL,[ATTRIB]
 19225 00002D2D AA                      	STOSB
 19226 00002D2E 50                      	PUSH	AX			; Save AH device info
 19227 00002D2F A1[4803]                	MOV	AX,[LASTENT]
 19228 00002D32 AB                      	STOSW
 19229 00002D33 A1[C205]                	MOV	AX,[DIRSTART]
 19230 00002D36 AB                      	STOSW
 19231                                  ; 4 bytes of 21 byte cont structure left for NET stuff
 19232 00002D37 83C704                  	ADD	DI,4
 19233 00002D3A 58                      	POP	AX			; Recover AH device info
 19234 00002D3B 08E4                    	OR	AH,AH
 19235 00002D3D 781B                    	JS	short DOSREL		; Device entry is DOSGROUP relative
 19236 00002D3F 833E[E205]FF            	CMP	WORD [CURBUF],-1
 19237 00002D44 7510                    	JNZ	short OKSTORE
 19238                                  
 19239                                  	; MSDOS 6.0
 19240 00002D46 F606[3A0D]10            	TEST	byte [FastOpenFlg],Set_For_Search
 19241                                  					;AN000;;FO. from fastopen and is good
 19242 00002D4B 7509                    	JNZ	short OKSTORE		;AN000;;FO.
 19243                                  
 19244                                  	; The user has specified the root directory itself, rather than some
 19245                                  	; contents of it. We can't "find" that.
 19246                                  
 19247 00002D4D 26C745F8FFFF            	MOV	WORD [ES:DI-8],-1	; Cause DOS_SEARCH_NEXT to fail by
 19248                                  					;   stuffing a -1 at Lastent
 19249 00002D53 E97DFF                  	JMP	find_no_more
 19250                                  
 19251                                  OKSTORE:
 19252 00002D56 8E1E[E405]              	MOV	DS,[CURBUF+2]
 19253                                  DOSREL:
 19254                                  	; BX = offset NAME1 (from GETPATH)
 19255 00002D5A 89DE                    	MOV	SI,BX			; SI-> start of entry
 19256                                  
 19257                                  ; NOTE: DOS_RENAME depends on BX not being altered after this point
 19258                                  
 19259                                  	;;mov	cx,32
 19260                                  	;MOV	CX,dir_entry.size
 19261                                  	; 03/02/2024
 19262 00002D5C B91000                  	mov	cx,dir_entry.size>>1
 19263                                  ;;;;; 7/29/86
 19264 00002D5F 89F8                    	MOV	AX,DI			; save the 1st byte addr
 19265                                  	;REP	MOVSB
 19266 00002D61 F3A5                    	rep	movsw
 19267                                  	;
 19268 00002D63 89C7                    	MOV	DI,AX			; restore 1st byte addr
 19269 00002D65 26803D05                	CMP	BYTE [ES:DI],05H	; special char check
 19270 00002D69 7504                    	JNZ	short NO05
 19271 00002D6B 26C605E5                	MOV	BYTE [ES:DI],0E5H	; convert it back to E5
 19272                                  NO05:
 19273                                  
 19274                                  ;;;;; 7/29/86
 19275                                  
 19276                                  ;hkn; FastOpenflg is in DOSDATA use SS
 19277                                  	; 16/12/2022
 19278                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 19279                                  	; MSDOS 6.0
 19280                                  	;AND	byte [SS:FastOpenFlg],Fast_yes ;AN000;;FO. reset fastopen
 19281                                  	; 18/05/2019 - Retro DOS v4.0
 19282 00002D6F 16                      	push	ss
 19283 00002D70 1F                      	pop	ds
 19284                                  	; 16/12/2022
 19285 00002D71 8026[3A0D]80            	AND	byte [FastOpenFlg],Fast_yes
 19286                                  
 19287                                  ;hkn; SS is DOSDATA
 19288                                  	;push	ss
 19289                                  	;pop	ds
 19290                                  	
 19291                                  	; 27/06/2024
 19292                                  	; cf=0
 19293                                  	;CLC
 19294                                  	
 19295                                  	;call	LCritDisk
 19296                                  	;retn
 19297                                  	; 16/12/2022
 19298 00002D76 E984E5                  	jmp	LCritDisk
 19299                                  
 19300                                  ;BREAK <DOS_SEARCH_NEXT - scan for subsequent matches>
 19301                                  ;----------------------------------------------------------------------------
 19302                                  ;
 19303                                  ; Procedure Name : DOS_SEARCH_NEXT
 19304                                  ;
 19305                                  ; Inputs:
 19306                                  ;	[DMAADD] Points to 53 byte buffer returned by DOS_SEARCH_FIRST
 19307                                  ;	    (only first 21 bytes must have valid information)
 19308                                  ; Function:
 19309                                  ;	Look for subsequent matches
 19310                                  ; Outputs:
 19311                                  ;	CARRY CLEAR
 19312                                  ;	    The 53 bytes at DMAADD are updated for next call
 19313                                  ;		(see DOS_SEARCH_FIRST)
 19314                                  ;	CARRY SET
 19315                                  ;	    AX = error code
 19316                                  ;		error_no_more_files
 19317                                  ;			No more files to find
 19318                                  ; DS preserved, others destroyed
 19319                                  ;---------------------------------------------------------------------------
 19320                                  
 19321                                  ;hkn; called from search.asm. DS already set up at this point.
 19322                                  
 19323                                  DOS_SEARCH_NEXT:
 19324 00002D79 C43E[2C03]              	LES	DI,[DMAADD]
 19325 00002D7D 268A05                  	MOV	AL,[ES:DI]
 19326 00002D80 A880                    	TEST	AL,80H			; Test for NET
 19327 00002D82 7406                    	JZ	short LOCAL_SEARCH_NEXT
 19328                                  ;IF NOT Installed
 19329                                  ;	transfer NET_SEARCH_NEXT
 19330                                  ;ELSE
 19331                                  	;mov	ax,111Ch
 19332 00002D84 B81C11                  	MOV	AX,(MultNET<<8)|28
 19333 00002D87 CD2F                    	INT	2FH  ; Multiplex - NETWORK REDIRECTOR - FINDNEXT
 19334                                  		     ; SS = DS = DOS CS, [DTA] = 21-byte findfirst search data
 19335                                  		     ; Return: CF set on error, AX = DOS error code
 19336                                  		     ; CF clear if successful
 19337 00002D89 C3                      	retn
 19338                                  ;ENDIF
 19339                                  
 19340                                  LOCAL_SEARCH_NEXT:
 19341                                  	;AL is drive A=1
 19342                                  	;mov	byte [EXTERR_LOCUS],2
 19343 00002D8A C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 19344 00002D8F E850E5                  	call	ECritDisk
 19345                                  
 19346                                  ;hkn; DummyCDS is in DOSDATA
 19347 00002D92 C706[A205][F304]        	MOV     word [THISCDS],DUMMYCDS
 19348                                  ;hkn; Segment address is DOSDATA - use ds
 19349                                  ;hkn;	MOV     WORD [THISCDS+2],CS
 19350 00002D98 8C1E[A405]              	mov	[THISCDS+2],DS
 19351                                  
 19352 00002D9C 0440                    	ADD	AL,'A'-1
 19353 00002D9E E8783A                  	call	InitCDS
 19354                                  
 19355                                  ;	call	GETTHISDRV		; Set CDS pointer
 19356                                  
 19357 00002DA1 7246                    	JC	short No_files		; Bogus drive letter
 19358 00002DA3 C43E[A205]              	LES	DI,[THISCDS]		; Get CDS pointer
 19359                                  	;les	bp,[es:di+45h]
 19360 00002DA7 26C46D45                	LES	BP,[ES:DI+curdir.devptr] ; Get DPB pointer
 19361 00002DAB E87AD8                  	call	GOTDPB			; [THISDPB] = ES:BP
 19362                                  
 19363                                  	; 16/12/2022
 19364 00002DAE 268A4600                	mov	al,[ES:BP]
 19365                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 19366                                  	;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[ES:BP+0]
 19367 00002DB2 A2[7605]                	mov	[THISDRV],AL
 19368                                  	;mov	word [CREATING],0E500h
 19369 00002DB5 C706[7E05]00E5          	MOV	WORD [CREATING],(DIRFREE*256)+0
 19370 00002DBB C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 19371 00002DC0 C536[2C03]              	LDS	SI,[DMAADD]
 19372 00002DC4 AC                      	LODSB				; Drive Byte
 19373                                  
 19374                                  	;entry	RENAME_NEXT		; Entry used by DOS_RENAME
 19375                                  RENAME_NEXT:
 19376                                  	;context ES
 19377 00002DC5 16                      	push	ss
 19378 00002DC6 07                      	pop	es			; THIS BLOWS ES:BP POINTER TO DPB
 19379                                  
 19380                                  ;hkn; NAME1 is in DOSDATA
 19381 00002DC7 BF[4B05]                	MOV	DI,NAME1
 19382                                  
 19383 00002DCA B90B00                  	MOV	CX,11
 19384 00002DCD F3A4                    	REP	MOVSB			; Search name
 19385 00002DCF AC                      	LODSB				; Attribute
 19386                                  
 19387                                  ;hkn; SS override
 19388 00002DD0 36A2[6B05]              	MOV	[SS:ATTRIB],AL
 19389 00002DD4 AD                      	LODSW				; LastEnt
 19390 00002DD5 09C0                    	OR	AX,AX
 19391                                  	; 03/02/2024
 19392                                  	;JNS	short cont_load
 19393 00002DD7 7810                    	js	short No_files
 19394                                  ;No_files:
 19395                                  	;JMP	find_no_more
 19396                                  
 19397                                  cont_load:
 19398 00002DD9 50                      	PUSH	AX			; Save LastEnt
 19399 00002DDA AD                      	LODSW				; DirStart
 19400 00002DDB 89C3                    	MOV	BX,AX
 19401                                  
 19402                                  ;hkn; SS is DOSDATA
 19403                                  	;context DS
 19404 00002DDD 16                      	push	ss
 19405 00002DDE 1F                      	pop	ds
 19406 00002DDF C42E[8A05]              	LES	BP,[THISDPB]		; Recover ES:BP
 19407                                  	;invoke	SetDirSrch
 19408 00002DE3 E8A20F                  	call	SETDIRSRCH
 19409 00002DE6 7304                    	JNC	short SEARCH_GOON
 19410 00002DE8 58                      	POP	AX			; Clean stack
 19411                                  	;JMP	short No_files
 19412                                  	; 03/02/2024
 19413                                  No_files:
 19414 00002DE9 E9E7FE                  	JMP	find_no_more
 19415                                  
 19416                                  SEARCH_GOON:
 19417 00002DEC E86D12                  	call	STARTSRCH
 19418 00002DEF 58                      	POP	AX
 19419 00002DF0 E8680F                  	call	GETENT
 19420 00002DF3 72F4                    	JC	short No_files
 19421 00002DF5 E8A00E                  	call	NEXTENT
 19422 00002DF8 72EF                    	JC	short No_files
 19423 00002DFA 30E4                    	XOR	AH,AH			; If Search_Next, can't be a DEV
 19424 00002DFC E900FF                  	JMP	found_it ; 10/08/2018
 19425                                  
 19426                                  ; MSDOS 6.0
 19427                                  ;---------------------------------------------------------------------------
 19428                                  ;
 19429                                  ; Procedure Name : CHECK_QUESTION
 19430                                  ;
 19431                                  ; Input: [WFP_START]= pointer to final path
 19432                                  ; Function: check '?' char
 19433                                  ; Output: carry clear, if no '?'
 19434                                  ;	 carry set, if '?' exists
 19435                                  ;---------------------------------------------------------------------------
 19436                                  
 19437                                  ; 03/02/2024
 19438                                  %if 0
 19439                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19440                                  CHECK_QUESTION:
 19441                                  ;hkn;	wfp_start is in DOSDATA;hkn;	MOV	WORD PTR ThisCDS+2,CS
 19442                                  ;hkn;	PUSH	CS			;AN000;;FO.
 19443                                  	push	ss
 19444                                  	POP	DS			;AN000;;FO. ds:si -> final path
 19445                                  	; 16/12/2022
 19446                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 19447                                  	MOV	SI,[WFP_START]		;AN000;;FO.
 19448                                  	;mov	si,[ss:WFP_START]
 19449                                  getnext:				;AN000;
 19450                                  	LODSB				;AN000;;FO. get char
 19451                                  	OR	AL,AL			;AN000;;FO. is it null
 19452                                  	JZ	short NO_Question	;AN000;;FO. yes
 19453                                  	CMP	AL,'?'                  ;AN000;;FO. is '?'
 19454                                  	JNZ	short getnext 		;AN000;;FO. no
 19455                                  	STC				;AN000;;FO.
 19456                                  NO_Question:				;AN000;
 19457                                  	retn				;AN000;;FO.
 19458                                  %endif
 19459                                  
 19460                                  ;============================================================================
 19461                                  ; ABORT.ASM, MSDOS 6.0, 1991
 19462                                  ;============================================================================
 19463                                  ; 23/07/2018 - Retro DOS v3.0
 19464                                  ; 18/05/2019 - Retro DOS v4.0
 19465                                  
 19466                                  ;**
 19467                                  ;
 19468                                  ; Internal Abort call closes all handles and FCBs associated with a process.
 19469                                  ;  If process has NET resources a close all is sent out over the net.
 19470                                  ;
 19471                                  ;   DOS_ABORT
 19472                                  ;
 19473                                  ;   Modification history:
 19474                                  ;
 19475                                  ;       Created: ARR 30 March 1983
 19476                                  ;
 19477                                  ;	M038	SR	10/16/90	Free SFT with the PSP of the process
 19478                                  ;				being terminated only if it is busy.
 19479                                  ;
 19480                                  
 19481                                  ;Break   <DOS_ABORT -- CLOSE all files for process>
 19482                                  ;--------------------------------------------------------------------------
 19483                                  ;
 19484                                  ; Procedure Name : DOS_ABORT
 19485                                  ;
 19486                                  ; Inputs:
 19487                                  ;       [CurrentPDB] set to PID of process aborting
 19488                                  ; Function:
 19489                                  ;       Close all files and free all SFTs for this PID
 19490                                  ; Returns:
 19491                                  ;       None
 19492                                  ; All destroyed except stack
 19493                                  ;---------------------------------------------------------------------------
 19494                                  
 19495                                  DOS_ABORT:
 19496 00002DFF 368E06[3003]            	MOV     ES,[SS:CurrentPDB]	; SS override
 19497 00002E04 268B0E3200              	MOV     CX,[ES:PDB.JFN_Length]  ; Number of JFNs
 19498                                  reset_free_jfn:
 19499 00002E09 89CB                    	MOV     BX,CX
 19500 00002E0B 51                      	PUSH    CX
 19501 00002E0C 4B                      	DEC     BX                      ; get jfn (start with last one)
 19502                                  
 19503 00002E0D E84F37                  	CALL	_$CLOSE
 19504 00002E10 59                      	POP     CX
 19505 00002E11 E2F6                    	LOOP    reset_free_jfn          ; and do 'em all
 19506                                  
 19507                                  ; Note: We do need to explicitly close FCBs. Reasons are as follows: If we
 19508                                  ; are running in the no-sharing no-network environment, we are simulating the
 19509                                  ; 2.0 world and thus if the user doesn't close the file, that is his problem
 19510                                  ; BUT... the cache remains in a state with garbage that may be reused by the
 19511                                  ; next process. We scan the set and blast the ref counts of the FCBs we own.
 19512                                  ;
 19513                                  ; If sharing is loaded, then the following call to close process will
 19514                                  ; correctly close all FCBs. We will then need to walk the list AFTER here.
 19515                                  ;
 19516                                  ; Finally, the following call to NET_Abort will cause an EOP to be sent to all
 19517                                  ; known network resources. These resources are then responsible for cleaning
 19518                                  ; up after this process.
 19519                                  ;
 19520                                  ; Sleazy, eh?
 19521                                  
 19522                                  	;context DS			; SS is DOSDATA
 19523 00002E13 16                      	push	ss
 19524 00002E14 1F                      	pop	ds  ; 09/09/2018
 19525                                  
 19526                                  	;CallInstall Net_Abort, MultNET, 29
 19527 00002E15 B81D11                  	mov	ax,111Dh
 19528 00002E18 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR 
 19529                                  			;	    - CLOSE ALL REMOTE FILES FOR PROCESS
 19530                                  			; DS???, SS = DOS CS
 19531                                  ;if installed
 19532 00002E1A FF1E[A000]              	call	far [JShare+(4*4)]	; 4 = MFTCloseP
 19533                                  ;else
 19534                                  ;	call 	MFTCloseP
 19535                                  ;endif
 19536                                  
 19537                                  ; Scan the FCB cache for guys that belong to this process and zap their ref
 19538                                  ; counts.
 19539                                  					; SS override
 19540 00002E1E 36C43E[4000]            	les     di,[ss:SFTFCB]		; grab the pointer to the table
 19541                                  	;mov	cx,[es:di+4]
 19542 00002E23 268B4D04                	mov     cx,[es:di+SFT.SFCount]
 19543 00002E27 E317                    	jcxz    FCBScanDone
 19544                                  	;lea	di,[di+6]
 19545 00002E29 8D7D06                  	LEA     DI,[DI+SFT.SFTable]	; point at table
 19546 00002E2C 36A1[3C03]              	mov     ax,[SS:PROC_ID]		; SS override
 19547                                  FCBTest:
 19548                                  	;cmp	[es:di+31h],ax
 19549 00002E30 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax ; is this one of ours
 19550 00002E34 7505                    	jnz	short FCBNext		; no, skip it
 19551 00002E36 26C7050000              	mov	word [es:di],0
 19552                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0  ; yes, blast ref count
 19553                                  FCBNext:
 19554 00002E3B 83C73B                  	add     di,SF_ENTRY.size ; 59 (for MSDOS 6.0)
 19555 00002E3E E2F0                    	loop    FCBTest
 19556                                  FCBScanDone:
 19557                                  
 19558                                  ; Walk the SFT to eliminate all busy SFT's for this process.
 19559                                  
 19560 00002E40 31DB                    	XOR     BX,BX
 19561                                  Scan:
 19562 00002E42 53                      	push    bx
 19563 00002E43 E89536                  	call	SFFromSFN
 19564 00002E46 5B                      	pop     bx
 19565                                  	;jnc	short Scan1
 19566                                  	;retn
 19567                                  
 19568                                  	; 18/12/2022
 19569                                  	;jc	short NO_Question ; retn
 19570                                  	; 03/02/2024
 19571 00002E47 7234                    	jc	short RET2
 19572                                  
 19573                                  ;M038
 19574                                  ; Do what the comment above says, check for busy state
 19575                                  
 19576                                  Scan1:
 19577                                  	;cmp	word [es:di],0
 19578                                  	;jz	short scan_next  ; MSDOS 3.3
 19579                                  	; MSDOS 6.0
 19580 00002E49 26833DFF                	cmp	word [es:di],sf_busy ; -1
 19581                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy
 19582                                  				; Is Sft busy? ;M038
 19583 00002E4D 7519                    	jnz	short scan_next
 19584                                  ;
 19585                                  ; we have a SFT that is busy. See if it is for the current process
 19586                                  ;
 19587 00002E4F 36A1[3C03]              	mov     ax,[SS:PROC_ID]		; SS override
 19588                                  	;cmp	[es:di+31h],ax
 19589 00002E53 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax
 19590 00002E57 750F                    	jnz	short scan_next
 19591 00002E59 36A1[3E03]              	mov     ax,[SS:USER_ID]		; SS override
 19592                                  	;cmp	[es:di+2Fh],ax
 19593 00002E5D 2639452F                	cmp	[es:di+SF_ENTRY.sf_UID],ax
 19594 00002E61 7505                    	jnz	short scan_next
 19595                                  
 19596                                  ; This SFT is labelled as ours.
 19597                                  
 19598 00002E63 26C7050000              	mov	word [es:di],0
 19599                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0
 19600                                  scan_next:
 19601 00002E68 43                      	inc     bx
 19602 00002E69 EBD7                    	jmp     short Scan
 19603                                  
 19604                                  ;============================================================================
 19605                                  ; CLOSE.ASM, MSDOS 6.0, 1991
 19606                                  ;============================================================================
 19607                                  ; 23/07/2018 - Retro DOS v3.0
 19608                                  ; 18/05/2019 - Retro DOS v4.0
 19609                                  
 19610                                  ;**	Internal Close and Commit calls to close a local or NET SFT.
 19611                                  ;
 19612                                  ;	DOS_CLOSE
 19613                                  ;	DOS_COMMIT
 19614                                  ;	FREE_SFT
 19615                                  ;	SetSFTTimes
 19616                                  ;
 19617                                  ;	Revision history:
 19618                                  ;
 19619                                  ;	   AN000  version 4.00	Jan. 1988
 19620                                  ;	   A005   PTM 3718 --- lost clusters when fastopen installed
 19621                                  ;	   A011   PTM 4766 --- C2 fastopen problem
 19622                                  
 19623                                  ;Installed = TRUE
 19624                                  
 19625                                  ;Break <DOS_CLOSE -- CLOSE FILE from SFT>
 19626                                  ;---------------------------------------------------------------------------
 19627                                  ;
 19628                                  ; Procedure Name : DOS_CLOSE
 19629                                  ;
 19630                                  ; Inputs:
 19631                                  ;	[THISSFT] set to the SFT for the file being used
 19632                                  ; Function:
 19633                                  ;	Close the indicated file via the SFT
 19634                                  ; Returns:
 19635                                  ;	sf_ref_count decremented otherwise
 19636                                  ;	ES:DI point to SFT
 19637                                  ;	Carry set if error
 19638                                  ;	    AX has error code
 19639                                  ; DS preserved, others destroyed
 19640                                  ;---------------------------------------------------------------------------
 19641                                  
 19642                                  ;hkn; DOS_CLOSE called from fcbio.asm and handle.asm. DS already set up.
 19643                                  
 19644                                  ; 18/05/2019 - Retro DOS v4.0
 19645                                  ; DOSCODE:6E2Eh (MSDOS 6.21, MSDOS.SYS)
 19646                                  
 19647                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19648                                  ; DOSCODE:6E1Ah (MSDOS 5.0, MSDOS.SYS)
 19649                                  
 19650                                  ; 23/07/2018 - IBMDOS.COM (MSDOS 3.3), 1987 - Offset 39D0h
 19651                                  
 19652                                  DOS_CLOSE:
 19653 00002E6B C43E[9E05]              	LES	DI,[THISSFT]
 19654                                  	;mov	bx,[ES:DI+5]
 19655 00002E6F 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 19656                                  
 19657                                  ; Network closes are handled entirely by the net code.
 19658                                  
 19659                                  	;;test	bx,8000h
 19660                                  	;TEST	BX,sf_isnet
 19661                                  	; 17/12/2022
 19662                                  	;test	bh,80h
 19663 00002E73 F6C780                  	test	bh,(sf_isnet>>8)
 19664 00002E76 7406                    	JZ	short LocalClose
 19665                                  
 19666                                  	;CallInstall Net_Close,MultNET,6
 19667 00002E78 B80611                  	mov     ax,1106h
 19668 00002E7B CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE FILE
 19669                                  			; ES:DI -> SFT
 19670                                  			; SFT DPB field -> DPB of drive containing file
 19671                                  			; Return: CF set on error, AX = DOS error code
 19672                                  			; CF clear if successful
 19673                                  RET2:		; 03/02/2024
 19674 00002E7D C3                      	retn
 19675                                  
 19676                                  ; All closes release the sharing information.
 19677                                  ; No commit releases sharing information
 19678                                  ;
 19679                                  ; All closes decrement the ref count.
 19680                                  ; No commit decrements the ref count.
 19681                                  
 19682                                  LocalClose:
 19683 00002E7E E861E4                  	call	ECritDisk
 19684 00002E81 E85701                  	CALL	SetSFTTimes
 19685 00002E84 E8D800                  	CALL	FREE_SFT		; dec ref count or mark as busy
 19686                                  
 19687                                  ;hkn; SS is DOSDATA
 19688                                  	;Context DS
 19689 00002E87 16                      	push	ss
 19690 00002E88 1F                      	pop	ds
 19691                                  
 19692 00002E89 50                      	push	ax
 19693 00002E8A 53                      	push	bx
 19694 00002E8B E8E042                  	call	ShareEnd
 19695 00002E8E 5B                      	pop	bx
 19696 00002E8F 58                      	pop	ax
 19697                                  
 19698                                  ; Commit enters here. AX from commit MUST be <> 1, BX is flags word
 19699                                  
 19700                                  CloseEntry:
 19701 00002E90 50                      	PUSH	AX
 19702                                  
 19703                                  ; File clean or device does not get stamped nor disk looked at.
 19704                                  
 19705                                  	;test	bx,0C0h
 19706                                  	; 17/12/2022
 19707 00002E91 F6C3C0                  	test	bl,devid_file_clean+devid_device
 19708                                  	;TEST	BX,devid_file_clean+devid_device
 19709 00002E94 7403                    	JZ	short rdir
 19710                                  	; 14/11/2022
 19711 00002E96 E9B400                  	JMP	FREE_SFT_OK		; either clean or device
 19712                                  	;jnz	short FREE_SFT_OK ; 24/07/2019	
 19713                                  
 19714                                  ; Retrieve the directory entry for the file
 19715                                  
 19716                                  rdir:
 19717 00002E99 E8D000                  	CALL	DirFromSFT
 19718                                  	;mov	al,5
 19719 00002E9C B005                    	MOV	AL,error_access_denied
 19720 00002E9E 7303                    	JNC	short clook
 19721                                  	; 14/11/2022
 19722 00002EA0 E9AB00                  	JMP	CloseFinish		; pretend the close worked.
 19723                                  	;jc	short CloseFinish ; 24/07/2019
 19724                                  clook:
 19725                                  
 19726                                  ; ES:DI points to entry
 19727                                  ; DS:SI points to SFT
 19728                                  ; ES:BX points to buffer header
 19729                                  
 19730 00002EA3 57                      	push	di
 19731 00002EA4 56                      	push	si
 19732                                  	;lea	si,[si+20h]
 19733 00002EA5 8D7420                  	LEA	SI,[SI+SF_ENTRY.sf_name]
 19734                                  
 19735                                  ; ES:DI point to directory entry
 19736                                  ; DS:SI point to unpacked name
 19737                                  
 19738 00002EA8 E832E3                  	call	XCHGP
 19739                                  
 19740                                  ; ES:DI point to unpacked name
 19741                                  ; DS:SI point to directory entry
 19742                                  
 19743 00002EAB E8480E                  	call	MetaCompare
 19744 00002EAE E82CE3                  	call	XCHGP
 19745 00002EB1 5E                      	pop	si
 19746 00002EB2 5F                      	pop	di
 19747 00002EB3 740C                    	JZ	short CLOSE_GO		; Name OK
 19748                                  Bye:	
 19749 00002EB5 89F7                    	MOV	DI,SI
 19750 00002EB7 1E                      	PUSH	DS
 19751 00002EB8 07                      	POP	ES			; ES:DI points to SFT
 19752 00002EB9 16                      	PUSH	SS
 19753 00002EBA 1F                      	POP	DS
 19754 00002EBB F9                      	STC
 19755                                  	;mov	al,2
 19756 00002EBC B002                    	MOV	AL,error_file_not_found
 19757 00002EBE E98D00                  	JMP	CloseFinish ; 24/07/2019
 19758                                  
 19759                                  	; 18/05/2019 - Retro DOS v4.0
 19760                                  CLOSE_GO:
 19761                                  	; 03/02/2024
 19762                                  	;mov	al,[si+4]
 19763 00002EC1 8A4404                  	mov	al,[si+SF_ENTRY.sf_attr]
 19764                                  	
 19765                                  	; MSDOS 6.0
 19766                                  	;test	word [si+2],8000h
 19767                                  	;TEST	word [SI+SF_ENTRY.sf_mode],sf_isFCB ; FCB ?
 19768                                  	; 17/12/2022
 19769                                  	;test	byte [si+3],80h
 19770 00002EC4 F6440380                	test	byte [SI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8) ; FCB ?
 19771 00002EC8 740A                    	JZ	short nofcb		; no, set dir attr, sf_attr
 19772                                  	; MSDOS 3.3 & MSDOS 6.0
 19773                                  	;mov	ch,[es:di+0Bh]
 19774 00002ECA 268A6D0B                	MOV	CH,[ES:DI+dir_entry.dir_attr]
 19775                                  
 19776                                  	; 03/02/2024
 19777                                  	;;mov	al,[si+4]
 19778                                  	;MOV	AL,[SI+SF_ENTRY.sf_attr]
 19779                                  
 19780                                  ;hkn; SS override
 19781 00002ECE 36A2[6B05]              	MOV	[SS:ATTRIB],AL
 19782                                  	; MSDOS 3.3
 19783                                  	;;call	MatchAttributes
 19784                                  	;;JNZ	short Bye		; attributes do not match
 19785                                  	; 18/05/2019
 19786 00002ED2 EB04                    	JMP	SHORT setattr		;FT.
 19787                                  nofcb:
 19788                                  	; 03/02/2024
 19789                                  	; MSDOS 6.0
 19790                                  	;;mov	al,[si+4]
 19791                                  	;MOV	AL,[SI+SF_ENTRY.sf_attr] ;FT.		;AN000;
 19792                                  
 19793 00002ED4 2688450B                	MOV	[ES:DI+dir_entry.dir_attr],AL ;FT.	;AN000;
 19794                                  setattr:
 19795                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19796                                  	;or	byte [es:di+0Bh],20h
 19797 00002ED8 26804D0B20              	OR	BYTE [ES:DI+dir_entry.dir_attr],attr_archive ;Set archive
 19798                                  	; MSDOS 6.0
 19799                                  	;mov	ax,[es:di+1Ah]
 19800 00002EDD 268B451A                	MOV	AX,[ES:DI+dir_entry.dir_first] ;AN011
 19801                                  					;F.O. save old first cluster
 19802                                  ;hkn; SS override
 19803 00002EE1 36A3[BE0F]              	MOV	[SS:OLD_FIRSTCLUS],AX	;AN011;F.O. save old first cluster
 19804                                  
 19805                                  ; 03/02/2024
 19806                                  %if 0
 19807                                  	;mov	ax,[si+0Bh]
 19808                                  	MOV	AX,[SI+SF_ENTRY.sf_firclus]
 19809                                  	;mov	[es:di+1Ah],ax
 19810                                  	MOV	[ES:DI+dir_entry.dir_first],AX	;Set firclus pointer
 19811                                  	;mov	ax,[si+11h]
 19812                                  	MOV	AX,[SI+SF_ENTRY.sf_size]
 19813                                  	;mov	[es:di+1Ch],ax
 19814                                  	MOV	[ES:DI+dir_entry.dir_size_l],AX	;Set size
 19815                                  	;mov	ax,[si+13h]
 19816                                  	MOV	AX,[SI+SF_ENTRY.sf_size+2]
 19817                                  	;mov	[es:di+1Eh],ax
 19818                                  	MOV	[ES:DI+dir_entry.dir_size_h],AX
 19819                                  	;mov	ax,[si+0Fh]
 19820                                  	MOV	AX,[SI+SF_ENTRY.sf_date]
 19821                                  	;mov	[es:di+18h],ax
 19822                                  	MOV	[ES:DI+dir_entry.dir_date],AX	;Set date
 19823                                  	;mov	ax,[si+0Dh]
 19824                                  	MOV	AX,[SI+SF_ENTRY.sf_time]
 19825                                  	;mov	[es:di+16h],ax
 19826                                  	MOV	[ES:DI+dir_entry.dir_time],AX	;Set time
 19827                                  %else
 19828                                  	; 03/02/2024 - Retro DOS v4.2
 19829 00002EE5 56                      	push	si
 19830 00002EE6 83C60B                  	add	si,0Bh
 19831 00002EE9 AD                      	lodsw	; [si+SF_ENTRY.sf_firclus]
 19832                                  	;mov	[es:di+1Ah],ax
 19833 00002EEA 2689451A                	mov	[es:di+dir_entry.dir_first],ax	; Set first cluster
 19834 00002EEE AD                      	lodsw	; [si+SF_ENTRY.sf_time]
 19835 00002EEF 26894516                	mov	[es:di+dir_entry.dir_time],ax	; Set time
 19836 00002EF3 AD                      	lodsw	; [si+SF_ENTRY.sf_date]
 19837 00002EF4 26894518                	mov	[es:di+dir_entry.dir_date],ax	; Set date
 19838 00002EF8 AD                      	lodsw	; [si+SF_ENTRY.sf_size]
 19839 00002EF9 2689451C                	mov	[es:di+dir_entry.dir_size_l],ax	; Set size
 19840 00002EFD AD                      	lodsw	; [si+SF_ENTRY.sf_size+2]
 19841 00002EFE 2689451E                	mov	[es:di+dir_entry.dir_size_h],ax
 19842 00002F02 5E                      	pop	si
 19843                                  %endif
 19844                                  
 19845                                  	; MSDOS 6.0
 19846                                  ;; File Tagging
 19847 00002F03 26F6470540              	TEST	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty
 19848                                  				  ;LB. if already dirty		    ;AN000;
 19849 00002F08 7508                    	JNZ	short yesdirty4	  ;LB.  don't increment dirty count ;AN000;
 19850                                  	; 02/06/2019
 19851 00002F0A E8B62A                  	call	INC_DIRTY_COUNT   ;LB.				    ;AN000;
 19852                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19853                                  	;or	byte [es:bx+5],40h
 19854 00002F0D 26804F0540              	OR	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty
 19855                                  yesdirty4:
 19856 00002F12 1E                      	push	ds
 19857 00002F13 56                      	push	si
 19858                                  	; MSDOS 6.0
 19859                                  	;mov	cx,[si+0Bh]
 19860                                  	; 07/12/2022
 19861 00002F14 8B4C0B                  	MOV	CX,[SI+SF_ENTRY.sf_firclus] ; do this for Fastopen
 19862                                  ;hkn; SS override
 19863 00002F17 36A0[7605]              	MOV	AL,[SS:THISDRV]
 19864                                  	; MSDOS 3.3 
 19865                                  	;push	ss
 19866                                  	;pop	ds
 19867                                  	;MOV	AL,[THISDRV]
 19868                                  ;;; 10/1/86  update fastopen cache
 19869                                  	; MSDOS 3.3 & MSDOS 6.0
 19870 00002F1B 52                      	PUSH	DX
 19871 00002F1C B400                    	MOV	AH,0			; dir entry update
 19872 00002F1E 88C2                    	MOV	DL,AL			; drive number A=0, B=1,,,
 19873                                  	; MSDOS 6.0
 19874 00002F20 09C9                    	OR	CX,CX			;AN005; first cluster 0; may be truncated
 19875 00002F22 750C                    	JNZ	short do_update2	;AN005; no, do update
 19876 00002F24 B403                    	MOV	AH,3			;AN005; do a delete cache entry
 19877                                  	; 27/06/2024
 19878                                  	;;;
 19879                                  	;;mov	di,[si+1Bh]
 19880                                  	;MOV	DI,[SI+SF_ENTRY.sf_dirsec] ;AN005; cx:di = dir sector
 19881                                  	;;mov	cx,[si+1Dh]
 19882                                  	;MOV	CX,[SI+SF_ENTRY.sf_dirsec+2] ;AN005;
 19883 00002F26 C57C1B                  	lds	di,[si+SF_ENTRY.sf_dirsec]
 19884 00002F29 8CD9                      	mov	cx,ds
 19885                                  	;;;
 19886                                  	;mov	dh,[si+1Fh]
 19887 00002F2B 8A741F                  	MOV	DH,[SI+SF_ENTRY.sf_dirpos] ;AN005; dh = dir pos
 19888 00002F2E EB0E                    	JMP	SHORT do_update 	;AN011;F.O.
 19889                                  
 19890                                  do_update2:				;AN011;F.O.
 19891                                  ;hkn; SS override fort OLD_FIRSTCLUS
 19892                                  	; 
 19893 00002F30 363B0E[BE0F]            	CMP	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O. same as old first clusetr?
 19894 00002F35 7407                    	JZ	short do_update		;AN011;F.O. yes
 19895 00002F37 B402                    	MOV	AH,2			;AN011;F.O. delete the old entry
 19896 00002F39 368B0E[BE0F]            	MOV	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O.
 19897                                  do_update:				;AN005;
 19898                                  ;hkn; SS is DOSDATA
 19899                                  	;Context DS
 19900 00002F3E 16                      	push	ss
 19901 00002F3F 1F                      	pop	ds
 19902                                  	; MSDOS 3.3 & MSDOS 6.0
 19903 00002F40 E822F7                  	call	FastOpen_Update 	; invoke fastopen
 19904 00002F43 5A                      	POP	DX
 19905                                  
 19906                                  ;;; 10/1/86  update fastopen cache
 19907 00002F44 E86E29                  	call	FLUSHBUF		; flush all relevant buffers
 19908 00002F47 5F                      	pop	di
 19909 00002F48 07                      	pop	es
 19910                                  	;mov	al,5
 19911 00002F49 B005                    	MOV	AL,error_access_denied
 19912 00002F4B 7201                    	JC	short CloseFinish
 19913                                  FREE_SFT_OK:
 19914 00002F4D F8                      	CLC				; signal no error.
 19915                                  CloseFinish:
 19916                                  
 19917                                  ; Indicate to the device that the SFT is being closed.
 19918                                  
 19919                                  ;;;; 7/21/86
 19920 00002F4E 9C                      	PUSHF				; save flag from DirFromSFT
 19921 00002F4F E83E15                  	call	DEV_CLOSE_SFT
 19922 00002F52 9D                      	POPF
 19923                                  ;;;; 7/21/86
 19924                                  ;
 19925                                  ; See if the ref count indicates that we have busied the SFT. If so, mark the
 19926                                  ; SFT as being free. Note that we do NOT need to be in critSFT as we are ONLY
 19927                                  ; going to be moving from busy to free.
 19928                                  ;
 19929 00002F53 59                      	POP	CX			; get old ref count
 19930 00002F54 9C                      	PUSHF
 19931                                  	; 03/02/2024
 19932                                  	;DEC	CX			; if cx != 1
 19933                                  	;JNZ	short NoFree		; then do NOT free SFT
 19934 00002F55 E203                    	loop	NoFree ; PCDOS 7.1 IBMDOS.COM
 19935                                  
 19936 00002F57 26890D                  	mov	[es:di],cx ; 0
 19937                                  	;MOV	[ES:DI+SF_ENTRY.sf_ref_Count],CX ; mov [es:di+0],cx
 19938                                  NoFree:
 19939 00002F5A E8A0E3                  	call	LCritDisk
 19940 00002F5D 9D                      	POPF
 19941 00002F5E C3                      	retn
 19942                                  
 19943                                  ;---------------------------------------------------------------------------
 19944                                  ;
 19945                                  ; Procedure Name : FREE_SFT
 19946                                  ;
 19947                                  ; ES:DI -> SFT. Decs sft_ref_count. If the count goes to 0, mark it as busy.
 19948                                  ; Flags preserved. Return old ref count in AX
 19949                                  ;
 19950                                  ; Note that busy is indicated by the SFT ref count being -1.
 19951                                  ;
 19952                                  ;---------------------------------------------------------------------------
 19953                                  
 19954                                  FREE_SFT:
 19955 00002F5F 9C                      	PUSHF		; Save carry state
 19956 00002F60 268B05                  	mov	ax,[es:di]
 19957                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 19958 00002F63 48                      	DEC	AX
 19959 00002F64 7501                    	JNZ	short SetCount
 19960 00002F66 48                      	DEC	AX
 19961                                  SetCount:
 19962 00002F67 268705                  	xchg	ax,[es:di]
 19963                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 19964 00002F6A 9D                      	POPF
 19965 00002F6B C3                      	retn
 19966                                  
 19967                                  	; 18/05/2019 - Retro DOS v4.0
 19968                                  
 19969                                  ;----------------------------------------------------------------------------
 19970                                  ;
 19971                                  ; Procedure Name : DirFromSFT
 19972                                  ;
 19973                                  ;   DirFromSFT - locate a directory entry given an SFT.
 19974                                  ;
 19975                                  ;   Inputs:	ES:DI point to SFT
 19976                                  ;		DS = DOSDATA
 19977                                  ;   Outputs:
 19978                                  ;		EXTERR_LOCUS = errLOC_Disk
 19979                                  ;		CurBuf points to buffer
 19980                                  ;		Carry Clear -> operation OK
 19981                                  ;		    ES:DI point to entry
 19982                                  ;		    ES:BX point to buffer
 19983                                  ;		    DS:SI point to SFT
 19984                                  ;		Carry SET   -> operation failed
 19985                                  ;		    registers trashified
 19986                                  ;   Registers modified: ALL
 19987                                  ;----------------------------------------------------------------------------
 19988                                  
 19989                                  DirFromSFT:
 19990                                  	;mov	byte [EXTERR_LOCUS],2
 19991 00002F6C C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 19992 00002F71 06                      	push	es
 19993 00002F72 57                      	push	di
 19994                                  	; MSDOS 3.3
 19995                                  	;;mov	dx,[es:di+1Dh]
 19996                                  	;MOV	dx,[ES:DI+SF_ENTRY.sf_dirsec]
 19997                                  	; MSDOS 6.0
 19998                                  	;mov	dx,[es:[di+1Dh]
 19999 00002F73 268B551D                	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec+2]  ;F.C. >32mb
 20000 00002F77 8916[0706]              	MOV	[HIGH_SECTOR],DX		 ;F.C. >32mb
 20001                                  	; 04/02/2024
 20002 00002F7B 52                      	push	dx
 20003                                  	;mov	dx,[es:di+1Bh]
 20004 00002F7C 268B551B                	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec]
 20005                                  	; 04/02/2024
 20006                                  	; 19/05/2019
 20007                                  	;PUSH	word [HIGH_SECTOR]	;F.C. >32mb
 20008                                  	; MSDOS 3.3 & MSDOS 6.0
 20009 00002F80 52                      	PUSH	DX
 20010 00002F81 E8AE25                  	call	FATREAD_SFT		; ES:BP points to DPB, [THISDRV] set
 20011                                  					; [THISDPB] set
 20012 00002F84 5A                      	POP	DX
 20013 00002F85 8F06[0706]              	POP	word [HIGH_SECTOR]	;F.C. >32mb
 20014 00002F89 721E                    	JC	short PopDone
 20015                                  	; 22/09/2023
 20016                                  	;XOR	AL,AL	; *		; Pre read
 20017                                  	;;mov	byte [ALLOWED],18h
 20018                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 20019                                  	;call	GETBUFFR
 20020                                  	; 22/09/2023
 20021 00002F8B E82328                  	call	GETBUFFER ; * 		; Pre read
 20022 00002F8E 7219                    	JC	short PopDone
 20023 00002F90 5E                      	pop	si
 20024 00002F91 1F                      	pop	ds			; Get back SFT pointer
 20025                                  
 20026                                  ;hkn; SS override
 20027 00002F92 36C43E[E205]            	LES	DI,[SS:CURBUF]
 20028                                  	;or	byte [es:di+5],4
 20029 00002F97 26804D0504              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 20030 00002F9C 89FB                    	MOV	BX,DI			; ES:BX point to buffer header
 20031                                  	;;lea	di,[di+16] ; MSDOS 3.3
 20032                                  	;lea	di,[di+20] ; MSDOS 6.0
 20033 00002F9E 8D7D14                  	LEA	DI,[DI+BUFINSIZ] 	; Point to buffer
 20034                                  	;mov	al,32
 20035 00002FA1 B020                    	MOV	AL,dir_entry.size
 20036                                  	;mul	byte [si+1Fh] ; MSDOS 6.0
 20037 00002FA3 F6641F                  	MUL	byte [SI+SF_ENTRY.sf_dirpos]
 20038 00002FA6 01C7                    	ADD	DI,AX			; Point at the entry
 20039 00002FA8 C3                      	retn				; carry is clear
 20040                                  PopDone:
 20041 00002FA9 5F                      	pop	di
 20042 00002FAA 07                      	pop	es
 20043                                  PopDone_retn:
 20044 00002FAB C3                      	retn
 20045                                  
 20046                                  ;----------------------------------------------------------------------------
 20047                                  ;
 20048                                  ;**	DOS_Commit - UPdate Directory Entries
 20049                                  ;
 20050                                  ;	ENTRY	same as DOS_CLOSE (??? BUGBUG - update this jgl)
 20051                                  ;		(DS) = DOSGROUP
 20052                                  ;	EXIT	Same as DOS_CLOSE except ref_count field is not altered
 20053                                  ;	USES	all but DS
 20054                                  ;
 20055                                  ;----------------------------------------------------------------------------
 20056                                  
 20057                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20058                                  ; DOSCODE:6F72h (MSDOS 5.0, MSDOS.SYS)
 20059                                  
 20060                                  DOS_COMMIT:
 20061                                  	;hkn; called from srvcall. DS already set up.
 20062 00002FAC C43E[9E05]              	LES	DI,[THISSFT]
 20063                                  	;mov	bx,[es:di+5]
 20064 00002FB0 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 20065                                  	;test	bx,0C0h
 20066                                  	; 17/12/2022
 20067 00002FB4 F6C3C0                  	test	bl,devid_file_clean+devid_device ;Clears carry
 20068                                  	;TEST	BX,devid_file_clean+devid_device ;Clears carry
 20069 00002FB7 75F2                    	jnz	short PopDone_retn
 20070                                  	;test	bx,8000h
 20071                                  	; 17/12/2022
 20072                                  	;test	bh,80h
 20073 00002FB9 F6C780                  	test	bh,(sf_isnet>>8) ; 80h
 20074                                  	;TEST	BX,sf_isnet ; 8000h
 20075 00002FBC 7406                    	JZ	short LOCAL_COMMIT
 20076                                  
 20077                                  ;IF NOT Installed
 20078                                  ;	transfer NET_COMMIT
 20079                                  ;ELSE
 20080                                  	;mov	ax,1107h
 20081 00002FBE B80711                  	MOV	AX,(MultNET<<8)|7
 20082 00002FC1 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
 20083                                  			; ES:DI -> SFT
 20084                                  			; SFT DPB field -> DPB of drive containing file
 20085                                  			; Return: CF set on error, AX = DOS error code
 20086                                  			; CF clear if successful
 20087                                  localcommit_retn: ; 18/12/2022	
 20088 00002FC3 C3                      	retn
 20089                                  ;ENDIF
 20090                                  
 20091                                  ; Perform local commit operation by doing a close but not releaseing the SFT.
 20092                                  ; There are three ways we can do this. One is to enter a critical section to
 20093                                  ; protect a potential free. The second is to increment the ref count to mask
 20094                                  ; the close decrementing.
 20095                                  ;
 20096                                  ; The proper way is to let the caller's of close decide if a decrement should
 20097                                  ; be done. We do this by providing another entry into close after the
 20098                                  ; decrement and after the share information release.
 20099                                  
 20100                                  ; DOSCODE:6FA0h (MSDOS 6.21, MSDOS.SYS)
 20101                                  ; DOSCODE:6F8Ch (MSDOS 5.0, MSDOS.SYS) 
 20102                                  
 20103                                  LOCAL_COMMIT:
 20104 00002FC4 E81BE3                  	call	ECritDisk
 20105                                  	; MSDOS 6.0
 20106 00002FC7 E818E3                  	call	ECritDisk	;PTM.
 20107 00002FCA E80E00                  	call	SetSFTTimes
 20108 00002FCD B8FFFF                  	MOV	AX,-1
 20109 00002FD0 E8BDFE                  	call	CloseEntry
 20110                                  	; MSDOS 6.0
 20111 00002FD3 9C                      	PUSHF			;PTM.				;AN000;
 20112 00002FD4 E8B114                  	call	DEV_OPEN_SFT	;PTM.  increment device count	;AN000;
 20113 00002FD7 9D                      	POPF			;PTM.				;AN000;
 20114                                  	;call	LCritDisk	;PTM.				;AN000;
 20115                                  	; 18/12/2022
 20116 00002FD8 E922E3                  	jmp	LCritDisk
 20117                                  ;localcommit_retn:
 20118                                  ;	retn
 20119                                  
 20120                                  ;Break	<SetSFTTimes - signal a change in the times for an SFT>
 20121                                  ;----------------------------------------------------------------------------
 20122                                  ;
 20123                                  ; Procedure Name : SetSFTTimes
 20124                                  ;
 20125                                  ;   SetSFTTimes - Examine the flags for a SFT and set the time appropriately.
 20126                                  ;   Reflect these times in other SFT's for the same file.
 20127                                  ;
 20128                                  ;   Inputs:	ES:DI point to SFT
 20129                                  ;		BX = sf_flags set apprpriately
 20130                                  ;   Outputs:	Set sft times to current time if File & dirty & !nodate
 20131                                  ;   Registers modified: All except ES:DI, BX, AX
 20132                                  ;
 20133                                  ;----------------------------------------------------------------------------
 20134                                  
 20135                                  	; 04/02/2024 - Retro DOS v4.2
 20136                                  
 20137                                  SetSFTTimes:
 20138                                  
 20139                                  ; 04/02/2024
 20140                                  %if 0
 20141                                  ;	File clean or device does not get stamped nor disk looked at.
 20142                                  	
 20143                                  	;test	bx,0C0h
 20144                                  	; 17/12/2022
 20145                                  	test	bl,devid_file_clean+devid_device
 20146                                  	;TEST	BX,devid_file_clean+devid_device
 20147                                  	;retnz				; clean or device => no timestamp
 20148                                  	jnz	short localcommit_retn
 20149                                  
 20150                                  ;	file and dirty. See if date is good
 20151                                  
 20152                                  	;test	bx,4000h
 20153                                  	; 17/12/2022
 20154                                  	;test	bh,40h
 20155                                  	test	bh,(sf_close_nodate>>8)
 20156                                  	;TEST	BX,sf_close_nodate
 20157                                  	;retnz				; nodate => no timestamp
 20158                                  	jnz	short localcommit_retn
 20159                                  %else
 20160                                  	; 04/02/2024
 20161                                  	; (PCDOS 7.1 IBMDOS.COM)
 20162                                  	;test	bx,40C0h
 20163 00002FDB F7C3C040                	test	bx,sf_close_nodate+devid_file_clean+devid_device
 20164 00002FDF 75E2                    	jnz	short localcommit_retn
 20165                                  %endif
 20166                                  
 20167 00002FE1 50                      	push	ax
 20168 00002FE2 53                      	push	bx
 20169 00002FE3 E8FADA                  	call	DATE16			; Date/Time to AX/DX
 20170                                  	;mov	[es:di+0Fh],ax
 20171 00002FE6 2689450F                	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 20172                                  	;mov	[es:di+0Dh],dx
 20173 00002FEA 2689550D                	MOV	[ES:DI+SF_ENTRY.sf_time],DX
 20174 00002FEE 31C0                    	XOR	AX,AX
 20175                                  ;if installed
 20176                                  	;call	JShare + 14 * 4
 20177 00002FF0 FF1E[C800]              	call	far [JShare+(14*4)]	; 14 = ShSU
 20178                                  ;else
 20179                                  ;	call	ShSU
 20180                                  ;endif
 20181 00002FF4 5B                      	pop	bx
 20182 00002FF5 58                      	pop	ax
 20183 00002FF6 C3                      	retn
 20184                                  
 20185                                  ;============================================================================
 20186                                  ; DIRCALL.ASM, MSDOS 6.0, 1991
 20187                                  ;============================================================================
 20188                                  ; 23/07/2018 - Retro DOS v3.0
 20189                                  ; 18/05/2019 - Retro DOS v4.0
 20190                                  
 20191                                  ; DOSCODE:6FDAh (MSDOS 6.21, MSDOS.SYS)
 20192                                  
 20193                                  ;TITLE DIRCALL - Directory manipulation internal calls
 20194                                  ;NAME  DIRCALL
 20195                                  
 20196                                  ;**	Low level directory manipulation routines for making removing and
 20197                                  ;	  verifying local or NET directories
 20198                                  ;
 20199                                  ;	DOS_MKDIR
 20200                                  ;	DOS_CHDIR
 20201                                  ;	DOS_RMDIR
 20202                                  ;
 20203                                  ;	Modification history:
 20204                                  ;
 20205                                  ;		Created: ARR 30 March 1983
 20206                                  
 20207                                  ;BREAK <DOS_MkDir - Make a directory entry>
 20208                                  ;---------------------------------------------------------------------------
 20209                                  ;
 20210                                  ; Procedure Name : DOS_MkDir
 20211                                  ;
 20212                                  ; Inputs:
 20213                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 20214                                  ;		terminated)
 20215                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 20216                                  ;		( = -1 if current dir not involved, else
 20217                                  ;		 Points to first char after last "/" of current dir part)
 20218                                  ;	[THISCDS] Points to CDS being used
 20219                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 20220                                  ; Function:
 20221                                  ;	Make a new directory
 20222                                  ; Returns:
 20223                                  ;	Carry Clear
 20224                                  ;		No error
 20225                                  ;	Carry Set
 20226                                  ;	    AX is error code
 20227                                  ;		error_path_not_found
 20228                                  ;			Bad path (not in curr dir part if present)
 20229                                  ;		error_bad_curr_dir
 20230                                  ;			Bad path in current directory part of path
 20231                                  ;		error_access_denied
 20232                                  ;			Already exists, device name
 20233                                  ; DS preserved, Others destroyed
 20234                                  ;---------------------------------------------------------------------------
 20235                                  
 20236                                  ;hkn; called from path.asm. DS already set up.
 20237                                  
 20238                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20239                                  ; DOSCODE:6FC6h (MSDOS 5.0, MSDOS.SYS)
 20240                                  
 20241                                  ; 04/02/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
 20242                                  ; DOSCODE:6FDAh (MSDOS 6.22, MSDOS.SYS)
 20243                                  
 20244                                  DOS_MKDIR:
 20245 00002FF7 E82FE2                  	call	TestNet
 20246 00002FFA 7313                    	JNC	short LOCAL_MKDIR
 20247                                  
 20248                                  ;IF NOT Installed
 20249                                  ;	transfer NET_MKDIR
 20250                                  ;ELSE
 20251                                  	;mov	ax,1103h
 20252 00002FFC B80311                  	MOV	AX,(MultNET<<8)|3
 20253 00002FFF CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY
 20254                                  			; SS = DOS CS
 20255                                  			; SDA first filename pointer -> fully-qualified directory name
 20256                                  			; SDA CDS pointer -> current directory
 20257                                  			; Return: CF set on error, AX = DOS error code
 20258                                  			; CF clear if successful
 20259 00003001 C3                      	retn
 20260                                  ;ENDIF
 20261                                  
 20262                                  NODEACCERRJ:
 20263                                  	;mov	ax,5
 20264 00003002 B80500                  	MOV	AX,error_access_denied
 20265                                  _BadRet:
 20266 00003005 F9                      	STC
 20267                                  	;call	LCritDisk
 20268                                  	;retn
 20269                                  	; 18/12/2022
 20270 00003006 E9F4E2                  	jmp	LCritDisk
 20271                                  
 20272                                  PATHNFJ:
 20273 00003009 E8F1E2                  	call	LCritDisk
 20274 0000300C E904FA                  	jmp	SET_MKND_ERR	; Map the MakeNode error and return
 20275                                  
 20276                                  LOCAL_MKDIR:
 20277 0000300F E8D0E2                  	call	ECritDisk
 20278                                  
 20279                                  ; MakeNode requires an SFT to fiddle with. We Use a temp spot (RENBUF)
 20280                                  
 20281 00003012 8C16[A005]              	MOV	[THISSFT+2],SS
 20282                                  
 20283                                  ;hkn; DOSDATA
 20284 00003016 C706[9E05][3E04]        	MOV	WORD [THISSFT],RENBUF
 20285                                  
 20286                                  ;  NOTE: Need WORD PTR because MASM takes type of
 20287                                  ;   TempSFT (byte) instead of type of sf_mft (word).
 20288                                  
 20289                                  	;mov	word [RENBUF+33h],0 ; MSDOS 6.0
 20290 0000301C C706[7104]0000          	MOV	WORD [RENBUF+SF_ENTRY.sf_MFT],0
 20291                                  				; make sure SHARER won't complain.
 20292                                  	;mov	al,10h
 20293 00003022 B010                    	MOV	AL,attr_directory
 20294 00003024 E8FA17                  	call	MakeNode
 20295 00003027 72E0                    	JC	short PATHNFJ
 20296 00003029 83F803                  	CMP	AX,3
 20297 0000302C 74D4                    	JZ	short NODEACCERRJ ; Can't make a device into a directory
 20298 0000302E C42E[8A05]              	LES	BP,[THISDPB]	; Makenode zaps this
 20299 00003032 C53E[E205]              	LDS	DI,[CURBUF]
 20300 00003036 29FE                    	SUB	SI,DI
 20301 00003038 56                      	PUSH	SI		; Pointer to dir_first
 20302                                  
 20303                                  ; 04/02/2024
 20304                                  %if 0
 20305                                  	; MSDOS 6.0
 20306                                  	;push	word [DI+8]
 20307                                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;F.C. >32mb
 20308                                  	; MSDOS 3.3 & MSDOS 6.0
 20309                                  	;push	word [di+6]
 20310                                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Sector of new node
 20311                                  %else
 20312                                  	; 04/02/2024
 20313                                  	; (PCDOS 7.1 IBMDOS.COM)
 20314 00003039 C54506                  	lds	ax,[di+BUFFINFO.buf_sector] ; Sector of new node
 20315 0000303C 1E                      	push	ds
 20316 0000303D 50                      	push	ax
 20317                                  %endif
 20318                                  
 20319 0000303E 16                      	push	ss
 20320 0000303F 1F                      	pop	ds
 20321                                  
 20322                                  	; 04/02/2024
 20323                                  	;PUSH	word [DIRSTART]	; Parent for .. entry
 20324 00003040 31C0                    	XOR	AX,AX
 20325                                  	;MOV	[DIRSTART],AX	; Null directory
 20326 00003042 8706[C205]              	xchg	ax,[DIRSTART]
 20327 00003046 50                      	push	ax
 20328                                  
 20329 00003047 E82117                  	call	NEWDIR
 20330 0000304A 7263                    	JC	short NODEEXISTSPOPDEL ; No room
 20331 0000304C E80C0D                  	call	GETENT		; First entry
 20332 0000304F 725E                    	JC	short NODEEXISTSPOPDEL ; Screw up
 20333 00003051 C43E[E205]              	LES	DI,[CURBUF]
 20334                                  
 20335                                  ; 07/07/2024 - Retro DOS v4.2
 20336                                  %if 0
 20337                                  	; MSDOS 6.0
 20338                                  	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 20339                                  				 ;LB. if already dirty		    ;AN000;
 20340                                  	JNZ	short yesdirty5	 ;LB.   don't increment dirty count ;AN000;
 20341                                  	call	INC_DIRTY_COUNT  ;LB.				    ;AN000;
 20342                                  	
 20343                                  	; MSDOS 3.3 & MSDOS 6.0
 20344                                  	;or	byte [es:di+5],40h  ; 07/12/2022
 20345                                  	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 20346                                  %else
 20347                                  	; 04/02/2024
 20348                                  	; (PCDOS 7.1 IBMDOS.COM)
 20349 00003055 E85F29                  	call	SET_BUF_DIRTY
 20350                                  %endif
 20351                                  
 20352                                  yesdirty5:
 20353                                  	;;add	di,16 ; MSDOS 3.3
 20354                                  	;add	di,20 ; MSDOS 6.0
 20355 00003058 83C714                  	ADD	DI,BUFINSIZ	; Point at buffer
 20356 0000305B B82E20                  	MOV	AX,202EH	; ". "
 20357 0000305E 8B16[C205]              	MOV	DX,[DIRSTART]	; Point at itself
 20358 00003062 E89917                  	call	SETDOTENT
 20359 00003065 B82E2E                  	MOV	AX,2E2EH	; ".."
 20360 00003068 5A                      	POP	DX		; Parent
 20361 00003069 E89217                  	call	SETDOTENT
 20362 0000306C C42E[8A05]              	LES	BP,[THISDPB]
 20363                                  	; 22/09/2023
 20364                                  	;;mov	byte [ALLOWED],18h
 20365                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 20366 00003070 5A                      	POP	DX		; Entry sector
 20367                                  	; MSDOS 6.0
 20368 00003071 8F06[0706]              	POP	word [HIGH_SECTOR] ;F.C. >32mb
 20369                                  
 20370                                  	;XOR	AL,AL ; *	; Pre read
 20371                                  	;call	GETBUFFR
 20372                                  	; 22/09/2023
 20373 00003075 E83927                  	call	GETBUFFER ; *	; Pre read
 20374 00003078 725B                    	JC	short NODEEXISTSP
 20375 0000307A 8B16[C205]              	MOV	DX,[DIRSTART]
 20376 0000307E C53E[E205]              	LDS	DI,[CURBUF]
 20377                                  	;or	byte [di+5],4
 20378 00003082 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 20379 00003086 5E                      	POP	SI		; dir_first pointer
 20380 00003087 01FE                    	ADD	SI,DI
 20381 00003089 8914                    	MOV	[SI],DX
 20382 0000308B 31D2                    	XOR	DX,DX
 20383 0000308D 895402                  	MOV	[SI+2],DX	; Zero size
 20384 00003090 895404                  	MOV	[SI+4],DX
 20385                                  DIRUP:
 20386                                  	; MSDOS 6.0
 20387 00003093 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 20388                                  	;			 ;LB. if already dirty 		   ;AN000;
 20389 00003097 7507                    	JNZ	short yesdirty6	 ;LB.  don't increment dirty count ;AN000;
 20390 00003099 E82729                  	call	INC_DIRTY_COUNT  ;LB.				   ;AN000;
 20391                                  	
 20392                                  	; MSDOS 3.3 & MSDOS 6.0
 20393                                  	;or	byte [di+5],40h
 20394 0000309C 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty	; Dirty buffer
 20395                                  yesdirty6:
 20396 000030A0 16                      	push	ss
 20397 000030A1 1F                      	pop	ds
 20398 000030A2 268A4600                	mov	al,[es:bp]
 20399                                  	;MOV	AL,[ES:BP+DPB.DRIVE]  ; mov al,[es:bp+0]
 20400 000030A6 E80C28                  	call	FLUSHBUF
 20401                                  	;mov	ax,5
 20402 000030A9 B80500                  	MOV	AX,error_access_denied
 20403                                  	;call	LCritDisk
 20404                                  	;retn
 20405                                  	; 18/12/2022
 20406 000030AC E94EE2                  	jmp	LCritDisk
 20407                                  
 20408                                  NODEEXISTSPOPDEL:
 20409 000030AF 5A                      	POP	DX		; Parent
 20410 000030B0 5A                      	POP	DX		; Entry sector
 20411                                  	; MSDOS 6.0 
 20412 000030B1 8F06[0706]              	POP	word [HIGH_SECTOR] ; F.C. >32mb
 20413 000030B5 C42E[8A05]              	LES	BP,[THISDPB]
 20414                                  	; 22/09/2023
 20415                                  	;;mov	byte [ALLOWED],18h
 20416                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 20417                                  	;XOR	AL,AL ; *	; Pre read
 20418                                  	;call	GETBUFFR
 20419                                  	; 22/09/2023
 20420 000030B9 E8F526                  	call	GETBUFFER ; *	; Pre read
 20421 000030BC 7217                    	JC	short NODEEXISTSP
 20422 000030BE C53E[E205]              	LDS	DI,[CURBUF]
 20423                                  	;or	byte [di+5],4
 20424 000030C2 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 20425 000030C6 5E                      	POP	SI		; dir_first pointer
 20426 000030C7 01FE                    	ADD	SI,DI
 20427                                  	;sub	si,1Ah ; 26
 20428 000030C9 83EE1A                  	SUB	SI,dir_entry.dir_first	;Point back to start of dir entry
 20429 000030CC C604E5                  	MOV	BYTE [SI],0E5H	; Free the entry
 20430 000030CF E8C1FF                  	CALL	DIRUP		; Error doesn't matter since erroring anyway
 20431                                  NODEEXISTS:
 20432 000030D2 E92DFF                  	JMP	NODEACCERRJ ; 10/08/2018
 20433                                  
 20434                                  NODEEXISTSP:
 20435 000030D5 5E                      	POP	SI		; Clean stack
 20436 000030D6 EBFA                    	JMP	short NODEEXISTS
 20437                                  
 20438                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20439                                  
 20440                                  ;BREAK <DOS_ChDir -- Verify a directory>
 20441                                  ;----------------------------------------------------------------------------
 20442                                  ;
 20443                                  ; Procedure Name : DOS_ChDir
 20444                                  ;
 20445                                  ; Inputs:
 20446                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 20447                                  ;		terminated)
 20448                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 20449                                  ;		( = -1 if current dir not involved, else
 20450                                  ;		 Points to first char after last "/" of current dir part)
 20451                                  ;	[THISCDS] Points to CDS being used May not be NUL
 20452                                  ; Function:
 20453                                  ;	Validate the path for potential new current directory
 20454                                  ; Returns:
 20455                                  ;	NOTE:
 20456                                  ;	    [SATTRIB] is modified by this call
 20457                                  ;	Carry Clear
 20458                                  ;	    CX is cluster number of the DIR, LOCAL CDS ONLY
 20459                                  ;		Caller must NOT set ID fields on a NET CDS.
 20460                                  ;	Carry Set
 20461                                  ;	    AX is error code
 20462                                  ;		error_path_not_found
 20463                                  ;			Bad path
 20464                                  ;		error_access_denied
 20465                                  ;			device or file name
 20466                                  ; DS preserved, Others destroyed
 20467                                  ;----------------------------------------------------------------------------
 20468                                  
 20469                                  ;hkn; called from path.asm and dir2.asm. DS already set up.
 20470                                  
 20471                                  ; 18/05/2019 - Retro DOS v4.0
 20472                                  ; DOSCODE:70DAh (MSDOS 6.21, MSDOS.SYS)
 20473                                  
 20474                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20475                                  ; DOSCODE:70C6h (MSDOS 5.0, MSDOS.SYS)
 20476                                  
 20477                                  DOS_CHDIR:
 20478 000030D8 E84EE1                  	call	TestNet
 20479 000030DB 7306                    	JNC	short LOCAL_CHDIR
 20480                                  
 20481                                  ;IF NOT Installed
 20482                                  ;	transfer NET_CHDIR
 20483                                  ;ELSE
 20484                                  	;mov	ax,1105h
 20485 000030DD B80511                  	MOV	AX,(MultNET<<8)|5
 20486 000030E0 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CHDIR
 20487                                  			; SS = DOS CS
 20488                                  			; SDA first filename pointer -> fully-qualified directory name
 20489                                  			; SDA CDS pointer -> current directory
 20490                                  			; Return: CF set on error, AX = DOS error code
 20491                                  			; CF clear if successful
 20492 000030E2 C3                      	retn
 20493                                  ;ENDIF
 20494                                  
 20495                                  LOCAL_CHDIR:
 20496 000030E3 E8FCE1                  	call	ECritDisk
 20497                                  	; MSDOS 6.0
 20498                                  	;;test	word [es:di+43h],2000h
 20499                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice ;PTM.
 20500                                  	; 17/12/2022
 20501                                  	;test	byte [es:di+44h],20h
 20502 000030E6 26F6454420              	test	byte [ES:DI+curdir.flags+1],(curdir_splice>>8) ;PTM.
 20503 000030EB 7406                    	JZ	short nojoin		   ;PTM.
 20504                                  	;mov	word [es:di+49h], 0FFFFh
 20505 000030ED 26C74549FFFF            	MOV	word [ES:DI+curdir.ID],0FFFFH ;PTM.
 20506                                  nojoin:
 20507                                  	; MSDOS 3.3 & MSDOS 6.0
 20508 000030F3 C606[4C03]00            	MOV	byte [NoSetDir],0 ; FALSE
 20509                                  	;mov	byte [SATTRIB],16h
 20510 000030F8 C606[6D05]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 20511                                  				; Dir calls can find these
 20512                                  ; DOS 3.3  6/24/86 FastOpen
 20513 000030FD 800E[3A0D]01            	OR	byte [FastOpenFlg],FastOpen_Set	; set fastopen flag
 20514 00003102 E8E00C                  	call	GETPATH
 20515                                  
 20516                                  	; 04/02/2024
 20517                                  	;PUSHF						;AN000;
 20518 00003105 9F                      	lahf						
 20519 00003106 8026[3A0D]80            	AND	byte [FastOpenFlg],Fast_yes ; clear it all ;AC000;
 20520                                  	;POPF						;AN000;
 20521 0000310B 9E                      	sahf
 20522                                  
 20523                                  ; DOS 3.3  6/24/86 FastOpen
 20524                                  
 20525                                  	; MSDOS 3.3
 20526                                  	;mov	byte [FastOpenFlg],0
 20527                                  	
 20528                                  	;mov	ax,3
 20529 0000310C B80300                  	MOV	AX,error_path_not_found
 20530 0000310F 7206                    	JC	short ChDirDone
 20531 00003111 7539                    	JNZ	short NOTDIRPATH	; Path not a DIR
 20532 00003113 8B0E[C205]              	MOV	CX,[DIRSTART]		; Get cluster number
 20533                                  	; 27/06/2024
 20534                                  	;CLC
 20535                                  ChDirDone:
 20536                                  	;call	LCritDisk
 20537                                  	;retn
 20538                                  	; 18/12/2022
 20539 00003117 E9E3E1                  	jmp	LCritDisk
 20540                                  
 20541                                  ;BREAK <DOS_RmDir -- Remove a directory>
 20542                                  ;----------------------------------------------------------------------------
 20543                                  ;
 20544                                  ; Procedure Name : DOS_RmDir
 20545                                  ;
 20546                                  ; Inputs:
 20547                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 20548                                  ;		terminated)
 20549                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 20550                                  ;		( = -1 if current dir not involved, else
 20551                                  ;		 Points to first char after last "/" of current dir part)
 20552                                  ;	[THISCDS] Points to CDS being used
 20553                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 20554                                  ; Function:
 20555                                  ;	Remove a directory
 20556                                  ;	NOTE: Attempt to remove current directory must be detected by caller
 20557                                  ; Returns:
 20558                                  ;	NOTE:
 20559                                  ;	    [SATTRIB] is modified by this call
 20560                                  ;	Carry Clear
 20561                                  ;		No error
 20562                                  ;	Carry Set
 20563                                  ;	    AX is error code
 20564                                  ;		error_path_not_found
 20565                                  ;			Bad path (not in curr dir part if present)
 20566                                  ;		error_bad_curr_dir
 20567                                  ;			Bad path in current directory part of path
 20568                                  ;		error_access_denied
 20569                                  ;			device or file name, root directory
 20570                                  ;			Bad directory ('.' '..' messed up)
 20571                                  ; DS preserved, Others destroyed
 20572                                  ;----------------------------------------------------------------------------
 20573                                  
 20574                                  ;hkn; called from path.asm. DS already set up.
 20575                                  
 20576                                  ; 18/05/2019 - Retro DOS v4.0
 20577                                  ; DOSCODE:711Fh (MSDOS 6.21, MSDOS.SYS)
 20578                                  
 20579                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20580                                  ; DOSCODE:710Bh (MSDOS 5.0, MSDOS.SYS)
 20581                                  
 20582                                  DOS_RMDIR:
 20583 0000311A E80CE1                  	call	TestNet
 20584 0000311D 7306                    	JNC	short LOCAL_RMDIR
 20585                                  
 20586                                  ;IF NOT Installed
 20587                                  ;	transfer NET_RMDIR
 20588                                  ;ELSE
 20589                                  	;mov	ax,1101h
 20590 0000311F B80111                  	MOV	AX,(MultNET<<8)|1
 20591 00003122 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
 20592                                  			; SS = DOS CS
 20593                                  			; SDA first filename pointer -> fully-qualified directory name
 20594                                  			; SDA CDS pointer -> current directory
 20595                                  			; Return: CF set on error, AX = DOS error code
 20596                                  			; CF clear if successful
 20597 00003124 C3                      	retn
 20598                                  ;ENDIF
 20599                                  
 20600                                  LOCAL_RMDIR:
 20601 00003125 E8BAE1                  	call	ECritDisk
 20602 00003128 C606[4C03]00            	MOV	byte [NoSetDir],0
 20603                                  	;mov	byte [SATTRIB],16h
 20604 0000312D C606[6D05]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 20605                                  					; Dir calls can find these
 20606 00003132 E8B00C                  	call	GETPATH
 20607 00003135 720C                    	JC	short NOPATH		; Path not found
 20608 00003137 7513                    	JNZ	short NOTDIRPATH	; Path not a DIR
 20609 00003139 8B3E[C205]              	MOV	DI,[DIRSTART]
 20610 0000313D 09FF                    	OR	DI,DI			; Root ?
 20611 0000313F 750E                    	JNZ	short rmdir_get_buf	; No
 20612 00003141 EB09                    	JMP	SHORT NOTDIRPATH
 20613                                  
 20614                                  NOPATH:
 20615                                  	;mov	ax,3
 20616 00003143 B80300                  	MOV	AX,error_path_not_found
 20617 00003146 E9BCFE                  	JMP	_BadRet
 20618                                  
 20619                                  NOTDIRPATHPOP:
 20620 00003149 58                      	POP	AX  ; MSDOS 6.0		;F.C. >32mb
 20621 0000314A 58                      	POP	AX
 20622                                  NOTDIRPATHPOP2:
 20623 0000314B 58                      	POP	AX
 20624                                  NOTDIRPATH:
 20625 0000314C E9B3FE                  	JMP	NODEACCERRJ
 20626                                  
 20627                                  rmdir_get_buf:
 20628 0000314F C53E[E205]              	LDS	DI,[CURBUF]
 20629 00003153 29FB                    	SUB	BX,DI		; Compute true offset
 20630 00003155 53                      	PUSH	BX		; Save entry pointer
 20631                                  	
 20632                                  	; MSDOS 6.0
 20633                                  	;push	word [di+8]
 20634 00003156 FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2] ;F.C. >32mb
 20635                                  	
 20636                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20637                                  	;push	word [di+6]
 20638 00003159 FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Save sector number
 20639                                  
 20640                                  ;hkn; SS is DOSDATA
 20641                                  	;context DS
 20642 0000315C 16                      	push	ss
 20643 0000315D 1F                      	pop	ds
 20644                                  	;context ES
 20645 0000315E 16                      	push	ss
 20646 0000315F 07                      	pop	es
 20647                                  
 20648                                  ;hkn; NAME1 is in DOSDATA
 20649 00003160 BF[4B05]                	MOV	DI,NAME1
 20650                                  	;MOV	AL,'?' ; 3Fh
 20651                                  	;MOV	CX,11
 20652                                  	;REP	STOSB
 20653                                  	;XOR	AL,AL
 20654                                  	;STOSB				; Nul terminate it
 20655                                  	; 27/06/2024
 20656 00003163 B83F00                  	mov	ax,3Fh
 20657 00003166 B90A00                  	mov	cx,10
 20658 00003169 F3AA                    	rep	stosb	; al = "?"
 20659 0000316B AB                      	stosw		; ah = 0
 20660                                  	;
 20661 0000316C E8ED0E                  	call	STARTSRCH		; Set search
 20662 0000316F E8E60B                  	call	GETENTRY		; Get start of directory
 20663 00003172 72D5                    	JC	short NOTDIRPATHPOP	; Screw up
 20664 00003174 8E1E[E405]              	MOV	DS,[CURBUF+2]
 20665 00003178 89DE                    	MOV	SI,BX
 20666 0000317A AD                      	LODSW
 20667                                  	;CMP	AX,(' ' SHL 8) OR '.'   ; First entry '.'?
 20668 0000317B 3D2E20                  	cmp	ax,202Eh ; ". "
 20669 0000317E 75C9                    	JNZ	short NOTDIRPATHPOP	; Nope
 20670                                  	;add	si,30
 20671 00003180 83C61E                  	ADD	SI,dir_entry.size-2 ; Next entry
 20672 00003183 AD                      	LODSW
 20673                                  	;CMP	AX,('.' SHL 8) OR '.'   ; Second entry '..'?
 20674                                  	;cmp	ax, '..'
 20675 00003184 3D2E2E                  	cmp	ax,2E2Eh
 20676 00003187 75C0                    	JNZ	short NOTDIRPATHPOP	; Nope
 20677                                  
 20678                                  ;hkn; SS is DOSDATA
 20679                                  	;context DS
 20680 00003189 16                      	push	ss
 20681 0000318A 1F                      	pop	ds
 20682 0000318B C706[4803]0200          	MOV	word [LASTENT],2	; Skip . and ..
 20683 00003191 E8C40B                  	call	GETENTRY		; Get next entry
 20684 00003194 72B3                    	JC	short NOTDIRPATHPOP	; Screw up
 20685                                  	;mov	byte [ATTRIB],16h
 20686 00003196 C606[6B05]16            	MOV	byte [ATTRIB],attr_directory+attr_hidden+attr_system
 20687 0000319B E8C40A                  	call	SRCH			; Do a search
 20688 0000319E 73A9                    	JNC	short NOTDIRPATHPOP	; Found another entry!
 20689 000031A0 803E[4A03]00            	CMP	byte [FAILERR],0
 20690 000031A5 75A2                    	JNZ	short NOTDIRPATHPOP	; Failure of search due to I 24 FAIL
 20691 000031A7 C42E[8A05]              	LES	BP,[THISDPB]
 20692 000031AB 8B1E[C205]              	MOV	BX,[DIRSTART]
 20693 000031AF E88B1B                  	call	RELEASE 		; Release data in sub dir
 20694 000031B2 7295                    	JC	short NOTDIRPATHPOP	; Screw up
 20695 000031B4 5A                      	POP	DX			; Sector # of entry
 20696 000031B5 8F06[0706]              	POP	word [HIGH_SECTOR] ; MSDOS 6.0	; F.C. >32mb
 20697                                  	; 22/09/2023
 20698                                  	;;mov	byte [ALLOWED],18h
 20699                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 20700                                  	;XOR	AL,AL ; *		; Pre read
 20701                                  	;call	GETBUFFR		; Get sector back
 20702 000031B9 E8F525                  	call	GETBUFFER ; *		; Pre Read
 20703 000031BC 728D                    	JC	short NOTDIRPATHPOP2	; Screw up
 20704 000031BE C53E[E205]              	LDS	DI,[CURBUF]
 20705                                  	;or	byte [di+5],4
 20706 000031C2 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 20707 000031C6 5B                      	POP	BX			; Pointer to start of entry
 20708 000031C7 01FB                    	ADD	BX,DI			; Corrected
 20709 000031C9 C607E5                  	MOV	BYTE [BX],0E5H		; Free the entry
 20710                                  
 20711                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 20712 000031CC 1E                      	PUSH	DS
 20713                                  
 20714                                  ;hkn; SS is DOSDATA
 20715                                  	;context DS
 20716 000031CD 16                      	push	ss
 20717 000031CE 1F                      	pop	ds
 20718                                  
 20719                                  	; MSDOS 6.0
 20720 000031CF E86BF4                  	call	FastOpen_Delete 	; call fastopen to delete an entry
 20721                                  
 20722                                  ;	; MSDOS 3.3
 20723                                  ;_FastOpen_Delete:
 20724                                  ;	push	ax
 20725                                  ;	mov	si,[WFP_START]
 20726                                  ;	mov	bx,FastTable
 20727                                  ;	;mov	al,3  ; FONC_delete
 20728                                  ;	mov	al,FONC_delete
 20729                                  ;	call	far [BX+2]  ; FastTable+2
 20730                                  ;	pop	ax
 20731                                  
 20732 000031D2 1F                      	POP	DS
 20733                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 20734                                  
 20735 000031D3 E9BDFE                  	JMP	DIRUP			; In MKDIR, dirty buffer and flush
 20736                                  
 20737                                  ;============================================================================
 20738                                  ; DISK.ASM, MSDOS 6.0, 1991
 20739                                  ;============================================================================
 20740                                  ; 23/07/2018 - Retro DOS v3.0 
 20741                                  ; 04/05/2019 - Retro DOS v4.0
 20742                                  
 20743                                  ;	TITLE	DISK - Disk utility routines
 20744                                  ;	NAME	Disk
 20745                                  
 20746                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 20747                                  ;
 20748                                  ;	SWAPCON
 20749                                  ;	SWAPBACK
 20750                                  ;	DOS_READ
 20751                                  ;	DOS_WRITE
 20752                                  ;	get_io_sft
 20753                                  ;	DirRead
 20754                                  ;	FIRSTCLUSTER
 20755                                  ;	SET_BUF_AS_DIR
 20756                                  ;	FATSecRd
 20757                                  ;	DREAD
 20758                                  ;	CHECK_WRITE_LOCK
 20759                                  ;	CHECK_READ_LOCK
 20760                                  ;
 20761                                  ;	Revision history:
 20762                                  ;
 20763                                  ;		A000   version 4.00  Jan. 1988
 20764                                  ;
 20765                                  ;----------------------------------------------------------------------------
 20766                                  ;
 20767                                  ; M065 : B#5276. On raw read/write of a block of characters if a critical
 20768                                  ;		error happens, DOS retries the entire block assuming that
 20769                                  ;		zero characters were transferred. Modified the code to take
 20770                                  ;		into account the number of characters transfered before
 20771                                  ;		retrying the operation.
 20772                                  ;
 20773                                  ;----------------------------------------------------------------------------
 20774                                  ;
 20775                                  
 20776                                  ;Installed = TRUE
 20777                                  
 20778                                  ;Break	<SwapCon, Swap Back - Old-style I/O to files>
 20779                                  
 20780                                  ; **** Drivers for file input from devices ****
 20781                                  ;----------------------------------------------------------------------------
 20782                                  ;   Indicate that there is no more I/O occurring through another SFT outside
 20783                                  ;   of handles 0 and 1
 20784                                  ;
 20785                                  ;   Inputs:	DS is DOSDATA
 20786                                  ;   Outputs:	CONSWAP is set to false.
 20787                                  ;   Registers modified: none
 20788                                  ;----------------------------------------------------------------------------
 20789                                  
 20790                                  ; IBMDOS.COM (MSDOS 3.3) - Offset 3CF8h
 20791                                  
 20792                                  ; DOSCODE:71E3h (MSDOS 6.21, MSDOS.SYS)
 20793                                  ; 04/05/2019 - Retro DOS v4.0
 20794                                  
 20795                                  ; DOSCODE:71CFh (MSDOS 5.0, MSDOS.SYS)
 20796                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20797                                  
 20798                                  SWAPBACK:
 20799 000031D6 C606[5703]00            	MOV	BYTE [CONSWAP],0	; signal no conswaps
 20800 000031DB C3                      	retn
 20801                                  
 20802                                  ;----------------------------------------------------------------------------
 20803                                  ;
 20804                                  ; Procedure Name : SWAPCON
 20805                                  ;
 20806                                  ;   Copy ThisSFT to CONSFT for use by the 1-12 primitives.
 20807                                  ;
 20808                                  ;   Inputs:	ThisSFT as the sft of the desired file
 20809                                  ;		DS is DOSDATA
 20810                                  ;   Outputs:	CONSWAP is set.  CONSFT = ThisSFT.
 20811                                  ;   Registers modified: none
 20812                                  ;--------------------------------------------------------------------------
 20813                                  
 20814                                  SWAPCON:
 20815                                  	; MSDOS 3.3
 20816                                  	;push	es
 20817                                  	;push	di
 20818                                  	;mov	byte [CONSWAP],1
 20819                                  	;les	di,[THISSFT]
 20820                                  	;mov	word [CONSFT],di
 20821                                  	;mov	word [CONSFT+2],es
 20822                                  	;pop	di
 20823                                  	;pop	es
 20824                                  	;retn
 20825                                  
 20826                                  	; MSDOS 6.0
 20827 000031DC C606[5703]01            	mov	byte [CONSWAP],1	; ConSwap = TRUE
 20828 000031E1 50                      	push	ax
 20829 000031E2 A1[9E05]                	mov	ax,[THISSFT]
 20830 000031E5 A3[E605]                	mov	[CONSFT],ax
 20831 000031E8 A1[A005]                	mov	ax,[THISSFT+2]
 20832 000031EB A3[E805]                	mov	[CONSFT+2],ax
 20833 000031EE 58                      	pop	ax
 20834 000031EF C3                      	retn
 20835                                  
 20836                                  ; DOSCODE:71FDh (MSDOS 6.21, MSDOS.SYS)
 20837                                  ; 04/05/2019 - Retro DOS v4.0
 20838                                  
 20839                                  ;Break	<DOS_READ -- MAIN READ ROUTINE AND DEVICE IN ROUTINES>
 20840                                  ;-----------------------------------------------------------------------------
 20841                                  ;
 20842                                  ; Inputs:
 20843                                  ;	ThisSFT set to the SFT for the file being used
 20844                                  ;	[DMAADD] contains transfer address
 20845                                  ;	CX = No. of bytes to read
 20846                                  ;	DS = DOSDATA
 20847                                  ; Function:
 20848                                  ;	Perform read operation
 20849                                  ; Outputs:
 20850                                  ;    Carry clear
 20851                                  ;	SFT Position and cluster pointers updated
 20852                                  ;	CX = No. of bytes read
 20853                                  ;	ES:DI point to SFT
 20854                                  ;    Carry set
 20855                                  ;	AX is error code
 20856                                  ;	CX = 0
 20857                                  ;	ES:DI point to SFT
 20858                                  ; DS preserved, all other registers destroyed
 20859                                  ;
 20860                                  ;-----------------------------------------------------------------------------
 20861                                  
 20862                                  ;hkn; called from fcbio.asm, handle.asm and dev.asm. DS is be set up.
 20863                                  
 20864                                  ; DOSCODE:71E9h (MSDOS 5.0, MSDOS.SYS)
 20865                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20866                                  
 20867                                  DOS_READ:
 20868 000031F0 C43E[9E05]              	LES	DI,[THISSFT]
 20869                                  
 20870                                  ; Verify that the sft has been opened in a mode that allows reading.
 20871                                  
 20872                                  	;mov	al,[es:di+2]
 20873 000031F4 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 20874                                  	;and	al,0Fh
 20875 000031F8 240F                    	AND	AL,access_mask
 20876                                  	;cmp	al,1
 20877 000031FA 3C01                    	CMP	AL,open_for_write
 20878 000031FC 7503                    	JNE	short READ_NO_MODE	; Is read or both
 20879 000031FE E9CD05                  	jmp	SET_ACC_ERR
 20880                                  
 20881                                  READ_NO_MODE:
 20882 00003201 E8B204                  	call	SETUP
 20883 00003204 E30B                    	JCXZ	NoIORet 		; no bytes to read - fast return
 20884 00003206 E839E0                  	call	IsSFTNet
 20885 00003209 7408                    	JZ	short LOCAL_READ
 20886                                  
 20887                                  ;IF NOT Installed
 20888                                  ;	transfer NET_READ
 20889                                  ;ELSE
 20890                                  	;mov	ax,1108h
 20891 0000320B B80811                  	MOV	AX,(MultNET<<8)|8
 20892 0000320E CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - READ FROM REMOTE FILE
 20893                                  			; ES:DI -> SFT
 20894                                  			; SFT DPB field -> DPB of drive containing file
 20895                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 20896                                  			; Return: CF set on error, CX = bytes read
 20897 00003210 C3                      	retn
 20898                                  ;ENDIF
 20899                                  
 20900                                  ; The user ended up requesting 0 bytes of input. We do nothing for this case
 20901                                  ; except return immediately.
 20902                                  
 20903                                  NoIORet:
 20904 00003211 F8                      	CLC
 20905 00003212 C3                      	retn
 20906                                  
 20907                                  LOCAL_READ:
 20908                                  	;test	word [es:di+5],80h
 20909                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device  ; Check for named device I/O
 20910 00003213 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; 02/06/2019
 20911 00003218 750E                    	JNZ	short READDEV
 20912                                  
 20913                                  	;mov	byte [EXTERR_LOCUS],2
 20914 0000321A C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 20915 0000321F E8C0E0                  	call	ECritDisk
 20916 00003222 E86C05                  	call	DISKREAD
 20917                                  
 20918                                  critexit:
 20919                                  	;call	LCritDisk
 20920                                  	;retn
 20921                                  	; 16/12/2022
 20922 00003225 E9D5E0                  	jmp	LCritDisk
 20923                                  
 20924                                  ; We are reading from a device. Examine the status of the device to see if we
 20925                                  ; can short-circuit the I/O. If the device in the EOF state or if it is the
 20926                                  ; null device, we can safely indicate no transfer.
 20927                                  
 20928                                  READDEV:
 20929                                  	;mov	byte [EXTERR_LOCUS],4
 20930 00003228 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 20931                                  	;mov	bl,[es:di+5]
 20932 0000322D 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 20933 00003231 C43E[2C03]              	LES	DI,[DMAADD]
 20934                                  	;test	bl,40h
 20935 00003235 F6C340                  	test	BL,devid_device_EOF	; End of file?
 20936 00003238 7407                    	JZ	short ENDRDDEVJ3
 20937                                  	;test	bl,4
 20938 0000323A F6C304                  	test	BL,devid_device_null	; NUL device?
 20939 0000323D 7405                    	JZ	short TESTRAW 		; NO
 20940 0000323F 30C0                    	XOR	AL,AL			; Indicate EOF by setting zero
 20941                                  ENDRDDEVJ3:
 20942                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 20943                                  	;JMP	short ENDRDDEVJ2
 20944                                  	; 16/12/2022
 20945 00003241 E93E01                  	jmp	ENDRDDEV ; 04/05/2019
 20946                                  
 20947                                  ; We need to hit the device. Figure out if we do a raw read or we do the
 20948                                  ; bizarre std_con_string_input.
 20949                                  
 20950                                  TESTRAW:
 20951                                  	;test	bl,20h
 20952 00003244 F6C320                  	test	BL,devid_device_raw	; Raw mode?
 20953 00003247 7508                    	JNZ	short DVRDRAW 		; Yes, let the device do all local editing
 20954                                  	;test	bl,1
 20955 00003249 F6C301                  	test	BL,devid_device_con_in	; Is it console device?
 20956 0000324C 7457                    	JZ	short NOTRDCON
 20957 0000324E E96601                  	JMP	READCON
 20958                                  
 20959                                  DVRDRAW:
 20960 00003251 06                      	PUSH	ES
 20961 00003252 1F                      	POP	DS			; Xaddr to DS:DI
 20962                                  
 20963                                  	; 04/05/2019 - Retro DOS v4.0
 20964                                  
 20965                                  	; MSDOS 6.0
 20966                                  ;SR;
 20967                                  ;Check for win386 presence -- if present, do polled read of characters
 20968                                  
 20969 00003253 36F606[3010]01          	test	byte [ss:IsWin386],1 ; 19/05/2019
 20970 00003259 7408                    	jz	short ReadRawRetry	;not present
 20971 0000325B F6C301                  	test	bl,devid_device_con_in	;is it console device
 20972 0000325E 7403                    	jz	short ReadRawRetry	;no, do normal read
 20973 00003260 E9A700                  	jmp	do_polling		;yes, do win386 polling loop
 20974                                  
 20975                                  ReadRawRetry:
 20976                                  
 20977                                  ; 07/02/2024
 20978                                  %if 0
 20979                                  	MOV	BX,DI			; DS:BX transfer addr
 20980                                  	; 06/02/2024 ; *
 20981                                  	;XOR	AX,AX			; Media Byte, unit = 0
 20982                                  	;;MOV	DX,AX			; Start at 0
 20983                                  	;; 06/02/2024
 20984                                  	;cwd
 20985                                  	;call	SETREAD
 20986                                  	; 06/02/2024 ; *
 20987                                  	call	SETREAD_X
 20988                                  %else
 20989 00003263 E81613                  	call	SETREAD_XJ
 20990                                  %endif
 20991                                  
 20992                                  ;hkn; SS override
 20993 00003266 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 20994 0000326B E89812                  	call	DEVIOCALL
 20995 0000326E 89FA                    	MOV	DX,DI			; DS:DX is preserved by INT 24
 20996 00003270 B486                    	MOV	AH,86H			; Read error
 20997                                  
 20998                                  ;hkn; SS override
 20999 00003272 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 21000                                  	; MSDOS 3.3
 21001                                  	;test	di,8000h
 21002                                  	;jz	short CRDROK
 21003                                  	; MSDOS 6.0
 21004 00003277 09FF                    	or	di,di
 21005 00003279 7920                    	jns	short CRDROK		; no errors
 21006                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21007 0000327B E8C81E                  	call	CHARHARD
 21008                                  
 21009                                  ; 06/02/2024 - Retrro DOS v5.0
 21010                                  %if 0
 21011                                  	MOV	DI,DX			; DS:DI is Xaddr
 21012                                  	; 04/05/2019
 21013                                  	; MSDOS 6.0
 21014                                  	add	di,[ss:CALLSCNT]	; update ptr and count to reflect the	M065
 21015                                  	sub	cx,[ss:CALLSCNT]	; number of chars xferred		M065
 21016                                  %else
 21017 0000327E 368B3E[6C03]            	mov	di,[ss:CALLSCNT]
 21018 00003283 29F9                    	sub	cx,di			; update transfer count
 21019 00003285 01D7                    	add	di,dx			; update pointer
 21020                                  %endif
 21021                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21022 00003287 08C0                    	OR	AL,AL
 21023 00003289 7410                    	JZ	short CRDROK		; Ignore
 21024 0000328B 3C03                    	CMP	AL,3
 21025 0000328D 7403                    	JZ	short CRDFERR 		; fail.
 21026 0000328F 1F                      	POP	DS			; Recover saved seg part of Xaddr
 21027 00003290 EBD1                    	JMP	short ReadRawRetry	; Retry
 21028                                  
 21029                                  ; We have encountered a device-driver error. We have informed the user of it
 21030                                  ; and he has said for us to fail the system call.
 21031                                  
 21032                                  CRDFERR:
 21033 00003292 5F                      	POP	DI			; Clean stack
 21034                                  DEVIOFERR:
 21035                                  
 21036                                  ;hkn; SS override
 21037 00003293 36C43E[9E05]            	LES	DI,[SS:THISSFT]
 21038 00003298 E93105                  	jmp	SET_ACC_ERR_DS
 21039                                  
 21040                                  CRDROK:
 21041 0000329B 5F                      	POP	DI			; Chuck saved seg of Xaddr
 21042 0000329C 89D7                    	MOV	DI,DX
 21043                                  
 21044                                  ;hkn; SS override
 21045 0000329E 36033E[6C03]            	ADD	DI,[ss:CALLSCNT]	; Amount transferred
 21046                                  	;JMP	SHORT ENDRDDEVJ3
 21047                                  	; 16/12/2022
 21048 000032A3 EB63                    	jmp	short ENDRDDEVJ2
 21049                                  
 21050                                  ; We are going to do a cooked read on some character device. There is a
 21051                                  ; problem here, what does the data look like? Is it a terminal device, line
 21052                                  ; CR line CR line CR, or is it file data, line CR LF line CR LF? Does it have
 21053                                  ; a ^Z at the end which is data, or is the ^Z not data?  In any event we're
 21054                                  ; going to do this: Read in pieces up to CR (CRs included in data) or ^z (^z
 21055                                  ; included in data). this "simulates" the way con works in cooked mode
 21056                                  ; reading one line at a time. With file data, however, the lines will look
 21057                                  ; like, LF line CR. This is a little weird.
 21058                                  
 21059                                  NOTRDCON:
 21060                                  	;MOV	AX,ES
 21061                                  	;MOV	DS,AX
 21062                                  	; 07/02/2024
 21063 000032A5 06                      	push	es
 21064 000032A6 1F                      	pop	ds
 21065                                  
 21066                                  ; 07/02/2024
 21067                                  %if 0
 21068                                  	MOV	BX,DI
 21069                                  	; 06/02/2024 ; *
 21070                                  	;;XOR	DX,DX
 21071                                  	;;MOV	AX,DX
 21072                                  	;; 06/02/2024
 21073                                  	;xor	ax,ax
 21074                                  	;cwd
 21075                                  	PUSH	CX
 21076                                  	MOV	CX,1
 21077                                  	;call	SETREAD
 21078                                  	; 06/02/2024 ; *
 21079                                  	call	SETREAD_X
 21080                                  	POP	CX
 21081                                  %else
 21082 000032A7 51                      	push	cx
 21083 000032A8 B90100                  	mov	cx,1
 21084 000032AB E8CE12                  	call	SETREAD_XJ
 21085 000032AE 59                      	pop	cx
 21086                                  %endif
 21087                                  
 21088                                  ;hkn; SS override
 21089 000032AF 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 21090                                  	;lds	si,[si+7]
 21091 000032B4 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 21092                                  DVRDLP:
 21093 000032B7 E8711C                  	call	DSKSTATCHK
 21094 000032BA E84C12                  	call	DEVIOCALL2
 21095 000032BD 57                      	PUSH	DI			; Save "count" done
 21096 000032BE B486                    	MOV	AH,86H
 21097                                  
 21098                                  ;hkn; SS override
 21099 000032C0 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 21100                                  	
 21101                                  	; MSDOS 3.3
 21102                                  	;test	di,8000h
 21103                                  	;jz	short CRDOK
 21104                                  	; MSDOS 6.0
 21105 000032C5 09FF                    	or	di,di
 21106 000032C7 7917                    	jns	short CRDOK
 21107                                  	
 21108 000032C9 E87A1E                  	call	CHARHARD
 21109 000032CC 5F                      	POP	DI
 21110                                  
 21111                                  ;hkn; SS override
 21112 000032CD 36C706[6C03]0100        	MOV	word [SS:CALLSCNT],1
 21113 000032D4 3C01                    	CMP	AL,1
 21114 000032D6 74DF                    	JZ	short DVRDLP		; Retry
 21115 000032D8 3C03                    	CMP	AL,3
 21116 000032DA 74B7                    	JZ	short DEVIOFERR		; FAIL
 21117 000032DC 30C0                    	XOR	AL,AL			; Ignore, Pick some random character
 21118 000032DE EB12                    	JMP	SHORT DVRDIGN
 21119                                  
 21120                                  CRDOK:
 21121 000032E0 5F                      	POP	DI
 21122                                  
 21123                                  ;hkn; SS override
 21124 000032E1 36833E[6C03]01          	CMP	word [SS:CALLSCNT],1
 21125                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 21126 000032E7 751F                    	JNZ	short ENDRDDEVJ2
 21127                                  	; 16/12/2022
 21128                                  	;jnz	short ENDRDDEV ; 24/07/2019
 21129                                  
 21130 000032E9 1E                      	PUSH	DS
 21131                                  
 21132                                  ;hkn; SS override
 21133 000032EA 368E1E[6A03]            	MOV	DS,[SS:CALLXAD+2]
 21134 000032EF 8A05                    	MOV	AL,[DI]			; Get the character we just read
 21135 000032F1 1F                      	POP	DS
 21136                                  DVRDIGN:
 21137                                  
 21138                                  ;hkn; SS override
 21139 000032F2 36FF06[6803]            	INC	WORD [SS:CALLXAD]	; Next character
 21140 000032F7 36C706[5D03]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 21141 000032FE 47                      	INC	DI			; Next character
 21142 000032FF 3C1A                    	CMP	AL,1Ah			; ^Z?
 21143                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 21144 00003301 7405                    	JZ	short ENDRDDEVJ2	; Yes, done zero set (EOF)
 21145                                  	; 16/12/2022
 21146                                  	;jz	short ENDRDDEV ; 24/07/2019	
 21147 00003303 3C0D                    	CMP	AL,c_CR  ; 0Dh		; CR?
 21148 00003305 E0B0                    	LOOPNZ	DVRDLP			; Loop if no, else done
 21149 00003307 40                      	INC	AX			; Resets zero flag so NOT EOF, unless
 21150                                  					;  AX=FFFF which is not likely
 21151                                  ENDRDDEVJ2:
 21152                                  	; 16/12/2022
 21153                                  	;JMP	short ENDRDDEV		; changed short to long for win386
 21154                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21155 00003308 EB78                    	jmp	ENDRDDEV
 21156                                  
 21157                                  	; 04/05/2019
 21158                                  
 21159                                  	; MSDOS 6.0
 21160                                  ;SR;
 21161                                  ;Polling code for raw read on CON when WIN386 is present
 21162                                  ;
 21163                                  ;At this point -- ds:di is transfer address
 21164                                  ;		  cx is count
 21165                                  
 21166                                  do_polling:
 21167                                  
 21168                                  ; 07/02/2024
 21169                                  %if 0
 21170                                  	mov	bx,di			;ds:bx is Xfer address
 21171                                  	; 06/02/2024 ; *
 21172                                  	;xor	ax,ax
 21173                                  	;;mov	dx,ax
 21174                                  	;; 06/02/2024
 21175                                  	;cwd
 21176                                  	;call	SETREAD			;prepare device packet
 21177                                  	; 06/02/2024 ; *
 21178                                  	call	SETREAD_X
 21179                                  %else
 21180 0000330A E86F12                  	call	SETREAD_XJ
 21181                                  %endif
 21182                                  
 21183                                  do_io:
 21184                                  ;Change read to a NON-DESTRUCTIVE READ, NO WAIT
 21185                                  
 21186 0000330D 26C6470205              	mov	byte [es:bx+2],DEVRDND ; 5 ;Change command code
 21187 00003312 1E                      	push	ds
 21188 00003313 36C536[9E05]            	lds	si,[ss:THISSFT]		;get device header
 21189 00003318 E8EB11                  	call	DEVIOCALL		;call device driver
 21190 0000331B 1F                      	pop	ds
 21191                                  	
 21192                                  	;test	word [es:bx+3],8000h
 21193                                  	; 16/12/2022
 21194                                  	;test	byte [es:bx+4],80h
 21195 0000331C 26F6470480              	test	byte [es:bx+SRHEAD.REQSTAT+1],STERR>>8 
 21196                                  	;test	word [es:bx+SRHEAD.REQSTAT],STERR ;check if error
 21197 00003321 7413                    	jz	short check_busy	;no
 21198                                  
 21199 00003323 1E                      	push	ds
 21200 00003324 89FA                    	mov	dx,di
 21201                                  
 21202                                  invoke_charhard:	; 07/02/2024
 21203                                  	;invoke charhard		;invoke int 24h handler
 21204 00003326 E81D1E                  	call	CHARHARD
 21205 00003329 89D7                    	mov	di,dx
 21206 0000332B 08C0                    	or	al,al
 21207 0000332D 744D                    	jz	short pop_done_read	;ignore by user, assume read done
 21208 0000332F 3C03                    	cmp	al,3
 21209 00003331 7438                    	jz	short devrderr		;user asked to fail
 21210 00003333 1F                      	pop	ds
 21211 00003334 EBD7                    	jmp	short do_io		;user asked to retry
 21212                                  
 21213                                  check_busy:
 21214                                  	;test	word [es:bx+3],200h
 21215                                  	; 16/12/2022
 21216 00003336 26F6470402              	test	byte [es:bx+SRHEAD.REQSTAT+1],02h
 21217                                  	;test	word [es:bx+SRHEAD.REQSTAT],0200h ;see if busy bit set
 21218 0000333B 7537                    	jnz	short no_char		;yes, no character available
 21219                                  
 21220                                  ;Character is available. Read in 1 character at a time until all characters
 21221                                  ;are read in or no character is available
 21222                                  
 21223 0000333D 26C6470204              	mov	byte [es:bx+2],DEVRD ; 4 ;command code is READ now
 21224 00003342 26C747120100            	mov	word [es:bx+18],1	;change count to 1 character
 21225 00003348 1E                      	push	ds
 21226 00003349 36C536[9E05]            	lds	si,[ss:THISSFT]
 21227 0000334E E8B511                  	call	DEVIOCALL
 21228                                  
 21229 00003351 89FA                    	mov	dx,di
 21230 00003353 B486                    	mov	ah,86h
 21231                                  	;mov	di,[es:bx+3]
 21232 00003355 268B7F03                	mov	di,[es:bx+SRHEAD.REQSTAT] ;get returned status
 21233 00003359 F7C70080                	test	di,STERR ; 8000h	;was there an error during read?
 21234                                  	;jz	short next_char		;no,read next character
 21235                                  	; 07/02/2024
 21236 0000335D 75C7                    	jnz	short invoke_charhard
 21237                                  
 21238                                  ; 07/02/2024
 21239                                  %if 0
 21240                                  	;invoke	charhard		;invoke int 24h handler
 21241                                  	call	CHARHARD
 21242                                  	mov	di,dx			;restore di
 21243                                  	or	al,al			;
 21244                                  	jz	short pop_done_read	;ignore by user,assume read is done
 21245                                  	cmp	al,3
 21246                                  	jz	short devrderr		;user issued a 'fail',indicate error
 21247                                  	pop	ds
 21248                                  	jmp	short do_io		;user issued a retry
 21249                                  %endif
 21250                                  
 21251                                  next_char:
 21252 0000335F 1F                      	pop	ds
 21253 00003360 89D7                    	mov	di,dx
 21254 00003362 49                      	dec	cx			;decrement count
 21255                                  	;jcxz	done_read		;all characters read in
 21256                                  	; 07/02/2024
 21257 00003363 7418                    	jz	short done_read
 21258 00003365 26FF470E                	inc	word [es:bx+14]		;update transfer address
 21259 00003369 EBA2                    	jmp	short do_io		;read next character in
 21260                                  
 21261                                  devrderr:
 21262 0000336B 5F                      	pop	di			;discard segment address
 21263 0000336C 36C43E[9E05]            	les	di,[ss:THISSFT]
 21264                                  	;transfer SET_ACC_ERR_DS	;indicate error
 21265 00003371 E95804                  	jmp     SET_ACC_ERR_DS
 21266                                  
 21267                                  no_char:
 21268                                  ;Since no character is available, we let win386 switch the VM out
 21269                                  
 21270 00003374 50                      	push	ax
 21271 00003375 B484                    	mov	ah,84h	; Microsoft Networks - KEYBOARD BUSY LOOP
 21272 00003377 CD2A                    	int	2Ah			;indicate idle to WIN386
 21273                                  
 21274                                  ;When control returns from WIN386, we continue the raw read
 21275                                  
 21276 00003379 58                      	pop	ax
 21277 0000337A EB91                    	jmp	short do_io	; 27/06/2024
 21278                                  
 21279                                  pop_done_read:
 21280 0000337C 1F                      	pop	ds
 21281                                  done_read:
 21282 0000337D 36033E[6C03]            	add	di,[ss:CALLSCNT] ; 19/05/2019
 21283                                  
 21284                                  	; 16/12/2022
 21285                                  
 21286                                  	;jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit
 21287                                  	;jmp	ENDRDDEV ; 04/05/2019
 21288                                  
 21289                                  	; 04/05/2019 - Retro DOS v4.0
 21290                                  ENDRDDEV:
 21291 00003382 16                      	push	ss
 21292 00003383 1F                      	pop	ds
 21293 00003384 EB1F                    	jmp	short endrddev1
 21294                                  
 21295                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21296                                  	;jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit
 21297                                  
 21298                                  TRANBUF:
 21299 00003386 AC                      	LODSB
 21300 00003387 AA                      	STOSB
 21301 00003388 3C0D                    	CMP	AL,c_CR ; 0Dh	; Check for carriage return
 21302 0000338A 7503                    	JNZ	short NORMCH
 21303 0000338C C6040A                  	MOV	BYTE [SI],c_LF ; 0Ah
 21304                                  NORMCH:
 21305 0000338F 3C0A                    	CMP	AL,c_LF ; 0Ah
 21306 00003391 E0F3                    	LOOPNZ	TRANBUF
 21307 00003393 7507                    	JNZ	short ENDRDCON
 21308 00003395 31F6                    	XOR	SI,SI		; Cause a new buffer to be read
 21309 00003397 E89BE2                  	call	OUTT		; Transmit linefeed
 21310 0000339A 0C01                    	OR	AL,1		; Clear zero flag--not end of file
 21311                                  ENDRDCON:
 21312                                  ;hkn; SS is DOSDATA
 21313 0000339C 16                      	push	ss
 21314 0000339D 1F                      	pop	ds
 21315 0000339E E835FE                  	CALL	SWAPBACK
 21316 000033A1 8936[2200]              	MOV	[CONTPOS],SI
 21317                                  
 21318                                  	; 16/12/2022
 21319                                  ;ENDRDDEV:
 21320                                  ;;hkn; SS is DOSDATA
 21321                                  ;	push	ss
 21322                                  ;	pop	ds
 21323                                  endrddev1:	; 04/05/2019
 21324 000033A5 893E[B805]              	MOV	[NEXTADD],DI
 21325 000033A9 7509                    	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
 21326 000033AB C43E[9E05]              	LES	DI,[THISSFT]
 21327                                  	;and	byte [es:di+5],0BFh
 21328 000033AF 26806505BF              	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF
 21329                                  				; Mark as no more data available
 21330                                  SETSFTC:
 21331                                  	; 31/07/2019
 21332                                  	;call	SETSFT
 21333                                  	;retn
 21334 000033B4 E9A904                  	jmp	SETSFT
 21335                                  
 21336                                  ; 16/12/2022
 21337                                  %if 0
 21338                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21339                                  ENDRDDEV:
 21340                                  ;hkn; SS is DOSDATA
 21341                                  	push	ss
 21342                                  	pop	ds
 21343                                  	MOV	[NEXTADD],DI
 21344                                  	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
 21345                                  	LES	DI,[THISSFT]
 21346                                  	;and	byte [es:di+5],0BFh
 21347                                  	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF
 21348                                  				; Mark as no more data available
 21349                                  SETSFTC:
 21350                                  	;call	SETSFT
 21351                                  	;retn
 21352                                  	jmp	SETSFT	
 21353                                  %endif
 21354                                  
 21355                                  READCON:
 21356 000033B7 E822FE                  	CALL	SWAPCON
 21357 000033BA 8B36[2200]              	MOV	SI,[CONTPOS]
 21358 000033BE 09F6                    	OR	SI,SI
 21359 000033C0 75C4                    	JNZ	short TRANBUF
 21360 000033C2 803E[7B02]80            	CMP	BYTE [CONBUF],128 ; 80h
 21361 000033C7 7406                    	JZ	short GETBUF
 21362 000033C9 C706[7B02]80FF          	MOV	WORD [CONBUF],0FF80H ; Set up 128-byte buffer with no template
 21363                                  GETBUF:
 21364 000033CF 51                      	PUSH	CX
 21365 000033D0 06                      	PUSH	ES
 21366 000033D1 57                      	PUSH	DI
 21367                                  
 21368                                  ;hkn; CONBUF is in DOSDATA
 21369 000033D2 BA[7B02]                	MOV	DX,CONBUF
 21370                                  
 21371 000033D5 E8D8DF                  	call	_$STD_CON_STRING_INPUT	; Get input buffer
 21372 000033D8 5F                      	POP	DI
 21373 000033D9 07                      	POP	ES
 21374 000033DA 59                      	POP	CX
 21375                                  
 21376                                  ;hkn; CONBUF is in DOSDATA
 21377 000033DB BE[7D02]                	MOV	SI,CONBUF+2
 21378                                  
 21379 000033DE 803C1A                  	CMP	BYTE [SI],1AH	; Check for Ctrl-Z in first character
 21380 000033E1 75A3                    	JNZ	short TRANBUF
 21381 000033E3 B01A                    	MOV	AL,1AH
 21382 000033E5 AA                      	STOSB
 21383 000033E6 4F                      	DEC	DI
 21384 000033E7 B00A                    	MOV	AL,c_LF
 21385 000033E9 E849E2                  	call	OUTT		; Send linefeed
 21386 000033EC 31F6                    	XOR	SI,SI
 21387 000033EE EBAC                    	JMP	short ENDRDCON ; 04/05/2019
 21388                                  
 21389                                  ; 24/07/2018 - Retro DOS v3.0
 21390                                  
 21391                                  ;Break	<DOS_WRITE -- MAIN WRITE ROUTINE AND DEVICE OUT ROUTINES>
 21392                                  ;---------------------------------------------------------------------------
 21393                                  ;
 21394                                  ; Procedure Name : DOS_WRITE
 21395                                  ;
 21396                                  ; Inputs:
 21397                                  ;	ThisSFT set to the SFT for the file being used
 21398                                  ;	[DMAADD] contains transfer address
 21399                                  ;	CX = No. of bytes to write
 21400                                  ; Function:
 21401                                  ;	Perform write operation
 21402                                  ;	NOTE: If CX = 0 on input, file is truncated or grown
 21403                                  ;		to current sf_position
 21404                                  ; Outputs:
 21405                                  ;    Carry clear
 21406                                  ;	SFT Position and cluster pointers updated
 21407                                  ;	CX = No. of bytes written
 21408                                  ;	ES:DI point to SFT
 21409                                  ;    Carry set
 21410                                  ;	AX is error code
 21411                                  ;	CX = 0
 21412                                  ;	ES:DI point to SFT
 21413                                  ; DS preserved, all other registers destroyed
 21414                                  ;---------------------------------------------------------------------------
 21415                                  
 21416                                  ;hkn; called from fcbio2.asm, handle.asm and dev.asm. DS is set up at this 
 21417                                  ;hkn; point to DOSDATA.
 21418                                  
 21419                                  ; 04/05/2019 - Retro DOS v4.0
 21420                                  ; DOSCODE:742Ch (MSDOS 6.21, MSDOS.SYS)
 21421                                  
 21422                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21423                                  ; DOSCODE:7418h (MSDOS 5.0, MSDOS.SYS)
 21424                                  
 21425                                  DOS_WRITE:
 21426 000033F0 C43E[9E05]              	LES	DI,[THISSFT]
 21427                                  	;mov	al,[ES:DI+2]
 21428 000033F4 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 21429                                  	;and	al,0Fh
 21430 000033F8 240F                    	AND	AL,access_mask
 21431                                  	;cmp	al,0
 21432 000033FA 3C00                    	CMP	AL,open_for_read
 21433 000033FC 7503                    	JNE	short Check_FCB_RO		 ;Is write or both
 21434                                  BadMode:
 21435 000033FE E9CD03                  	jmp	SET_ACC_ERR
 21436                                  
 21437                                  ; NOTE: The following check for writting to a Read Only File is performed
 21438                                  ;	    ONLY on FCBs!!!!
 21439                                  ;	We ALLOW writes to Read Only files via handles to allow a CREATE
 21440                                  ;	    of a read only file which can then be written to.
 21441                                  ;	This is OK because we are NOT ALLOWED to OPEN a RO file via handles
 21442                                  ;	    for writting, or RE-CREATE an EXISTING RO file via handles. Thus,
 21443                                  ;	    CREATing a NEW RO file, or RE-CREATing an existing file which
 21444                                  ;	    is NOT RO to be RO, via handles are the only times we can write
 21445                                  ;	    to a read-only file.
 21446                                  
 21447                                  Check_FCB_RO:
 21448                                  	;;test	word [es:di+2],8000h
 21449                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 21450                                  	;JZ	short WRITE_NO_MODE	; Not an FCB
 21451                                  	
 21452                                  	;test	byte [es:di+3],80h
 21453 00003401 26F6450380              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 21454 00003406 7407                    	JZ	short WRITE_NO_MODE	; Not an FCB
 21455                                  
 21456                                  	;test	byte [es:di+4],1
 21457 00003408 26F6450401              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_read_only
 21458 0000340D 75EF                    	JNZ	short BadMode 		; Can't write to Read_Only files via FCB
 21459                                  WRITE_NO_MODE:
 21460 0000340F E8A402                  	call	SETUP
 21461 00003412 E82DDE                  	call	IsSFTNet
 21462 00003415 7406                    	JZ	short LOCAL_WRITE
 21463                                  
 21464                                  ;IF NOT Installed
 21465                                  ;	transfer NET_WRITE
 21466                                  ;ELSE
 21467                                  	;mov	ax,1109h
 21468 00003417 B80911                  	MOV	AX,(MultNET<<8)|9
 21469 0000341A CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
 21470                                  			; ES:DI -> SFT
 21471                                  			; SFT DPB field -> DPB of drive containing file
 21472                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 21473                                  			; Return: CF set on error, CX = bytes written
 21474 0000341C C3                      	retn
 21475                                  ;ENDIF
 21476                                  
 21477                                  LOCAL_WRITE:
 21478                                  	;;test	word [es:di+5],80h
 21479                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 21480                                  	;jnz	short WRTDEV
 21481                                  
 21482                                  	;test	byte [es:di+5],80h
 21483 0000341D 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; Check for named device I/O
 21484 00003422 756D                    	jnz	short WRTDEV
 21485                                  
 21486                                  	;mov	byte [EXTERR_LOCUS],2
 21487 00003424 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 21488 00003429 E8B6DE                  	call	ECritDisk
 21489                                  
 21490 0000342C E8E104                  	call	DISKWRITE
 21491                                  
 21492                                  	; 04/05/2019 - Retro DOS v4.0
 21493                                  
 21494                                  	; MSDOS 6.0
 21495                                  ; Extended Open
 21496 0000342F 7210                    	JC	short nocommit
 21497                                  	
 21498 00003431 C43E[9E05]              	LES	DI,[THISSFT]
 21499                                  	
 21500                                  	;;test	word [ES:DI+2],4000h
 21501                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],AUTO_COMMIT_WRITE
 21502                                  	;JZ	short nocommit
 21503                                  	
 21504                                  	;test	byte [ES:DI+3],40h
 21505 00003435 26F6450340              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(AUTO_COMMIT_WRITE>>8)
 21506 0000343A 7405                    	JZ	short nocommit
 21507                                  	
 21508 0000343C 51                      	PUSH	CX
 21509 0000343D E86CFB                  	call	DOS_COMMIT
 21510 00003440 59                      	POP	CX
 21511                                  nocommit:
 21512                                  ; Extended Open
 21513                                  	;call	LCritDisk
 21514                                  	;retn
 21515                                  	; 18/12/2022
 21516 00003441 E9B9DE                  	jmp	LCritDisk
 21517                                  
 21518                                  DVWRTRAW:
 21519 00003444 31C0                    	XOR	AX,AX			; Media Byte, unit = 0
 21520 00003446 E87411                  	call	SETWRITE
 21521 00003449 1E                      	PUSH	DS			; Save seg of transfer
 21522                                  
 21523                                  ;hkn; SS override
 21524 0000344A 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 21525 0000344F E8B410                  	call	DEVIOCALL		; DS:SI -> DEVICE
 21526                                  
 21527 00003452 89FA                    	MOV	DX,DI			; Offset part of Xaddr saved in DX
 21528 00003454 B487                    	MOV	AH,87H
 21529                                  
 21530                                  ;hkn; SS override
 21531 00003456 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 21532                                  
 21533                                  	; MSDOS 3.3
 21534                                  	;test	di,8000h
 21535                                  	;jz	short CWRTROK
 21536                                  
 21537                                  	; MSDOS 6.0
 21538 0000345B 09FF                    	or	di,di
 21539 0000345D 791F                    	jns	short CWRTROK
 21540                                  	
 21541                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21542 0000345F E8E41C                  	call	CHARHARD
 21543                                  
 21544                                  	; 04/05/2019  - Retro DOS v4.0
 21545                                  
 21546                                  	; MSDOS 6.0
 21547                                  	;sub	cx,[ss:CALLSCNT]	; update ptr & count to reflect	M065
 21548                                  	; 08/02/2024
 21549 00003462 368B3E[6C03]            	mov	di,[ss:CALLSCNT]
 21550 00003467 29F9                    	sub	cx,di
 21551 00003469 89D3                    	mov	bx,dx			; number of chars xferred	M065
 21552                                  	;add	bx,[ss:CALLSCNT]	;				M065
 21553 0000346B 01FB                    	add	bx,di
 21554 0000346D 89DF                    	mov	di,bx			;				M065
 21555                                  	
 21556                                  	; MSDOS 3.3
 21557                                  	;MOV	BX,DX			; Recall transfer addr		M065
 21558                                  
 21559                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21560 0000346F 08C0                    	OR	AL,AL
 21561 00003471 740B                    	JZ	short CWRTROK 		; Ignore
 21562 00003473 3C03                    	CMP	AL,3
 21563 00003475 7403                    	JZ	short CWRFERR
 21564 00003477 1F                      	POP	DS			; Recover saved seg of transfer
 21565 00003478 EBCA                    	JMP	short DVWRTRAW		; Try again
 21566                                  CWRFERR:
 21567 0000347A 58                      	POP	AX			; Chuck saved seg of transfer
 21568 0000347B E914FE                  	JMP	CRDFERR 		; Will pop one more stack element
 21569                                  CWRTROK:
 21570 0000347E 58                      	POP	AX			; Chuck saved seg of transfer
 21571 0000347F 1F                      	POP	DS
 21572 00003480 A1[6C03]                	MOV	AX,[CALLSCNT]		; Get actual number of bytes transferred
 21573                                  ENDWRDEV:
 21574 00003483 C43E[9E05]              	LES	DI,[THISSFT]
 21575 00003487 89C1                    	MOV	CX,AX
 21576                                  	;call	ADDREC
 21577                                  	;retn
 21578                                  	; 16/12/2022
 21579                                  	; 10/06/2019
 21580 00003489 E9F503                  	jmp	ADDREC
 21581                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21582                                  	;call	ADDREC
 21583                                  	;retn
 21584                                  	
 21585                                  WRTNUL:
 21586 0000348C 89CA                    	MOV	DX,CX			; Entire transfer done
 21587                                  WRTCOOKJ:
 21588 0000348E E98D00                  	JMP	WRTCOOKDONE
 21589                                  WRTDEV:
 21590                                  	;mov	byte [EXTERR_LOCUS],4
 21591 00003491 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 21592                                  	;or	byte [es:di+5],40h
 21593 00003496 26804D0540              	OR	BYTE [ES:DI+SF_ENTRY.sf_flags],devid_device_EOF
 21594                                  					; Reset EOF for input
 21595                                  	;mov	bl,[es:di+5]
 21596 0000349B 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 21597 0000349F 31C0                    	XOR	AX,AX
 21598 000034A1 E3E0                    	JCXZ	ENDWRDEV		; problem of creating on a device.
 21599 000034A3 1E                      	PUSH	DS
 21600 000034A4 88D8                    	MOV	AL,BL
 21601 000034A6 C51E[2C03]              	LDS	BX,[DMAADD]		; Xaddr to DS:BX
 21602 000034AA 89DF                    	MOV	DI,BX			; Xaddr to DS:DI
 21603 000034AC 31D2                    	XOR	DX,DX			; Set starting point
 21604                                  	;test	al,20h
 21605 000034AE A820                    	test	AL,devid_device_raw	; Raw?
 21606                                  	;JZ	short TEST_DEV_CON
 21607                                  	;JMP	DVWRTRAW
 21608                                  	; 16/12/2022
 21609 000034B0 7592                    	jnz	short DVWRTRAW
 21610                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21611                                  	;JZ	short TEST_DEV_CON
 21612                                  	;JMP	short DVWRTRAW
 21613                                  
 21614                                  TEST_DEV_CON:
 21615                                  	;test	al,2
 21616 000034B2 A802                    	test	AL,devid_device_con_out ; Console output device?
 21617 000034B4 756E                    	jnz	short WRITECON
 21618                                  	;test	al,4
 21619 000034B6 A804                    	test	AL,devid_device_null
 21620 000034B8 75D2                    	JNZ	short WRTNUL
 21621 000034BA 89D0                    	MOV	AX,DX
 21622 000034BC 803F1A                  	CMP	BYTE [BX],1Ah		; ^Z?
 21623 000034BF 74CD                    	JZ	short WRTCOOKJ		; Yes, transfer nothing
 21624 000034C1 51                      	PUSH	CX
 21625 000034C2 B90100                  	MOV	CX,1
 21626 000034C5 E8F510                  	call	SETWRITE
 21627 000034C8 59                      	POP	CX
 21628                                  
 21629                                  ;hkn; SS override
 21630 000034C9 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 21631                                  ;
 21632                                  ;SR; Removed X25 support from here
 21633                                  ;
 21634                                  	;lds	si,[si+7]
 21635 000034CE C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 21636                                  DVWRTLP:
 21637 000034D1 E8571A                  	call	DSKSTATCHK
 21638 000034D4 E83210                  	call	DEVIOCALL2
 21639 000034D7 57                      	PUSH	DI
 21640 000034D8 B487                    	MOV	AH,87H
 21641                                  
 21642                                  ;hkn; SS override
 21643 000034DA 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 21644                                  	
 21645                                  	; MSDOS 3.3
 21646                                  	;test	di,8000h
 21647                                  	;jz	short CWROK
 21648                                  
 21649                                  	; MSDOS 6.0
 21650 000034DF 09FF                    	or	di,di
 21651 000034E1 7916                    	jns	short CWROK
 21652                                  	
 21653                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21654 000034E3 E8601C                  	call	CHARHARD
 21655 000034E6 5F                      	POP	DI
 21656                                  
 21657                                  ;hkn; SS override
 21658 000034E7 36C706[6C03]0100        	MOV	word [SS:CALLSCNT],1
 21659 000034EE 3C01                    	CMP	AL,1
 21660 000034F0 74DF                    	JZ	short DVWRTLP 	; Retry
 21661 000034F2 08C0                    	OR	AL,AL
 21662 000034F4 740C                    	JZ	short DVWRTIGN	; Ignore
 21663                                  	; 10/08/2018
 21664 000034F6 E999FD                  	JMP	CRDFERR 	; Fail, pops one stack element
 21665                                  CWROK:
 21666 000034F9 5F                      	POP	DI
 21667                                  
 21668                                  ;hkn; SS override
 21669 000034FA 36833E[6C03]00          	CMP	word [SS:CALLSCNT],0
 21670 00003500 741C                    	JZ	short WRTCOOKDONE
 21671                                  DVWRTIGN:
 21672 00003502 42                      	INC	DX
 21673                                  
 21674                                  ;hkn; SS override for CALLXAD
 21675 00003503 36FF06[6803]            	INC	WORD [SS:CALLXAD]
 21676 00003508 47                      	INC	DI
 21677 00003509 1E                      	PUSH	DS
 21678 0000350A 368E1E[6A03]            	MOV	DS,[SS:CALLXAD+2]
 21679 0000350F 803D1A                  	CMP	BYTE [DI],1Ah	; ^Z?
 21680 00003512 1F                      	POP	DS
 21681 00003513 7409                    	JZ	short WRTCOOKDONE
 21682                                  
 21683                                  ;hkn; SS override
 21684 00003515 36C706[5D03]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 21685 0000351C E2B3                    	LOOP	DVWRTLP
 21686                                  WRTCOOKDONE:
 21687 0000351E 89D0                    	MOV	AX,DX
 21688 00003520 1F                      	POP	DS
 21689 00003521 E95FFF                  	JMP	ENDWRDEV ; 10/08/2018
 21690                                  
 21691                                  WRITECON:
 21692 00003524 1E                      	PUSH	DS
 21693                                  
 21694                                  ;hkn; SS is DOSDATA
 21695 00003525 16                      	push	ss
 21696 00003526 1F                      	pop	ds
 21697 00003527 E8B2FC                  	CALL	SWAPCON
 21698 0000352A 1F                      	POP	DS
 21699 0000352B 89DE                    	MOV	SI,BX
 21700 0000352D 51                      	PUSH	CX
 21701                                  WRCONLP:
 21702 0000352E AC                      	LODSB
 21703 0000352F 3C1A                    	CMP	AL,1Ah		; ^Z?
 21704 00003531 7405                    	JZ	short CONEOF
 21705 00003533 E8FFE0                  	call	OUTT
 21706 00003536 E2F6                    	LOOP	WRCONLP
 21707                                  CONEOF:
 21708 00003538 58                      	POP	AX			; Count
 21709 00003539 1F                      	POP	DS
 21710 0000353A 29C8                    	SUB	AX,CX			; Amount actually written
 21711 0000353C E897FC                  	CALL	SWAPBACK
 21712 0000353F E941FF                  	JMP	ENDWRDEV
 21713                                  
 21714                                  ;---------------------------------------------------------------------------
 21715                                  ;
 21716                                  ; Procedure Name : get_io_sft
 21717                                  ;
 21718                                  ;   Convert JFN number in BX to sf_entry in DS:SI We get the normal SFT if
 21719                                  ;   CONSWAP is FALSE or if the handle desired is 2 or more. Otherwise, we
 21720                                  ;   retrieve the sft from ConSFT which is set by SwapCon.
 21721                                  ;
 21722                                  ;---------------------------------------------------------------------------
 21723                                  
 21724                                  ; 04/05/2019 - Retro DOS v4.0
 21725                                  ; DOSCODE:7583h (MSDOS 6.21, MSDOS.SYS)
 21726                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21727                                  ; DOSCODE:756Fh (MSDOS 5.0, MSDOS.SYS)
 21728                                  
 21729                                  GET_IO_SFT:
 21730                                  	;test	byte [SS:CONSWAP],0FFh
 21731 00003542 36803E[5703]00          	cmp	byte [SS:CONSWAP],0			;smr;SS Override
 21732 00003548 7512                    	JNZ	short GetRedir
 21733                                  GetNormal:
 21734 0000354A 16                      	push	ss
 21735 0000354B 1F                      	pop	ds
 21736 0000354C 06                      	PUSH	ES
 21737 0000354D 57                      	PUSH	DI
 21738 0000354E E8742F                  	call	SFFromHandle
 21739 00003551 7206                    	JC	short RET44P
 21740 00003553 8CC6                    	MOV	SI,ES
 21741 00003555 8EDE                    	MOV	DS,SI
 21742 00003557 89FE                    	MOV	SI,DI
 21743                                  RET44P:
 21744 00003559 5F                      	POP	DI
 21745 0000355A 07                      	POP	ES
 21746 0000355B C3                      	retn
 21747                                  GetRedir:
 21748 0000355C 83FB01                  	CMP	BX,1
 21749 0000355F 77E9                    	JA	short GetNormal
 21750 00003561 36C536[E605]            	LDS	SI,[SS:CONSFT]
 21751 00003566 F8                      	CLC
 21752                                  get_io_sft_retn:
 21753 00003567 C3                      	retn
 21754                                  
 21755                                  ;Break	<DIRREAD -- READ A DIRECTORY SECTOR>
 21756                                  ;---------------------------------------------------------------------------
 21757                                  ;
 21758                                  ; Procedure Name : DIRREAD
 21759                                  ;
 21760                                  ; Inputs:
 21761                                  ;	AX = Directory block number (relative to first block of directory)
 21762                                  ;	ES:BP = Base of drive parameters
 21763                                  ;	[DIRSEC] = First sector of first cluster of directory
 21764                                  ;	[CLUSNUM] = Next cluster
 21765                                  ;	[CLUSFAC] = Sectors/Cluster
 21766                                  ; Function:
 21767                                  ;	Read the directory block into [CURBUF].
 21768                                  ; Outputs:
 21769                                  ;	[NXTCLUSNUM] = Next cluster (after the one skipped to)
 21770                                  ;	[SECCLUSPOS] Set
 21771                                  ;	ES:BP unchanged
 21772                                  ;	[CURBUF] Points to Buffer with dir sector
 21773                                  ;	Carry set if error (user said FAIL to I 24)
 21774                                  ; DS preserved, all other registers destroyed.
 21775                                  ;---------------------------------------------------------------------------
 21776                                  
 21777                                  ;hkn; called from dir.asm. DS already set up to DOSDATA.
 21778                                  
 21779                                  DIRREAD:
 21780                                  
 21781                                  ; Note that ClusFac is the sectors per cluster. This is NOT necessarily
 21782                                  ; the same as what is in the DPB! In the case of the root directory, we have
 21783                                  ; ClusFac = # sectors in the root directory. The root directory is detected
 21784                                  ; by DIRStart = 0.
 21785                                  
 21786 00003568 31D2                    	XOR	DX,DX
 21787                                  	;CMP	word [DIRSTART],0
 21788                                  	; 21/09/2023
 21789 0000356A 3916[C205]              	cmp	[DIRSTART],dx ; 0
 21790 0000356E 7503                    	jnz	short SubDir
 21791 00003570 92                      	XCHG	AX,DX
 21792 00003571 EB0C                    	JMP	short DoRead
 21793                                  
 21794                                  ; Convert the sector number in AX into cluster and sector-within-cluster pair
 21795                                  
 21796                                  SubDir:
 21797 00003573 88C2                    	MOV	DL,AL
 21798                                  	;and	dl,[es:bp+4]
 21799 00003575 26225604                	AND	DL,[ES:BP+DPB.CLUSTER_MASK]
 21800                                  
 21801                                  ;	(DX) = sector-in-cluster
 21802                                  
 21803                                  	;mov	cl,[es:bp+5]
 21804 00003579 268A4E05                	MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 21805 0000357D D3E8                    	SHR	AX,CL
 21806                                  
 21807                                  ;	(DX) = position in cluster
 21808                                  ;	(AX) = number of clusters to skip
 21809                                  
 21810                                  DoRead:
 21811 0000357F 8816[7305]              	MOV	[SECCLUSPOS],DL
 21812 00003583 89C1                    	MOV	CX,AX
 21813 00003585 88D4                    	MOV	AH,DL
 21814                                  
 21815                                  ;	(CX) = number of clusters to skip.
 21816                                  ;	(AH) = remainder
 21817                                  
 21818                                  	; 04/05/2019 - Retro DOS v4.0
 21819                                  	 
 21820                                  	; MSDOS 6.0
 21821                                  	;MOV	DX,[DIRSEC+2]	     	  ;>32mb
 21822                                  	;MOV	[HIGH_SECTOR],DX	  ;>32mb
 21823                                  	;MOV	DX,[DIRSEC]
 21824                                  	;ADD	DL,AH
 21825                                  	;ADC	DH,0
 21826                                  	;ADC	word [HIGH_SECTOR],0	  ;>32mb
 21827                                  	; 21/09/2023
 21828 00003587 31DB                    	xor	bx,bx ; 0
 21829 00003589 8B16[BE05]              	mov	dx,[DIRSEC]
 21830 0000358D 00E2                    	add	dl,ah
 21831 0000358F 10DE                    	adc	dh,bl ; 0
 21832 00003591 131E[C005]              	adc	bx,[DIRSEC+2]
 21833 00003595 891E[0706]              	mov	[HIGH_SECTOR],bx
 21834                                  
 21835 00003599 8B1E[BC05]              	MOV	BX,[CLUSNUM]
 21836 0000359D 891E[DC05]              	MOV	[NXTCLUSNUM],BX
 21837 000035A1 E319                    	JCXZ	FIRSTCLUSTER
 21838                                  SKPCLLP:
 21839 000035A3 E8071E                  	call	UNPACK
 21840 000035A6 72BF                    	jc	short get_io_sft_retn
 21841 000035A8 87DF                    	XCHG	BX,DI
 21842 000035AA E8E91D                  	call	IsEOF			; test for eof based on fat size
 21843 000035AD 7302                    	JAE	short HAVESKIPPED
 21844 000035AF E2F2                    	LOOP	SKPCLLP
 21845                                  HAVESKIPPED:
 21846 000035B1 891E[DC05]              	MOV	[NXTCLUSNUM],BX
 21847 000035B5 89FA                    	MOV	DX,DI
 21848 000035B7 88E3                    	MOV	BL,AH
 21849 000035B9 E8B116                  	call	FIGREC
 21850                                  
 21851                                  	;entry	FIRSTCLUSTER
 21852                                  
 21853                                  FIRSTCLUSTER:
 21854                                  	; 22/09/2023
 21855                                  	;;mov	byte [ALLOWED],18h
 21856                                  	;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 21857                                  	;XOR	AL,AL ; *	; Indicate pre-read
 21858                                  	;call	GETBUFFR
 21859 000035BC E8F221                  	call	GETBUFFER ; *	; pre-read
 21860 000035BF 72A6                    	jc	short get_io_sft_retn
 21861                                  
 21862                                  	;entry	SET_BUF_AS_DIR
 21863                                  
 21864                                  SET_BUF_AS_DIR:
 21865                                  
 21866                                  ;	Set the type of CURBUF to be a directory sector.
 21867                                  ;	Only flags are modified.
 21868                                  
 21869 000035C1 1E                      	PUSH	DS
 21870 000035C2 56                      	PUSH	SI
 21871 000035C3 C536[E205]              	LDS	SI,[CURBUF]
 21872                                  	;or	byte [si+5],4
 21873 000035C7 804C0504                	OR	byte [SI+BUFFINFO.buf_flags],buf_isDIR	; Clears carry
 21874 000035CB 5E                      	POP	SI
 21875 000035CC 1F                      	POP	DS
 21876                                  dirread_retn:
 21877 000035CD C3                      	retn
 21878                                  
 21879                                  ;Break	<FATSECRD -- READ A FAT SECTOR>
 21880                                  ;----------------------------------------------------------------------------
 21881                                  ;
 21882                                  ; Procedure Name : FATSECRD
 21883                                  ; Inputs:
 21884                                  ;	Same as DREAD
 21885                                  ;	DS:BX = Transfer address
 21886                                  ;	CX = Number of sectors
 21887                                  ;	DX = Absolute record number
 21888                                  ;	ES:BP = Base of drive parameters
 21889                                  ; Function:
 21890                                  ;	Calls BIOS to perform FAT read.
 21891                                  ; Outputs:
 21892                                  ;	Same as DREAD
 21893                                  ;---------------------------------------------------------------------------
 21894                                  
 21895                                  	; 04/05/2019 - Retro DOS v4.0
 21896                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21897                                  
 21898                                  FATSECRD:
 21899                                  ;hkn; SS override
 21900                                  	;mov	byte [ss:ALLOWED],18h
 21901 000035CE 36C606[4B03]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 21902 000035D4 89CF                    	MOV	DI,CX
 21903                                  	;mov	cl,[es:bp+8]
 21904 000035D6 268A4E08                	MOV	CL,[ES:BP+DPB.FAT_COUNT]
 21905                                  	; MSDOS 3.3
 21906                                  	;;mov	al,[es:bp+0Fh]
 21907                                  	;MOV	AL,[ES:BP+DPB.FAT_SIZE]
 21908                                  	;XOR	AH,AH
 21909                                  	; MSDOS 6.0
 21910                                  	;mov	ax,[es:bp+0Fh]
 21911 000035DA 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE] ;>32mb
 21912 000035DE 30ED                    	XOR	CH,CH
 21913 000035E0 52                      	PUSH	DX
 21914                                  NXTFAT:
 21915                                  	; MSDOS 6.0
 21916                                  ;hkn; SS override
 21917 000035E1 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0	;>32mb FAT sectors cannot exceed
 21918 000035E8 51                      	PUSH	CX			;32mb
 21919 000035E9 50                      	PUSH	AX
 21920 000035EA 89F9                    	MOV	CX,DI
 21921 000035EC E85B00                  	call	DSKREAD
 21922 000035EF 58                      	POP	AX
 21923 000035F0 59                      	POP	CX
 21924 000035F1 7420                    	JZ	short RET41P		; Carry clear
 21925 000035F3 01C2                    	ADD	DX,AX
 21926 000035F5 E2EA                    	LOOP	NXTFAT
 21927 000035F7 5A                      	POP	DX
 21928 000035F8 89F9                    	MOV	CX,DI
 21929                                  
 21930                                  ; NOTE FALL THROUGH
 21931                                  
 21932                                  ;Break	<DREAD -- DO A DISK READ>
 21933                                  ;---------------------------------------------------------------------------
 21934                                  ;
 21935                                  ; Procedure Name : DREAD
 21936                                  ;
 21937                                  ; Inputs:
 21938                                  ;	DS:BX = Transfer address
 21939                                  ;	CX = Number of sectors
 21940                                  ;	DX = Absolute record number	      (LOW)
 21941                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 21942                                  ;	ES:BP = Base of drive parameters
 21943                                  ;	[ALLOWED] must be set in case call to HARDERR needed
 21944                                  ; Function:
 21945                                  ;	Calls BIOS to perform disk read. If BIOS reports
 21946                                  ;	errors, will call HARDERRRW for further action.
 21947                                  ; Outputs:
 21948                                  ;	Carry set if error (currently user FAILED to INT 24)
 21949                                  ; DS,ES:BP preserved. All other registers destroyed.
 21950                                  ;---------------------------------------------------------------------------
 21951                                  
 21952                                  	;entry	DREAD
 21953                                  DREAD:
 21954 000035FA E84D00                  	call	DSKREAD
 21955 000035FD 74CE                    	jz	short dirread_retn	; Carry clear
 21956                                  ;hkn; SS override
 21957 000035FF 36C606[7505]00          	MOV	BYTE [SS:READOP],0
 21958 00003605 E89500                  	call	HARDERRRW
 21959 00003608 3C01                    	CMP	AL,1			; Check for retry
 21960 0000360A 74EE                    	JZ	short DREAD
 21961                                  
 21962                                  fail_ignore:	; 09/02/2024
 21963 0000360C 3C03                    	CMP	AL,3			; Check for FAIL
 21964 0000360E F8                      	CLC
 21965 0000360F 7501                    	JNZ	short NO_CAR		; Ignore
 21966 00003611 F9                      	STC
 21967                                  NO_CAR:
 21968 00003612 C3                      	retn
 21969                                  RET41P: 
 21970 00003613 5A                      	POP	DX
 21971 00003614 C3                      	retn
 21972                                  
 21973                                  ; 24/07/2018 - Retro DOS v3.0
 21974                                  
 21975                                  ;Break	<CHECK_WRITE_LOCK>
 21976                                  ;---------------------------------------------------------------------------
 21977                                  ;
 21978                                  ; Procedure Name : CHECK_WRITE_LOCK
 21979                                  ;
 21980                                  ; Inputs:
 21981                                  ;	output of SETUP
 21982                                  ;	ES:DI -> SFT
 21983                                  ; Function:
 21984                                  ;	check write lock
 21985                                  ; Outputs:
 21986                                  ;	Carry set if error
 21987                                  ;	Carry clear if ok
 21988                                  ;
 21989                                  ;----------------------------------------------------------------------------
 21990                                  
 21991                                  	; 04/05/2019 - Retro DOS v4.0
 21992                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21993                                  
 21994                                  CHECK_WRITE_LOCK:
 21995                                  	; MSDOS 6.0
 21996                                  	;test	byte [es:di+4],8
 21997 00003615 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 21998                                  	;JZ	short write_cont			     ;no
 21999                                  	;;call	SET_ACC_ERR_DS
 22000                                  	;;retn
 22001                                  	;;jnz	SET_ACC_ERR_DS
 22002                                  	; 19/08/2018
 22003                                  	;jz	short write_cont
 22004                                  	;jmp	SET_ACC_ERR_DS
 22005                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22006 0000361A 7403                    	JZ	short write_cont
 22007                                  	;call	SET_ACC_ERR_DS
 22008                                  	;retn
 22009                                  	; 16/12/2022
 22010 0000361C E9AD01                  	jmp	SET_ACC_ERR_DS
 22011                                  
 22012                                  write_cont:				;
 22013 0000361F 51                      	PUSH	CX			;save reg
 22014 00003620 09C9                    	OR	CX,CX			;
 22015 00003622 7501                    	JNZ	short Not_Truncate	;
 22016 00003624 49                      	dec	cx			;(cx) = -1; check for lock on whole file
 22017                                  Not_Truncate:				;
 22018 00003625 B080                    	MOV	AL,80H			;check write access
 22019 00003627 E8D73A                  	call	LOCK_CHECK		;check lock
 22020 0000362A 59                      	POP	CX			;restore reg
 22021 0000362B 7305                    	JNC	short WRITE_OK		;lock ok
 22022 0000362D E85A01                  	call	WRITE_LOCK_VIOLATION	;issue I24
 22023 00003630 73ED                    	JNC	short write_cont	;retry
 22024                                  WRITE_OK:				;
 22025 00003632 C3                      	retn				;
 22026                                  
 22027                                  ;Break	<CHECK_READ_LOCK>
 22028                                  ;---------------------------------------------------------------------------
 22029                                  ;
 22030                                  ; Procedure Name : CHECK_READ_LOC
 22031                                  ;
 22032                                  ; Inputs:
 22033                                  ;	ES:DI -> SFT
 22034                                  ;	output of SETUP
 22035                                  ; Function:
 22036                                  ;	check read lock
 22037                                  ; Outputs:
 22038                                  ;	Carry set if error
 22039                                  ;	Carry clear if ok
 22040                                  ;----------------------------------------------------------------------------
 22041                                  
 22042                                  CHECK_READ_LOCK:
 22043                                  	; MSDOS 6.0
 22044                                  	;test	byte [es:di+4],8
 22045 00003633 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 22046                                  	;JZ	short do_retry			   	     ; no
 22047                                  	;;call	SET_ACC_ERR
 22048                                  	;;retn
 22049                                  	;;jnz	SET_ACC_ERR
 22050                                  	; 16/12/2022
 22051                                  	; 28/07/2019
 22052 00003638 7403                    	jz	short do_retry
 22053 0000363A E99101                  	jmp	SET_ACC_ERR
 22054                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22055                                  	;JZ	short do_retry
 22056                                  	;call	SET_ACC_ERR
 22057                                  	;retn
 22058                                  do_retry:				;
 22059 0000363D 30C0                    	xor	al,al			;check read access
 22060 0000363F E8BF3A                  	call	LOCK_CHECK		;check lock
 22061 00003642 7305                    	JNC	short READLOCK_OK 	;lock ok
 22062 00003644 E82301                  	call	READ_LOCK_VIOLATION	;issue I24
 22063 00003647 73F4                    	JNC	short do_retry		;retry
 22064                                  READLOCK_OK:				;
 22065                                  dw_ret_label:	; 09/02/2024
 22066 00003649 C3                      	retn				;
 22067                                  
 22068                                  ;============================================================================
 22069                                  ; DISK2.ASM, MSDOS 6.0, 1991
 22070                                  ;============================================================================
 22071                                  ; 24/07/2018 - Retro DOS v3.0
 22072                                  ; 04/05/2019 - Retro DOS v4.0
 22073                                  
 22074                                  ;	TITLE	DISK2 - Disk utility routines
 22075                                  ;	NAME	Disk2
 22076                                  
 22077                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 22078                                  ;
 22079                                  ;	DskRead
 22080                                  ;	DWRITE
 22081                                  ;	DSKWRITE
 22082                                  ;	HarderrRW
 22083                                  ;	SETUP
 22084                                  ;	BREAKDOWN
 22085                                  ;	READ_LOCK_VIOLATION
 22086                                  ;	WRITE_LOCK_VIOLATION
 22087                                  ;	DISKREAD
 22088                                  ;	SET_ACC_ERR_DS
 22089                                  ;	SET_ACC_ERR
 22090                                  ;	SETSFT
 22091                                  ;	SETCLUS
 22092                                  ;	AddRec
 22093                                  ;
 22094                                  ;	Revision history:
 22095                                  ;
 22096                                  ;		AN000 version 4.00 Jan. 1988
 22097                                  ;		M039 DB 10/17/90 - Disk read/write optimization
 22098                                  
 22099                                  ; 04/05/2019 - Retro DOS v4.0
 22100                                  ; DOSCODE:7699h (MSDOS 6.21, MSDOS.SYS)
 22101                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22102                                  ; DOSCODE:7685h (MSDOS 5.0, MSDOS.SYS)
 22103                                  
 22104                                  ;Break	<DSKREAD -- PHYSICAL DISK READ>
 22105                                  ;---------------------------------------------------------------------------
 22106                                  ;
 22107                                  ; Procedure Name : DSKREAD
 22108                                  ;
 22109                                  ; Inputs:
 22110                                  ;	DS:BX = Transfer addr
 22111                                  ;	CX = Number of sectors
 22112                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 22113                                  ;	DX = Absolute record number	       (LOW)
 22114                                  ;	ES:BP = Base of drive parameters
 22115                                  ; Function:
 22116                                  ;	Call BIOS to perform disk read
 22117                                  ; Outputs:
 22118                                  ;	DI = CX on entry
 22119                                  ;	CX = Number of sectors unsuccessfully transfered
 22120                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 22121                                  ;	Zero set if OK (from BIOS) (carry clear)
 22122                                  ;	Zero clear if error (carry clear)
 22123                                  ; SI Destroyed, others preserved
 22124                                  ;---------------------------------------------------------------------------
 22125                                  
 22126                                  DSKREAD:
 22127 0000364A 51                      	PUSH	CX
 22128                                  	;mov	ah,[es:bp+17h] ; 04/05/2019
 22129 0000364B 268A6617                	MOV	AH,[ES:BP+DPB.MEDIA]
 22130                                  	;mov	al,[es:bp+1]
 22131 0000364F 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 22132 00003653 53                      	PUSH	BX
 22133 00003654 06                      	PUSH	ES
 22134 00003655 E8320F                  	call	SETREAD
 22135 00003658 EB22                    	JMP	short DODSKOP
 22136                                  
 22137                                  ;Break	<DWRITE -- SEE ABOUT WRITING>
 22138                                  ;--------------------------------------------------------------------------
 22139                                  ;
 22140                                  ; Procedure Name : DWRITE
 22141                                  ;
 22142                                  ; Inputs:
 22143                                  ;	DS:BX = Transfer address
 22144                                  ;	CX = Number of sectors
 22145                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 22146                                  ;	DX = Absolute record number	       (LOW)
 22147                                  ;	ES:BP = Base of drive parameters
 22148                                  ;	[ALLOWED] must be set in case HARDERR called
 22149                                  ; Function:
 22150                                  ;	Calls BIOS to perform disk write. If BIOS reports
 22151                                  ;	errors, will call HARDERRRW for further action.
 22152                                  ; Output:
 22153                                  ;	Carry set if error (currently, user FAILed to I 24)
 22154                                  ; BP preserved. All other registers destroyed.
 22155                                  ;----------------------------------------------------------------------------
 22156                                  
 22157                                  	;entry	DWRITE
 22158                                  DWRITE:
 22159 0000365A E81100                  	CALL	DSKWRITE
 22160 0000365D 74EA                    	jz	short dw_ret_label	; Carry clear (retz)
 22161                                  
 22162                                  ;hkn; SS override
 22163 0000365F 36C606[7505]01          	MOV	BYTE [SS:READOP],1	; Write
 22164 00003665 E83500                  	call	HARDERRRW
 22165 00003668 3C01                    	CMP	AL,1			; Check for retry
 22166 0000366A 74EE                    	JZ	short DWRITE
 22167                                  
 22168                                  ; 09/02/2024
 22169                                  %if 0
 22170                                  	CMP	AL,3			; Check for FAIL
 22171                                  	CLC
 22172                                  	JNZ	short NO_CAR2 		; Ignore
 22173                                  	STC
 22174                                  NO_CAR2:
 22175                                  dw_ret_label:
 22176                                  	retn
 22177                                  %else
 22178                                  	; 09/02/2024 - Retro DOS v4.1
 22179 0000366C EB9E                    	jmp	short fail_ignore
 22180                                  %endif
 22181                                  
 22182                                  ;Break	<DSKWRITE -- PHYSICAL DISK WRITE>
 22183                                  ;---------------------------------------------------------------------------
 22184                                  ;
 22185                                  ; Procedure Name : DSKWRITE
 22186                                  ;
 22187                                  ; Inputs:
 22188                                  ;	DS:BX = Transfer addr
 22189                                  ;	CX = Number of sectors
 22190                                  ;	DX = Absolute record number	       (LOW)
 22191                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 22192                                  ;	ES:BP = Base of drive parameters
 22193                                  ; Function:
 22194                                  ;	Call BIOS to perform disk read
 22195                                  ; Outputs:
 22196                                  ;	DI = CX on entry
 22197                                  ;	CX = Number of sectors unsuccessfully transfered
 22198                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 22199                                  ;	Zero set if OK (from BIOS) (carry clear)
 22200                                  ;	Zero clear if error (carry clear)
 22201                                  ; SI Destroyed, others preserved
 22202                                  ;
 22203                                  ;----------------------------------------------------------------------------
 22204                                  
 22205                                  	;entry	DSKWRITE
 22206                                  DSKWRITE:
 22207 0000366E 51                      	PUSH	CX
 22208                                  	;mov	ah,[es:bp+17h] ; 04/05/2019
 22209 0000366F 268A6617                	MOV	AH,[ES:BP+DPB.MEDIA]
 22210                                  	;mov	al,[es:bp+1]
 22211 00003673 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 22212 00003677 53                      	PUSH	BX
 22213 00003678 06                      	PUSH	ES
 22214 00003679 E8410F                  	call	SETWRITE
 22215                                  DODSKOP:
 22216 0000367C 8CD9                    	MOV	CX,DS		; Save DS
 22217 0000367E 1F                      	POP	DS		; DS:BP points to DPB
 22218 0000367F 1E                      	PUSH	DS
 22219                                  
 22220                                  	;lds	si,[ds:bp+13h] ; 04/05/2019
 22221 00003680 3EC57613                	LDS	SI,[ds:BP+DPB.DRIVER_ADDR] ; 07/09/2018
 22222 00003684 E8820E                  	call	DEVIOCALL2
 22223                                  
 22224 00003687 8ED9                    	MOV	DS,CX		; Restore DS
 22225 00003689 07                      	POP	ES		; Restore ES
 22226 0000368A 5B                      	POP	BX
 22227                                  
 22228                                  ;hkn; SS override
 22229 0000368B 368B0E[6C03]            	MOV	CX,[SS:CALLSCNT] ; Number of sectors transferred
 22230 00003690 5F                      	POP	DI
 22231 00003691 29F9                    	SUB	CX,DI
 22232 00003693 F7D9                    	NEG	CX		; Number of sectors not transferred
 22233                                  
 22234                                  ;hkn; SS override
 22235 00003695 36A1[5D03]              	MOV	AX,[SS:DEVCALL_REQSTAT]
 22236                                  	;test	ax,8000h
 22237                                  	; 17/12/2022
 22238                                  	;test	ah,80h
 22239 00003699 F6C480                  	test	ah,(STERR>>8)
 22240                                  	;test	AX,STERR
 22241 0000369C C3                      	retn
 22242                                  
 22243                                  ;Break	<HardErrRW - map extended errors and call harderr>
 22244                                  ;---------------------------------------------------------------------------
 22245                                  ;
 22246                                  ; Procedure Name : HardErrRW
 22247                                  ;
 22248                                  ; Inputs:
 22249                                  ;	AX is error code from read or write
 22250                                  ;	Other registers set as per HARDERR
 22251                                  ; Function:
 22252                                  ;	Checks the error code for special extended
 22253                                  ;	errors and maps them if needed. Then invokes
 22254                                  ;	Harderr
 22255                                  ; Outputs:
 22256                                  ;	Of HARDERR
 22257                                  ; AX may be modified prior to call to HARDERR.
 22258                                  ; No other registers altered.
 22259                                  ;
 22260                                  ;---------------------------------------------------------------------------
 22261                                  
 22262                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22263                                  HARDERRRW:
 22264                                  	;cmp	al,0Fh
 22265 0000369D 3C0F                    	CMP	AL,error_I24_wrong_disk
 22266 0000369F 7512                    	JNZ	short DO_ERR				; Nothing to do
 22267                                  
 22268                                  	; MSDOS 3.3
 22269                                  	;push	ds
 22270                                  	;push	si
 22271                                  	;lds	si,[ss:CALLVIDRW]
 22272                                  	;mov	[ss:EXTERRPT+2], ds
 22273                                  	;mov	[ss:EXTERRPT], si
 22274                                  	;pop	si
 22275                                  	;pop	ds
 22276                                  
 22277                                  	; MSDOS 6.0
 22278 000036A1 50                      	push	ax
 22279 000036A2 36A1[7003]              	mov	ax,[SS:CALLVIDRW]		; get ptr lo  ;smr;SS Override
 22280 000036A6 36A3[2803]              	mov	[ss:EXTERRPT],ax		; set ext err ptr lo
 22281 000036AA 36A1[7203]              	mov	ax,[SS:CALLVIDRW+2]		; get ptr hi from dev
 22282 000036AE 36A3[2A03]              	mov	[ss:EXTERRPT+2],ax		; set ext err ptr hi
 22283 000036B2 58                      	pop	ax
 22284                                  DO_ERR:
 22285                                  	;;call	HARDERR
 22286                                  	;;retn
 22287                                  	; 16/12/2022
 22288                                  	; 10/06/2019
 22289 000036B3 E9C11A                  	jmp	HARDERR	
 22290                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22291                                  	;call	HARDERR
 22292                                  	;retn
 22293                                  
 22294                                  ; 24/07/2018 - Retro DOS v3.0
 22295                                  
 22296                                  ;Break	<SETUP -- SETUP A DISK READ OR WRITE FROM USER>
 22297                                  ;----------------------------------------------------------------------------
 22298                                  ;
 22299                                  ; Procedure Name : SETUP
 22300                                  ;
 22301                                  ; Inputs:
 22302                                  ;	ES:DI point to SFT (value also in THISSFT)
 22303                                  ;	DMAAdd contains transfer address
 22304                                  ;	CX = Byte count
 22305                                  ;	DS = DOSDATA
 22306                                  ;   WARNING Stack must be clean, two ret addrs on stack, 1st of caller,
 22307                                  ;		2nd of caller of caller.
 22308                                  ; Outputs:
 22309                                  ;	    CX = byte count
 22310                                  ;	    [THISDPB] = Base of drive parameters if file
 22311                                  ;		      = Pointer to device header if device or NET
 22312                                  ;	    ES:DI Points to SFT
 22313                                  ;	    [NEXTADD] = Displacement of disk transfer within segment
 22314                                  ;	    [TRANS] = 0 (No transfers yet)
 22315                                  ;	    BytPos = Byte position in file
 22316                                  ;
 22317                                  ;	The following fields are relevant to local files (not devices) only:
 22318                                  ;
 22319                                  ;	    SecPos = Position of first sector (local files only)
 22320                                  ;	    [BYTSECPOS] = Byte position in first sector (local files only)
 22321                                  ;	    [CLUSNUM] = First cluster (local files only)
 22322                                  ;	    [SECCLUSPOS] = Sector within first cluster (local files only)
 22323                                  ;	    [THISDRV] = Physical unit number (local files only)
 22324                                  ;
 22325                                  ;      RETURNS ONE LEVEL UP WITH:
 22326                                  ;	   CX = 0
 22327                                  ;	   CARRY = Clear
 22328                                  ;	IF AN ERROR IS DETECTED
 22329                                  ; All other registers destroyed
 22330                                  ;----------------------------------------------------------------------------
 22331                                  
 22332                                  ;hkn; called from disk.asm. DS has been set up to DOSDATA.
 22333                                  
 22334                                  ; DOSCODE:770Bh (MSDOS 6.21, MSDOS.SYS)
 22335                                  
 22336                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22337                                  ; DOSCODE:76F7h (MSDOS 5.0, MSDOS.SYS)
 22338                                  
 22339                                  SETUP:
 22340                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 411Bh
 22341                                  
 22342                                  	;lds 	si,[es:di+7]
 22343 000036B6 26C57507                	LDS	SI,[ES:DI+SF_ENTRY.sf_devptr]
 22344                                  
 22345                                  ;hkn; SS override
 22346 000036BA 368C1E[8C05]            	MOV	[SS:THISDPB+2],DS
 22347                                  
 22348                                  ;hkn; SS is DOSDATA
 22349 000036BF 16                      	push	ss
 22350 000036C0 1F                      	pop	ds
 22351                                  
 22352 000036C1 8936[8A05]              	MOV	[THISDPB],SI
 22353                                  
 22354 000036C5 8B1E[2C03]              	MOV	BX,[DMAADD]
 22355 000036C9 891E[B805]              	MOV	[NEXTADD],BX		;Set NEXTADD to start of Xaddr
 22356 000036CD C606[7405]00            	MOV	BYTE [TRANS],0		;No transferes
 22357                                  	;mov	ax,[es:di+15h]
 22358 000036D2 268B4515                	MOV	AX,[ES:DI+SF_ENTRY.sf_position]
 22359                                  	;mov	dx,[es:di+17h]
 22360 000036D6 268B5517                	MOV	DX,[ES:DI+SF_ENTRY.sf_position+2]
 22361 000036DA 8916[D005]              	MOV	[BYTPOS+2],DX		;Set it
 22362 000036DE A3[CE05]                	MOV	[BYTPOS],AX
 22363                                  	;test	word [es:di+5],8080h
 22364 000036E1 26F745058080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet+devid_device
 22365 000036E7 753C                    	JNZ	short NOSETSTUFF	;Following not done on devs or NET
 22366 000036E9 06                      	PUSH	ES
 22367 000036EA C42E[8A05]              	LES	BP,[THISDPB]		;Point at the DPB
 22368                                  
 22369                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22370                                  	;;mov	bl,[es:bp+0]
 22371                                  	;MOV	BL,[ES:BP+DPB.DRIVE]
 22372                                  	; 05/12/2022
 22373 000036EE 268A5E00                	mov	bl,[es:bp]
 22374                                  	
 22375 000036F2 881E[7605]              	MOV	[THISDRV],BL		;Set THISDRV
 22376                                  	;mov	bx,[es:bp+2]
 22377 000036F6 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 22378                                  
 22379                                  	;; MSDOS 3.3
 22380                                  	;cmp	dx,bx
 22381                                  	;jnb	short EOFERR
 22382                                  	;div	bx
 22383                                  	;mov	[SECPOS],ax
 22384                                  	;mov	[BYTSECPOS],dx
 22385                                  	;mov	dx,ax
 22386                                  	;;and	al,[es:bp+4]
 22387                                  	;AND	AL,[ES:BP+DPB.CLUSTER_MASK]
 22388                                  	;mov	[SECCLUSPOS],al
 22389                                  	;mov	ax,cx
 22390                                  	;;mov	cl,[es:bp+5]
 22391                                  	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 22392                                  	;shr	dx,cl
 22393                                  	;mov	[CLUSNUM],dx
 22394                                  	;pop	es
 22395                                  	;mov	cx,ax
 22396                                  
 22397                                  	; 04/05/2019 - Retro DOS v4.0
 22398                                  
 22399                                  	; MSDOS 6.0
 22400                                  ;M039: Optimized this section.
 22401 000036FA 51                              PUSH    CX			;SHR32 and DIV32 use CX.
 22402 000036FB E81A05                  	call	DIV32			;DX:AX/BX = CX:AX + DX (rem)
 22403 000036FE 8916[CC05]              	MOV	[BYTSECPOS],DX
 22404 00003702 A3[C405]                	MOV	[SECPOS],AX
 22405 00003705 890E[C605]              	MOV	[SECPOS+2],CX
 22406 00003709 89CA                    	MOV	DX,CX
 22407                                  
 22408 0000370B 89C3                    	MOV	BX,AX
 22409                                  	;and	bl,[es:bp+4]
 22410 0000370D 26225E04                	AND	BL,[ES:BP+DPB.CLUSTER_MASK]
 22411 00003711 881E[7305]              	MOV	[SECCLUSPOS],BL
 22412                                  
 22413 00003715 E82705                  	call	SHR32			;(DX:AX SHR dpb_cluster_shift)
 22414 00003718 59                      	POP	CX			;CX = byte count.
 22415 00003719 751F                    	JNZ	short EOFERR		;cluster number above 64k
 22416                                  	;cmp	ax,[es:bp+0Dh]
 22417 0000371B 263B460D                	CMP	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  if > disk size ;AN000;
 22418 0000371F 7719                    	JA	short EOFERR		   ;>32mb  then EOF       ;AN000;
 22419                                  
 22420 00003721 A3[BC05]                	MOV	[CLUSNUM],AX
 22421 00003724 07                      	POP	ES			; ES:DI point to SFT
 22422                                  ;M039
 22423                                  
 22424                                  NOSETSTUFF:
 22425 00003725 89C8                    	MOV	AX,CX		; AX = Byte count.
 22426 00003727 0306[2C03]              	ADD	AX,[DMAADD]	; See if it will fit in one segment
 22427 0000372B 730C                    	JNC	short setup_OK	; Must be less than 64
 22428 0000372D A1[2C03]                	MOV	AX,[DMAADD]
 22429 00003730 F7D8                    	NEG	AX		; Amount of room left in segment (know
 22430                                  				;    less than 64K since max value of CX
 22431                                  				;    is FFFF).
 22432 00003732 7501                    	JNZ	short NoDec
 22433 00003734 48                      	DEC	AX
 22434                                  NoDec:
 22435 00003735 89C1                    	MOV	CX,AX		; Can do this much
 22436 00003737 E304                    	JCXZ	NOROOM		; Silly user gave Xaddr of FFFF in segment
 22437                                  setup_OK:
 22438 00003739 C3                      	retn
 22439                                  
 22440                                  EOFERR:
 22441 0000373A 07                      	POP	ES		; ES:DI point to SFT
 22442 0000373B 31C9                    	XOR	CX,CX		; No bytes read
 22443                                  ;;;;;;;;;;; 7/18/86
 22444                                  	; MSDOS 3.3
 22445                                  	;MOV	BYTE [DISK_FULL],1 ; set disk full flag
 22446                                  ;;;;;;;;;;;
 22447                                  NOROOM:
 22448 0000373D 5B                      	POP	BX		; Kill return address
 22449 0000373E F8                      	CLC
 22450 0000373F C3                      	retn			; RETURN TO CALLER OF CALLER
 22451                                  
 22452                                  ;Break	<BREAKDOWN -- CUT A USER READ OR WRITE INTO PIECES>
 22453                                  ;---------------------------------------------------------------------------
 22454                                  ;
 22455                                  ; Procedure Name : BREAKDOWN
 22456                                  ;
 22457                                  ; Inputs:
 22458                                  ;	CX = Length of disk transfer in bytes
 22459                                  ;	ES:BP = Base of drive parameters
 22460                                  ;	[BYTSECPOS] = Byte position within first sector
 22461                                  ;	DS = DOSDATA
 22462                                  ; Outputs:
 22463                                  ;	[BYTCNT1] = Bytes to transfer in first sector
 22464                                  ;	[SECCNT] = No. of whole sectors to transfer
 22465                                  ;	[BYTCNT2] = Bytes to transfer in last sector
 22466                                  ; AX, BX, DX destroyed. No other registers affected.
 22467                                  ;---------------------------------------------------------------------------
 22468                                  
 22469                                  BREAKDOWN:
 22470 00003740 A1[CC05]                	MOV	AX,[BYTSECPOS]
 22471 00003743 89CB                    	MOV	BX,CX
 22472 00003745 09C0                    	OR	AX,AX
 22473 00003747 740E                    	JZ	short SAVFIR	; Partial first sector?
 22474                                  	;sub	ax,[es:bp+2]
 22475 00003749 262B4602                	SUB	AX,[ES:BP+DPB.SECTOR_SIZE]
 22476 0000374D F7D8                    	NEG	AX		; Max number of bytes left in first sector
 22477 0000374F 29C3                    	SUB	BX,AX		; Subtract from total length
 22478 00003751 7304                    	JAE	short SAVFIR
 22479 00003753 01D8                    	ADD	AX,BX		; Don't use all of the rest of the sector
 22480 00003755 31DB                    	XOR	BX,BX		; And no bytes are left
 22481                                  SAVFIR:
 22482 00003757 A3[D205]                	MOV	[BYTCNT1],AX
 22483 0000375A 89D8                    	MOV	AX,BX
 22484 0000375C 31D2                    	XOR	DX,DX
 22485                                  	;div	word [ES:BP+2]
 22486 0000375E 26F77602                	DIV	word [ES:BP+DPB.SECTOR_SIZE]  ; How many whole sectors?
 22487 00003762 A3[D605]                	MOV	[SECCNT],AX
 22488 00003765 8916[D405]              	MOV	[BYTCNT2],DX	; Bytes remaining for last sector
 22489                                  	; MSDOS 3.3
 22490                                  	;OR	DX,[BYTCNT1]	; SMR ONESECTORFIX BUGBUG
 22491                                  	;retnz			; NOT (BYTCNT1 = BYTCNT2 = 0)
 22492                                  	;CMP	AX,1
 22493                                  	;retnz
 22494                                  	;MOV	AX,[ES:BP+DPB.SECTOR_SIZE] ; Buffer EXACT one sector I/O
 22495                                  	;MOV	[BYTCNT2],AX
 22496                                  	;MOV	[SECCNT],DX	; DX = 0
 22497                                  _RET45:
 22498 00003769 C3                      	retn
 22499                                  
 22500                                  ; DOSCODE:77BFh (MSDOS 6.21, MSDOS.SYS)
 22501                                  
 22502                                  ;----------------------------------------------------------------------------
 22503                                  ;
 22504                                  ; Procedure Name : READ_LOCK_VIOLATION
 22505                                  ;
 22506                                  ; ES:DI points to SFT. This entry used by NET_READ
 22507                                  ; Carry set if to return error (CX=0,AX=error_sharing_violation).
 22508                                  ; Else do retrys.
 22509                                  ; ES:DI,DS,CX preserved
 22510                                  ;
 22511                                  ;----------------------------------------------------------------------------
 22512                                  
 22513                                  READ_LOCK_VIOLATION:
 22514 0000376A C606[7505]00            	MOV	byte [READOP],0
 22515                                  ERR_ON_CHECK:
 22516                                  	;;test	word [es:di+2],8000h
 22517                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 22518                                  	;JNZ	short HARD_ERR
 22519                                  
 22520                                  	; 04/05/2019
 22521                                  	;test	byte [es:di+3],80h
 22522 0000376F 26F6450380              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 22523 00003774 7508                    	JNZ	short HARD_ERR
 22524                                  
 22525                                  	;PUSH	CX
 22526                                  	;;mov	cl,[es:di+2]
 22527                                  	;MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 22528                                  	;;and	cl,0F0h
 22529                                  	;AND	CL,SHARING_MASK
 22530                                  	;;cmp	cl,0
 22531                                  	;CMP	CL,SHARING_COMPAT
 22532                                  	;POP	CX
 22533                                  	;JNE	short NO_HARD_ERR
 22534                                  	; 21/09/2023
 22535 00003776 268A4502                	mov	al,[ES:DI+SF_ENTRY.sf_mode]
 22536 0000377A 24F0                    	and	al,SHARING_MASK
 22537                                  	;cmp	al,SHARING_COMPAT
 22538                                  	;jne	short NO_HARD_ERR
 22539 0000377C 7505                    	jnz	short NO_HARD_ERR
 22540                                  HARD_ERR:
 22541 0000377E E89639                  	call	LOCK_VIOLATION
 22542 00003781 73E6                    	jnc	short _RET45		; User wants Retrys
 22543                                  NO_HARD_ERR:
 22544 00003783 31C9                    	XOR	CX,CX			;No bytes transferred
 22545                                  	;mov	ax,21h
 22546 00003785 B82100                  	MOV	AX,error_lock_violation
 22547 00003788 F9                      	STC
 22548                                  RET3:		; 06/02/2024
 22549 00003789 C3                      	retn
 22550                                  
 22551                                  ;----------------------------------------------------------------------------
 22552                                  ;
 22553                                  ; Procedure Name : WRITE_LOCK_VIOLATION
 22554                                  ;
 22555                                  ; Same as READ_LOCK_VIOLATION except for READOP.
 22556                                  ; This entry used by NET_WRITE
 22557                                  ;
 22558                                  ;----------------------------------------------------------------------------
 22559                                  
 22560                                  WRITE_LOCK_VIOLATION:
 22561 0000378A C606[7505]01            	MOV	byte [READOP],1
 22562 0000378F EBDE                    	JMP	short ERR_ON_CHECK
 22563                                  
 22564                                  ; 04/05/2019 - Retro DOS v4.0
 22565                                  
 22566                                  ; DOSCODE:77ECh (MSDOS 6.21, MSDOS.SYS)
 22567                                  
 22568                                  ;Break	<DISKREAD -- PERFORM USER DISK READ>
 22569                                  ;----------------------------------------------------------------------------
 22570                                  ;
 22571                                  ; Procedure Name : DISKREAD
 22572                                  ;
 22573                                  ; Inputs:
 22574                                  ;	Outputs of SETUP
 22575                                  ; Function:
 22576                                  ;	Perform disk read
 22577                                  ; Outputs:
 22578                                  ;    Carry clear
 22579                                  ;	CX = No. of bytes read
 22580                                  ;	ES:DI point to SFT
 22581                                  ;	SFT offset and cluster pointers updated
 22582                                  ;    Carry set
 22583                                  ;	CX = 0
 22584                                  ;	ES:DI point to SFT
 22585                                  ;	AX has error code
 22586                                  ;----------------------------------------------------------------------------
 22587                                  
 22588                                  ;hkn; called from disk.asm. DS already set up.
 22589                                  
 22590                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22591                                  ; DOSCODE:77D8h (MSDOS 5.0, MSDOS.SYS)
 22592                                  
 22593                                  DISKREAD:
 22594                                  	;mov	ax,[es:di+11h]
 22595 00003791 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 22596                                  	;mov	bx,[es:di+13h]
 22597 00003795 268B5D13                	MOV	BX,[ES:DI+SF_ENTRY.sf_size+2]
 22598 00003799 2B06[CE05]              	SUB	AX,[BYTPOS]
 22599 0000379D 1B1E[D005]              	SBB	BX,[BYTPOS+2]
 22600 000037A1 721F                    	JB	short RDERR		;Read starts past EOF
 22601 000037A3 750A                    	JNZ	short ENUF		;More than 64k to EOF
 22602 000037A5 09C0                    	OR	AX,AX
 22603 000037A7 7419                    	JZ	short RDERR		;Read starts at EOF
 22604 000037A9 39C8                    	CMP	AX,CX
 22605 000037AB 7302                    	JAE	short ENUF		;I/O fits
 22606 000037AD 89C1                    	MOV	CX,AX			;Limit read to up til EOF
 22607                                  ENUF:
 22608                                  	; MSDOS 3.3
 22609                                  	;test	byte [es:di+4],8
 22610                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 22611                                  	;jnz	short SET_ACC_ERR
 22612                                  	;call	LOCK_CHECK
 22613                                  	;jnb	short _READ_OK
 22614                                  	;call	READ_LOCK_VIOLATION
 22615                                  	;jnb	short ENUF
 22616                                  	;retn
 22617                                  
 22618                                  	; MSDOS 6.0
 22619 000037AF E881FE                  	call	CHECK_READ_LOCK		;IFS. check read lock	;AN000;
 22620                                  	;JNC	short _READ_OK 		; There are no locks
 22621                                  	;retn
 22622                                  	; 06/02/2024
 22623 000037B2 72D5                    	jc	short RET3
 22624                                  
 22625                                  _READ_OK:
 22626 000037B4 C42E[8A05]              	LES	BP,[THISDPB]
 22627 000037B8 E885FF                  	CALL	BREAKDOWN
 22628                                  
 22629                                  ; 10/02/2024
 22630                                  %if 0
 22631                                  	MOV	CX,[CLUSNUM] ; *
 22632                                  	call	FNDCLUS
 22633                                       	; MSDOS 6.0			;M022 conditional removed here
 22634                                  	JC	short SET_ACC_ERR_DS	; fix to take care of I24 fail
 22635                                  					; migrated from 330a - HKN
 22636                                  %else
 22637                                  	; 10/02/2024 - Retro DOS v4.2
 22638 000037BB E81213                  	call	FNDCLUS_X ; *
 22639 000037BE 720E                    	jc	short SET_ACC_ERR ; ds=ss
 22640                                  %endif
 22641                                  	;OR	CX,CX
 22642                                  	;JZ	short SKIPERR
 22643                                  	; 06/02/2024
 22644 000037C0 E313                    	jcxz	SKIPERR
 22645                                  
 22646                                  RDERR:
 22647 000037C2 B40E                    	MOV	AH,0EH			;MS. read/data/fail ;AN000;
 22648 000037C4 E91802                  	jmp	WRTERR22
 22649                                  
 22650                                  ;RDLASTJ: 
 22651                                  	;JMP	RDLAST                  ;M039
 22652                                  
 22653                                  SETSFTJ2: 
 22654 000037C7 E99600                  	JMP	SETSFT
 22655                                  
 22656                                  CANOT_READ:
 22657                                  	; MSDOS 3.3
 22658                                  	;POP	CX		;M039.
 22659                                  	; MSDOS 3.3 & MSDOS 6.0
 22660 000037CA 59                      	POP	CX              ;Clean stack.
 22661 000037CB 5B                      	POP	BX
 22662                                  
 22663                                  	;entry	SET_ACC_ERR_DS
 22664                                  SET_ACC_ERR_DS:
 22665                                  
 22666                                  ;hkn; SS is DOSDATA
 22667                                  	;Context DS
 22668 000037CC 16                      	push	ss
 22669 000037CD 1F                      	pop	ds
 22670                                  
 22671                                  	;entry	SET_ACC_ERR
 22672                                  SET_ACC_ERR:
 22673 000037CE 31C9                    	XOR	CX,CX
 22674                                  	;mov	ax,5
 22675 000037D0 B80500                  	MOV	AX,error_access_denied
 22676 000037D3 F9                      	STC
 22677 000037D4 C3                      	retn
 22678                                  
 22679                                  SKIPERR:
 22680 000037D5 8916[BA05]              	MOV	[LASTPOS],DX
 22681 000037D9 891E[BC05]              	MOV	[CLUSNUM],BX
 22682 000037DD 833E[D205]00            	CMP	word [BYTCNT1],0
 22683 000037E2 7405                    	JZ	short RDMID
 22684                                  
 22685 000037E4 E86313                  	call	BUFRD
 22686                                  	;JC	short SET_ACC_ERR_DS ; ds<>ss ; 10/02/2024
 22687                                  	; 10/02/2024
 22688                                  	; ds=ss
 22689 000037E7 72E5                    	jc	short SET_ACC_ERR
 22690                                  
 22691                                  RDMID:
 22692 000037E9 833E[D605]00            	CMP	word [SECCNT],0
 22693                                  	;JZ	RDLAST ; 10/08/2018
 22694 000037EE 7453                    	jz	short RDLAST
 22695                                  
 22696 000037F0 E8EB13                  	call	NEXTSEC
 22697 000037F3 72D2                    	JC	short SETSFTJ2
 22698                                  
 22699 000037F5 C606[7405]01            	MOV	BYTE [TRANS],1		; A transfer is taking place
 22700                                  ONSEC:
 22701 000037FA 8A16[7305]              	MOV	DL,[SECCLUSPOS]	; (dx/DL = Extent start) ((dh = ?))
 22702 000037FE 8B0E[D605]              	MOV	CX,[SECCNT]
 22703 00003802 8B1E[BC05]              	MOV	BX,[CLUSNUM]
 22704                                  RDLP:
 22705 00003806 E80614                  	call	OPTIMIZE
 22706                                  	;JC	short SET_ACC_ERR_DS ; ds<>ss ; 10/02/2024
 22707                                  	; 10/02/2024
 22708                                  	; ds=ss
 22709 00003809 72C3                    	jc	short SET_ACC_ERR
 22710                                  
 22711 0000380B 57                      	PUSH	DI                      ;DI = Next physical cluster.
 22712 0000380C 50                      	PUSH	AX                      ;AX = # of sectors remaining.
 22713 0000380D 53                      	PUSH	BX			;[DMAADD+2]:BX = Transfer address.
 22714                                  	;mov	byte [ALLOWED],38h
 22715 0000380E C606[4B03]38            	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 22716 00003813 8E1E[2E03]              	MOV	DS,[DMAADD+2]
 22717                                  
 22718 00003817 52                      	PUSH	DX                      ;[HIGH_SECTOR]:DX = phys. sector #.
 22719 00003818 51                      	PUSH	CX                      ;CX = # of contiguous sectors to read.
 22720                                  
 22721                                  	; 04/05/2019 - Retro DOS v4.0
 22722                                  
 22723                                  	; MSDOS 6.0
 22724 00003819 E88821                  	call	SET_RQ_SC_PARMS		;LB. do this for SC ;AN000;
 22725                                  
 22726                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22727 0000381C E8DBFD                  	call	DREAD
 22728                                  
 22729                                  	; 10/02/2024
 22730                                  	; ds<>ss
 22731                                  
 22732                                  	; MSDOS 3.3 
 22733                                  	;pop	bx
 22734                                  	;pop	dx
 22735                                  	;jc	short CANOT_READ
 22736                                  	;add	bx,dx	; (bx = Extent end)
 22737                                  	;mov	al,[es:bp] ; mov al,[es:bp+0]
 22738                                  	;;mov	al,[ES:BP+DPB.DRIVE] 
 22739                                  	;call	SETVISIT
 22740                                  	; ->***
 22741                                  ;M039
 22742                                  	; MSDOS 6.0 
 22743 0000381F 59                      	pop	cx
 22744 00003820 5A                      	pop	dx
 22745 00003821 368F06[0C06]            	pop	WORD [ss:TEMP_VAR]
 22746 00003826 72A2                    	jc	short CANOT_READ
 22747                                  
 22748 00003828 368C1E[0E06]            	mov	[ss:TEMP_VAR2],ds
 22749                                  
 22750                                  ;       CX = # of contiguous sectors read. (These constitute a block of
 22751                                  ;            sectors, also termed an "Extent".)
 22752                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 22753                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 22754                                  ;       ES:BP -> Drive Parameter Block (DPB).
 22755                                  ;
 22756                                  ;	The Buffer Queue must now be scanned: the contents of any dirty
 22757                                  ;	buffers must be "read" into the transfer memory block, so that the
 22758                                  ;       transfer memory reflects the most recent data.
 22759                                  
 22760 0000382D E85E00                  	call	DskRdBufScan
 22761                                  
 22762                                  	;Context DS
 22763 00003830 16                      	push	ss
 22764 00003831 1F                      	pop	ds
 22765                                          
 22766 00003832 59                      	pop	cx
 22767 00003833 5B                              pop	bx
 22768                                  
 22769                                  ;       CX = # of sector remaining.
 22770                                  ;       BX = Next physical cluster.
 22771                                  
 22772                                  ;M039
 22773                                  
 22774                                  ;;;;;;;;
 22775                                  ;	; 25/07/2018 - Retro DOS v3.0
 22776                                  ;	; ***->
 22777                                  ;	; MSDOS 3.3
 22778                                  ;	; IBMDOS.COM (1987) - Offset 42BDh
 22779                                  ;bufq:
 22780                                  ;;	DX = Extent start.
 22781                                  ;;	BX = Extent end.
 22782                                  ;;	 AL = Drive #.
 22783                                  ;;     DS:DI-> 1st buffer in queue.
 22784                                  ;
 22785                                  ;	;or	byte [di+5],20h
 22786                                  ;	or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 22787                                  ;	;cmp	al,[di+4]	
 22788                                  ;	cmp	al,[DI+BUFFINFO.buf_ID]
 22789                                  ;	jnz	short bufq3
 22790                                  ;	;cmp	[di+6],dx
 22791                                  ;	cmp	[DI+BUFFINFO.buf_sector],dx
 22792                                  ;	jb	short bufq3	; Jump if Extent start > buffer sector.
 22793                                  ;	;cmp	[di+6],bx
 22794                                  ;	cmp	[DI+BUFFINFO.buf_sector],bx
 22795                                  ;	jnb	short bufq3	; Jump if Extent end >= buffer sector.
 22796                                  ;	
 22797                                  ;	; Buffer sector is in the Extent (contiguous sectors to read)
 22798                                  ;
 22799                                  ;;      Buffer's sector is in Extent: if it is dirty, copy its contents to
 22800                                  ;;      transfer memory; otherwise, just re-position it in the buffer queue
 22801                                  ;;      as MRU (Most Recently Used).
 22802                                  ;
 22803                                  ;	;test	byte [di+5],40h
 22804                                  ;	test	byte [DI+BUFFINFO.buf_flags],buf_dirty ; Bit 6 = dirty flag
 22805                                  ;	jz	short bufq2	; clear buffer, check the next buff sec
 22806                                  ;	pop	ax ; transfer address
 22807                                  ;	push	ax
 22808                                  ;	push	di
 22809                                  ;	push	dx
 22810                                  ;	;sub	dx,[di+6]
 22811                                  ;	sub	dx,[DI+BUFFINFO.buf_sector]
 22812                                  ;	neg	dx
 22813                                  ;
 22814                                  ;;      DX = offset (in sectors) of buffer sector within Transfer memory
 22815                                  ;;           block.
 22816                                  ;
 22817                                  ;	mov	si,di
 22818                                  ;	mov	di,ax
 22819                                  ;	mov	ax,dx
 22820                                  ;	;mov	cx,[es:bp+6]	
 22821                                  ;	mov     cx,[ES:BP+DPB.SECTOR_SIZE] ; CX = sector size (in bytes).
 22822                                  ;	mul	cx
 22823                                  ;	add	di,ax
 22824                                  ;
 22825                                  ;	lea	si,[si+16]
 22826                                  ;	lea	si,[SI+BUFINSIZ] ;DS:SI -> buffer data.
 22827                                  ;	shr	cx,1
 22828                                  ;	push	es
 22829                                  ;	mov	es,[SS:DMAADD+2]
 22830                                  ;
 22831                                  ;;      CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
 22832                                  ;;      DS:SI-> Buffer sector data.
 22833                                  ;;      ES:DI-> Destination within Transfer memory block.
 22834                                  ;
 22835                                  ;	rep	movsw			;Copy buffer sector to Transfer memory
 22836                                  ;	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 22837                                  ;	;rep	movsb                   ;Copy last byte.
 22838                                  ;	jnc	short bufq1
 22839                                  ;	movsb
 22840                                  ;bufq1:
 22841                                  ;	pop	es
 22842                                  ;	pop	dx
 22843                                  ;	pop	di
 22844                                  ;	mov	al,[es:bp]  ; mov al,[es:bp+0]
 22845                                  ;	;mov	al,[ES:BP+DPB.DRIVE]
 22846                                  ;bufq2:
 22847                                  ;	call	SCANPLACE
 22848                                  ;bufq3:
 22849                                  ;	call	SKIPVISIT
 22850                                  ;	jnz	short bufq
 22851                                  ;	
 22852                                  ;	push	ss
 22853                                  ;	pop	ds
 22854                                  ;	pop	cx
 22855                                  ;	pop	cx
 22856                                  ;	pop	bx	
 22857                                  ;bufq4:
 22858                                  ;;;;;;;
 22859 00003834 E30D                    	JCXZ	RDLAST
 22860                                  
 22861 00003836 E85D1B                  	call	IsEOF			; test for eof on fat size
 22862 00003839 7325                    	JAE	short SETSFT
 22863                                  
 22864 0000383B B200                    	MOV	DL,0
 22865 0000383D FF06[BA05]              	INC	word [LASTPOS]		; We'll be using next cluster
 22866 00003841 EBC3                    	JMP	short RDLP ; 19/05/2019
 22867                                  
 22868                                  RDLAST:
 22869 00003843 A1[D405]                	MOV	AX,[BYTCNT2]
 22870 00003846 09C0                    	OR	AX,AX
 22871 00003848 7416                    	JZ	short SETSFT
 22872 0000384A A3[D205]                	MOV	[BYTCNT1],AX
 22873                                  
 22874 0000384D E88E13                  	call	NEXTSEC
 22875 00003850 720E                    	JC	short SETSFT
 22876                                  
 22877 00003852 C706[CC05]0000          	MOV	word [BYTSECPOS],0
 22878 00003858 E8EF12                  	call	BUFRD
 22879                                  	; 10/08/2018
 22880 0000385B 7303                    	JNC	short SETSFT
 22881                                  	;JMP	SET_ACC_ERR_DS
 22882                                  	; 10/02/2024
 22883                                  	; ds=ss
 22884 0000385D E96EFF                  	jmp	SET_ACC_ERR
 22885                                  
 22886                                  ;------------------------------------------------------------------------------
 22887                                  ;
 22888                                  ; Procedure Name : SETSFT
 22889                                  ; Inputs:
 22890                                  ;	[NEXTADD],[CLUSNUM],[LASTPOS] set to determine transfer size
 22891                                  ;		and set cluster fields
 22892                                  ; Function:
 22893                                  ;	Update [THISSFT] based on the transfer
 22894                                  ; Outputs:
 22895                                  ;	sf_position, sf_lstclus, and sf_cluspos updated
 22896                                  ;	ES:DI points to [THISSFT]
 22897                                  ;	CX No. of bytes transferred
 22898                                  ;	Carry clear
 22899                                  ;
 22900                                  ;----------------------------------------------------------------------------
 22901                                  
 22902                                  	;entry	SETSFT
 22903                                  
 22904                                  ; 26/07/2018 - Retro DOS v3.0
 22905                                  SETSFT:
 22906 00003860 C43E[9E05]              	LES	DI,[THISSFT]
 22907                                  
 22908                                  ; Same as SETSFT except ES:DI already points to SFT
 22909                                  	;entry	SETCLUS
 22910                                  SETCLUS:	
 22911 00003864 8B0E[B805]              	MOV	CX,[NEXTADD]
 22912 00003868 2B0E[2C03]              	SUB	CX,[DMAADD]		; Number of bytes transfered
 22913                                  	;;test	word [es:di+5],80h
 22914                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 22915                                  	;JNZ	short ADDREC		; don't set clusters if device
 22916                                  
 22917                                  	; 04/05/2019 - Retro DOS v4.0
 22918                                  	;test	byte [es:di+5],80h
 22919 0000386C 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 22920 00003871 750E                    	JNZ	short ADDREC		; don't set clusters if device
 22921                                  
 22922 00003873 A1[BC05]                	MOV	AX,[CLUSNUM]
 22923                                  	;;mov	[es:di+1Bh],ax ; MSDOS 3.3
 22924                                  	;mov	[es:di+35h],ax ; MSDOS 6.0 (& MSDOS 6.21)
 22925 00003876 26894535                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 22926 0000387A A1[BA05]                	MOV	AX,[LASTPOS]
 22927                                  	;mov	[es:di+19h],ax
 22928 0000387D 26894519                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],AX
 22929                                  
 22930                                  ;----------------------------------------------------------------------------
 22931                                  ;
 22932                                  ; Procedure : AddRec
 22933                                  ; Inputs:
 22934                                  ;	ES:DI points to SFT
 22935                                  ;	CX is No. Bytes transferred
 22936                                  ; Function:
 22937                                  ;	Update the SFT offset based on the transfer
 22938                                  ; Outputs:
 22939                                  ;	sf_position updated to point to first byte after transfer
 22940                                  ;	ES:DI points to SFT
 22941                                  ;	CX No. of bytes transferred
 22942                                  ;	Carry clear
 22943                                  ;----------------------------------------------------------------------------
 22944                                  
 22945                                  	;entry	AddRec
 22946                                  ADDREC:
 22947 00003881 E309                    	JCXZ	RET28		; If no records read,  don't change position
 22948                                  	;add	[es:di+15h],cx
 22949 00003883 26014D15                	ADD	[ES:DI+SF_ENTRY.sf_position],CX  ; Update current position
 22950                                  	;adc	word [es:di+17h], 0
 22951 00003887 2683551700              	ADC	WORD [ES:DI+SF_ENTRY.sf_position+2],0
 22952                                  RET28:	
 22953 0000388C F8                      	CLC
 22954 0000388D C3                      	retn
 22955                                  
 22956                                  ; 25/07/2018
 22957                                  ; MSDOS 6.0
 22958                                  ;Break   <DskRdBufScan -- Disk Read Buffer Scan>
 22959                                  ;----------------------------------------------------------------------------
 22960                                  ;
 22961                                  ; Procedure Name : DskRdBufScan
 22962                                  ;
 22963                                  ; Inputs:
 22964                                  ;       CX = # of contiguous sectors read. (These constitute a block of
 22965                                  ;            sectors, also termed an "Extent".)
 22966                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 22967                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 22968                                  ;       ES:BP -> Drive Parameter Block (DPB).
 22969                                  ;
 22970                                  ; Function:
 22971                                  ;	The Buffer Queue is scanned: the contents of any dirty buffers are
 22972                                  ;	"read" into the transfer memory block, so that the transfer memory
 22973                                  ;	reflects the most recent data.
 22974                                  ;
 22975                                  ; Outputs:
 22976                                  ;       Transfer memory updated as required.
 22977                                  ;
 22978                                  ; Uses:
 22979                                  ;       DS,AX,BX,CX,SI,DI destroyed.
 22980                                  ;       SS override for all global variables.
 22981                                  ;
 22982                                  ; Notes:
 22983                                  ;       FIRST_BUFF_ADDR is set-up to contain the LAST buffer to check, rather
 22984                                  ;	than the FIRST.
 22985                                  ;----------------------------------------------------------------------------
 22986                                  ;M039: Created
 22987                                  
 22988                                  ; 04/05/2019 - Retro DOS v4.0
 22989                                  ; DOSCODE:78F0h (MSDOS 6.21, MSDOS.SYS)
 22990                                  
 22991                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22992                                  ; DOSCODE:78DCh (MSDOS 5.0, MSDOS.SYS) 
 22993                                  
 22994                                  ;procedure DskRdBufScan,NEAR
 22995                                  ;
 22996                                  ;ASSUME  DS:NOTHING
 22997                                  
 22998                                  DskRdBufScan:
 22999 0000388E 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0 ; Any dirty buffers?
 23000 00003894 743C                    	je	short bufx		     ; -no, skip all work.
 23001                                  
 23002 00003896 368B1E[0706]            	mov     bx,[ss:HIGH_SECTOR]
 23003 0000389B 89DE                    	mov     si,bx
 23004 0000389D 01D1                    	add     cx,dx
 23005 0000389F 83D600                  	adc     si,0
 23006                                  
 23007 000038A2 E89A1E                  	call	GETCURHEAD		;DS:DI -> 1st buf in queue.
 23008                                  	;mov	ax,[di+2]
 23009 000038A5 8B4502                  	mov     ax,[di+BUFFINFO.buf_prev]
 23010 000038A8 36A3[BB0E]              	mov     [ss:FIRST_BUFF_ADDR],ax
 23011                                  		
 23012                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23013                                  	;;mov	al,[es:bp+0]
 23014                                  	;mov	al,[es:bp+DPB.DRIVE]
 23015                                  	; 15/12/2022
 23016 000038AC 268A4600                	mov	al,[es:bp]
 23017                                  
 23018                                  ;       BX:DX = Extent start.
 23019                                  ;       SI:CX = Extent end + 1.
 23020                                  ;          AL = Drive #.
 23021                                  ;       DS:DI-> 1st buffer in queue.
 23022                                  ;[FIRST_BUFF_ADDR] = Address offset of last buffer in queue.
 23023                                  
 23024                                  bufq:	
 23025                                  	;cmp	al,[di+4]
 23026 000038B0 3A4504                  	cmp     al,[di+BUFFINFO.buf_ID] ;Same drive?
 23027 000038B3 7514                    	jne	short bufq1        	;  -no, jump.
 23028                                  
 23029                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 23030                                  ;       ja	short bufq1		;Jump if Extent start > buffer sector.
 23031                                  
 23032                                  	;cmp	bx,[di+8]
 23033 000038B5 3B5D08                  	cmp	bx,[di+BUFFINFO.buf_sector+2]
 23034 000038B8 7503                    	jne	short bufq01
 23035                                  	;cmp	dx,[di+6]
 23036 000038BA 3B5506                  	cmp	dx,[di+BUFFINFO.buf_sector]
 23037                                  bufq01:
 23038 000038BD 770A                    	ja	short bufq1
 23039                                  
 23040                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 23041                                  ;       ja	short bufq2		;Jump if Extent end >= buffer sector.
 23042                                  
 23043                                  	;cmp	si,[di+8]
 23044 000038BF 3B7508                  	cmp	si,[di+BUFFINFO.buf_sector+2]
 23045 000038C2 7503                    	jne	short bufq02
 23046                                  	;cmp	cx,[di+6]
 23047 000038C4 3B4D06                  	cmp	cx,[di+BUFFINFO.buf_sector]
 23048                                  bufq02:
 23049 000038C7 770A                    	ja	short bufq2
 23050                                  bufq1:	
 23051 000038C9 363B3E[BB0E]            	cmp     di,[ss:FIRST_BUFF_ADDR]	;Scanned entire buffer queue?
 23052 000038CE 8B3D                    	mov	di,[di]
 23053                                  	;mov	di,[di+BUFFINFO.buf_next] ; Set-up for next buffer.
 23054 000038D0 75DE                    	jne	short bufq		; -no, do next buffer
 23055                                  bufx:
 23056 000038D2 C3                      	retn				;Exit.
 23057                                  
 23058                                  ;       Buffer's sector is in Extent: if it is dirty, copy its contents to
 23059                                  ;	transfer memory; otherwise, just re-position it in the buffer queue
 23060                                  ;       as MRU (Most Recently Used).
 23061                                  
 23062                                  bufq2:	
 23063 000038D3 50                      	push	ax
 23064                                  	;test	byte [di+5],40h
 23065 000038D4 F6450540                	test	byte [di+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty?
 23066 000038D8 7428                    	jz	short bufq3                    ; -no, jump.
 23067                                  
 23068                                  ;       SaveReg <cx,dx,si,di,es>
 23069 000038DA 51                      	push	cx
 23070 000038DB 52                      	push	dx
 23071 000038DC 56                      	push	si
 23072 000038DD 57                      	push	di
 23073 000038DE 06                      	push	es
 23074                                  
 23075 000038DF 89D0                    	mov     ax,dx
 23076                                  	;sub	ax,[di+6]
 23077 000038E1 2B4506                  	sub	ax,[di+BUFFINFO.buf_sector]
 23078 000038E4 F7D8                    	neg	ax
 23079                                  
 23080                                  ;       AX = offset (in sectors) of buffer sector within Transfer memory
 23081                                  ;            block. (Note: the upper word of the sector # may be ignored
 23082                                  ;	     since no more than 64k bytes will ever be read. This 64k limit
 23083                                  ;            is imposed by the input parameters of the disk read operation.)
 23084                                  
 23085                                  	;lea	si,[di+20]
 23086 000038E6 8D7514                  	lea	si,[di+BUFINSIZ]	;DS:SI -> buffer data.
 23087                                  	;mov	cx,[es:bp+2]
 23088 000038E9 268B4E02                	mov     cx,[es:bp+DPB.SECTOR_SIZE] ;CX = sector size (in bytes).
 23089 000038ED F7E1                    	mul     cx			;AX = offset (in bytes) of buf. sector
 23090                                  	;mov	di,[ss:TEMP_VAR]
 23091                                  	; 09/02/2024
 23092 000038EF 36C43E[0C06]            	les	di,[ss:TEMP_VAR]
 23093 000038F4 01C7                    	add	di,ax
 23094                                  	;mov	es,[ss:TEMP_VAR2]
 23095 000038F6 D1E9                    	shr	cx,1
 23096                                  
 23097                                  ;	   CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
 23098                                  ;       DS:SI-> Buffer sector data.
 23099                                  ;       ES:DI-> Destination within Transfer memory block.
 23100                                  
 23101 000038F8 F3A5                    	rep	movsw			;Copy buffer sector to Transfer memory
 23102                                  	;; 04/05/2019
 23103                                  	;;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 23104                                  	;;rep	movsb                   ;Copy last byte.
 23105                                  	;jnc	short bufq03	
 23106                                  	;movsb
 23107                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23108                                  	;adc	cx,0
 23109                                  	;rep	movsb
 23110                                  	; 22/09/2023
 23111 000038FA 7301                    	jnc	short bufq03
 23112 000038FC A4                      	movsb
 23113                                  bufq03:
 23114                                  	;RestoreReg <es,di,si,dx,cx>
 23115 000038FD 07                      	pop	es
 23116 000038FE 5F                      	pop	di
 23117 000038FF 5E                      	pop	si
 23118 00003900 5A                      	pop	dx
 23119 00003901 59                      	pop	cx
 23120                                  
 23121                                  ;       DS:DI -> current buffer.
 23122                                  bufq3:	
 23123 00003902 89F8                    	mov     ax,di			;DS:AX -> Current buffer.
 23124                                          ;invoke SCANPLACE
 23125 00003904 E84A1E                  	call	SCANPLACE
 23126 00003907 363B06[BB0E]            	cmp	ax,[ss:FIRST_BUFF_ADDR] ;Last buffer?
 23127 0000390C 58                      	pop	ax
 23128                                  	;jne	short bufq		; -no, jump.
 23129                                  	;;jmp	short bufx		; -yes, exit.
 23130                                  	;; 12/06/2019
 23131                                  	;retn
 23132                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compability)
 23133 0000390D 75A1                    	jne	short bufq
 23134                                  	;jmp	short bufx
 23135                                  	; 09/02/2024
 23136 0000390F C3                      	retn	; Exit
 23137                                  
 23138                                  ;EndProc DskRdBufScan
 23139                                  
 23140                                  ;============================================================================
 23141                                  ; DISK3.ASM, MSDOS 6.0, 1991
 23142                                  ;============================================================================
 23143                                  ; 04/05/2019 - Retro DOS v4.0
 23144                                  ; 24/07/2018 - Retro DOS v3.0
 23145                                  
 23146                                  ;Break   <DISKWRITE -- PERFORM USER DISK WRITE>
 23147                                  ;----------------------------------------------------------------------------
 23148                                  ;
 23149                                  ; Procedure Name : DISKWRITE
 23150                                  ;
 23151                                  ; Inputs:
 23152                                  ;       Outputs of SETUP
 23153                                  ; Function:
 23154                                  ;       Perform disk write
 23155                                  ; Outputs:
 23156                                  ;    Carry clear
 23157                                  ;       CX = No. of bytes written
 23158                                  ;       ES:DI point to SFT
 23159                                  ;       SFT offset and cluster pointers updated
 23160                                  ;    Carry set
 23161                                  ;       CX = 0
 23162                                  ;       ES:DI point to SFT
 23163                                  ;       AX has error code
 23164                                  ;----------------------------------------------------------------------------
 23165                                  
 23166                                  ;hkn; called by DOS_WRITE. DS already set up at this point.
 23167                                  
 23168                                  ; DOSCODE:797Ah (MSDOS 6.21, MSDOS.SYS)
 23169                                  
 23170                                  ; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23171                                  ; DOSCODE:7966h (MSDOS 5.0, MSDOS.SYS) 
 23172                                  
 23173                                  DISKWRITE:
 23174                                  	; MSDOS 3.3
 23175                                  	; IBMDOS.COM - Offset 436Dh
 23176                                  	;;test	byte [es:di+4],8
 23177                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 23178                                  	;jz	short write_cont
 23179                                  	;jmp	SET_ACC_ERR_DS
 23180                                  ;write_cont:
 23181                                  	;push	cx
 23182                                  	;or	cx,cx
 23183                                  	;jnz	short Not_Truncate
 23184                                  	;;mov	cx,-1
 23185                                  	;dec	cx
 23186                                  ;Not_Truncate:
 23187                                  	;call	LOCK_CHECK
 23188                                  	;pop	cx
 23189                                  	;jnb	short _WRITE_OK
 23190                                  	;call	WRITE_LOCK_VIOLATION
 23191                                  	;jnb	short DISKWRITE
 23192                                  	;retn
 23193                                  
 23194                                  	; MSDOS 6.0
 23195 00003910 E802FD                  	call	CHECK_WRITE_LOCK	;IFS. check write lock	;AN000;
 23196                                  	; 19/08/2018
 23197 00003913 7304                    	JNC	short _WRITE_OK		;IFS. lock check ok	;AN000;
 23198 00003915 C3                      	retn
 23199                                  
 23200                                  WRTEOFJ:
 23201 00003916 E9D101                  	JMP     WRTEOF
 23202                                  
 23203                                  _WRITE_OK:
 23204                                   	; 27/07/2018
 23205                                  	; IBMDOS.COM - Offset 438Eh
 23206                                  	
 23207                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23208                                  	;and	word [es:di+5],0BFBFh
 23209 00003919 26816505BFBF            	AND     word [ES:DI+SF_ENTRY.sf_flags],~(sf_close_nodate|devid_file_clean)
 23210                                  				; Mark file as dirty, clear no date on close
 23211                                  ; 10/02/2024
 23212                                  %if 0
 23213                                  	; 04/05/2019 - Retro DOS v4.0
 23214                                  
 23215                                  	; MSDOS 6.0
 23216                                  	;mov 	ax,[es:di+11h]
 23217                                  	MOV	AX,[ES:DI+SF_ENTRY.sf_size]		;M039
 23218                                          MOV	[TEMP_VAR],AX                           ;M039
 23219                                  	;mov	ax,[es:di+13h]
 23220                                  	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]		;M039
 23221                                          MOV	[TEMP_VAR2],AX                          ;M039
 23222                                  %else
 23223                                  	; 10/02/2024 (PCDOS 7.1 IBMDOS COM)
 23224                                  	;les	ax,[es:di+11h]
 23225 0000391F 26C44511                	les	ax,[es:di+SF_ENTRY.sf_size]
 23226 00003923 8C06[0E06]              	mov	[TEMP_VAR2],es
 23227 00003927 A3[0C06]                	mov	[TEMP_VAR],ax
 23228                                  %endif
 23229                                  
 23230                                  ;	TEMP_VAR2:TEMP_VAR = Current file size (sf_size);M039
 23231                                  
 23232                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23233 0000392A C42E[8A05]              	LES     BP,[THISDPB]
 23234                                  
 23235 0000392E E80FFE                  	call	BREAKDOWN
 23236                                  
 23237 00003931 A1[CE05]                	MOV     AX,[BYTPOS]
 23238 00003934 8B16[D005]              	MOV     DX,[BYTPOS+2]
 23239 00003938 E3DC                    	JCXZ    WRTEOFJ                 ;Make the file length = sf_position
 23240 0000393A 01C8                    	ADD     AX,CX
 23241 0000393C 83D200                  	ADC     DX,0                    ;DX:AX = last byte to write + 1.
 23242                                  
 23243                                  	;mov	bx,[es:bp+2]
 23244 0000393F 268B5E02                	MOV     BX,[ES:BP+DPB.SECTOR_SIZE]
 23245                                  
 23246                                  	; MSDOS 3.3
 23247                                  	;cmp	dx,bx
 23248                                  	;jnb	short WRTERR33
 23249                                  	;div	bx
 23250                                  	;mov	bx,ax
 23251                                  	;OR	DX,DX
 23252                                  	;JNZ	short CALCLUS
 23253                                  	;dec	ax
 23254                                  ;CALCLUS:
 23255                                  	; MSDOS 3.3
 23256                                  	;mov	cl,[es:bp+5]
 23257                                  	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 23258                                  	;shr	ax,cl
 23259                                  	;push	ax
 23260                                  	;push	dx
 23261                                  	;push	es
 23262                                  	;les	di,[THISSFT]
 23263                                  	;;mov	ax,[es:di+11h]
 23264                                  	;;mov	dx,[es:di+13h]
 23265                                  	;mov	ax,[ES:DI+SF_ENTRY.sf_size]
 23266                                  	;mov	dx,[ES:DI+SF_ENTRY.sf_size+2]
 23267                                  	;pop	es
 23268                                  	;;DX:AX = current file size (in bytes).
 23269                                  	;;div	word [es:bp+2]
 23270                                  	;div	word [ES:BP+DPB.SECTOR_SIZE]
 23271                                  	;mov	cx,ax
 23272                                  	;or	dx,dx
 23273                                  	;jz	short NORND
 23274                                  	;inc	ax
 23275                                  ;NORND:
 23276                                  	; MSDOS 6.0
 23277 00003943 E8D202                  	CALL	DIV32                   ;DX:AX/BX = CX:AX + DX (rem.).
 23278 00003946 89C6                    	MOV	SI,AX
 23279 00003948 890E[0706]                      MOV	[HIGH_SECTOR],CX
 23280                                  
 23281                                  ;       [HIGH_SECTOR]:SI = Last full sector to write.
 23282                                  
 23283 0000394C 09D2                    	OR	DX,DX
 23284 0000394E 52                      	PUSH	DX			;M039: Free DX for use by SHR32
 23285 0000394F 89CA                    	MOV	DX,CX			;M039
 23286 00003951 7506                    	JNZ	short CALCLUS
 23287 00003953 83E801                  	SUB	AX,1                    ;AX must be zero base indexed	;AC000;
 23288 00003956 83DA00                  	SBB	DX,0			;M039 ;F.C. >32mb		;AN000;
 23289                                  
 23290                                  CALCLUS:
 23291                                  	; MSDOS 6.0
 23292 00003959 E8E302                  	CALL	SHR32                   ;F.C. >32mb			;AN000;
 23293 0000395C 5A                      	POP	DX
 23294                                  
 23295                                  ;       AX = Last cluster to write.
 23296                                  ;       DX = # of bytes in last sector to write (the "tail").
 23297                                  ;       BX = [ES:BP+DPB.SECTOR_SIZE]
 23298                                  
 23299 0000395D 50                      	PUSH	AX
 23300 0000395E 52                      	PUSH	DX
 23301                                  ;M039
 23302 0000395F 8B16[0E06]              	mov	dx,[TEMP_VAR2]
 23303 00003963 A1[0C06]                	mov	ax,[TEMP_VAR]           ;DX:AX = current file size (in bytes).
 23304 00003966 E8AF02                  	call	DIV32           	;DX:AX/BX = CX:AX + DX (rem.)
 23305 00003969 890E[0E06]              	mov	[TEMP_VAR2],cx
 23306 0000396D 890E[CA05]              	mov	[VALSEC+2],cx
 23307 00003971 89C1                    	mov	cx,ax
 23308 00003973 89F3                    	mov	bx,si
 23309                                  
 23310                                  ;       [HIGH_SECTOR]:BX = Last full sector to write.
 23311                                  ;          [VALSEC+2]:CX = Last full sector of current file.
 23312                                  ;         [TEMP_VAR2]:CX = Last full sector of current file.
 23313                                  ;                     DX = # of bytes in last sector of current file.
 23314                                  ;M039
 23315 00003975 09D2                    	OR	DX,DX
 23316 00003977 7407                    	JZ	short NORND
 23317                                  	;ADD	AX,1            	;Round up if any remainder	;AC000;
 23318                                  	;ADC	word [VALSEC+2],0
 23319                                  	; 22/09/2023
 23320 00003979 40                      	inc	ax  ; 0FFFFh -> 0
 23321 0000397A 7504                    	jnz	short NORND
 23322 0000397C FF06[CA05]              	inc	word [VALSEC+2]
 23323                                  NORND:	
 23324                                  	; MSDOS 3.3 & MSDOS 6.0
 23325 00003980 A3[C805]                	MOV     [VALSEC],AX
 23326                                  
 23327                                  ;       [VALSEC] = Last sector of current file.
 23328                                  
 23329 00003983 31C0                    	XOR     AX,AX
 23330 00003985 A3[DE05]                	MOV     [GROWCNT],AX
 23331 00003988 A3[E005]                	MOV     [GROWCNT+2],AX
 23332 0000398B 58                      	POP     AX
 23333                                  
 23334                                  	; MSDOS 6.0
 23335 0000398C 8B3E[0706]              	MOV	DI,[HIGH_SECTOR]        ;F.C. >32mb			;AN000;
 23336 00003990 3B3E[0E06]              	CMP	DI,[TEMP_VAR2]		;M039; F.C. >32mb		;AN000;
 23337 00003994 7263                    	JB	short NOGROW		;F.C. >32mb                     ;AN000;
 23338 00003996 7408                    	JZ	short lowsec		;F.C. >32mb                     ;AN000;
 23339 00003998 29CB                    	SUB	BX,CX                   ;F.C. >32mb                     ;AN000;
 23340 0000399A 1B3E[0E06]              	SBB	DI,[TEMP_VAR2]   	;M039; F.C. >32mb di:bx no. of sectors ;AN000;
 23341 0000399E EB08                    	JMP	short yesgrow           ;F.C. >32mb                     ;AN000;
 23342                                  lowsec:
 23343                                  	;MOV	DI,0			;F.C. >32mb
 23344                                  	; 22/09/2023
 23345 000039A0 31FF                    	xor	di,di
 23346                                  	; MSDOS 3.3 & MSDOS 6.0
 23347 000039A2 29CB                    	SUB	BX,CX			; Number of full sectors
 23348 000039A4 7253                    	JB	short NOGROW
 23349 000039A6 7444                    	JZ	short TESTTAIL
 23350                                  yesgrow:
 23351                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23352 000039A8 89D1                    	MOV     CX,DX
 23353 000039AA 93                      	XCHG    AX,BX
 23354                                  	;mul	word [es:bp+2]
 23355 000039AB 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]  ; Bytes of full sector growth
 23356                                  	
 23357                                  	; MSDOS 6.0
 23358 000039AF 8916[0706]              	MOV	[HIGH_SECTOR],DX	;F.C. >32mb save dx		;AN000;
 23359 000039B3 A3[0E06]                	MOV	[TEMP_VAR2],AX		;M039; F.C. >32mb save ax	;AN000;
 23360 000039B6 89F8                    	MOV	AX,DI			;F.C. >32mb			;AN000;
 23361                                  	;mul	word [es:bp+2]
 23362 000039B8 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE] ;F.C. >32mb do higher word multiply ;AN000;
 23363                                  	
 23364 000039BC 0306[0706]              	ADD	AX,[HIGH_SECTOR]	;F.C. >32mb add lower value	;AN000;
 23365 000039C0 89C2                    	MOV	DX,AX			;F.C. >32mb DX:AX is the result of ;AN000;
 23366 000039C2 A1[0E06]                	MOV	AX,[TEMP_VAR2]		;M039; F.C. >32mb a 32 bit multiply ;AN000;
 23367                                  
 23368                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23369 000039C5 29C8                    	SUB     AX,CX			; Take off current "tail"
 23370 000039C7 83DA00                  	SBB     DX,0			; 32-bit extension
 23371 000039CA 01D8                    	ADD     AX,BX			; Add on new "tail"
 23372 000039CC 83D200                  	ADC     DX,0			; ripple tim's head off
 23373 000039CF EB21                    	JMP     SHORT SETGRW
 23374                                  
 23375                                  HAVSTART:
 23376                                  	;int 3
 23377 000039D1 89C1                    	MOV     CX,AX
 23378 000039D3 E81E11                  	call	SKPCLP
 23379                                  	;JCXZ	DOWRTJ
 23380                                  	; 16/12/2022
 23381 000039D6 E353                    	jcxz	DOWRT
 23382                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23383                                  	;jcxz	DOWRTJ
 23384                                  
 23385 000039D8 E8B612                  	call	ALLOCATE
 23386                                  	;JNC	short DOWRTJ
 23387                                  	; 16/12/2022
 23388 000039DB 734E                    	jnc	short DOWRT
 23389                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23390                                  	;jnc	short DOWRTJ
 23391                                  
 23392                                  	;entry   WRTERR
 23393                                  WRTERR:
 23394 000039DD B40F                    	MOV     AH,0FH			;MS. write/data/fail/abort	;AN000;
 23395                                  
 23396                                  	;entry WRTERR22
 23397                                  WRTERR22:
 23398 000039DF A0[7605]                	MOV     AL,[THISDRV]		;MS.				;AN000;
 23399                                  
 23400                                  	; 27/07/2018
 23401                                  WRTERR33:
 23402                                  	;MOV	CX,0			;No bytes transferred
 23403 000039E2 31C9                    	XOR     CX,CX
 23404                                  
 23405 000039E4 C43E[9E05]              	LES     DI,[THISSFT]
 23406                                  	;CLC ; 19/05/2019
 23407                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23408                                  	; 16/12/2022
 23409                                  	;clc
 23410 000039E8 C3                      	retn
 23411                                  
 23412                                  	; 16/12/2022
 23413                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23414                                  ;DOWRTJ:
 23415                                  	;JMP	short DOWRT
 23416                                  
 23417                                  ACC_ERRWJ:
 23418                                  	; 10/08/2018
 23419                                  	;JMP	SET_ACC_ERRW
 23420                                  	; 16/12/2022
 23421                                  	;jmp	SET_ACC_ERR_DS ; ds<>ss ; 10/02/2024
 23422                                  	; 10/02/2024
 23423                                  	; ds=ss
 23424 000039E9 E9E2FD                  	jmp	SET_ACC_ERR
 23425                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23426                                  	;;jmp	SET_ACC_ERRW	
 23427                                  
 23428                                  TESTTAIL:
 23429 000039EC 29D0                    	SUB     AX,DX
 23430 000039EE 7609                    	JBE	short NOGROW
 23431 000039F0 31D2                    	XOR     DX,DX
 23432                                  SETGRW:
 23433 000039F2 A3[DE05]                	MOV	[GROWCNT],AX
 23434 000039F5 8916[E005]              	MOV	[GROWCNT+2],DX
 23435                                  NOGROW:
 23436 000039F9 58                      	POP     AX
 23437                                  
 23438                                  ; 10/02/2024
 23439                                  %if 0
 23440                                  	MOV     CX,[CLUSNUM] ; *+ ; First cluster accessed
 23441                                  	call	FNDCLUS
 23442                                  %else
 23443                                  	; 10/02/2024 - Retro DOS v4.2
 23444 000039FA E8D310                  	call	FNDCLUS_X ; *+
 23445                                  %endif
 23446 000039FD 72EA                    	JC	short ACC_ERRWJ ; ds=ss ; 10/02/2024
 23447                                  
 23448 000039FF 891E[BC05]              	MOV     [CLUSNUM],BX
 23449 00003A03 8916[BA05]              	MOV     [LASTPOS],DX
 23450                                  
 23451 00003A07 29D0                    	SUB     AX,DX           ; Last cluster minus current cluster
 23452 00003A09 7420                    	JZ	short DOWRT	; If we have last clus, we must have first
 23453 00003A0B E3C4                    	JCXZ    HAVSTART        ; See if no more data
 23454 00003A0D 51                      	PUSH    CX              ; No. of clusters short of first
 23455 00003A0E 89C1                    	MOV     CX,AX
 23456 00003A10 E87E12                  	call	ALLOCATE
 23457 00003A13 59                      	POP     CX
 23458 00003A14 72C7                    	JC	short WRTERR
 23459 00003A16 8B16[BA05]              	MOV     DX,[LASTPOS]
 23460 00003A1A 42                      	INC     DX
 23461 00003A1B 49                      	DEC     CX
 23462 00003A1C 7405                    	JZ	short NOSKIP
 23463 00003A1E E8D310                  	call	SKPCLP
 23464 00003A21 72C6                    	JC	short ACC_ERRWJ ; ds=ss ; 10/02/2024
 23465                                  NOSKIP:
 23466 00003A23 891E[BC05]              	MOV     [CLUSNUM],BX
 23467 00003A27 8916[BA05]              	MOV     [LASTPOS],DX
 23468                                  DOWRT:
 23469 00003A2B 833E[D205]00            	CMP     word [BYTCNT1],0
 23470 00003A30 7405                    	JZ	short WRTMID
 23471                                  	; 09/02/2024
 23472                                  	;MOV	BX,[CLUSNUM]	 ; (not used in 'BUFWRT') ; 09/02/2024
 23473 00003A32 E84E11                  	call	BUFWRT
 23474 00003A35 72B2                    	JC	short ACC_ERRWJ
 23475                                  WRTMID:
 23476 00003A37 A1[D605]                	MOV     AX,[SECCNT]
 23477 00003A3A 09C0                    	OR      AX,AX
 23478                                  	; 20/11/2022
 23479 00003A3C 746F                    	JZ	short WRTLAST	; 24/07/2019	;M039
 23480 00003A3E 0106[C405]              	ADD     [SECPOS],AX
 23481                                  	; 19/05/2019
 23482                                  	; MSDOS 6.0
 23483 00003A42 8316[C605]00            	ADC	WORD [SECPOS+2],0	;F.C. >32mb 	;AN000;
 23484 00003A47 E89411                  	call	NEXTSEC
 23485                                  	; 16/12/2022
 23486 00003A4A 729D                    	JC	short ACC_ERRWJ
 23487                                  	;JC	short SET_ACC_ERRW	;M039
 23488 00003A4C C606[7405]01            	MOV     BYTE [TRANS],1		; A transfer is taking place
 23489 00003A51 8A16[7305]              	MOV     DL,[SECCLUSPOS] 	; (dx/DL = Extent start) ((dh = ?))
 23490 00003A55 8B1E[BC05]              	MOV     BX,[CLUSNUM]
 23491 00003A59 8B0E[D605]              	MOV     CX,[SECCNT]
 23492                                  WRTLP:
 23493 00003A5D E8AF11                  	call	OPTIMIZE
 23494 00003A60 7248                    	JC	short SET_ACC_ERRW
 23495                                  	; 16/12/2022
 23496                                  	;JC	short ACC_ERRWJ
 23497                                  
 23498                                  ;M039
 23499                                  ;       DI = Next physical cluster.
 23500                                  ;       AX = # sectors remaining.
 23501                                  ;       [DMAADD+2]:BX = transfer address (source data address).
 23502                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 23503                                  ;	     sectors, also termed an "Extent".)
 23504                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 23505                                  ;       ES:BP -> Drive Parameter Block (DPB).
 23506                                  ;
 23507                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 23508                                  ;	are in Extent; they are being over-written.
 23509                                  
 23510 00003A62 57                      	push    di
 23511 00003A63 50                      	push    ax
 23512                                  
 23513                                  	; MSDOS 3.3
 23514                                  	; IBMDOS.COM (1987) - Offset 4497h
 23515                                  	;push	dx
 23516                                  	;push	bx
 23517                                  	;mov	al,[es:bp]
 23518                                  	;;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 23519                                  	;mov	bx,cx
 23520                                  	;add	bx,dx	; (bx = Extent end)
 23521                                  
 23522                                  ;	DX = Extent start.
 23523                                  ;	BX = Extent end.
 23524                                  ;	AL = Drive #.
 23525                                  
 23526                                  	;call	SETVISIT
 23527                                  
 23528                                  ;wbufq1:
 23529                                  	;;or	byte [di+5],20h
 23530                                  	;or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 23531                                  	;;cmp	al,[di+4]
 23532                                  	;cmp	al,[DI+BUFFINFO.buf_ID]
 23533                                  	;jnz	short wbufq2	; Jump if Extent start > buffer sector.
 23534                                  	;;cmp	[di+6],dx
 23535                                  	;cmp	[DI+BUFFINFO.buf_sector],dx
 23536                                  	;jb	short wbufq2
 23537                                  	;;cmp	[di+6],bx
 23538                                  	;cmp	[DI+BUFFINFO.buf_sector],bx
 23539                                  	;jnb	short wbufq2	; Jump if Extent end >= buffer sector.
 23540                                  
 23541                                  	;; Buffer sector is in the Extent
 23542                                  
 23543                                  	;;mov	word [di+4],20FFh
 23544                                  	;mov	word [DI+BUFFINFO.buf_ID],20FFh
 23545                                  	;				; .buf_ID,    AL = FFh (Free buffer)
 23546                                  	;				; .buf_flags, AH = 0, reset/clear
 23547                                  	;call	SCANPLACE
 23548                                  ;wbufq2:
 23549                                  	;call	SKIPVISIT
 23550                                  	;jnz	short wbufq1
 23551                                  	;pop	bx
 23552                                  	;pop	dx
 23553                                  
 23554                                          ; MSDOS 6.0
 23555 00003A64 E82B01                  	call	DskWrtBufPurge		;DS trashed.
 23556                                  
 23557                                  ;ASSUME DS:NOTHING
 23558                                  ;M039
 23559                                  	; MSDOS 3.3 & MSDOS 6.0
 23560                                  ;hkn; SS override for DMAADD and ALLOWED
 23561 00003A67 368E1E[2E03]            	MOV     DS,[SS:DMAADD+2]
 23562                                  	;mov	byte [ss:ALLOWED],38h
 23563 00003A6C 36C606[4B03]38          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 23564                                  
 23565                                  ;	put logic from DWRITE in-line here so we can modify it
 23566                                  ;	for DISK FULL conditions.
 23567                                  
 23568                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23569                                  	; DOSCODE:7AD8h (MSDOS 5.0 MSDOS.SYS)
 23570                                  
 23571                                  	; 16/12/2022
 23572                                  	; MSDOS 3.3 (& MSDOS 5.0)
 23573                                  	;call	DWRITE
 23574                                  
 23575                                  ;DWRITE_OKAY:
 23576                                  
 23577                                  	; 16/12/2022
 23578                                  	; MSDOS 5.0 (& MSDOS 3.3)
 23579                                  	;pop	cx
 23580                                  	;pop	bx
 23581                                  	;push	ss
 23582                                  	;pop	ds
 23583                                  	;jc	short SET_ACC_ERRW
 23584                                  	;jcxz	WRTLAST
 23585                                  	;mov	dl,0
 23586                                  	;inc	word [LASTPOS]
 23587                                  	;jmp	short WRTLP
 23588                                  
 23589                                  	; 16/12/2022
 23590                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23591                                  DWRITE_LUP:
 23592                                  	; 23/07/2019 - Retro DOS v3.2
 23593                                  
 23594                                  	; MSDOS 6.0
 23595 00003A72 E8F9FB                  	call	DSKWRITE
 23596 00003A75 7417                    	jz	short DWRITE_OKAY
 23597                                  
 23598                                  ;;	int	3
 23599                                  
 23600 00003A77 3C27                    	cmp	al,error_handle_Disk_Full	; compressed volume full?
 23601 00003A79 7423                    	jz	short DWRITE_DISK_FULL
 23602                                  
 23603                                  	; 16/12/2022
 23604                                  
 23605                                  ;;hkn; SS override
 23606 00003A7B 36C606[7505]01          	MOV	BYTE [SS:READOP],1
 23607 00003A81 E819FC                  	call	HARDERRRW
 23608 00003A84 3C01                    	CMP	AL,1		; Check for retry
 23609 00003A86 74EA                    	JZ	short DWRITE_LUP
 23610                                  
 23611                                  	; 16/12/2022
 23612                                  	; 23/07/2019
 23613                                  	;POP	CX ; *4*
 23614                                  	;POP	BX ; *5*
 23615                                  	;
 23616                                  	;push	ss
 23617                                  	;pop	ds
 23618                                  	;
 23619                                  
 23620                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23621                                  
 23622                                  	; 16/12/2022
 23623 00003A88 3C03                    	CMP	AL,3		; Check for FAIL
 23624 00003A8A F8                      	CLC
 23625 00003A8B 7501                    	JNZ	short DWRITE_OKAY ; Ignore
 23626 00003A8D F9                      	STC
 23627                                  
 23628                                  DWRITE_OKAY:
 23629                                  	; 16/12/2022
 23630                                  	; 23/07/2019
 23631                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23632 00003A8E 59                      	POP	CX ; *4*
 23633 00003A8F 5B                      	POP	BX ; *5*
 23634                                  
 23635                                  ;       CX = # sectors remaining.
 23636                                  ;       BX = Next physical cluster.
 23637                                  
 23638                                  ;hkn; SS override
 23639                                          ;Context DS
 23640                                  	; 16/12/2022
 23641                                  	;push	ss
 23642                                  	;pop	ds
 23643                                  
 23644                                  	; 10/02/2024
 23645                                  	; 16/12/2022
 23646                                  	;jc	short SET_ACC_ERRW
 23647                                  
 23648                                  	; 16/12/2022
 23649 00003A90 16                      	push	ss
 23650 00003A91 1F                      	pop	ds
 23651                                  
 23652                                  	; 10/02/2024
 23653 00003A92 7216                    	jc	short SET_ACC_ERRW
 23654                                  
 23655 00003A94 E317                    	JCXZ    WRTLAST
 23656                                  
 23657                                  	; 10/02/2024
 23658 00003A96 B200                    	MOV	DL,0
 23659                                  	;xor	dl,dl ; 23/07/2019
 23660 00003A98 FF06[BA05]              	INC     word [LASTPOS]	; We'll be using next cluster
 23661 00003A9C EBBF                    	JMP     short WRTLP
 23662                                  
 23663                                  	; 23/07/2019 - Retro DOS v3.2
 23664                                  	; 09/08/2018
 23665                                  	; MSDOS 6.0
 23666                                  DWRITE_DISK_FULL:
 23667                                  	;Context DS		;SQ 3-5-93 DS must be setup on return!
 23668                                  	; 16/12/2022
 23669 00003A9E 16                      	push	ss
 23670 00003A9F 1F                      	pop	ds
 23671 00003AA0 59                      	pop	cx		; unjunk stack
 23672 00003AA1 5B                      	pop	bx
 23673 00003AA2 C606[0B06]01            	mov	byte [DISK_FULL],1
 23674                                  	;stc
 23675 00003AA7 E933FF                  	jmp	WRTERR ; 24/07/2019 ; go to disk full exit
 23676                                  
 23677                                  SET_ACC_ERRW:
 23678                                  	;jmp	SET_ACC_ERR_DS ; ds<>ss ; 10/02/2024
 23679                                  	; 10/02/2024
 23680                                  	; ds=ss
 23681 00003AAA E921FD                  	jmp	SET_ACC_ERR
 23682                                  
 23683                                  WRTLAST:
 23684 00003AAD A1[D405]                	MOV     AX,[BYTCNT2]
 23685 00003AB0 09C0                    	OR      AX,AX
 23686 00003AB2 7413                    	JZ	short FINWRT
 23687 00003AB4 A3[D205]                	MOV     [BYTCNT1],AX
 23688 00003AB7 E82411                  	call	NEXTSEC
 23689 00003ABA 72EE                    	JC	short SET_ACC_ERRW
 23690 00003ABC C706[CC05]0000          	MOV     word [BYTSECPOS],0
 23691 00003AC2 E8BE10                  	call	BUFWRT
 23692 00003AC5 72E3                    	JC	short SET_ACC_ERRW
 23693                                  FINWRT:
 23694 00003AC7 C43E[9E05]              	LES     DI,[THISSFT]
 23695 00003ACB A1[DE05]                	MOV     AX,[GROWCNT]
 23696 00003ACE 8B0E[E005]              	MOV     CX,[GROWCNT+2]
 23697 00003AD2 09C0                    	OR      AX,AX
 23698 00003AD4 7502                    	JNZ	short UPDATE_size
 23699 00003AD6 E30F                    	JCXZ    SAMSIZ
 23700                                  UPDATE_size:
 23701                                  	;add	[es:di+11h],ax
 23702 00003AD8 26014511                	ADD     [ES:DI+SF_ENTRY.sf_size],AX
 23703                                  	;adc	[es:di+13h],cx
 23704 00003ADC 26114D13                	ADC     [ES:DI+SF_ENTRY.sf_size+2],CX
 23705                                  
 23706                                  ; Make sure that all other SFT's see this growth also.
 23707                                  
 23708 00003AE0 B80100                  	MOV     AX,1
 23709                                  ;if installed
 23710                                  	;Call	JShare + 14 * 4
 23711 00003AE3 FF1E[C800]              	call    far [JShare+(14*4)]	; 14 = ShSU
 23712                                  ;else
 23713                                  ;	Call    ShSU
 23714                                  ;endif
 23715                                  
 23716                                  SAMSIZ:
 23717 00003AE7 E97AFD                  	jmp	SETCLUS	; ES:DI already points to SFT
 23718                                  
 23719                                  	; 16/12/2022
 23720                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23721                                  ;SET_ACC_ERRW:
 23722                                  	;jmp	SET_ACC_ERR_DS
 23723                                  
 23724                                  WRTEOF:
 23725 00003AEA 89C1                    	MOV     CX,AX
 23726 00003AEC 09D1                    	OR      CX,DX
 23727 00003AEE 746A                    	JZ	short KILLFIL
 23728 00003AF0 83E801                  	SUB     AX,1
 23729 00003AF3 83DA00                  	SBB     DX,0
 23730                                  
 23731                                  	; MSDOS 3.3
 23732                                  	;;div	word [es:bp+2]
 23733                                  	;div	word [ES:BP+DPB.SECTOR_SIZE]
 23734                                  	;;mov	cl,[es:bp+5]
 23735                                  	;mov	cl,[ES:BP+DPB.CLUSTER_SHIFT] 
 23736                                  	;shr	ax,cl
 23737                                  
 23738                                  	; MSDOS 6.0
 23739 00003AF6 53                      	PUSH	BX
 23740                                  	;mov	bx,[es:bp+2]
 23741 00003AF7 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]    ;F.C. >32mb                       ;AN000;
 23742 00003AFB E81A01                  	CALL	DIV32                         ;F.C. >32mb                       ;AN000;
 23743 00003AFE 5B                      	POP	BX			      ;F.C. >32mb			;AN000;
 23744 00003AFF 89CA                    	MOV	DX,CX			      ;M039
 23745 00003B01 890E[0706]                      MOV	[HIGH_SECTOR],CX              ;M039: Probably extraneous, but not sure.
 23746 00003B05 E83701                  	CALL	SHR32                         ;F.C. >32mb                       ;AN000;
 23747                                  
 23748 00003B08 89C1                    	MOV     CX,AX
 23749 00003B0A E8C70F                  	call	FNDCLUS
 23750                                  SET_ACC_ERRWJ2:
 23751 00003B0D 729B                    	JC	short SET_ACC_ERRW
 23752                                  
 23753 00003B0F E324                    	JCXZ    RELFILE
 23754 00003B11 E87D11                  	call	ALLOCATE
 23755                                  	;JC	short WRTERRJ              ;;;;;;;;; disk full
 23756                                  	; 16/12/2022
 23757 00003B14 7303                    	jnc	short UPDATE
 23758 00003B16 E9C4FE                  	JMP	WRTERR
 23759                                  UPDATE:
 23760 00003B19 C43E[9E05]              	LES	DI,[THISSFT]
 23761 00003B1D A1[CE05]                	MOV	AX,[BYTPOS]
 23762                                  	;mov	[es:di+11h],ax
 23763 00003B20 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 23764 00003B24 A1[D005]                	MOV	AX,[BYTPOS+2]
 23765                                  	;mov	[es:di+13h],ax
 23766 00003B27 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 23767                                  ;
 23768                                  ; Make sure that all other SFT's see this growth also.
 23769                                  ;
 23770 00003B2B B80200                  	MOV     AX,2
 23771                                  ;if installed
 23772                                  	;Call	JShare + 14 * 4
 23773 00003B2E FF1E[C800]              	call    far [JShare+(14*4)]	; 14 = ShSU
 23774                                  ;else
 23775                                  ;	Call    ShSU
 23776                                  ;endif
 23777 00003B32 31C9                    	XOR     CX,CX ; 0
 23778                                  	;jmp	ADDREC
 23779                                  	; 08/02/2024
 23780 00003B34 C3                      	retn
 23781                                  
 23782                                  	; 16/12/2022
 23783                                  ;WRTERRJ: 
 23784                                  	;JMP	WRTERR
 23785                                  
 23786                                  ;;;;;;;;;;;;;;;; 7/18/86
 23787                                  ;;;;;;;;;;;;;;;;
 23788                                  
 23789                                  RELFILE:
 23790                                  	; MSDOS 6.0
 23791 00003B35 06                      	PUSH    ES                    ;AN002; BL Reset Lstclus and cluspos to
 23792 00003B36 C43E[9E05]              	LES     DI,[THISSFT]          ;AN002; BL beginning of file if current
 23793                                  	;cmp	dx,[es:di+19h]
 23794 00003B3A 263B5519                	CMP     DX,[ES:DI+SF_ENTRY.sf_cluspos]	;AN002; BL cluspos is past EOF.
 23795 00003B3E 730E                    	JAE	short SKIPRESET	      		;AN002; BL
 23796                                  	;mov	[es:di+19h],0
 23797 00003B40 26C745190000            	MOV     word [ES:DI+SF_ENTRY.sf_cluspos],0 ;AN002; BL
 23798                                  	;mov	dx,[es:di+0Bh]
 23799 00003B46 268B550B                	MOV     DX,[ES:DI+SF_ENTRY.sf_firclus]	;AN002; BL
 23800                                  	;mov	[es:di+35h],dx
 23801 00003B4A 26895535                	MOV     [ES:DI+SF_ENTRY.sf_lstclus],DX	;AN002; BL
 23802                                  SKIPRESET:                            		;AN002; BL
 23803 00003B4E 07                      	POP     ES                    		;AN002; BL
 23804                                  ;
 23805 00003B4F BAFFFF                  	MOV     DX,0FFFFH
 23806 00003B52 E8EA11                  	call	RELBLKS
 23807                                  	; 16/12/2022
 23808                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23809 00003B55 73C2                    	jnc	short UPDATE
 23810                                  SET_ACC_ERRWJ:
 23811                                  	;JC	short SET_ACC_ERRWJ2
 23812                                  	;JMP	SHORT UPDATE
 23813                                  	; 16/12/2022
 23814                                  	;jmp	SET_ACC_ERR_DS ; ds<>ss
 23815                                  	; 10/02/2024
 23816                                  	; ds=ss
 23817 00003B57 E974FC                  	jmp	SET_ACC_ERR
 23818                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23819                                  	;JC	short SET_ACC_ERRWJ2
 23820                                  	;JMP	SHORT UPDATE
 23821                                  
 23822                                  KILLFIL:
 23823 00003B5A 31DB                    	XOR     BX,BX
 23824 00003B5C 06                      	PUSH    ES
 23825 00003B5D C43E[9E05]              	LES     DI,[THISSFT]
 23826                                  	;mov	[es:di+19h],bx
 23827 00003B61 26895D19                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],BX
 23828                                  	;mov	[es:di+35h],bx ; 04/05/2019
 23829 00003B65 26895D35                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],BX
 23830                                  	;xchg	bx,[es:di+0Bh]
 23831 00003B69 26875D0B                	XCHG    BX,[ES:DI+SF_ENTRY.sf_firclus]
 23832 00003B6D 07                      	POP	ES
 23833                                  
 23834 00003B6E 09DB                    	OR	BX,BX
 23835                                  	;JZ	short UPDATEJ
 23836                                  	; 16/12/2022
 23837 00003B70 74A7                    	jz	short UPDATE
 23838                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23839                                  	;jz	short UPDATEJ
 23840                                  
 23841                                  ;; 10/23/86 FastOpen update
 23842 00003B72 06                      	PUSH	ES              ; since first cluster # is 0
 23843 00003B73 55                      	PUSH	BP              ; we must delete the old cache entry
 23844 00003B74 50                      	PUSH	AX
 23845 00003B75 51                      	PUSH	CX
 23846 00003B76 52                      	PUSH	DX
 23847 00003B77 C42E[8A05]              	LES	BP,[THISDPB]             ; get current DPB
 23848                                  	; 15/12/2022
 23849 00003B7B 268A5600                	mov	dl,[ES:BP] ; mov dl,[es:bp+0]
 23850                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23851                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; get current drive
 23852 00003B7F 89D9                    	MOV	CX,BX                    ; first cluster #
 23853 00003B81 B402                    	MOV	AH,2                     ; delete cache entry by drive:firclus
 23854 00003B83 E8DFEA                  	call	FastOpen_Update          ; call fastopen
 23855 00003B86 5A                      	POP	DX
 23856 00003B87 59                      	POP	CX
 23857 00003B88 58                      	POP	AX
 23858 00003B89 5D                      	POP	BP
 23859 00003B8A 07                      	POP	ES
 23860                                  ;; 10/23/86 FastOpen update
 23861                                  
 23862 00003B8B E8AF11                  	call	RELEASE
 23863 00003B8E 72C7                    	JC	short SET_ACC_ERRWJ
 23864                                  UPDATEJ:
 23865                                  	; 20/11/2022
 23866 00003B90 EB87                    	JMP	short UPDATE ; 10/08/2018
 23867                                  
 23868                                  ;Break   <DskWrtBufPurge -- Disk Write Buffer Purge>
 23869                                  ;----------------------------------------------------------------------------
 23870                                  ;
 23871                                  ; Procedure Name : DskWrtBufPurge
 23872                                  ;
 23873                                  ; Inputs:
 23874                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 23875                                  ;	     sectors, also termed an "Extent".)
 23876                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 23877                                  ;       ES:BP -> Drive Parameter Block (DPB).
 23878                                  ;
 23879                                  ; Function:
 23880                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 23881                                  ;	are in Extent; they are being over-written.
 23882                                  ;
 23883                                  ; Outputs:
 23884                                  ;       (Same as Input.)
 23885                                  ; Uses:
 23886                                  ;       All registers except DS,AX,SI,DI preserved.
 23887                                  ;       SS override for all global variables.
 23888                                  ;----------------------------------------------------------------------------
 23889                                  ;M039: Created
 23890                                  
 23891                                  ;procedure   DskWrtBufPurge,NEAR
 23892                                  ;
 23893                                  ;ASSUME  DS:NOTHING
 23894                                  
 23895                                  ; 04/05/2019 - Retro DOS v4.0
 23896                                  ; DOSCODE:7C0Eh (MSDOS 6.21, MSDOS.SYS)
 23897                                  
 23898                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23899                                  ; DOSCODE:7BD4h (MSDOS 5.0, MSDOS.SYS) 
 23900                                  
 23901                                  DskWrtBufPurge:
 23902                                  	;SaveReg <bx,cx>
 23903 00003B92 53                      	push	bx
 23904 00003B93 51                      	push	cx
 23905                                  
 23906 00003B94 368B1E[0706]            	mov	bx,[ss:HIGH_SECTOR]	;BX:DX = Extent start (sector #).
 23907 00003B99 89DE                    	mov	si,bx
 23908 00003B9B 01D1                    	add	cx,dx
 23909 00003B9D 83D600                  	adc	si,0                    ;SI:CX = Extent end + 1.
 23910                                  
 23911                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23912                                  	;;mov	al,[es:bp+0]
 23913                                  	;mov	al,[es:bp+DPB.DRIVE]
 23914                                  	; 15/12/2022
 23915 00003BA0 268A4600                	mov	al,[es:bp]
 23916                                  
 23917                                  ;	BX:DX = Extent start.
 23918                                  ;	SI:CX = Extent end + 1.
 23919                                  ;	AL = Drive #
 23920                                  
 23921 00003BA4 36833E[7700]00          	cmp	word [ss:SC_CACHE_COUNT],0 ;Secondary cache in-use?
 23922 00003BAA 7431                    	je	short nosc		; -no, jump.
 23923                                  
 23924                                  ;	If any of the sectors to be written are in the secondary cache (SC),
 23925                                  ;	invalidate the entire SC. (This is an optimization; we really only
 23926                                  ;	need to invalidate those sectors which intersect, but that's slower.)
 23927                                  
 23928 00003BAC 363A06[B00D]            	cmp	al,[ss:CurSC_DRIVE]	;Same drive?
 23929 00003BB1 752A                    	jne	short nosc		; -no, jump.
 23930                                  
 23931 00003BB3 50                      	push    ax
 23932 00003BB4 36A1[B10D]              	mov     ax,[ss:CurSC_SECTOR]
 23933 00003BB8 368B3E[B30D]            	mov     di,[ss:CurSC_SECTOR+2]	;DI:AX = SC start.
 23934                                  
 23935                                  	;Cmp32	si,cx,di,ax		;Extent end < SC start?
 23936                                  	;jbe	short sc5		; -yes, jump.
 23937                                  
 23938 00003BBD 39FE                    	cmp	si,di
 23939 00003BBF 7502                    	jne	short sc01
 23940 00003BC1 39C1                    	cmp	cx,ax
 23941                                  sc01: 
 23942 00003BC3 7617                    	jbe	short sc5
 23943                                  
 23944 00003BC5 360306[7700]            	add	ax,[ss:SC_CACHE_COUNT]
 23945 00003BCA 83D700                  	adc	di,0                    ;DI:AX = SC end + 1.
 23946                                  	
 23947                                  	;Cmp32	bx,dx,di,ax             ;Extent start > SC end?
 23948                                  	;jae	short sc5		; -yes, jump.
 23949                                  
 23950 00003BCD 39FB                    	cmp	bx,di
 23951 00003BCF 7502                    	jne	short sc02
 23952 00003BD1 39C2                    	cmp	dx,ax
 23953                                  sc02:
 23954 00003BD3 7307                    	jnb	short sc5
 23955                                  
 23956 00003BD5 36C706[B50D]0000        	mov	word [ss:SC_STATUS],0	;Extent intersects SC: invalidate SC.
 23957                                  sc5:	
 23958 00003BDC 58                      	pop     ax
 23959                                  
 23960                                  ;	Free any buffered sectors which are in Extent; they are being over-
 23961                                  ;	written.
 23962                                  
 23963                                  nosc:	
 23964 00003BDD E85F1B                  	call	GETCURHEAD		;DS:DI -> first buffer in queue.
 23965                                  
 23966                                  _bufq:	
 23967                                  	;cmpo	al,[di+4]
 23968 00003BE0 3A4504                  	cmp     al,[di+BUFFINFO.buf_ID] ;Same drive?
 23969 00003BE3 7527                    	jne	short bufq5		; -no, jump.
 23970                                  
 23971                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 23972                                  ;       ja	short bufq5		;Jump if Extent start > buffer sector.
 23973                                  
 23974                                  	;cmp	bx,[di+8]
 23975 00003BE5 3B5D08                  	cmp	bx,[di+BUFFINFO.buf_sector+2]
 23976 00003BE8 7503                    	jne	short bufq04
 23977                                  	;cmp	dx,[di+6]
 23978 00003BEA 3B5506                  	cmp	dx,[di+BUFFINFO.buf_sector]
 23979                                  bufq04:
 23980 00003BED 771D                    	ja	short bufq5
 23981                                  
 23982                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 23983                                  ;       jbe	short bufq5		;Jump if Extent end < buffer sector.
 23984                                  
 23985                                  	;cmp	si,[di+8]
 23986 00003BEF 3B7508                  	cmp	si,[di+BUFFINFO.buf_sector+2]
 23987 00003BF2 7503                    	jne	short bufq05
 23988                                  	;cmp	cx,[di+6]
 23989 00003BF4 3B4D06                  	cmp	cx,[di+BUFFINFO.buf_sector]
 23990                                  bufq05:
 23991 00003BF7 7613                    	jbe	short bufq5
 23992                                  
 23993                                  ;	Buffer's sector is in Extent, so free it; it is being over-written.
 23994                                  
 23995                                  	;test	byte [di+5],40h
 23996 00003BF9 F6450540                	test	byte [di+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty?
 23997 00003BFD 7403                    	jz	short bufq4		; -no, jump.
 23998 00003BFF E8C71D                  	call	DEC_DIRTY_COUNT		; -yes, decrement dirty count.
 23999                                  bufq4:
 24000                                  	;mov	word [di+4],20FFh
 24001 00003C02 C74504FF20              	mov     word [di+BUFFINFO.buf_ID],((buf_visit<<8)|0FFh)
 24002                                  
 24003 00003C07 E8471B                  	call	SCANPLACE
 24004 00003C0A EB02                    	jmp     short bufq6
 24005                                  bufq5: 
 24006 00003C0C 8B3D                    	mov     di,[di]
 24007                                  	;mov	di,[di+BUFFINFO.buf_next]
 24008                                  bufq6: 
 24009 00003C0E 363B3E[BB0E]            	cmp	di,[ss:FIRST_BUFF_ADDR]	;Scanned entire buffer queue?
 24010 00003C13 75CB                    	jne	short _bufq		; --no, go do next buffer.
 24011                                  	
 24012                                  	;RestoreReg <cx,bx>
 24013 00003C15 59                      	pop	cx
 24014 00003C16 5B                      	pop	bx
 24015 00003C17 C3                      	retn
 24016                                  
 24017                                  ;EndProc DskWrtBufPurge
 24018                                  
 24019                                  ;Break   <DIV32 -- PERFORM 32 BIT DIVIDE>
 24020                                  ;----------------------------------------------------------------------------
 24021                                  ;
 24022                                  ; Procedure Name : DIV32
 24023                                  ;
 24024                                  ; Inputs:
 24025                                  ;       DX:AX = 32 bit dividend   BX= divisor
 24026                                  ; Function:
 24027                                  ;       Perform 32 bit division:  DX:AX/BX = CX:AX + DX (rem.)
 24028                                  ; Outputs:
 24029                                  ;       CX:AX = quotient , DX= remainder
 24030                                  ; Uses:
 24031                                  ;       All registers except AX,CX,DX preserved.
 24032                                  ;----------------------------------------------------------------------------
 24033                                  ;M039: DIV32 optimized for divisor of 512 (common sector size).
 24034                                  
 24035                                  ; 04/05/2019 - Retro DOS v4.0
 24036                                  ; DOSCODE:7C94h (MSDOS 6.21, MSDOS.SYS)
 24037                                  
 24038                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24039                                  ; DOSCODE:7C5Ah (MSDOS 5.0, MSDOS.SYS) 
 24040                                  
 24041                                  DIV32:
 24042 00003C18 81FB0002                	cmp	bx,512
 24043 00003C1C 7515                    	jne	short div5
 24044                                  
 24045 00003C1E 89D1                    	mov	cx,dx
 24046 00003C20 89C2                    	mov	dx,ax           ; CX:AX = Dividend
 24047 00003C22 81E2FF01                	and	dx,(512-1)      ; DX = Remainder
 24048 00003C26 88E0                    	mov	al,ah
 24049 00003C28 88CC                    	mov	ah,cl
 24050 00003C2A 88E9                    	mov	cl,ch
 24051 00003C2C 30ED                    	xor	ch,ch
 24052 00003C2E D1E9                    	shr	cx,1
 24053 00003C30 D1D8                    	rcr	ax,1
 24054 00003C32 C3                      	retn
 24055                                  div5:	
 24056 00003C33 89C1                    	mov	cx,ax
 24057 00003C35 89D0                    	mov	ax,dx
 24058 00003C37 31D2                    	xor	dx,dx
 24059 00003C39 F7F3                    	div	bx              ; 0:AX/BX
 24060 00003C3B 91                      	xchg	cx,ax
 24061 00003C3C F7F3                    	div	bx              ; DX:AX/BX
 24062 00003C3E C3                      	retn
 24063                                  
 24064                                  ;Break   <SHR32 -- PERFORM 32 BIT SHIFT RIGHT>
 24065                                  ;----------------------------------------------------------------------------
 24066                                  ;
 24067                                  ; Procedure Name : SHR32
 24068                                  ;
 24069                                  ; Inputs:
 24070                                  ;	DX:AX = 32 bit sector number
 24071                                  ; Function:
 24072                                  ;       Perform 32 bit shift right
 24073                                  ; Outputs:
 24074                                  ;	AX = cluster number
 24075                                  ;	ZF = 1 if no error
 24076                                  ;	   = 0 if error (cluster number > 64k)
 24077                                  ; Uses:
 24078                                  ;       DX,CX
 24079                                  ;---------------------------------------------------------------------------
 24080                                  ; M017	- SHR32 rewritten for better performance
 24081                                  ; M039	- Additional optimization
 24082                                  
 24083                                  ; 04/05/2019 - Retro DOS v4.0
 24084                                  ; DOSCODE:7CBBh (MSDOS 6.21, MSDOS.SYS)
 24085                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24086                                  ; DOSCODE:7C81h (MSDOS 5.0, MSDOS.SYS) 
 24087                                  
 24088                                  SHR32:
 24089                                  	;mov	cl,[es:bp+5]
 24090 00003C3F 268A4E05                	mov	cl,[ES:BP+DPB.CLUSTER_SHIFT]
 24091 00003C43 30ED                    	xor	ch,ch	    ;ZF=1
 24092 00003C45 E306                    	jcxz	norota
 24093                                  
 24094                                  rotashft2:
 24095 00003C47 D1EA                    	shr	dx,1	    ;ZF reflects state of DX.
 24096 00003C49 D1D8                    	rcr	ax,1	    ;ZF not affected.
 24097 00003C4B E2FA                    	loop	rotashft2
 24098                                  norota:
 24099 00003C4D C3                      	retn
 24100                                  
 24101                                  ;============================================================================
 24102                                  ; DIR.ASM, MSDOS 6.0, 1991
 24103                                  ;============================================================================
 24104                                  ; 27/07/2018 - Retro DOS v3.0
 24105                                  ; 19/05/2019 - Retro DOS v4.0
 24106                                  
 24107                                  ;	TITLE	DIR - Directory and path cracking
 24108                                  ;	NAME	Dir
 24109                                  
 24110                                  ;Break	<FINDENTRY -- LOOK FOR AN ENTRY>
 24111                                  ;---------------------------------------------------------------------------
 24112                                  ;
 24113                                  ; Procedure Name : FINDENTRY,SEARCH
 24114                                  ;
 24115                                  ; Inputs:
 24116                                  ;	[THISDPB] set
 24117                                  ;	[SECCLUSPOS] = 0
 24118                                  ;	[DIRSEC] = Starting directory sector number
 24119                                  ;	[CLUSNUM] = Next cluster of directory
 24120                                  ;	[CLUSFAC] = Sectors/Cluster
 24121                                  ;	[NAME1] = Name to look for
 24122                                  ; Function:
 24123                                  ;	Find file name in disk directory.
 24124                                  ;	"?" matches any character.
 24125                                  ; Outputs:
 24126                                  ;	Carry set if name not found
 24127                                  ;	ELSE
 24128                                  ;	Zero set if attributes match (always except when creating)
 24129                                  ;	AH = Device ID (bit 7 set if not disk)
 24130                                  ;	[THISDPB] = Base of drive parameters
 24131                                  ;	DS = DOSGROUP
 24132                                  ;	ES = DOSGROUP
 24133                                  ;	[CURBUF+2]:BX = Pointer into directory buffer
 24134                                  ;	[CURBUF+2]:SI = Pointer to First Cluster field in directory entry
 24135                                  ;	[CURBUF] has directory record with match
 24136                                  ;	[NAME1] has file name
 24137                                  ;	[LASTENT] is entry number of the entry
 24138                                  ; All other registers destroyed.
 24139                                  ;----------------------------------------------------------------------------
 24140                                  
 24141                                  ;hkn; called from rename.asm and dir2.asm. DS must be already set up at
 24142                                  ;hkn; this point.
 24143                                  
 24144                                  SEARCH:
 24145                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24146                                  	; DOSCODE:7C90h (MSDOS 5.0, MSDOS.SYS) 
 24147                                  
 24148                                  	; 19/05/2019 - Retro DOS v4.0
 24149                                  	; DOSCODE:7CCA (MSDOS 6.21, MSDOS.SYS)
 24150                                  
 24151                                  	; 27/07/2018 - Retro DOS v3.0
 24152                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 45B3h 
 24153                                  	; 15/03/2018 - Retro DOS v2.0
 24154                                  
 24155                                  	; 24/01/2024
 24156                                  
 24157                                  	;entry	FindEntry
 24158                                  FINDENTRY:
 24159 00003C4E E80B04                  	call	STARTSRCH
 24160 00003C51 A0[6B05]                	MOV	AL,[ATTRIB]
 24161                                  	;and	al,9Eh
 24162 00003C54 24DE                    	AND	AL,~attr_ignore		; Ignore useless bits
 24163                                  	;cmp	al,8
 24164 00003C56 3C08                    	CMP	AL,attr_volume_id	; Looking for vol ID only ?
 24165 00003C58 7503                    	JNZ	short NOTVOLSRCH	; No
 24166 00003C5A E86601                  	CALL	SETROOTSRCH		; Yes force search of root
 24167                                  NOTVOLSRCH:
 24168 00003C5D E8F800                  	CALL	GETENTRY
 24169                                  	;JNC	short SRCH
 24170                                  	;JMP	SETESRET
 24171                                  	; 24/01/2024
 24172 00003C60 723F                    	jc	short SETESRET
 24173                                  
 24174                                  	;entry	Srch
 24175                                  SRCH:
 24176 00003C62 1E                      	PUSH	DS
 24177 00003C63 8E1E[E405]              	MOV	DS,[CURBUF+2]
 24178                                  
 24179                                  ;	(DS:BX) = directory entry address
 24180                                  
 24181 00003C67 8A27                    	mov	ah,[BX]
 24182                                  	;MOV	AH,[BX+dir_entry.dir_name] ; mov ah,[bx+0]
 24183 00003C69 08E4                    	OR	AH,AH			; End of directory?
 24184 00003C6B 7437                    	JZ	short FREE
 24185                                  
 24186                                  ;hkn; SS override
 24187 00003C6D 363A26[7F05]            	CMP	AH,[SS:DELALL]		; Free entry?
 24188 00003C72 7430                    	JZ	short FREE
 24189                                  	;test	byte [bx+0Bh],8
 24190 00003C74 F6470B08                	TEST	byte [BX+dir_entry.dir_attr],attr_volume_id
 24191                                  					; Volume ID file?
 24192 00003C78 7405                    	JZ	short CHKFNAM 		; NO
 24193                                  
 24194                                  ;hkn; SS override
 24195 00003C7A 36FE06[7B05]            	INC	BYTE [SS:VOLID]
 24196                                  CHKFNAM:
 24197                                  ;	Context ES
 24198 00003C7F 8CD6                    	MOV	SI,SS
 24199 00003C81 8EC6                    	MOV	ES,SI
 24200 00003C83 89DE                    	MOV	SI,BX
 24201                                  
 24202                                  ;hkn; NAME1 is in DOSDATA
 24203 00003C85 BF[4B05]                	MOV	DI,NAME1
 24204                                  ;;;;; 7/29/86
 24205                                  
 24206                                  ;hkn; SS override for NAME1
 24207                                  	;CMP	BYTE [SS:NAME1],0E5H	; special char check
 24208                                  	;JNZ	short NO_E5
 24209                                  	;MOV	BYTE [SS:NAME1],05H
 24210                                  	; 22/09/2023
 24211 00003C88 26803DE5                	cmp	byte [es:di],0E5h
 24212 00003C8C 7504                    	jnz	short NO_E5
 24213 00003C8E 26C60505                	mov	byte [es:di],05h
 24214                                  NO_E5:
 24215                                  ;;;;; 7/29/86
 24216 00003C92 E86100                  	CALL	MetaCompare
 24217 00003C95 7429                    	JZ	short FOUND
 24218 00003C97 1F                      	POP	DS
 24219                                  
 24220                                  	;entry	NEXTENT
 24221                                  NEXTENT:
 24222 00003C98 C42E[8A05]              	LES	BP,[THISDPB]
 24223 00003C9C E86600                  	CALL	NEXTENTRY
 24224 00003C9F 73C1                    	JNC	short SRCH
 24225                                  	;JMP	SHORT SETESRET
 24226                                  	; 24/01/2024
 24227                                  SETESRET:
 24228 00003CA1 16                      	PUSH	SS
 24229 00003CA2 07                      	POP	ES
 24230 00003CA3 C3                      	retn
 24231                                  FREE:
 24232 00003CA4 1F                      	POP	DS
 24233 00003CA5 8B0E[4803]              	MOV	CX,[LASTENT]
 24234 00003CA9 3B0E[D805]              	CMP	CX,[ENTFREE]
 24235 00003CAD 7304                    	JAE	short TSTALL
 24236 00003CAF 890E[D805]              	MOV	[ENTFREE],CX
 24237                                  TSTALL:
 24238 00003CB3 3A26[7F05]              	CMP	AH,[DELALL]		; At end of directory?
 24239                                  NEXTENTJ:
 24240 00003CB7 74DF                    	je	short NEXTENT 		; No - continue search
 24241 00003CB9 890E[DA05]              	MOV	[ENTLAST],CX
 24242 00003CBD F9                      	STC
 24243 00003CBE EBE1                    	JMP	SHORT SETESRET
 24244                                  
 24245                                  FOUND:
 24246                                  ; We have a file with a matching name. We must now consider the attributes:
 24247                                  ; ATTRIB	Action
 24248                                  ; ------	------
 24249                                  ; Volume_ID	Is Volume_ID in test?
 24250                                  ; Otherwise	If no create then Is ATTRIB+extra superset of test?
 24251                                  ;		If create then Is ATTRIB equal to test?
 24252                                  
 24253 00003CC0 8A2C                    	MOV	CH,[SI] 		; Attributes of file
 24254 00003CC2 1F                      	POP	DS
 24255 00003CC3 8A26[6B05]              	MOV	AH,[ATTRIB]		; Attributes of search
 24256                                  	;and	ah,9Eh
 24257 00003CC7 80E4DE                  	AND	AH,~attr_ignore
 24258                                  	;lea	si,[si+15]
 24259 00003CCA 8D740F                  	LEA	SI,[SI+dir_entry.dir_first-dir_entry.dir_attr]
 24260                                  					; point to first cluster field
 24261                                  	;test	ch,8
 24262 00003CCD F6C508                  	TEST	CH,attr_volume_id	; Volume ID file?
 24263 00003CD0 7409                    	JZ	short check_one_volume_id ; Nope check other attributes
 24264                                  	;test	ah,8
 24265 00003CD2 F6C408                  	TEST	AH,attr_volume_id	; Can we find Volume ID?
 24266                                  	;JZ	short NEXTENTJ		; Nope, (not even $FCB_CREATE)
 24267                                  	; 16/12/2022
 24268 00003CD5 74C1                    	jz	short NEXTENT ; 19/05/2019
 24269                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24270                                  	;JZ	short NEXTENTJ
 24271 00003CD7 30E4                    	XOR	AH,AH			; Set zero flag for $FCB_CREATE
 24272 00003CD9 EB11                    	JMP	SHORT RETFF		; Found Volume ID
 24273                                  check_one_volume_id:
 24274                                  	;CMP	ah,8
 24275 00003CDB 80FC08                  	CMP	AH,attr_volume_id	; Looking only for Volume ID?
 24276                                  	;JZ	short NEXTENTJ		; Yes, continue search
 24277                                  	; 16/12/2022
 24278 00003CDE 74B8                    	je	short NEXTENT ; 19/05/2019
 24279                                  	;JZ	short NEXTENTJ
 24280 00003CE0 E88D03                  	CALL	MatchAttributes
 24281 00003CE3 7407                    	JZ	SHORT RETFF
 24282 00003CE5 F606[7E05]FF            	TEST	BYTE [CREATING],-1	; Pass back mismatch if creating
 24283                                  	; 16/12/2022
 24284                                  	;JZ	short NEXTENTJ		; Otherwise continue searching
 24285 00003CEA 74AC                    	jz	short NEXTENT ; 19/05/2019
 24286                                  RETFF:
 24287 00003CEC C42E[8A05]              	LES	BP,[THISDPB]
 24288                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24289                                  	;MOV	AH,[ES:BP+DPB.DRIVE]  ; mov ah,[es:bp+0]
 24290                                  	; 15/12/2022
 24291 00003CF0 268A6600                	MOV	AH,[ES:BP]
 24292                                  ;SETESRET:
 24293                                  	;PUSH	SS
 24294                                  	;POP	ES
 24295                                  	;retn
 24296                                  	; 24/01/2024
 24297 00003CF4 EBAB                    	jmp	short SETESRET
 24298                                  
 24299                                  ;----------------------------------------------------------------------------
 24300                                  ;
 24301                                  ; Procedure Name : MetaCompare
 24302                                  ;
 24303                                  ; Inputs:
 24304                                  ;	DS:SI -> 11 character FCB style name NO '?'
 24305                                  ;	    Typically this is a directory entry. It MUST be in upper case
 24306                                  ;	ES:DI -> 11 character FCB style name with possible '?'
 24307                                  ;	    Typically this is a FCB or SFT. It MUST be in upper case
 24308                                  ; Function:
 24309                                  ;	Compare FCB style names allowing for ? match to any char
 24310                                  ; Outputs:
 24311                                  ;	Zero if match else NZ
 24312                                  ; Destroys CX,SI,DI all others preserved
 24313                                  ;----------------------------------------------------------------------------
 24314                                  
 24315                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24316                                  	; DOSCODE:7D3Fh (MSDOS 5.0, MSDOS.SYS) 
 24317                                  
 24318                                  MetaCompare:
 24319 00003CF6 B90B00                  	MOV	CX,11
 24320                                  WILDCRD:
 24321 00003CF9 F3A6                    	REPE	CMPSB
 24322 00003CFB 7407                    	JZ	short MetaRet 		; most of the time we will fail.
 24323                                  CHECK_META:
 24324 00003CFD 26807DFF3F              	CMP	BYTE [ES:DI-1],"?"
 24325 00003D02 74F5                    	JZ	short WILDCRD
 24326                                  MetaRet:
 24327 00003D04 C3                       	retn				; Zero set, Match
 24328                                  
 24329                                  ;Break	<NEXTENTRY -- STEP THROUGH DIRECTORY>
 24330                                  ;----------------------------------------------------------------------------
 24331                                  ;
 24332                                  ; Procedure Name : NEXTENTRY
 24333                                  ;
 24334                                  ; Inputs:
 24335                                  ;	Same as outputs of GETENTRY, above
 24336                                  ; Function:
 24337                                  ;	Update BX, and [LASTENT] for next directory entry.
 24338                                  ;	Carry set if no more.
 24339                                  ;----------------------------------------------------------------------------
 24340                                  
 24341                                  NEXTENTRY:
 24342                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24343                                  	; DOSCODE:7D4Eh (MSDOS 5.0, MSDOS.SYS) 
 24344                                  
 24345                                  	; 19/05/2019 - Retro DOS v4.0
 24346                                  	; DOSCODE:7D88h (MSDOS 6.21, MSDOS.SYS)
 24347                                  
 24348                                  	; 27/07/2018 - Retro DOS v3.0
 24349                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 4671h 
 24350                                  	; 15/03/2018 - Retro DOS v2.0
 24351                                  
 24352 00003D05 A1[4803]                	MOV	AX,[LASTENT]
 24353 00003D08 3B06[DA05]              	CMP	AX,[ENTLAST]
 24354 00003D0C 7422                    	JZ	short NONE
 24355 00003D0E 40                      	INC	AX
 24356                                  	;ADD	BX,32
 24357 00003D0F 8D5F20                  	LEA	BX,[BX+32]
 24358 00003D12 39D3                    	CMP	BX,DX
 24359                                  	; 21/11/2022 - MSDOS 5.0 MSDOS.SYS (DOSCODE:7D5Dh)
 24360                                  	;JB	short HAVIT ; MSDOS 6.0 src (dir.asm)
 24361                                  	; 16/12/2022
 24362 00003D14 751C                    	jne	short HAVIT ; MSDOS 6.21 (DOSCODE:7D97h)
 24363 00003D16 8A1E[7305]              	MOV	BL,[SECCLUSPOS]
 24364 00003D1A FEC3                    	INC	BL
 24365 00003D1C 3A1E[7705]              	CMP	BL,[CLUSFAC]
 24366 00003D20 7215                    	JB	short SAMECLUS
 24367 00003D22 8B1E[DC05]              	MOV	BX,[NXTCLUSNUM]
 24368 00003D26 E86D16                  	call	IsEOF
 24369 00003D29 7305                    	JAE	short NONE
 24370                                  	; 23/07/2019
 24371 00003D2B 83FB02                  	CMP	BX,2
 24372                                  	;JB	short NONE
 24373                                  	;JMP	short GETENT
 24374                                  	; 16/12/2022
 24375 00003D2E 732B                    	jnb	short GETENT
 24376                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24377                                  	;JB	short NONE
 24378                                  	;JMP	short GETENT
 24379                                  NONE:
 24380 00003D30 F9                      	STC
 24381 00003D31 C3                      	retn
 24382                                  HAVIT:
 24383 00003D32 A3[4803]                	MOV	[LASTENT],AX
 24384 00003D35 F8                      	CLC
 24385                                  nextentry_retn:
 24386 00003D36 C3                      	retn
 24387                                  
 24388                                  SAMECLUS:
 24389 00003D37 881E[7305]              	MOV	[SECCLUSPOS],BL
 24390 00003D3B A3[4803]                	MOV	[LASTENT],AX
 24391 00003D3E 1E                      	PUSH	DS
 24392 00003D3F C53E[E205]              	LDS	DI,[CURBUF]
 24393                                  	; 19/05/2019
 24394                                  	; MSDOS 6.0
 24395                                  	;;mov	dx,[di+8]
 24396                                  	; 23/09/2023
 24397                                  	;MOV	DX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 24398                                  ;hkn; SS override
 24399                                  	;MOV	[SS:HIGH_SECTOR],DX 		;AN000; >32mb
 24400                                  
 24401                                  ; 14/02/2024
 24402                                  %if 0
 24403                                  	; 23/09/2023
 24404                                  	mov	si,[di+BUFFINFO.buf_sector+2]
 24405                                  	
 24406                                  	;mov	dx,[di+6]
 24407                                  	MOV	DX,[DI+BUFFINFO.buf_sector]	;AN000; >32mb
 24408                                  
 24409                                  	;inc	dx ; MSDOS 3.3
 24410                                  	; MSDOS 6.0
 24411                                  	;ADD	DX,1				;AN000; >32mb
 24412                                  	;ADC	word [SS:HIGH_SECTOR],0 	;AN000; >32mb
 24413                                  	; 23/09/2023
 24414                                  	inc	dx
 24415                                  	jnz	short nextexntry_fc
 24416                                  	inc	si
 24417                                  	;inc	word [SS:HIGH_SECTOR]
 24418                                  nextexntry_fc:
 24419                                  	; 23/09/2023
 24420                                  	mov	[SS:HIGH_SECTOR],si
 24421                                  	; MSDOS 3.3 & MSDOS 6.0
 24422                                  	POP	DS
 24423                                  %else
 24424                                  	; 14/02/2024 - Retro DOS v4.2
 24425 00003D43 C55506                  	lds	dx,[di+BUFFINFO.buf_sector]
 24426 00003D46 8CDE                    	mov	si,ds
 24427 00003D48 1F                      	pop	ds
 24428 00003D49 42                      	inc	dx
 24429 00003D4A 7501                    	jnz	short nextexntry_fc
 24430 00003D4C 46                      	inc	si
 24431                                  nextexntry_fc:
 24432 00003D4D 8936[0706]              	mov	[HIGH_SECTOR],si
 24433                                  %endif
 24434                                  
 24435 00003D51 E868F8                  	call	FIRSTCLUSTER
 24436 00003D54 31DB                    	XOR	BX,BX
 24437 00003D56 EB21                    	JMP	short SETENTRY
 24438                                  
 24439                                  ;----------------------------------------------------------------------------
 24440                                  ;
 24441                                  ; Procedure Name : GETENTRY
 24442                                  ;
 24443                                  ; Inputs:
 24444                                  ;	[LASTENT] has directory entry
 24445                                  ;	ES:BP points to drive parameters
 24446                                  ;	[DIRSEC],[CLUSNUM],[CLUSFAC],[ENTLAST] set for DIR involved
 24447                                  ; Function:
 24448                                  ;	Locates directory entry in preparation for search
 24449                                  ;	GETENT provides entry for passing desired entry in AX
 24450                                  ; Outputs:
 24451                                  ;	[CURBUF+2]:BX = Pointer to next directory entry in CURBUF
 24452                                  ;	[CURBUF+2]:DX = Pointer to first byte after end of CURBUF
 24453                                  ;	[LASTENT] = New directory entry number
 24454                                  ;	[NXTCLUSNUM],[SECCLUSPOS] set via DIRREAD
 24455                                  ;	Carry set if error (currently user FAILed to I 24)
 24456                                  ;----------------------------------------------------------------------------
 24457                                  
 24458                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24459                                  GETENTRY:
 24460                                  	; 27/07/2018 - Retro DOS v3.0
 24461 00003D58 A1[4803]                	MOV	AX,[LASTENT]
 24462                                  
 24463                                  	;entry	GETENT
 24464                                  GETENT:
 24465 00003D5B A3[4803]                	MOV	[LASTENT],AX
 24466                                  ;
 24467                                  ; Convert the entry number in AX into a byte offset from the beginning of the
 24468                                  ; directory.
 24469                                  ;
 24470 00003D5E B105                    	mov	cl,5			; shift left by 5 = mult by 32
 24471 00003D60 D3C0                    	rol	ax,cl			; keep hight order bits
 24472 00003D62 89C2                    	mov	dx,ax
 24473                                  	; 19/05/2019 - Retro DOS v4.0
 24474                                  	;and	ax,0FFE0h
 24475                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24476                                  	;and	ax,~(32-1)		; mask off high order bits
 24477                                  	; 16/12/2022
 24478 00003D64 24E0                    	and	al,0E0h ; ~31
 24479 00003D66 83E21F                  	and	dx,1Fh
 24480                                  	;and	dx,32-1			; mask off low order bits
 24481                                  ;
 24482                                  ; DX:AX contain the byte offset of the required directory entry from the
 24483                                  ; beginning of the directory. Convert this to a sector number. Round the
 24484                                  ; sector size down to a multiple of 32.
 24485                                  ;
 24486                                  	;mov	bx,[es:bp+2]
 24487 00003D69 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 24488 00003D6D 80E3E0                  	and	bl,0E0h
 24489                                  	;AND	BL,255-31		; Must be multiple of 32
 24490 00003D70 F7F3                    	DIV	BX
 24491                                  	; 14/02/2024
 24492                                  	;MOV	BX,DX			; Position within sector
 24493                                  				; NOTE: This BX value is not used in DIRREAD
 24494                                  				; Erdogan Tan - 14/02/2024
 24495                                  	;PUSH	BX
 24496 00003D72 52                      	push	dx
 24497                                  	;
 24498 00003D73 E8F2F7                  	call	DIRREAD
 24499 00003D76 5B                      	POP	BX
 24500                                  	;retc
 24501 00003D77 72BD                    	jc	short nextentry_retn
 24502                                  SETENTRY:
 24503 00003D79 8B16[E205]              	MOV	DX,[CURBUF]
 24504                                  	;add	dx,16 ; MSDOS 3.3
 24505                                  	;add	dx,20 ; MSDOS 6.0 
 24506 00003D7D 83C214                  	ADD	DX,BUFINSIZ
 24507 00003D80 01D3                    	ADD	BX,DX
 24508                                  	;add	dx,[es:bp+2]
 24509 00003D82 26035602                	ADD	DX,[ES:BP+DPB.SECTOR_SIZE]  ; Always clears carry
 24510                                  	; 29/12/2022
 24511                                  	; MSDOS 6.21 MSDOS.SYS contains a 'CLC' here, at DOSCODE:7E15h
 24512 00003D86 F8                      	clc
 24513 00003D87 C3                      	retn
 24514                                  
 24515                                  ;Break	<SETDIRSRCH SETROOTSRCH -- Set Search environments>
 24516                                  ;----------------------------------------------------------------------------
 24517                                  ;
 24518                                  ; Procedure Name : SETDIRSRCH,SETROOTSRCH
 24519                                  ;
 24520                                  ; Inputs:
 24521                                  ;	BX cluster number of start of directory
 24522                                  ;	ES:BP Points to DPB
 24523                                  ;	DI next cluster number from fastopen extended info. DOS 3.3 only
 24524                                  ; Function:
 24525                                  ;	Set up a directory search
 24526                                  ; Outputs:
 24527                                  ;	[DIRSTART] = BX
 24528                                  ;	[CLUSFAC],[CLUSNUM],[SECCLUSPOS],[DIRSEC] set
 24529                                  ;	Carry set if error (currently user FAILed to I 24)
 24530                                  ; destroys AX,DX,BX
 24531                                  ;----------------------------------------------------------------------------
 24532                                  
 24533                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24534                                  SETDIRSRCH:
 24535 00003D88 09DB                    	OR	BX,BX
 24536 00003D8A 7437                    	JZ	short SETROOTSRCH
 24537 00003D8C 891E[C205]              	MOV	[DIRSTART],BX
 24538                                  	;mov	al,[es:bp+4]
 24539 00003D90 268A4604                	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
 24540 00003D94 FEC0                    	INC	AL
 24541 00003D96 A2[7705]                	MOV	[CLUSFAC],AL
 24542                                  
 24543                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 24544                                  	;SAVE	<SI>
 24545 00003D99 56                      	push	si
 24546                                  	;test	byte [FastOpenFlg],2
 24547 00003D9A F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success
 24548 00003D9F 7507                    	JNZ	short UNP_OK
 24549                                  
 24550                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 24551                                  	;invoke	UNPACK
 24552 00003DA1 E80916                  	call	UNPACK
 24553 00003DA4 7302                    	JNC	short UNP_OK
 24554                                  	;RESTORE <SI>
 24555 00003DA6 5E                      	pop	si
 24556                                  	;return
 24557 00003DA7 C3                      	retn
 24558                                  
 24559                                  UNP_OK:
 24560 00003DA8 893E[BC05]              	MOV	[CLUSNUM],DI
 24561 00003DAC 89DA                    	MOV	DX,BX
 24562 00003DAE 30DB                    	XOR	BL,BL
 24563 00003DB0 881E[7305]              	MOV	[SECCLUSPOS],BL
 24564                                  	;invoke	FIGREC
 24565 00003DB4 E8B60E                  	call	FIGREC
 24566                                  	;RESTORE <SI>
 24567 00003DB7 5E                      	pop	si
 24568                                  	
 24569                                  	; 19/05/2019 - Retro DOS v4.0
 24570                                  
 24571                                  	; MSDOS 6.0
 24572                                  	;PUSH	DX			   ;AN000; >32mb
 24573                                  	;MOV	DX,[HIGH_SECTOR]	   ;AN000; >32mb
 24574                                  	;MOV	[DIRSEC+2],DX		   ;AN000; >32mb
 24575                                  	;POP	DX			   ;AN000; >32mb
 24576                                  
 24577                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24578                                  	;push	dx
 24579                                  	;mov	dx,[HIGH_SECTOR]
 24580                                  	;mov	[DIRSEC+2],dx
 24581                                  	;pop	dx
 24582                                  	;MOV	[DIRSEC],dx
 24583                                  	; 16/12/2022
 24584 00003DB8 A1[0706]                	mov	ax,[HIGH_SECTOR]
 24585 00003DBB A3[C005]                	mov	[DIRSEC+2],AX
 24586 00003DBE 8916[BE05]              	MOV	[DIRSEC],DX
 24587                                  
 24588                                  	; 16/12/2022
 24589                                  	; cf=0 (at the return of FIGREC)
 24590                                  	;CLC
 24591 00003DC2 C3                      	retn
 24592                                  
 24593                                  	;entry	SETROOTSRCH
 24594                                  SETROOTSRCH:
 24595 00003DC3 31C0                    	XOR	AX,AX
 24596 00003DC5 A3[C205]                	MOV	[DIRSTART],AX
 24597                                  	; 22/09/2023
 24598 00003DC8 A3[C005]                	mov	[DIRSEC+2],ax ; 0
 24599 00003DCB A2[7305]                	MOV	[SECCLUSPOS],AL
 24600 00003DCE 48                      	DEC	AX
 24601 00003DCF A3[BC05]                	MOV	[CLUSNUM],AX
 24602                                  	;mov	ax,[es:bp+0Bh]
 24603 00003DD2 268B460B                	MOV	AX,[ES:BP+DPB.FIRST_SECTOR]
 24604                                  	; 19/05/2019
 24605                                  	;;mov	dx,[es:bp+10h] ; MSDOS 3.3
 24606                                  	;mov	dx,[es:bp+11h] ; MSDOS 6.0
 24607 00003DD6 268B5611                	MOV	DX,[ES:BP+DPB.DIR_SECTOR]
 24608 00003DDA 29D0                    	SUB	AX,DX
 24609 00003DDC A2[7705]                	MOV	[CLUSFAC],AL
 24610 00003DDF 8916[BE05]              	MOV	[DIRSEC],DX		      ;F.C. >32mb
 24611                                  	; 22/09/2023
 24612                                  	; MSDOS 6.0
 24613                                  	;MOV	WORD [DIRSEC+2],0	      ;F.C. >32mb
 24614 00003DE3 F8                      	CLC
 24615 00003DE4 C3                      	retn
 24616                                  
 24617                                  ;============================================================================
 24618                                  ; DIR2.ASM, MSDOS 6.0, 1991
 24619                                  ;============================================================================
 24620                                  ; 27/07/2018 - Retro DOS v3.0
 24621                                  ; 19/05/2019 - Retro DOS v4.0 
 24622                                  
 24623                                  ;	TITLE	DIR2 - Directory and path cracking
 24624                                  ;	NAME	Dir2
 24625                                  
 24626                                  ;Break	<GETPATH -- PARSE A WFP>
 24627                                  ;----------------------------------------------------------------------------
 24628                                  ;
 24629                                  ; Procedure Name : GETPATH
 24630                                  ;
 24631                                  ; Inputs:
 24632                                  ;	[WFP_START] Points to WFP string ("d:\" must be first 3 chars, NUL
 24633                                  ;		terminated; d:/ (note forward slash) indicates a real device).
 24634                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 24635                                  ;		( = -1 if current dir not involved, else
 24636                                  ;		 Points to first char after last "/" of current dir part)
 24637                                  ;	[THISCDS] Points to CDS being used
 24638                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 24639                                  ;	[NoSetDir] set
 24640                                  ;	[THISDPB] set to DPB if disk otherwise garbage.
 24641                                  ; Function:
 24642                                  ;	Crack the path
 24643                                  ; Outputs:
 24644                                  ;	Sets EXTERR_LOCUS = errLOC_Disk if disk file
 24645                                  ;	Sets EXTERR_LOCUS = errLOC_Unk if char device
 24646                                  ;	ID1 field of [THISCDS] updated appropriately
 24647                                  ;	[ATTRIB] = [SATTRIB]
 24648                                  ;	ES:BP Points to DPB
 24649                                  ;	Carry set if bad path
 24650                                  ;	   SI Points to path element causing failure
 24651                                  ;	   Zero set
 24652                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 24653                                  ;	      start a search on the last directory
 24654                                  ;	      CL is zero if there is a bad name in the path
 24655                                  ;	      CL is non-zero if the name was simply not found
 24656                                  ;		 [ENTFREE] may have free spot in directory
 24657                                  ;		 [NAME1] is the name.
 24658                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 24659                                  ;	   Zero reset
 24660                                  ;	      File in middle of path or bad name in path or attribute mismatch
 24661                                  ;		or path too long or malformed path
 24662                                  ;	ELSE
 24663                                  ;	   [CurBuf] = -1 if root directory
 24664                                  ;	   [CURBUF] contains directory record with match
 24665                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 24666                                  ;	   [CURBUF+2]:SI Points into [CURBUF] to dir_first field for entry
 24667                                  ;	   AH = device ID
 24668                                  ;	      bit 7 of AH set if device SI and BX
 24669                                  ;	      will point DOSGROUP relative The firclus
 24670                                  ;	      field of the device entry contains the device pointer
 24671                                  ;	   [NAME1] Has name looked for
 24672                                  ;	   If last element is a directory zero is set and:
 24673                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 24674                                  ;	      are set up to start a search on it.
 24675                                  ;	      unless [NoSetDir] is non zero in which case the return is
 24676                                  ;	      like that for a file (except for zero flag)
 24677                                  ;	   If last element is a file zero is reset
 24678                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 24679                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 24680                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 24681                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 24682                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 24683                                  ; DS preserved, Others destroyed
 24684                                  ;---------------------------------------------------------------------------
 24685                                  
 24686                                  ;hkn; called from delete.asm, finfo.asm, mknode.asm and rename.asm.
 24687                                  ;hkn; DS already set up at this point.
 24688                                  
 24689                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24690                                  GETPATH:
 24691                                  	;mov	word [CREATING],0E500h
 24692 00003DE5 C706[7E05]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Not Creating, not DEL *.*
 24693                                  
 24694                                  ; Same as GetPath only CREATING and DELALL already set
 24695                                  
 24696                                  	;entry	GetPathNoSet
 24697                                  GetPathNoSet:
 24698                                  	;mov	byte [EXTERR_LOCUS],2	
 24699 00003DEB C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 24700 00003DF0 C706[E205]FFFF          	MOV	word [CURBUF],-1	; initial setting
 24701                                  
 24702                                  ; See if the input indicates a device that has already been detected. If so,
 24703                                  ; go build the guy quickly. Otherwise, let findpath find the device.
 24704                                  
 24705 00003DF6 8B3E[B205]              	MOV	DI,[WFP_START]		; point to the beginning of the name
 24706                                  	;cmp	word [DI+1],5C3Ah
 24707                                  	;CMP	WORD [DI+1],'\' << 8 + ':'
 24708 00003DFA 817D013A5C              	cmp	word [DI+1],':\'
 24709 00003DFF 7437                    	JZ	short CrackIt
 24710                                  
 24711                                  ; Let ChkDev find it in the device list
 24712                                  
 24713 00003E01 83C703                  	ADD	DI,3
 24714                                  	; 18/08/2018
 24715                                  	;MOV	SI,DI			; let CHKDEV see the original name
 24716                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24717                                  	; 16/12/2022
 24718                                  	;mov	si,di ; not required ! (it is written in CHKDEV proc already!)
 24719 00003E04 E89E00                  	CALL	CHKDEV
 24720 00003E07 722D                    	JC	short InternalError
 24721                                  
 24722                                  Build_devJ:
 24723 00003E09 A0[6D05]                	MOV	AL,[SATTRIB]
 24724 00003E0C A2[6B05]                	MOV	[ATTRIB],AL
 24725                                  	;mov	byte [EXTERR_LOCUS],1
 24726 00003E0F C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; In the particular case of
 24727                                  					; "finding" a char device
 24728                                  					; set LOCUS to Unknown. This makes
 24729                                  					; certain idiotic problems reported
 24730                                  					; by a certain 3 letter OEM go away.
 24731                                  
 24732                                  ; Take name in name1 and pack it back into where wfp_start points. This
 24733                                  ; guarantees wfp_start pointing to a canonical representation of a device.
 24734                                  ; We are allowed to do this as GetPath is *ALWAYS* called before entering a
 24735                                  ; wfp into the share set.
 24736                                  ;
 24737                                  ; We copy chars from name1 to wfp_start remembering the position of the last
 24738                                  ; non-space seen +1.  This position is kept in DX.
 24739                                  
 24740                                  ;hkn; SS is DOSDATA
 24741 00003E14 16                      	push	ss
 24742 00003E15 07                      	pop	es
 24743                                  
 24744                                  ;hkn; NAME1 is in DOSDATA
 24745 00003E16 BE[4B05]                	mov	si,NAME1
 24746 00003E19 8B3E[B205]              	mov	di,[WFP_START]
 24747 00003E1D 89FA                    	mov	dx,di
 24748 00003E1F B90800                  	mov	cx,8			; 8 chars in device name
 24749                                  MoveLoop:
 24750 00003E22 AC                      	lodsb
 24751 00003E23 AA                      	stosb
 24752 00003E24 3C20                    	cmp	al," "
 24753 00003E26 7402                    	jz	short NoSave
 24754                                  
 24755 00003E28 89FA                    	mov	dx,di
 24756                                  NoSave:
 24757 00003E2A E2F6                    	loop	MoveLoop
 24758                                  
 24759                                  ; DX is the position of the last seen non-space + 1. We terminate the name
 24760                                  ; at this point.
 24761                                  
 24762 00003E2C 89D7                    	mov	di,dx
 24763                                  	;mov	byte [di],0		; end of string
 24764                                  	; 15/02/2024
 24765 00003E2E 880D                    	mov	[di],cl ; 0
 24766 00003E30 E8A802                  	call	Build_device_ent	; Clears carry sets zero
 24767 00003E33 FEC0                    	INC	AL			; reset zero
 24768 00003E35 C3                      	retn
 24769                                  
 24770                                  InternalError:
 24771                                  InternalError_loop:
 24772 00003E36 EBFE                    	JMP	short InternalError_loop ; freeze
 24773                                  
 24774                                  ; Start off at the correct spot. Optimize if the current dir part is valid.
 24775                                  
 24776                                  CrackIt:
 24777                                  ; 15/02/2024
 24778                                  %if 0
 24779                                  	MOV	SI,[CURR_DIR_END]	; get current directory pointer
 24780                                  	CMP	SI,-1			; valid?
 24781                                  	JNZ	short LOOK_SING		; Yes, use it.
 24782                                  	LEA	SI,[DI+3]		; skip D:\.
 24783                                  LOOK_SING:
 24784                                  %endif
 24785                                  	;mov	byte [ATTRIB],16h
 24786 00003E38 C606[6B05]16            	MOV	byte [ATTRIB],attr_directory+attr_system+attr_hidden
 24787                                  					; Attributes to search through Dirs
 24788 00003E3D C43E[A205]              	LES	DI,[THISCDS]
 24789 00003E41 B8FFFF                  	MOV	AX,-1
 24790                                  	;mov	bx,[es:di+73]
 24791 00003E44 268B5D49                	MOV	BX,[ES:DI+curdir.ID]
 24792 00003E48 8B36[B605]              	MOV	SI,[CURR_DIR_END]
 24793                                  
 24794                                  ; AX = -1
 24795                                  ; BX = cluster number of current directory. THis number is -1 if the media
 24796                                  ;      has been uncertainly changed.
 24797                                  ; SI = offset in DOSGroup into path to end of current directory text. This
 24798                                  ;      may be -1 if no current directory part has been used.
 24799                                  
 24800 00003E4C 39C6                    	CMP	SI,AX			; if Current directory is not part
 24801 00003E4E 743B                    	JZ	short NO_CURR_D		; then we must crack from root
 24802 00003E50 39C3                    	CMP	BX,AX			; is the current directory cluster valid
 24803                                  
 24804                                  ; DOS 3.3  6/25/86
 24805 00003E52 7437                    	JZ	short NO_CURR_D		; no, crack from the root
 24806                                  	;test	byte [FastOpenFlg],1
 24807 00003E54 F606[3A0D]01            	TEST	byte [FastOpenFlg],FastOpen_Set ; for fastopen ?
 24808 00003E59 743D                    	JZ	short GOT_SEARCH_CLUSTER	; no
 24809 00003E5B 06                      	PUSH	ES			; save registers
 24810 00003E5C 57                      	PUSH	DI
 24811 00003E5D 51                      	PUSH	CX
 24812 00003E5E FF74FF                  	PUSH	word [SI-1]		; save \ and 1st char of next element
 24813 00003E61 56                      	PUSH	SI
 24814 00003E62 53                      	PUSH	BX
 24815                                  
 24816 00003E63 C644FF00                	MOV	BYTE [SI-1],0		; call fastopen to look up cur dir info
 24817 00003E67 8B36[B205]              	MOV	SI,[WFP_START]
 24818                                  
 24819                                  ;hkn; FastOpenTable, Dir_Info_Buff & FastOpen_Ext_Info are in DOSDATA
 24820 00003E6B BB[300D]                	MOV	BX,FastOpenTable
 24821 00003E6E BF[460D]                	MOV	DI,Dir_Info_Buff
 24822 00003E71 B9[3B0D]                	MOV	CX,FastOpen_Ext_Info
 24823                                  	;mov	al,1
 24824 00003E74 B001                    	MOV	AL,FONC_Look_up
 24825 00003E76 1E                      	PUSH	DS
 24826 00003E77 07                      	POP	ES
 24827                                  	;call	far [BX+2]
 24828 00003E78 FF5F02                  	CALL	far [BX+fastopen_entry.name_caching]
 24829 00003E7B 7203                    	JC	short GO_Chk_end1 	;fastopen not installed, or wrong drive.
 24830                                  					; Go to Got_Srch_cluster
 24831                                  	; 29/12/2022
 24832                                  	;CMP	BYTE [SI],0		;fastopen has current dir info?
 24833                                  	;JE	short GO_Chk_end	;yes. Go to got_search_cluster
 24834                                  	;stc
 24835                                  	;jmp	short GO_Chk_end	;Go to No_Curr_D
 24836                                  
 24837 00003E7D 803C01                  	cmp	byte [si],1
 24838                                  GO_Chk_end1:	; 29/12/2022
 24839 00003E80 F5                      	cmc 
 24840                                  	; [si] = 0 -> cf = 0
 24841                                  	; [si] > 0 -> cf = 1
 24842                                  
 24843                                  ;GO_Chk_end1:
 24844                                  	; 29/12/2022
 24845                                  	;clc
 24846                                  
 24847                                  GO_Chk_end:				; restore registers
 24848 00003E81 5B                      	POP	BX
 24849 00003E82 5E                      	POP	SI
 24850 00003E83 8F44FF                  	POP	word [SI-1]
 24851 00003E86 59                      	POP	CX
 24852 00003E87 5F                      	POP	DI
 24853 00003E88 07                      	POP	ES
 24854 00003E89 730D                    	JNC	short GOT_SEARCH_CLUSTER ; crack based on cur dir
 24855                                  
 24856                                  ; DOS 3.3  6/25/86
 24857                                  ;
 24858                                  ; We must cract the path beginning at the root. Advance pointer to beginning
 24859                                  ; of path and go crack from root.
 24860                                  
 24861                                  NO_CURR_D:
 24862 00003E8B 8B36[B205]              	MOV	SI,[WFP_START]
 24863                                  	;LEA	SI,[SI+3]		; Skip "d:/"
 24864                                  	; 15/02/2024
 24865 00003E8F 83C603                  	add	si,3
 24866 00003E92 C42E[8A05]              	LES	BP,[THISDPB]		; Get ES:BP
 24867 00003E96 EB37                    	JMP	short ROOTPATH
 24868                                  
 24869                                  ; We are able to crack from the current directory part. Go set up for search
 24870                                  ; of specified cluster.
 24871                                  
 24872                                  GOT_SEARCH_CLUSTER:
 24873 00003E98 C42E[8A05]              	LES	BP,[THISDPB]		; Get ES:BP
 24874 00003E9C E8E9FE                  	call	SETDIRSRCH
 24875                                  	;JC	short SETFERR
 24876                                  	;JMP	short FINDPATH
 24877                                  	; 16/12/2022
 24878 00003E9F 733E                    	jnc	short FINDPATH ; 17/08/2018
 24879                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24880                                  	;JC	short SETFERR
 24881                                  	;JMP	short FINDPATH
 24882                                  SETFERR:
 24883 00003EA1 30C9                    	XOR	CL,CL			; set zero
 24884 00003EA3 F9                      	STC
 24885 00003EA4 C3                      	retn
 24886                                  
 24887                                  ;---------------------------------------------------------------------------
 24888                                  ;
 24889                                  ; Procedure Name : ChkDev
 24890                                  ;
 24891                                  ; Check to see if the name at DS:DI is a device. Returns carry set if not a
 24892                                  ;   device.
 24893                                  ; Blasts CX,SI,DI,AX,BX
 24894                                  ;---------------------------------------------------------------------------
 24895                                  
 24896                                  CHKDEV:
 24897 00003EA5 89FE                    	MOV	SI,DI
 24898                                  	;MOV	DI,SS
 24899                                  	;MOV	ES,DI
 24900                                  	; 27/06/2024
 24901 00003EA7 16                      	push	ss
 24902 00003EA8 07                      	pop	es
 24903                                  
 24904 00003EA9 BF[4B05]                	MOV	DI,NAME1
 24905 00003EAC B90900                  	MOV	CX,9
 24906                                  TESTLOOP:
 24907 00003EAF E80A10                  	call	GETLET
 24908                                  
 24909 00003EB2 3C2E                    	CMP	AL,'.'
 24910 00003EB4 740E                    	JZ	short TESTDEVICE
 24911 00003EB6 E85910                  	call	PATHCHRCMP
 24912 00003EB9 7407                    	JZ	short NOTDEV
 24913 00003EBB 08C0                    	OR	AL,AL
 24914 00003EBD 7405                    	JZ	short TESTDEVICE
 24915                                  
 24916 00003EBF AA                      	STOSB
 24917 00003EC0 E2ED                    	LOOP	TESTLOOP
 24918                                  NOTDEV:
 24919 00003EC2 F9                      	STC
 24920 00003EC3 C3                      	retn
 24921                                  
 24922                                  TESTDEVICE:
 24923                                  	;ADD	CX,2
 24924                                  	; 24/09/2023
 24925 00003EC4 41                      	inc	cx
 24926 00003EC5 41                      	inc	cx
 24927 00003EC6 B020                    	MOV	AL,' '
 24928 00003EC8 F3AA                    	REP	STOSB
 24929                                  	;MOV	AX,SS
 24930                                  	;MOV	DS,AX
 24931                                  	; 27/06/2024
 24932 00003ECA 16                      	push	ss
 24933 00003ECB 1F                      	pop	ds
 24934                                  	;call	DEVNAME
 24935                                  	;retn
 24936                                  	; 18/12/2022
 24937 00003ECC E9AE01                  	jmp	DEVNAME
 24938                                  
 24939                                  ;Break	<ROOTPATH, FINDPATH -- PARSE A PATH>
 24940                                  ;----------------------------------------------------------------------------
 24941                                  ;
 24942                                  ; Procedure Name : ROOTPATH,FINDPATH
 24943                                  ;
 24944                                  ; Inputs:
 24945                                  ;	Same as FINDPATH but,
 24946                                  ;	SI Points to asciz string of path which is assumed to start at
 24947                                  ;		the root (no leading '/').
 24948                                  ; Function:
 24949                                  ;	Search from root for path
 24950                                  ; Outputs:
 24951                                  ;	Same as FINDPATH but:
 24952                                  ;	If root directory specified, [CURBUF] and [NAME1] are NOT set, and
 24953                                  ;	[NoSetDir] is ignored.
 24954                                  ;----------------------------------------------------------------------------
 24955                                  
 24956                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24957                                  	; DOSCODE:7F47h (MSDOS 5.0, MSDOS.SYS)
 24958                                  
 24959                                  ROOTPATH:
 24960 00003ECF E8F1FE                  	call	SETROOTSRCH
 24961                                  	; 24/09/2023
 24962 00003ED2 30E4                    	xor	ah,ah
 24963                                  	;CMP	BYTE [SI],0
 24964 00003ED4 3824                    	cmp	[si],ah ; 0
 24965 00003ED6 7507                    	JNZ	short FINDPATH
 24966                                  
 24967                                  ; Root dir specified
 24968 00003ED8 A0[6D05]                	MOV	AL,[SATTRIB]
 24969 00003EDB A2[6B05]                	MOV	[ATTRIB],AL
 24970                                  	; 24/09/2023
 24971                                  	;XOR	AH,AH			; Sets "device ID" byte, sets zero
 24972                                  					; (dir), clears carry.
 24973 00003EDE C3                      	retn
 24974                                  
 24975                                  ; Inputs:
 24976                                  ;	[ATTRIB] Set to get through directories
 24977                                  ;	[SATTRIB] Set to find last element
 24978                                  ;	ES:BP Points to DPB
 24979                                  ;	SI Points to asciz string of path (no leading '/').
 24980                                  ;	[SECCLUSPOS] = 0
 24981                                  ;	[DIRSEC] = Phys sec # of first sector of directory
 24982                                  ;	[CLUSNUM] = Cluster # of next cluster
 24983                                  ;	[CLUSFAC] = Sectors per cluster
 24984                                  ;	[NoSetDir] set
 24985                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 24986                                  ;		( = -1 if current dir not involved, else
 24987                                  ;		 Points to first char after last "/" of current dir part)
 24988                                  ;	[THISCDS] Points to CDS being used
 24989                                  ;	[CREATING] and [DELALL] set
 24990                                  ; Function:
 24991                                  ;	Parse path name
 24992                                  ; Outputs:
 24993                                  ;	ID1 field of [THISCDS] updated appropriately
 24994                                  ;	[ATTRIB] = [SATTRIB]
 24995                                  ;	ES:BP Points to DPB
 24996                                  ;	[THISDPB] = ES:BP
 24997                                  ;	Carry set if bad path
 24998                                  ;	   SI Points to path element causing failure
 24999                                  ;	   Zero set
 25000                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 25001                                  ;	      start a search on the last directory
 25002                                  ;	      CL is zero if there is a bad name in the path
 25003                                  ;	      CL is non-zero if the name was simply not found
 25004                                  ;		 [ENTFREE] may have free spot in directory
 25005                                  ;		 [NAME1] is the name.
 25006                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 25007                                  ;	   Zero reset
 25008                                  ;	      File in middle of path or bad name in path
 25009                                  ;		or path too long or malformed path
 25010                                  ;	ELSE
 25011                                  ;	   [CURBUF] contains directory record with match
 25012                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 25013                                  ;	   [CURBUF+2]:SI Points to fcb_FIRCLUS field for entry
 25014                                  ;	   [NAME1] Has name looked for
 25015                                  ;	   AH = device ID
 25016                                  ;	      bit 7 of AH set if device SI and BX
 25017                                  ;	      will point DOSGROUP relative The firclus
 25018                                  ;	      field of the device entry contains the device pointer
 25019                                  ;	   If last element is a directory zero is set and:
 25020                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 25021                                  ;	      are set up to start a search on it,
 25022                                  ;	      unless [NoSetDir] is non zero in which case the return is
 25023                                  ;	      like that for a file (except for zero flag)
 25024                                  ;	   If last element is a file zero is reset
 25025                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 25026                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 25027                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 25028                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 25029                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 25030                                  ; Destroys all other registers
 25031                                  
 25032                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25033                                  	; DOSCODE:7F58h (MSDOS 5.0, MSDOS.SYS)
 25034                                  
 25035                                  	; 15/02/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
 25036                                  	; DOSCODE:7F93h (MSDOS 6.22, MSDOS.SYS)
 25037                                  
 25038                                      	;entry	FINDPATH
 25039                                  FINDPATH:
 25040 00003EDF 06                      	PUSH	ES			; Save ES:BP
 25041 00003EE0 56                      	PUSH	SI
 25042 00003EE1 89F7                    	MOV	DI,SI
 25043 00003EE3 8B0E[C205]              	MOV	CX,[DIRSTART]		; Get start clus of dir being searched
 25044 00003EE7 833E[B605]FF            	CMP	word [CURR_DIR_END],-1
 25045 00003EEC 740E                    	JZ	short NOIDS		; No current dir part
 25046 00003EEE 3B3E[B605]              	CMP	DI,[CURR_DIR_END]
 25047 00003EF2 7508                    	JNZ	short NOIDS		; Not to current dir end yet
 25048 00003EF4 C43E[A205]              	LES	DI,[THISCDS]
 25049                                  	;mov	[es:di+73],cx
 25050 00003EF8 26894D49                	MOV	[ES:DI+curdir.ID],CX	; Set current directory cluster
 25051                                  NOIDS:
 25052                                  
 25053                                  ; Parse the name off of DS:SI into NAME1. AL = 1 if there was a meta
 25054                                  ; character in the string. CX,DI may be destroyed.
 25055                                  ;
 25056                                  ;	invoke	NAMETRANS
 25057                                  ;	MOV	CL,AL
 25058                                  ;
 25059                                  ; The above is the slow method. The name has *already* been munged by
 25060                                  ; TransPath so no special casing needs to be done. All we do is try to copy
 25061                                  ; the name until ., \ or 0 is hit.
 25062                                  
 25063                                  	;MOV	AX,SS
 25064                                  	;MOV	ES,AX
 25065                                  	; 15/02/2024 - Retro DOS v4.2
 25066 00003EFC 16                      	push	ss
 25067 00003EFD 07                      	pop	es
 25068                                  
 25069                                  ;hkn; Name1 is in DOSDATA
 25070 00003EFE BF[4B05]                	MOV	DI,NAME1
 25071 00003F01 B82020                  	MOV	AX,'  ' ; 2020h
 25072 00003F04 AA                      	STOSB
 25073 00003F05 AB                      	STOSW
 25074 00003F06 AB                      	STOSW
 25075 00003F07 AB                      	STOSW
 25076 00003F08 AB                      	STOSW
 25077 00003F09 AB                      	STOSW
 25078                                  
 25079                                  ;hkn; Name1 is in DOSDATA
 25080 00003F0A BF[4B05]                	MOV	DI,NAME1
 25081 00003F0D 30E4                    	XOR	AH,AH			; bits for CL
 25082                                  GetNam:
 25083                                  	; 19/05/2019 - Retro DOS v4.0
 25084                                  	;INC	CL ; ?*! ; MSDOS 6.0	;AN000; KK increment volid count
 25085                                  
 25086                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25087                                  	; 16/12/2022
 25088                                  	;inc	cl ; not required !
 25089                                  	
 25090 00003F0F AC                      	LODSB
 25091 00003F10 3C2E                    	CMP	AL,'.'	; 2Eh
 25092 00003F12 7412                    	JZ	short _SetExt
 25093 00003F14 08C0                    	OR	AL,AL
 25094 00003F16 7424                    	JZ	short _GetDone
 25095 00003F18 3C5C                    	CMP	AL,'\'	; 5Ch
 25096 00003F1A 7420                    	JZ	short _GetDone
 25097 00003F1C 3C3F                    	CMP	AL,'?'	; 3Fh
 25098 00003F1E 7503                    	JNZ	short StoNam
 25099 00003F20 80CC01                  	OR	AH,1
 25100                                  StoNam: 
 25101 00003F23 AA                      	STOSB
 25102 00003F24 EBE9                    	JMP	short GetNam
 25103                                  _SetExt:
 25104 00003F26 BF[5305]                	MOV	DI,NAME1+8
 25105                                  GetExt:
 25106 00003F29 AC                      	LODSB
 25107 00003F2A 08C0                    	OR	AL,AL
 25108 00003F2C 740E                    	JZ	short _GetDone
 25109 00003F2E 3C5C                    	CMP	AL,'\'
 25110 00003F30 740A                    	JZ	short _GetDone
 25111 00003F32 3C3F                    	CMP	AL,'?'
 25112 00003F34 7503                    	JNZ	short StoExt
 25113 00003F36 80CC01                  	OR	AH,1
 25114                                  StoExt: 
 25115 00003F39 AA                      	STOSB
 25116 00003F3A EBED                    	JMP	short GetExt
 25117                                  _GetDone:
 25118 00003F3C 4E                      	DEC	SI
 25119 00003F3D 88E1                    	MOV	CL,AH  ; 0 or 1 ; 29/12/2022
 25120 00003F3F 80C980                  	OR	CL,80H
 25121 00003F42 5F                      	POP	DI			; Start of this element
 25122 00003F43 07                      	POP	ES			; Restore ES:BP
 25123 00003F44 39FE                    	CMP	SI,DI
 25124 00003F46 7503                    	JNZ	short check_device
 25125 00003F48 E9DD00                  	JMP	_BADPATH		; NUL parse (two delims most likely)
 25126                                  check_device:
 25127 00003F4B 56                      	PUSH	SI			; Start of next element
 25128                                  	;MOV	AL,[SI]
 25129                                  	; 15/02/2024
 25130 00003F4C 08C0                    	OR	AL,AL
 25131                                  	; 23/09/2023
 25132                                  	;cmp	byte [si],0
 25133 00003F4E 7508                    	JNZ	short NOT_LAST
 25134                                  
 25135                                  ; for last element of the path switch to the correct search attributes
 25136                                  
 25137 00003F50 8A3E[6D05]              	MOV	BH,[SATTRIB]
 25138 00003F54 883E[6B05]              	MOV	[ATTRIB],BH
 25139                                  
 25140                                  NOT_LAST:
 25141                                  
 25142                                  ; check name1 to see if we have a device...
 25143                                  
 25144 00003F58 06                      	PUSH	ES			; Save ES:BP
 25145                                  
 25146                                  ;hkn; SS is DOSDATA
 25147                                  	;context ES
 25148 00003F59 16                      	push	ss
 25149 00003F5A 07                      	pop	es
 25150 00003F5B E81F01                  	call	DEVNAME 		; blast BX
 25151 00003F5E 07                      	POP	ES			; Restore ES:BP
 25152 00003F5F 7208                    	JC	short FindFile		; Not a device
 25153 00003F61 08C0                    	OR	AL,AL			; Test next char again
 25154                                  	;JZ	short GO_BDEV
 25155                                  	;JMP	FILEINPATH		; Device name in middle of path
 25156                                  	; 27/06/2024
 25157 00003F63 752D                    	jnz	short FILEINPATH_j
 25158                                  
 25159                                  GO_BDEV:
 25160 00003F65 5E                      	POP	SI			; Points to NUL at end of path
 25161 00003F66 E9A0FE                  	JMP	Build_devJ
 25162                                  
 25163                                  FindFile:
 25164                                  ;;;; 7/28/86
 25165 00003F69 803E[4B05]E5            	CMP	BYTE [NAME1],0E5H	; if 1st char = E5
 25166 00003F6E 7505                    	JNZ	short NOE5		; no
 25167 00003F70 C606[4B05]05            	MOV	BYTE [NAME1],05H	; change it to 05
 25168                                  NOE5:
 25169                                  ;;;; 7/28/86
 25170 00003F75 57                      	PUSH	DI			; Start of this element
 25171 00003F76 06                      	PUSH	ES			; Save ES:BP
 25172 00003F77 51                      	PUSH	CX			; CL return from NameTrans
 25173                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 25174                                  
 25175 00003F78 E88A02                  	CALL	LookupPath		; call fastopen to get dir entry
 25176 00003F7B 7303                    	JNC	short DIR_FOUND		; found dir entry
 25177                                  
 25178                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 25179 00003F7D E8CEFC                  	call	FINDENTRY
 25180                                  DIR_FOUND:
 25181 00003F80 59                      	POP	CX
 25182 00003F81 07                      	POP	ES
 25183 00003F82 5F                      	POP	DI
 25184 00003F83 7303                    	JNC	short LOAD_BUF
 25185 00003F85 E9C500                  	JMP	BADPATHPOP
 25186                                  
 25187                                  LOAD_BUF:
 25188 00003F88 C53E[E205]              	LDS	DI,[CURBUF]
 25189                                  	;test	byte [bx+0Bh],10h
 25190 00003F8C F6470B10                	TEST	BYTE [BX+dir_entry.dir_attr],attr_directory
 25191 00003F90 7503                    	JNZ	short GO_NEXT 		; DOS 3.3
 25192                                  FILEINPATH_j:	; 27/06/2024
 25193 00003F92 E99700                  	JMP	FILEINPATH		; Error or end of path
 25194                                  
 25195                                  ; if we are not setting the directory, then check for end of string
 25196                                  
 25197                                  GO_NEXT:
 25198                                  ;hkn; SS override
 25199 00003F95 36803E[4C03]00          	CMP	BYTE [SS:NoSetDir],0
 25200 00003F9B 7423                    	JZ	short SetDir
 25201 00003F9D 89FA                    	MOV	DX,DI			; Save pointer to entry
 25202 00003F9F 8CD9                    	MOV	CX,DS
 25203                                  
 25204                                  ;hkn; SS is DOSDATA
 25205                                  	;context DS
 25206 00003FA1 16                      	push	ss
 25207 00003FA2 1F                      	pop	ds
 25208 00003FA3 5F                      	POP	DI			; Start of next element
 25209                                  	; 19/05/2019 - Retro DOS v4.0
 25210                                  	; MSDOS 6.0
 25211 00003FA4 F606[3A0D]01            	TEST	byte [FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 25212 00003FA9 740B                    	JZ	short _nofast			; the FastOpen
 25213 00003FAB F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success ; Lookup just happened
 25214 00003FB0 7404                    	JZ	short _nofast			; no
 25215 00003FB2 8B3E[660D]              	MOV	DI,[Next_Element_Start]	; no need to insert it again
 25216                                  _nofast:
 25217 00003FB6 803D00                  	CMP	BYTE [DI],0
 25218                                  	;;JNZ	short NEXT_ONE		; DOS 3.3
 25219                                  	;;JMP	_SETRET  ; retn		; Got it
 25220                                  	;retn	; 05/09/2018
 25221                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25222                                  	;jmp	_SETRET
 25223                                  	; 16/12/2022
 25224 00003FB9 7421                    	jz	short _SETRET
 25225                                  
 25226                                  NEXT_ONE:
 25227 00003FBB 57                      	PUSH	DI			; Put start of next element back on stack
 25228 00003FBC 89D7                    	MOV	DI,DX
 25229 00003FBE 8ED9                    	MOV	DS,CX			; Get back pointer to entry
 25230                                  SetDir:
 25231 00003FC0 8B14                    	MOV	DX,[SI] 		; Dir_first
 25232                                  
 25233                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 25234 00003FC2 1E                      	PUSH	DS		      ; save [curbuf+2]
 25235                                  ;hkn; SS is DOSDATA
 25236 00003FC3 16                      	push	ss
 25237 00003FC4 1F                      	pop	ds		      ; set DS Dosgroup
 25238                                  	;test	byte [FastOpenFlg],2
 25239 00003FC5 F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success
 25240 00003FCA 7411                    	JZ	short DO_NORMAL	      ; fastopen not in memory or path not
 25241 00003FCC 89D3                    	MOV	BX,DX		      ; not found
 25242 00003FCE 8B3E[BC05]              	MOV	DI,[CLUSNUM]	      ; clusnum was set in LookupPath
 25243 00003FD2 50                      	PUSH	AX		      ; save device id (AH)
 25244 00003FD3 E8B2FD                  	call	SETDIRSRCH
 25245 00003FD6 58                      	POP	AX		      ; restore device id (AH)
 25246 00003FD7 83C402                  	ADD	SP,2		      ; pop ds in stack
 25247 00003FDA EB36                    	JMP	short FAST_OPEN_SKIP
 25248                                  
 25249                                  	; 16/12/2022
 25250                                  _SETRET:
 25251 00003FDC C3                      	retn
 25252                                  
 25253                                  DO_NORMAL:
 25254 00003FDD 1F                      	POP	DS			; DS = [curbuf + 2]
 25255                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 25256                                  
 25257 00003FDE 29FB                    	SUB	BX,DI			; Offset into sector of start of entry
 25258 00003FE0 29FE                    	SUB	SI,DI			; Offset into sector of dir_first
 25259 00003FE2 53                      	PUSH	BX
 25260 00003FE3 50                      	PUSH	AX
 25261 00003FE4 56                      	PUSH	SI
 25262 00003FE5 51                      	PUSH	CX
 25263                                  
 25264                                  ; 16/02/2024
 25265                                  %if 0
 25266                                  	;push	word [di+6]
 25267                                  	PUSH	WORD [DI+BUFFINFO.buf_sector]	;AN000;>32mb
 25268                                  	; 19/05/2019
 25269                                  	; MSDOS 6.0
 25270                                  	;push	word [di+8]
 25271                                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;AN000;>32mb
 25272                                  %else	
 25273                                  	; 16/02/2024
 25274                                  	;lds	bx,[di+6]
 25275 00003FE6 C55D06                  	lds	bx,[di+BUFFINFO.buf_sector]
 25276 00003FE9 53                      	push	bx
 25277 00003FEA 1E                      	push	ds
 25278                                  %endif
 25279                                  
 25280 00003FEB 89D3                    	MOV	BX,DX
 25281                                  
 25282                                  ;hkn; SS is DOSDATA
 25283                                  	;context DS
 25284 00003FED 16                      	push	ss
 25285 00003FEE 1F                      	pop	ds
 25286                                  	;invoke	SETDIRSRCH		; This uses UNPACK which might blow
 25287 00003FEF E896FD                  	call	SETDIRSRCH		; the entry sector buffer
 25288                                  	; 19/05/2019
 25289                                  	; MSDOS 6.0
 25290 00003FF2 8F06[0706]              	POP	word [HIGH_SECTOR]
 25291 00003FF6 5A                      	POP	DX
 25292 00003FF7 7203                    	JC	short SKIP_GETB
 25293                                  	; 22/09/2023
 25294                                  	;;mov	byte [ALLOWED],18h
 25295                                  	;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 25296                                  	;XOR	AL,AL ; *
 25297                                  	;;invoke GETBUFFR		; Get the entry buffer back
 25298                                  	;call	GETBUFFR
 25299 00003FF9 E8B517                  	call	GETBUFFER ; * ; pre-read
 25300                                  SKIP_GETB:
 25301 00003FFC 59                      	POP	CX
 25302 00003FFD 5E                      	POP	SI
 25303 00003FFE 58                      	POP	AX
 25304 00003FFF 5B                      	POP	BX
 25305 00004000 7305                    	JNC	short SET_THE_BUF
 25306 00004002 5F                      	POP	DI			; Start of next element
 25307 00004003 89FE                    	MOV	SI,DI			; Point with SI
 25308 00004005 EB21                    	JMP	SHORT _BADPATH
 25309                                  
 25310                                  SET_THE_BUF:
 25311 00004007 E8B7F5                  	call	SET_BUF_AS_DIR
 25312 0000400A 8B3E[E205]              	MOV	DI,[CURBUF]
 25313 0000400E 01FE                    	ADD	SI,DI			; Get the offsets back
 25314 00004010 01FB                    	ADD	BX,DI
 25315                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 25316                                  FAST_OPEN_SKIP:
 25317 00004012 5F                      	POP	DI			; Start of next element
 25318 00004013 E89302                  	CALL	InsertPath		; insert dir entry info
 25319                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 25320 00004016 8A05                    	MOV	AL,[DI]
 25321 00004018 08C0                    	OR	AL,AL
 25322 0000401A 74C0                    	JZ	short _SETRET		; At end
 25323 0000401C 47                      	INC	DI			; Skip over "/"
 25324 0000401D 89FE                    	MOV	SI,DI			; Point with SI
 25325 0000401F E8F00E                  	call	PATHCHRCMP
 25326 00004022 7503                    	JNZ	short find_bad_name	; oops
 25327 00004024 E9B8FE                  	JMP	FINDPATH		; Next element
 25328                                  
 25329                                  find_bad_name:
 25330 00004027 4E                      	DEC	SI			; Undo above INC to get failure point
 25331                                  _BADPATH:
 25332 00004028 30C9                    	XOR	CL,CL			; Set zero
 25333 0000402A EB28                    	JMP	SHORT BADPRET
 25334                                  
 25335                                  FILEINPATH:
 25336 0000402C 5F                      	POP	DI			; Start of next element
 25337                                  
 25338                                  ;hkn; SS is DOSDATA
 25339                                  	;context DS			; Got to from one place with DS gone
 25340 0000402D 16                      	push	ss
 25341 0000402E 1F                      	pop	ds
 25342                                  
 25343                                  ; DOS 3.3 FastOpen
 25344                                  	;test	byte [FastOpenFlg],1
 25345 0000402F F606[3A0D]01            	TEST	byte [FastOpenFlg],FastOpen_Set  ; do this here is we don't want to
 25346 00004034 740B                    	JZ	short NO_FAST		; device info to fastopen
 25347                                  	;test	byte [FastOpenFlg],2
 25348 00004036 F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success
 25349 0000403B 7404                    	JZ	short NO_FAST
 25350 0000403D 8B3E[660D]              	MOV	DI,[Next_Element_Start]  ; This takes care of one time lookup
 25351                                  					 ; success
 25352                                  NO_FAST:
 25353                                  ; DOS 3.3 FastOpen
 25354 00004041 8A05                    	MOV	AL,[DI]
 25355 00004043 08C0                    	OR	AL,AL
 25356                                  	;JZ	short INCRET
 25357                                  	;MOV	SI,DI			; Path too long
 25358                                  	;JMP	SHORT BADPRET
 25359                                  	; 27/06/2024
 25360 00004045 750B                    	jnz 	short BADPRET_X
 25361                                  
 25362                                  INCRET:
 25363                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 25364                                  
 25365 00004047 E85F02                  	CALL   InsertPath		; insert dir entry info
 25366                                  
 25367                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 25368 0000404A FEC0                    	INC	AL			; Reset zero
 25369                                  	; 16/12/2022	
 25370                                  ;_SETRET:
 25371 0000404C C3                      	retn
 25372                                  
 25373                                  BADPATHPOP:
 25374 0000404D 5E                      	POP	SI			; Start of next element
 25375 0000404E 8A04                    	MOV	AL,[SI]
 25376                                  	; 27/06/2024
 25377                                  	;MOV	SI,DI			; Start of bad element
 25378 00004050 08C0                    	OR	AL,AL			; zero if bad element is last, non-zero if path too long
 25379                                  BADPRET_X:	; 27/06/2024
 25380 00004052 89FE                    	mov	si,di
 25381                                  BADPRET:
 25382 00004054 A0[6D05]                	MOV	AL,[SATTRIB]
 25383 00004057 A2[6B05]                	MOV	[ATTRIB],AL		; Make sure return correct
 25384 0000405A F9                      	STC
 25385 0000405B C3                      	retn
 25386                                  
 25387                                  ;Break	<STARTSRCH -- INITIATE DIRECTORY SEARCH>
 25388                                  ;---------------------------------------------------------------------------
 25389                                  ;
 25390                                  ; Procedure Name : STARTSRCH
 25391                                  ;
 25392                                  ; Inputs:
 25393                                  ;	[THISDPB] Set
 25394                                  ; Function:
 25395                                  ;	Set up a search for GETENTRY and NEXTENTRY
 25396                                  ; Outputs:
 25397                                  ;	ES:BP = Drive parameters
 25398                                  ;	Sets up LASTENT, ENTFREE=ENTLAST=-1, VOLID=0
 25399                                  ; Destroys ES,BP,AX
 25400                                  ;--------------------------------------------------------------------------
 25401                                  
 25402                                  STARTSRCH:
 25403 0000405C C42E[8A05]              	LES	BP,[THISDPB]
 25404 00004060 31C0                    	XOR	AX,AX
 25405 00004062 A3[4803]                	MOV	[LASTENT],AX
 25406 00004065 A2[7B05]                	MOV	[VOLID],AL		; No volume ID found
 25407 00004068 48                      	DEC	AX
 25408 00004069 A3[D805]                	MOV	[ENTFREE],AX
 25409 0000406C A3[DA05]                	MOV	[ENTLAST],AX
 25410 0000406F C3                      	retn
 25411                                  
 25412                                  ;BREAK <MatchAttributes - the final check for attribute matching>
 25413                                  ;----------------------------------------------------------------------------
 25414                                  ; Procedure Name : MatchAttributes
 25415                                  ;
 25416                                  ; Input:    [Attrib] = attribute to search for
 25417                                  ;	    CH = found attribute
 25418                                  ; Output:   JZ <match>
 25419                                  ;	    JNZ <nomatch>
 25420                                  ; Registers modified: noneski
 25421                                  ;----------------------------------------------------------------------------
 25422                                  
 25423                                  MatchAttributes:
 25424 00004070 50                      	PUSH	AX
 25425                                  
 25426                                  ;hkn; SS override
 25427 00004071 36A0[6B05]              	MOV	AL,[ss:ATTRIB]		; AL <- SearchSet
 25428 00004075 F6D0                    	NOT	AL			; AL <- SearchSet'
 25429 00004077 20E8                    	AND	AL,CH			; AL <- SearchSet' and FoundSet
 25430                                  	;and	al,16h
 25431 00004079 2416                    	AND	AL,attr_all	; AL <- SearchSet' and FoundSet and Important
 25432                                  ;
 25433                                  ; the result is non-zero if an attribute is not in the search set
 25434                                  ; and in the found set and in the important set. This means that we do not
 25435                                  ; have a match. Do a JNZ <nomatch> or JZ <match>
 25436                                  ;
 25437 0000407B 58                      	POP	AX
 25438 0000407C C3                      	retn
 25439                                  
 25440                                  ; 19/05/2019 - Retro DOS v4.0
 25441                                  ; DOSCODE:8148h (MSDOS 6.21, MSDOS.SYS)
 25442                                  
 25443                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25444                                  ; DOSCODE:810Dh (MSDOS 5.0, MSDOS.SYS)
 25445                                  
 25446                                  ;Break <DevName - Look for name of device>
 25447                                  ;---------------------------------------------------------------------------
 25448                                  ;
 25449                                  ; Procedure Name : DevName
 25450                                  ;
 25451                                  ; Inputs:
 25452                                  ;	DS,ES:DOSDATA
 25453                                  ;	Filename in NAME1
 25454                                  ;	ATTRIB set so that we can error out if looking for Volume IDs
 25455                                  ; Function:
 25456                                  ;	Determine if file is in list of I/O drivers
 25457                                  ; Outputs:
 25458                                  ;	Carry set if not a device
 25459                                  ;	ELSE
 25460                                  ;	Zero flag set
 25461                                  ;	BH = Bit 7,6 = 1, bit 5 = 0 (cooked mode)
 25462                                  ;	     bits 0-4 set from low byte of attribute word
 25463                                  ;	DEVPT = DWORD pointer to Device header of device
 25464                                  ; BX destroyed, others preserved
 25465                                  ;---------------------------------------------------------------------------
 25466                                  
 25467                                  DEVNAME:
 25468                                  	; 28/07/2018 - Retro DOS v3.0
 25469                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 49FBh
 25470                                  
 25471 0000407D 56                      	PUSH	SI
 25472 0000407E 57                      	PUSH	DI
 25473 0000407F 51                      	PUSH	CX
 25474 00004080 50                      	PUSH	AX
 25475                                  
 25476                                  ; E5 special code
 25477 00004081 FF36[4B05]              	PUSH	WORD [NAME1]
 25478 00004085 803E[4B05]05            	CMP	byte [NAME1],5
 25479 0000408A 7505                    	JNZ	short NOKTR
 25480 0000408C C606[4B05]E5            	MOV	byte [NAME1],0E5h
 25481                                  NOKTR:
 25482                                  	;test	byte [ATTRIB],8
 25483 00004091 F606[6B05]08            	TEST	byte [ATTRIB],attr_volume_id
 25484                                  					; If looking for VOL id don't find devs
 25485 00004096 7520                    	JNZ	short RET31
 25486                                  
 25487                                  ;hkn; NULDEV is in DOSDATA
 25488 00004098 BE[4800]                	MOV	SI,NULDEV
 25489                                  LOOKIO:
 25490                                  	; 21/11/2022
 25491                                  	;test	byte [SI+SYSDEV.ATT+1],80h
 25492                                  	; 17/12/2022
 25493                                  	;test	byte [si+5],80h
 25494 0000409B F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8)
 25495                                  	;;test	word [si+4],8000h
 25496                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP
 25497 0000409F 7410                    	JZ	short SKIPDEV 		; Skip block devices (NET and LOCAL)
 25498 000040A1 89F0                    	MOV	AX,SI
 25499                                  	;add	si,10
 25500 000040A3 83C60A                  	ADD	SI,SYSDEV.NAME
 25501                                  
 25502                                  ;hkn; NAME1 is in DOSDATA
 25503 000040A6 BF[4B05]                	MOV	DI,NAME1
 25504 000040A9 B90400                  	MOV	CX,4			; All devices are 8 letters
 25505 000040AC F3A7                    	REPE	CMPSW			; Check for name in list
 25506                                  	;MOV	SI,AX
 25507                                  	; 27/06/2024
 25508 000040AE 96                      	xchg	ax,si
 25509 000040AF 7415                    	JZ	short IOCHK		; Found it?
 25510                                  SKIPDEV:
 25511 000040B1 C534                    	LDS	SI,[SI]			; Get address of next device
 25512 000040B3 83FEFF                  	CMP	SI,-1			; At end of list?
 25513 000040B6 75E3                    	JNZ	short LOOKIO
 25514                                  RET31:	
 25515 000040B8 F9                      	STC				; Not found
 25516                                  RETNV:	
 25517 000040B9 8CD1                    	MOV	CX,SS
 25518 000040BB 8ED9                    	MOV	DS,CX
 25519                                  
 25520 000040BD 8F06[4B05]              	POP	WORD [NAME1]
 25521 000040C1 58                      	POP	AX
 25522 000040C2 59                      	POP	CX
 25523 000040C3 5F                      	POP	DI
 25524 000040C4 5E                      	POP	SI
 25525 000040C5 C3                      	RETN
 25526                                  
 25527                                  IOCHK:
 25528                                  ;hkn; SS override for DEVPT
 25529 000040C6 368C1E[9C05]            	MOV	[SS:DEVPT+2],DS		; Save pointer to device
 25530                                  	;mov	bh,[si+4]
 25531 000040CB 8A7C04                  	MOV	BH,[SI+SYSDEV.ATT]
 25532 000040CE 80CFC0                  	OR	BH,0C0h
 25533 000040D1 80E7DF                  	and	bh,0DFh
 25534                                  	;AND	BH,~(020h)		; Clears Carry
 25535 000040D4 368936[9A05]            	MOV	[SS:DEVPT],SI
 25536 000040D9 EBDE                    	JMP	short RETNV
 25537                                  
 25538                                  ;BREAK <Build_device_ent - Make a Directory entry>
 25539                                  ;---------------------------------------------------------------------------
 25540                                  ; Procedure Name : Build_device_ent
 25541                                  ;
 25542                                  ; Inputs:
 25543                                  ;	[NAME1] has name
 25544                                  ;	BH is attribute field (supplied by DEVNAME)
 25545                                  ;	[DEVPT] points to device header (supplied by DEVNAME)
 25546                                  ; Function:
 25547                                  ;	Build a directory entry for a device at DEVFCB
 25548                                  ; Outputs:
 25549                                  ;	BX points to DEVFCB
 25550                                  ;	SI points to dir_first field
 25551                                  ;	AH = input BH
 25552                                  ;	AL = 0
 25553                                  ;	dir_first = DEVPT
 25554                                  ;	Zero Set, Carry Clear
 25555                                  ; DS,ES,BP preserved, others destroyed
 25556                                  ;--------------------------------------------------------------------------
 25557                                  
 25558                                  Build_device_ent:
 25559 000040DB B82020                  	MOV	AX,"  " ; 2020h
 25560                                  
 25561                                  ;hkn; DEVFCB is in DOSDATA
 25562 000040DE BF[5305]                	MOV	DI,DEVFCB+8		; Point to extent field
 25563                                  
 25564                                  ;	Fill dir_ext  BUGBUG - use ERRNZs for this stuff!
 25565                                  
 25566 000040E1 AB                      	STOSW
 25567 000040E2 AA                      	STOSB				; Blank out extent field
 25568                                  	;mov	al,40h
 25569 000040E3 B040                    	MOV	AL,attr_device
 25570                                  
 25571                                  ;	Fill Dir_attr
 25572                                  
 25573 000040E5 AA                      	STOSB				; Set attribute field
 25574 000040E6 31C0                    	XOR	AX,AX
 25575 000040E8 B90A00                  	MOV	CX,10
 25576                                  
 25577                                  ; Fill dir_pad
 25578                                  
 25579 000040EB F3AB                    	REP	STOSW			; Fill rest with zeros
 25580 000040ED E8F0C9                  	call	DATE16
 25581                                  
 25582                                  ;hkn; DEVFCB is in DOSDATA
 25583 000040F0 BF[6105]                	MOV	DI,DEVFCB+dir_entry.dir_time ; 09/08/2018
 25584 000040F3 92                      	XCHG	AX,DX
 25585                                  
 25586                                  ; Fill dir_time
 25587                                  
 25588 000040F4 AB                      	STOSW
 25589 000040F5 92                      	XCHG	AX,DX
 25590                                  
 25591                                  ; Fill dir_date
 25592                                  
 25593 000040F6 AB                      	STOSW
 25594 000040F7 89FE                    	MOV	SI,DI			; SI points to dir_first field
 25595 000040F9 A1[9A05]                	MOV	AX,[DEVPT]
 25596                                  
 25597                                  ; Fill dir_first
 25598                                  
 25599 000040FC AB                      	STOSW				; Dir_first points to device
 25600 000040FD A1[9C05]                	MOV	AX,[DEVPT+2]
 25601                                  ;
 25602                                  ; Fill dir_size_l
 25603                                  ;
 25604 00004100 AB                      	STOSW
 25605 00004101 88FC                    	MOV	AH,BH			; Put device atts in AH
 25606                                  
 25607                                  ;hkn; DEVFCB is in DOSDATA
 25608 00004103 BB[4B05]                	MOV	BX,DEVFCB
 25609 00004106 30C0                    	XOR	AL,AL			; Set zero, clear carry
 25610 00004108 C3                      	retn
 25611                                  
 25612                                  ;Break	<ValidateCDS - given a CDS, validate the media and the current directory>
 25613                                  ;----------------------------------------------------------------------------
 25614                                  ;
 25615                                  ;   ValidateCDS - Get current CDS. Splice it. Call FatReadCDS to check
 25616                                  ;   media. If media has been changed, do DOS_Chdir to validate path.
 25617                                  ;   If invalid, reset original CDS to root.
 25618                                  ;
 25619                                  ;   Inputs:	ThisCDS points to CDS of interest
 25620                                  ;		SS:DI points to temp buffer
 25621                                  ;   Outputs:	The current directory string is validated on the appropriate
 25622                                  ;		    drive
 25623                                  ;		ThisDPB changed
 25624                                  ;		ES:DI point to CDS
 25625                                  ;		Carry set if error (currently user FAILed to I 24)
 25626                                  ;   Registers modified: all
 25627                                  ;----------------------------------------------------------------------------
 25628                                  
 25629                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25630                                  	; DOSCODE:819Bh (MSDOS 5.0, MSDOS.SYS)
 25631                                  
 25632                                  ValidateCDS:
 25633                                  	; 19/05/2019 - Retro DOS v4.0
 25634                                  	; 28/07/2018 - Retro DOS v3.0
 25635                                  
 25636                                     %define  Temp	[bp-2]	; word
 25637                                     %define  SaveCDS	[bp-6]	; dword
 25638                                     %define  SaveCDSL	[bp-6]	; word
 25639                                     %define  SaveCDSH	[bp-4]	; word
 25640                                  
 25641                                  	;Enter
 25642 00004109 55                      	push	bp
 25643 0000410A 89E5                    	mov	bp,sp
 25644 0000410C 83EC06                  	sub	sp,6
 25645                                  
 25646 0000410F 897EFE                  	MOV	Temp,DI
 25647                                  
 25648                                  ;hkn; SS override
 25649 00004112 36C536[A205]            	LDS	SI,[SS:THISCDS]
 25650 00004117 8976FA                  	MOV	SaveCDSL,SI
 25651 0000411A 8C5EFC                  	MOV	SaveCDSH,DS
 25652                                  	;EnterCrit critDisk
 25653 0000411D E8C2D1                  	call	ECritDisk
 25654                                  	; 21/11/2022
 25655                                  	;test	byte [SI+curdir.flags+1],80h
 25656                                  	;test	word [si+67],8000h
 25657                                  	; 17/12/2022
 25658                                  	;test	byte [SI+68],80h
 25659 00004120 F6444480                	test	byte [SI+curdir.flags+1],(curdir_isnet>>8)
 25660                                  	;TEST	word [SI+curdir.flags],curdir_isnet	; Clears carry
 25661 00004124 7403                    	JZ	short _DoSplice
 25662 00004126 E98D00                  	JMP	FatFail
 25663                                  _DoSplice:
 25664 00004129 30D2                    	XOR	DL,DL
 25665 0000412B 368616[4C03]            	XCHG	DL,[SS:NoSetDir]
 25666                                  
 25667                                  ;hkn; SS is DOSDATA
 25668                                  	;Context ES
 25669 00004130 16                      	push	ss
 25670 00004131 07                      	pop	es
 25671                                  	;Invoke	FStrcpy
 25672 00004132 E88BD0                  	call	FStrCpy
 25673 00004135 8B76FE                  	MOV	SI,Temp
 25674                                  
 25675                                  ;hkn; SS is DOSDATA
 25676                                  	;Context DS
 25677 00004138 16                      	push	ss
 25678 00004139 1F                      	pop	ds	
 25679                                  	;Invoke	Splice
 25680 0000413A E8EE2A                  	call	Splice
 25681                                  
 25682                                   ;hkn; SS is DOSDATA
 25683                                  	;Context DS			;   FatReadCDS (ThisCDS);
 25684 0000413D 16                      	push	ss
 25685 0000413E 1F                      	pop	ds
 25686 0000413F 8816[4C03]              	MOV	[NoSetDir],DL
 25687 00004143 C43E[A205]              	LES	DI,[THISCDS]
 25688                                  	;SAVE	<BP>
 25689 00004147 55                      	push	bp
 25690                                  	;Invoke	FATREAD_CDS
 25691 00004148 E8F713                  	call	FATREAD_CDS	
 25692                                  	;RESTORE <BP>
 25693 0000414B 5D                      	pop	bp
 25694 0000414C 7268                    	JC	short FatFail
 25695                                  
 25696 0000414E C536[A205]              	LDS	SI,[THISCDS]		;   if (ThisCDS->ID == -1) {
 25697                                  	;cmp	word [si+73],-1
 25698 00004152 837C49FF                	CMP	word [SI+curdir.ID],-1
 25699 00004156 7550                    	JNZ	short RestoreCDS
 25700                                  
 25701                                  ;hkn; SS is DOSDATA
 25702                                  	;Context ES
 25703 00004158 16                      	push	ss
 25704 00004159 07                      	pop	es
 25705                                  
 25706                                  ;hkn; SS override
 25707                                  	;SAVE	<wfp_Start>		;	t = wfp_Start;
 25708 0000415A 36FF36[B205]            	push	word [SS:WFP_START]
 25709                                  	;cmp	si,[bp-6]
 25710 0000415F 3B76FA                  	CMP	SI,SaveCDSL		; if not spliced
 25711 00004162 750B                    	JNZ	short DoChdir
 25712                                  	;mov	di,[bp-2]
 25713 00004164 8B7EFE                  	MOV	DI,Temp
 25714                                  
 25715                                  ;hkn; SS override
 25716 00004167 36893E[B205]            	MOV	[SS:WFP_START],DI	;	wfp_start = d;
 25717                                  	;Invoke	FStrCpy 		;	strcpy (d, ThisCDS->Text);
 25718 0000416C E851D0                  	call	FStrCpy
 25719                                  DoChdir:
 25720                                  ;hkn; SS is DOSDATA
 25721                                  	;Context DS
 25722 0000416F 16                      	push	ss
 25723 00004170 1F                      	pop	ds
 25724                                  	;SAVE	<<WORD PTR SAttrib>,BP> ;	c = DOSChDir ();
 25725 00004171 FF36[6D05]              	push	word [SATTRIB]
 25726 00004175 55                      	push	bp
 25727                                  	;Invoke	DOS_ChDir
 25728 00004176 E85FEF                  	call	DOS_CHDIR
 25729                                  	;RESTORE <BP,BX,wfp_start>	;	wfp_Start = t;
 25730 00004179 5D                      	pop	bp
 25731 0000417A 5B                      	pop	bx
 25732 0000417B 8F06[B205]              	pop	word [WFP_START]
 25733 0000417F 881E[6D05]              	MOV	[SATTRIB],BL
 25734 00004183 C576FA                  	LDS	SI,SaveCDS
 25735 00004186 730F                    	JNC	short SetCluster	;	if (c == -1) {
 25736                                  
 25737                                  ;hkn; SS override for THISCDS
 25738 00004188 368936[A205]            	MOV	[SS:THISCDS],SI		;	    ThisCDS = TmpCDS;
 25739 0000418D 368C1E[A405]            	MOV	[SS:THISCDS+2],DS
 25740 00004192 31C9                    	XOR	CX,CX			;	    TmpCDS->text[3] = c = 0;
 25741 00004194 884C03                  	MOV	[SI+3],CL		;	    }
 25742                                  SetCluster:
 25743                                  	; 16/02/2024
 25744                                  	;;mov	word [si+73],0FFFFh
 25745                                  	;MOV	word [SI+curdir.ID],-1	;	TmpCDS->ID = -1;
 25746                                  	;
 25747 00004197 36C536[A205]            	LDS	SI,[SS:THISCDS]		;	ThisCDS->ID = c;
 25748                                  	; 21/11/2022
 25749                                  	;test	byte [si+curdir.flags+1],20h
 25750                                  	; 19/05/2019
 25751                                  	; MSDOS 6.0
 25752                                  	; 17/12/2022
 25753                                  	;test	byte [si+68],20h
 25754 0000419C F6444420                	test	byte [SI+curdir.flags+1],(curdir_splice>>8)	
 25755                                  	;;test	word [si+67],2000h
 25756                                  	;TEST	word [SI+curdir.flags],curdir_splice ;AN000;;MS. for Join and Subst
 25757 000041A0 7403                    	JZ	short _setdirclus		     ;AN000;;MS.
 25758 000041A2 B9FFFF                  	MOV	CX,-1				     ;AN000;;MS.
 25759                                  _setdirclus:
 25760                                  	;mov	[si+73],cx
 25761 000041A5 894C49                  	MOV	[SI+curdir.ID],CX	;	}
 25762                                  RestoreCDS:
 25763 000041A8 C47EFA                  	LES	DI,SaveCDS
 25764 000041AB 36893E[A205]            	MOV	[SS:THISCDS],DI
 25765 000041B0 368C06[A405]            	MOV	[SS:THISCDS+2],ES
 25766 000041B5 F8                      	CLC
 25767                                  FatFail:
 25768                                  	;LeaveCrit critDisk
 25769 000041B6 E844D1                  	call	LCritDisk
 25770                                  
 25771                                  	;les	di,[bp-6]
 25772 000041B9 C47EFA                  	LES	DI,SaveCDS
 25773                                  	;Leave
 25774 000041BC 89EC                    	mov	sp,bp
 25775 000041BE 5D                      	pop	bp
 25776 000041BF C3                      	retn
 25777                                  
 25778                                  ; 28/07/2018 - Retro DOS v3.0
 25779                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - offset 43BDh
 25780                                  
 25781                                  ;Break	<CheckThisDevice - Check for being a device>
 25782                                  ;---------------------------------------------------------------------------
 25783                                  ;
 25784                                  ;   CheckThisDevice - Examine the area at DS:SI to see if there is a valid
 25785                                  ;   device specified. We will return carry if there is a device present. 
 25786                                  ;   The forms of devices we will recognize are:
 25787                                  ;
 25788                                  ;	[path]device
 25789                                  ;
 25790                                  ;   Note that the drive letter has *already* been removed. All other forms
 25791                                  ;   are not considered to be devices. If such a device is found we change
 25792                                  ;   the source pointer to point to the device component.
 25793                                  ;
 25794                                  ;   Inputs:	ES is DOSDATA
 25795                                  ;		DS:SI contains name
 25796                                  ;   Outputs:	ES is DOSDATA
 25797                                  ;		DS:SI point to name or device
 25798                                  ;		Carry flag set if device was found
 25799                                  ;		Carry flag reset otherwise
 25800                                  ;   Registers Modified: all except ES:DI, DS
 25801                                  ;----------------------------------------------------------------------------
 25802                                  
 25803                                  CheckThisDevice:
 25804 000041C0 57                      	push	di
 25805 000041C1 56                      	push	si
 25806 000041C2 89F7                    	MOV	DI,SI
 25807                                  
 25808                                  ; Check for presence of \dev\ (Dam multiplan!)
 25809                                  
 25810 000041C4 8A04                    	MOV	AL,[SI]
 25811 000041C6 E8490D                  	call	PATHCHRCMP		; is it a path char?
 25812 000041C9 7517                    	JNZ	short ParseDev		; no, go attempt to parse device
 25813 000041CB 46                      	INC	SI			; simulate LODSB
 25814                                  
 25815                                  ; We have the leading path separator. Look for DEV part.
 25816                                  
 25817 000041CC AD                      	LODSW
 25818 000041CD 0D2020                  	OR	AX,2020h
 25819 000041D0 3D6465                  	cmp	ax,"de"
 25820                                  	;CMP	AX,"e"<< 8 + "d"
 25821 000041D3 752D                    	JNZ	short NotDevice		; not "de", assume not device
 25822 000041D5 AC                      	LODSB
 25823 000041D6 0C20                    	OR	AL,20h
 25824 000041D8 3C76                    	CMP	AL,"v"                  ; Not "v", assume not device
 25825 000041DA 7526                    	JNZ	short NotDevice
 25826 000041DC AC                      	LODSB
 25827 000041DD E8320D                  	call	PATHCHRCMP		; do we have the last path separator?
 25828 000041E0 7520                    	JNZ	short NotDevice		; no. go for it.
 25829                                  
 25830                                  ; DS:SI now points to a potential drive. Preserve them as NameTrans advances
 25831                                  ; SI and DevName may destroy DS.
 25832                                  
 25833                                  ParseDev:
 25834 000041E2 1E                      	push	ds
 25835 000041E3 56                      	push	si			; preserve the source pointer
 25836 000041E4 E86D0C                  	call	NameTrans		; advance DS:SI
 25837 000041E7 803C00                  	CMP	BYTE [SI],0		; parse entire string?
 25838 000041EA F9                      	STC				; simulate a Carry return from DevName
 25839 000041EB 750B                    	JNZ	short SkipSearch	; no parse. simulate a file return.
 25840                                  
 25841                                  ;hkn; SS is DOSDATA
 25842 000041ED 16                      	push	ss
 25843 000041EE 1F                      	pop	ds
 25844                                  
 25845                                  ; M026 - start - fix ported from ROMDOS2 for bug # 2849
 25846                                  ;
 25847                                  ; SR;
 25848                                  ; We have to set Attrib before invoking DevName. Otherwise, the value from
 25849                                  ; a previous DOS call is used and DevName thinks it is not a device if the
 25850                                  ; old call set the volume attribute bit.
 25851                                  
 25852 000041EF A0[6D05]                	mov	al,[SATTRIB]
 25853 000041F2 A2[6B05]                	mov	[ATTRIB],al		;set Attrib for DevName
 25854                                  
 25855                                  ; M026 - end
 25856                                  
 25857 000041F5 E885FE                  	call	DEVNAME
 25858                                  
 25859                                  SkipSearch:
 25860 000041F8 5E                      	pop	si
 25861 000041F9 1F                      	pop	ds
 25862                                  
 25863                                  ; SI points to the beginning of the potential device. If we have a device
 25864                                  ; then we do not change SI. If we have a file, then we reset SI back to the
 25865                                  ; original value. At this point Carry set indicates FILE.
 25866                                  
 25867                                  CheckReturn:
 25868 000041FA 5F                      	pop	di			; get original SI
 25869 000041FB 7302                    	JNC	short Check_Done	; if device then do not reset pointer
 25870 000041FD 89FE                    	MOV	SI,DI
 25871                                  Check_Done:
 25872 000041FF 5F                      	pop	di
 25873 00004200 F5                      	CMC				; invert carry. Carry => device
 25874 00004201 C3                      	retn
 25875                                  NotDevice:
 25876 00004202 F9                      	STC
 25877 00004203 EBF5                    	JMP	short CheckReturn
 25878                                  
 25879                                  ;BREAK <LookupPath - call fastopen to get dir entry info>
 25880                                  ;-----------------------------------------------------------------------------
 25881                                  ;
 25882                                  ; Procedure Name : LookupPath
 25883                                  ;
 25884                                  ; Output  DS:SI -> path name,
 25885                                  ;	  ES:DI -> dir entry info buffer
 25886                                  ;	  ES:CX -> extended dir info buffer
 25887                                  ;
 25888                                  ;	  carry flag clear : tables pointed by ES:DI and ES:CX are filled by
 25889                                  ;			     FastOpen, DS:SI points to char just one after
 25890                                  ;			     the last char of path name which is fully or
 25891                                  ;			     partially found in FastOPen
 25892                                  ;	  carry flag set : FastOpen not in memory or path name not found
 25893                                  ;
 25894                                  ;----------------------------------------------------------------------------
 25895                                  
 25896                                  LookupPath:
 25897                                  ;	PUSH	AX
 25898                                  
 25899                                  ;hkn; SS override
 25900                                  	;test	byte [ss:FastOpenFlg],1
 25901 00004205 36F606[3A0D]01          	TEST	byte [ss:FastOpenFlg],FastOpen_Set  ; flg is set in DOSOPEN
 25902 0000420B 7503                    	JNZ	short FASTINST			    ; and this routine is
 25903                                  NOLOOK:
 25904 0000420D E99700                  	JMP	NOLOOKUP			    ; executed once
 25905                                  
 25906                                  FASTINST:
 25907                                  ;hkn; SS override
 25908                                  	;test	byte [ss:FastOpenFlg],8
 25909 00004210 36F606[3A0D]08          	TEST	byte [ss:FastOpenFlg],No_Lookup	    ; no more lookup?
 25910 00004216 75F5                    	JNZ	short NOLOOK			    ; yes
 25911                                  
 25912 00004218 BB[300D]                	MOV	BX,FastOpenTable		    ; get fastopen related tab
 25913                                  
 25914                                  ;hkn; SS override
 25915 0000421B 368B36[B205]            	MOV	SI,[SS:WFP_START]		    ; si points to path name
 25916 00004220 BF[460D]                	MOV	DI,Dir_Info_Buff
 25917 00004223 B9[3B0D]                	MOV	CX,FastOpen_Ext_Info
 25918 00004226 B001                    	MOV	AL,FONC_Look_up 		    ; al = 1
 25919 00004228 1E                      	PUSH	DS
 25920 00004229 07                      	POP	ES
 25921                                  
 25922                                  ;hkn; SS override
 25923                                  	;call	far [bx+2]
 25924 0000422A FF5F02                  	CALL	far [BX+fastopen_entry.name_caching] ;call fastopen
 25925 0000422D 7267                    	JC	short NOTFOUND			    ; fastopen not in memory
 25926                                  
 25927 0000422F 8D5CFE                  	LEA	BX,[SI-2]
 25928                                  
 25929                                  ;hkn; SS override
 25930 00004232 363B1E[B205]            	CMP	BX,[SS:WFP_START]		    ; path found ?
 25931 00004237 745D                    	JZ	short NOTFOUND			    ; no
 25932                                  
 25933                                  	; 19/05/2019 - Retro DOS v4.0
 25934                                  
 25935                                  	; MSDOS 6.0				    ; fully or partially found
 25936 00004239 803C00                  	CMP	BYTE [SI],0			    ;AN000;FO.
 25937 0000423C 751A                    	JNZ	short parfnd			    ;AN000;FO.; partiallyfound
 25938 0000423E 51                      	PUSH	CX				    ;AN000;FO.; is attribute matched ?
 25939                                  
 25940                                  ;hkn; SS override for attrib/sattrib
 25941 0000423F 368A0E[6B05]            	MOV	CL,[ss:ATTRIB]			    ;AN000;FO.;
 25942 00004244 368A2E[6D05]            	MOV	CH,[ss:SATTRIB]			    ;AN000;FO.; attrib=sattrib
 25943 00004249 36882E[6B05]            	MOV	[ss:ATTRIB],CH			    ;AN000;FO.;
 25944                                  	;mov	ch,[es:di+0Bh]
 25945 0000424E 268A6D0B                	MOV	CH,[ES:DI+dir_entry.dir_attr]	    ;AN000;FO.;
 25946 00004252 E81BFE                  	call	MatchAttributes 		    ;AN000;FO.;
 25947                                  ;;;	MOV	[ss:ATTRIB],CL			    ;AN001;FO.; restore attrib
 25948 00004255 59                      	POP	CX				    ;AN000;FO.;
 25949 00004256 754F                    	JNZ	short NOLOOKUP			    ;AN000;FO.; not matched
 25950                                  parfnd:
 25951                                  
 25952                                  ;hkn; SS override
 25953 00004258 368936[660D]            	MOV	[SS:Next_Element_Start],SI	    ; save si
 25954 0000425D 89CB                    	MOV	BX,CX
 25955                                  	; MSDOS 6.0
 25956                                  	;mov	ax,[bx+7]
 25957 0000425F 8B4707                  	MOV	AX,[BX+FEI.lastent]		    ;AN000;;FO. restore lastentry
 25958                                  ;hkn; SS override for LASTENT, DIRSTART, CLUSNUM
 25959 00004262 36A3[4803]              	MOV	[SS:LASTENT],AX			    ;AN000;;FO.
 25960 00004266 8B4709                  	MOV	AX,[BX+FEI.dirstart]		    ;AN001;;FO. restore dirstart
 25961 00004269 36A3[C205]              	MOV	[SS:DIRSTART],AX		    ;AN001;;FO.
 25962                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25963                                  	;;mov	ax,[bx+3] ; MSDOS 3.3
 25964                                  	;mov	ax,[bx+5] ; MSDOS 6.0
 25965 0000426D 8B4705                  	MOV	AX,[BX+FEI.clusnum]		    ; restore next cluster num
 25966 00004270 36A3[BC05]              	MOV	[SS:CLUSNUM],AX			    ;
 25967                                  
 25968 00004274 06                      	PUSH	ES				    ; save ES
 25969                                  ;hkn; SS override
 25970 00004275 36C41E[8A05]            	LES	BX,[SS:THISDPB]			    ; put drive id
 25971 0000427A 268A27                  	mov	ah,[ES:BX] ; 15/08/2018
 25972                                  	;MOV	AH,[ES:BX+DPB.DRIVE]		    ; in AH for DOOPEN
 25973 0000427D 07                      	POP	ES				    ; pop ES
 25974                                  ;SR;
 25975                                  ; We cannot have a root dir if we have come here. So, we zero out CurBuf to
 25976                                  ;indicate it is not a root dir
 25977                                  
 25978 0000427E 36C706[E205]0000        	mov	word [SS:CURBUF],0		    ; indicate not root dir
 25979 00004285 368C06[E405]            	MOV	WORD [SS:CURBUF+2],ES		    ; [curbuf+2].bx points to
 25980 0000428A 89FB                    	MOV	BX,DI				    ; start of entry
 25981                                  	;lea	si,[di+1Ah]
 25982 0000428C 8D751A                  	LEA	SI,[DI+dir_entry.dir_first]	    ; [curbuf+2]:si points to
 25983                                  						    ; dir_first field in the
 25984                                  						    ; dir entry
 25985                                  ;hkn; SS override for FastOpenFlg
 25986                                  	;or	byte [ss:FastOpenFlg],12h ; 29/12/2022
 25987 0000428F 36800E[3A0D]12          	OR	byte [SS:FastOpenFlg],Lookup_Success+Set_For_Search
 25988                                  ;	POP	AX
 25989 00004295 C3                      	RETN
 25990                                  NOTFOUND:
 25991 00004296 83F8FF                  	CMP	AX,-1				    ; not in memory ?
 25992 00004299 7506                    	JNZ	short Partial_Success 		    ; yes, in memory
 25993 0000429B 36C606[3A0D]00          	MOV	byte [SS:FastOpenFlg],0		    ; no more fastopen
 25994                                  Partial_Success:
 25995                                  	;and	byte [SS:FastOpenFlg],0FBh
 25996 000042A1 368026[3A0D]FB          	AND	byte [SS:FastOpenFlg],Special_Fill_Reset
 25997                                  NOLOOKUP:
 25998                                  ;	POP	AX
 25999 000042A7 F9                      	STC
 26000 000042A8 C3                      	RETN
 26001                                  
 26002                                  ;BREAK <InsertPath - call fastopen to insert dir entry info>
 26003                                  ;-----------------------------------------------------------------------------
 26004                                  ;
 26005                                  ; Procedure Name : InsertPath
 26006                                  ; Input:  FastOpen_Set flag set when from DOSOPEN otherwise 0
 26007                                  ;	  Lookup_Success flag set when got dir entry info from FASTOPEN
 26008                                  ;	  DS = DOSDATA
 26009                                  ; Output: FastOPen_Ext_Info is set and path dir info is inserted
 26010                                  ;
 26011                                  ;-----------------------------------------------------------------------------
 26012                                  
 26013                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26014                                  
 26015                                  InsertPath:
 26016 000042A9 9C                      	PUSHF
 26017                                  ;hkn; SS override for FastOpenFlag
 26018                                  	;test	byte [SS:FastOpenFlg], 1
 26019 000042AA 36F606[3A0D]01          	TEST	byte [SS:FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 26020 000042B0 7476                    	JZ	short GET_NEXT_ELEMENT		; the FastOpen
 26021                                  	;test	byte [ss:FastOpenFlg],2
 26022 000042B2 36F606[3A0D]02          	TEST	byte [SS:FastOpenFlg],Lookup_Success ; Lookup just happened
 26023 000042B8 740D                    	JZ	short INSERT_DIR_INFO		; no
 26024                                  	;and	byte [ss:FastOpenFlg],0FDh
 26025 000042BA 368026[3A0D]FD          	AND	byte [SS:FastOpenFlg],Lookup_Reset  ; we got dir info from fastopen so
 26026 000042C0 368B3E[660D]            	MOV	DI,[SS:Next_Element_Start]	; no need to insert it again
 26027 000042C5 EB5B                    	JMP	short GET_NEXT2
 26028                                  
 26029                                  INSERT_DIR_INFO:				; save registers
 26030 000042C7 1E                      	PUSH	DS
 26031 000042C8 06                      	PUSH	ES
 26032 000042C9 53                      	PUSH	BX
 26033 000042CA 56                      	PUSH	SI
 26034 000042CB 57                      	PUSH	DI
 26035 000042CC 51                      	PUSH	CX
 26036 000042CD 50                      	PUSH	AX
 26037                                  
 26038                                  ;hkn; SS override
 26039 000042CE 36C53E[E205]            	LDS	DI,[SS:CURBUF]			; DS:DI -> buffer header
 26040 000042D3 BE[3B0D]                	MOV	SI,FastOpen_Ext_Info
 26041                                  
 26042                                  ; 21/02/2024
 26043                                  %if 0
 26044                                  	;mov	ax,[di+6]
 26045                                  	MOV	AX,[DI+BUFFINFO.buf_sector]	; get directory sector
 26046                                  	; MSDOS 6.0
 26047                                  	;mov	[ss:si+1],ax
 26048                                  	MOV	[SS:SI+FEI.dirsec],AX 		;AN000; >32mb save dir sector
 26049                                  	; 19/05/2019 - Retro DOS v4.0
 26050                                  	MOV	AX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 26051                                  
 26052                                  ;hkn; SS is DOSDATA
 26053                                  	push	ss
 26054                                  	pop	ds
 26055                                  	; MSDOS 3.3
 26056                                  	;;mov	[si+1],ax
 26057                                  	;MOV	[SI+FEI.dirsec],AX
 26058                                  	; MSDOS 6.0
 26059                                  	;mov	[si+3],ax
 26060                                  	MOV	[SI+FEI.dirsec+2],AX		;AN000;>32mb save high dir sector
 26061                                  %else
 26062                                  	;lds	ax,[di+6]
 26063 000042D6 C54506                  	lds	ax,[di+BUFFINFO.buf_sector]	; get directory sector
 26064                                  	;mov	[ss:si+1],ax
 26065                                  	; 27/06/2024
 26066                                  	;mov	[ss:si+FEI.dirsec],ax
 26067                                  	;
 26068                                  	;mov	[ss:si+3],ax
 26069 000042D9 368C5C03                	mov	[ss:si+FEI.dirsec+2],ds
 26070 000042DD 16                      	push	ss
 26071 000042DE 1F                      	pop	ds
 26072                                  	; 27/06/2024
 26073 000042DF 894401                  	mov	[si+FEI.dirsec],ax
 26074                                  %endif
 26075                                  
 26076                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26077 000042E2 A1[BC05]                	MOV	AX,[CLUSNUM]		; save next cluster number
 26078                                  	;mov	[si+5],ax ; MSDOS 6.0
 26079                                  	;;mov	[si+3],ax ; MSDOS 3.3
 26080 000042E5 894405                  	MOV	[SI+FEI.clusnum],AX
 26081                                  	; MSDOS 6.0
 26082 000042E8 A1[4803]                	MOV	AX,[LASTENT]		;AN000;FO. save lastentry for search first
 26083                                  	;mov	[si+7],ax
 26084 000042EB 894407                  	MOV	[SI+FEI.lastent],AX	;AN000;FO.
 26085 000042EE A1[C205]                	MOV	AX,[DIRSTART]		;AN001;FO. save  for search first
 26086                                  	;mov	[si+9],ax
 26087 000042F1 894409                  	MOV	[SI+FEI.dirstart],AX	;AN001;FO.
 26088                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26089 000042F4 89D8                    	MOV	AX,BX
 26090                                  	;;add	di,16  ; MSDOS 3.3
 26091                                  	;add	di,20  ; MSDOS 6.0
 26092 000042F6 83C714                  	ADD	DI,BUFINSIZ		; DS:DI -> start of data in buffer
 26093 000042F9 29F8                    	SUB	AX,DI			; AX=BX relative to start of sector
 26094                                  	;mov	cl,32
 26095 000042FB B120                    	MOV	CL,dir_entry.size
 26096 000042FD F6F1                    	DIV	CL
 26097                                  	;MOV	[SI+FEI.dirpos],AL	; save directory entry # in buffer
 26098 000042FF 8804                    	mov	[si],al
 26099                                  
 26100 00004301 1E                      	PUSH	DS
 26101 00004302 07                      	POP	ES
 26102                                  
 26103 00004303 8E1E[E405]              	MOV	DS,[CURBUF+2]
 26104 00004307 89DF                    	MOV	DI,BX			; DS:DI -> dir entry info
 26105                                  	;cmp	word [di+1Ah],0
 26106 00004309 837D1A00                	CMP	word [DI+dir_entry.dir_first],0 
 26107                                  					; never insert info when file is empty
 26108 0000430D 740C                    	JZ	short SKIP_INSERT	; e.g. newly created file
 26109                                  
 26110 0000430F 56                      	PUSH	SI			; ES:BX -> extended info
 26111 00004310 5B                      	POP	BX
 26112                                  
 26113                                  	;mov	al,2
 26114 00004311 B002                    	MOV	AL,FONC_insert		; call fastopen insert operation
 26115 00004313 BE[300D]                	MOV	SI,FastOpenTable
 26116                                  	;call	far [es:si+2]	 ; call dword ptr es:[si+2] ; 29/12/2022
 26117                                  	; 07/12/2022
 26118 00004316 26FF5C02                	CALL	far [ES:SI+fastopen_entry.name_caching]
 26119                                  
 26120 0000431A F8                      	CLC
 26121                                  SKIP_INSERT:
 26122 0000431B 58                      	POP	AX
 26123 0000431C 59                      	POP	CX			; restore registers
 26124 0000431D 5F                      	POP	DI
 26125 0000431E 5E                      	POP	SI
 26126 0000431F 5B                      	POP	BX
 26127 00004320 07                      	POP	ES
 26128 00004321 1F                      	POP	DS
 26129                                  GET_NEXT2:
 26130                                  	;or	[ss:FastOpenFlg],8
 26131 00004322 36800E[3A0D]08          	OR	byte [SS:FastOpenFlg],No_Lookup
 26132                                  					; we got dir info from fastopen so
 26133                                  GET_NEXT_ELEMENT:
 26134 00004328 9D                      	POPF
 26135 00004329 C3                      	RETN
 26136                                  
 26137                                  ;============================================================================
 26138                                  ; DEV.ASM (MSDOS 6.0, 1991)
 26139                                  ;============================================================================
 26140                                  ; 17/07/2018 - Retro DOS v3.0
 26141                                  ; 30/04/2019 - Retro DOS v4.0
 26142                                  
 26143                                  ;**	Misc Routines to do 1-12 low level I/O and call devices
 26144                                  
 26145                                  ; Offset 12B8h of IBMDOS.COM (MSDOS 3.3), 1987
 26146                                  
 26147                                  ;DOSCODE:8401h (MSDOS 6.21, MSDOS.SYS)
 26148                                  
 26149                                  ;Public DEV001S, DEV001E 		; Pathgen labels
 26150                                  ;DEV001s:
 26151                                  ;		length of packets
 26152 0000432A 160E160D0F0E            LenTab:	 DB	DRDWRHL, DRDNDHL, DRDWRHL, DSTATHL, DFLSHL, DRDNDHL
 26153                                  ;LenTab: db	22,14,22,13,15,14
 26154                                  
 26155                                  ;	Error Function
 26156                                  
 26157                                  CmdTab:
 26158 00004330 8604                    	DB	86h, DEVRD	; 0 input
 26159 00004332 8605                    	DB	86h, DEVRDND	; 1 input status
 26160 00004334 8708                    	DB	87h, DEVWRT	; 2 output
 26161 00004336 870A                    	DB	87h, DEVOST	; 3 output status
 26162 00004338 8607                    	DB	86h, DEVIFL	; 4 input flush
 26163 0000433A 8605                    	DB	86h, DEVRDND	; 5 input status with system WAIT
 26164                                  
 26165                                  ; Offset 12BEh of IBMDOS.COM (MSDOS 3.3), 1987
 26166                                  
 26167                                  ;CmdTab:
 26168                                  ;	db	86h, 4
 26169                                  ;	db	86h, 5
 26170                                  ;	db	87h, 8
 26171                                  ;	db	87h, 10
 26172                                  ;	db	86h, 7
 26173                                  ;	db	86h, 5
 26174                                  
 26175                                  ;DEV001E:
 26176                                  
 26177                                  ; 30/04/2019 - Retro DOS v4.0
 26178                                  ; DOSCODE:8413h (MSDOS 6.21, MSDOS.SYS)
 26179                                  
 26180                                  ;Break	<IOFUNC -- DO FUNCTION 1-12 I/O>
 26181                                  ;----------------------------------------------------------------------------
 26182                                  ;
 26183                                  ; Procedure Name : IOFUNC
 26184                                  ;
 26185                                  ; Inputs:
 26186                                  ;	DS:SI Points to SFT
 26187                                  ;	AH is function code
 26188                                  ;		= 0 Input
 26189                                  ;		= 1 Input Status
 26190                                  ;		= 2 Output
 26191                                  ;		= 3 Output Status
 26192                                  ;		= 4 Flush
 26193                                  ;		= 5 Input Status - System WAIT invoked for K09 if no char
 26194                                  ;				   present.
 26195                                  ;	AL = character if output
 26196                                  ; Function:
 26197                                  ;	Perform indicated I/O to device or file
 26198                                  ; Outputs:
 26199                                  ;	AL is character if input
 26200                                  ;	If a status call
 26201                                  ;		zero set if not ready
 26202                                  ;		zero reset if ready (character in AL for input status)
 26203                                  ; For regular files:
 26204                                  ;	Input Status
 26205                                  ;		Gets character but restores position
 26206                                  ;		Zero set on EOF
 26207                                  ;	Input
 26208                                  ;		Gets character advances position
 26209                                  ;		Returns ^Z on EOF
 26210                                  ;	Output Status
 26211                                  ;		Always ready
 26212                                  ; AX altered, all other registers preserved
 26213                                  ;----------------------------------------------------------------------------
 26214                                  
 26215                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26216                                  ; DOSCODE:83D8h (MSDOS 5.0, MSDOS.SYS)
 26217                                  
 26218                                  IOFUNC:
 26219 0000433C 368C16[8C03]            	MOV	[SS:IOXAD+2],SS		; SS override for IOXAD, IOSCNT, 
 26220                                  					; DEVIOBUF
 26221 00004341 36C706[8A03][BC03]      	MOV	WORD [SS:IOXAD],DEVIOBUF
 26222 00004348 36C706[8E03]0100        	MOV	WORD [SS:IOSCNT],1
 26223 0000434F 36A3[BC03]              	MOV	WORD [SS:DEVIOBUF],AX
 26224                                  	;test	byte [si+6],80h
 26225                                  	;TEST	word [SI+SF_ENTRY.sf_flags],sf_isnet ; 8000h
 26226 00004353 F6440680                	test	byte [SI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 26227 00004357 7403                    	JZ	short IOTO22		;AN000;
 26228 00004359 E9A300                  	JMP	IOTOFILE		;AN000;
 26229                                  IOTO22:
 26230                                  	;test	word [si+5],80h
 26231                                  	;TEST	word [SI+SF_ENTRY.sf_flags],devid_device 
 26232 0000435C F6440580                	test	byte [SI+SF_ENTRY.sf_flags],devid_device	
 26233 00004360 7503                    	JNZ	short IOTO33		;AN000;
 26234 00004362 E99A00                  	JMP	IOTOFILE		;AN000;
 26235                                  IOTO33:
 26236 00004365 06                      	push	es ; * (MSDOS 6.21)
 26237 00004366 E8F9C0                  	call	save_world
 26238 00004369 8CDA                    	MOV	DX,DS
 26239 0000436B 8CD3                    	MOV	BX,SS
 26240 0000436D 8EDB                    	MOV	DS,BX
 26241 0000436F 8EC3                    	MOV	ES,BX
 26242 00004371 31DB                    	XOR	BX,BX
 26243 00004373 80FC05                  	cmp	ah,5		    ; system wait enabled?
 26244 00004376 7502                    	jnz	short _no_sys_wait
 26245                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26246                                  	; 16/12/2022
 26247                                  	;or	bh,04h
 26248                                  	;;or	bx,0400H	    ; Set bit 10 in status word for driver
 26249                                  				    ; It is up to device driver to carry out
 26250                                  				    ; appropriate action.
 26251                                  	; 04/07/2024
 26252 00004378 B704                    	mov	bh,4
 26253                                  _no_sys_wait:
 26254 0000437A 891E[7F03]              	MOV	[IOCALL_REQSTAT],BX
 26255 0000437E 31DB                    	XOR	BX,BX
 26256 00004380 881E[8903]              	MOV	[IOMED],BL
 26257                                  
 26258 00004384 88E3                    	MOV	BL,AH		 	; get function
 26259 00004386 2E8AA7[2A43]            	MOV	AH,[cs:BX+LenTab]
 26260 0000438B D1E3                    	SHL	BX,1
 26261 0000438D 2E8B8F[3043]            	MOV	CX,[cs:BX+CmdTab]
 26262 00004392 BB[7C03]                	MOV	BX,IOCALL ; DOSDATA:037Ch
 26263 00004395 8826[7C03]              	MOV	[IOCALL_REQLEN],AH
 26264 00004399 882E[7E03]              	MOV	[IOCALL_REQFUNC],CH
 26265                                  
 26266 0000439D 8EDA                    	MOV	DS,DX
 26267 0000439F E86401                  	CALL	DEVIOCALL
 26268 000043A2 368B3E[7F03]            	MOV	DI,[SS:IOCALL_REQSTAT]	; SS override
 26269 000043A7 21FF                    	and	di,di
 26270 000043A9 7833                    	js	short DevErr
 26271                                  OKDevIO:
 26272 000043AB 8CD0                    	MOV	AX,SS
 26273 000043AD 8ED8                    	MOV	DS,AX
 26274                                  
 26275                                  	;cmp	ch,5
 26276 000043AF 80FD05                  	CMP	CH,DEVRDND
 26277 000043B2 7506                    	JNZ	short DNODRD
 26278 000043B4 A0[8903]                	MOV	AL,[IORCHR]
 26279 000043B7 A2[BC03]                	MOV	[DEVIOBUF],AL
 26280                                  
 26281                                  DNODRD: 
 26282 000043BA 8A26[8003]              	MOV	AH,[IOCALL_REQSTAT+1]
 26283 000043BE F6D4                    	NOT	AH			; Zero = busy, not zero = ready
 26284                                  	;and	ah,2
 26285 000043C0 80E402                  	AND	AH,STBUI>>8
 26286                                  
 26287                                  QuickReturn:				;AN000; 2/13/KK
 26288 000043C3 E885C0                  	call	restore_world
 26289 000043C6 07                      	pop	es ; * (MSDOS 6.21)
 26290                                  
 26291                                  	; SR;
 26292                                  	; We return ax = -1 if the user failed on I24. This is the case if 
 26293                                  	; IoStatFail = -1 (set after return from the I24)
 26294                                  
 26295                                  	; MSDOS 6.0
 26296 000043C7 9C                      	pushf
 26297 000043C8 36A0[8300]              	mov	al,[ss:IoStatFail]	;assume fail error
 26298 000043CC 98                      	cbw				;sign extend to word
 26299                                  	;cmp	ax,-1
 26300                                  	; 27/06/2024
 26301 000043CD 3CFF                    	cmp	al,0FFh ; -1
 26302 000043CF 7507                    	jne	short not_fail_ret
 26303 000043D1 36FE06[8300]            	inc	byte [ss:IoStatFail]
 26304 000043D6 9D                      	popf
 26305 000043D7 C3                      	retn
 26306                                  
 26307                                  not_fail_ret:
 26308 000043D8 36A1[BC03]              	mov	ax,[ss:DEVIOBUF]	;ss override
 26309 000043DC 9D                      	popf
 26310 000043DD C3                      	retn
 26311                                  
 26312                                  DevErr:
 26313 000043DE 88CC                    	MOV	AH,CL
 26314 000043E0 E8630D                  	call	CHARHARD
 26315 000043E3 3C01                    	CMP	AL,1
 26316 000043E5 7507                    	JNZ	short NO_RETRY
 26317 000043E7 E861C0                  	call	restore_world
 26318                                  	; 12/05/2019
 26319 000043EA 07                      	pop	es ; * (MSDOS 6.21)		
 26320 000043EB E94EFF                  	JMP	IOFUNC	; 10/08/2018
 26321                                  
 26322                                  NO_RETRY:
 26323                                  	; Know user must have wanted Ignore OR Fail. Make sure device shows ready
 26324                                  	; ready so that DOS doesn't get caught in a status loop when user 
 26325                                  	; simply wants to ignore the error.
 26326                                  	;
 26327                                  	; SR; If fail wanted by user set ax to special value (ax = -1). This 
 26328                                  	; should be checked by the caller on return
 26329                                  
 26330                                  					; SS override
 26331 000043EE 368026[8003]FD          	and	byte [SS:IOCALL_REQSTAT+1],0FDh
 26332                                  	;AND	BYTE [SS:IOCALL_REQSTAT+1],~(STBUI>>8)
 26333                                  
 26334                                  	; SR;
 26335                                  	; Check if user failed
 26336                                  
 26337                                  	; MSDOS 6.0
 26338 000043F4 3C03                    	cmp	al,3
 26339 000043F6 7505                    	jnz	short not_fail
 26340 000043F8 36FE0E[8300]            	dec	byte [ss:IoStatFail]	;set flag indicating fail on I24
 26341                                  not_fail:
 26342 000043FD EBAC                    	JMP	short OKDevIO
 26343                                  
 26344                                  IOTOFILE:
 26345 000043FF 08E4                    	OR	AH,AH
 26346 00004401 7421                    	JZ	short IOIN
 26347 00004403 FECC                    	DEC	AH
 26348 00004405 7405                    	JZ	short IOIST
 26349 00004407 FECC                    	DEC	AH
 26350 00004409 7411                    	JZ	short IOUT
 26351                                  IOUT_retn:	; 18/12/2022
 26352 0000440B C3                      	retn				; NON ZERO FLAG FOR OUTPUT STATUS
 26353                                  IOIST:
 26354                                  	;push	word [si+15h]
 26355 0000440C FF7415                  	PUSH	WORD [SI+SF_ENTRY.sf_position]   ; Save position
 26356                                  	;push	word [si+17h]
 26357 0000440F FF7417                  	PUSH	WORD [SI+SF_ENTRY.sf_position+2]
 26358 00004412 E80F00                  	CALL	IOIN
 26359                                  	;pop	word [si+17h]
 26360 00004415 8F4417                  	POP	WORD [SI+SF_ENTRY.sf_position+2] ; Restore position
 26361                                  	;pop	word [si+15h]
 26362 00004418 8F4415                  	POP	WORD [SI+SF_ENTRY.sf_position]
 26363 0000441B C3                      	retn
 26364                                  IOUT:
 26365 0000441C E82500                  	CALL	SETXADDR
 26366 0000441F E8CEEF                  	call	DOS_WRITE
 26367                                  	;CALL	RESTXADDR	; If you change this into a jmp don't
 26368                                  	; 18/12/2022
 26369 00004422 EB4F                    	jmp	RESTXADDR
 26370                                  ;IOUT_retn:
 26371                                  	;retn			; come crying to me when things don't
 26372                                  				; work ARR
 26373                                  IOIN:
 26374 00004424 E81D00                  	CALL	SETXADDR
 26375                                  					; SS override for DOS34_FLAG
 26376                                  	;OR	word [SS:DOS34_FLAG],Disable_EOF_I24	;AN000;
 26377                                  	;or	word [ss:DOS34_FLAG],40h
 26378                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26379                                  	; 16/12/2022
 26380 00004427 36800E[1106]40          	or	byte [ss:DOS34_FLAG],40h 
 26381 0000442D E8C0ED                  	CALL	DOS_READ
 26382                                  	;AND	word [SS:DOS34_FLAG],NO_Disable_EOF_I24 ;AN000;
 26383                                  	;and	word [SS:DOS34_FLAG],0FFBFh
 26384                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26385                                  	; 16/12/2022
 26386 00004430 368026[1106]BF          	and	byte [SS:DOS34_FLAG],0BFh ; 07/12/2022
 26387 00004436 09C9                    	OR	CX,CX			; Check EOF
 26388 00004438 E83800                  	CALL	RESTXADDR
 26389                                  					; SS override
 26390 0000443B 36A0[BC03]              	MOV	AL,[SS:DEVIOBUF]	; Get byte from trans addr
 26391 0000443F 75CA                    	jnz	short IOUT_retn	
 26392 00004441 B01A                    	MOV	AL,1AH			; ^Z if no bytes
 26393 00004443 C3                      	retn
 26394                                  
 26395                                  SETXADDR:
 26396                                  					; SS override
 26397 00004444 368F06[6C03]            	POP	WORD [SS:CALLSCNT]	; Return address
 26398                                  
 26399 00004449 06                      	push	es ; * (MSDOS 6.21)
 26400                                  
 26401 0000444A E815C0                  	call	save_world
 26402                                  					; SS override for DMAADD and THISSFT
 26403                                  	; 24/09/2023
 26404                                  	;PUSH	WORD [SS:DMAADD]	; Save Disk trans addr
 26405                                  	;PUSH	WORD [SS:DMAADD+2]
 26406 0000444D 368C1E[A005]            	MOV	[SS:THISSFT+2],DS
 26407                                  
 26408                                  ; 22/02/2024
 26409                                  %if 0
 26410                                  	push	ss
 26411                                  	pop	ds
 26412                                  
 26413                                  	; 24/09/2023
 26414                                  	push	word [DMAADD]
 26415                                  	push	word [DMAADD+2]
 26416                                  
 26417                                  	MOV	[THISSFT],SI		; Finish setting SFT pointer
 26418                                  	MOV	CX,[IOXAD+2]
 26419                                  	MOV	[DMAADD+2],CX
 26420                                  	MOV	CX,[IOXAD]
 26421                                  	MOV	[DMAADD],CX		; Set byte trans addr
 26422                                  %else
 26423                                  	; 22/02/2024 - Retro DOS v4.2
 26424                                  	; PCDOS 7.1 IBMDOS.COM
 26425                                  	
 26426 00004452 36C50E[2C03]            	lds	cx,[ss:DMAADD]		; Save Disk transfer address
 26427 00004457 51                      	push	cx
 26428 00004458 1E                      	push	ds
 26429 00004459 36C50E[8A03]            	lds	cx,[ss:IOXAD]		; Set byte trans address
 26430 0000445E 368C1E[2E03]            	mov	[ss:DMAADD+2],ds
 26431 00004463 16                      	push	ss
 26432 00004464 1F                      	pop	ds
 26433 00004465 890E[2C03]              	mov	[DMAADD],cx
 26434 00004469 8936[9E05]              	mov	[THISSFT],si
 26435                                  %endif
 26436 0000446D 8B0E[8E03]              	MOV	CX,[IOSCNT]		; ioscnt specifies length of buffer
 26437 00004471 EB10                    	JMP	SHORT RESTRET		; RETURN ADDRESS
 26438                                  
 26439                                  RESTXADDR:
 26440 00004473 8F06[6C03]              	POP	WORD [CALLSCNT]		; Return address
 26441 00004477 8F06[2E03]              	POP	WORD [DMAADD+2]		; Restore Disk trans addr
 26442 0000447B 8F06[2C03]              	POP	WORD [DMAADD]
 26443                                  
 26444 0000447F E8C9BF                  	call	restore_world
 26445                                  
 26446 00004482 07                      	pop	es ; * (MSDOS 6.21)
 26447                                  					; SS override
 26448                                  RESTRET:
 26449 00004483 36FF26[6C03]            	JMP	WORD [SS:CALLSCNT]	; Return address
 26450                                  
 26451                                  ; DOSCODE:8569h (MSDOS 6.21, MSDOS.SYS)
 26452                                  ; 21/11/2022
 26453                                  ; DOSCODE:852Eh (MSDOS 5.0, MSDOS.SYS)
 26454                                  
 26455                                  ;Break <DEV_OPEN_SFT, DEV_CLOSE_SFT - OPEN or CLOSE A DEVICE>
 26456                                  
 26457                                  ;----------------------------------------------------------------------------
 26458                                  ;**	Dev_Open_SFT - Open the Device for an SFT
 26459                                  ;
 26460                                  ;	Dev_Open_SFT issues an open call to the device associated with
 26461                                  ;	the SFT.
 26462                                  ;
 26463                                  ;	ENTRY	(ES:DI) = SFT
 26464                                  ;	EXIT	none
 26465                                  ;	USES	all
 26466                                  ;----------------------------------------------------------------------------
 26467                                  
 26468                                  DEV_OPEN_SFT:
 26469 00004488 06                      	push	es ; * (MSDOS 6.21)
 26470 00004489 E8D6BF                  	call	save_world
 26471                                  	;mov	al,0Dh	
 26472 0000448C B00D                    	MOV	AL,DEVOPN
 26473 0000448E EB06                    	JMP	SHORT DO_OPCLS
 26474                                  
 26475                                  ;----------------------------------------------------------------------------
 26476                                  ; Procedure Name : DEV_CLOSE_SFT
 26477                                  ;
 26478                                  ; Inputs:
 26479                                  ;	ES:DI Points to SFT
 26480                                  ; Function:
 26481                                  ;	Issue a CLOSE call to the correct device
 26482                                  ; Outputs:
 26483                                  ;	None
 26484                                  ; ALL preserved
 26485                                  ;----------------------------------------------------------------------------
 26486                                  
 26487                                  DEV_CLOSE_SFT:
 26488 00004490 06                      	push	es ; * (MSDOS 6.21)
 26489 00004491 E8CEBF                  	call	save_world
 26490                                  	;mov	al,0Eh	
 26491 00004494 B00E                    	MOV	AL,DEVCLS
 26492                                  
 26493                                  	; Main entry for device open and close. AL contains the function 
 26494                                  	; requested. Subtlety: if Sharing is NOT loaded then we do NOT issue 
 26495                                  	; open/close to block devices. This allows networks to function but 
 26496                                  	; does NOT hang up with bogus change-line code.
 26497                                  
 26498                                  	;entry	DO_OPCLS
 26499                                  DO_OPCLS:
 26500                                  	; Is the SFT for the net? If so, no action necessary.
 26501                                  
 26502                                  	; MSDOS 6.0
 26503                                  	;test	word [es:di+5],8000h
 26504                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 26505 00004496 26F6450680              	test	byte [es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 26506 0000449B 7564                    	jnz	short OPCLS_DONE	; NOP on net SFTs
 26507 0000449D 30E4                    	XOR	AH,AH			; Unit
 26508                                  	;test	byte [es:di+5],80h
 26509 0000449F 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 26510                                  	;les	di,[es:di+7]
 26511 000044A4 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get DPB or device
 26512 000044A8 7511                    	JNZ	short GOT_DEV_ADDR
 26513                                  
 26514                                  	; We are about to call device open/close on a block driver. If no 
 26515                                  	; sharing then just short circuit to done.
 26516                                  	
 26517                                  	; MSDOS 6.0
 26518                                  					; SS override
 26519 000044AA 36803E[0303]01          	CMP	byte [ss:fShare],1	;AN010; /NC or no SHARE
 26520 000044B0 764F                    	JBE	short OPCLS_DONE	;AN010; yes
 26521                                  
 26522                                  ; 22/02/2024
 26523                                  %if 0
 26524                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26525                                  	;mov	ah,[es:di+1]
 26526                                  	MOV	AH,[ES:DI+DPB.UNIT]	; (ah) = unit
 26527                                  	mov	cl,[es:di]
 26528                                  	;MOV	CL,[ES:DI+DPB.DRIVE]	; (cl) = drive
 26529                                  %else
 26530                                  	; 22/02/2024 - Retro DOS v4.2
 26531                                  	; (PCDOS 7.1 IBMDOS.COM)
 26532                                  	;mov	cx,[es:di+DPB.DRIVE]
 26533 000044B2 268B0D                  	mov	cx,[es:di]
 26534 000044B5 88EC                    	mov	ah,ch			; AH = unit
 26535                                  					; CL = drive
 26536                                  %endif
 26537                                  
 26538                                  	;;les	di,[es:di+12h] ; MSDOS 3.3
 26539                                  	;les	di,[es:di+13h] ; MSDOS 6.0
 26540 000044B7 26C47D13                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Get device
 26541                                  GOT_DEV_ADDR:				; ES:DI -> device
 26542                                  	;test	word [es:di+4],800h
 26543                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL
 26544 000044BB 26F6450508              	test	byte [ES:DI+SYSDEV.ATT+1],(DEVOPCL>>8)
 26545 000044C0 743F                    	JZ	short OPCLS_DONE	; Device can't
 26546 000044C2 06                      	PUSH	ES
 26547 000044C3 1F                      	POP	DS
 26548 000044C4 89FE                    	MOV	SI,DI			; DS:SI -> device
 26549                                  
 26550                                  OPCLS_RETRY:
 26551                                  	;Context ES
 26552 000044C6 16                      	push	ss
 26553 000044C7 07                      	pop	es
 26554                                  					; DEVCALL is in DOSDATA
 26555 000044C8 BF[5A03]                	MOV	DI,DEVCALL
 26556                                  
 26557 000044CB 89FB                    	MOV	BX,DI
 26558 000044CD 50                      	PUSH	AX
 26559                                  	;mov	al,13
 26560 000044CE B00D                    	MOV	AL,DOPCLHL
 26561 000044D0 AA                      	STOSB				; Length
 26562 000044D1 58                      	POP	AX
 26563                                  
 26564 000044D2 86E0                    	XCHG	AH,AL
 26565                                  	;STOSB				; Unit
 26566                                  	; 22/02/2024 (PCDOS 7.1 IBMDOS.COM)
 26567 000044D4 AB                      	stosw				; Unit, Command
 26568 000044D5 86E0                    	XCHG	AH,AL
 26569                                  	;STOSB				; Command
 26570                                  
 26571 000044D7 26C7050000              	MOV	WORD [ES:DI],0		; Status
 26572 000044DC 50                      	PUSH	AX			; Save Unit,Command
 26573                                  	;invoke	DEVIOCALL2
 26574 000044DD E82900                  	call	DEVIOCALL2
 26575                                  
 26576                                  	;mov	di,[es:bx+3]
 26577 000044E0 268B7F03                	MOV	DI,[ES:BX+SRHEAD.REQSTAT]
 26578                                  	;test	di,8000h
 26579                                  	;jz	short OPCLS_DONEP	
 26580 000044E4 21FF                    	and	di,di
 26581 000044E6 7918                    	jns	short OPCLS_DONEP	; No error
 26582                                  	; 21/11/2022
 26583                                  	;test	word [si+4],8000h
 26584                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP
 26585                                  	;test	word [si+5],80h
 26586 000044E8 F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8)
 26587 000044EC 7404                    	JZ	short BLKDEV
 26588 000044EE B486                    	MOV	AH,86H			; Read error in data, Char dev
 26589 000044F0 EB04                    	JMP	SHORT HRDERR
 26590                                  BLKDEV:
 26591 000044F2 88C8                    	MOV	AL,CL			; Drive # in AL
 26592 000044F4 B406                    	MOV	AH,6			; Read error in data, Blk dev
 26593                                  HRDERR:
 26594                                  	;invoke	CHARHARD
 26595 000044F6 E84D0C                  	call	CHARHARD
 26596 000044F9 3C01                    	cmp	al,1
 26597 000044FB 7503                    	jne	short OPCLS_DONEP	; IGNORE or FAIL
 26598                                  					;  Note that FAIL is essentually IGNORED
 26599 000044FD 58                      	POP	AX			; Get back Unit, Command
 26600 000044FE EBC6                    	JMP	short OPCLS_RETRY
 26601                                  OPCLS_DONEP:
 26602 00004500 58                      	POP	AX			; Clean stack
 26603                                  OPCLS_DONE:
 26604 00004501 E847BF                  	call	restore_world
 26605 00004504 07                      	pop	es ; * (MSDOS 6.21)
 26606 00004505 C3                      	retn
 26607                                  
 26608                                  ; 30/04/2019 - Retro DOS v4.0
 26609                                  ; DOSCODE:85EAh (MSDOS 6.21, MSDOS.SYS)
 26610                                  
 26611                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26612                                  ; DOSCODE:85AFh (MSDOS 5.0, MSDOS.SYS)
 26613                                  
 26614                                  ;Break	<DEVIOCALL, DEVIOCALL2 - CALL A DEVICE>
 26615                                  ;----------------------------------------------------------------------------
 26616                                  ;**	DevIoCall  - Call Device
 26617                                  ;
 26618                                  ;	ENTRY	DS:SI Points to device SFT
 26619                                  ;		ES:BX Points to request data
 26620                                  ;	EXIT	DS:SI -> Device driver
 26621                                  ;	USES	DS:SI,AX
 26622                                  ;----------------------------------------------------------------------------
 26623                                  ;**	DevIoCall2 - Call Device
 26624                                  ;
 26625                                  ;	ENTRY	DS:SI Points to DPB
 26626                                  ;		ES:BX Points to request data
 26627                                  ;	EXIT	DS:SI -> Device driver
 26628                                  ;	USES	DS:SI,AX
 26629                                  ;----------------------------------------------------------------------------
 26630                                  
 26631                                  DEVIOCALL:
 26632                                  					; SS override for CALLSSEC, 
 26633                                  	;lds	si,[si+7]		; CALLNEWSC, HIGH_SECTOR & CALLDEVAD
 26634 00004506 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 26635                                  
 26636                                  	;entry	DEVIOCALL2
 26637                                  DEVIOCALL2:
 26638                                  	;EnterCrit critDevice
 26639 00004509 E80BCE                  	call	ECritDevice
 26640                                  
 26641                                  	; MSDOS 6.0
 26642                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP ;AN000; >32mb block device ?
 26643                                  	;test	byte [si+5],80h
 26644 0000450C F6440580                	test	byte [si+SYSDEV.ATT+1],(DEVTYP>>8)
 26645 00004510 7545                    	jnz	short chardev2		;AN000; >32mb no
 26646                                  
 26647                                  	; 16/12/2022
 26648                                  	; 22/11/2022
 26649 00004512 268A4702                	mov	al,[ES:BX+SRHEAD.REQFUNC] ; [es:bx+2]
 26650 00004516 3C04                    	cmp	al,DEVRD	; 4
 26651 00004518 7408                    	je	short chkext	
 26652 0000451A 3C08                    	cmp	al,DEVWRT	; 8
 26653 0000451C 7404                    	je	short chkext
 26654 0000451E 3C09                    	cmp	al,DEVWRTV	; 9
 26655 00004520 7535                    	jne	short chardev2
 26656                                  
 26657                                  	; 16/12/2022
 26658                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26659                                  	;;cmp	byte [es:bx+2],4
 26660                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVRD  ;AN000; >32mb read ?
 26661                                  	;JZ	short chkext		;AN000; >32mb   yes
 26662                                  	;;cmp	byte [es:bx+2],8
 26663                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRT ;AN000; >32mb write ?
 26664                                  	;JZ	short chkext		;AN000; >32mb   yes
 26665                                  	;;cmp	byte [es:bx+2],9
 26666                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRTV
 26667                                  	;				;AN000; >32mb write/verify ?
 26668                                  	;JNZ	short chardev2		;AN000; >32mb no
 26669                                  chkext:
 26670 00004522 E8A400                  	CALL	RW_SC			;AN000;LB. use secondary cache if there
 26671 00004525 7252                    	JC	short dev_exit		;AN000;LB. done
 26672                                  
 26673                                  	;test	byte [si+4],2
 26674 00004527 F6440402                	TEST	byte [SI+SYSDEV.ATT],EXTDRVR ;AN000;>32mb extended driver?
 26675 0000452B 741A                    	JZ	short chksector		;AN000;>32mb   no
 26676 0000452D 26800708                	ADD	BYTE [ES:BX],8		;AN000;>32mb   make length to 30
 26677                                  
 26678                                  	;MOV	AX,[SS:CALLSSEC]	;AN000;>32mb
 26679                                  	;MOV	word [SS:CALLSSEC],-1	;AN000;>32mb   old sector  =-1
 26680                                  	; 22/02/2024
 26681 00004531 B8FFFF                  	mov	ax,-1 ; 0FFFFh
 26682 00004534 368706[6E03]            	xchg    ax,[ss:CALLSSEC]
 26683                                  
 26684 00004539 36A3[7403]              	MOV	[SS:CALLNEWSC],AX	;AN000;>32mb   new sector  =
 26685 0000453D 36A1[0706]              	MOV	AX,[SS:HIGH_SECTOR]	;AN000; >32mb  low sector,high sector
 26686 00004541 36A3[7603]              	MOV	[SS:CALLNEWSC+2],AX	;AN000; >32mb
 26687 00004545 EB10                    	JMP	short chardev2		;AN000; >32mb
 26688                                  chksector:				;AN000; >32mb
 26689 00004547 36833E[0706]00          	CMP	word [SS:HIGH_SECTOR],0	;AN000; >32mb   if >32mb
 26690 0000454D 7408                    	JZ	short chardev2		;AN000; >32mb   then fake error
 26691                                  	;mov	word [es:bx+3],8107h
 26692 0000454F 26C747030781            	MOV	word [ES:BX+SRHEAD.REQSTAT],STERR+STDON+error_I24_not_DOS_disk 
 26693                                  					;AN000; >32mb
 26694 00004555 EB22                    	JMP	SHORT dev_exit		;AN000; >32mb
 26695                                  
 26696                                  chardev2:				;AN000;
 26697                                  	; As above only DS:SI points to device header on entry, and DS:SI is 
 26698                                  	; preserved
 26699                                  
 26700                                  	;mov	ax,[si+6]
 26701 00004557 8B4406                  	MOV	AX,[SI+SYSDEV.STRAT]
 26702 0000455A 36A3[7803]              	MOV	[SS:CALLDEVAD],AX
 26703 0000455E 368C1E[7A03]            	MOV	[SS:CALLDEVAD+2],DS
 26704 00004563 36FF1E[7803]            	CALL	far [SS:CALLDEVAD]
 26705                                  
 26706                                  	;mov	ax,[si+8]
 26707 00004568 8B4408                  	MOV	AX,[SI+SYSDEV.INT]
 26708 0000456B 36A3[7803]              	MOV	[SS:CALLDEVAD],AX
 26709 0000456F 36FF1E[7803]            	CALL	far [SS:CALLDEVAD]
 26710                                  
 26711                                  	; MSDOS 6.0
 26712 00004574 E84801                  	CALL	VIRREAD 		;AN000;LB. move data from SC to buffer
 26713 00004577 72DE                    	JC	short chardev2		;AN000;LB. bad sector or exceeds max sec
 26714                                  
 26715                                  dev_exit:
 26716                                  	;LeaveCrit critDevice
 26717                                  	;call	LCritDevice
 26718                                  	;retn
 26719                                  	; 18/12/2022
 26720 00004579 E9B6CD                  	jmp	LCritDevice
 26721                                  
 26722                                  ; DOSCODE:8669h (MSDOS 6.21, MSDOS.SYS)
 26723                                  ; 22/11/2022
 26724                                  ; DOSCODE:862Eh (MSDOS 5.0, MSDOS.SYS)
 26725                                  
 26726                                  ;Break	<SETREAD, SETWRITE -- SET UP HEADER BLOCK>
 26727                                  ;---------------------------------------------------------------------------
 26728                                  ;
 26729                                  ; Procedure Name : SETREAD, SETWRITE
 26730                                  ;
 26731                                  ; Inputs:
 26732                                  ;	DS:BX = Transfer Address
 26733                                  ;	CX = Record Count
 26734                                  ;	DX = Starting Record
 26735                                  ;	AH = Media Byte
 26736                                  ;	AL = Unit Code
 26737                                  ; Function:
 26738                                  ;	Set up the device call header at DEVCALL
 26739                                  ; Output:
 26740                                  ;	ES:BX Points to DEVCALL
 26741                                  ; No other registers effected
 26742                                  ;
 26743                                  ;---------------------------------------------------------------------------
 26744                                  
 26745                                  SETREAD_XJ:
 26746                                  	;;;
 26747                                  	; 07/02/2024 - Retro DOS v4.2
 26748 0000457C 89FB                    	mov	bx,di
 26749 0000457E EB07                    	jmp	short SETREAD_X
 26750                                  	;;;
 26751                                  
 26752                                  SETREAD_XT:
 26753                                  	;;;
 26754                                  	; 07/02/2024 - Retro DOS v4.2
 26755 00004580 BB[B603]                	mov	bx,TIMEBUF
 26756 00004583 53                      	push	bx
 26757                                  SETREAD_XTC:
 26758 00004584 B90600                  	mov	cx,6
 26759                                  	;;;
 26760                                  SETREAD_X:
 26761                                  	;;;
 26762                                  	; 06/02/2024 - Retro DOS v4.2
 26763 00004587 31C0                    	xor	ax,ax
 26764                                  	;mov	dx,ax ; 0
 26765 00004589 99                      	cwd
 26766                                  	;;;
 26767                                  
 26768                                  ; ------------------------------------
 26769                                  
 26770                                  SETREAD:
 26771 0000458A 57                      	PUSH	DI
 26772 0000458B 51                      	PUSH	CX
 26773 0000458C 50                      	PUSH	AX
 26774 0000458D B104                    	MOV	CL,DEVRD ; mov cl,4
 26775                                  SETCALLHEAD:
 26776 0000458F B016                    	MOV	AL,DRDWRHL ; mov al,16h
 26777 00004591 16                      	PUSH	SS
 26778 00004592 07                      	POP	ES
 26779                                  					; DEVCALL is in DOSDATA
 26780 00004593 BF[5A03]                	MOV	DI,DEVCALL
 26781                                  
 26782 00004596 AA                      	STOSB				; length
 26783 00004597 58                      	POP	AX			; 
 26784 00004598 AA                      	STOSB				; Unit
 26785 00004599 50                      	PUSH	AX
 26786 0000459A 88C8                    	MOV	AL,CL
 26787 0000459C AA                      	STOSB				; Command code
 26788 0000459D 31C0                    	XOR	AX,AX
 26789 0000459F AB                      	STOSW				; Status
 26790 000045A0 83C708                  	ADD	DI,8			; Skip link fields
 26791 000045A3 58                      	POP	AX
 26792 000045A4 86E0                    	XCHG	AH,AL
 26793 000045A6 AA                      	STOSB				; Media byte
 26794 000045A7 86C4                    	XCHG	AL,AH
 26795 000045A9 50                      	PUSH	AX
 26796 000045AA 89D8                    	MOV	AX,BX
 26797 000045AC AB                      	STOSW
 26798                                  
 26799 000045AD 8CD8                    	MOV	AX,DS
 26800 000045AF AB                      	STOSW				; Transfer addr
 26801                                  
 26802 000045B0 59                      	POP	CX			; Real AX
 26803 000045B1 58                      	POP	AX			; Real CX
 26804 000045B2 AB                      	STOSW				; Count
 26805                                  
 26806 000045B3 92                      	XCHG	AX,DX			; AX=Real DX, DX=real CX, CX=real AX
 26807 000045B4 AB                      	STOSW				; Start
 26808 000045B5 91                      	XCHG	AX,CX
 26809 000045B6 87D1                    	XCHG	DX,CX
 26810 000045B8 5F                      	POP	DI
 26811                                  					; DEVCALL is in DOSDATA
 26812 000045B9 BB[5A03]                	MOV	BX,DEVCALL
 26813 000045BC C3                      	retn
 26814                                  
 26815                                  	;entry	SETWRITE
 26816                                  SETWRITE:
 26817                                  
 26818                                  ; Inputs:
 26819                                  ;	DS:BX = Transfer Address
 26820                                  ;	CX = Record Count
 26821                                  ;	DX = Starting Record
 26822                                  ;	AH = Media Byte
 26823                                  ;	AL = Unit Code
 26824                                  ; Function:
 26825                                  ;	Set up the device call header at DEVCALL
 26826                                  ; Output:
 26827                                  ;	ES:BX Points to DEVCALL
 26828                                  ; No other registers effected
 26829                                  
 26830 000045BD 57                      	PUSH	DI
 26831 000045BE 51                      	PUSH	CX
 26832 000045BF 50                      	PUSH	AX
 26833 000045C0 B108                    	MOV	CL,DEVWRT ; mov cl,8
 26834 000045C2 36020E[FF02]            	ADD	CL,[SS:VERFLG]		; SS override
 26835 000045C7 EBC6                    	JMP	SHORT SETCALLHEAD
 26836                                  
 26837                                  ; 30/04/2019 - Retro DOS v4.0
 26838                                  ; DOSCODE:86A8h (MSDOS 6.21, MSDOS.SYS)
 26839                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26840                                  ; DOSCODE:866Dh (MSDOS 5.0, MSDOS.SYS)
 26841                                  
 26842                                  ;Break	<RW_SC -- Read Write Secondary Cache>
 26843                                  ;---------------------------------------------------------------------------
 26844                                  ;
 26845                                  ; Procedure Name : RW_SC
 26846                                  ;
 26847                                  ; Inputs:
 26848                                  ;	 [SC_CACHE_COUNT]= secondary cache count
 26849                                  ;	 [SC_STATUS]= SC validity status
 26850                                  ;	 [SEQ_SECTOR]= last sector read
 26851                                  ; Function:
 26852                                  ;	Read from or write through secondary cache
 26853                                  ; Output:
 26854                                  ;	ES:BX Points to DEVCALL
 26855                                  ;	carry clear, I/O is not done
 26856                                  ;		     [SC_FLAG]=1 if continuos sectors will be read
 26857                                  ;	carry set, I/O is done
 26858                                  ;
 26859                                  ;----------------------------------------------------------------------------
 26860                                  
 26861                                  RW_SC:
 26862                                  	; SS override for all variables used.
 26863                                  	
 26864 000045C9 36833E[7700]00          	CMP	word [ss:SC_CACHE_COUNT],0  ;AN000;LB. secondary cache exists?
 26865 000045CF 7421                    	JZ	short scexit4		    ;AN000;LB. no, do nothing
 26866 000045D1 36833E[6C03]01          	CMP	word [ss:CALLSCNT],1	    ;AN000;LB. sector count = 1 (buffer I/O)
 26867 000045D7 7519                    	JNZ	short scexit4 		    ;AN000;LB. no, do nothing
 26868 000045D9 51                      	PUSH	CX			    ;AN000;LB.
 26869 000045DA 52                      	PUSH	DX			    ;AN000;LB. yes
 26870 000045DB 1E                      	PUSH	DS			    ;AN000;LB. save registers
 26871 000045DC 56                      	PUSH	SI			    ;AN000;LB.
 26872 000045DD 06                      	PUSH	ES			    ;AN000;LB.
 26873 000045DE 57                      	PUSH	DI			    ;AN000;LB.
 26874                                  
 26875 000045DF 368B16[6E03]            	MOV	DX,[ss:CALLSSEC]	    ;AN000;LB. starting sector
 26876 000045E4 36803E[5C03]04          	CMP	BYTE [ss:DEVCALL_REQFUNC],DEVRD ;AN000;LB. read ?
 26877 000045EA 7408                    	JZ	short doread		    ;AN000;LB. yes
 26878 000045EC E8BE00                  	CALL	INVALIDATE_SC		    ;AN000;LB. invalidate SC
 26879 000045EF E98B00                  	JMP	scexit2 		    ;AN000;LB. back to normal
 26880                                  scexit4:				    ;AN000;
 26881 000045F2 F8                      	CLC				    ;AN000;LB. I/O not done yet
 26882 000045F3 C3                      	retn				    ;AN000;LB.
 26883                                  doread: 				    ;AN000;
 26884 000045F4 E82001                  	CALL	SC2BUF			    ;AN000;LB. check if in SC
 26885 000045F7 720A                    	JC	short readSC		    ;AN000;LB.
 26886 000045F9 36C706[5D03]0001        	MOV	word [ss:DEVCALL_REQSTAT],STDON ;AN000;LB. fake done and ok
 26887 00004600 F9                      	STC				    ;AN000;LB. set carry
 26888 00004601 EB68                    	JMP	short saveseq 		    ;AN000;LB. save seq. sector #
 26889                                  readSC: 				    ;AN000;
 26890 00004603 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]   	    ;AN000;LB. subtract sector num from
 26891 00004607 368B0E[6E03]            	MOV	CX,[ss:CALLSSEC]	    ;AN000;LB. saved sequential sector
 26892 0000460C 362B0E[A90D]            	SUB	CX,[ss:SEQ_SECTOR]    	    ;AN000;LB. number
 26893 00004611 361B06[AB0D]            	SBB	AX,[ss:SEQ_SECTOR+2]  	    ;AN000;LB.
 26894                                  	; 24/09/2023
 26895                                  	;CMP	AX,0			    ;AN000;LB. greater than 64K
 26896 00004616 7552                    	JNZ	short saveseq2		    ;AN000;LB. yes,save seq. sector #
 26897                                  chklow: 						
 26898 00004618 83F901                  	CMP	CX,1			    ;AN000;LB. <= 1
 26899 0000461B 774D                    	JA	short saveseq2		    ;AN000;LB. no, not sequential
 26900 0000461D 36C706[B50D]FFFF        	MOV	word [ss:SC_STATUS],-1	    ;AN000;LB. presume all SC valid
 26901 00004624 36A1[7700]              	MOV	AX,[ss:SC_CACHE_COUNT]	    ;AN000;LB. yes, sequential
 26902 00004628 36A3[6C03]              	MOV	[ss:CALLSCNT],AX	    ;AN000;LB. read continuous sectors
 26903                                  readsr:
 26904 0000462C 36A1[6A03]              	MOV	AX,[ss:CALLXAD+2]	    ;AN000;LB. save buffer addr
 26905 00004630 36A3[0E06]              	MOV	[ss:TEMP_VAR2],AX	    ;AN000;LB. in temp vars
 26906 00004634 36A1[6803]              	MOV	AX,[ss:CALLXAD]	    	    ;AN000;LB.
 26907 00004638 36A3[0C06]              	MOV	[ss:TEMP_VAR],AX	    ;AN000;LB.
 26908                                  
 26909 0000463C 36A1[7300]              	MOV	AX,[ss:SC_CACHE_PTR]	    ;AN000;LB. use SC cache addr as
 26910 00004640 36A3[6803]              	MOV	[ss:CALLXAD],AX		    ;AN000;LB. transfer addr
 26911 00004644 36A1[7500]              	MOV	AX,[ss:SC_CACHE_PTR+2]	    ;AN000;LB.
 26912 00004648 36A3[6A03]              	MOV	[ss:CALLXAD+2],AX	    ;AN000;LB.
 26913 0000464C 36C606[B70D]01          	MOV	byte [ss:SC_FLAG],1	    ;AN000;LB. flag it for later;
 26914 00004652 36A0[AF0D]              	MOV	AL,[ss:SC_DRIVE]	    ;AN000;LB. current drive
 26915 00004656 36A2[B00D]              	MOV	[ss:CurSC_DRIVE],AL	    ;AN000;LB. set current drive
 26916 0000465A 36A1[6E03]              	MOV	AX,[ss:CALLSSEC]	    ;AN000;LB. current sector
 26917 0000465E 36A3[B10D]              	MOV	[ss:CurSC_SECTOR],AX	    ;AN000;LB. set current sector
 26918 00004662 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;LB.
 26919 00004666 36A3[B30D]              	MOV	[ss:CurSC_SECTOR+2],AX	    ;AN000;LB.
 26920                                  saveseq2:				    ;AN000;
 26921 0000466A F8                      	CLC				    ;AN000;LB. clear carry
 26922                                  saveseq:				    ;AN000;	
 26923 0000466B 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;LB. save current sector #
 26924 0000466F 36A3[AB0D]              	MOV	[ss:SEQ_SECTOR+2],AX	    ;AN000;LB. for access mode ref.
 26925 00004673 36A1[6E03]              	MOV	AX,[ss:CALLSSEC]	    ;AN000;LB.	
 26926 00004677 36A3[A90D]              	MOV	[ss:SEQ_SECTOR],AX 	    ;AN000;LB.	
 26927 0000467B EB01                    	JMP	short scexit 		    ;AN000;LB.	
 26928                                  scexit2:				    ;AN000;LB.
 26929 0000467D F8                      	CLC				    ;AN000;LB.	clear carry
 26930                                  scexit: 				    ;AN000;		
 26931 0000467E 5F                      	POP	DI			    ;AN000;LB.
 26932 0000467F 07                      	POP	ES			    ;AN000;LB. restore registers
 26933 00004680 5E                      	POP	SI			    ;AN000;LB.
 26934 00004681 1F                      	POP	DS			    ;AN000;LB.
 26935 00004682 5A                      	POP	DX			    ;AN000;LB.
 26936 00004683 59                      	POP	CX			    ;AN000;LB.
 26937 00004684 C3                      	retn				    ;AN000;LB.
 26938                                  
 26939                                  ;Break	<IN_SC -- check if in secondary cache>
 26940                                  ;--------------------------------------------------------------------------
 26941                                  ;
 26942                                  ; Procedure Name : IN_SC
 26943                                  ;
 26944                                  ; Inputs:  [SC_DRIVE]= requesting drive
 26945                                  ;	   [CURSC_DRIVE]= current SC drive
 26946                                  ;	   [CURSC_SECTOR]= starting scetor # of SC
 26947                                  ;	   [SC_CACHE_COUNT]= SC count
 26948                                  ;	   [HIGH_SECTOR]:DX= sector number
 26949                                  ; Function:
 26950                                  ;	Check if the sector is in secondary cache
 26951                                  ; Output:
 26952                                  ;	carry clear, in SC
 26953                                  ;	   CX= the index in the secondary cache
 26954                                  ;	carry set, not in SC
 26955                                  ;
 26956                                  ;---------------------------------------------------------------------------
 26957                                  
 26958                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26959                                  IN_SC:
 26960                                  	; SS override for all variables used
 26961 00004685 36A0[AF0D]              	MOV	AL,[ss:SC_DRIVE]	    ;AN000;;LB. current drive
 26962 00004689 363A06[B00D]            	CMP	AL,[ss:CurSC_DRIVE]	    ;AN000;;LB. same as SC drive
 26963 0000468E 751B                    	JNZ	short outrange2		    ;AN000;;LB. no
 26964 00004690 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;;LB. subtract sector num from
 26965 00004694 89D1                    	MOV	CX,DX			    ;AN000;;LB. secondary starting sector
 26966 00004696 362B0E[B10D]            	SUB	CX,[ss:CurSC_SECTOR]        ;AN000;;LB. number
 26967 0000469B 361B06[B30D]            	SBB	AX,[ss:CurSC_SECTOR+2]      ;AN000;;LB.
 26968                                  	; 24/09/2023
 26969                                  	;CMP	AX,0			    ;AN000;;LB. greater than 64K
 26970 000046A0 7509                    	JNZ	short outrange2		    ;AN000;;LB. yes
 26971 000046A2 363B0E[7700]            	CMP	CX,[ss:SC_CACHE_COUNT]	    ;AN000;;LB. greater than SC count
 26972 000046A7 7302                    	JAE	short outrange2		    ;AN000;;LB. yes
 26973 000046A9 F8                      	CLC				    ;AN000;;LB. clear carry
 26974                                  	;JMP	short inexit		    ;AN000;;LB. in SC
 26975                                  	; 16/12/2022
 26976 000046AA C3                      	retn	; 30/04/2019
 26977                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26978                                  	;jmp	short inexit
 26979                                  
 26980                                  outrange2:				    ;AN000;;LB. set carry
 26981 000046AB F9                      	STC				    ;AN000;;LB.
 26982                                  inexit: 				    ;AN000;;LB.
 26983 000046AC C3                      	retn				    ;AN000;;LB.
 26984                                  
 26985                                  ;Break	<INVALIDATE_SC - invalide secondary cache>
 26986                                  ;---------------------------------------------------------------------------
 26987                                  ;
 26988                                  ; Procedure Name : Invalidate_Sc
 26989                                  ;
 26990                                  ; Inputs:  [SC_DRIVE]= requesting drive
 26991                                  ;	   [CURSC_DRIVE]= current SC drive
 26992                                  ;	   [CURSC_SECTOR]= starting scetor # of SC
 26993                                  ;	   [SC_CACHE_COUNT]= SC count
 26994                                  ;	   [SC_STATUS]= SC status word
 26995                                  ;	   [HIGH_SECTOR]:DX= sector number
 26996                                  ;
 26997                                  ; Function:
 26998                                  ;	invalidate secondary cache if in there
 26999                                  ; Output:
 27000                                  ;	[SC_STATUS] is updated
 27001                                  ;---------------------------------------------------------------------------
 27002                                  
 27003                                  INVALIDATE_SC:
 27004                                  	; SS override for all variables used
 27005                                  
 27006 000046AD E8D5FF                  	CALL	IN_SC			    ;AN000;;LB. in secondary cache
 27007 000046B0 720C                    	JC	short outrange		    ;AN000;;LB. no
 27008 000046B2 B80100                  	MOV	AX,1			    ;AN000;;LB. invalidate the sector
 27009 000046B5 D3E0                    	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
 27010 000046B7 F7D0                    	NOT	AX			    ;AN000;;LB.
 27011 000046B9 362106[B50D]            	AND	[ss:SC_STATUS],AX	    ;AN000;;LB. save the status
 27012                                  outrange:				    ;AN000;;LB.
 27013 000046BE C3                      	retn				    ;AN000;;LB.
 27014                                  
 27015                                  ; DOSCODE:87A5h (MSDOS 6.21, MSDOS.SYS)
 27016                                  ; 22/11/2022
 27017                                  ; DOSCODE:876Ah (MSDOS 5.0, MSDOS.SYS)
 27018                                  
 27019                                  ;Break	<VIRREAD- virtually read data into buffer>
 27020                                  ;--------------------------------------------------------------------------
 27021                                  ;
 27022                                  ; Procedure Name : SC_FLAG
 27023                                  ;
 27024                                  ; Inputs:  SC_FLAG = 0, no sectors were read into SC
 27025                                  ;		     1, continuous sectors were read into SC
 27026                                  ; Function:
 27027                                  ;	   Move data from SC to buffer
 27028                                  ; Output:
 27029                                  ;	 carry clear, data is moved to buffer
 27030                                  ;	 carry set, bad sector or exceeds maximum sector
 27031                                  ;	   SC_FLAG =0
 27032                                  ;	   CALLSCNT=1
 27033                                  ;	   SC_STATUS= -1 if succeeded
 27034                                  ;     
 27035                                  ;		       0 if failed
 27036                                  ;--------------------------------------------------------------------------
 27037                                  
 27038                                  VIRREAD:
 27039                                  	; SS override for all variables used
 27040                                  
 27041 000046BF 36803E[B70D]00          	CMP	byte [ss:SC_FLAG],0	    ;AN000;;LB. from SC fill
 27042 000046C5 744E                    	JZ	short sc2end		    ;AN000;;LB. no
 27043 000046C7 36A1[0E06]              	MOV	AX,[ss:TEMP_VAR2]	    ;AN000;;LB. restore buffer addr
 27044 000046CB 36A3[6A03]              	MOV	[ss:CALLXAD+2],AX	    ;AN000;;LB.
 27045 000046CF 36A1[0C06]              	MOV	AX,[ss:TEMP_VAR]	    ;AN000;;LB.
 27046 000046D3 36A3[6803]              	MOV	[ss:CALLXAD],AX		    ;AN000;;LB.
 27047 000046D7 36C606[B70D]00          	MOV	byte [ss:SC_FLAG],0	    ;AN000;;LB. reset sc_flag
 27048 000046DD 36C706[6C03]0100        	MOV	word [ss:CALLSCNT],1	    ;AN000;;LB. one sector transferred
 27049                                  
 27050                                  	;TEST	word [SS:DEVCALL_REQSTAT],STERR ;AN000;;LB. error?
 27051 000046E4 36F606[5E03]80          	test	byte [ss:DEVCALL_REQSTAT+1],(STERR>>8) ; 80h
 27052 000046EA 7513                    	JNZ	short scerror 		    ;AN000;;LB. yes
 27053 000046EC 1E                      	PUSH	DS			    ;AN000;;LB.
 27054 000046ED 56                      	PUSH	SI			    ;AN000;;LB.
 27055 000046EE 06                      	PUSH	ES			    ;AN000;;LB.
 27056 000046EF 57                      	PUSH	DI			    ;AN000;;LB.
 27057 000046F0 52                      	PUSH	DX			    ;AN000;;LB.
 27058 000046F1 51                      	PUSH	CX			    ;AN000;;LB.
 27059 000046F2 31C9                    	XOR	CX,CX			    ;AN000;;LB. we want first sector in SC
 27060 000046F4 E83100                  	CALL	SC2BUF2 		    ;AN000;;LB. move data from SC to buf
 27061 000046F7 59                      	POP	CX
 27062 000046F8 5A                      	POP	DX			    ;AN000;;LB.
 27063 000046F9 5F                      	POP	DI			    ;AN000;;LB.
 27064 000046FA 07                      	POP	ES			    ;AN000;;LB.
 27065 000046FB 5E                      	POP	SI			    ;AN000;;LB.
 27066 000046FC 1F                      	POP	DS			    ;AN000;;LB.
 27067 000046FD EB16                    	JMP	SHORT sc2end		    ;AN000;;LB. return
 27068                                  scerror:				    ;AN000;
 27069 000046FF 36C706[6C03]0100        	MOV	word [ss:CALLSCNT],1	    ;AN000;;LB. reset sector count to 1
 27070 00004706 36C706[B50D]0000        	MOV	word [ss:SC_STATUS],0	    ;AN000;;LB. invalidate all SC sectors
 27071 0000470D 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1    ;AN000;;LB. invalidate drive
 27072 00004713 F9                      	STC				    ;AN000;;LB. carry set
 27073 00004714 C3                      	retn				    ;AN000;;LB.
 27074                                  sc2end: 				    ;AN000;
 27075 00004715 F8                      	CLC				    ;AN000;;LB. carry clear
 27076 00004716 C3                      	retn				    ;AN000;;LB.
 27077                                  
 27078                                  ; 30/04/2019 - Retro  DOS v4.0
 27079                                  ; DOSCODE:87FDh (MSDOS 6.21, MSDOS.SYS)
 27080                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27081                                  ; DOSCODE:87C2h (MSDOS 5.0, MSDOS.SYS)
 27082                                  
 27083                                  ;Break	<SC2BUF- move data from SC to buffer>
 27084                                  ;----------------------------------------------------------------------------
 27085                                  ;
 27086                                  ; Procedure Name : SC2BUF
 27087                                  ;
 27088                                  ; Inputs:  [SC_STATUS] = SC validity status
 27089                                  ;	   [SC_SECTOR_SIZE] = request sector size
 27090                                  ;	   [SC_CACHE_PTR] = pointer to SC
 27091                                  ; Function:
 27092                                  ;	   Move data from SC to buffer
 27093                                  ; Output:
 27094                                  ;	   carry clear, in SC  and data is moved
 27095                                  ;	   carry set, not in SC and data is not moved
 27096                                  ;---------------------------------------------------------------------------
 27097                                  
 27098                                  SC2BUF:
 27099                                  	; SS override for all variables used
 27100 00004717 E86BFF                  	CALL	IN_SC			    ;AN000;LB. in secondary cache
 27101                                  	;JC	short noSC		    ;AN000;LB. no
 27102                                  	; 24/09/2023
 27103 0000471A 723D                    	jc	short sexit
 27104 0000471C B80100                  	MOV	AX,1			    ;AN000;LB. check if valid sector
 27105 0000471F D3E0                    	SHL	AX,CL			    ;AN000;LB. in the secondary cache
 27106 00004721 368506[B50D]            	TEST	[ss:SC_STATUS],AX	    ;AN000;LB.
 27107 00004726 7430                    	JZ	short noSC		    ;AN000;LB. invalid
 27108                                  ;entry SC2BUF2
 27109                                  SC2BUF2:				    ;AN000;
 27110                                  	;MOV	AX,CX			    ;AN000;LB. times index with
 27111                                  	;MUL	word [ss:SC_SECTOR_SIZE]    ;AN000;LB. sector size
 27112                                  	; 24/09/2023
 27113 00004728 36A1[AD0D]              	mov	ax,[ss:SC_SECTOR_SIZE]
 27114 0000472C 91                      	xchg	ax,cx ; cx = [ss:SC_SECTOR_SIZE]
 27115 0000472D F7E1                    	mul	cx
 27116 0000472F 360306[7300]            	ADD	AX,[ss:SC_CACHE_PTR]	    ;AN000;LB. add SC starting addr
 27117 00004734 361316[7500]            	ADC	DX,[ss:SC_CACHE_PTR+2]	    ;AN000;LB.
 27118 00004739 8EDA                    	MOV	DS,DX			    ;AN000;LB. DS:SI-> SC sector addr
 27119 0000473B 89C6                    	MOV	SI,AX			    ;AN000;LB.
 27120 0000473D 368E06[6A03]            	MOV	ES,[ss:CALLXAD+2]		    ;AN000;LB. ES:DI-> buffer addr
 27121 00004742 368B3E[6803]            	MOV	DI,[ss:CALLXAD]		    ;AN000;LB.
 27122                                  	; 24/09/2023
 27123                                  	;MOV	CX,[ss:SC_SECTOR_SIZE]	    ;AN000;LB. count= sector size
 27124 00004747 D1E9                    	SHR	CX,1			    ;AN000;LB. may use DWORD move for 386
 27125                                  ;entry MOVWORDS
 27126                                  MOVWORDS:				    ;AN000;
 27127 00004749 36803E[6A00]00          	CMP	byte [ss:DDMOVE],0	    ;AN000;LB. 386 ?
 27128 0000474F 7403                    	JZ	short nodd		    ;AN000;LB. no
 27129 00004751 D1E9                    	SHR	CX,1			    ;AN000;LB. words/2
 27130 00004753 66                      	DB	66H			    ;AN000;LB. use double word move
 27131                                  nodd:
 27132 00004754 F3A5                    	REP	MOVSW			    ;AN000;LB. move to buffer
 27133 00004756 F8                      	CLC				    ;AN000;LB. clear carry
 27134 00004757 C3                      	retn				    ;AN000;LB. exit
 27135                                  noSC:					    ;AN000;
 27136 00004758 F9                      	STC				    ;AN000;LB. set carry
 27137                                  sexit:					    ;AN000;
 27138 00004759 C3                      	retn				    ;AN000;LB.
 27139                                  
 27140                                  ;============================================================================
 27141                                  ; MKNODE.ASM, MSDOS 6.0, 1991
 27142                                  ;============================================================================
 27143                                  ; 29/07/2018 - Retro DOS v3.0
 27144                                  ; 19/05/2019 - Retro DOS v4.0
 27145                                  
 27146                                  ;	TITLE	MKNODE - Node maker
 27147                                  ;	NAME	MKNODE
 27148                                  
 27149                                  ;**	MKNODE.ASM
 27150                                  ;----------------------------------------------------------------------------
 27151                                  ;	Low level routines for making a new local file system node
 27152                                  ;	and filling in an SFT from a directory entry
 27153                                  ;
 27154                                  ;	BUILDDIR
 27155                                  ;	SETDOTENT
 27156                                  ;	MakeNode
 27157                                  ;	NEWENTRY
 27158                                  ;	FREEENT
 27159                                  ;	NEWDIR
 27160                                  ;	DOOPEN
 27161                                  ;	RENAME_MAKE
 27162                                  ;	CHECK_VIRT_OPEN
 27163                                  ;
 27164                                  ;	Revision history:
 27165                                  ;
 27166                                  ;	 AN000	version 4.0  Jan. 1988
 27167                                  ;	 A004	PTM 3680  --- Make SFT NAME field offset same as 3.30
 27168                                  
 27169                                  ;Break   <BUILDDIR,NEWDIR -- ALLOCATE DIRECTORIES>
 27170                                  ;----------------------------------------------------------------------------
 27171                                  ;
 27172                                  ; Procedure Name : BUILDDIR,NEWDIR
 27173                                  ;
 27174                                  ; Inputs:
 27175                                  ;       ES:BP Points to DPB
 27176                                  ;       [THISSFT] Set if using NEWDIR entry point
 27177                                  ;               (used by ALLOCATE)
 27178                                  ;       [LASTENT] current last valid entry number in directory if no free
 27179                                  ;               entries
 27180                                  ;       [DIRSTART] Points to first cluster of dir (0 means root)
 27181                                  ; Function:
 27182                                  ;       Grow directory if no free entries and not root
 27183                                  ; Outputs:
 27184                                  ;       CARRY SET IF FAILURE
 27185                                  ;       ELSE
 27186                                  ;          AX entry number of new entry
 27187                                  ;          If a new dir [DIRSTART],[CLUSFAC],[CLUSNUM],[DIRSEC] set
 27188                                  ;               AX = first entry of new dir
 27189                                  ;       GETENT should be called to set [LASTENT]
 27190                                  ;
 27191                                  ;----------------------------------------------------------------------------
 27192                                  
 27193                                  ; 19/05/2019 - Retro DOS v4.0
 27194                                  ; DOSCODE:8845h (MSDOS 6.21, MSDOS.SYS)
 27195                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27196                                  ; DOSCODE:880Ah (MSDOS 6.21, MSDOS.SYS)
 27197                                  
 27198                                  ; 24/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 MSDOS.SYS)
 27199                                  ; DOSCODE:8845h (MSDOS 6.22, MSDOS.SYS)
 27200                                  
 27201                                  BUILDDIR:
 27202                                  	; 29/07/2018 - Retro DOS v3.0
 27203                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 4E66h
 27204                                  
 27205 0000475A A1[D805]                        MOV     AX,[ENTFREE]
 27206 0000475D 83F8FF                          CMP     AX,-1 ; 0FFFFh
 27207                                  	;JZ	short CHECK_IF_ROOT
 27208                                          ;CLC
 27209                                          ;retn
 27210                                  	; 24/09/2023
 27211 00004760 7507                    	jne	short builddir_cmc_retn  ; cf=1 (will be 0)
 27212                                  
 27213                                  CHECK_IF_ROOT:
 27214 00004762 833E[C205]00                    CMP     word [DIRSTART],0
 27215 00004767 7502                            JNZ	short NEWDIR
 27216                                          ;STC
 27217                                  	; 24/09/2023
 27218                                  	; [DIRSTART]=0, cf=0, zf=1 (cf will be 1 after cmc instruction)
 27219                                  builddir_cmc_retn:
 27220                                  	; 24/09/2023
 27221 00004769 F5                      	cmc	; cf=1 <-> cf=0
 27222                                  builddir_retn:
 27223 0000476A C3                              retn				; Can't grow root
 27224                                  
 27225                                  	;entry   NEWDIR
 27226                                  NEWDIR: 
 27227 0000476B 8B1E[C205]              	MOV     BX,[DIRSTART]
 27228 0000476F 09DB                            OR      BX,BX
 27229 00004771 7405                            JZ	short NULLDIR
 27230 00004773 E80206                  	call	GETEOF
 27231 00004776 72F2                            jc	short builddir_retn	; Screw up
 27232                                  NULLDIR:
 27233 00004778 B90100                          MOV     CX,1
 27234 0000477B E81305                  	call	ALLOCATE
 27235 0000477E 72EA                            jc	short builddir_retn
 27236 00004780 8B16[C205]                      MOV     DX,[DIRSTART]
 27237 00004784 09D2                            OR      DX,DX
 27238 00004786 750D                            JNZ	short ADDINGDIR
 27239 00004788 E8FDF5                  	call	SETDIRSRCH
 27240 0000478B 72DD                            jc	short builddir_retn
 27241 0000478D C706[4803]FFFF                  MOV     word [LASTENT],-1
 27242 00004793 EB29                            JMP     SHORT GOTDIRREC
 27243                                  ADDINGDIR:
 27244 00004795 53                              PUSH    BX
 27245 00004796 8B1E[BC05]                      MOV     BX,[CLUSNUM]
 27246 0000479A E8F90B                          call	IsEOF
 27247 0000479D 5B                              POP     BX
 27248 0000479E 7217                            JB	short NOTFIRSTGROW
 27249                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 27250 000047A0 891E[BC05]                      MOV     [CLUSNUM],BX
 27251                                  	; 24/09/2023
 27252                                  	;PUSH	CX ; (not necessary)
 27253 000047A4 50                      	PUSH	AX
 27254 000047A5 55                      	PUSH	BP
 27255 000047A6 B401                            MOV     AH,1			; CLUSNUM update
 27256                                  	; 15/12/2022
 27257 000047A8 268A5600                	mov	dl,[ES:BP] ; 09/09/2018
 27258                                          ; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27259                                  	;;mov	dl,[es:bp+0]
 27260                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; drive #
 27261 000047AC 8B0E[C205]                      MOV     CX,[DIRSTART]		; first cluster #
 27262 000047B0 89DD                            MOV     BP,BX 			; CLUSNUM
 27263 000047B2 E8B0DE                  	call	FastOpen_Update
 27264 000047B5 5D                              POP     BP
 27265 000047B6 58                              POP     AX
 27266                                  	; 24/09/2023
 27267                                          ;POP	CX
 27268                                  
 27269                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 27270                                  NOTFIRSTGROW:
 27271 000047B7 89DA                            MOV     DX,BX
 27272 000047B9 30DB                            XOR     BL,BL
 27273 000047BB E8AF04                  	call	FIGREC
 27274                                  GOTDIRREC:
 27275                                  	;mov	cl,[es:bp+4]
 27276 000047BE 268A4E04                        MOV     CL,[ES:BP+DPB.CLUSTER_MASK]
 27277                                  	;INC	CL
 27278                                  	; 27/06/2024
 27279 000047C2 41                      	inc	cx
 27280 000047C3 30ED                            XOR     CH,CH
 27281                                  ZERODIR:
 27282 000047C5 51                              PUSH    CX
 27283                                  	; 22/09/2023
 27284                                  	;;mov	byte [ALLOWED],18h
 27285                                          ;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 27286 000047C6 B0FF                            MOV     AL,0FFH
 27287                                          ;call	GETBUFFR
 27288 000047C8 E8E80F                          call	GETBUFFRD ; *
 27289 000047CB 7302                    	JNC	short GET_SSIZE
 27290 000047CD 59                              POP     CX
 27291 000047CE C3                              retn
 27292                                  
 27293                                  GET_SSIZE:
 27294                                  	;mov	cx,[es:bp+2]
 27295 000047CF 268B4E02                        MOV     CX,[ES:BP+DPB.SECTOR_SIZE]
 27296 000047D3 06                              PUSH    ES
 27297 000047D4 C43E[E205]                      LES     DI,[CURBUF]
 27298                                  	;or	byte [es:di+5],4
 27299 000047D8 26804D0504                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 27300 000047DD 57                              PUSH    DI
 27301                                  	;;add	di,16	; MSDOS 3.3
 27302                                  	;add	di,20	; MSDOS 6.0	
 27303 000047DE 83C714                          ADD     DI,BUFINSIZ
 27304 000047E1 31C0                            XOR     AX,AX
 27305 000047E3 D1E9                            SHR     CX,1
 27306 000047E5 F3AB                            REP     STOSW
 27307 000047E7 7301                            JNC	short EVENZ
 27308 000047E9 AA                              STOSB
 27309                                  EVENZ:
 27310 000047EA 5F                              POP     DI
 27311                                  
 27312                                  ; 07/07/2024 - Retro DOS v4.2
 27313                                  %if 0
 27314                                  	; MSDOS 6.0
 27315                                  	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 27316                                  					;LB. if already dirty		  ;AN000;
 27317                                  	JNZ	short yesdirty7		;LB.  don't increment dirty count ;AN000;
 27318                                  	call	INC_DIRTY_COUNT		;LB. 				  ;AN000;
 27319                                  	
 27320                                  	;or	byte [es:di+5],40h
 27321                                  	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 27322                                  %else
 27323                                  	; 23/02/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
 27324 000047EB E8C911                  	call	SET_BUF_DIRTY
 27325                                  %endif
 27326                                  
 27327                                  yesdirty7:
 27328 000047EE 07                              POP	ES
 27329 000047EF 59                              POP	CX
 27330                                  
 27331                                  	; 19/05/2019 - Retro DOS v4.0
 27332                                  
 27333                                  	; MSDOS 3.3
 27334                                  	;INC	DX
 27335                                  
 27336                                  	; MSDOS 6.0
 27337                                  	; 24/09/2023
 27338                                  	;add	dx,1
 27339                                  	;;adc	word [HIGH_SECTOR],0
 27340                                  	;; 24/09/2023
 27341                                  	;; ax=0
 27342                                  	;adc	[HIGH_SECTOR],ax ; 0
 27343                                  	; 24/09/2023
 27344 000047F0 42                      	inc	dx
 27345 000047F1 7504                    	jnz	short loop_zerodir
 27346 000047F3 FF06[0706]              	inc	word [HIGH_SECTOR]
 27347                                  loop_zerodir:
 27348 000047F7 E2CC                            LOOP    ZERODIR
 27349                                  
 27350 000047F9 A1[4803]                        MOV     AX,[LASTENT]
 27351 000047FC 40                              INC     AX
 27352                                  	; 24/09/2023
 27353                                  	; cf=0
 27354                                  	;CLC
 27355 000047FD C3                              retn
 27356                                  
 27357                                  ;--------------------------------------------------------------------------
 27358                                  ;
 27359                                  ; Procedure Name : SETDOTENT
 27360                                  ;
 27361                                  ; set up a . or .. directory entry for a directory.
 27362                                  ;
 27363                                  ;   Inputs:     ES:DI point to the beginning of a directory entry.
 27364                                  ;               AX contains ". " or ".."
 27365                                  ;               DX contains first cluster of entry
 27366                                  ;
 27367                                  ;----------------------------------------------------------------------------
 27368                                  
 27369                                  SETDOTENT:
 27370                                  ;	Fill in name field
 27371 000047FE AB                      	STOSW
 27372 000047FF B90400                  	MOV	CX,4
 27373 00004802 B82020                  	MOV	AX,"  " ; 2020h
 27374 00004805 F3AB                    	REP	STOSW
 27375 00004807 AA                      	STOSB
 27376                                  
 27377                                  ;	Set up attribute
 27378                                  	;mov	al, 10h
 27379 00004808 B010                    	MOV	AL,attr_directory
 27380 0000480A AA                      	STOSB
 27381                                  
 27382                                  ;	Initialize time and date of creation
 27383 0000480B 83C70A                  	ADD	DI,10
 27384 0000480E 8B36[9E05]              	MOV	SI,[THISSFT]
 27385                                  	;mov	ax,[si+0Dh]
 27386 00004812 8B440D                  	MOV	AX,[SI+SF_ENTRY.sf_time]
 27387 00004815 AB                      	STOSW
 27388                                  	;mov	ax,[si+0Fh]
 27389 00004816 8B440F                  	MOV	AX,[SI+SF_ENTRY.sf_date]
 27390 00004819 AB                      	STOSW
 27391                                  
 27392                                  ;	Set up first cluster field
 27393 0000481A 89D0                    	MOV	AX,DX
 27394 0000481C AB                      	STOSW
 27395                                  
 27396                                  ;	0 file size
 27397                                  	;XOR	AX,AX
 27398 0000481D 91                      	xchg	ax,cx ; 23/02/2024
 27399 0000481E AB                      	STOSW
 27400 0000481F AB                      	STOSW
 27401 00004820 C3                      	retn
 27402                                  
 27403                                  ;Break   <MAKENODE -- CREATE A NEW NODE>
 27404                                  ;---------------------------------------------------------------------------
 27405                                  ;
 27406                                  ; Procedure Name : MakeNode
 27407                                  ;
 27408                                  ; Inputs:
 27409                                  ;       AL - attribute to create
 27410                                  ;       AH = 0 if it is ok to truncate a file already by this name
 27411                                  ;	AH != 0 if truncation not allowed (prexisting file is an error)
 27412                                  ;               (AH ignored on dirs and devices)
 27413                                  ;
 27414                                  ;        NOTE: When making a DIR or volume ID, AH need not be set since
 27415                                  ;               a name already existant is ALWAYS an error in these cases.
 27416                                  ;
 27417                                  ;       [WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 27418                                  ;               terminated)
 27419                                  ;       [CURR_DIR_END] Points to end of Current dir part of string
 27420                                  ;               ( = -1 if current dir not involved, else
 27421                                  ;                Points to first char after last "/" of current dir part)
 27422                                  ;       [THISCDS] Points to CDS being used
 27423                                  ;       [THISSFT] Points to an empty SFT. EXCEPT sf_mode filled in.
 27424                                  ; Function:
 27425                                  ;       Make a new node
 27426                                  ; Outputs:
 27427                                  ;       Sets EXTERR_LOCUS = errLOC_Disk or errLOC_Unk via GetPathNoset
 27428                                  ;       CARRY SET IF ERROR
 27429                                  ;          AX = 1 A node by this name exists and is a directory
 27430                                  ;          AX = 2 A new node could not be created
 27431                                  ;          AX = 3 A node by this name exists and is a disk file
 27432                                  ;               (AH was NZ on input)
 27433                                  ;          AX = 4 Bad Path
 27434                                  ;               SI return from GetPath maintained
 27435                                  ;          AX = 5 Attribute mismatch
 27436                                  ;          AX = 6 Sharing Violation
 27437                                  ;               (INT 24 generated ALWAYS since create is always compat mode
 27438                                  ;          AX = 7 file not found for Extended Open (not exists and fails)
 27439                                  ;       ELSE
 27440                                  ;          AX = 0 Disk Node
 27441                                  ;          AX = 3 Device Node (error in some cases)
 27442                                  ;          [DIRSTART],[DIRSEC],[CLUSFAC],[CLUSNUM] set to directory
 27443                                  ;               containing new node.
 27444                                  ;          [CURBUF+2]:BX Points to entry
 27445                                  ;          [CURBUF+2]:SI Points to entry.dir_first
 27446                                  ;          [THISSFT] is filled in
 27447                                  ;               sf_mode = unchanged.
 27448                                  ;          Attribute byte in entry is input AL
 27449                                  ; DS preserved, others destroyed
 27450                                  ;
 27451                                  ;-------------------------------------------------------------------------
 27452                                  
 27453                                  ; 19/05/2019 - Retro DOS v4.0
 27454                                  ; DOSCODE:8925h (MSDOS 6.21, MSDOS.SYS)
 27455                                  
 27456                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27457                                  ; DOSCODE:88EAh (MSDOS 5.0, MSDOS.SYS)
 27458                                  
 27459                                  ; 23/02/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
 27460                                  ; DOSCODE:8925h (MSDOS 6.22, MSDOS.SYS)
 27461                                  ; DOSCODE:951Ah (PCDOS 7.1, IBMDOS.COM)
 27462                                  
 27463                                  MakeNode:
 27464                                  	;mov	word [CREATING],0E5FFh
 27465 00004821 C706[7E05]FFE5          	MOV	WORD [CREATING],DIRFREE*256 + 0FFh ; Creating, not DEL *.*
 27466 00004827 50                      	PUSH	AX 		; Save AH value
 27467 00004828 C606[4C03]00            	MOV	byte [NoSetDir],0
 27468 0000482D A2[6D05]                	MOV	[SATTRIB],AL
 27469 00004830 E8B8F5                  	call	GetPathNoSet
 27470 00004833 88CA                    	MOV	DL,CL		; Save CL info
 27471                                  	;MOV	CX,AX		; Device ID to CH
 27472                                  	; 23/02/2024
 27473 00004835 91                      	xchg	ax,cx
 27474 00004836 58                      	POP	AX		; Get back AH
 27475 00004837 732D                    	JNC	short make_exists ; File existed
 27476 00004839 7505                    	JNZ	short make_err_4 ; Path bad
 27477 0000483B 80FA80                  	CMP	DL,80h		; Check "CL" return from GETPATH
 27478 0000483E 7405                    	JZ	short make_type	; Name simply not found, and no metas
 27479                                  make_err_4:
 27480 00004840 B004                    	MOV	AL,4		; case 1 bad path
 27481                                  make_err_ret:
 27482                                  	;XOR	AH,AH
 27483                                  	; 23/02/2024
 27484 00004842 98                      	cbw
 27485 00004843 F9                      	STC
 27486                                  ;make_retn:	; 22/11/2022
 27487 00004844 C3                      	retn
 27488                                  
 27489                                  	;entry	RENAME_MAKE	; Used by DOS_RENAME to "copy" a node
 27490                                  RENAME_MAKE:
 27491                                  make_type:
 27492                                  ;Extended Open hooks
 27493                                  	; MSDOS 6.0
 27494                                  	;TESTB	EXTOPEN_ON,EXT_OPEN_ON	;FT. from extended open		;AN000;
 27495 00004845 F606[F605]01            	test	byte [EXTOPEN_ON],EXT_OPEN_ON ; 1
 27496 0000484A 7411                    	JZ	short make_type2	;FT. no				;AN000;
 27497 0000484C 800E[F605]04            	OR	byte [EXTOPEN_ON],EXT_FILE_NOT_EXISTS ; 4
 27498                                  					;FT. set for extended open ;AN000;
 27499                                  	;TESTB	EXTOPEN_FLAG,0F0H	;FT. not exists and fails	;AN000;
 27500 00004851 F606[F405]F0            	test	byte [EXTOPEN_FLAG],0F0h
 27501 00004856 7505                    	JNZ	short make_type2	;FT. no				;AN000;
 27502 00004858 F9                      	STC				;FT. set carry			;AN000;
 27503 00004859 B80700                  	MOV    AX,7			;FT. file not found		;AN000;
 27504                                  	; 22/11/2022
 27505                                  make_retn:
 27506                                  	;return
 27507 0000485C C3                      	retn				;FT.				;AN000;
 27508                                  
 27509                                  ;	Extended Open hooks
 27510                                  
 27511                                  make_type2:
 27512 0000485D C43E[9E05]              	LES	DI,[THISSFT]
 27513 00004861 31C0                    	XOR	AX,AX		; nothing exists Disk Node
 27514 00004863 F9                      	STC			; Not found
 27515 00004864 EB59                    	JMP	short make_new
 27516                                  
 27517                                  ; The node exists. It may be either a device, directory or file:
 27518                                  ;   Zero set => directory
 27519                                  ;   High bit of CH on => device
 27520                                  ;   else => file
 27521                                  
 27522                                  make_exists:
 27523 00004866 7447                    	JZ	short make_exists_dir
 27524 00004868 B003                    	MOV	AL,3		; file exists type 3  (error or device node)
 27525                                  	;test	byte [ATTRIB],18h
 27526 0000486A F606[6B05]18            	TEST	byte [ATTRIB],attr_volume_id+attr_directory
 27527 0000486F 753A                    	JNZ	short make_err_ret_5
 27528                                  				; Cannot already exist as Disk or Device Node
 27529                                  				;  if making DIR or Volume ID
 27530 00004871 08ED                    	OR	CH,CH
 27531 00004873 781A                    	JS	short make_share ; No further checks on attributes if device
 27532 00004875 08E4                    	OR	AH,AH
 27533 00004877 75C9                    	JNZ	short make_err_ret ; truncating NOT OK (AL = 3)
 27534 00004879 51                      	PUSH	CX		; Save device ID
 27535 0000487A 8E06[E405]              	MOV	ES,[CURBUF+2]
 27536                                  	;mov	ch,[es:bx+0Bh]
 27537 0000487E 268A6F0B                	MOV	CH,[ES:BX+dir_entry.dir_attr] ; Get file attributes
 27538                                  	;test	ch,1
 27539 00004882 F6C501                  	test	CH,attr_read_only
 27540 00004885 7523                    	JNZ	short make_err_ret_5P ; Cannot create on read only files
 27541 00004887 E8E6F7                  	call	MatchAttributes
 27542 0000488A 59                      	POP	CX		; Devid back in CH
 27543 0000488B 751E                    	JNZ	short make_err_ret_5 ; Attributes not ok
 27544 0000488D 30C0                    	XOR	AL,AL		; AL = 0, Disk Node
 27545                                  
 27546                                  make_share:
 27547                                  	;XOR	AH,AH
 27548                                  	; 23/02/2024
 27549 0000488F 98                      	cbw
 27550 00004890 50                      	PUSH	AX		; Save Disk or Device node
 27551 00004891 51                      	PUSH	CX		; Save Device ID
 27552 00004892 88EC                    	MOV	AH,CH		; Device ID to AH
 27553 00004894 E83901                  	CALL	DOOPEN		; Fill in SFT for share check
 27554 00004897 C43E[9E05]              	LES	DI,[THISSFT]
 27555 0000489B 56                      	push	si
 27556 0000489C 53                      	push	bx		; Save CURBUF pointers
 27557 0000489D E8D328                  	call	ShareEnter
 27558 000048A0 734E                    	jnc	short MakeEndShare
 27559                                  
 27560                                  ; User failed request.
 27561 000048A2 5B                      	pop	bx
 27562 000048A3 5E                      	pop	si
 27563 000048A4 59                      	pop	cx
 27564 000048A5 58                      	pop	ax
 27565                                  
 27566                                  Make_Share_ret:
 27567 000048A6 B006                    	MOV	AL,6
 27568 000048A8 EB98                    	JMP	short make_err_ret
 27569                                  
 27570                                  make_err_ret_5P:
 27571 000048AA 59                      	POP	CX		; Get back device ID
 27572                                  make_err_ret_5:
 27573 000048AB B005                    	MOV     AL,5		; Attribute mismatch
 27574                                          ; 22/11/2022
 27575 000048AD EB93                    	JMP	short make_err_ret
 27576                                  
 27577                                  make_exists_dir:
 27578 000048AF B001                    	MOV	AL,1		; exists as directory, always an error
 27579                                  	; 22/11/2022
 27580 000048B1 EB8F                    	JMP	short make_err_ret
 27581                                  
 27582                                  make_save:
 27583 000048B3 50                      	PUSH	AX		; Save whether Disk or File
 27584 000048B4 89C8                    	MOV	AX,CX		; Device ID to AH
 27585 000048B6 E86800                  	CALL	NEWENTRY
 27586 000048B9 58                      	POP	AX		; 0 if Disk, 3 if File
 27587 000048BA 73A0                    	jnc	short make_retn
 27588 000048BC B002                    	MOV	AL,2		; create failed case 2
 27589                                  make_save_retn:
 27590 000048BE C3                      	retn
 27591                                  
 27592                                  make_new:
 27593 000048BF E8F1FF                  	call	make_save
 27594 000048C2 72FA                    	jc	short make_save_retn	; case 2 fail
 27595                                  	;test	byte [ATTRIB],10h
 27596 000048C4 F606[6B05]10            	test	BYTE [ATTRIB],attr_directory
 27597 000048C9 75F3                    	jnz	short make_save_retn	; Don't "open" directories,
 27598                                  					; so don't tell the sharer about them
 27599 000048CB 50                      	push	ax
 27600 000048CC 53                      	push	bx
 27601 000048CD 56                      	push	si
 27602 000048CE E8A228                  	call	ShareEnter
 27603 000048D1 5E                      	pop	si
 27604 000048D2 5B                      	pop	bx
 27605 000048D3 58                      	pop	ax
 27606 000048D4 73E8                    	jnc	short make_save_retn
 27607                                  
 27608                                  ; We get here by having the user FAIL a share problem. Typically a failure of
 27609                                  ; this nature is an out-of-space or an internal error. We clean up as best as
 27610                                  ; possible: delete the newly created directory entry and return share_error.
 27611                                  
 27612 000048D6 50                      	PUSH	AX
 27613 000048D7 C43E[E205]              	LES	DI,[CURBUF]
 27614                                  	;mov	byte [es:bx],0E5h
 27615 000048DB 26C607E5                	MOV	BYTE [ES:BX],DIRFREE	; nuke newly created entry.
 27616                                  	
 27617                                  ; 07/07/2024 - Retro DOS v4.2
 27618                                  %if 0	
 27619                                  	; MSDOS 6.0
 27620                                  	;test	byte [es:di+5],40h
 27621                                  	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 27622                                  					;LB. if already dirty		  ;AN000;
 27623                                  	JNZ	short yesdirty8		;LB.  don't increment dirty count ;AN000;
 27624                                  	; 22/11/2022
 27625                                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 27626                                  	;or	byte [es:di+5],40h
 27627                                  	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty ; flag buffer as dirty
 27628                                  yesdirty8:
 27629                                  %else
 27630                                  	; 23/02/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
 27631 000048DF E8D510                  	call	SET_BUF_DIRTY
 27632                                  %endif
 27633 000048E2 C42E[8A05]              	LES	BP,[THISDPB]
 27634                                  	; 15/12/2022
 27635 000048E6 268A4600                	mov	al,[ES:BP]
 27636                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27637                                  	;;mov	al,[es:bp+0]
 27638                                  	;MOV	AL,[ES:BP+DPB.DRIVE]	; get drive for flush
 27639 000048EA E8C80F                  	call	FLUSHBUF		; write out buffer.
 27640 000048ED 58                      	POP	AX
 27641 000048EE EBB6                    	jmp	short Make_Share_ret
 27642                                  
 27643                                  ; We have found an existing file. We have also entered it into the share set.
 27644                                  ; At this point we need to call newentry to correctly address the problem of
 27645                                  ; getting rid of old data (create an existing file) or creating a new
 27646                                  ; directory entry (create a new file). Unfortunately, this operation may
 27647                                  ; result in an INT 24 that the user doesn't return from, thus locking the file
 27648                                  ; irretrievably into the share set. The correct solution is for us to LEAVE
 27649                                  ; the share set now, do the operation and then reassert the share access.
 27650                                  ;
 27651                                  ; We are allowed to do this! There is no window! After all, we are in
 27652                                  ; critDisk here and for someone else to get in, they must enter critDisk also.
 27653                                  
 27654                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27655                                  	; DOSCODE:89C8h (MSDOS 5.0, MSDOS.SYS)
 27656                                  
 27657                                  MakeEndShare:
 27658 000048F0 C43E[9E05]              	LES	DI,[THISSFT]		; grab SFT
 27659 000048F4 31C0                    	XOR	AX,AX
 27660 000048F6 E8E9C9                  	call	ECritSFT
 27661 000048F9 268705                  	xchg	AX,[ES:DI]
 27662                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 27663 000048FC 50                      	push	ax
 27664 000048FD 57                      	push	di
 27665 000048FE 06                      	push	es
 27666 000048FF 9C                      	PUSHF
 27667 00004900 E86B28                  	call	ShareEnd		; remove sharing
 27668 00004903 9D                      	POPF
 27669 00004904 07                      	pop	es
 27670 00004905 5F                      	pop	di
 27671 00004906 268F05                  	pop	word [ES:DI]
 27672                                  	;pop	word [ES:DI+SF_ENTRY.sf_ref_count]
 27673 00004909 E8F1C9                  	call	LCritSFT
 27674                                  	; 22/11/2022
 27675                                  	; DOSCODE:89E4h (MSDOS 5.0, MSDOS.SYS)
 27676 0000490C 5B                      	pop	bx
 27677 0000490D 5E                      	pop	si
 27678 0000490E 59                      	pop	cx
 27679 0000490F 58                      	pop	ax
 27680 00004910 E8A0FF                  	CALL	make_save
 27681                                  
 27682                                  ; If the user failed, we do not reenter into the sharing set.
 27683                                  
 27684 00004913 72A9                    	jc	short make_save_retn	; bye if error
 27685 00004915 50                      	push	ax
 27686 00004916 53                      	push	bx
 27687 00004917 56                      	push	si
 27688 00004918 9C                      	PUSHF
 27689 00004919 E85728                  	call	ShareEnter
 27690 0000491C 9D                      	POPF
 27691 0000491D 5E                      	pop	si
 27692 0000491E 5B                      	pop	bx
 27693 0000491F 58                      	pop	ax
 27694                                  
 27695                                  ; If Share_check fails, then we have an internal ERROR!!!!!
 27696                                  
 27697                                  makeendshare_retn:
 27698 00004920 C3                      	retn
 27699                                  
 27700                                  ;---------------------------------------------------------------------------
 27701                                  ;
 27702                                  ; Procedure Name : NEWENTRY
 27703                                  ;
 27704                                  ; Inputs:
 27705                                  ;	  [THISSFT] set
 27706                                  ;	  [THISDPB] set
 27707                                  ;	  [LASTENT] current last valid entry number in directory if no free
 27708                                  ;		  entries
 27709                                  ;	  [VOLID] set if a volume ID was found during search
 27710                                  ;	Attrib Contains attributes for new file
 27711                                  ;	  [DIRSTART] Points to first cluster of dir (0 means root)
 27712                                  ;	  CARRY FLAG INDICATES STATUS OF SEARCH FOR FILE
 27713                                  ;		  NC means file existed (device)
 27714                                  ;		  C  means file did not exist
 27715                                  ;	  AH = Device ID byte
 27716                                  ;	  If FILE
 27717                                  ;	  [CURBUF+2]:BX points to start of directory entry
 27718                                  ;	  [CURBUF+2]:SI points to dir_first of directory entry
 27719                                  ;	  If device
 27720                                  ;	  DS:BX points to start of "fake" directory entry
 27721                                  ;	  DS:SI points to dir_first of "fake" directory entry
 27722                                  ;		  (has DWORD pointer to device header)
 27723                                  ; Function:
 27724                                  ;	  Make a new directory entry
 27725                                  ;	  If an old one existed it is truncated first
 27726                                  ; Outputs:
 27727                                  ;	  Carry set if error
 27728                                  ;		  Can't grow dir, atts didn't match, attempt to make 2nd
 27729                                  ;		  vol ID, user FAILed to I 24
 27730                                  ;	  else
 27731                                  ;		  outputs of DOOPEN
 27732                                  ; DS, BX, SI preserved (meaning on SI BX, not value), others destroyed
 27733                                  ;
 27734                                  ;----------------------------------------------------------------------------
 27735                                  
 27736                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27737                                  	; DOSCODE:89F9h (MSDOS 5.0, MSDOS.SYS)
 27738                                  
 27739                                  NEWENTRY:
 27740 00004921 C42E[8A05]              	LES	BP,[THISDPB]
 27741 00004925 7315                    	JNC	short EXISTENT
 27742 00004927 803E[4A03]00            	CMP	byte [FAILERR],0
 27743                                  	;STC
 27744                                  	;jnz	short makeendshare_retn	; User FAILed, node might exist
 27745                                  	; 24/09/2023
 27746 0000492C 750C                    	jnz	short ERRRET3
 27747 0000492E E829FE                  	CALL	BUILDDIR	; Try to build dir
 27748 00004931 72ED                    	jc	short makeendshare_retn	; Failed
 27749 00004933 E825F4                  	call	GETENT		; Point at that free entry
 27750 00004936 72E8                    	jc	short makeendshare_retn	; Failed
 27751 00004938 EB0E                    	JMP	SHORT FREESPOT
 27752                                  
 27753                                  ERRRET3:
 27754 0000493A F9                      	STC
 27755                                  newentry_retn:
 27756 0000493B C3                      	retn
 27757                                  
 27758                                  EXISTENT:
 27759 0000493C 08E4                    	OR	AH,AH		; Check if file is I/O device
 27760 0000493E 7903                    	JNS	short NOT_DEV1
 27761 00004940 E98D00                  	JMP	DOOPEN		; If so, proceed with open
 27762                                  
 27763                                  NOT_DEV1:
 27764 00004943 E82801                  	call	FREEENT	; Free cluster chain
 27765 00004946 72F3                    	jc	short newentry_retn ; Failed
 27766                                  FREESPOT:
 27767                                  	;test	byte [ATTRIB],8
 27768 00004948 F606[6B05]08            	test	BYTE [ATTRIB],attr_volume_id
 27769 0000494D 7407                    	JZ	short NOTVOLID
 27770 0000494F 803E[7B05]00            	CMP	BYTE [VOLID],0
 27771 00004954 75E4                    	JNZ	short ERRRET3	; Can't create a second volume ID
 27772                                  NOTVOLID:
 27773 00004956 8E06[E405]              	MOV	ES,[CURBUF+2]
 27774 0000495A 89DF                    	MOV	DI,BX
 27775                                  
 27776 0000495C BE[4B05]                	MOV	SI,NAME1
 27777                                  
 27778 0000495F B90500                  	MOV	CX,5
 27779 00004962 F3A5                    	REP	MOVSW
 27780 00004964 A4                      	MOVSB			; Move name into dir entry
 27781 00004965 A0[6B05]                	MOV	AL,[ATTRIB]
 27782 00004968 AA                      	STOSB			; Attributes
 27783                                  
 27784                                  ;; File Tagging for Create DOS 4.00
 27785 00004969 B105                    	MOV	CL,5		;FT. assume normal FBUGBUG	;AN000;
 27786                                  ;; File Tagging for Create DOS 4.00
 27787                                  
 27788 0000496B 31C0                    	XOR	AX,AX
 27789 0000496D F3AB                    	REP	STOSW		; Zero pad
 27790 0000496F E86EC1                  	call	DATE16
 27791 00004972 92                      	XCHG	AX,DX
 27792 00004973 AB                      	STOSW			; dir_time
 27793 00004974 92                      	XCHG	AX,DX
 27794 00004975 AB                      	STOSW			; dir_date
 27795 00004976 31C0                    	XOR	AX,AX
 27796 00004978 57                      	PUSH	DI		; Correct SI input value
 27797                                  				; (recomputed for new buffer)
 27798 00004979 AB                      	STOSW			; Zero dir_first and size
 27799 0000497A AB                      	STOSW
 27800 0000497B AB                      	STOSW
 27801                                  updnxt:
 27802 0000497C 8B36[E205]              	MOV	SI,[CURBUF]
 27803                                  
 27804                                  	; 19/05/2019 - Retro DOS v4.0
 27805                                  
 27806                                  	; MSDOS 6.0
 27807 00004980 26F6440540              	TEST	byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 27808                                  				;LB. if already dirty		  ;AN000;
 27809 00004985 7508                    	JNZ	short yesdirty9	;LB.  don't increment dirty count ;AN000;
 27810 00004987 E83910                  	call	INC_DIRTY_COUNT	;LB.				  ;AN000;
 27811                                  	
 27812                                  	;or	byte [es:si+5],40h
 27813 0000498A 26804C0540              	OR	byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 27814                                  yesdirty9:
 27815 0000498F C42E[8A05]              	LES	BP,[THISDPB]
 27816                                  	; 15/12/2022
 27817 00004993 268A4600                	MOV	AL,[ES:BP]
 27818                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27819                                  	;;mov	al,[es:bp+0]
 27820                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; Sets AH value again (in AL)
 27821 00004997 50                      	PUSH	AX
 27822 00004998 53                      	PUSH	BX
 27823                                  
 27824                                  ; If we have a file, we need to increment the open ref. count so that
 27825                                  ; we have some protection against invalid media changes if an Int 24
 27826                                  ; error occurs.
 27827                                  ; Do nothing for a device.
 27828                                  
 27829 00004999 06                      	push	es
 27830 0000499A 57                      	push	di
 27831 0000499B C43E[9E05]              	LES	DI,[THISSFT]
 27832                                  	;test	word [es:di+5],80h
 27833                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 27834 0000499F 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 27835 000049A4 751A                    	jnz	short GotADevice
 27836 000049A6 1E                      	push	ds
 27837 000049A7 53                      	push	bx
 27838 000049A8 C51E[8A05]              	LDS	BX,[THISDPB]
 27839                                  	;mov	[es:di+7],bx
 27840 000049AC 26895D07                	MOV	[ES:DI+SF_ENTRY.sf_devptr],BX
 27841 000049B0 8CDB                    	MOV	BX,DS
 27842                                  	;mov	[es:di+9],bx
 27843 000049B2 26895D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],BX
 27844 000049B6 5B                      	pop	bx
 27845 000049B7 1F                      	pop	ds ; need to use DS for segment later on
 27846                                  
 27847 000049B8 E8CDFA                  	call	DEV_OPEN_SFT	; increment ref. count
 27848 000049BB C606[A20A]01            	mov	byte [VIRTUAL_OPEN],1; set flag
 27849                                  
 27850                                  GotADevice:
 27851 000049C0 5F                      	pop	di
 27852 000049C1 07                      	pop	es
 27853                                  
 27854 000049C2 E8F00E                  	call	FLUSHBUF
 27855                                  
 27856 000049C5 E8EC00                  	Call	CHECK_VIRT_OPEN	; decrement ref. count	;AN000;
 27857                                  
 27858 000049C8 5B                      	POP	BX
 27859 000049C9 58                      	POP	AX
 27860 000049CA 5E                      	POP	SI		; Get SI input back
 27861 000049CB 88C4                    	MOV	AH,AL		; Get I/O driver number back
 27862 000049CD 7301                    	jnc	short DOOPEN	
 27863 000049CF C3                      	retn			; Failed
 27864                                  	
 27865                                  ;NOTE FALL THROUGH
 27866                                  
 27867                                  ; DOSCODE:8AE4h (MSDOS 6.21, MSDOS.SYS)
 27868                                  
 27869                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27870                                  ; DOSCODE:8AA9h (MSDOS 5.0, MSDOS.SYS)
 27871                                  
 27872                                  ; DOOPEN
 27873                                  ;----------------------------------------------------------------------------
 27874                                  ;
 27875                                  ; Inputs:
 27876                                  ;	  [THISDPB] points to DPB if file
 27877                                  ;	  [THISSFT] points to SFT being used
 27878                                  ;	  AH = Device ID byte
 27879                                  ;	  If FILE
 27880                                  ;	  [CURBUF+2]:BX points to start of directory entry
 27881                                  ;	  [CURBUF+2]:SI points to dir_first of directory entry
 27882                                  ;	  If device
 27883                                  ;	  DS:BX points to start of "fake" directory entry
 27884                                  ;	  DS:SI points to dir_first of "fake" directory entry
 27885                                  ;		  (has DWORD pointer to device header)
 27886                                  ; Function:
 27887                                  ;	  Fill in SFT from dir entry
 27888                                  ; Outputs:
 27889                                  ;	  CARRY CLEAR
 27890                                  ;	  sf_ref_count and sf_mode fields not altered
 27891                                  ;	  sf_flags high byte = 0
 27892                                  ;	  sf_flags low byte = AH except
 27893                                  ;	  sf_flags Bit 6 set (not dirty or not EOF)
 27894                                  ;	  sf_attr sf_date sf_time sf_name set from entry
 27895                                  ;	  sf_position = 0
 27896                                  ;	  If device
 27897                                  ;	  sf_devptr = dword at dir_first (pointer to device header)
 27898                                  ;	  sf_size = 0
 27899                                  ;	  If file
 27900                                  ;	  sf_firclus sf_size set from entry
 27901                                  ;	  sf_devptr = [THISDPB]
 27902                                  ;	  sf_cluspos = 0
 27903                                  ;	  sf_lstclus = sf_firclus
 27904                                  ;	  sf_dirsec sf_dirpos set
 27905                                  ; DS,SI,BX preserved, others destroyed
 27906                                  ;
 27907                                  ;----------------------------------------------------------------------------
 27908                                  
 27909                                  	;entry	DOOPEN
 27910                                  DOOPEN:
 27911                                  ;	Generate and store attribute
 27912                                  
 27913 000049D0 88E6                    	MOV	DH,AH	  	; AH to different place
 27914 000049D2 C43E[9E05]              	LES	DI,[THISSFT]
 27915                                  	;add	di,4
 27916 000049D6 83C704                  	ADD	DI,SF_ENTRY.sf_attr ; Skip ref_count and mode fields
 27917                                  	; 24/09/2023
 27918 000049D9 31C0                    	xor	ax,ax
 27919                                  	;XOR	AL,AL		; Assume it's a device, devices have an
 27920                                  				;  attribute of 0 (for R/O testing etc).
 27921 000049DB 08F6                    	OR	DH,DH		; See if our assumption good.
 27922 000049DD 7807                    	JS	short DEV_SFT1	; If device DS=DOSGROUP
 27923 000049DF 8E1E[E405]              	MOV	DS,[CURBUF+2]
 27924                                  	;mov	al,[BX+0Bh]
 27925 000049E3 8A470B                  	MOV	AL,[BX+dir_entry.dir_attr]
 27926                                  				; If file, get attrib from dir entry
 27927                                  DEV_SFT1:
 27928 000049E6 AA                      	STOSB			; sf_attr, ES:DI -> sf_flags
 27929                                  
 27930                                  ;	Generate and store flags word
 27931                                  
 27932                                  	; 24/09/2023
 27933                                  	;XOR	AX,AX
 27934                                  	; ah=0
 27935 000049E7 88F0                    	MOV	AL,DH
 27936                                  	;or	al,40h
 27937 000049E9 0C40                    	OR	AL,devid_file_clean
 27938 000049EB AB                      	STOSW			; sf_flags, ES:DI -> sf_devptr
 27939                                  
 27940                                  ;	Generate and store device pointer
 27941                                  
 27942 000049EC 1E                      	PUSH	DS
 27943                                  	;lds	ax,[bx+1Ah]
 27944 000049ED C5471A                  	LDS	AX,[BX+dir_entry.dir_first] ; Assume device
 27945 000049F0 08F6                    	OR	DH,DH
 27946 000049F2 7805                    	JS	short DEV_SFT2
 27947                                  
 27948                                  ;hkn; SS override
 27949 000049F4 36C506[8A05]            	LDS	AX,[SS:THISDPB]	; Was file
 27950                                  DEV_SFT2:
 27951 000049F9 AB                      	STOSW			; store offset
 27952 000049FA 8CD8                    	MOV	AX,DS
 27953 000049FC 1F                      	POP	DS
 27954 000049FD AB                      	STOSW			; store segment
 27955                                  				; ES:DI -> sf_firclus
 27956                                  
 27957                                  ;	Generate pointer to, generate and store first cluster
 27958                                  ;	(irrelevant for devices)
 27959                                  
 27960 000049FE 56                      	PUSH	SI		; Save pointer to dir_first
 27961 000049FF A5                      	MOVSW			; dir_first -> sf_firclus
 27962                                  				; DS:SI -> dir_size_l, ES:DI -> sf_time
 27963                                  
 27964                                  ;	Copy time/date of last modification
 27965                                  
 27966                                  	;sub	si,6
 27967 00004A00 83EE06                  	SUB	SI,dir_entry.dir_size_l - dir_entry.dir_time 
 27968                                  				; DS:SI->dir_time
 27969 00004A03 A5                      	MOVSW			; dir_time -> sf_time
 27970                                  				; DS:SI -> dir_date, ES:DI -> sf_date
 27971 00004A04 A5                      	MOVSW			; dir_date -> sf_date
 27972                                  				; DS:SI -> dir_first, ES:DI -> sf_size
 27973                                  
 27974                                  ;	Generate and store file size (0 for devices)
 27975                                  
 27976 00004A05 AD                      	LODSW			; skip dir_first, DS:SI -> dir_size_l
 27977 00004A06 AD                      	LODSW			; dir_size_l in AX, DS:SI -> dir_size_h
 27978                                  	;MOV	CX,AX		; dir_size_l in CX
 27979                                  	; 23/02/2024
 27980 00004A07 91                      	xchg	ax,cx
 27981 00004A08 AD                      	LODSW			; dir_size_h (size AX:CX), DS:SI -> ????
 27982 00004A09 08F6                    	OR	DH,DH
 27983 00004A0B 7904                    	JNS	short FILE_SFT1
 27984 00004A0D 31C0                    	XOR	AX,AX
 27985 00004A0F 89C1                    	MOV	CX,AX		; Devices are open ended
 27986                                  FILE_SFT1:
 27987 00004A11 91                      	XCHG	AX,CX
 27988 00004A12 AB                      	STOSW			; Low word of sf_size
 27989 00004A13 91                      	XCHG	AX,CX
 27990 00004A14 AB                      	STOSW			; High word of sf_size
 27991                                  				; ES:DI -> sf_position
 27992                                  ; Initialize position to 0
 27993                                  
 27994 00004A15 31C0                    	XOR	AX,AX
 27995 00004A17 AB                      	STOSW
 27996 00004A18 AB                      	STOSW			; sf_position
 27997                                  				; ES:DI -> sf_cluspos
 27998                                  
 27999                                  ; Generate cluster optimizations for files
 28000                                  
 28001 00004A19 08F6                    	OR	DH,DH
 28002 00004A1B 7843                    	JS	short DEV_SFT3
 28003 00004A1D AB                      	STOSW			; sf_cluspos ; 19h
 28004                                  	;mov	ax,[bx+1Ah]
 28005 00004A1E 8B471A                  	MOV	AX,[BX+dir_entry.dir_first]
 28006                                  	; 19/05/2019
 28007                                  	; MSDOS 3.3
 28008                                  	;STOSW			; sf_lstclus ; 1Bh
 28009                                  	; MSDOS 6.0
 28010 00004A21 57                      	PUSH	DI		;AN004; save dirsec offset
 28011                                  	;sub	di,1Bh
 28012 00004A22 83EF1B                  	SUB	DI,SF_ENTRY.sf_dirsec	;AN004; es:di -> SFT
 28013                                  	;mov	[es:di+35h],ax
 28014 00004A25 26894535                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX	;AN004; save it
 28015 00004A29 5F                      	POP	DI		;AN004; restore dirsec offset
 28016                                  
 28017                                  ; DOS 3.3  FastOpen  6/13/86
 28018                                  
 28019 00004A2A 1E                      	PUSH	DS
 28020                                  
 28021                                  ;hkn; SS is DOSDATA
 28022 00004A2B 16                      	push	ss
 28023 00004A2C 1F                      	pop	ds
 28024                                  	;test	byte [FastOpenFlg],4
 28025 00004A2D F606[3A0D]04            	TEST	byte [FastOpenFlg],Special_Fill_Set
 28026 00004A32 7411                    	JZ	short Not_FastOpen
 28027                                  
 28028                                  ;hkn; FastOpen_Ext_Info is in DOSDATA
 28029 00004A34 BE[3B0D]                	MOV	SI,FastOpen_Ext_Info
 28030                                  
 28031                                  	;mov	ax,[si+1]
 28032 00004A37 8B4401                  	MOV	AX,[SI+FEI.dirsec]
 28033 00004A3A AB                      	STOSW		  	; sf_dirsec
 28034                                  	; MSDOS 6.0
 28035                                  	;mov	ax,[si+3]
 28036 00004A3B 8B4403                  	MOV	AX,[SI+FEI.dirsec+2]
 28037                                  		;;; changed for >32mb
 28038 00004A3E AB                      	STOSW		  	; sf_dirsec
 28039                                  	; 19/08//2018
 28040 00004A3F 8A04                    	mov	al,[SI]
 28041                                  	;MOV	AL,[SI+FEI.dirpos] ; mov al,[SI+0]
 28042 00004A41 AA                      	STOSB		  	; sf_dirpos
 28043 00004A42 1F                      	POP	DS
 28044                                  	;JMP	short Next_Name
 28045                                  	; 24/09/2023
 28046 00004A43 EB1E                    	jmp	short FILE_SFT2	; cf=0 (after 'test' instruction)
 28047                                  
 28048                                  ; DOS 3.3  FastOpen  6/13/86
 28049                                  
 28050                                  Not_FastOpen:
 28051                                  	;POP	DS		; normal path
 28052                                  
 28053                                  ;hkn; SS override
 28054                                  	;MOV	SI,[SS:CURBUF]	; DS:SI->buffer header
 28055                                  	; 16/12/2022
 28056                                  	; 28/07/2019
 28057 00004A45 8B36[E205]              	mov	si,[CURBUF]
 28058 00004A49 1F                      	pop	ds
 28059                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28060                                  	;pop	ds
 28061                                  	;mov	si,[ss:CURBUF]
 28062                                  	
 28063                                  	;mov	ax,[si+6]
 28064 00004A4A 8B4406                  	MOV	AX,[SI+BUFFINFO.buf_sector]	;F.C. >32mb ;AN000;
 28065 00004A4D AB                      	STOSW		  	; sf_dirsec	;F.C. >32mb ;AN000;
 28066                                  	; 19/05/2019	
 28067                                  	; MSDOS 6.0
 28068                                  	;mov	ax,[si+8]
 28069 00004A4E 8B4408                  	MOV	AX,[SI+BUFFINFO.buf_sector+2]	;F.C. >32mb ;AN000;
 28070 00004A51 AB                      	STOSW		  	; sf_dirsec	;F.C. >32mb ;AN000;
 28071                                  	
 28072 00004A52 89D8                    	MOV	AX,BX
 28073                                  	;;add	si,16	; MSDOS 3.3
 28074                                  	;add	si,20	; MSDOS 6.0
 28075 00004A54 83C614                  	ADD	SI,BUFINSIZ	; DS:SI-> start of data in buffer
 28076 00004A57 29F0                    	SUB	AX,SI		; AX = BX relative to start of sector
 28077                                  	;mov	cl,32
 28078 00004A59 B120                    	MOV	CL,dir_entry.size
 28079 00004A5B F6F1                    	DIV	CL
 28080 00004A5D AA                      	STOSB		  	; sf_dirpos
 28081                                  Next_Name:
 28082 00004A5E EB03                    	JMP	SHORT FILE_SFT2
 28083                                  
 28084                                  	; 24/09/2023
 28085                                  	; cf=0 (after 'or' instruction)
 28086                                  DEV_SFT3:
 28087                                  	;add	di,7
 28088 00004A60 83C707                  	ADD	DI,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
 28089                                  FILE_SFT2:
 28090                                  
 28091                                  ; Copy in the object's name
 28092                                  
 28093 00004A63 89DE                    	MOV	SI,BX		; DS:SI points to dir_name
 28094 00004A65 B90B00                  	MOV	CX,11
 28095 00004A68 F3A4                    	REP	MOVSB		; sf_name
 28096 00004A6A 5E                      	POP	SI		; recover DS:SI -> dir_first
 28097                                  
 28098                                  ;hkn; SS is DOSDATA
 28099 00004A6B 16                      	push	ss
 28100 00004A6C 1F                      	pop	ds
 28101                                  	; 24/09/2023
 28102                                  	; cf=0
 28103                                  	;CLC
 28104 00004A6D C3                      	retn
 28105                                  
 28106                                  ;---------------------------------------------------------------------------
 28107                                  ;
 28108                                  ; Procedure Name : FREEENT
 28109                                  ;
 28110                                  ; Inputs:
 28111                                  ;	  ES:BP -> DPB
 28112                                  ;	  [CURBUF] Set
 28113                                  ;	  [CURBUF+2]:BX points to directory entry
 28114                                  ;	  [CURBUF+2]:SI points to above dir_first
 28115                                  ; Function:
 28116                                  ;	  Free the cluster chain for the entry if present
 28117                                  ; Outputs:
 28118                                  ;	  Carry set if error (currently user FAILed to I 24)
 28119                                  ;	  (NOTE dir_firclus and dir_size_l/h are wrong)
 28120                                  ; DS BX SI ES BP preserved (BX,SI in meaning, not value) others destroyed
 28121                                  ;---------------------------------------------------------------------------
 28122                                  
 28123                                  	; 24/02/2024 - Retro DOS v4.2
 28124                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28125                                  FREEENT:
 28126 00004A6E 1E                      	PUSH	DS
 28127 00004A6F C53E[E205]              	LDS	DI,[CURBUF]
 28128 00004A73 8B0C                    	MOV	CX,[SI]		; Get pointer to clusters
 28129                                  	; 19/05/2019 - Retro DOS v4.0
 28130                                  	; MSDOS 6.0
 28131 00004A75 8B5508                  	MOV	DX,[DI+BUFFINFO.buf_sector+2] ;F.C. >32mb  ;AN000;
 28132                                  ;hkn; SS override
 28133 00004A78 368916[0706]            	MOV	[SS:HIGH_SECTOR],DX	      ;F.C. >32mb  ;AN000;
 28134 00004A7D 8B5506                  	MOV	DX,[DI+BUFFINFO.buf_sector]
 28135 00004A80 1F                      	POP	DS
 28136 00004A81 83F902                  	CMP	CX,2
 28137 00004A84 722C                    	JB	short RET1	; Was 0 length file (or mucked Firclus if CX=1)
 28138                                  	;cmp	cx,[es:bp+0Dh]
 28139 00004A86 263B4E0D                	CMP	CX,[ES:BP+DPB.MAX_CLUSTER]
 28140                                  	;JA	short RET1	; Treat like zero length file (firclus mucked)
 28141 00004A8A 7715                    	ja	short freeent_retn ; 24/02/2024
 28142 00004A8C 29FB                    	SUB	BX,DI
 28143 00004A8E 53                      	PUSH	BX		; Save offset
 28144 00004A8F FF36[0706]              	PUSH	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 28145 00004A93 52                      	PUSH	DX		; Save sector number
 28146 00004A94 89CB                    	MOV	BX,CX
 28147 00004A96 E8A402                  	call	RELEASE		; Free any data allocated
 28148 00004A99 5A                      	POP	DX
 28149 00004A9A 8F06[0706]              	POP	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 28150 00004A9E 7302                    	JNC	short GET_BUF_BACK
 28151 00004AA0 5B                      	POP	BX
 28152                                  freeent_retn:
 28153 00004AA1 C3                      	retn			; Screw up
 28154                                  
 28155                                  GET_BUF_BACK:
 28156                                  	; 22/09/2023
 28157                                  	;;mov	byte [ALLOWED],18h
 28158                                  	;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 28159                                  	;XOR	AL,AL ; *
 28160                                  	;call	GETBUFFR	; Get sector back
 28161 00004AA2 E80C0D                  	call	GETBUFFER ; *	; pre read
 28162                                  
 28163 00004AA5 5B                      	POP	BX		; Get offset back
 28164 00004AA6 72F9                    	jc	short freeent_retn
 28165 00004AA8 E816EB                  	call	SET_BUF_AS_DIR
 28166 00004AAB 031E[E205]              	ADD	BX,[CURBUF]	; Correct it for new buffer
 28167                                  
 28168                                  	;MOV	SI,BX
 28169                                  	;;add	si,1Ah
 28170                                  	;ADD	SI,dir_entry.dir_first	; Get corrected SI
 28171                                  	; 24/02/2024
 28172                                  	;lea	si,[bx+1Ah]
 28173 00004AAF 8D771A                  	lea	si,[bx+dir_entry.dir_first]
 28174                                  RET1:
 28175 00004AB2 F8                      	CLC
 28176 00004AB3 C3                      	retn
 28177                                  
 28178                                  ;---------------------------------------------------------------------------
 28179                                  ;
 28180                                  ; Procedure Name : CHECK_VIRT_OPEN
 28181                                  ;
 28182                                  ; CHECK_VIRT_OPEN checks to see if we had performed a "virtual open" (by
 28183                                  ; examining the flag [VIRTUAL_OPEN] to see if it is 1). If we did, then
 28184                                  ; it calls Dev_Close_SFT to decrement the ref. count. It also resets the
 28185                                  ; flag [VIRTUAL_OPEN].
 28186                                  ; No registers affected (including flags).
 28187                                  ; On input, [THISSFT] points to current SFT.
 28188                                  ;
 28189                                  ;---------------------------------------------------------------------------
 28190                                  
 28191                                  CHECK_VIRT_OPEN:
 28192 00004AB4 50                      	PUSH	AX
 28193 00004AB5 9F                      	lahf			; preserve flags
 28194 00004AB6 803E[A20A]00            	CMP	byte [VIRTUAL_OPEN],0
 28195 00004ABB 7410                    	JZ	short ALL_CLOSED
 28196 00004ABD C606[A20A]00            	mov	byte [VIRTUAL_OPEN],0 ; reset flag
 28197 00004AC2 06                      	push	es
 28198 00004AC3 57                      	push	di
 28199 00004AC4 C43E[9E05]              	LES	DI,[THISSFT]
 28200 00004AC8 E8C5F9                  	call	DEV_CLOSE_SFT
 28201 00004ACB 5F                      	pop	di
 28202 00004ACC 07                      	pop	es
 28203                                  
 28204                                  ALL_CLOSED:
 28205 00004ACD 9E                      	sahf			; restore flags
 28206 00004ACE 58                      	POP	AX
 28207 00004ACF C3                      	retn
 28208                                  
 28209                                  ;============================================================================
 28210                                  ; ROM.ASM, MSDOS 6.0, 1991
 28211                                  ;============================================================================
 28212                                  ; 29/07/2018 - Retro DOS v3.0
 28213                                  ; 20/05/2019 - Retro DOS v4.0
 28214                                  
 28215                                  ;	TITLE	ROM - Miscellaneous routines
 28216                                  ;	NAME	ROM
 28217                                  
 28218                                  ;**	Misc Low level routines for doing simple FCB computations, Cache
 28219                                  ;       reads and writes, I/O optimization, and FAT allocation/deallocation
 28220                                  ;
 28221                                  ;	SKPCLP
 28222                                  ;	FNDCLUS
 28223                                  ;	BUFSEC
 28224                                  ;	BUFRD
 28225                                  ;	BUFWRT
 28226                                  ;	NEXTSEC
 28227                                  ;	OPTIMIZE
 28228                                  ;	FIGREC
 28229                                  ;	ALLOCATE
 28230                                  ;	RESTFATBYT
 28231                                  ;	RELEASE
 28232                                  ;	RELBLKS
 28233                                  ;	GETEOF
 28234                                  ;
 28235                                  ;	Modification history:
 28236                                  ;
 28237                                  ;		Created: ARR 30 March 1983
 28238                                  ;               M039: DB 10/25/90 - Disk read/write optimization.
 28239                                  
 28240                                  ;Break   <FNDCLUS -- Skip over allocation units>
 28241                                  ;--------------------------------------------------------------------------
 28242                                  ;
 28243                                  ; Procedure Name : FNDCLUS
 28244                                  ;
 28245                                  ; Inputs:
 28246                                  ;       CX = No. of clusters to skip
 28247                                  ;       ES:BP = Base of drive parameters
 28248                                  ;       [THISSFT] point to SFT
 28249                                  ; Outputs:
 28250                                  ;       BX = Last cluster skipped to
 28251                                  ;       CX = No. of clusters remaining (0 unless EOF)
 28252                                  ;       DX = Position of last cluster
 28253                                  ;       Carry set if error (currently user FAILed to I 24)
 28254                                  ; DI destroyed. No other registers affected.
 28255                                  ;--------------------------------------------------------------------------
 28256                                  
 28257                                  	; 10/02/2024 - Retro DOS v4.2
 28258                                  FNDCLUS_X:
 28259 00004AD0 8B0E[BC05]              	mov	cx,[CLUSNUM]
 28260                                  
 28261                                  ; 20/05/2019 - Retro DOS v4.0
 28262                                  ; DOSCODE:8BF2h (MSDOS 6.21, MSDOS.SYS)
 28263                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28264                                  ; DOSCODE:8BB7h (MSDOS 5.0, MSDOS.SYS)
 28265                                  
 28266                                  FNDCLUS:
 28267 00004AD4 06                      	PUSH	ES
 28268 00004AD5 C43E[9E05]                      LES     DI,[THISSFT]		; setup addressability to SFT
 28269                                  	;;mov	bx,[es:di+1Bh] ; MSDOS 3.3
 28270                                  	;mov	bx,[es:di+35h] ; MSDOS 6.0
 28271 00004AD9 268B5D35                	MOV	BX,[ES:DI+SF_ENTRY.sf_lstclus]
 28272                                  	;mov	dx,[es:di+19h]
 28273 00004ADD 268B5519                        MOV     DX,[ES:DI+SF_ENTRY.sf_cluspos]
 28274 00004AE1 09DB                    	OR	BX,BX
 28275 00004AE3 7424                    	JZ	short NOCLUS
 28276                                  
 28277 00004AE5 29D1                            SUB     CX,DX
 28278 00004AE7 7308                            JNB	short FINDIT
 28279                                  
 28280 00004AE9 01D1                            ADD     CX,DX
 28281 00004AEB 31D2                            XOR     DX,DX
 28282                                  	;mov	bx,[es:di+0Bh]
 28283 00004AED 268B5D0B                        MOV     BX,[ES:DI+SF_ENTRY.sf_firclus]
 28284                                  FINDIT:
 28285 00004AF1 07                              POP	ES
 28286 00004AF2 E313                    	JCXZ	RET9
 28287                                  
 28288                                  	;entry	SKPCLP
 28289                                  SKPCLP:
 28290 00004AF4 E8B608                  	call	UNPACK
 28291 00004AF7 7214                            jc	short fndclus_retn	; retc
 28292                                  
 28293                                  	; 09/09/2018
 28294                                  
 28295                                  	; MSDOS 3.3
 28296                                  	;push	bx
 28297                                  	;mov	bx,di
 28298                                  	;call	IsEOF
 28299                                  	;pop	bx	
 28300                                  	;jae	short RET9
 28301                                  
 28302                                  	; 20/05/2019 - Retro DOS v4.0
 28303                                  
 28304                                  	; MSDOS 6.0
 28305 00004AF9 87DF                    	xchg	bx,di
 28306 00004AFB E89808                  	call	IsEOF
 28307 00004AFE 87DF                    	xchg	bx,di
 28308 00004B00 7305                    	jae	short RET9
 28309                                  
 28310 00004B02 87DF                            XCHG    BX,DI
 28311 00004B04 42                              INC     DX
 28312                                  
 28313 00004B05 E2ED                    	LOOP	SKPCLP			; RMFS
 28314                                  RET9:	
 28315 00004B07 F8                      	CLC
 28316 00004B08 C3                              retn
 28317                                  NOCLUS:
 28318 00004B09 07                              POP	ES
 28319 00004B0A 41                              INC	CX
 28320 00004B0B 4A                              DEC	DX
 28321 00004B0C F8                              CLC
 28322                                  
 28323                                  fndclus_retn:
 28324 00004B0D C3                              retn
 28325                                  
 28326                                  ;Break  <BUFSEC -- BUFFER A SECTOR AND SET UP A TRANSFER>
 28327                                  ;--------------------------------------------------------------------------
 28328                                  ;
 28329                                  ; Procedure Name : BUFSEC
 28330                                  ;
 28331                                  ; Inputs:
 28332                                  ;       AH = priority of buffer
 28333                                  ;       AL = 0 if buffer must be read, 1 if no pre-read needed
 28334                                  ;       ES:BP = Base of drive parameters
 28335                                  ;       [CLUSNUM] = Physical cluster number
 28336                                  ;       [SECCLUSPOS] = Sector position of transfer within cluster
 28337                                  ;       [BYTCNT1] = Size of transfer
 28338                                  ; Function:
 28339                                  ;       Insure specified sector is in buffer, flushing buffer before
 28340                                  ;       read if necessary.
 28341                                  ; Outputs:
 28342                                  ;       ES:DI = Pointer to buffer
 28343                                  ;       SI = Pointer to transfer address
 28344                                  ;       CX = Number of bytes
 28345                                  ;       [NEXTADD] updated
 28346                                  ;       [TRANS] set to indicate a transfer will occur
 28347                                  ;       Carry set if error (user FAILed to I 24)
 28348                                  ;--------------------------------------------------------------------------
 28349                                  
 28350                                  BUFSEC:
 28351 00004B0E 8B16[BC05]              	MOV	DX,[CLUSNUM]
 28352 00004B12 8A1E[7305]              	MOV	BL,[SECCLUSPOS]
 28353                                  	;mov	byte [ALLOWED],38h
 28354 00004B16 C606[4B03]38            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY+Allowed_IGNORE
 28355 00004B1B E84F01                  	CALL	FIGREC
 28356 00004B1E E8970C                  	call	GETBUFFR
 28357 00004B21 72EA                    	jc	short fndclus_retn
 28358                                  
 28359 00004B23 C606[7405]01            	MOV	BYTE [TRANS],1		; A transfer is taking place
 28360 00004B28 8B36[B805]              	MOV	SI,[NEXTADD]
 28361 00004B2C 89F7                    	MOV	DI,SI
 28362 00004B2E 8B0E[D205]              	MOV	CX,[BYTCNT1]
 28363 00004B32 01CF                    	ADD	DI,CX
 28364 00004B34 893E[B805]              	MOV	[NEXTADD],DI
 28365 00004B38 C43E[E205]              	LES	DI,[CURBUF]
 28366                                  	;or	byte [es:di+5],8
 28367 00004B3C 26804D0508              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_isDATA
 28368                                  	;;lea	di,[di+16] ; MSDOS 3.3 
 28369                                  	;lea	di,[di+20] ; MSDOS 6.0
 28370 00004B41 8D7D14                  	LEA	DI,[DI+BUFINSIZ]        ; Point to buffer
 28371 00004B44 033E[CC05]              	ADD	DI,[BYTSECPOS]
 28372 00004B48 F8                      	CLC
 28373 00004B49 C3                      	retn
 28374                                  
 28375                                  ;Break   <BUFRD, BUFWRT -- PERFORM BUFFERED READ AND WRITE>
 28376                                  
 28377                                  ;---------------------------------------------------------------------------
 28378                                  ;
 28379                                  ; Procedure Name : BUFRD
 28380                                  ;
 28381                                  ; Do a partial sector read via one of the system buffers
 28382                                  ; ES:BP Points to DPB
 28383                                  ; Carry set if error (currently user FAILed to I 24)
 28384                                  ;
 28385                                  ; DS - set to DOSDATA
 28386                                  ;
 28387                                  ;----------------------------------------------------------------------------
 28388                                  
 28389                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28390                                  	; 20/05/2019 - Retro DOS v4.0
 28391                                  BUFRD:
 28392 00004B4A 06                      	PUSH	ES
 28393 00004B4B 31C0                    	xor	ax,ax			; pre-read sector
 28394 00004B4D E8BEFF                  	CALL	BUFSEC
 28395 00004B50 7303                    	JNC	short BUF_OK ; ds=ss
 28396                                  
 28397                                  BUF_IO_FAIL:				; this label used by BUFWRT also
 28398 00004B52 07                      	POP	ES
 28399 00004B53 EB2D                    	JMP	SHORT RBUFPLACED ; ds=ss ; 25/02/2024 - Retro DOS v4.2
 28400                                  
 28401                                  BUF_OK:
 28402 00004B55 8CC3                    	MOV	BX,ES
 28403 00004B57 8E06[2E03]              	MOV	ES,[DMAADD+2]
 28404 00004B5B 8EDB                    	MOV	DS,BX
 28405 00004B5D 87FE                    	XCHG	DI,SI
 28406 00004B5F D1E9                    	SHR	CX,1
 28407                                  ;M039
 28408                                  	; MSDOS 3.3
 28409                                  	;JNC	short EVENRD
 28410                                  	;MOVSB
 28411                                  ;EVENRD:
 28412                                  	;REP	MOVSW
 28413                                  
 28414                                  ;	CX = # of whole WORDs ; CF=1 if odd # of bytes.
 28415                                  ;       DS:SI-> Source within Buffer.
 28416                                  ;       ES:DI-> Destination within Transfer memory block.
 28417                                  
 28418                                  	; MSDOS 6.0
 28419 00004B61 F3A5                    	rep	movsw			;Copy Buffer to Transfer memory.
 28420                                  	;adc	cx,0			;CX=1 if odd # of bytes, else CX=0.
 28421                                  	;rep	movsb			;Copy last byte.
 28422                                  	; 16/12/2022
 28423 00004B63 7301                    	jnc	short EVENRD ; **** 20/05/2019
 28424 00004B65 A4                      	movsb ; ****
 28425                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28426                                  	;adc	cx,0
 28427                                  	;rep	movsb
 28428                                  ;M039
 28429                                  EVENRD: ; ****
 28430 00004B66 07                      	POP	ES
 28431                                  ;hkn; SS override
 28432 00004B67 36C53E[E205]            	LDS	DI,[SS:CURBUF]
 28433                                  	;;lea	bx,[di+16]
 28434                                  	;lea	bx,[di+20] ; MSDOS 6.0
 28435 00004B6C 8D5D14                  	LEA	BX,[DI+BUFINSIZ]
 28436 00004B6F 29DE                    	SUB	SI,BX			; Position in buffer
 28437 00004B71 E8E40B                  	call	PLACEBUF
 28438                                  	;cmp	si,[es:bp+2]
 28439 00004B74 263B7602                	CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Read Last byte?
 28440 00004B78 7205                    	JB	short RBUFPLACEDC ; ds<>ss ; No, leave buf where it is
 28441                                  ;M039
 28442                                  	; MSDOS 3.3
 28443                                  	;call	PLACEHEAD 		; Make it prime candidate for chucking
 28444                                  					;  even though it is MRU.
 28445                                  	; MSDOS 6.0
 28446 00004B7A 36893E[6D00]            	MOV	[ss:BufferQueue],DI	; Make it prime candidate for
 28447                                  ;M039					; chucking even though it is MRU.
 28448                                  
 28449                                  RBUFPLACEDC:
 28450 00004B7F F8                      	CLC
 28451                                  ;RBUFPLACED:
 28452 00004B80 16                      	push	ss
 28453 00004B81 1F                      	pop	ds
 28454                                  RBUFPLACED:	; 25/02/2024 (ds=ss)
 28455 00004B82 C3                      	retn
 28456                                  
 28457                                  ;----------------------------------------------------------------------------
 28458                                  ;
 28459                                  ; Procedure : BUFWRT
 28460                                  ;
 28461                                  ; Do a partial sector write via one of the system buffers
 28462                                  ; ES:BP Points to DPB
 28463                                  ; Carry set if error (currently user FAILed to I 24)
 28464                                  ;
 28465                                  ; DS - set to DOSDATA
 28466                                  ;
 28467                                  ;----------------------------------------------------------------------------
 28468                                  
 28469                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28470                                  	; 20/05/2019 - Retro DOS v4.0
 28471                                  BUFWRT:
 28472                                  	;MOV	AX,[SECPOS]
 28473                                  	; MSDOS 6.0
 28474                                  	;ADD	AX,1			; Set for next sector
 28475                                  	;MOV	[SECPOS],AX 		;F.C. >32mb	;AN000;
 28476                                  	;ADC	word [SECPOS+2],0	;F.C. >32mb	;AN000;
 28477                                  	; 24/09/2023
 28478 00004B83 FF06[C405]              	inc	word [SECPOS]
 28479 00004B87 7504                    	jnz	short bufw_secpos
 28480 00004B89 FF06[C605]              	inc	word [SECPOS+2]
 28481                                  bufw_secpos:
 28482 00004B8D A1[C605]                	MOV	AX,[SECPOS+2]		;F.C. >32mb	;AN000;
 28483 00004B90 3B06[CA05]              	CMP	AX,[VALSEC+2]		;F.C. >32mb	;AN000;
 28484 00004B94 B001                    	MOV	AL,1			;F.C. >32mb	;AN000;
 28485 00004B96 770F                    	JA	short NOREAD		;F.C. >32mb	;AN000;
 28486 00004B98 720B                    	JB	short _doread		;F.C. >32mb	;AN000;
 28487 00004B9A A1[C405]                	MOV	AX,[SECPOS]		;F.C. >32mb	;AN000;
 28488                                  
 28489                                  	; MSDOS 3.3
 28490                                  	;INC	AX
 28491                                  	;MOV	[SECPOS],AX ; 09/09/2018
 28492                                  
 28493                                  	; 20/05/2019
 28494                                  	; MSDOS 3.3 & MSDOS 6.0
 28495 00004B9D 3B06[C805]              	CMP	AX,[VALSEC]		; Has sector been written before?
 28496 00004BA1 B001                    	MOV	AL,1
 28497 00004BA3 7702                    	JA	short NOREAD		; Skip preread if SECPOS>VALSEC
 28498                                  _doread:
 28499 00004BA5 30C0                    	XOR	AL,AL
 28500                                  NOREAD:
 28501 00004BA7 06                      	PUSH	ES
 28502 00004BA8 E863FF                  	CALL	BUFSEC
 28503 00004BAB 72A5                    	JC	short BUF_IO_FAIL
 28504 00004BAD 8E1E[2E03]              	MOV	DS,[DMAADD+2]
 28505 00004BB1 D1E9                    	SHR	CX,1
 28506                                  ;M039
 28507                                  	; MSDOS 3.3
 28508                                  	;JNC	short EVENWRT ; 09/09/2018
 28509                                  	;MOVSB
 28510                                  ;EVENWRT:
 28511                                  	;REP	MOVSW
 28512                                  
 28513                                  ;	CX = # of whole WORDs; CF=1 if odd # of bytes.
 28514                                  ;	DS:SI-> Source within Transfer memory block.
 28515                                  ;	ES:DI-> Destination within Buffer.
 28516                                  
 28517                                  	; MSDOS 6.0
 28518 00004BB3 F3A5                    	rep	movsw			;Copy Transfer memory to Buffer.
 28519                                  	;adc	cx,0			;CX=1 if odd # of bytes, else CX=0.
 28520                                  	;rep	movsb		  	;Copy last byte.
 28521                                  	; 16/12/2022
 28522 00004BB5 7301                    	jnc	short EVENWRT ; **** 20/05/2019
 28523 00004BB7 A4                      	movsb ; ****
 28524                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28525                                  	;adc	cx,0
 28526                                  	;rep	movsb
 28527                                  ;M039
 28528                                  EVENWRT: ; ****
 28529 00004BB8 07                      	POP	ES
 28530                                  
 28531                                  ;hkn; SS override
 28532 00004BB9 36C51E[E205]            	LDS	BX,[SS:CURBUF]
 28533                                  
 28534                                  	; MSDOS 6.0
 28535 00004BBE F6470540                	TEST	byte [BX+BUFFINFO.buf_flags],buf_dirty
 28536                                  					;LB. if already dirty		 ;AN000;
 28537 00004BC2 7507                    	JNZ	short yesdirty10	;LB. don't increment dirty count ;AN000;
 28538 00004BC4 E8FC0D                  	call	INC_DIRTY_COUNT		;LB.				 ;AN000;
 28539                                  	
 28540                                  	;or	byte [bx+5],40h
 28541 00004BC7 804F0540                	OR	byte [BX+BUFFINFO.buf_flags],buf_dirty
 28542                                  yesdirty10:
 28543                                  	;;lea	si,[bx+16]
 28544                                  	;lea	si,[bx+20] ; MSDOS 6.0
 28545 00004BCB 8D7714                  	LEA	SI,[BX+BUFINSIZ]
 28546 00004BCE 29F7                    	SUB	DI,SI		  	; Position in buffer
 28547                                  ;M039
 28548                                  	; MSDOS 3.3
 28549                                  	;MOV	SI,DI
 28550                                  	;MOV	DI,BX
 28551                                  	;call	PLACEBUF
 28552                                  	;;cmp	si,[es:bp+2]
 28553                                  	;CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 28554                                  	;JB	short WBUFPLACED	; No, leave buf where it is
 28555                                  	;call	PLACEHEAD		; Make it prime candidate for chucking
 28556                                  					;  even though it is MRU.
 28557                                  	; 10/02/2024
 28558 00004BD0 16                      	push	ss
 28559 00004BD1 1F                      	pop	ds
 28560                                  
 28561                                  	; MSDOS 6.0
 28562                                  	;cmp	di,[es:bp+2]
 28563 00004BD2 263B7E02                	CMP	di,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 28564 00004BD6 7204                    	JB	short WBUFPLACED	; No, leave buf where it is
 28565                                  
 28566                                  	; 10/02/2024
 28567                                  	;MOV	[ss:BufferQueue],BX	; Make it prime candidate for
 28568                                  					; chucking even though it is MRU.
 28569 00004BD8 891E[6D00]              	mov	[BufferQueue],bx
 28570                                  ;M039
 28571                                  
 28572                                  WBUFPLACED:
 28573 00004BDC F8                      	CLC
 28574                                  	; 10/02/2024
 28575                                  	;push	ss
 28576                                  	;pop	ds
 28577 00004BDD C3                      	retn
 28578                                  
 28579                                  ;Break   <NEXTSEC -- Compute next sector to read or write>
 28580                                  ;---------------------------------------------------------------------------
 28581                                  ;
 28582                                  ; Procedure Name : NEXTSEC
 28583                                  ;
 28584                                  ; Compute the next sector to read or write
 28585                                  ; ES:BP Points to DPB
 28586                                  ;
 28587                                  ;---------------------------------------------------------------------------
 28588                                  
 28589                                  NEXTSEC:
 28590 00004BDE F606[7405]FF            	test	byte [TRANS],0FFh ; -1
 28591                                  	;JZ	short CLRET
 28592                                  	; 29/02/2024
 28593 00004BE3 7427                    	jz	short CLRET2
 28594                                  
 28595 00004BE5 A0[7305]                	MOV	AL,[SECCLUSPOS]
 28596 00004BE8 FEC0                    	INC	AL
 28597                                  	;cmp	al,[es:bp+4]
 28598 00004BEA 263A4604                	CMP	AL,[ES:BP+DPB.CLUSTER_MASK]
 28599 00004BEE 7618                    	JBE	short SAVPOS
 28600                                  
 28601 00004BF0 8B1E[BC05]              	MOV	BX,[CLUSNUM]
 28602 00004BF4 E89F07                  	call	IsEOF
 28603 00004BF7 7314                    	JAE	short NONEXT
 28604                                  
 28605 00004BF9 E8B107                  	call	UNPACK
 28606                                  	;JC	short NONEXT
 28607                                  	; 26/02/2024
 28608 00004BFC 7210                    	jc	short NONEXT2
 28609                                  clusgot:
 28610 00004BFE 893E[BC05]              	MOV	[CLUSNUM],DI
 28611 00004C02 FF06[BA05]              	INC	word [LASTPOS]
 28612 00004C06 B000                    	MOV	AL,0
 28613                                  SAVPOS:
 28614 00004C08 A2[7305]                	MOV	[SECCLUSPOS],AL
 28615                                  CLRET:
 28616 00004C0B F8                              CLC
 28617                                  CLRET2:		; 29/02/2024
 28618 00004C0C C3                      	retn
 28619                                  NONEXT:
 28620 00004C0D F9                      	STC
 28621                                  NONEXT2:	; 26/02/2024
 28622 00004C0E C3                      	retn
 28623                                  
 28624                                  ;Break	<OPTIMIZE -- DO A USER DISK REQUEST WELL>
 28625                                  ;----------------------------------------------------------------------------
 28626                                  ;
 28627                                  ; Procedure Name : OPTIMIZE
 28628                                  ;
 28629                                  ; Inputs:
 28630                                  ;	  BX = Physical cluster
 28631                                  ;	  CX = No. of records
 28632                                  ;	  DL = sector within cluster
 28633                                  ;	  ES:BP = Base of drive parameters
 28634                                  ;	  [NEXTADD] = transfer address
 28635                                  ; Outputs:
 28636                                  ;	  AX = No. of records remaining
 28637                                  ;	  BX = Transfer address
 28638                                  ;	  CX = No. or records to be transferred
 28639                                  ;	  DX = Physical sector address (LOW)
 28640                                  ;	  [HIGH_SECTOR] = Physical sector address (HIGH)
 28641                                  ;	  DI = Next cluster
 28642                                  ;	  [CLUSNUM] = Last cluster accessed
 28643                                  ;	  [NEXTADD] updated
 28644                                  ;	  Carry set if error (currently user FAILed to I 24)
 28645                                  ; ES:BP unchanged. Note that segment of transfer not set.
 28646                                  ;
 28647                                  ;---------------------------------------------------------------------------
 28648                                  
 28649                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28650                                  OPTIMIZE:
 28651 00004C0F 52                      	PUSH	DX
 28652 00004C10 53                      	PUSH	BX
 28653                                  	;mov	al,[es:bp+4]
 28654 00004C11 268A4604                	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
 28655 00004C15 FEC0                    	INC	AL		; Number of sectors per cluster
 28656 00004C17 88C4                    	MOV	AH,AL
 28657 00004C19 28D0                    	SUB	AL,DL		; AL = Num of sectors left in first cluster
 28658 00004C1B 89CA                    	MOV	DX,CX
 28659                                  	;MOV	CX,0
 28660                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28661                                  	; 16/12/2022
 28662 00004C1D 31C9                    	xor	cx,cx	; sub cx,cx
 28663                                  OPTCLUS:
 28664                                  ; AL has number of sectors available in current cluster
 28665                                  ; AH has number of sectors available in next cluster
 28666                                  ; BX has current physical cluster
 28667                                  ; CX has number of sequential sectors found so far
 28668                                  ; DX has number of sectors left to transfer
 28669                                  ; ES:BP Points to DPB
 28670                                  ; ES:SI has FAT pointer
 28671                                  
 28672                                  do_norm3:
 28673 00004C1F E88B07                  	call	UNPACK
 28674 00004C22 7236                    	JC	short OP_ERR
 28675                                  clusgot2:
 28676 00004C24 00C1                    	ADD	CL,AL
 28677 00004C26 80D500                  	ADC	CH,0
 28678 00004C29 39D1                    	CMP	CX,DX
 28679 00004C2B 7332                    	JAE	short BLKDON
 28680 00004C2D 88E0                    	MOV	AL,AH
 28681 00004C2F 43                      	INC	BX
 28682 00004C30 39DF                    	CMP	DI,BX
 28683 00004C32 74EB                    	JZ	short OPTCLUS
 28684 00004C34 4B                      	DEC	BX
 28685                                  FINCLUS:
 28686 00004C35 891E[BC05]              	MOV	[CLUSNUM],BX	; Last cluster accessed
 28687 00004C39 29CA                    	SUB	DX,CX		; Number of sectors still needed
 28688 00004C3B 52                      	PUSH	DX
 28689 00004C3C 89C8                    	MOV	AX,CX
 28690                                  	;mul	word[ES:BP+2]
 28691 00004C3E 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE] 
 28692                                  				; Number of sectors times sector size
 28693 00004C42 8B36[B805]              	MOV	SI,[NEXTADD]
 28694 00004C46 01F0                    	ADD	AX,SI		; Adjust by size of transfer
 28695 00004C48 A3[B805]                	MOV	[NEXTADD],AX
 28696 00004C4B 58                      	POP	AX		; Number of sectors still needed
 28697 00004C4C 5A                      	POP	DX		; Starting cluster
 28698 00004C4D 29D3                    	SUB	BX,DX		; Number of new clusters accessed
 28699 00004C4F 011E[BA05]              	ADD	[LASTPOS],BX
 28700 00004C53 5B                      	POP	BX		; BL = sector position within cluster
 28701 00004C54 E81600                  	call	FIGREC
 28702 00004C57 89F3                    	MOV	BX,SI
 28703                                  	; 24/09/2023
 28704                                  	; cf=0 (at the return of FIGREC)
 28705                                  	;CLC
 28706 00004C59 C3                      	retn
 28707                                  OP_ERR:
 28708 00004C5A 83C404                  	ADD	SP,4
 28709 00004C5D F9                      	STC
 28710 00004C5E C3                      	retn
 28711                                  BLKDON:
 28712 00004C5F 29D1                    	SUB	CX,DX	  	; Number of sectors in cluster we don't want
 28713 00004C61 28CC                    	SUB	AH,CL	  	; Number of sectors in cluster we accepted
 28714 00004C63 FECC                    	DEC	AH		; Adjust to mean position within cluster
 28715 00004C65 8826[7305]              	MOV	[SECCLUSPOS],AH
 28716 00004C69 89D1                    	MOV	CX,DX		; Anyway, make the total equal to the request
 28717 00004C6B EBC8                    	JMP	SHORT FINCLUS
 28718                                  
 28719                                  ;Break	<FIGREC -- Figure sector in allocation unit>
 28720                                  ;---------------------------------------------------------------------------
 28721                                  ;
 28722                                  ; Procedure Name : FIGREC
 28723                                  ;
 28724                                  ; Inputs:
 28725                                  ;	  DX = Physical cluster number
 28726                                  ;	  BL = Sector position within cluster
 28727                                  ;	  ES:BP = Base of drive parameters
 28728                                  ; Outputs:
 28729                                  ;	  DX = physical sector number (LOW)
 28730                                  ;	  [HIGH_SECTOR] Physical sector address (HIGH)
 28731                                  ; No other registers affected.
 28732                                  ;
 28733                                  ;---------------------------------------------------------------------------
 28734                                  
 28735                                  	; 10/06/2019
 28736                                  	; 20/05/2019 - Retro DOS v4.0
 28737                                  	; DOSCODE:8D96h (MSDOS 6.21, MSDOS.SYS)
 28738                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28739                                  	; DOSCODE:8D5Bh (MSDOS 5.0, MSDOS.SYS)
 28740                                  
 28741                                  	; 27/02/2024 - Retro DOS v4.2
 28742                                  	; (ds=ss)
 28743                                  FIGREC:
 28744 00004C6D 51                      	PUSH	CX
 28745                                  	;
 28746                                  	; 27/02/2024
 28747 00004C6E 31C9                    	xor	cx,cx
 28748 00004C70 890E[0706]              	mov	[HIGH_SECTOR],cx ;0
 28749                                  	;
 28750                                  	;mov	cl,[es:bp+5]
 28751 00004C74 268A4E05                	MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 28752 00004C78 4A                      	DEC	DX
 28753 00004C79 4A                      	DEC	DX
 28754                                  
 28755                                  	; MSDOS 3.3
 28756                                  	;SHL	DX,CL
 28757                                  
 28758                                  ;hkn; SS override HIGH_SECTOR
 28759                                  	; MSDOS 6.0
 28760                                  	;MOV	word [SS:HIGH_SECTOR],0		;F.C. >32mb
 28761                                  	; 27/02/2024
 28762                                  	;mov	word [HIGH_SECTOR],0
 28763                                  	; 24/09/2023
 28764                                  	;;xor	ch,ch				;F.C. >32mb
 28765                                  	;OR	CL,CL				;F.C. >32mb
 28766                                  	;JZ	short noshift			;F.C. >32mb
 28767                                  	; 27/02/2024
 28768 00004C7A E309                    	jcxz	noshift
 28769                                  	; 27/02/2024
 28770                                  	;;XOR	CH,CH				;F.C. >32mb
 28771                                  rotleft:					;F.C. >32mb
 28772 00004C7C F8                      	CLC					;F.C. >32mb
 28773 00004C7D D1D2                    	RCL	DX,1				;F.C. >32mb
 28774                                  	; 10/06/2019
 28775                                  	;RCL	word [ss:HIGH_SECTOR],1		;F.C. >32mb
 28776                                  	; 27/02/2024
 28777 00004C7F D116[0706]              	rcl	word [HIGH_SECTOR],1
 28778 00004C83 E2F7                    	LOOP	rotleft				;F.C. >32mb
 28779                                  noshift:
 28780                                  	; MSDOS 3.3 & MSDOS 6.0
 28781 00004C85 08DA                    	OR	DL,BL
 28782                                  	;add	dx,[es:bp+0Bh]
 28783 00004C87 2603560B                	ADD	DX,[ES:BP+DPB.FIRST_SECTOR]
 28784                                  	; MSDOS 6.0
 28785                                  	; 10/06/2019
 28786                                  	;ADC	word [ss:HIGH_SECTOR],0		;F.C. >32mb
 28787                                  	; 24/09/2023
 28788                                  	; cx=0
 28789                                  	;ADC	word [ss:HIGH_SECTOR],cx ; 0
 28790                                  	; 27/02/2024
 28791 00004C8B 110E[0706]              	adc	word [HIGH_SECTOR],cx ; 0
 28792                                  
 28793                                  	; MSDOS 3.3 & MSDOS 6.0
 28794 00004C8F 59                      	POP	CX
 28795                                  figrec_retn:
 28796 00004C90 C3                      	retn
 28797                                  
 28798                                  ; 20/05/2019 - Retro DOS v4.0
 28799                                  ; DOSCODE:8DC2h (MSDOS 6.21, MSDOS.SYS)
 28800                                  
 28801                                  ; 30/07/2018 - Retro DOS v3.0
 28802                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 
 28803                                  
 28804                                  ;Break   <ALLOCATE -- Assign disk space>
 28805                                  ;---------------------------------------------------------------------------
 28806                                  ;
 28807                                  ; Procedure Name : ALLOCATE - Allocate Disk Space
 28808                                  ;
 28809                                  ;   ALLOCATE is called to allocate disk clusters. The new clusters are
 28810                                  ;   FAT-chained onto the end of the existing file.
 28811                                  ;
 28812                                  ;   The DPB contains the cluster # of the last free cluster allocated
 28813                                  ;   (dpb_next_free). We start at this cluster and scan towards higher
 28814                                  ;   numbered clusters, looking for the necessary free blocks.
 28815                                  ;
 28816                                  ;   Once again, fancy terminology gets in the way of correct coding. When
 28817                                  ;   using next_free, start scanning AT THAT POINT and not the one following it.
 28818                                  ;   This fixes the boundary condition bug when only free = next_free = 2.
 28819                                  ;
 28820                                  ;       If we get to the end of the disk without satisfaction:
 28821                                  ;
 28822                                  ;           if (dpb_next_free == 2) then we've scanned the whole disk.
 28823                                  ;               return (insufficient_disk_space)
 28824                                  ;           ELSE
 28825                                  ;               dpb_next_free = 2; start scan over from the beginning.
 28826                                  ;
 28827                                  ;   Note that there is no multitasking interlock. There is no race when
 28828                                  ;   examining the entrys in an in-core FAT block since there will be no
 28829                                  ;   context switch. When UNPACK context switches while waiting for a FAT read
 28830                                  ;   we are done with any in-core FAT blocks, so again there is no race. The
 28831                                  ;   only special concern is that V2 and V3 MSDOS left the last allocated
 28832                                  ;   cluster as "00"; marking it EOF only when the entire alloc request was
 28833                                  ;   satisfied. We can't allow another activation to think this cluster is
 28834                                  ;   free, so we give it a special temporary mark to show that it is, indeed,
 28835                                  ;   allocated.
 28836                                  ;
 28837                                  ;   Note that when we run out of space this algorithem will scan from
 28838                                  ;   dpb_next_free to the end, then scan from cluster 2 through the end,
 28839                                  ;   redundantly scanning the later part of the disk. This only happens when
 28840                                  ;   we run out of space, so sue me.
 28841                                  ;
 28842                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 28843                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 28844                                  ;                                                                          ;
 28845                                  ;   The use of FATBYT and RESTFATBYT is somewhat mysterious. Here is the
 28846                                  ;   explanation:
 28847                                  ;
 28848                                  ;   In the NUL file case (sf_firclus currently 0) ALLOCATE is called with
 28849                                  ;   entry BX = 0. What needs to be done in this case is to stuff the cluster
 28850                                  ;   number of the first cluster allocated in sf_firclus when the ALLOCATE is
 28851                                  ;   complete. THIS VALUE IS SAVED TEMPORARILY IN CLUSTER 0, HENCE THE CURRENT
 28852                                  ;   VALUE IN CLUSTER 0 MUST BE SAVED AND RESTORED. This is a side effect of
 28853                                  ;   the fact that PACK and UNPACK don't treat requests for clusters 0 and 1 as
 28854                                  ;   errors. This "stuff" is done by the call to PACK which is right before
 28855                                  ;   the
 28856                                  ;           LOOP   findfre         ; alloc more if needed
 28857                                  ;   instruction when the first cluster is allocated to the nul file. The
 28858                                  ;   value is recalled from cluster 0 and stored at sf_firclus at ads4:
 28859                                  ;
 28860                                  ;   This method is obviously useless (because it is non-reentrant) for
 28861                                  ;   multitasking, and will have to be changed. Storing the required value on
 28862                                  ;   the stack is recommended. Setting sf_firclus at the PACK of cluster 0
 28863                                  ;   (instead of actually doing the PACK) is BAD because it doesn't handle
 28864                                  ;   problems with INT 24 well.
 28865                                  ;
 28866                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 28867                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 28868                                  ;                                                                          ;
 28869                                  ;       ENTRY   BX = Last cluster of file (0 if null file)
 28870                                  ;               CX = No. of clusters to allocate
 28871                                  ;               ES:BP = Base of drive parameters
 28872                                  ;               [THISSFT] = Points to SFT
 28873                                  ;
 28874                                  ;       EXIT    'C' set if insufficient space
 28875                                  ;                 [FAILERR] can be tested to see the reason for failure
 28876                                  ;                 CX = max. no. of clusters that could be added to file
 28877                                  ;               'C' clear if space allocated
 28878                                  ;                 BX = First cluster allocated
 28879                                  ;                 FAT is fully updated
 28880                                  ;                 sf_FIRCLUS field of SFT set if file was null
 28881                                  ;
 28882                                  ;       USES    ALL but SI, BP
 28883                                  
 28884                                  ;callmagic  proc near
 28885                                  ;       push    ds                             ;push segment of routine 
 28886                                  ;       push    Offset MagicPatch              ;push offset for routine
 28887                                  ;       retf                                   ;simulate jmp far
 28888                                  ;                                              ;far return address is on
 28889                                  ;                                              ;stack, so far return from
 28890                                  ;                                              ;call will return this routine
 28891                                  ;callmagic  endp
 28892                                  
 28893                                  
 28894                                  ; 25/09/2023
 28895                                  %if 0
 28896                                  callmagic:
 28897                                  	push	ds
 28898                                  	push	MagicPatch
 28899                                  	retf	
 28900                                  %endif
 28901                                  
 28902                                  ALLOCATE:
 28903                                  	; 10/09/2018
 28904                                  ;BEGIN MAGICDRV MODIFICATIONS
 28905                                  ;
 28906                                  ;7/5/92 scottq
 28907                                  ;
 28908                                  ;This is the disk compression patch location which allows
 28909                                  ;the disk compression software to fail allocations if the
 28910                                  ;FAT would allows allocation, but the free space for compressed
 28911                                  ;data would not.
 28912                                  ;        
 28913                                  ;;;	call    far ptr MAGICPATCH
 28914                                  ;;; We cannot do a far call since we cannot have fix-ups[romdos,hidos],
 28915                                  ;;; but we do know the segment and offset of the routine
 28916                                  ;;; so simulate a far call to dosdata:magicpatch
 28917                                  ;;; note dosassume above, so DS -> dosdata
 28918                                  
 28919                                  	; MSDOS 6.0
 28920                                          ;clc				;clear carry so we fall through
 28921                                  	;				;if no patch is present
 28922                                  	;push	cs			;push segment for far return
 28923                                          ;call	callmagic		;this is a near call
 28924                                          ;jnc	short Regular_Allocate_Path
 28925                                  	;jmp	Disk_Full_Return
 28926                                  
 28927                                  ; 25/09/2023
 28928                                  %if 0
 28929                                  	clc
 28930                                  	push	cs
 28931                                  	call	callmagic
 28932                                  	jnc	short Regular_Allocate_Path
 28933                                  	jmp	Disk_Full_Return
 28934                                  Regular_Allocate_Path:
 28935                                  %endif
 28936                                  
 28937                                  	; 20/05/2019 - Retro DOS v4.0
 28938                                  ;END MAGICDRV MODIFICATIONS
 28939                                  
 28940                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28941                                  	; DOSCODE:8D87h (MSDOS 5.0, MSDOS.SYS)
 28942                                  
 28943 00004C91 53                              PUSH    BX                      ; save (bx)
 28944 00004C92 31DB                            XOR     BX,BX
 28945 00004C94 E81607                  	call	UNPACK
 28946 00004C97 893E[9605]                      MOV     [FATBYT],DI             ; save correct cluster 0 value
 28947 00004C9B 5B                              POP     BX
 28948 00004C9C 72F2                            jc	short figrec_retn	; abort if error   [INTERR?]
 28949                                  
 28950 00004C9E 51                              PUSH    CX
 28951 00004C9F 53                              PUSH    BX
 28952                                  
 28953 00004CA0 89DA                            MOV     DX,BX
 28954                                  	;;mov	bx,[es:bp+1Ch]  ; MSDOS 3.3
 28955                                  	;mov	bx,[es:bp+1Dh]	; MSDOS 6.0
 28956 00004CA2 268B5E1D                        mov     bx,[ES:BP+DPB.NEXT_FREE]
 28957 00004CA6 83FB02                          cmp     bx,2
 28958 00004CA9 7709                            ja	short FINDFRE
 28959                                  
 28960                                  ;   couldn't find enough free space beyond dpb_next_free, or dpb_next_free is
 28961                                  ;   <2 or >dpb_max_clus. Reset it and restart the scan
 28962                                  
 28963                                  ads1:
 28964                                  	;;mov	word [es:bp+1Ch],2 ; MSDOS 3.3
 28965                                  	;mov	word [es:bp+1Dh],2 ; MSDOS 6.0
 28966 00004CAB 26C7461D0200                    mov     word [ES:BP+DPB.NEXT_FREE],2
 28967 00004CB1 BB0100                          mov     bx,1                    ; Counter next instruction so first
 28968                                                                          ;       cluster examined is 2
 28969                                  
 28970                                  ;   Scanning both forwards and backwards for a free cluster
 28971                                  ;
 28972                                  ;       (BX) = forwards scan pointer
 28973                                  ;       (CX) = clusters remaining to be allocated
 28974                                  ;       (DX) = current last cluster in file
 28975                                  ;       (TOS) = last cluster of file
 28976                                  
 28977                                  FINDFRE:
 28978 00004CB4 43                              INC     BX
 28979                                  	;cmp	bx,[es:bp+0Dh]
 28980 00004CB5 263B5E0D                        CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 28981 00004CB9 7757                    	ja	short ads7	; at end of disk
 28982 00004CBB E8EF06                          call	UNPACK          ; check out this cluster
 28983 00004CBE 722F                            jc	short ads4	; FAT error             [INTERR?]
 28984 00004CC0 75F2                            jnz	short FINDFRE	; not free, keep on truckin
 28985                                  
 28986                                  ;   Have found a free cluster. Chain it to the file
 28987                                  ;
 28988                                  ;       (BX) = found free cluster #
 28989                                  ;       (DX) = current last cluster in file
 28990                                  
 28991                                  	;;mov	[es:bp+1Ch],bx
 28992                                  	;mov	[es:bp+1Dh],bx ; MSDOS 6.0
 28993 00004CC2 26895E1D                        mov	[ES:BP+DPB.NEXT_FREE],bx ; next time start search here
 28994 00004CC6 92                              xchg    ax,dx           ; save (dx) in ax
 28995 00004CC7 BA0100                          mov     dx,1            ; mark this free guy as "1"
 28996 00004CCA E83407                  	call	PACK            ; set special "temporary" mark
 28997 00004CCD 7220                            jc	short ads4	; FAT error             [INTERR?]
 28998                                  	;;cmp	word [es:bp+1Eh],-1
 28999                                          ;cmp	word [es:bp+1Fh],-1 ; MSDOS 6.0
 29000 00004CCF 26837E1FFF              	CMP	word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 29001 00004CD4 7404                            JZ	short NO_ALLOC	; No
 29002                                  	;;dec	word [es:bp+1Eh]
 29003                                          ;dec	word [es:bp+1Fh] ; MSDOS 6.0
 29004 00004CD6 26FF4E1F                        DEC     word [ES:BP+DPB.FREE_CNT] ; Reduce free count by 1
 29005                                  NO_ALLOC:
 29006 00004CDA 92                              xchg    ax,dx           ; (dx) = current last cluster in file
 29007 00004CDB 87DA                            XCHG    BX,DX
 29008 00004CDD 89D0                            MOV     AX,DX
 29009 00004CDF E81F07                  	call	PACK            ; link free cluster onto file
 29010                                                                  ;  CAVEAT.. On Nul file, first pass stuffs
 29011                                                                  ;    cluster 0 with FIRCLUS value.
 29012 00004CE2 720B                            jc	short ads4	; FAT error [INTERR?]
 29013 00004CE4 93                              xchg    BX,AX           ; (BX) = last one we looked at
 29014 00004CE5 89DA                            mov     dx,bx           ; (dx) = current end of file
 29015 00004CE7 E2CB                            LOOP    FINDFRE         ; alloc more if needed
 29016                                  
 29017                                  ;   We've successfully extended the file. Clean up and exit
 29018                                  ;
 29019                                  ;       (BX) = last cluster in file
 29020                                  
 29021 00004CE9 BAFFFF                          MOV     DX,0FFFFH
 29022 00004CEC E81207                  	call	PACK            ; mark last cluster EOF
 29023                                  
 29024                                  ;   Note that FAT errors jump here to clean the stack and exit. This saves us
 29025                                  ;   2 whole bytes. Hope its worth it...
 29026                                  ;
 29027                                  ;       'C' set if error
 29028                                  ;       calling (BX) and (CX) pushed on stack
 29029                                  
 29030                                  ads4:   
 29031 00004CEF 5B                      	POP     BX
 29032 00004CF0 59                              POP     CX              ; Don't need this stuff since we're successful
 29033 00004CF1 729D                            jc	short figrec_retn
 29034 00004CF3 E8B706                          call	UNPACK          ; Get first cluster allocated for return
 29035                                                                  ; CAVEAT... In nul file case, UNPACKs cluster 0.
 29036 00004CF6 7298                            jc	short figrec_retn
 29037 00004CF8 E83200                  	call	RESTFATBYT      ; Restore correct cluster 0 value
 29038 00004CFB 7293                            jc	short figrec_retn
 29039 00004CFD 87DF                            XCHG    BX,DI           ; (DI) = last cluster in file upon our entry
 29040 00004CFF 09FF                            OR      DI,DI           ; clear 'C'
 29041 00004D01 758D                    	jnz	short figrec_retn ; we were extending an existing file
 29042                                  
 29043                                  ;   We were doing the first allocation for a new file. Update the SFT cluster
 29044                                  ;   info
 29045                                  dofastk:
 29046                                  	; 20/05/2019
 29047                                  	; MSDOS 6.0
 29048                                  	;push	dx ; * MSDOS 6.0
 29049                                  	;;mov	dl,[es:bp+0]
 29050                                  	;;MOV	DL,[ES:BP+DPB.DRIVE]	; get drive #
 29051                                  	;mov	dl,[es:bp]
 29052                                  
 29053                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29054                                  	; DOSCODE:8DF9h (MSDOS 5.0, MSDOS.SYS)
 29055                                  	
 29056                                  	; 16/12/2022
 29057                                  	;push	dx ; *
 29058                                  	;mov	dl,[ES:BP+DPB.DRIVE] 
 29059                                  	; 15/12/2022
 29060                                  	;mov	dl,[es:bp]
 29061                                  	
 29062                                  	; MSDOS 3.3 & MSDOS 6.0
 29063 00004D03 06                      	PUSH	ES
 29064 00004D04 C43E[9E05]              	LES     DI,[THISSFT]
 29065                                  	;mov	[es:di+0Bh],bx
 29066 00004D08 26895D0B                	MOV     [ES:DI+SF_ENTRY.sf_firclus],BX
 29067                                  	;;mov	[es:di+1Bh],bx ; MSDOS 3.3
 29068                                  	;mov	[es:di+35h],bx ; MSDOS 6.0
 29069 00004D0C 26895D35                	MOV     [ES:DI+SF_ENTRY.sf_lstclus],BX
 29070 00004D10 07                      	POP	ES
 29071                                  	;retn
 29072                                  
 29073                                  	;pop	dx ; * MSDOS 6.0
 29074                                  
 29075                                  	; 16/12/2022
 29076                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29077                                  	;pop	dx ; *
 29078                                  
 29079 00004D11 C3                      	retn	
 29080                                  
 29081                                  ;** we're at the end of the disk, and not satisfied. See if we've scanned ALL
 29082                                  ;   of the disk...
 29083                                  
 29084                                  ads7:   
 29085 00004D12 26837E1D02              	cmp	word [ES:BP+DPB.NEXT_FREE],2
 29086 00004D17 7592                    	jnz	short ads1	; start scan from front of disk
 29087                                  
 29088                                  ;   Sorry, we've gone over the whole disk, with insufficient luck. Lets give
 29089                                  ;   the space back to the free list and tell the caller how much he could have
 29090                                  ;   had.  We have to make sure we remove the "special mark" we put on the last
 29091                                  ;   cluster we were able to allocate, so it doesn't become orphaned.
 29092                                  ;
 29093                                  ;       (CX) = clusters remaining to be allocated
 29094                                  ;       (TOS) = last cluster of file (before call to ALLOCATE)
 29095                                  ;       (TOS+1) = # of clusters wanted to allocate
 29096                                  
 29097 00004D19 5B                              POP     BX              ; (BX) = last cluster of file
 29098 00004D1A BAFFFF                          MOV     DX,0FFFFH
 29099 00004D1D E81F00                  	call	RELBLKS         ; give back any clusters just alloced
 29100 00004D20 58                              POP     AX              ; No. of clusters requested
 29101                                                                  ; Don't "retc". We are setting Carry anyway,
 29102                                                                  ;   Alloc failed, so proceed with return CX
 29103                                                                  ;   setup.
 29104 00004D21 29C8                            SUB     AX,CX           ; AX=No. of clusters allocated
 29105 00004D23 E80700                  	call	RESTFATBYT      ; Don't "retc". We are setting Carry anyway,
 29106                                                                  ;   Alloc failed.
 29107                                  Disk_Full_Return:               ;label added for magic patch 8-6-92 scottq
 29108                                          ; MSDOS 6.0
 29109 00004D26 C606[0B06]01            	MOV	byte [DISK_FULL],1 ;MS. indicating disk full
 29110 00004D2B F9                              STC
 29111 00004D2C C3                              retn
 29112                                  
 29113                                  ;-----------------------------------------------------------------------
 29114                                  ;
 29115                                  ; Procedure Name : RESTFATBYT
 29116                                  ;
 29117                                  ; SEE ALLOCATE CAVEAT
 29118                                  ;       Carry set if error (currently user FAILed to I 24)
 29119                                  ;-----------------------------------------------------------------------
 29120                                  
 29121                                  RESTFATBYT:
 29122 00004D2D 53                              PUSH    BX
 29123 00004D2E 52                              PUSH    DX
 29124 00004D2F 57                              PUSH    DI
 29125 00004D30 31DB                            XOR     BX,BX
 29126 00004D32 8B16[9605]                      MOV     DX,[FATBYT]
 29127 00004D36 E8C806                  	call	PACK
 29128 00004D39 5F                              POP     DI
 29129 00004D3A 5A                              POP     DX
 29130 00004D3B 5B                              POP     BX
 29131                                  ; 16/12/2022
 29132                                  ; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29133                                  ;RELEASE_flush:
 29134 00004D3C C3                      	retn
 29135                                  
 29136                                  ;Break	<RELEASE -- DEASSIGN DISK SPACE>
 29137                                  ;---------------------------------------------------------------------------
 29138                                  ;
 29139                                  ; Procedure Name : RELEASE
 29140                                  ;
 29141                                  ; Inputs:
 29142                                  ;       BX = Cluster in file
 29143                                  ;       ES:BP = Base of drive parameters
 29144                                  ; Function:
 29145                                  ;       Frees cluster chain starting with [BX]
 29146                                  ;       Carry set if error (currently user FAILed to I 24)
 29147                                  ; AX,BX,DX,DI all destroyed. Other registers unchanged.
 29148                                  ;
 29149                                  ;-----------------------------------------------------------------------------
 29150                                  
 29151                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29152                                  	; 20/05/2019 - Retro DOS v4.0
 29153                                  RELEASE:
 29154 00004D3D 31D2                            XOR     DX,DX
 29155                                  
 29156                                  	;entry	RELBLKS
 29157                                  RELBLKS:
 29158                                  
 29159                                  ;   Enter here with DX=0FFFFH to put an end-of-file mark in the first cluster
 29160                                  ;   and free the rest in the chain.
 29161                                  
 29162 00004D3F E86B06                  	call	UNPACK
 29163 00004D42 7224                    	jc	short RELEASE_flush
 29164 00004D44 7422                    	jz	short RELEASE_flush
 29165 00004D46 89F8                            MOV     AX,DI
 29166 00004D48 52                              PUSH    DX
 29167 00004D49 E8B506                  	call	PACK
 29168 00004D4C 5A                              POP     DX
 29169 00004D4D 7219                    	jc	short RELEASE_flush
 29170 00004D4F 09D2                            OR      DX,DX
 29171 00004D51 750B                            JNZ	short NO_DEALLOC	; Was putting EOF mark
 29172                                  	;;cmp	word [es:bp+1Eh],-1 ; MSDOS 3.3
 29173                                  	;cmp	word [es:bp+1Fh],-1 ; MSDOS 6.0
 29174 00004D53 26837E1FFF              	CMP     word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 29175 00004D58 7404                            JZ	short NO_DEALLOC	; No
 29176 00004D5A 26FF461F                        INC	word [ES:BP+DPB.FREE_CNT] ; Increase free count by 1
 29177                                  NO_DEALLOC:
 29178 00004D5E 89C3                            MOV     BX,AX
 29179 00004D60 48                              dec     ax              ; check for "1"
 29180 00004D61 7405                    	jz	short RELEASE_flush	; is last cluster of incomplete chain
 29181 00004D63 E83006                  	call	IsEOF
 29182 00004D66 72D5                            JB	short RELEASE	; Carry clear if JMP not taken
 29183                                  
 29184                                  	; 16/12/2022
 29185                                  ; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29186                                  ;%if 0
 29187                                  RELEASE_flush:
 29188                                  	; MSDOS 6.0
 29189 00004D68 268A4600                	mov	al,[es:bp]
 29190                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 29191 00004D6C 56                      	push	si		; FLUSHBUF may trash these and we guarantee
 29192 00004D6D 51                      	push	cx		;  them to be preserved.
 29193 00004D6E 06                      	push	es
 29194 00004D6F 55                      	push	bp
 29195 00004D70 E8420B                  	call	FLUSHBUF	; commit buffers for this drive
 29196 00004D73 5D                      	pop	bp
 29197 00004D74 07                      	pop	es
 29198 00004D75 59                      	pop	cx
 29199 00004D76 5E                      	pop	si
 29200                                  ;%endif
 29201                                  RET12:
 29202 00004D77 C3                      	retn
 29203                                  
 29204                                  ;Break	<GETEOF -- Find the end of a file>
 29205                                  ;------------------------------------------------------------------------
 29206                                  ;
 29207                                  ; Procedure Name : GETEOF
 29208                                  ;
 29209                                  ; Inputs:
 29210                                  ;       ES:BP Points to DPB
 29211                                  ;       BX = Cluster in a file
 29212                                  ;       DS = CS
 29213                                  ; Outputs:
 29214                                  ;       BX = Last cluster in the file
 29215                                  ;       Carry set if error (currently user FAILed to I 24)
 29216                                  ; DI destroyed. No other registers affected.
 29217                                  ;
 29218                                  ;--------------------------------------------------------------------------
 29219                                  
 29220                                  GETEOF:
 29221 00004D78 E83206                  	call	UNPACK
 29222 00004D7B 72FA                            jc	short RET12
 29223 00004D7D 53                              PUSH    BX
 29224 00004D7E 89FB                            MOV     BX,DI
 29225 00004D80 E81306                  	call	IsEOF
 29226 00004D83 5B                              POP     BX
 29227 00004D84 73F1                            JAE     short RET12
 29228 00004D86 89FB                            MOV     BX,DI
 29229 00004D88 EBEE                            JMP     short GETEOF
 29230                                  
 29231                                  ;============================================================================
 29232                                  ; FCB.ASM, MSDOS 6.0, 1991
 29233                                  ;============================================================================
 29234                                  ; 30/07/2018 - Retro DOS v3.0
 29235                                  ; 20/05/2019 - Retro DOS v4.0
 29236                                  
 29237                                  ;	TITLE	FCB - FCB parse calls for MSDOS
 29238                                  ;	NAME	FCB
 29239                                  
 29240                                  ;**	FCB.ASM - Low level routines for parsing names into FCBs and analyzing
 29241                                  ;		  filename characters
 29242                                  ;
 29243                                  ;	MakeFcb
 29244                                  ;	NameTrans
 29245                                  ;	PATHCHRCMP
 29246                                  ;	GetLet
 29247                                  ;	UCase
 29248                                  ;	GetLet3
 29249                                  ;	GetCharType
 29250                                  ;	TESTKANJ
 29251                                  ;	NORMSCAN
 29252                                  ;	DELIM
 29253                                  ;
 29254                                  ;	Revision history:
 29255                                  ;
 29256                                  ;		A000  version 4.00  Jan. 1988
 29257                                  ;	
 29258                                  ;	M048 - access FILE_UCASE_TAB using DS rather than SS.
 29259                                  
 29260                                  TableLook	EQU	-1
 29261                                  
 29262                                  SCANSEPARATOR	EQU	1
 29263                                  DRVBIT		EQU	2
 29264                                  NAMBIT		EQU	4
 29265                                  EXTBIT		EQU	8
 29266                                  
 29267                                  ;----------------------------------------------------------------------------
 29268                                  ;
 29269                                  ; Procedure : MakeFcb
 29270                                  ;
 29271                                  ;----------------------------------------------------------------------------
 29272                                  
 29273                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29274                                  	; DOSCODE:8E77h (MSDOS 5.0, MSDOS.SYS)
 29275                                  
 29276                                  	; 29/02/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
 29277                                  	; (MSDOS 6.22 MSDOS.SYS - DOSCODE:8ED3h)
 29278                                  MAKEFCB:
 29279                                  ;hkn; SS override
 29280                                  	;MOV	BYTE [SS:SpaceFlag],0
 29281 00004D8A 30D2                    	XOR	DL,DL		; Flag--not ambiguous file name
 29282                                  	; 29/02/2024
 29283 00004D8C 368816[4E03]            	mov	[ss:SpaceFlag],dl ; 0
 29284                                  	;test	al,2
 29285 00004D91 A802                    	test	AL,DRVBIT	; Use current drive field if default?
 29286 00004D93 7503                    	JNZ	short DEFDRV
 29287                                  	;MOV	BYTE [ES:DI],0	; No - use default drive
 29288                                  	; 29/02/2024
 29289 00004D95 268815                  	mov	[es:di],dl ; 0
 29290                                  DEFDRV:
 29291 00004D98 47                      	INC	DI
 29292 00004D99 B90800                  	MOV	CX,8
 29293                                  	;test	al,4
 29294 00004D9C A804                    	test	AL,NAMBIT	; Use current name fields as default?
 29295 00004D9E 93                      	XCHG	AX,BX		; Save bits in BX
 29296 00004D9F B020                    	MOV	AL," "
 29297 00004DA1 7404                    	JZ	short FILLB	; If not, go fill with blanks
 29298 00004DA3 01CF                    	ADD	DI,CX
 29299 00004DA5 31C9                    	XOR	CX,CX		; Don't fill any
 29300                                  FILLB:
 29301 00004DA7 F3AA                    	REP	STOSB
 29302 00004DA9 B103                    	MOV	CL,3
 29303 00004DAB F6C308                  	test	BL,EXTBIT	; Use current extension as default
 29304 00004DAE 7404                    	JZ	short FILLB2
 29305 00004DB0 01CF                    	ADD	DI,CX
 29306 00004DB2 31C9                    	XOR	CX,CX
 29307                                  FILLB2:
 29308 00004DB4 F3AA                    	REP	STOSB
 29309 00004DB6 91                      	XCHG	AX,CX		; Put zero in AX
 29310 00004DB7 AB                      	STOSW
 29311 00004DB8 AB                      	STOSW			; Initialize two words after to zero
 29312 00004DB9 83EF10                  	SUB	DI,16		; Point back at start
 29313                                  	;test	bl,1
 29314 00004DBC F6C301                  	test	BL,SCANSEPARATOR; Scan off separators if not zero
 29315 00004DBF 7409                    	JZ	short SKPSPC
 29316 00004DC1 E88800                  	CALL	SCANB		; Peel off blanks and tabs
 29317 00004DC4 E81E01                  	CALL	DELIM		; Is it a one-time-only delimiter?
 29318 00004DC7 7504                    	JNZ	short NOSCAN
 29319 00004DC9 46                      	INC	SI		; Skip over the delimiter
 29320                                  SKPSPC:
 29321 00004DCA E87F00                  	CALL	SCANB		; Always kill preceding blanks and tabs
 29322                                  NOSCAN:
 29323 00004DCD E8EC00                  	CALL	GETLET
 29324 00004DD0 761E                    	JBE	short NODRV	; Quit if termination character
 29325 00004DD2 803C3A                  	CMP	BYTE [SI],":"	; Check for potential drive specifier
 29326 00004DD5 7519                    	JNZ	short NODRV
 29327 00004DD7 46                      	INC	SI		; Skip over colon
 29328 00004DD8 2C40                    	SUB	AL,"@"          ; Convert drive letter to drive number (A=1)
 29329 00004DDA 760F                    	JBE	short BADDRV	; Drive letter out of range
 29330                                  
 29331 00004DDC 50                      	PUSH	AX
 29332 00004DDD E8D81A                  	call	GetVisDrv
 29333 00004DE0 58                      	POP	AX
 29334 00004DE1 730A                    	JNC	short HAVDRV
 29335                                  
 29336                                  	; 20/05/2019 - Retro DOS v4.0
 29337                                  	; MSDOS 6.0
 29338                                  ;hkn; SS override
 29339 00004DE3 36803E[1006]1A          	CMP	byte [SS:DrvErr],error_not_DOS_disk ; 1Ah
 29340                                  					; if not FAT drive ;AN000;
 29341 00004DE9 7402                    	JZ	short HAVDRV		; assume ok	   ;AN000;
 29342                                  BADDRV:
 29343 00004DEB B2FF                    	MOV	DL,-1
 29344                                  HAVDRV:
 29345 00004DED AA                      	STOSB			; Put drive specifier in first byte
 29346 00004DEE 46                      	INC	SI
 29347 00004DEF 4F                      	DEC	DI		; Counteract next two instructions
 29348                                  NODRV:
 29349 00004DF0 4E                      	DEC	SI		; Back up
 29350 00004DF1 47                      	INC	DI		; Skip drive byte
 29351                                  
 29352                                  	;entry	NORMSCAN
 29353                                  NORMSCAN:
 29354 00004DF2 B90800                  	MOV	CX,8
 29355 00004DF5 E82200                  	CALL	GETWORD 	; Get 8-letter file name
 29356 00004DF8 803C2E                  	CMP	BYTE [SI],"."
 29357 00004DFB 7510                    	JNZ	short NODOT
 29358 00004DFD 46                      	INC	SI		; Skip over dot if present
 29359                                  
 29360                                  	; 24/09/2023
 29361                                  	;mov	cx,3
 29362 00004DFE B103                    	mov	cl,3	; ch=0
 29363                                  
 29364                                  	; MSDOS 6.0
 29365                                  ;hkn; SS override
 29366                                  	;TEST	word [SS:DOS34_FLAG],DBCS_VOLID2 ; 100h ;AN000;
 29367                                  	; 10/06/2019
 29368 00004E00 36F606[1206]01          	test	byte [SS:DOS34_FLAG+1],(DBCS_VOLID2>>8) ; 1
 29369 00004E06 7402                    	JZ	short VOLOK				;AN000;
 29370 00004E08 A4                      	MOVSB			; 2nd byte of DBCS	;AN000;
 29371                                  	; 24/09/2023
 29372                                  	;MOV	CX,2					;AN000;
 29373 00004E09 49                      	dec	cx  ; cx=2
 29374                                  	;JMP	SHORT contvol				;AN000;
 29375                                  VOLOK:
 29376                                  	;MOV	CX,3		; Get 3-letter extension
 29377                                  contvol:
 29378 00004E0A E81300                  	CALL	MUSTGETWORD
 29379                                  NODOT:
 29380 00004E0D 88D0                    	MOV	AL,DL
 29381                                  
 29382                                  	; MSDOS 6.0
 29383                                  	;and	word [ss:DOS34_FLAG],0FEFFh
 29384                                  	; 18/12/2022
 29385 00004E0F 368026[1206]FE          	and	byte [ss:DOS34_FLAG+1],0FEh ; (~DBCS_VOLID2)>>8
 29386                                  	;and	word [ss:DOS34_FLAG],~DBCS_VOLID2 ; ### BUG FIX ###
 29387                                  
 29388 00004E15 C3                      	retn
 29389                                  
 29390                                  NONAM:
 29391 00004E16 01CF                    	ADD	DI,CX
 29392 00004E18 4E                      	DEC	SI
 29393 00004E19 C3                      	retn
 29394                                  
 29395                                  GETWORD:
 29396 00004E1A E89F00                  	CALL	GETLET		
 29397 00004E1D 76F7                    	JBE	short NONAM	; Exit if invalid character
 29398 00004E1F 4E                      	DEC	SI
 29399                                  
 29400                                  ;	UGH!!! Horrible bug here that should be fixed at some point:
 29401                                  ;	If the name we are scanning is longer than CX, we keep on reading!
 29402                                  
 29403                                  MUSTGETWORD:
 29404 00004E20 E89900                  	CALL	GETLET
 29405                                  
 29406                                  ;	If spaceFlag is set then we allow spaces in a pathname
 29407                                  
 29408                                  ;IF NOT TABLELOOK
 29409                                  ;	JB	short FILLNAM  ; MSDOS 3.3
 29410                                  ;ENDIF
 29411 00004E23 750C                    	JNZ	short MustCheckCX
 29412                                  
 29413                                  ;hkn; SS override
 29414 00004E25 36F606[4E03]FF          	test	BYTE [SS:SpaceFlag],0FFh
 29415 00004E2B 7419                    	JZ	short FILLNAM
 29416 00004E2D 3C20                    	CMP	AL," "
 29417 00004E2F 7515                    	JNZ	short FILLNAM
 29418                                  
 29419                                  MustCheckCX:
 29420 00004E31 E3ED                    	JCXZ	MUSTGETWORD
 29421 00004E33 49                      	DEC	CX
 29422 00004E34 3C2A                    	CMP	AL,"*"          ; Check for ambiguous file specifier
 29423 00004E36 7504                    	JNZ	short NOSTAR
 29424 00004E38 B03F                    	MOV	AL,"?"
 29425 00004E3A F3AA                    	REP	STOSB
 29426                                  NOSTAR:
 29427 00004E3C AA                      	STOSB
 29428 00004E3D 3C3F                    	CMP	AL,"?"
 29429 00004E3F 75DF                    	JNZ	short MUSTGETWORD
 29430 00004E41 80CA01                  	OR	DL,1		; Flag ambiguous file name
 29431 00004E44 EBDA                    	JMP	short MUSTGETWORD
 29432                                  FILLNAM:
 29433 00004E46 B020                    	MOV	AL," "
 29434 00004E48 F3AA                    	REP	STOSB
 29435 00004E4A 4E                      	DEC	SI
 29436 00004E4B C3                      	retn
 29437                                  
 29438                                  SCANB:
 29439 00004E4C AC                      	LODSB
 29440 00004E4D E89D00                  	CALL	SPCHK
 29441 00004E50 74FA                    	JZ	short SCANB
 29442 00004E52 4E                      	DEC	SI
 29443                                  scanb_retn:
 29444 00004E53 C3                      	retn
 29445                                  
 29446                                  ;----------------------------------------------------------------------------
 29447                                  ;
 29448                                  ; Procedure Name : NameTrans
 29449                                  ;
 29450                                  ; NameTrans is used by FindPath to scan off an element of a path. We must
 29451                                  ; allow spaces in pathnames
 29452                                  ;
 29453                                  ;   Inputs:	DS:SI points to start of path element
 29454                                  ;   Outputs:	Name1 has unpacked name, uppercased
 29455                                  ;		ES = DOSGroup
 29456                                  ;		DS:SI advanced after name
 29457                                  ;   Registers modified: DI,AX,DX,CX
 29458                                  ;
 29459                                  ;----------------------------------------------------------------------------
 29460                                  
 29461                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29462                                  	; 20/05/2019 - Retro DOS v4.0
 29463                                  
 29464                                  	; 29/02/2024 - Retro DOS v4.1
 29465                                  
 29466                                  NameTrans:
 29467                                  ;hkn; SS override
 29468 00004E54 36C606[4E03]01          	MOV	BYTE [SS:SpaceFlag],1
 29469 00004E5A 16                      	push	ss
 29470 00004E5B 07                      	pop	es
 29471                                  
 29472                                  ;hkn; NAME1 is in DOSDATA
 29473 00004E5C BF[4B05]                	MOV	DI,NAME1
 29474 00004E5F 57                      	PUSH	DI
 29475                                  
 29476                                  ; 29/02/2024
 29477                                  %if 0
 29478                                  	MOV	AX,'  '	; 2020h
 29479                                  	MOV	CX,5
 29480                                  	STOSB
 29481                                  	REP	STOSW		; Fill "FCB" at NAME1 with spaces
 29482                                  	XOR	AL,AL		; Set stuff for NORMSCAN
 29483                                  	MOV	DL,AL
 29484                                  %else
 29485                                  	; 29/02/2024
 29486                                  	; (PCDOS 7.1 IBMDOS.COM)
 29487 00004E60 B020                    	mov     al,20h ; ' '
 29488 00004E62 B90B00                  	mov     cx,11
 29489 00004E65 F3AA                    	rep stosb               ; Fill "FCB" at NAME1 with spaces
 29490 00004E67 91                      	xchg    ax,cx
 29491 00004E68 99                      	cwd
 29492                                  %endif
 29493                                  
 29494 00004E69 AA                      	STOSB
 29495 00004E6A 5F                      	POP	DI
 29496                                  
 29497 00004E6B E884FF                  	CALL	NORMSCAN
 29498                                  
 29499                                  ;hkn; SS override for NAME1
 29500 00004E6E 36803E[4B05]E5          	CMP	byte [SS:NAME1],0E5H
 29501 00004E74 75DD                    	jnz	short scanb_retn
 29502 00004E76 36C606[4B05]05          	MOV	byte [SS:NAME1],5 ; Magic name translation
 29503 00004E7C C3                      	retn
 29504                                  
 29505                                  ;Break	<GETLET, DELIM -- CHECK CHARACTERS AND CONVERT>
 29506                                  ;============================================================================
 29507                                  
 29508                                  ; 20/05/2019 - Retro DOS v4.0
 29509                                  ; DOSCODE:8FD2h (MSDOS 6.21, MSDOS.SYS)
 29510                                  
 29511                                  ;If TableLook
 29512                                  
 29513                                  ;hkn; Table	SEGMENT
 29514                                  ;	PUBLIC	CharType
 29515                                  ;----------------------------------------------------------------------------
 29516                                  
 29517                                  ; Character type table for file name scanning
 29518                                  ; Table provides a mapping of characters to validity bits.
 29519                                  ; Four bits are provided for each character. Values 7Dh and above
 29520                                  ; have all bits set, so that part of the table is chopped off, and
 29521                                  ; the translation routine is responsible for screening these values.
 29522                                  ; The bit values are defined in DOSSYM.INC
 29523                                  
 29524                                  ;	      ; ^A and NUL
 29525                                  ;CharType:
 29526                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29527                                  ;	      ; ^C and ^B
 29528                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29529                                  ;	      ; ^E and ^D
 29530                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29531                                  ;	      ; ^G and ^F
 29532                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29533                                  ;	      ; TAB and BS
 29534                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM+FSPCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29535                                  ;	      ; ^K and ^J
 29536                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29537                                  ;	      ; ^M and ^L
 29538                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29539                                  ;	      ; ^O and ^N
 29540                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29541                                  ;	      ; ^Q and ^P
 29542                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29543                                  ;	      ; ^S and ^R
 29544                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29545                                  ;	      ; ^U and ^T
 29546                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29547                                  ;	      ; ^W and ^V
 29548                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29549                                  ;	      ; ^Y and ^X
 29550                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29551                                  ;	      ; ESC and ^Z
 29552                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29553                                  ;	      ; ^] and ^;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29555                                  ;	      ; ^_ and ^^
 29556                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29557                                  ;	      ; ! and SPACE
 29558                                  ;	 db   LOW (NOT FCHK+FDELIM+FSPCHK)
 29559                                  ;	      ; # and "
 29560                                  ;	 db   LOW (NOT FFCB+FCHK)
 29561                                  ;	      ; $ - )
 29562                                  ;	 db   3 dup (0FFh)
 29563                                  ;	      ; + and *
 29564                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR 0Fh
 29565                                  ;	      ; - and '
 29566                                  ;	 db   NOT (FFCB+FCHK+FDELIM)
 29567                                  ;	      ; / and .
 29568                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FCHK) AND 0Fh
 29569                                  ;	      ; 0 - 9
 29570                                  ;	 db   5 dup (0FFh)
 29571                                  ;	      ; ; and :
 29572                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
 29573                                  ;	      ; = and <
 29574                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
 29575                                  ;	      ; ? and >
 29576                                  ;	 db   NOT FFCB+FCHK+FDELIM
 29577                                  ;	      ; A - Z
 29578                                  ;	 db   13 dup (0FFh)
 29579                                  ;	      ; \ and [
 29580                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR 0Fh
 29581                                  ;	      ; ^ and ]
 29582                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 29583                                  ;	      ; _ - {
 29584                                  ;	 db   15 dup (0FFh)
 29585                                  ;	      ; } and |
 29586                                  ;	 db   NOT FFCB+FCHK+FDELIM
 29587                                  
 29588                                  ;CharType_last equ ($ - CharType) * 2	; This is the value of the last
 29589                                  ;					; character in the table
 29590                                  
 29591                                  ;FCHK	equ 1		; normal name char, no chks needed
 29592                                  ;FDELIM	equ 2		; is a delimiter
 29593                                  ;FSPCHK	equ 4		; set if character is not a space or equivalent
 29594                                  ;FFCB	equ 8		; is valid in an FCB
 29595                                  
 29596                                  ; DOSCODE:8FD2h (MSDOS 6.21, MSDOS.SYS)
 29597                                  ;----------------------------------------------------------------------------
 29598                                  ; DOSCODE:8F76h (MSDOS 5.0, MSDOS.SYS)
 29599                                  
 29600                                  CharType: ; 63 bytes
 29601 00004E7D 6666666606666666                db  66h, 66h, 66h, 66h, 06h, 66h, 66h, 66h ; 0-7
 29602 00004E85 6666666666666666        	db  66h, 66h, 66h, 66h, 66h, 66h, 66h, 66h ; 8-15
 29603 00004E8D F8F6FFFFFF4FF46E        	db 0F8h,0F6h,0FFh,0FFh,0FFh, 4Fh,0F4h, 6Eh ; 16-23
 29604 00004E95 FFFFFFFFFF4444F4        	db 0FFh,0FFh,0FFh,0FFh,0FFh, 44h, 44h,0F4h ; 24-31
 29605 00004E9D FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh ; 32-39
 29606 00004EA5 FFFFFFFFFF6F66FF        	db 0FFh,0FFh,0FFh,0FFh,0FFh, 6Fh, 66h,0FFh ; 40-47
 29607 00004EAD FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh ; 48-55
 29608 00004EB5 FFFFFFFFFFFFF4          	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0F4h	   ; 56-62
 29609                                  
 29610                                  CharType_last equ ($ - CharType) * 2
 29611                                  
 29612                                  ; Offset 12CAh of IBMDOS.COM (MSDOS 3.3), 1987
 29613                                  ;----------------------------------------------------------------------------
 29614                                  ;CharType:
 29615                                  ;       db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 29616                                  ;	db 0F6h,0F0h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 29617                                  ;	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 29618                                  ;	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 29619                                  ;	db 0F8h,0FFh,0F6h,0FFh,0FFh,0FFh,0FFh,0FFh
 29620                                  ;	db 0FFh,0FFh,0FFh,0F4h,0F4h,0FFh,0FEh,0F6h
 29621                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29622                                  ;	db 0FFh,0FFh,0F4h,0F4h,0F4h,0F4h,0F4h,0FFh
 29623                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29624                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29625                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29626                                  ;	db 0FFh,0FFh,0FFh,0F6h,0F6h,0F6h,0FFh,0FFh
 29627                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29628                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29629                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29630                                  ;	db 0FFh,0FFh,0FFh,0FFh,0F4h,0FFh,0FFh,0FFh
 29631                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29632                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29633                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29634                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29635                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29636                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29637                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29638                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29639                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29640                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29641                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29642                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29643                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29644                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29645                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29646                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 29647                                  
 29648                                  ;hkn; Table	ENDS
 29649                                  
 29650                                  ;ENDIF
 29651                                  
 29652                                  ; 20/05/2019 - Retro DOS v4.0
 29653                                  ; DOSCODE:9011h (MSDOS 6.21, MSDOS.SYS)
 29654                                  
 29655                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29656                                  ; DOSCODE:8FB5h (MSDOS 5.0, MSDOS.SYS)
 29657                                  
 29658                                  ;----------------------------------------------------------------------------
 29659                                  ;
 29660                                  ; Procedure Names : GetLet, UCase, GetLet3
 29661                                  ;
 29662                                  ; These routines take a character, convert it to upper case, and check
 29663                                  ; for delimiters.  Three different entry points:
 29664                                  ;	GetLet -  DS:[SI] = character to convert
 29665                                  ;	UCase  -  AL = character to convert
 29666                                  ;	GetLet3 - AL = character
 29667                                  ;		  [BX] = translation table to use
 29668                                  ;
 29669                                  ;	Exit (in all cases) : AL = upper case character
 29670                                  ;			      CY set if char is control char other than TAB
 29671                                  ;			      ZF set if char is a delimiter
 29672                                  ;	Uses : AX, flags
 29673                                  ;
 29674                                  ; NOTE: This routine exists in a fast table lookup version, and a slow
 29675                                  ; inline version.  Return with carry set is only possible in the inline
 29676                                  ; version. The table lookup version is the one in use.
 29677                                  ;
 29678                                  ;----------------------------------------------------------------------------
 29679                                  
 29680                                  ; This entry point has character at [SI]
 29681                                  
 29682                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5517h
 29683                                  GETLET:	
 29684 00004EBC AC                      	LODSB
 29685                                  
 29686                                  ; This entry point has character in AL
 29687                                  
 29688                                  	;entry	UCase
 29689                                  UCase:	
 29690                                  	; 09/08/2018
 29691                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5518h
 29692                                  _UCase:
 29693 00004EBD 53                      	PUSH	BX
 29694 00004EBE BB[310B]                	MOV	BX,FILE_UCASE_TAB+2
 29695                                  
 29696                                  ; Convert the character in AL to upper case
 29697                                  
 29698                                  gl_0:
 29699 00004EC1 3C61                    	CMP	AL,"a"
 29700 00004EC3 7214                    	JB	short gl_2	; Already upper case, go check type
 29701 00004EC5 3C7A                    	CMP	AL,"z"
 29702 00004EC7 7702                    	JA	short gl_1
 29703 00004EC9 2C20                    	SUB	AL,20H		; Convert to upper case
 29704                                  
 29705                                  ; Map European character to upper case
 29706                                  
 29707                                  gl_1:
 29708 00004ECB 3C80                    	CMP	AL,80H
 29709 00004ECD 720A                    	JB	short gl_2	; Not EuroChar, go check type
 29710 00004ECF 2C80                    	SUB	AL,80H		; translate to upper case with this index
 29711                                  
 29712                                  	; M048 - Start 
 29713                                  	; Lantastic call Ucase thru int 2f without setting SS to DOSDATA.
 29714                                  	; So we shall set up DS and to access FILE_UCASE_TAB in BX and also 
 29715                                  	; preserve it.
 29716                                  
 29717                                  	; 09/08/2018 - Retro DOS v3.0
 29718                                  	; MSDOS 3.3
 29719                                  	;;XLAT	BYTE [CS:BX]	; ds as file_ucase_tab is in DOSDATA
 29720                                  	;CS	XLAT
 29721                                  
 29722                                  	; 20/05/2019 - Retro DOS v4.0
 29723                                  
 29724                                  	; MSDOS 6.0
 29725 00004ED1 1E                      	push	ds
 29726                                  	;getdseg <ds>
 29727 00004ED2 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 29728 00004ED7 D7                      	XLAT			; ds as file_ucase_tab is in DOSDATA
 29729 00004ED8 1F                      	pop	ds
 29730                                  
 29731                                  	; M048 - End
 29732                                  
 29733                                  ; Now check the type
 29734                                  
 29735                                  ;If TableLook
 29736                                  gl_2:
 29737                                  	; 20/05/2019 - Retro DOS v4.0
 29738 00004ED9 50                      	PUSH	AX
 29739                                  
 29740                                  	; MSDOS 3.3
 29741                                  	;mov	bx,CharType
 29742                                  	;; 09/08/2018
 29743                                  	;;xlat	byte [cs:bx]
 29744                                  	;cs	xlat	
 29745                                  	
 29746                                  	; MSDOS 6.0
 29747 00004EDA E81800                  	CALL	GetCharType	; returns type flags in AL
 29748                                  	
 29749                                  	;test	al,1	
 29750 00004EDD A801                    	TEST	AL,FCHK 	; test for normal character
 29751 00004EDF 58                      	POP	AX
 29752                                  
 29753 00004EE0 5B                      	POP	BX
 29754 00004EE1 C3                      	RETN
 29755                                  
 29756                                  ; This entry has character in AL and lookup table in BX
 29757                                  
 29758                                  	; MSDOS 6.0
 29759                                  ;	;entry GetLet3
 29760                                  GETLET3: ; 10/08/2018
 29761 00004EE2 53                      	PUSH	BX
 29762 00004EE3 EBDC                    	JMP	short gl_0
 29763                                  ;ELSE
 29764                                  ;
 29765                                  ;gl_2:
 29766                                  ;	POP	BX
 29767                                  ;	CMP	AL,"."
 29768                                  ;	retz
 29769                                  ;	CMP	AL,'"'
 29770                                  ;	retz
 29771                                  ;	CALL	PATHCHRCMP
 29772                                  ;	retz
 29773                                  ;	CMP	AL,"["
 29774                                  ;	retz
 29775                                  ;	CMP	AL,"]"
 29776                                  ;	retz
 29777                                  ;ENDIF
 29778                                  
 29779                                  ;---------------------------------------------------------------------
 29780                                  ;
 29781                                  ; DELIM - check if character is a delimiter
 29782                                  ;	Entry : AX = character to check
 29783                                  ;	Exit  : ZF set if character is not a delimiter
 29784                                  ;	Uses  : Flags
 29785                                  ;
 29786                                  ;--------------------------------------------------------------------
 29787                                  
 29788                                  	;entry	DELIM
 29789                                  DELIM:
 29790                                  ;IF TableLook
 29791                                  	; 20/05/2019 - Retro DOS v4.0
 29792 00004EE5 50                      	PUSH	AX
 29793                                  
 29794                                  	; MSDOS 3.3
 29795                                  	;push	bx
 29796                                  	;mov	bx,CharType
 29797                                  	;;09/08/2018
 29798                                  	;;xlat	byte [cs:bx]
 29799                                  	;cs	xlat
 29800                                  	;pop	bx
 29801                                  
 29802                                  	; MSDOS 6.0
 29803 00004EE6 E80C00                  	CALL	GetCharType
 29804                                  	
 29805                                  	;test	al,2
 29806 00004EE9 A802                    	TEST	AL,FDELIM
 29807 00004EEB 58                      	POP	AX
 29808 00004EEC C3                      	RETN
 29809                                  ;ELSE
 29810                                  ;	CMP	AL,":"
 29811                                  ;	retz
 29812                                  ;
 29813                                  ;	CMP	AL,"<"
 29814                                  ;	retz
 29815                                  ;	CMP	AL,"|"
 29816                                  ;	retz
 29817                                  ;	CMP	AL,">"
 29818                                  ;	retz
 29819                                  ;
 29820                                  ;	CMP	AL,"+"
 29821                                  ;	retz
 29822                                  ;	CMP	AL,"="
 29823                                  ;	retz
 29824                                  ;	CMP	AL,";"
 29825                                  ;	retz
 29826                                  ;	CMP	AL,","
 29827                                  ;	retz
 29828                                  ;ENDIF
 29829                                  
 29830                                  ;-------------------------------------------------------------------------
 29831                                  ;
 29832                                  ;  SPCHK - checks to see if a character is a space or equivalent
 29833                                  ;	Entry : AL = character to check
 29834                                  ;	Exit  : ZF set if character is a space
 29835                                  ;	Uses  : flags
 29836                                  ;
 29837                                  ;-------------------------------------------------------------------------
 29838                                  
 29839                                  	;entry SPCHK
 29840                                  SPCHK:
 29841                                  ;IF TableLook
 29842                                  	; 20/05/2019 - Retro DOS v4.0
 29843 00004EED 50                      	PUSH	AX
 29844                                  
 29845                                  	; MSDOS 3.3
 29846                                  	;push	bx
 29847                                  	;mov	bx,CharType
 29848                                  	;; 09/08/2018
 29849                                  	;;xlat	byte [cs:bx]
 29850                                  	;cs	xlat
 29851                                  	;pop	bx
 29852                                  
 29853                                  	; MSDOS 6.0
 29854 00004EEE E80400                  	CALL	GetCharType
 29855                                  	
 29856                                  	;test	al,4
 29857 00004EF1 A804                    	TEST	AL,FSPCHK
 29858 00004EF3 58                      	POP	AX
 29859 00004EF4 C3                      	RETN
 29860                                  ;ELSE
 29861                                  ;	CMP	AL,9		; Filter out tabs too
 29862                                  ;	retz
 29863                                  ;; WARNING! " " MUST be the last compare
 29864                                  ;	CMP	AL," "
 29865                                  ;	return
 29866                                  ;ENDIF
 29867                                  
 29868                                  ;-------------------------------------------------------------------------
 29869                                  ;
 29870                                  ;  GetCharType - return flag bits indicating character type
 29871                                  ;	Bits are defined in DOSSYM.INC. Uses lookup table
 29872                                  ;	defined above at label CharType.
 29873                                  ;
 29874                                  ;	Entry : AL = character to return type flags for
 29875                                  ;	Exit  : AL = type flags
 29876                                  ;	Uses  : AL, flags
 29877                                  ;
 29878                                  ;-------------------------------------------------------------------------
 29879                                  
 29880                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29881                                  
 29882                                  	; 20/05/2019 - Retro DOS v4.0
 29883                                  	; MSDOS 6.0
 29884                                  GetCharType:
 29885                                  	;cmp	al,7Eh
 29886 00004EF5 3C7E                    	cmp	al,CharType_last 	; beyond end of table?
 29887 00004EF7 7316                    	jae	short gct_90		; return standard value
 29888                                  
 29889 00004EF9 53                      	push	bx
 29890 00004EFA BB[7D4E]                	mov	bx,CharType		; load lookup table
 29891 00004EFD D0E8                    	shr	al,1			; adjust for half-byte table entry size
 29892                                  	;xlat	cs:[bx] 		; get flags
 29893 00004EFF 2ED7                    	cs	xlat	
 29894 00004F01 5B                      	pop	bx
 29895                                  
 29896                                  ; carry clear from previous shift means we want the low nibble.  Otherwise
 29897                                  ; we have to shift the flags down to the low nibble
 29898                                  
 29899 00004F02 7308                    	jnc	short gct_80		; carry clear, no shift needed
 29900                                  
 29901 00004F04 D0E8                    	shr	al,1			; we want high nibble, shift it down
 29902 00004F06 D0E8                    	shr	al,1
 29903 00004F08 D0E8                    	shr	al,1
 29904 00004F0A D0E8                    	shr	al,1
 29905                                  gct_80:
 29906 00004F0C 240F                    	and	al,0Fh			; clear the unused nibble
 29907 00004F0E C3                      	retn
 29908                                  gct_90:
 29909 00004F0F B00F                    	mov	al,0Fh			; set all flags
 29910 00004F11 C3                      	retn
 29911                                  
 29912                                  ;----------------------------------------------------------------------------
 29913                                  ;
 29914                                  ; Procedure : PATHCHRCMP
 29915                                  ;
 29916                                  ;----------------------------------------------------------------------------
 29917                                  
 29918                                  PATHCHRCMP:
 29919 00004F12 3C2F                    	CMP	AL,'/'
 29920 00004F14 7606                    	JBE	short PathRet
 29921 00004F16 3C5C                    	CMP	AL,'\'
 29922 00004F18 C3                      	retn
 29923                                  GotFor:
 29924 00004F19 B05C                    	MOV	AL,'\'
 29925 00004F1B C3                      	retn
 29926                                  PathRet:
 29927 00004F1C 74FB                    	JZ	short GotFor
 29928 00004F1E C3                      	retn
 29929                                  
 29930                                  ;============================================================================
 29931                                  ; MSCRTLC.ASM, MSDOS 6.0, 1991
 29932                                  ;============================================================================
 29933                                  ; 30/07/2018 - Retro DOS v3.0
 29934                                  ; 29/04/2019 - Retro DOS v4.0
 29935                                  
 29936                                  ; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11, CTRLC.ASM, 1983)
 29937                                  
 29938                                  ;**	MSCTRLC.ASM - ^C and error handler for MSDOS
 29939                                  
 29940                                  ;	TITLE	Control C detection, Hard error and EXIT routines
 29941                                  ;	NAME	IBMCTRLC
 29942                                  
 29943                                  ;**	Low level routines for detecting special characters on CON input,
 29944                                  ;	the ^C exit/int code, the Hard error INT 24 code, the
 29945                                  ;	process termination code, and the INT 0 divide overflow handler.
 29946                                  ;
 29947                                  ;	FATAL
 29948                                  ;	FATAL1
 29949                                  ;	reset_environment
 29950                                  ;	DSKSTATCHK
 29951                                  ;	SPOOLINT
 29952                                  ;	STATCHK
 29953                                  ;	CNTCHAND
 29954                                  ;	DIVOV
 29955                                  ;	CHARHARD
 29956                                  ;	HardErr
 29957                                  ;
 29958                                  ;	Revision history:
 29959                                  ;
 29960                                  ;	    AN000	version 4.0   Jan 1988
 29961                                  ;	    A002	PTM    -- dir >lpt3 hangs
 29962                                  ;	    A003	PTM 3957- fake version for IBMCAHE.COM
 29963                                  ;
 29964                                  ; 	M011: NEC's 8086 clone chip uses Intel's undocumented bit number in
 29965                                  ;	      flags register. In order to return to user normally DOS used to
 29966                                  ;	      move F202 into flags, which sets bit number 1 in flags uncondit-
 29967                                  ;	      ionally. Now it is modified to maintain the state of bit 1.
 29968                                  ;
 29969                                  ; 	M024: suppressed fail and ignore options if not in the middle of int 
 29970                                  ;	      24 and if Ctrl P or ctrl printscrn is pressed in routine 
 29971                                  ;	      charhard.
 29972                                  
 29973                                  ; 29/04/2019 - Retro DOS v4.0
 29974                                  	; MSDOS 6.0
 29975                                  ;		public	LowInt23Addr		
 29976                                  LowInt23Addr: ;	LABEL	DWORD
 29977 00004F1F [E710]0000              	DW	LowInt23, 0
 29978                                  
 29979                                  ;		public	LowInt24Addr
 29980                                  LowInt24Addr: ;	LABEL	DWORD
 29981 00004F23 [FB10]0000              	DW	LowInt24, 0
 29982                                  
 29983                                  ;		public	LowInt28Addr
 29984                                  LowInt28Addr: ;	LABEL	DWORD
 29985 00004F27 [0F11]0000              	DW	LowInt28, 0
 29986                                  
 29987                                  ;Break	<Checks for ^C in CON I/O>
 29988                                  
 29989                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29990                                  ; 05/05/2019 - Retro DOS v4.0
 29991                                  
 29992                                  ;---------------------------------------------------------------------------
 29993                                  ;
 29994                                  ; Procedure Name : DSKSTATCHK
 29995                                  ;
 29996                                  ; Check for ^C if only one level in
 29997                                  ;
 29998                                  ;---------------------------------------------------------------------------
 29999                                  
 30000                                          ;procedure DSKSTATCHK,NEAR ; Check for ^C if only one level in
 30001                                  
 30002                                  	; 29/02/2024 - Retro DOS v4.2
 30003                                  
 30004                                  DSKSTATCHK:        
 30005                                  	;CMP	BYTE [INDOS],1
 30006 00004F2B 36803E[2103]01          	CMP	BYTE [SS:INDOS],1 ; 15/03/2018
 30007                                  	;retnz			; Do NOTHING
 30008                                  	; 16/12/2022
 30009 00004F31 7537                    	JNZ	SHORT _RET37 ; Retro DOS v2.0 - 04/03/2018
 30010                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30011                                  	;jz	short _RET37 ; dskstatchk1
 30012                                  	;retn
 30013                                  ;_RET37:
 30014                                  ;dskstatchk1:
 30015 00004F33 51                      	PUSH    CX
 30016 00004F34 06                      	PUSH    ES
 30017 00004F35 53                      	PUSH    BX
 30018 00004F36 1E                      	PUSH    DS
 30019 00004F37 56                      	PUSH    SI
 30020                                          
 30021                                  	;PUSH	CS
 30022                                  	;POP	ES
 30023                                  	;PUSH	CS
 30024                                  	;POP	DS
 30025                                  
 30026 00004F38 8CD3                    	MOV	BX,SS		; SS is DOSDATA. ES:BX must be set up
 30027 00004F3A 8EC3                    	MOV	ES,BX		; for deviocall2
 30028 00004F3C 8EDB                    	MOV	DS,BX
 30029                                  
 30030                                  	; 16/12/2022
 30031                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30032                                  
 30033                                  	; 05/05/2019
 30034                                  	;MOV	BYTE [ss:DSKSTCOM],DEVRDND
 30035                                          ;MOV	BYTE [ss:DSKSTCALL],DRDNDHL
 30036                                  	;mov	word [ss:DSKSTST],0
 30037                                  
 30038                                  	; 16/12/2022
 30039                                  	; 25/06/2019
 30040 00004F3E C606[9403]05            	MOV	BYTE [DSKSTCOM],DEVRDND	 ; 5
 30041 00004F43 C606[9203]0E                    MOV	BYTE [DSKSTCALL],DRDNDHL ; 14
 30042 00004F48 C706[9503]0000          	mov	word [DSKSTST],0
 30043                                  
 30044 00004F4E BB[9203]                        MOV     BX,DSKSTCALL
 30045                                  
 30046                                  	;LDS	SI,[ss:BCON]
 30047                                          ; 25/062019
 30048 00004F51 C536[3200]              	lds	si,[BCON]
 30049                                  
 30050                                  ; 16/12/2022
 30051                                  ;	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30052                                  ;	mov	byte [ss:DSKSTCOM],DEVRDND  ; 5
 30053                                  ;       mov	byte [ss:DSKSTCALL],DRDNDHL ; 14
 30054                                  ;	mov	word [ss:DSKSTST],0
 30055                                  ;	mov	bx,DSKSTCALL
 30056                                  ;	lds	si,[ss:BCON]
 30057                                  
 30058 00004F55 E8B1F5                  	CALL	DEVIOCALL2
 30059                                  
 30060                                  	; 29/02/2024
 30061 00004F58 1E                      	push	ds ; *
 30062 00004F59 16                      	push	ss
 30063 00004F5A 1F                      	pop	ds
 30064                                  
 30065                                   	; 15/03/2018
 30066                                  	;;test	word [ss:DSKSTST],200h
 30067                                          ;TEST	WORD [SS:DSKSTST],STBUI
 30068                                  	; 05/05/2019
 30069                                  	;test	byte [ss:DSKSTST+1],(STBUI>>8) ; 2
 30070                                  	; 29/02/2024
 30071 00004F5B F606[9603]02            	test	byte [DSKSTST+1],(STBUI>>8) ; 2
 30072 00004F60 7409                    	jz	short _GotCh		; No characters available
 30073                                  
 30074 00004F62 30C0                    	XOR	AL,AL			; Set zero
 30075                                  RET36:
 30076                                  	; 29/02/2024
 30077 00004F64 5E                      	pop	si ; *
 30078                                  	;
 30079 00004F65 5E                      	POP	SI
 30080 00004F66 1F                      	POP	DS
 30081 00004F67 5B                      	POP	BX
 30082 00004F68 07                      	POP	ES
 30083 00004F69 59                      	POP	CX
 30084                                  	; 16/12/2022
 30085                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30086                                  _RET37:
 30087 00004F6A C3                      	RETN
 30088                                  
 30089                                  _GotCh:
 30090                                  
 30091                                  ; 29/02/2024
 30092                                  %if 0
 30093                                  	MOV	AL,[SS:DSKCHRET]	; SS override
 30094                                  
 30095                                  	CMP	AL,"C"-"@" ; cmp al,3
 30096                                  	JNZ	SHORT RET36
 30097                                  	MOV	BYTE [SS:DSKSTCOM],DEVRD
 30098                                  	MOV	BYTE [SS:DSKSTCALL],DRDWRHL
 30099                                  	MOV	[SS:DSKCHRET],CL
 30100                                  	; 09/09/2018
 30101                                  	MOV	word [SS:DSKSTST],0
 30102                                  	MOV	word [SS:DSKSTCNT],1
 30103                                  %else
 30104                                  	; 29/02/2024
 30105 00004F6B A0[9F03]                	mov	al,[DSKCHRET]
 30106                                  
 30107 00004F6E 3C03                    	cmp	al,"C"-"@" ; cmp al,3
 30108 00004F70 75F2                    	jnz	short RET36
 30109                                  
 30110 00004F72 C606[9403]04            	mov	byte [DSKSTCOM],DEVRD
 30111 00004F77 C606[9203]16            	mov	byte [DSKSTCALL],DRDWRHL
 30112 00004F7C 880E[9F03]              	mov	[DSKCHRET],cl
 30113 00004F80 C706[9503]0000          	mov	word [DSKSTST],0
 30114 00004F86 C706[A403]0100          	mov	word [DSKSTCNT],1
 30115 00004F8C 1F                      	pop	ds ; *
 30116                                  %endif
 30117                                  	
 30118 00004F8D E879F5                  	CALL	DEVIOCALL2              ; Eat the ^C
 30119                                  
 30120 00004F90 5E                              POP     SI
 30121 00004F91 1F                              POP     DS
 30122 00004F92 5B                              POP     BX                      ; Clean stack
 30123 00004F93 07                              POP     ES
 30124 00004F94 59                              POP     CX
 30125 00004F95 E9CF00                          JMP	CNTCHAND ; 10/08/2018
 30126                                  
 30127                                  	; 05/05/2019
 30128                                  NOSTOP:
 30129                                  	; MSDOS 6.0
 30130 00004F98 3C10                    	CMP	AL,"P"-"@"
 30131 00004F9A 7509                    	JNZ	short check_next
 30132                                  				    	; SS override
 30133 00004F9C 36803E[900D]00          	CMP	BYTE [SS:SCAN_FLAG],0	; ALT_Q ?
 30134 00004FA2 7405                    	JZ	short INCHKJ		; no
 30135                                  check_end:	; 24/09/2023
 30136 00004FA4 C3                      	retn
 30137                                  check_next:
 30138                                  	;IF	NOT TOGLPRN
 30139                                  	;CMP	AL,"N"-"@"
 30140                                  	;JZ	short INCHKJ
 30141                                  	;ENDIF
 30142                                  
 30143 00004FA5 3C03                    	CMP	AL,"C"-"@"
 30144                                  	; 24/09/2023
 30145                                  	;JZ	short INCHKJ
 30146                                  ;check_end:
 30147                                  	;retn
 30148 00004FA7 75FB                    	jnz	short check_end
 30149                                  
 30150                                  	; 24/09/2023
 30151                                  	; 08/09/2018
 30152                                  INCHKJ:	; 10/08/2018
 30153 00004FA9 E9A500                  	jmp	INCHK
 30154                                  
 30155                                  	; MSDOS 3.3
 30156                                          ;CMP	AL,"P"-"@"  ; cmp al,16
 30157                                          ;JZ	short INCHKJ
 30158                                  
 30159                                  	; 15/04/2018
 30160                                          ;;IF	NOT TOGLPRN
 30161                                          ;CMP	AL,"N"-"@"
 30162                                          ;JZ	SHORT INCHKJ
 30163                                          ;;ENDIF
 30164                                  	
 30165                                  	;CMP	AL,"C"-"@"  ; cmp al,3
 30166                                          ;JZ	short INCHKJ
 30167                                  	;RETN
 30168                                  
 30169                                  ;	; 08/09/2018
 30170                                  ;INCHKJ:; 10/08/2018
 30171                                  ;	JMP	INCHK
 30172                                  
 30173                                  ;----------------------------------------------------------------------------
 30174                                  ;
 30175                                  ; Procedure Name : SpoolInt
 30176                                  ;
 30177                                  ; SpoolInt - signal processes that the DOS is truly idle. We are allowed to
 30178                                  ; do this ONLY if we are working on a 1-12 system call AND if we are not in
 30179                                  ; the middle of an INT 24.
 30180                                  ;
 30181                                  ;----------------------------------------------------------------------------
 30182                                  
 30183                                  SPOOLINT:
 30184 00004FAC 9C                      	PUSHF
 30185                                  	; 15/03/2018
 30186 00004FAD 36803E[5803]00          	CMP	BYTE [SS:IDLEINT],0	; SS override
 30187 00004FB3 7423                    	JZ	SHORT POPFRET
 30188 00004FB5 36803E[2003]00          	CMP	BYTE [SS:ERRORMODE],0
 30189 00004FBB 751B                    	JNZ	SHORT POPFRET		; No spool ints in error mode
 30190                                  
 30191                                  	; 30/07/2018
 30192                                  
 30193                                  	; Note that we are going to allow an external program to issue system 
 30194                                  	; calls at this time. We MUST preserve IdleInt across this.
 30195                                  
 30196 00004FBD 36FF36[5803]            	PUSH	WORD [SS:IDLEINT]
 30197                                  
 30198                                  	; 05/05/2019 - Retro DOS v4.0
 30199                                   
 30200                                  	; MSDOS 6.0
 30201 00004FC2 36803E[1112]00          	cmp	byte [SS:DosHasHMA],0	; Q: is dos running in HMA (M021)
 30202 00004FC8 7504                    	jne	short do_low_int28	; Y: the int must be done from low mem
 30203 00004FCA CD28                    	INT	int_spooler  ; int 28h	; N: Execute user int 28 handler
 30204 00004FCC EB05                    	jmp	short spool_ret_addr
 30205                                  
 30206                                  do_low_int28:
 30207                                  	;call	far [ss:LowInt28Addr]
 30208 00004FCE 2EFF1E[274F]            	call	far [cs:LowInt28Addr]	; 05/05/2019
 30209                                  
 30210                                  spool_ret_addr:
 30211                                  	;INT	int_spooler		; INT 28h
 30212                                  
 30213 00004FD3 368F06[5803]            	POP	WORD [SS:IDLEINT]
 30214                                  POPFRET:
 30215 00004FD8 9D                      	POPF
 30216                                  _RET18:  
 30217 00004FD9 C3                      	RETN
 30218                                  
 30219                                  ; 05/05/2019 - Retro DOS v4.0
 30220                                  ; DOSCODE:9137h (MSDOS 6.21, MSDOS.SYS)
 30221                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30222                                  ; DOSCODE:90DBh (MSDOS 5.0, MSDOS.SYS)
 30223                                  
 30224                                  ;----------------------------------------------------------------------------
 30225                                  ;
 30226                                  ; Procedure Name : STATCHK
 30227                                  ;
 30228                                  ;----------------------------------------------------------------------------
 30229                                  
 30230                                  STATCHK:
 30231 00004FDA E84EFF                          CALL	DSKSTATCHK              ; Allows ^C to be detected under
 30232                                                                          ; input redirection
 30233 00004FDD 53                              PUSH    BX
 30234 00004FDE 31DB                            XOR     BX,BX
 30235 00004FE0 E85FE5                          CALL	GET_IO_SFT
 30236 00004FE3 5B                              POP     BX
 30237 00004FE4 72F3                            JC      SHORT _RET18
 30238                                  
 30239 00004FE6 B401                            MOV     AH,1
 30240 00004FE8 E851F3                          CALL	IOFUNC
 30241 00004FEB 74BF                            JZ      SHORT SPOOLINT
 30242 00004FED 3C13                            CMP     AL,'S'-'@'
 30243 00004FEF 75A7                            JNZ     SHORT NOSTOP
 30244                                  
 30245                                  	; 05/05/2019
 30246                                  	; MSDOS 6.0			; SS override
 30247 00004FF1 36803E[900D]00          	CMP	BYTE [SS:SCAN_FLAG],0	; AN000; ALT_R ?
 30248 00004FF7 75AB                    	JNZ	short check_end		; AN000; yes
 30249                                  
 30250 00004FF9 30E4                            XOR     AH,AH
 30251 00004FFB E83EF3                          CALL	IOFUNC                  ; Eat Cntrl-S
 30252 00004FFE EB4A                            JMP     SHORT PAUSOSTRT
 30253                                  PRINTOFF:
 30254                                  PRINTON:
 30255 00005000 36F616[FE02]            	NOT	BYTE [SS:PFLAG] ; 14/03/2018
 30256                                  
 30257                                  	; 30/07/2018 - Retro DOS v3.0
 30258 00005005 53                      	PUSH	BX
 30259 00005006 BB0400                  	MOV	BX,4
 30260 00005009 E836E5                  	call	GET_IO_SFT
 30261 0000500C 5B                      	POP	BX
 30262 0000500D 72CA                    	jc	short _RET18
 30263 0000500F 06                      	PUSH	ES
 30264 00005010 57                      	PUSH	DI
 30265 00005011 1E                      	PUSH	DS
 30266 00005012 07                      	POP	ES
 30267 00005013 89F7                    	MOV	DI,SI			; ES:DI -> SFT
 30268                                  	;test	word [es:di+5],800h
 30269                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_net_spool
 30270                                  	; 05/05/2019
 30271 00005015 26F6450608              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8)
 30272 0000501A 7418                    	JZ	short NORM_PR 		; Not redirected, echo is OK
 30273                                  
 30274                                  	;Callinstall NetSpoolEchoCheck,MultNet,38,<AX>,<AX> 
 30275                                  					; See if allowed
 30276 0000501C 50                      	push	ax
 30277 0000501D B82611                  	mov	ax,1126h
 30278 00005020 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 30279                                  			; Return: CF set on error, AX = error code
 30280                                  			; STACK unchanged
 30281 00005022 58                      	pop	ax
 30282                                  
 30283 00005023 730F                    	JNC	short NORM_PR 		; Echo is OK
 30284                                  
 30285                                  					; SS override
 30286 00005025 36C606[FE02]00          	MOV	BYTE [SS:PFLAG],0	; If not allowed, disable echo
 30287                                  
 30288                                  	;Callinstall NetSpoolClose,MultNet,36,<AX>,<AX> ; and close
 30289                                  
 30290 0000502B 50                      	push    ax
 30291 0000502C B82411                  	mov     ax,1124h
 30292 0000502F CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 30293                                  			; ES:DI -> SFT, SS = DOS CS
 30294 00005031 58                      	pop     ax
 30295                                  
 30296 00005032 EB10                    	JMP	SHORT RETP6
 30297                                  NORM_PR:
 30298 00005034 36803E[FE02]00          	CMP	BYTE [SS:PFLAG],0	; SS override
 30299 0000503A 7505                    	JNZ	short PRNOPN
 30300 0000503C E851F4                  	call	DEV_CLOSE_SFT
 30301 0000503F EB03                    	JMP	SHORT RETP6
 30302                                  PRNOPN:
 30303 00005041 E844F4                  	call	DEV_OPEN_SFT
 30304                                  RETP6:
 30305 00005044 5F                      	POP	DI
 30306 00005045 07                      	POP	ES
 30307                                  STATCHK_RETN:
 30308 00005046 C3                              RETN
 30309                                  PAUSOLP:
 30310 00005047 E862FF                          CALL    SPOOLINT
 30311                                  PAUSOSTRT:
 30312 0000504A B401                            MOV     AH,1
 30313 0000504C E8EDF2                          CALL	IOFUNC
 30314 0000504F 74F6                            JZ      SHORT PAUSOLP
 30315                                  INCHK:
 30316 00005051 53                              PUSH    BX
 30317 00005052 31DB                            XOR     BX,BX
 30318 00005054 E8EBE4                          CALL	GET_IO_SFT
 30319 00005057 5B                              POP     BX
 30320 00005058 72EC                            JC      SHORT STATCHK_RETN ; 30/07/2018
 30321 0000505A 30E4                            XOR     AH,AH
 30322 0000505C E8DDF2                          CALL	IOFUNC
 30323                                  	; 30/07/2018
 30324                                  	; MSDOS 3.3
 30325                                          ;CMP	AL,'P'-'@' ;cmp al,16
 30326                                          ;JNZ	SHORT NOPRINT
 30327                                  
 30328                                  	;cmp	byte [SS:SCAN_FLAG],0
 30329                                  	;JZ	SHORT PRINTON	
 30330                                  	;mov	byte [ss:SCAN_FLAG],0
 30331                                  
 30332                                  	; 05/05/2019
 30333                                  	; MSDOS 6.0
 30334 0000505F 3C10                    	CMP	AL,"P"-"@"
 30335                                  	;;;;  7/14/86	ALT_Q key fix
 30336 00005061 749D                    	JZ	short PRINTON		; no! must be CTRL_P
 30337                                  ;NOPRINT:	
 30338                                  	;IF	NOT TOGLPRN
 30339                                  	;CMP	AL,"N"-"@"
 30340                                  	;JZ	short PRINTOFF
 30341                                  	;ENDIF
 30342 00005063 3C03                    	CMP	AL,"C"-"@" ; cmp al,3 
 30343                                  	;retnz
 30344 00005065 75DF                    	jnz	short STATCHK_RETN
 30345                                  
 30346                                  	; !! NOTE: FALL THROUGH !!
 30347                                  
 30348                                  ;---------------------------------------------------------------------------
 30349                                  ;
 30350                                  ; Procedure Name : CNTHAND ( CTRLC_C HANDLER )
 30351                                  ;
 30352                                  ; "^C" and CR/LF is printed. Then the user registers are restored and the
 30353                                  ; user CTRL-C handler is executed. At this point the top of the stack has 1)
 30354                                  ; the interrupt return address should the user CTRL-C handler wish to allow
 30355                                  ; processing to continue; 2) the original interrupt return address to the code
 30356                                  ; that performed the function call in the first place. If the user CTRL-C
 30357                                  ; handler wishes to continue, it must leave all registers unchanged and RET
 30358                                  ; (not IRET) with carry CLEAR. If carry is SET then an terminate system call
 30359                                  ; is simulated.
 30360                                  ;
 30361                                  ;---------------------------------------------------------------------------
 30362                                  
 30363                                  CNTCHAND:
 30364                                  	; MSDOS 6.0			; SS override
 30365                                  					; AN002; from RAWOUT
 30366                                  	;TEST	word [SS:DOS34_FLAG],CTRL_BREAK_FLAG  
 30367                                  	;JNZ	short around_deadlock 	; AN002;
 30368                                  
 30369                                  	; 05/05/2019 - Retro DOS v4.0
 30370                                  	; (MSDOS 6.21 MSDOS.SYS DOSCODE:91C4h, 29/12/2022)
 30371 00005067 36F606[1206]02          	TEST	byte [SS:DOS34_FLAG+1],(CTRL_BREAK_FLAG>>8)  ; 2 
 30372 0000506D 7508                    	JNZ	short around_deadlock 	; AN002;
 30373                                  
 30374 0000506F B003                            MOV     AL,3			; Display "^C"
 30375 00005071 E855C6                          CALL	BUFOUT
 30376 00005074 E8F0C4                          CALL	CRLF
 30377                                  around_deadlock:
 30378 00005077 16                              PUSH    SS
 30379 00005078 1F                              POP     DS
 30380 00005079 803E[5703]00                    CMP     BYTE [CONSWAP],0
 30381 0000507E 7403                            JZ      SHORT NOSWAP
 30382 00005080 E853E1                          CALL	SWAPBACK
 30383                                  NOSWAP:
 30384 00005083 FA                      	CLI				; Prepare to play with stack
 30385 00005084 8E16[8605]              	MOV	SS,[USER_SS]		; User stack now restored
 30386 00005088 8B26[8405]              	MOV	SP,[USER_SP]
 30387 0000508C E8BCB3                          CALL	restore_world       ; User registers now restored
 30388                                  
 30389                                  	; 30/07/2018 - Retro DOS v3.0 
 30390                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56ACh)
 30391                                          ; 14/03/2018 - Retro DOS v2.0
 30392                                  	;MOV	BYTE [CS:INDOS],0	
 30393                                          ;MOV	BYTE [CS:ERRORMODE],0
 30394                                          ;MOV	[CS:ConC_Spsave],SP
 30395                                  	;clc	;30/07/2018
 30396                                          ;INT	int_ctrl_c ; 23h    ; Execute user Ctrl-C handler
 30397                                  	;;int	23h	; DOS - CONTROL "C" EXIT ADDRESS
 30398                                  			; Return: return via RETF 2 with CF set
 30399                                  			; DOS will abort program with errorlevel 0
 30400                                  			; else
 30401                                  			; interrupted DOS call continues
 30402                                  
 30403                                  	; 05/05/2019 - Retro DOS v4.0
 30404                                  	; MSDOS 6.0 (MSDOS 6.21, MSDOS.SYS,91ECh) 
 30405                                  
 30406                                  	; CS was used to address these variables. We have to use DOSDATA
 30407                                  	
 30408 0000508F 07                      	pop	es ; *	; MSDOS 6.21 (MSDOS.SYS, DOSCODE:91ECh)
 30409                                  			; (pop es, after 'call restore_world')	
 30410 00005090 1E                      	push	ds
 30411                                  	;getdseg <ds>			; ds -> dosdata
 30412 00005091 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 30413 00005096 C606[2103]00            	mov	byte [INDOS],0		; Go to known state
 30414 0000509B C606[2003]00            	mov	byte [ERRORMODE],0
 30415 000050A0 8926[3203]              	mov	[ConC_Spsave],SP	; save his SP
 30416                                  	; User SP has changed because of push. Adjust for it
 30417 000050A4 8306[3203]02            	add	word [ConC_Spsave],2
 30418                                  
 30419 000050A9 803E[1112]00            	cmp	byte [DosHasHMA],0	; Q: is dos running in HMA (M021)
 30420 000050AE 1F                       	pop	ds	; restore ds
 30421 000050AF 7505                    	jne	short do_low_int23	; Y: the int must be done from low mem
 30422 000050B1 F8                      	CLC				
 30423 000050B2 CD23                    	INT	int_ctrl_c  ; int 23h	; N: Execute user Ctrl-C handler
 30424 000050B4 EB06                    	jmp	short ctrlc_ret_addr
 30425                                  
 30426                                  	; 05/05/2019
 30427                                  do_low_int23:
 30428 000050B6 F8                      	clc
 30429 000050B7 2EFF1E[1F4F]            	call	far [cs:LowInt23Addr]	
 30430                                  
 30431                                  	; 30/07/2018 
 30432                                  
 30433                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56C0h)
 30434                                  
 30435                                  ; The user has returned to us. The circumstances we allow are:
 30436                                  ;
 30437                                  ;   IRET	We retry the operation by redispatching the system call
 30438                                  ;   CLC/RETF	POP the stack and retry
 30439                                  ;   ... 	Exit the current process with ^C exit
 30440                                  ;
 30441                                  ; User's may RETURN to us and leave interrupts on. 
 30442                                  ; Turn 'em off just to be sure
 30443                                  
 30444                                  ctrlc_ret_addr: ; 05/05/2019
 30445                                  
 30446 000050BC FA                      	CLI
 30447                                  
 30448                                  	; MSDOS 3.3 
 30449                                  	;MOV	[CS:USER_IN_AX],ax	; save the AX
 30450                                  	;PUSHF				; and the flags (maybe new call)
 30451                                  	;POP	AX
 30452                                  
 30453                                  	; 05/05/2019
 30454                                  	; MSDOS 6.0
 30455                                  
 30456                                  	; We have to use DOSDATA for these variables. Previously CS was used 
 30457                                  
 30458 000050BD 50                      	push	ax
 30459 000050BE 8CD8                    	mov	ax,ds
 30460                                  	;getdseg <ds>			; ds -> dosdata
 30461 000050C0 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 30462 000050C5 A3[0A0D]                	mov	[TEMPSEG],ax
 30463 000050C8 58                      	pop	ax
 30464 000050C9 A3[3A03]                	MOV	[USER_IN_AX],ax		; save the AX
 30465 000050CC 9C                      	pushf				; and the flags (maybe new call)
 30466 000050CD 58                      	pop	ax
 30467                                  
 30468                                  ; See if the input stack is identical to the output stack
 30469                                  
 30470                                  	; MSDOS 3.3
 30471                                  	;CMP	SP,[CS:ConC_Spsave]
 30472                                  	;JNZ	SHORT ctrlc_try_new	; current SP not the same as saved SP
 30473                                  
 30474                                  	; MSDOS 6.0
 30475 000050CE 3B26[3203]              	CMP	SP,[ConC_Spsave]
 30476 000050D2 750A                    	JNZ	SHORT ctrlc_try_new	; current SP not the same as saved SP
 30477                                  
 30478                                  ; Repeat the operation by redispatching the system call.
 30479                                  
 30480                                  ctrlc_repeat:
 30481                                  	; MSDOS 3.3
 30482                                  	;MOV	AX,[CS:USER_IN_AX]
 30483                                  	; 05/05/2019
 30484                                  	; MSDOS 6.0
 30485 000050D4 A1[3A03]                	mov	ax,[USER_IN_AX]
 30486 000050D7 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore ds and original sp
 30487                                  	; MSDOS 3.3 & MSDOS 6.0 
 30488                                  	;transfer COMMAND
 30489                                  COMMANDJ:
 30490 000050DB E92AB2                  	JMP	COMMAND
 30491                                  
 30492                                  ; The current SP is NOT the same as the input SP. Presume that he 
 30493                                  ; RETF'd leaving some flags on the stack and examine the input
 30494                                  
 30495                                  ctrlc_try_new:
 30496                                  	; 29/02/2024
 30497                                  	;ADD	SP,2			; pop those flags
 30498                                  	;
 30499                                  	;;test	ax,1
 30500                                  	;TEST	AX,f_Carry		; did he return with carry?
 30501 000050DE A801                    	test	al,f_Carry ; test al,1
 30502                                  	;
 30503                                  	; 29/02/2024
 30504 000050E0 58                      	pop	ax  ; (PCDOS 7.1 IBMDOS.COM)
 30505                                  	;
 30506 000050E1 74F1                    	JZ	short ctrlc_repeat	; no carry set, just retry
 30507                                  
 30508                                  	; MSDOS 6.0
 30509 000050E3 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore ds
 30510                                  
 30511                                  	; Well...  time to abort the user.  
 30512                                  	; Signal a ^C exit and use the EXIT system call..
 30513                                  
 30514                                  ctrlc_abort:
 30515                                  	; MSDOS 3.3
 30516                                          ;;MOV	AX,(EXIT SHL 8) + 0
 30517                                          ;MOV	AX,(EXIT*256) + 0 ; 4C00h
 30518                                  	;mov	byte [CS:DidCTRLC],0FFh ; 14/03/2018
 30519                                          ;transfer COMMAND	    ; give up by faking $EXIT
 30520                                  	;;JMP	SHORT COMMANDJ
 30521                                  	;JMP	COMMAND
 30522                                  
 30523                                  	; 05/05/2019 - Retro DOS v4.0
 30524                                  	; MSDOS 6.0
 30525 000050E7 B8004C                  	MOV	AX,(EXIT<<8)+0  ; 4C00h
 30526 000050EA 1E                      	push	ds
 30527                                  	;getdseg <ds>			; ds -> dosdata
 30528 000050EB 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]	
 30529 000050F0 C606[4D03]FF            	MOV	byte [DidCTRLC],-1 ; 0FFh
 30530 000050F5 1F                      	pop	ds
 30531                                  	;transfer COMMAND		; give up by faking $EXIT
 30532 000050F6 EBE3                    	JMP	SHORT COMMANDJ
 30533                                  	;JMP	COMMAND
 30534                                  
 30535                                  ;Break	<DIVISION OVERFLOW INTERRUPT>
 30536                                  ;----------------------------------------------------------------------------
 30537                                  ;
 30538                                  ; Procedure Name : DIVOV
 30539                                  ;
 30540                                  ; Default handler for division overflow trap
 30541                                  ;
 30542                                  ;----------------------------------------------------------------------------
 30543                                  
 30544                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30545                                  DIVOV: 
 30546                                  	; 05/05/2019 - Retro DOS v4.0
 30547                                  	; 30/07/2018
 30548                                  	; 07/07/2018 - Retro DOS v3.0
 30549 000050F8 BE[9709]                	mov	si,DIVMES
 30550 000050FB 2E8B1E[AA09]            	mov	bx,[cs:DivMesLen]
 30551                                  	;mov	ax,cs
 30552                                  	;mov	ss,ax
 30553                                  	; 05/05/2019
 30554                                  	;getdseg <ss>		; we are in an ISR, flag is CLI
 30555 00005100 2E8E16[0700]            	mov	ss,[cs:DosDSeg]
 30556 00005105 BC[A007]                	mov     sp,AUXSTACK
 30557                                  	;call	RealDivOv ; MSDOS 3.3
 30558 00005108 E80200                  	call	_OUTMES ; MSDOS 6.0
 30559 0000510B EBDA                    	jmp	short ctrlc_abort  ; Use Ctrl-C abort on divide overflow
 30560                                  
 30561                                  ; 30/07/2018
 30562                                  
 30563                                  ; MSDOS 6.0
 30564                                  ;---------------------------------------------------------------------------
 30565                                  ;
 30566                                  ; Procedure Name : OutMes
 30567                                  ;
 30568                                  ;
 30569                                  ; OutMes: perform message output
 30570                                  ; Inputs:   SS:SI points to message
 30571                                  ;	    BX has message length
 30572                                  ; Outputs:  message to BCON
 30573                                  ;
 30574                                  ;Actually, cs:si points to the message now. The segment address is filled in
 30575                                  ;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
 30576                                  ;NB. This procedure is called only from DIVOV. -SR
 30577                                  ;
 30578                                  ;---------------------------------------------------------------------------
 30579                                  
 30580                                  ;MSDOS 3.3
 30581                                  ;---------------------------------------------------------------------------
 30582                                  ; RealDivOv: perform actual divide overflow stuff.
 30583                                  ; Inputs:   none
 30584                                  ; Outputs:  message to BCON
 30585                                  ;---------------------------------------------------------------------------
 30586                                  
 30587                                  	; 05/05/2019 - Retro DOS v4.0
 30588                                  	; DOSCODE:926Ch (MSDOS 6.21, MSDOS.SYS)
 30589                                  
 30590                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30591                                  	; DOSCODE:9210h (MSDOS 5.0, MSDOS.SYS)
 30592                                  
 30593                                  ;---------------------------------------------------------------------------
 30594                                  ;
 30595                                  ; Procedure Name : OutMes
 30596                                  ;
 30597                                  ; OutMes: perform message output
 30598                                  ; Inputs:   SS:SI points to message
 30599                                  ;	    BX has message length
 30600                                  ; Outputs:  message to BCON
 30601                                  ;
 30602                                  ;Actually, cs:si points to the message now. The segment address is filled in
 30603                                  ;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
 30604                                  ;NB. This procedure is called only from DIVOV. -SR
 30605                                  ;
 30606                                  ;---------------------------------------------------------------------------
 30607                                  
 30608                                  	; 30/07/2018
 30609                                  	; MSDOS 6.0
 30610                                  _OUTMES:
 30611                                  	; MSDOS 3.3
 30612                                  ;RealDivOv:
 30613                                  	; 07/07/2018 - Retro DOS v3.0
 30614                                          ;Context ES
 30615 0000510D 16                      	push	ss ; 05/05/2019
 30616                                  	;PUSH	CS ; 30/07/2018		; get ES addressability
 30617 0000510E 07                      	POP	ES
 30618                                          ;Context DS
 30619 0000510F 16                      	push	ss ; 05/05/2019	
 30620                                  	;PUSH	CS ; 30/07/2018		; get DS addressability
 30621 00005110 1F                      	POP	DS
 30622 00005111 C606[9403]08                    MOV     BYTE [DSKSTCOM],DEVWRT
 30623 00005116 C606[9203]16                    MOV     BYTE [DSKSTCALL],DRDWRHL
 30624 0000511B C706[9503]0000                  MOV     WORD [DSKSTST],0
 30625                                  	; BX = [DivMesLen] = 19
 30626 00005121 891E[A403]                      MOV     [DSKSTCNT],BX
 30627 00005125 BB[9203]                        MOV     BX,DSKSTCALL
 30628 00005128 8936[A003]                      MOV     [DSKCHRET+1],SI		; transfer address (need an EQU)
 30629                                  	; 08/09/2018
 30630                                  	;mov	[DEVIOBUF_PTR],si
 30631                                  	; MSDOS 6.0
 30632                                  					; CS is used for string, fill in 
 30633                                  					; segment address 
 30634                                  	;mov	[DOSSEG_INIT],cs ; 29/02/2024
 30635 0000512C 8C0E[A203]              	MOV	[DSKCHRET+3],CS
 30636                                  
 30637 00005130 C536[3200]                      LDS     SI,[BCON]
 30638 00005134 E8D2F3                          CALL	DEVIOCALL2
 30639                                  
 30640                                  	;; 14/03/2018
 30641                                          ;;MOV	WORD [CS:DSKCHRET+1],DEVIOBUF
 30642                                  	;; 08/09/2018
 30643                                  	;mov	word [CS:DEVIOBUF_PTR],DEVIOBUF
 30644                                          ;MOV	WORD [CS:DSKSTCNT],1
 30645                                          
 30646                                  	; 05/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 30647                                  
 30648                                  	; ES still points to DOSDATA. ES is
 30649                                  					; not destroyed by deviocall2. So use
 30650                                  					; ES override.
 30651                                  
 30652 00005137 26C706[A003][BC03]      	MOV	WORD [ES:DSKCHRET+1],DEVIOBUF
 30653 0000513E 26C706[A403]0100        	MOV	WORD [ES:DSKSTCNT],1
 30654                                  
 30655 00005145 C3                      	RETN
 30656                                  
 30657                                  ;Break	<CHARHRD,HARDERR,ERROR -- HANDLE DISK ERRORS AND RETURN TO USER>
 30658                                  ;---------------------------------------------------------------------------
 30659                                  ;
 30660                                  ; Procedure Name : CHARHARD
 30661                                  ;
 30662                                  ;
 30663                                  ; Character device error handler
 30664                                  ; Same function as HARDERR
 30665                                  ;
 30666                                  ;---------------------------------------------------------------------------
 30667                                  
 30668                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30669                                  CHARHARD:
 30670                                  	; 05/05/2019 - Retro DOS v4.0
 30671                                  	; 30/07/2018
 30672                                  	; 08/07/2018 - Retro DOS v3.0
 30673                                  
 30674                                  	; MSDOS 6.0
 30675                                  		   			; M024 - start
 30676 00005146 36803E[2003]00          	cmp	byte [SS:ERRORMODE], 0	; Q: are we in the middle of int 24
 30677                                  	;jne	short @f		; Y: allow fail
 30678 0000514C 750B                    	jne	short chard1
 30679                                  
 30680 0000514E 80CC10                  	OR	AH,Allowed_RETRY ; 10h	; assume ctrl p
 30681                                  
 30682 00005151 36F606[FE02]FF          	test	byte [ss:PFLAG],-1	; Q: has ctrl p been pressed
 30683 00005157 7503                    	jnz	short ctrlp		; Y: 
 30684                                  ;@@:
 30685                                  chard1:					; M024 - end
 30686                                  	; MSDOS 6.0 & MSDOS 3.3
 30687                                  
 30688                                  ; Character device error handler
 30689                                  ; Same function as HARDERR
 30690                                  
 30691                                  	;or	ah,38h
 30692 00005159 80CC38                  	or	ah,Allowed_IGNORE+Allowed_RETRY+Allowed_FAIL
 30693                                  ctrlp:			; SS override for Allowed and EXITHOLD
 30694 0000515C 368826[4B03]            	mov	[SS:ALLOWED],ah
 30695                                  
 30696                                  	; 15/03/2018
 30697 00005161 368C06[8205]                    MOV     [SS:EXITHOLD+2],ES
 30698 00005166 36892E[8005]                    MOV     [SS:EXITHOLD],BP
 30699 0000516B 56                              PUSH    SI
 30700                                  	;and	di,0FFh
 30701 0000516C 81E7FF00                        AND     DI,STECODE
 30702 00005170 8CDD                            MOV     BP,DS                   ;Device pointer is BP:SI
 30703 00005172 E86400                          CALL    FATALC
 30704 00005175 5E                              POP     SI
 30705                                  	;return
 30706 00005176 C3                              RETN
 30707                                  
 30708                                  ;---------------------------------------------------------------------------
 30709                                  ;
 30710                                  ; Procedure Name : HardErr
 30711                                  ;
 30712                                  ; Hard disk error handler. Entry conditions:
 30713                                  ;	DS:BX = Original disk transfer address
 30714                                  ;	DX = Original logical sector number
 30715                                  ;	CX = Number of sectors to go (first one gave the error)
 30716                                  ;	AX = Hardware error code
 30717                                  ;	DI = Original sector transfer count	
 30718                                  ;	ES:BP = Base of drive parameters
 30719                                  ;	[READOP] = 0 for read, 1 for write
 30720                                  ;	Allowed Set with allowed responses to this error (other bits MUST BE 0)
 30721                                  ; Output:
 30722                                  ;	[FAILERR] will be set if user responded FAIL
 30723                                  ;
 30724                                  ;--------------------------------------------------------------------------
 30725                                  
 30726                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30727                                  HARDERR:
 30728                                  	; 05/05/2019 - Retro DOS v4.0
 30729                                  	; 30/07/2018
 30730                                  	; 08/07/2018 - Retro DOS v3.0
 30731 00005177 97                      	XCHG    AX,DI			; Error code in DI, count in AX
 30732                                  	;and	di,0FFh
 30733 00005178 81E7FF00                	AND	DI,STECODE		; And off status bits
 30734                                  	;CMP	DI,WRECODE		; Write Protect Error?
 30735                                  	;cmp	di,0
 30736 0000517C 83FF00                  	cmp	DI,error_I24_write_protect ; Write Protect Error?
 30737 0000517F 750A                    	JNZ	short NOSETWRPERR
 30738 00005181 50                      	PUSH    AX
 30739                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30740                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 30741                                  	;;MOV	AL,[ES:BP+0]
 30742                                  	; 15/12/2022
 30743 00005182 268A4600                	mov	al,[ES:BP]
 30744                                  		; 15/03/2018
 30745 00005186 36A2[2203]              	MOV	[SS:WPERR],AL		; Flag drive with WP error
 30746 0000518A 58                      	POP	AX
 30747                                  NOSETWRPERR:
 30748 0000518B 29C8                    	SUB	AX,CX		  ; Number of sectors successfully transferred
 30749 0000518D 01C2                    	ADD	DX,AX		  ; First sector number to retry
 30750 0000518F 52                      	PUSH    DX
 30751                                  	; 08/07/2018
 30752                                  	;MUL	word [ES:BP+2] 		; Number of bytes transferred
 30753 00005190 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]
 30754 00005194 5A                      	POP	DX
 30755 00005195 01C3                    	ADD	BX,AX			; First address for retry
 30756 00005197 30E4                    	XOR	AH,AH			; Flag disk section in error
 30757                                  	;CMP	DX,[ES:BP+6] 		; In reserved area?
 30758 00005199 263B5606                	CMP	DX,[ES:BP+DPB.FIRST_FAT]
 30759 0000519D 721A                    	JB	SHORT ERRINT
 30760 0000519F FEC4                    	INC	AH			; Flag for FAT
 30761                                  	;CMP	DX,[ES:BP+10H] ; MSDOS 3.3
 30762                                  	;cmp	dx,[ES:BP+11h] ; MSDOS 6.0 - 05/05/2019
 30763 000051A1 263B5611                	CMP	DX,[ES:BP+DPB.DIR_SECTOR]  ; In FAT?  
 30764 000051A5 7308                    	JAE	short TESTDIR		; No
 30765                                  		; Err in FAT must force recomp of freespace
 30766                                  	;mov	word [ES:BP+1Eh],-1 ; MSDOS 3.3
 30767                                  	;mov	word [ES:BP+1Fh],-1 ; MSDOS 6.0 - 05/05/2019 
 30768 000051A7 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1
 30769 000051AD EB0A                    	JMP	SHORT ERRINT
 30770                                  TESTDIR:
 30771 000051AF FEC4                    	INC	AH
 30772                                  	;CMP	DX,[ES:BP+0BH]		; In directory?
 30773 000051B1 263B560B                	CMP	DX,[ES:BP+DPB.FIRST_SECTOR]
 30774 000051B5 7202                    	JB	SHORT ERRINT
 30775 000051B7 FEC4                    	INC	AH			; Must be in data area
 30776                                  ERRINT:
 30777 000051B9 D0E4                    	SHL	AH,1			; Make room for read/write bit
 30778 000051BB 360A26[7505]            	OR	AH,[SS:READOP] ; 15/03/2018
 30779                                  
 30780                                  	; 15/08/2018
 30781                                  					; SS override for allowed and EXITHOLD
 30782 000051C0 360A26[4B03]            	OR	AH,[SS:ALLOWED]		; Set the allowed_ bits
 30783                                  
 30784                                  	;entry   FATAL
 30785                                  FATAL:
 30786                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30787                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 30788                                  	;;MOV	AL,[ES:BP+0]		; Get drive number
 30789                                  	; 15/12/2022
 30790 000051C5 268A4600                	MOV	AL,[ES:BP]
 30791                                  
 30792                                  	;entry   FATAL1
 30793                                  FATAL1:  
 30794                                  	; 15/03/2018	
 30795 000051C9 368C06[8205]            	MOV	[SS:EXITHOLD+2],ES
 30796 000051CE 36892E[8005]            	MOV	[SS:EXITHOLD],BP	; The only things we preserve
 30797                                  	;LES	SI,[ES:BP+12H] ; MSDOS 3.3
 30798                                  	;LES	SI,[ES:BP+13H] ; MSDOS 6.0 - 05/05/2019
 30799 000051D3 26C47613                	LES	SI,[ES:BP+DPB.DRIVER_ADDR]
 30800 000051D7 8CC5                    	MOV	BP,ES		  ; BP:SI points to the device involved
 30801                                  
 30802                                  	; DI has the INT-24-style extended error. We now map the error code
 30803                                  	; for this into the normalized get extended error set by using the
 30804                                  	; ErrMap24 table as a translate table. Note that we translate ONLY
 30805                                  	; the device returned codes and leave all others beyond the look up
 30806                                  	; table alone.
 30807                                  
 30808                                  	; 08/07/2018 - Retro DOS v3.0
 30809                                  FATALC:
 30810 000051D9 E89301                  	call	SET_I24_EXTENDED_ERROR
 30811                                  	;cmp	di,0Ch
 30812 000051DC 83FF0C                  	CMP	DI,error_I24_gen_failure
 30813 000051DF 7603                    	JBE	short GOT_RIGHT_CODE	; Error codes above gen_failure get
 30814 000051E1 BF0C00                  	MOV	DI,error_I24_gen_failure; mapped to gen_failure. Real codes
 30815                                  					;  Only come via GetExtendedError
 30816                                  ;** ----------------------------------------------------------------
 30817                                  ;
 30818                                  ; Entry point used by REDIRector on Network I 24 errors.
 30819                                  ;
 30820                                  ;	ASSUME	DS:NOTHING,ES:NOTHING,SS:DOSDATA
 30821                                  ;
 30822                                  ; ALL I 24 regs set up. ALL Extended error info SET. ALLOWED Set.
 30823                                  ;	EXITHOLD set for restore of ES:BP.
 30824                                  ; ------------------------------------------------------------------
 30825                                  	;entry	NET_I24_ENTRY
 30826                                  NET_I24_ENTRY:
 30827                                  GOT_RIGHT_CODE:
 30828 000051E4 36803E[2003]00          	CMP	BYTE [SS:ERRORMODE],0	; No INT 24s if already INT 24
 30829 000051EA 7404                    	JZ	SHORT NoSetFail
 30830 000051EC B003                    	MOV	AL,3
 30831 000051EE EB6A                    	JMP	short FailRet
 30832                                  NoSetFail:
 30833 000051F0 368926[8805]            	MOV	[SS:CONTSTK],SP		; SS override
 30834 000051F5 16                      	PUSH	SS
 30835 000051F6 07                      	POP	ES
 30836                                      
 30837                                  	; Wango!!! We may need to free some user state info... In 
 30838                                  	; particular, we may have locked down a JFN for a user and he may
 30839                                  	; NEVER return to us. Thus,we need to free it here and then
 30840                                  	; reallocate it when we come back.
 30841                                  
 30842 000051F7 36833E[AA05]FF          	CMP	word [SS:SFN],-1 ; 0FFFFh
 30843 000051FD 740C                    	JZ	short _NoFree
 30844 000051FF 1E                      	push	ds
 30845 00005200 56                      	push	si
 30846 00005201 36C536[AE05]            	LDS	SI,[SS:PJFN]
 30847 00005206 C604FF                  	MOV	BYTE [SI],0FFH
 30848 00005209 5E                      	pop	si
 30849 0000520A 1F                      	pop	ds
 30850                                  
 30851                                  _NoFree:
 30852 0000520B FA                      	CLI
 30853                                  					; Prepare to play with stack
 30854 0000520C 36FE06[2003]            	INC	BYTE [SS:ERRORMODE]	; Flag INT 24 in progress
 30855 00005211 36FE0E[2103]            	DEC	BYTE [SS:INDOS]		; INT 24 handler might not return
 30856                                  
 30857                                  	; 05/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 30858                                  
 30859                                  	;; Extended Open hooks
 30860                                  					; AN000;IFS.I24 error disabled
 30861                                  	;test	byte [ss:EXTOPEN_ON],2
 30862 00005216 36F606[F605]02          	TEST	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF
 30863 0000521C 7404                    	JZ	short i24yes		; AN000;IFS.no
 30864                                  faili24:				; AN000;
 30865 0000521E B003                    	MOV	AL,3			; AN000;IFS.fake fail
 30866 00005220 EB27                    	JMP	short passi24 		; AN000;IFS.exit
 30867                                  i24yes: 				; AN000;
 30868                                  	;; Extended Open hooks
 30869                                  
 30870 00005222 368E16[8605]            	MOV	SS,[SS:USER_SS]
 30871 00005227 268B26[8405]            	MOV	SP,[ES:USER_SP]	; User stack pointer restored
 30872                                  
 30873                                  	;;int	24h	
 30874                                  	;IN	int_fatal_abort		; Fatal error interrupt vector,
 30875                                  					; must preserve ES
 30876                                  	; 05/05/2019
 30877 0000522C 26803E[1112]00          	cmp	byte [es:DosHasHMA],0	; Q: is dos running in HMA (M021)
 30878 00005232 7504                    	jne	short do_low_int24	; Y: the int must be done from low mem
 30879 00005234 CD24                    	INT	int_fatal_abort 	; Fatal error interrupt vector, 
 30880                                  					; must preserve ES
 30881 00005236 EB05                    	jmp	short criterr_ret_addr
 30882                                  
 30883                                  do_low_int24:
 30884                                  	; 05/05/2019
 30885                                  	; MSDOS 6.0
 30886 00005238 2EFF1E[234F]            	call    far [cs:LowInt24Addr]
 30887                                  criterr_ret_addr:
 30888 0000523D 268926[8405]            	MOV	[ES:USER_SP],SP	; restore our stack
 30889 00005242 268C16[8605]            	MOV	[ES:USER_SS],SS
 30890                                  	;MOV	BP,ES
 30891                                  	;MOV	SS,BP
 30892                                  	; 30/06/2024
 30893 00005247 06                      	push	es
 30894 00005248 17                      	pop	ss
 30895                                  passi24:
 30896 00005249 368B26[8805]            	MOV	SP,[SS:CONTSTK]
 30897 0000524E 36FE06[2103]            	INC	BYTE [SS:INDOS]		; Back in the DOS
 30898 00005253 36C606[2003]00          	MOV	BYTE [SS:ERRORMODE],0	; Back from INT 24
 30899 00005259 FB                      	STI
 30900                                  FailRet:
 30901 0000525A 36C42E[8005]            	LES	BP,[SS:EXITHOLD]
 30902                                  	
 30903                                  	; 08/07/2018
 30904                                  
 30905                                  	; Triage the user's reply.
 30906                                  
 30907 0000525F 3C01                    	CMP	AL,1
 30908 00005261 723D                    	JB	short CheckIgnore	; 0 => ignore
 30909 00005263 7445                    	JZ	short CheckRetry	; 1 => retry
 30910 00005265 3C03                    	CMP	AL,3			; 3 => fail
 30911 00005267 7549                    	JNZ	short DoAbort 		; 2, invalid => abort
 30912                                  
 30913                                  	; The reply was fail. See if we are allowed to fail.
 30914                                  
 30915                                  					; SS override for ALLOWED, EXTOPEN_ON,
 30916                                  					; ALLOWED, FAILERR, WPERR, SFN, pJFN
 30917                                  	;test	byte [ss:ALLOWED],8
 30918 00005269 36F606[4B03]08          	test	byte [ss:ALLOWED],Allowed_FAIL ; Can we?
 30919 0000526F 7441                    	jz	short DoAbort		; No, do abort
 30920                                  DoFail:
 30921 00005271 B003                    	MOV	AL,3			; just in case...
 30922                                  					; AN000;EO. I24 error disabled
 30923                                  	; 05/05/2019
 30924                                  	;(MSDOS 6.0, MSCTRLC.ASM, 1991)
 30925 00005273 36F606[F605]02          	test	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF ; 2
 30926 00005279 7505                    	jnz	short CleanUp 		; AN000;EO. no
 30927                                  	
 30928 0000527B 36FE06[4A03]            	inc	byte [SS:FAILERR]	; Tell everybody
 30929                                  CleanUp:
 30930 00005280 36C606[2203]FF          	MOV	byte [SS:WPERR],-1
 30931 00005286 36833E[AA05]FF          	CMP	word [SS:SFN],-1
 30932                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30933                                  	;jnz	short CleanUp2
 30934                                  	;retn
 30935                                  	; 17/12/2022
 30936 0000528C 7411                    	jz	short Cleanup_retn ; 08/07/2018 - Retro DOS v3.0
 30937                                  CleanUp2:
 30938 0000528E 1E                      	push	ds
 30939 0000528F 56                      	push	si
 30940 00005290 50                      	push	ax
 30941 00005291 36A1[AA05]              	MOV	AX,[ss:SFN]
 30942 00005295 36C536[AE05]            	LDS	SI,[ss:PJFN]
 30943 0000529A 8804                    	MOV	[SI],AL
 30944 0000529C 58                      	pop	ax
 30945 0000529D 5E                      	pop	si
 30946 0000529E 1F                      	pop	ds
 30947                                  Cleanup_retn:
 30948 0000529F C3                      	retn
 30949                                  
 30950                                  	; The reply was IGNORE. See if we are allowed to ignore.
 30951                                  
 30952                                  CheckIgnore:
 30953                                  	;test	byte [ss:ALLOWED],20h
 30954 000052A0 36F606[4B03]20          	test	byte [ss:ALLOWED],Allowed_IGNORE ; Can we?
 30955                                  CheckRI:	; 29/02/2024
 30956 000052A6 74C9                    	jz	short DoFail			; No, do fail
 30957 000052A8 EBD6                    	jmp	short CleanUp
 30958                                  
 30959                                  	; The reply was RETRY. See if we are allowed to retry.
 30960                                  
 30961                                  CheckRetry:
 30962                                  	;test	byte [ss:ALLOWED],10h
 30963 000052AA 36F606[4B03]10          	test	byte [ss:ALLOWED],Allowed_RETRY	; Can we?
 30964                                  	;jz	short DoFail			; No, do fail
 30965                                  	;JMP	short CleanUp
 30966                                  	; 29/02/2024 (PCDOS 7.1 IBMDOS.COM)
 30967 000052B0 EBF4                    	jmp	short CheckRI
 30968                                  
 30969                                  	; The reply was ABORT.
 30970                                  DoAbort:
 30971 000052B2 16                      	push	ss
 30972 000052B3 1F                      	pop	ds
 30973                                  
 30974 000052B4 803E[5703]00            	CMP	byte [CONSWAP],0
 30975 000052B9 7403                    	JZ	short NOSWAP2
 30976 000052BB E818DF                  	call	SWAPBACK
 30977                                  NOSWAP2:
 30978                                  	; See if we are to truly abort. If we are in the process of aborting, 
 30979                                  	; turn this abort into a fail.
 30980                                  
 30981                                  	;test	[fAborting],0FFh
 30982                                  	;jnz	short DoFail
 30983                                  
 30984 000052BE 803E[5903]00            	cmp	byte [fAborting],0
 30985 000052C3 75AC                    	JNZ	short DoFail
 30986                                  
 30987                                  	; Set return code
 30988                                  
 30989 000052C5 C606[7C05]02            	MOV	BYTE [EXIT_TYPE],EXIT_HARD_ERROR ; 2
 30990 000052CA 30C0                    	XOR	AL,AL
 30991                                  
 30992                                  	; we are truly aborting the process. Go restore information from 
 30993                                  	; the PDB as necessary.
 30994                                  
 30995 000052CC E97B0D                  	jmp	exit_inner
 30996                                  
 30997                                  ;** --------------------------------------------------------------------------
 30998                                  ;
 30999                                  ; reset_environment checks the DS value against the CurrentPDB. If they are
 31000                                  ; different, then an old-style return is performed. If they are the same,
 31001                                  ; then we release jfns and restore to parent. We still use the PDB at DS:0 as
 31002                                  ; the source of the terminate addresses.
 31003                                  ;
 31004                                  ; Some subtlety: We are about to issue a bunch of calls that *may* generate
 31005                                  ; INT 24s. We *cannot* allow the user to restart the abort process; we may
 31006                                  ; end up aborting the wrong process or turn a terminate/stay/resident into a
 31007                                  ; normal abort and leave interrupt handlers around. What we do is to set a
 31008                                  ; flag that will indicate that if any abort code is seen, we just continue the
 31009                                  ; operation. In essence, we dis-allow the abort response.
 31010                                  ;
 31011                                  ; output:   none.
 31012                                  ; ----------------------------------------------------------------------------
 31013                                  
 31014                                  	;entry	reset_environment
 31015                                  	
 31016                                  reset_environment:
 31017                                  	; 30/07/2018 - Retro DOS v3.0
 31018                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 588Ah 
 31019                                  
 31020                                  ;***	invoke	Reset_Version		; AN007 ;MS. reset version number
 31021                                  
 31022 000052CF 1E                      	PUSH	DS			; save PDB of process
 31023                                  
 31024                                  	; There are no critical sections in force. Although we may enter
 31025                                  	; here with critical sections locked down, they are no longer 
 31026                                  	; relevant. We may safely free all allocated resources.
 31027                                  
 31028 000052D0 B482                    	MOV	AH,82h
 31029                                  		; Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7
 31030                                  	;int	2Ah 	
 31031 000052D2 CD2A                    	INT	int_IBM
 31032                                  
 31033                                  					; SS override
 31034 000052D4 36C606[5903]FF          	MOV	byte [SS:fAborting],-1	; signal abort in progress
 31035                                  
 31036                                  					; DOS 4.00 doesn't need it
 31037                                  	;CallInstall NetResetEnvironment, MultNET, 34  
 31038                                  					; Allow REDIR to clear some stuff
 31039                                  					; On process exit.
 31040 000052DA B82211                  	mov	ax, 1122h
 31041 000052DD CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
 31042                                  			; SS = DOS CS
 31043                                  	;mov	al,22h	
 31044 000052DF B022                    	MOV	AL,int_terminate
 31045 000052E1 E88EBB                  	call	_$GET_INTERRUPT_VECTOR	; and who to go to
 31046                                  
 31047 000052E4 59                      	POP	CX			; get ThisPDB
 31048 000052E5 06                      	push	es
 31049 000052E6 53                      	push	bx			; save return address
 31050                                  
 31051 000052E7 368B1E[3003]            	MOV	BX,[SS:CurrentPDB] 	; get currentPDB
 31052 000052EC 8EDB                    	MOV	DS,BX
 31053 000052EE A11600                  	MOV	AX,[PDB.PARENT_PID]	; get parentPDB
 31054                                  
 31055                                  	; AX = parentPDB, BX = CurrentPDB, CX = ThisPDB
 31056                                  	; Only free handles if AX <> BX and BX = CX and [exit_code].upper
 31057                                  	; is not Exit_keep_process
 31058                                  	
 31059 000052F1 39D8                    	CMP	AX,BX
 31060 000052F3 7418                    	JZ	short reset_return	; parentPDB = CurrentPDB
 31061 000052F5 39CB                    	CMP	BX,CX
 31062 000052F7 7514                    	JNZ	short reset_return	; CurrentPDB <> ThisPDB
 31063 000052F9 50                      	PUSH	AX			; save parent
 31064                                  
 31065                                  					; SS override
 31066                                  	;cmp	byte [SS:EXIT_TYPE],3
 31067 000052FA 36803E[7C05]03          	CMP	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS ; 15/08/2018
 31068 00005300 7406                    	JZ	short reset_to_parent 	; keeping this process
 31069                                  
 31070                                  	; We are truly removing a process. Free all allocation blocks
 31071                                  	; belonging to this PDB
 31072                                  
 31073                                  	;invoke	arena_free_process
 31074 00005302 E8840D                  	call	arena_free_process
 31075                                  
 31076                                  	; Kill off remainder of this process. Close file handles and signal
 31077                                  	; to relevant network folks that this process is dead. Remember that
 31078                                  	; CurrentPDB is STILL the current process!
 31079                                  
 31080                                  	;invoke	DOS_ABORT
 31081 00005305 E8F7DA                  	call	DOS_ABORT
 31082                                  
 31083                                  reset_to_parent:
 31084                                  					; SS override
 31085 00005308 368F06[3003]            	POP	word [SS:CurrentPDB]	; set up process as parent
 31086                                  
 31087                                  reset_return:				; come here for normal return
 31088                                  	;Context DS			; DS is used to refer to DOSDATA
 31089 0000530D 16                      	push	ss
 31090 0000530E 1F                      	pop	ds	
 31091                                  
 31092 0000530F B0FF                    	MOV	AL,-1
 31093                                  
 31094                                  	; make sure that everything is clean In this case ignore any errors,
 31095                                  	; we cannot "FAIL" the abort, the program being aborted is dead.
 31096                                  
 31097                                  	;EnterCrit critDisk
 31098 00005311 E8CEBF                  	call	ECritDisk
 31099                                  	;invoke	FLUSHBUF
 31100 00005314 E89E05                  	call	FLUSHBUF
 31101                                  	;LeaveCrit critDisk
 31102 00005317 E8E3BF                  	call	LCritDisk
 31103                                  
 31104                                  	; Decrement open ref. count if we had done a virtual open earlier.
 31105                                  
 31106 0000531A E897F7                  	call	CHECK_VIRT_OPEN
 31107 0000531D FA                      	CLI
 31108 0000531E C606[2103]00            	MOV	BYTE [INDOS],0		; Go to known state
 31109 00005323 C606[2203]FF            	MOV	BYTE [WPERR],-1		; Forget about WP error
 31110 00005328 C606[5903]00            	MOV	byte [fAborting],0	; let aborts occur
 31111 0000532D 8F06[8005]              	POP	WORD [EXITHOLD]
 31112 00005331 8F06[8205]              	POP	WORD [EXITHOLD+2]
 31113                                  
 31114                                  	; Snake into multitasking... Get stack from CurrentPDB person
 31115                                  
 31116 00005335 8E1E[3003]              	MOV	DS,[CurrentPDB]
 31117 00005339 8E163000                	MOV	SS,[PDB.USER_STACK+2]
 31118 0000533D 8B262E00                	MOV	SP,[PDB.USER_STACK]
 31119                                  
 31120 00005341 E807B1                  	call	restore_world
 31121                                  
 31122                                  	; 05/05/2019
 31123 00005344 07                      	pop	es ; * ; MSDOS 6.21 (DOSCODE:94A8h, MSDOS.SYS)
 31124                                  
 31125                                  	; MSDOS 6.0
 31126 00005345 50                      	push	ax			; set up ds, but save ds in TEMPSEG
 31127 00005346 8CD8                    	mov	ax,ds			; and not on stack.
 31128                                  	;getdseg <ds>			; ds -> dosdata
 31129 00005348 2E8E1E[0700]            	mov	ds,[cs:DosDSeg] 
 31130 0000534D A3[0A0D]                	mov	[TEMPSEG],ax
 31131 00005350 58                      	pop	ax
 31132                                  					; set up ds to DOSDATA
 31133                                  	;MOV	[CS:USER_SP],AX ; MSDOS 3.3
 31134 00005351 A3[8405]                	mov	[USER_SP],ax
 31135                                  
 31136 00005354 58                      	POP	AX			; suck off CS:IP of interrupt...
 31137 00005355 58                      	POP	AX
 31138 00005356 58                      	POP	AX
 31139                                  
 31140                                  ; M011 : BEGIN
 31141                                  
 31142                                  	; MSDOS 3.3
 31143                                  ;	MOV	AX,0F202h	; STI
 31144                                  
 31145                                  	; MSDOS 6.0
 31146 00005357 9F                      	LAHF
 31147 00005358 86E0                    	XCHG	AH,AL
 31148 0000535A 2402                    	AND	AL,2
 31149 0000535C B4F2                    	MOV	AH,0F2h
 31150                                  
 31151                                  ; M011 : END
 31152                                  
 31153                                  	; MSDOS 3.3 (& MSDOS 6.0)
 31154 0000535E 50                      	PUSH	AX
 31155                                   
 31156                                  	;PUSH	word [CS:EXITHOLD+2]
 31157                                  	;PUSH	word [CS:EXITHOLD]
 31158                                  	
 31159                                  	; MSDOS 6.0
 31160 0000535F FF36[8205]              	PUSH	word [EXITHOLD+2]
 31161 00005363 FF36[8005]              	PUSH	word [EXITHOLD]
 31162                                  
 31163                                  	;MOV	AX,[CS:USER_SP]
 31164                                  
 31165                                  	; MSDOS 6.0
 31166 00005367 A1[8405]                	MOV	AX,[USER_SP]
 31167 0000536A 8E1E[0A0D]              	mov	ds,[TEMPSEG]	; restore ds
 31168                                  
 31169 0000536E CF                      	IRET			; Long return back to user terminate address
 31170                                  
 31171                                  ;---------------------------------------------------------------------------
 31172                                  ;
 31173                                  ; Procedure Name : SET_I24_EXTENDED_ERROR
 31174                                  ;
 31175                                  ; This routine handles extended error codes.
 31176                                  ; Input : DI = error code from device
 31177                                  ; Output: All EXTERR fields are set
 31178                                  ;
 31179                                  ;--------------------------------------------------------------------------
 31180                                  
 31181                                  SET_I24_EXTENDED_ERROR:
 31182 0000536F 50                      	PUSH	AX
 31183                                  					; ErrMap24End is in DOSDATA
 31184 00005370 B8[BB0E]                	MOV	AX,ErrMap24End
 31185 00005373 2D[AB0E]                	SUB	AX,ErrMap24
 31186                                  					; Change to dosdata to access
 31187                                  					; ErrMap24 and EXTERR -SR
 31188                                  	; 05/05/2019 - Retro DOS v4.0
 31189                                  	
 31190                                  	; MSDOS 6.0
 31191 00005376 1E                      	push	ds
 31192                                  	;getdseg <ds>			; ds ->dosdata
 31193 00005377 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 31194                                  
 31195                                  	; AX is the index of the first unavailable error. Do not translate
 31196                                  	; if greater or equal to AX.
 31197                                  
 31198 0000537C 39C7                    	CMP	DI,AX
 31199 0000537E 89F8                    	MOV	AX,DI
 31200 00005380 7306                    	JAE	short NoTrans
 31201                                  
 31202                                  	;MOV	AL,[CS:DI+ErrMap24]  ; MSDOS 3.3
 31203 00005382 8A85[AB0E]              	mov	al,[ErrMap24+di] ; MSDOS 6.0
 31204 00005386 30E4                    	XOR	AH,AH
 31205                                  NoTrans:
 31206                                  	;MOV	[CS:EXTERR],AX
 31207 00005388 A3[2403]                	mov	[EXTERR],AX
 31208 0000538B 1F                      	pop	ds
 31209                                  	;assume	ds:nothing
 31210 0000538C 58                      	POP	AX
 31211                                  
 31212                                  	; Now Extended error is set correctly. Translate it to get correct
 31213                                  	; error locus class and recommended action.
 31214                                  
 31215 0000538D 56                      	PUSH	SI
 31216                                  					; ERR_TABLE_24 is in DOSCODE 
 31217 0000538E BE[5B0E]                	MOV	SI,ERR_TABLE_24
 31218 00005391 E8E0B2                  	call	CAL_LK			; Set other extended error fields
 31219 00005394 5E                      	POP	SI
 31220 00005395 C3                      	retn
 31221                                  
 31222                                  ;============================================================================
 31223                                  ; FAT.ASM, MSDOS 6.0, 1991
 31224                                  ;============================================================================
 31225                                  ; 30/07/2018 - Retro DOS v3.0
 31226                                  ; 20/05/2019 - Retro DOS v4.0
 31227                                  
 31228                                  ;	TITLE	FAT - FAT maintenance routines
 31229                                  ;	NAME	FAT
 31230                                  
 31231                                  ;**	FAT.ASM
 31232                                  ;----------------------------------------------------------------------------
 31233                                  ;	Low level local device routines for performing disk change sequence,
 31234                                  ;	setting cluster validity, and manipulating the FAT
 31235                                  ;
 31236                                  ;	IsEof
 31237                                  ;	UNPACK
 31238                                  ;	PACK
 31239                                  ;	MAPCLUSTER
 31240                                  ;	FATREAD_SFT
 31241                                  ;	FATREAD_CDS
 31242                                  ;	FAT_operation
 31243                                  ;
 31244                                  ;	Revision history:
 31245                                  ;
 31246                                  ;	  AN000  version Jan. 1988
 31247                                  ;	   A001  PTM	      -- disk changed for look ahead buffers
 31248                                  ;
 31249                                  ;	M014 - if a request for pack\unpack cluster 0 is made we write\read
 31250                                  ;	       from CL0FATENTRY rather than disk.
 31251                                  
 31252                                  ; DOSCODE:94FAh (MSDOS 6.21, MSDOS.SYS)
 31253                                  
 31254                                  ;Break <IsEOF - check the quantity in BX for EOF>
 31255                                  ;----------------------------------------------------------------------------
 31256                                  ;
 31257                                  ; Procedure Name : IsEOF
 31258                                  ;
 31259                                  ; IsEOF - check the fat value in BX for eof.
 31260                                  ;
 31261                                  ;   Inputs:	ES:BP point to DPB
 31262                                  ;		BX has fat value
 31263                                  ;   Outputs:	JAE eof
 31264                                  ;   Registers modified: none
 31265                                  ;
 31266                                  ;---------------------------------------------------------------------------
 31267                                  
 31268                                  IsEOF:
 31269                                  	;cmp	word [es:bp+0Dh],0FF6h
 31270 00005396 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; is this 16 bit fat?
 31271 0000539C 730B                    	JAE	short EOF16			; yes, check for eof there
 31272                                  
 31273                                  ;J.K. 8/27/86
 31274                                  ;Modified to accept 0FF0h as an eof. This is to handle the diskfull case
 31275                                  ;of any media that has "F0"(Other) as a MediaByte.
 31276                                  ;Hopely, this does not create any side effect for those who may use any value
 31277                                  ;other than "FF8-FFF" as an EOF for their own file.
 31278                                  
 31279 0000539E 81FBF00F                	cmp	bx,0FF0h
 31280 000053A2 7404                    	je	short IsEOF_other
 31281                                  
 31282 000053A4 81FBF80F                	CMP	BX,0FF8h		; do the 12 bit compare
 31283                                  IsEOF_other:
 31284 000053A8 C3                      	retn
 31285                                  EOF16:
 31286 000053A9 83FBF8                  	CMP	BX,0FFF8h		; 16 bit compare
 31287 000053AC C3                      	retn
 31288                                  
 31289                                  ; DOSCODE:9511h (MSDOS 6.21, MSDOS.SYS)
 31290                                  
 31291                                  ;Break	<UNPACK -- UNPACK FAT ENTRIES>
 31292                                  ;---------------------------------------------------------------------------
 31293                                  ;
 31294                                  ; Procedur Name : UNPACK
 31295                                  ;
 31296                                  ; Inputs:
 31297                                  ;	BX = Cluster number (may be full 16-bit quantity)
 31298                                  ;	ES:BP = Base of drive parameters
 31299                                  ; Outputs:
 31300                                  ;	DI = Contents of FAT for given cluster (may be full 16-bit quantity)
 31301                                  ;	Zero set means DI=0 (free cluster)
 31302                                  ;	Carry set means error (currently user FAILed to I 24)
 31303                                  ; SI Destroyed, No other registers affected. Fatal error if cluster too big.
 31304                                  ;
 31305                                  ; NOTE: if BX = 0 then DI = contents of CL0FATENTRY
 31306                                  ;
 31307                                  ;----------------------------------------------------------------------------
 31308                                  	
 31309                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31310                                  	; DOSCODE:94B5h (MSDOS 5.0, MSDOS.SYS)
 31311                                  
 31312                                  	; 20/05/2019 - Retro DOS v4.0
 31313                                  UNPACK:
 31314                                  	; MSDOS 6.0			; M014 - Start
 31315 000053AD 09DB                    	or	bx,bx			; Q: are we unpacking cluster 0
 31316 000053AF 7507                    	jnz	short up_cont		; N: proceed with normal unpack
 31317 000053B1 8B3E[8100]              	mov	di,[CL0FATENTRY]	; Y: return value in CL0FATENTRY
 31318 000053B5 09FF                    	or	di,di 			; return z if di=0
 31319 000053B7 C3                      	retn				; done
 31320                                  up_cont:				; M014 - End
 31321                                  	; MSDOS 3.3 & MSDOS 6.0
 31322                                  	;cmp	bx,[es:bp+0Dh]
 31323 000053B8 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 31324 000053BC 7726                    	JA	short HURTFAT
 31325 000053BE E8D500                  	CALL	MAPCLUSTER
 31326 000053C1 721E                    	jc	short _DoContext
 31327 000053C3 8B3D                    	MOV	DI,[DI]
 31328 000053C5 750E                    	JNZ	short High12		; MZ if high 12 bits, go get 'em
 31329 000053C7 268B760D                	MOV	SI,[ES:BP+DPB.MAX_CLUSTER] ; MZ is this 16-bit fat?
 31330 000053CB 81FEF60F                	CMP	SI,4096-10
 31331 000053CF 720C                    	JB	short Unpack12		; MZ No, go 'AND' off bits
 31332 000053D1 09FF                    	OR	DI,DI			; MZ set zero condition code, clears carry
 31333 000053D3 EB0C                    	JMP	SHORT _DoContext 	; MZ go do context
 31334                                  High12:
 31335 000053D5 D1EF                    	SHR	DI,1
 31336 000053D7 D1EF                    	SHR	DI,1
 31337 000053D9 D1EF                    	SHR	DI,1
 31338 000053DB D1EF                    	SHR	DI,1
 31339                                  Unpack12:
 31340 000053DD 81E7FF0F                	AND	DI,0FFFh		; Clears carry
 31341                                  _DoContext:
 31342 000053E1 16                      	PUSH	SS
 31343 000053E2 1F                      	POP	DS
 31344 000053E3 C3                      	retn
 31345                                  HURTFAT:
 31346                                  	;;mov	word [es:bp+1Eh],0FFFFh
 31347                                  	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
 31348 000053E4 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; Err in FAT must force recomp of freespace
 31349 000053EA 50                      	PUSH	AX
 31350 000053EB B488                    	MOV	AH,Allowed_FAIL+80h ; 88h
 31351                                  
 31352                                  ;hkn; SS override
 31353 000053ED 36C606[4B03]08          	MOV	byte [SS:ALLOWED],Allowed_FAIL ; 8
 31354                                  ;
 31355                                  ; Signal Bad FAT to INT int_fatal_abort handler. We have an invalid cluster.
 31356                                  ;
 31357 000053F3 BFFF0F                  	MOV	DI,0FFFh		; In case INT int_fatal_abort returns (it shouldn't)
 31358 000053F6 E8CCFD                  	call	FATAL
 31359 000053F9 3C03                    	CMP	AL,3
 31360 000053FB F8                      	CLC
 31361 000053FC 7501                    	JNZ	short OKU_RET 		; Try to ignore bad FAT
 31362 000053FE F9                      	STC				; User said FAIL
 31363                                  OKU_RET:
 31364 000053FF 58                      	POP	AX
 31365                                  hurtfat_retn:
 31366 00005400 C3                      	retn
 31367                                  
 31368                                  ; DOSCODE:9565h (MSDOS 6.21, MSDOS.SYS)
 31369                                  
 31370                                  ;Break	<PACK -- PACK FAT ENTRIES>
 31371                                  ;----------------------------------------------------------------------------
 31372                                  ;
 31373                                  ; Procedure Name : PACK
 31374                                  ;
 31375                                  ; Inputs:
 31376                                  ;	BX = Cluster number
 31377                                  ;	DX = Data
 31378                                  ;	ES:BP = Pointer to drive DPB
 31379                                  ; Outputs:
 31380                                  ;	The data is stored in the FAT at the given cluster.
 31381                                  ;	SI,DX,DI all destroyed
 31382                                  ;	Carry set means error (currently user FAILed to I 24)
 31383                                  ;	No other registers affected
 31384                                  ;
 31385                                  ; NOTE: if BX = 0 then data in DX is stored in CL0FATENTRY.
 31386                                  ;
 31387                                  ;---------------------------------------------------------------------------
 31388                                  
 31389                                  	; 02/01/2024
 31390                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31391                                  	; 20/05/2019 - Retro DOS v4.0
 31392                                  PACK:
 31393                                  	; MSDOS 6.0			; M014 - start
 31394 00005401 09DB                    	or	bx,bx			; Q: are we packing cluster 0
 31395 00005403 7505                    	jnz	short p_cont		; N: proceed with normal pack
 31396 00005405 8916[8100]              	mov	[CL0FATENTRY],dx	; Y: place value in CL0FATENTRY
 31397 00005409 C3                      	retn				; done
 31398                                  p_cont:					; M014 - end
 31399                                  	; MSDOS 3.3 & MSDOS 6.0
 31400 0000540A E88900                  	CALL	MAPCLUSTER
 31401 0000540D 72D2                    	JC	short _DoContext
 31402 0000540F 8B35                    	MOV	SI,[DI]
 31403 00005411 740B                    	JZ	short ALIGNED 		; byte (not nibble) aligned
 31404 00005413 51                      	PUSH	CX			; move data to upper 12 bits
 31405 00005414 B104                    	MOV	CL,4
 31406 00005416 D3E2                    	SHL	DX,CL
 31407 00005418 59                      	POP	CX
 31408 00005419 83E60F                  	AND	SI,0FH			; leave in original low 4 bits
 31409 0000541C EB13                    	JMP	SHORT PACKIN
 31410                                  ALIGNED:
 31411                                  	;cmp	word [es:bp+0Dh],0FF6h
 31412 0000541E 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ 16 bit fats?
 31413 00005424 7309                    	JAE	short Pack16		; MZ yes, go clobber original data
 31414 00005426 81E600F0                	AND	SI,0F000h		; MZ leave in upper 4 bits of original
 31415                                  	;AND	DX,0FFFh		; MZ store only 12 bits
 31416                                  	; 01/07/2024
 31417 0000542A 80E60F                  	and	dh,0Fh
 31418 0000542D EB02                    	JMP	SHORT PACKIN		; MZ go store
 31419                                  Pack16:
 31420 0000542F 31F6                    	XOR	SI,SI			; MZ no original data
 31421                                  PACKIN:
 31422 00005431 09D6                    	OR	SI,DX
 31423 00005433 8935                    	MOV	[DI],SI
 31424                                  
 31425                                  ;hkn; SS override
 31426 00005435 36C536[E205]            	LDS	SI,[SS:CURBUF]
 31427                                  	; MSDOS 6.0
 31428 0000543A F6440540                	TEST	byte [SI+BUFFINFO.buf_flags],buf_dirty  
 31429                                  					;LB. if already dirty		  ;AN000;
 31430 0000543E 7507                    	JNZ	short yesdirty11	;LB.  don't increment dirty count ;AN000;
 31431                                  	; 10/06/2019
 31432 00005440 E88005                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 31433                                  	
 31434                                  	;or	byte [si+5],40h
 31435 00005443 804C0540                	OR	byte [SI+BUFFINFO.buf_flags],buf_dirty  
 31436                                  yesdirty11:				;LB.				;AN000;
 31437                                  ;hkn; SS override
 31438 00005447 36803E[7805]00          	CMP	BYTE [SS:CLUSSPLIT],0	; 15/08/2018
 31439                                  ;hkn; SS is DOSDATA
 31440 0000544D 16                      	push	ss
 31441 0000544E 1F                      	pop	ds
 31442 0000544F 74AF                    	jz	short hurtfat_retn	; Carry clear
 31443 00005451 50                      	PUSH	AX
 31444 00005452 53                      	PUSH	BX
 31445 00005453 51                      	PUSH	CX
 31446 00005454 A1[8E05]                	MOV	AX,[CLUSSAVE]
 31447 00005457 8E1E[E405]              	MOV	DS,[CURBUF+2]
 31448                                  	;;add	si,16 ; MSDOS 3.3
 31449                                  	;add	si,20 ; MSDOS 6.0
 31450 0000545B 83C614                  	ADD	SI,BUFINSIZ
 31451 0000545E 8824                    	MOV	[SI],AH
 31452                                  ;hkn; SS is DOSDATA
 31453                                  	;Context DS
 31454 00005460 16                      	push	ss
 31455 00005461 1F                      	pop	ds
 31456                                  	
 31457 00005462 50                      	PUSH	AX
 31458                                  	
 31459                                  	; MSDOS 6.0
 31460 00005463 8B16[9205]              	MOV	DX,[CLUSSEC+2]		;F.C. >32mb			;AN000;
 31461 00005467 8916[0706]              	MOV	[HIGH_SECTOR],DX	;F.C. >32mb			;AN000;
 31462                                  
 31463                                  	; MSDOS 3.3 & MSDOS 6.0
 31464 0000546B 8B16[9005]              	MOV	DX,[CLUSSEC]
 31465                                  
 31466                                  	;MOV	SI,1	  ; *
 31467                                  	;XOR	AL,AL     ; *
 31468                                  	;call	GETBUFFRB ; *
 31469                                  	; 22/09/2023
 31470 0000546F E83803                  	call	GETBUFFRA ; *
 31471                                  
 31472 00005472 58                      	POP	AX
 31473 00005473 721B                    	JC	short POPP_RET
 31474 00005475 C53E[E205]              	LDS	DI,[CURBUF]
 31475                                  	
 31476                                  	; MSDOS 6.0
 31477 00005479 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 31478                                  					;LB. if already dirty		  ;AN000;
 31479 0000547D 7507                    	JNZ	short yesdirty12	;LB.  don't increment dirty count ;AN000;
 31480 0000547F E84105                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 31481                                  	
 31482                                  	;or	byte [di+5],40h
 31483 00005482 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty 
 31484                                  yesdirty12:
 31485                                  	;;add	di,16
 31486                                  	;add	di,20 ; MSDOS 6.0
 31487                                  	; 02/01/2024
 31488                                  	;ADD	DI,BUFINSIZ
 31489                                  	;DEC	DI
 31490 00005486 83C713                  	add	di,BUFINSIZ-1 ; 19
 31491                                  
 31492                                  	;add	di,[es:bp+2]
 31493 00005489 26037E02                	ADD	DI,[ES:BP+DPB.SECTOR_SIZE]
 31494 0000548D 8805                    	MOV	[DI],AL
 31495 0000548F F8                      	CLC
 31496                                  POPP_RET:
 31497 00005490 16                      	PUSH	SS
 31498 00005491 1F                      	POP	DS
 31499 00005492 59                      	POP	CX
 31500 00005493 5B                      	POP	BX
 31501 00005494 58                      	POP	AX
 31502 00005495 C3                      	retn
 31503                                  
 31504                                  ; 31/07/2018 - Retro DOS v3.0
 31505                                  
 31506                                  ;Break	<MAPCLUSTER - BUFFER A FAT SECTOR>
 31507                                  ;---------------------------------------------------------------------------
 31508                                  ;
 31509                                  ; Procedure Name : MAPCLUSTER
 31510                                  ;
 31511                                  ; Inputs:
 31512                                  ;	ES:BP Points to DPB
 31513                                  ;	BX Is cluster number
 31514                                  ; Function:
 31515                                  ;	Get a pointer to the cluster
 31516                                  ; Outputs:
 31517                                  ;	DS:DI Points to contents of FAT for given cluster
 31518                                  ;	DS:SI Points to start of buffer
 31519                                  ;	Zero Not set if cluster data is in high 12 bits of word
 31520                                  ;	Zero set if cluster data is in low 12 or 16 bits
 31521                                  ;	Carry set if failed.
 31522                                  ; SI is destroyed.
 31523                                  ;
 31524                                  ;---------------------------------------------------------------------------
 31525                                  
 31526                                  	; 20/05/2019 - Retro DOS v4.0
 31527                                  	; DOSCODE:9601h (MSDOS 6.21, MSDOS.SYS)
 31528                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31529                                  	; DOSCODE:95A5h (MSDOS 5.0, MSDOS.SYS)
 31530                                  
 31531                                  MAPCLUSTER:
 31532                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5A15h
 31533 00005496 C606[7805]00            	MOV	BYTE [CLUSSPLIT],0
 31534                                  	;SAVE	<AX,BX,CX,DX>
 31535 0000549B 50                      	push	ax
 31536 0000549C 53                      	push	bx
 31537 0000549D 51                      	push	cx
 31538 0000549E 52                      	push	dx
 31539 0000549F 89D8                    	MOV	AX,BX			; AX = BX
 31540 000054A1 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10  ; MZ 16 bit fat?
 31541 000054A7 7302                    	JAE	short Map16		; MZ yes, do 16 bit algorithm
 31542 000054A9 D1E8                    	SHR	AX,1			; AX = BX/2
 31543                                  Map16:	
 31544                                  	; MSDOS 6.0			; MZ skip prev => AX=2*BX
 31545 000054AB 31FF                    	XOR	DI,DI ; *		; >32mb fat ;AN000;
 31546                                  	; MSDOS 3.3 (& MSDOS 6.0)
 31547 000054AD 01D8                    	ADD	AX,BX			; AX = 1.5*fat = byte offset in fat
 31548 000054AF 11FF                    	ADC	DI,DI ; * MSDOS 6.0	; >32mb fat ;DI is zero before op;AN000;
 31549 000054B1 268B4E02                	MOV	CX,[ES:BP+DPB.SECTOR_SIZE]
 31550                                  
 31551                                  ;IF FastDiv
 31552                                  ;
 31553                                  ; Gross hack: 99% of all disks have 512 bytes per sector. We test for this
 31554                                  ; case and apply a really fast algorithm to get the desired results
 31555                                  ;
 31556                                  ; Divide method takes 157+4*4=173 (MOV and DIV)
 31557                                  ; Fast method takes 39+20*4=119
 31558                                  ;
 31559                                  ; This saves a bunch.
 31560                                  
 31561 000054B5 81F90002                	CMP	CX,512			; 4  Is this 512 byte sector?
 31562 000054B9 7510                    	jne	short _DoDiv		; 4  for no jump
 31563 000054BB 89C2                    	MOV	DX,AX			; 2  get set for remainder
 31564 000054BD 81E2FF01                	AND	DX,512-1		; 4  Form remainder
 31565 000054C1 88E0                    	MOV	AL,AH			; 2  Quotient in formation in AL
 31566                                  	; MDOS 3.3
 31567                                  	;shr	al,1	
 31568                                  	; MDOS 6.0
 31569 000054C3 D1EF                    	shr	di,1			; 2
 31570 000054C5 D0D8                    	rcr	al,1			; 2
 31571                                  	; MDOS 3.3 (& MSDOS 6.0)
 31572 000054C7 30E4                    	xor	ah,ah			; 3
 31573 000054C9 EB04                    	jmp	short DivDone		; 16
 31574                                  _DoDiv:
 31575                                  ;ENDIF
 31576                                  	; MSDOS 3.3
 31577                                  	;xor	dx,dx
 31578                                  	; MSDOS 6.0
 31579 000054CB 89FA                    	mov	dx,di			; 2
 31580                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 31581 000054CD F7F1                    	DIV	CX			; 155 AX is FAT sector # DX is sector index
 31582                                  ;IF FastDiv
 31583                                  DivDone:
 31584                                  ;ENDIF
 31585                                  	;add	ax,[es:bp+6]
 31586 000054CF 26034606                	ADD	AX,[ES:BP+DPB.FIRST_FAT]
 31587 000054D3 49                      	DEC	CX			; CX is sector size - 1
 31588                                  	;SAVE	<AX,DX,CX>
 31589 000054D4 50                      	push	ax
 31590 000054D5 52                      	push	dx
 31591 000054D6 51                      	push	cx
 31592 000054D7 89C2                    	MOV	DX,AX
 31593                                  
 31594                                  	; MSDOS 6.0
 31595                                  	; 22/09/2023
 31596                                  	;MOV	word [HIGH_SECTOR],0 ; *! ;F.C. >32mb  low sector #
 31597                                  	;
 31598                                  	; MDOS 3.3 (& MSDOS 6.0)
 31599                                  	;XOR	AL,AL	   ; *
 31600                                  	;MOV	SI,1	   ; *
 31601                                  	;;invoke GETBUFFRB ; *
 31602                                  	;call	GETBUFFRB  ; *
 31603                                  	; 22/09/2023
 31604 000054D9 E8C802                  	call	GETBUFFRC  ; *!
 31605                                  
 31606                                  	;RESTORE <CX,AX,DX>		; CX is sec siz-1, AX is offset in sec
 31607 000054DC 59                      	pop	cx
 31608 000054DD 58                      	pop	ax
 31609 000054DE 5A                      	pop	dx
 31610 000054DF 724C                    	JC	short MAP_POP
 31611                                  
 31612 000054E1 C536[E205]              	LDS	SI,[CURBUF]
 31613                                  	;;lea	di,[si+16]
 31614                                  	;lea	di,[si+20] ; MSDOS 6.0
 31615 000054E5 8D7C14                  	LEA	DI,[SI+BUFINSIZ]
 31616 000054E8 01C7                    	ADD	DI,AX
 31617 000054EA 39C8                    	CMP	AX,CX
 31618 000054EC 752C                    	JNZ	short MAPRET
 31619 000054EE 8A05                    	MOV	AL,[DI]
 31620                                  	;Context DS		 	;hkn; SS is DOSDATA
 31621 000054F0 16                      	push	ss
 31622 000054F1 1F                      	pop	ds	
 31623 000054F2 FE06[7805]              	INC	BYTE [CLUSSPLIT]
 31624 000054F6 A2[8E05]                	MOV	[CLUSSAVE],AL
 31625 000054F9 8916[9005]              	MOV	[CLUSSEC],DX
 31626                                  	; MSDOS 6.0
 31627 000054FD C706[9205]0000          	MOV	WORD [CLUSSEC+2],0      ;F.C. >32mb	;AN000;
 31628 00005503 42                      	INC	DX
 31629                                  
 31630                                  	; 22/09/2023
 31631                                  	;MOV	word [HIGH_SECTOR],0 ; *! ;F.C. >32mb FAT sector <32mb ;AN000;
 31632                                  	;
 31633                                  	; MDOS 3.3 (& MSDOS 6.0)
 31634                                  	;XOR	AL,AL	   ; *
 31635                                  	;MOV	SI,1	   ; *
 31636                                  	;;invoke GETBUFFRB ; *
 31637                                  	;call	GETBUFFRB  ; *
 31638                                  	; 22/09/2023
 31639 00005504 E89D02                  	call	GETBUFFRC  ; *!
 31640 00005507 7224                    	JC	short MAP_POP
 31641                                  
 31642 00005509 C536[E205]              	LDS	SI,[CURBUF]
 31643 0000550D 8D7C14                  	LEA	DI,[SI+BUFINSIZ]
 31644 00005510 8A05                    	MOV	AL,[DI]
 31645                                  	;Context DS			;hkn; SS is DOSDATA
 31646 00005512 16                      	push	ss
 31647 00005513 1F                      	pop	ds
 31648 00005514 A2[8F05]                	MOV	[CLUSSAVE+1],AL
 31649                                  
 31650                                  ;hkn; CLUSSAVE is in DOSDATA
 31651 00005517 BF[8E05]                	MOV	DI,CLUSSAVE
 31652                                  MAPRET:
 31653                                  	;RESTORE <DX,CX,BX>
 31654 0000551A 5A                      	pop	dx
 31655 0000551B 59                      	pop	cx
 31656 0000551C 5B                      	pop	bx
 31657 0000551D 31C0                    	XOR	AX,AX			; MZ allow shift to clear carry
 31658 0000551F 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ is this 16-bit fat?
 31659 00005525 7302                    	JAE	short MapSet		; MZ no, set flags
 31660 00005527 89D8                    	MOV	AX,BX
 31661                                  MapSet:
 31662 00005529 A801                    	TEST	AL,1			; set zero flag if not on boundary
 31663                                  	;RESTORE <AX>
 31664 0000552B 58                      	pop	ax
 31665 0000552C C3                      	retn
 31666                                  
 31667                                  MAP_POP:
 31668                                  	;RESTORE <DX,CX,BX,AX>
 31669 0000552D 5A                      	pop	dx
 31670 0000552E 59                      	pop	cx
 31671 0000552F 5B                      	pop	bx
 31672 00005530 58                      	pop	ax
 31673                                  fatread_sft_retn: ; 17/12/2022
 31674 00005531 C3                      	retn
 31675                                  
 31676                                  ; 20/05/2019 - Retro DOS v4.0
 31677                                  ; DOSCODE:96B3h (MSDOS 6.21, MSDOS.SYS)
 31678                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31679                                  ; DOSCODE:9657h (MSDOS 5.0, MSDOS.SYS)
 31680                                  
 31681                                  ;Break	<FATREAD_SFT/FATREAD_CDS -- CHECK DRIVE GET FAT>
 31682                                  ;----------------------------------------------------------------------------
 31683                                  ;
 31684                                  ; Procedure Name : FATREAD_SFT
 31685                                  ;
 31686                                  ; Inputs:
 31687                                  ;	ES:DI points to an SFT for the drive of intrest (local only,
 31688                                  ;		giving a NET SFT will produce system crashing results).
 31689                                  ;	DS DOSDATA
 31690                                  ; Function:
 31691                                  ;	Can be used by an SFT routine (like CLOSE) to invalidate buffers
 31692                                  ;	if disk changed.
 31693                                  ;	In other respects, same as FATREAD_CDS.
 31694                                  ;	(note ES:DI destroyed!)
 31695                                  ; Outputs:
 31696                                  ;	Carry set if error (currently user FAILed to I 24)
 31697                                  ; NOTE: This routine may cause FATREAD_CDS to "miss" a disk change
 31698                                  ;	as far as invalidating curdir_ID is concerned.
 31699                                  ;	Since getting a true disk changed on this call is a screw up
 31700                                  ;	anyway, that's the way it goes.
 31701                                  ;
 31702                                  ;---------------------------------------------------------------------------
 31703                                  
 31704                                  FATREAD_SFT:
 31705 00005532 26C46D07                	LES	BP,[ES:DI+SF_ENTRY.sf_devptr]
 31706                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31707                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 31708                                  	; 15/12/2022
 31709 00005536 268A4600                	mov	AL,[ES:BP]
 31710 0000553A A2[7605]                	MOV	[THISDRV],AL
 31711 0000553D E8E8B0                  	call	GOTDPB			;Set THISDPB
 31712                                  	;CALL	FAT_GOT_DPB
 31713                                  	; 17/12/2022
 31714 00005540 EB78                    	jmp	FAT_GOT_DPB
 31715                                  ;fatread_sft_retn:
 31716                                  	;retn
 31717                                  
 31718                                  ;----------------------------------------------------------------------------
 31719                                  ;
 31720                                  ; Procedure Name : FATREAD_CDS
 31721                                  ;
 31722                                  ; Inputs:
 31723                                  ;	DS:DOSDATA
 31724                                  ;	ES:DI points to an CDS for the drive of intrest (local only,
 31725                                  ;		giving a NET or NUL CDS will produce system crashing results).
 31726                                  ; Function:
 31727                                  ;	If disk may have been changed, media is determined and buffers are
 31728                                  ;	flagged invalid. If not, no action is taken.
 31729                                  ; Outputs:
 31730                                  ;	ES:BP = Drive parameter block
 31731                                  ;	THISDPB = ES:BP
 31732                                  ;	THISDRV set
 31733                                  ;	Carry set if error (currently user FAILed to I 24)
 31734                                  ; DS preserved , all other registers destroyed
 31735                                  ;
 31736                                  ;---------------------------------------------------------------------------
 31737                                  
 31738                                  	; 20/05/2019 - Retro DOS v4.0
 31739                                  	; DOSCODE:96C5h (MSDOS 6.21, MSDOS.SYS)
 31740                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31741                                  	; DOSCODE:9669h (MSDOS 5.0, MSDOS.SYS)
 31742                                  
 31743                                  FATREAD_CDS:
 31744 00005542 06                      	PUSH	ES
 31745 00005543 57                      	PUSH	DI
 31746                                  	;les	bp,[es:di+45h]
 31747 00005544 26C46D45                	LES	BP,[ES:DI+curdir.devptr]
 31748                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31749                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 31750                                  	; 15/12/2022
 31751 00005548 268A4600                	mov	AL,[ES:BP]
 31752 0000554C A2[7605]                	MOV	[THISDRV],AL
 31753 0000554F E8D6B0                  	call	GOTDPB			;Set THISDPB
 31754 00005552 E86500                  	CALL	FAT_GOT_DPB
 31755 00005555 5F                      	POP	DI			;Get back CDS pointer
 31756 00005556 07                      	POP	ES
 31757 00005557 72D8                    	jc	short fatread_sft_retn
 31758 00005559 7538                    	JNZ	short NO_CHANGE		;Media NOT changed
 31759                                  
 31760                                  ;	Media changed. We now need to find all CDS structures which use this
 31761                                  ;	DPB and invalidate their ID pointers.
 31762                                  
 31763                                  MED_CHANGE:
 31764 0000555B 31C0                    	XOR	AX,AX
 31765 0000555D 48                      	DEC	AX			; AX = -1
 31766 0000555E 1E                      	PUSH	DS
 31767 0000555F 8A0E[4700]              	MOV	CL,[CDSCOUNT]
 31768 00005563 30ED                    	XOR	CH,CH			; CX is number of structures
 31769                                  	;lds	si,[es:di+45h]
 31770 00005565 26C57545                	LDS	SI,[ES:DI+curdir.devptr] ; Find all CDS with this devptr
 31771                                  
 31772                                  ;hkn; SS override
 31773                                  
 31774                                  ;	Find all CDSs with this DevPtr
 31775                                  ;
 31776                                  ;	(ax) = -1
 31777                                  ;	(ds:si) = DevPtr
 31778                                  
 31779 00005569 36C43E[3C00]            	LES	DI,[SS:CDSADDR]		; (es:di) = CDS pointer
 31780                                  frcd20: 
 31781                                  	;;test	word [es:di+43h],8000h
 31782                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 31783 0000556E 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 31784 00005573 7518                    	JNZ	short frcd25		; Leave NET guys alone!!
 31785                                  
 31786                                  	; MSDOS 3.3
 31787                                  	;push	es
 31788                                  	;push	di
 31789                                  	;les	di,[es:di+45h]
 31790                                  	;;les	di,[ES:DI+curdir.devptr]
 31791                                  	;call	POINTCOMP
 31792                                  	;pop	di
 31793                                  	;pop	es
 31794                                  	;jnz	short frcd25
 31795                                  
 31796                                  	; MSDOS 6.0
 31797 00005575 263B7545                	cmp	si,[ES:DI+curdir.devptr]
 31798 00005579 7512                    	jne	short frcd25		; no match
 31799 0000557B 8CDB                    	mov	bx,ds
 31800 0000557D 263B5D47                	cmp	bx,[ES:DI+curdir.devptr+2]
 31801 00005581 750A                    	jne	short frcd25		; CDS not for this drive
 31802                                  
 31803                                  	; MSDOS 3.3 (& MSDOS 6.0)
 31804                                  	;test	[es:di+49h],ax
 31805 00005583 26854549                	test	[ES:DI+curdir.ID],AX
 31806 00005587 7404                    	JZ	short frcd25		; If root (0), leave root
 31807                                  	;mov	[es:di+49h],ax
 31808 00005589 26894549                	MOV	[ES:DI+curdir.ID],AX	; else invalid
 31809                                  frcd25:	
 31810                                  	;;add	di,81  ; MSDOS 3.3
 31811                                  	;add	di,88  ; MSDOS 6.0	 
 31812 0000558D 83C758                  	ADD	DI,curdir.size		; Point to next CDS
 31813 00005590 E2DC                    	LOOP	frcd20
 31814 00005592 1F                      	POP	DS
 31815                                  NO_CHANGE:
 31816 00005593 C42E[8A05]              	LES	BP,[THISDPB]
 31817 00005597 F8                      	CLC
 31818 00005598 C3                      	retn
 31819                                  
 31820                                  ;Break	<Fat_Operation - miscellaneous fat stuff>
 31821                                  ;----------------------------------------------------------------------------
 31822                                  ;
 31823                                  ; Procedure Name : FAT_operation
 31824                                  ;
 31825                                  ;----------------------------------------------------------------------------
 31826                                  
 31827                                  	; 03/01/2024
 31828                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31829                                  
 31830                                  FAT_operation:
 31831                                  	; 31/07/2018 - Retro DOS v3.0
 31832                                  FATERR:
 31833                                  	;mov	word [es:bp+1Eh],-1
 31834                                  	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
 31835 00005599 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 
 31836                                  					; Err in FAT must force recomp of freespace
 31837                                  	;and	di,0FFh
 31838 0000559F 81E7FF00                	AND	DI,STECODE		; Put error code in DI
 31839                                  	;mov	byte [ALLOWED],18h
 31840 000055A3 C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 31841                                  	;mov	ah,1Ah
 31842 000055A8 B41A                    	MOV	AH,2+Allowed_FAIL+Allowed_RETRY ; While trying to read FAT
 31843 000055AA A0[7605]                	MOV	AL,[THISDRV]		; Tell which drive
 31844 000055AD E819FC                  	call	FATAL1
 31845 000055B0 C42E[8A05]              	LES	BP,[THISDPB]
 31846 000055B4 3C03                    	CMP	AL,3
 31847 000055B6 7502                    	JNZ	short FAT_GOT_DPB	; User said retry
 31848 000055B8 F9                      	STC				; User said FAIL
 31849 000055B9 C3                      	retn
 31850                                  
 31851                                  FAT_GOT_DPB:
 31852                                  	;Context DS			;hkn; SS is DOSDATA
 31853 000055BA 16                      	push	ss			
 31854 000055BB 1F                      	pop	ds
 31855                                  	;mov	al,0Fh
 31856 000055BC B00F                    	MOV	AL,DMEDHL
 31857                                  	;mov	ah,[es:bp+1]
 31858 000055BE 268A6601                	MOV	AH,[ES:BP+DPB.UNIT] 
 31859 000055C2 A3[5A03]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018 
 31860 000055C5 C606[5C03]01            	MOV	BYTE [DEVCALL_REQFUNC],DEVMDCH
 31861 000055CA C706[5D03]0000          	MOV	word [DEVCALL_REQSTAT],0
 31862                                  	;;mov	al,[es:bp+16h]
 31863                                  	;mov	al,[es:bp+17h] ; MSDOS 6.0
 31864 000055D0 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 31865 000055D4 A2[6703]                	MOV	[CALLMED],AL
 31866 000055D7 06                      	PUSH	ES
 31867 000055D8 1E                      	PUSH	DS
 31868                                  
 31869                                  ;hkn; DEVCALL is in DOSDATA
 31870 000055D9 BB[5A03]                	MOV	BX,DEVCALL
 31871                                  	;;lds	si,[es:bp+12h]
 31872                                  	;lds	si,[es:bp+13h] ; MSDOS 6.0
 31873 000055DC 26C57613                	LDS	SI,[ES:BP+DPB.DRIVER_ADDR] ; DS:SI Points to device header
 31874 000055E0 07                      	POP	ES			; ES:BX Points to call header
 31875 000055E1 E825EF                  	call	DEVIOCALL2
 31876                                  	;Context DS		 	;hkn; SS is DOSDATA
 31877 000055E4 16                      	push	ss
 31878 000055E5 1F                      	pop	ds
 31879 000055E6 07                      	POP	ES			; Restore ES:BP
 31880 000055E7 8B3E[5D03]              	MOV	DI,[DEVCALL_REQSTAT]
 31881                                  	;test	di,8000h
 31882                                  	;jnz	short FATERR
 31883 000055EB 09FF                    	or	di,di
 31884 000055ED 78AA                    	js	short FATERR		; have error
 31885 000055EF 30E4                    	XOR	AH,AH
 31886                                  	;xchg	ah,[es:bp+17h] ; MSDOS 3.3
 31887                                  	;xchg	ah,[es:bp+18h] ; MSDOS 6.0
 31888 000055F1 26866618                	XCHG	AH,[ES:BP+DPB.FIRST_ACCESS] ; Reset dpb_first_access
 31889 000055F5 A0[7605]                	MOV	AL,[THISDRV]		; Use physical unit number
 31890                                  ; See if we had changed volume id by creating one on the diskette
 31891 000055F8 3806[A10A]              	cmp	[VOLCHNG_FLAG],AL
 31892 000055FC 7508                    	jnz	short CHECK_BYT
 31893 000055FE C606[A10A]FF            	mov	byte [VOLCHNG_FLAG],-1
 31894 00005603 E9A300                  	jmp	GOGETBPB		; Need to get device driver to read in
 31895                                  					; new volume label.
 31896                                  CHECK_BYT:
 31897 00005606 0A26[6803]              	OR	AH,[CALLRBYT]
 31898                                  	;JNS	short CHECK_ZR		; ns = 0 or 1
 31899                                  	;JMP	short NEWDSK
 31900                                  	; 17/12/2022
 31901 0000560A 7861                    	js	short NEWDSK
 31902                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31903                                  	;JNS	short CHECK_ZR		; ns = 0 or 1
 31904                                  	;JMP	short NEWDSK
 31905                                  
 31906                                  CHECK_ZR:
 31907 0000560C 743B                    	JZ	short CHKBUFFDIRT	; jump if I don't know
 31908                                  	; 24/09/2023
 31909                                  	; cf=0 (after 'or' instruction)
 31910                                  	;CLC
 31911 0000560E C3                      	retn				; If Media not changed (NZ)
 31912                                  
 31913                                  DISK_CHNG_ERR:
 31914 0000560F 06                      	PUSH	ES
 31915 00005610 55                      	PUSH	BP
 31916                                  	;;les	bp,[es:bp+12h]
 31917                                  	;les	bp,[es:bp+13h] ; MSDOS 6.0
 31918 00005611 26C46E13                	LES	BP,[ES:BP+DPB.DRIVER_ADDR] ; Get device pointer
 31919                                  	;;test	word [es:bp+4],800h
 31920                                  	;TEST	word [ES:BP+SYSDEV.ATT],DEVOPCL ; Did it set vol id?
 31921 00005615 26F6460508              	test	byte [es:bp+SYSDEV.ATT+1],(DEVOPCL>>8)
 31922 0000561A 5D                      	POP	BP
 31923 0000561B 07                      	POP	ES
 31924                                  	;JZ	short FAIL_OPJ2		; Nope, FAIL
 31925                                  	; 03/03/2024
 31926 0000561C 7443                    	jz	short FAIL_OP
 31927 0000561E 1E                      	PUSH	DS			; Save buffer pointer for ignore
 31928 0000561F 57                      	PUSH	DI
 31929 00005620 16                      	push	ss			;hkn; SS is DOSDATA
 31930 00005621 1F                      	pop	ds
 31931                                  	;mov	byte [ALLOWED],18h
 31932 00005622 C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 31933 00005627 06                      	PUSH	ES
 31934 00005628 C43E[6903]              	LES	DI,[CALLVIDM]		; Get volume ID pointer
 31935 0000562C 8C06[2A03]              	MOV	[EXTERRPT+2],ES
 31936 00005630 07                      	POP	ES
 31937 00005631 893E[2803]              	MOV	[EXTERRPT],DI
 31938                                  	;mov	ax,0Fh
 31939 00005635 B80F00                  	MOV	AX,error_I24_wrong_disk
 31940 00005638 C606[7505]01            	MOV	byte [READOP],1		; Write
 31941                                  	;invoke	HARDERR
 31942 0000563D E837FB                  	call	HARDERR
 31943 00005640 5F                      	POP	DI			; Get back buffer for ignore
 31944 00005641 1F                      	POP	DS
 31945 00005642 3C03                    	CMP	AL,3
 31946                                  FAIL_OPJ2:
 31947 00005644 741B                    	JZ	short FAIL_OP
 31948 00005646 E971FF                  	JMP	FAT_GOT_DPB		; Retry
 31949                                  
 31950                                  CHKBUFFDIRT:
 31951                                  	; 20/05/2019 - Retro DOS v4.0
 31952                                  
 31953                                  	; MSDOS 3.3
 31954                                  	;lds	di,[BUFFHEAD]
 31955                                  
 31956                                  	; MSDOS 6.0
 31957                                  	;cmp	word [ss:DirtyBufferCount],0	; any dirty buffers ? ;hkn;
 31958                                  	; 03/03/2024
 31959                                  	; ds=ss
 31960                                  	;;;
 31961 00005649 833E[7100]00            	cmp	word [DirtyBufferCount],0 ; (Win ME IO.SYS - BIOSCODE:0C7A7h)
 31962                                  	;;;
 31963 0000564E 741D                    	je	short NEWDSK			; no, skip the check
 31964 00005650 E8EC00                  	call	GETCURHEAD			; get pointer to first buffer
 31965                                  nbuffer:
 31966                                  	;cmp	al,[di+4]
 31967 00005653 384504                  	cmp	[di+BUFFINFO.buf_ID],al	; Unit OK ?
 31968 00005656 750C                    	jne	short lfnxt			; no, go for next buffer
 31969                                  	;test   byte [di+5],40h
 31970 00005658 F6450540                	TEST	byte [di+BUFFINFO.buf_flags],buf_dirty	; is the buffer dirty ?
 31971 0000565C 7406                    	jz	short lfnxt			; no, go for next buffer
 31972                                  
 31973                                  FAIL_OP2:	; 03/03/2024
 31974                                  	;Context DS
 31975 0000565E 16                      	push	ss
 31976 0000565F 1F                      	pop	ds
 31977                                  	; 24/09/2023
 31978                                  	; cf=0 (after 'test' instruction)
 31979                                  	;clc
 31980 00005660 C3                      	retn
 31981                                  
 31982                                  FAIL_OP:					; This label & code is here
 31983                                  	;Context DS				;  for reachability
 31984                                  	;push	ss
 31985                                  	;pop	ds
 31986 00005661 F9                      	STC
 31987                                  	; 03/03/2024
 31988                                  	;retn
 31989 00005662 EBFA                    	jmp	short FAIL_OP2 ; cf=1
 31990                                  
 31991                                  lfnxt:
 31992                                  	; 15/08/2018 - Retro DOS v3.0
 31993                                  	; MSDOS 3.3
 31994                                  	;lds	di,[di]
 31995                                  
 31996                                  	; 20/05/2019 - Retro DOS v4.0
 31997 00005664 8B3D                    	mov	di,[di]
 31998                                  	;;mov	di,[di+BUFFINFO.buf_next]	; get next buffer
 31999                                  	
 32000                                  	; MSDOS 3.3
 32001                                  	;cmp	di,-1
 32002                                  	;jne	short nbuffer
 32003                                  	
 32004                                  	; MSDOS 6.0
 32005 00005666 36393E[BB0E]            	cmp	[ss:FIRST_BUFF_ADDR],di		; is this where we started ?;hkn;
 32006 0000566B 75E6                    	jne	short nbuffer			; no, check this guy also
 32007                                  
 32008                                  ; If no dirty buffers, assume Media changed
 32009                                  NEWDSK:
 32010                                  	;;mov	word [es:bp+1Eh],0FFFFh  ; MSDOS 3.3
 32011                                  	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
 32012 0000566D 26C7461FFFFF            	mov	word [ES:BP+DPB.FREE_CNT],-1	; Media changed, must
 32013                                  						;  recompute
 32014                                  	; MSDOS 3.3
 32015                                  	;call	SETVISIT
 32016                                  	; MSDOS 6.0
 32017 00005673 E8C900                  	call	 GETCURHEAD
 32018                                  nxbuffer:
 32019                                  	; MSDOS 3.3
 32020                                  	;or 	byte [di+5],20h
 32021                                  	; MSDOS 3.3 & MSDOS 6.0
 32022                                  	;cmp	[di+4],al
 32023 00005676 384504                  	cmp	[DI+BUFFINFO.buf_ID],al		; This drive ?
 32024 00005679 7510                    	jne	short lfnxt2
 32025                                  	;test	byte [di+5],40h
 32026 0000567B F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 32027 0000567F 758E                    	jnz	short DISK_CHNG_ERR
 32028                                  	;mov	word [di+4],20FFh
 32029 00005681 C74504FF20              	mov	word [DI+BUFFINFO.buf_ID],(buf_visit*256)+0FFh ; free up
 32030 00005686 E8C800                  	call	SCANPLACE
 32031                                  	; MSDOS 6.0
 32032 00005689 EB02                    	jmp	short skpbuff
 32033                                  lfnxt2:
 32034 0000568B 8B3D                    	mov	di,[di]
 32035                                  	;mov	di,[di+BUFFINFO.buf_next]
 32036                                  skpbuff:
 32037                                  	; MSDOS 6.0
 32038 0000568D 363B3E[BB0E]            	cmp	di,[ss:FIRST_BUFF_ADDR]					;hkn;
 32039 00005692 75E2                    	jne	short nxbuffer
 32040                                  
 32041 00005694 36833E[7700]00          	CMP	word [ss:SC_CACHE_COUNT],0 ;LB.  look ahead buffers ?	;AN001;
 32042 0000569A 740D                    	JZ	short GOGETBPB		;LB.  no			;AN001;
 32043 0000569C 363A06[B00D]            	CMP	AL,[ss:CurSC_DRIVE]	;LB.  same as changed drive	;AN001;
 32044 000056A1 7506                    	JNZ	short GOGETBPB		;LB.  no			;AN001;
 32045 000056A3 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ;LB.  invalidate look ahead buffers ;AN000;
 32046                                  ;lfnxt2:
 32047                                  	; MSDOS 3.3
 32048                                  	;call	SKIPVISIT
 32049                                  	;jnz	short nxbuffer
 32050                                  GOGETBPB:
 32051                                  	; MSDOS 3.3 & MSDOS 6.0
 32052                                  	;;lds	di,[es:bp+12h]
 32053                                  	;lds	di,[es:bp+13h] ; MSDOS 6.0	
 32054 000056A9 26C57E13                	LDS	DI,[ES:BP+DPB.DRIVER_ADDR]
 32055                                  	; 20/05/2019
 32056                                  	;test	word [di+4],2000h
 32057                                  	;TEST	word [DI+SYSDEV.ATT],ISFATBYDEV
 32058 000056AD F6450520                	TEST	byte [DI+SYSDEV.ATT+1],(ISFATBYDEV>>8)
 32059 000056B1 7510                    	JNZ	short GETFREEBUF
 32060                                  	;context DS	    		;hkn; SS is DOSDATA
 32061 000056B3 16                      	push	ss
 32062 000056B4 1F                      	pop	ds
 32063 000056B5 BB0200                  	MOV	BX,2
 32064 000056B8 E8F2FC                  	CALL	UNPACK			; Read the first FAT sector into CURBUF
 32065                                  FAIL_OPJ:
 32066                                  	;JC	short FAIL_OP
 32067                                  	; 03/03/2024
 32068 000056BB 72A1                    	jc	short FAIL_OP2 ; cf=1
 32069 000056BD C53E[E205]              	LDS	DI,[CURBUF]
 32070 000056C1 EB13                    	JMP	SHORT GOTGETBUF
 32071                                  
 32072                                  GETFREEBUF:
 32073 000056C3 06                      	PUSH	ES			; Get a free buffer for BIOS to use
 32074 000056C4 55                      	PUSH	BP
 32075                                  	; MSDOS 3.3
 32076                                  	;LDS	DI,[SS:BUFFHEAD] ; 15/08/2018
 32077                                  	; MSDOS 6.0
 32078 000056C5 31D2                    	XOR	DX,DX			;LB.  fake to get 1st	  ;AN000;
 32079                                  ;hkn; SS override
 32080 000056C7 368916[0706]            	MOV	[SS:HIGH_SECTOR],DX ; 0	;LB.  buffer addr	  ;AN000;
 32081 000056CC E87000                  	call	GETCURHEAD		;LB.			  ;AN000;
 32082                                  	; MSDOS 3.3 & MSDOS 6.0
 32083 000056CF E84B02                  	call	BUFWRITE
 32084 000056D2 5D                      	POP	BP
 32085 000056D3 07                      	POP	ES
 32086                                  	;;JC	short FAIL_OPJ
 32087                                  	;jc	short FAIL_OP
 32088                                  	; 03/03/2024
 32089 000056D4 7288                    	jc	short FAIL_OP2 ; cf=1
 32090                                  
 32091                                  GOTGETBUF:
 32092                                  	;;add	di,16
 32093                                  	;add	di,20 ; MSDOS 6.0
 32094 000056D6 83C714                  	ADD	DI,BUFINSIZ
 32095                                  
 32096                                  ;hkn; SS override
 32097 000056D9 368C1E[6A03]            	MOV	[SS:CALLXAD+2],DS
 32098                                  	;Context DS			;hkn; SS is DOSDATA
 32099 000056DE 16                      	push	ss
 32100 000056DF 1F                      	pop	ds
 32101 000056E0 893E[6803]              	MOV	[CALLXAD],DI
 32102                                  	;mov	al,16h
 32103 000056E4 B016                    	MOV	AL,DBPBHL
 32104                                  	;mov	ah,[es:bp+1]
 32105 000056E6 268A6601                	MOV	AH,[ES:BP+DPB.UNIT]
 32106 000056EA A3[5A03]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018
 32107 000056ED C606[5C03]02            	MOV	BYTE [DEVCALL_REQFUNC],DEVBPB
 32108 000056F2 C706[5D03]0000          	MOV	word [DEVCALL_REQSTAT],0
 32109                                  	;;mov	al,[es:bp+16h]
 32110                                  	;mov	al,[es:bp+17h]
 32111 000056F8 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 32112 000056FC A2[6703]                	MOV	[CALLMED],AL
 32113 000056FF 06                      	PUSH	ES ; **
 32114 00005700 1E                      	PUSH	DS ; *
 32115                                  	;;
 32116                                  ; 03/01/2024
 32117                                  %if 0
 32118                                  	;;push	word [es:bp+14h]
 32119                                  	;push	word [es:bp+15h] ; MSDOS 6.0
 32120                                  	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR+2]
 32121                                  	;;push	word [es:bp+12h]
 32122                                  	;push	word [es:bp+13h] ; MSDOS 6.0
 32123                                  	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR]
 32124                                  
 32125                                  ;hkn; DEVCALL is in DOSDATA
 32126                                  	MOV	BX,DEVCALL
 32127                                  	POP	SI
 32128                                  	POP	DS			; DS:SI Points to device header
 32129                                  %endif
 32130                                  	; 03/01/2024
 32131 00005701 BB[5A03]                	mov	bx,DEVCALL
 32132                                  	;lds	si,[es:bp+13h]
 32133 00005704 26C57613                	lds	si,[es:bp+DPB.DRIVER_ADDR]
 32134                                  					; DS:SI Points to device header
 32135                                  	;;
 32136 00005708 07                      	POP	ES ; *			; ES:BX Points to call header
 32137                                  	;invoke	DEVIOCALL2
 32138 00005709 E8FDED                  	call	DEVIOCALL2
 32139 0000570C 07                      	POP	ES ; **			; Restore ES:BP
 32140                                  	;Context DS
 32141 0000570D 16                      	push	ss		 	;hkn; SS is DOSDATA
 32142 0000570E 1F                      	pop	ds
 32143 0000570F 8B3E[5D03]              	MOV	DI,[DEVCALL_REQSTAT]
 32144                                  	; MSDOS 3.3
 32145                                  	;test	di,8000h
 32146                                  	;jnz	short FATERRJ
 32147                                  	; MSDOS 6.0
 32148 00005713 09FF                    	or	di,di
 32149 00005715 7825                    	js	short FATERRJ 		; have error
 32150                                  
 32151                                  ; 04/03/2024
 32152                                  %if 0
 32153                                  	;;mov	al,[es:bp+16h]
 32154                                  	;mov	al,[es:bp+17h]  ; MSDOS 6.0
 32155                                  	MOV	AL,[ES:BP+DPB.MEDIA]
 32156                                  %endif
 32157                                  
 32158 00005717 C536[6C03]              	LDS	SI,[CALLBPB]
 32159                                  	;;mov	word [es:bp+1Ch],0
 32160                                  	;mov	word [es:bp+1Dh],0 ; MSDOS 6.0
 32161 0000571B 26C7461D0000            	MOV	word [ES:BP+DPB.NEXT_FREE],0 ; recycle scanning pointer
 32162                                  	;invoke	$SETDPB
 32163 00005721 E88AB8                  	call	_$SETDPB
 32164                                  
 32165                                  ;hkn; SS override
 32166 00005724 36C53E[6803]            	LDS	DI,[SS:CALLXAD]		; Get back buffer pointer
 32167                                  	;mov	al,[es:bp+8]
 32168 00005729 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]
 32169                                  
 32170                                  	; MSDOS 3.3
 32171                                  	;;mov	ah,[es:bp+0Fh]
 32172                                  	;MOV	AH,[ES:BP+DPB.FAT_SIZE]
 32173                                  	;;mov	[DI-8],ax
 32174                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AX
 32175                                  
 32176                                  	; MSDOS 6.0
 32177                                  	;mov	[di-0Ah],al
 32178 0000572D 8845F6                  	MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AL 
 32179                                  						;>32mb		  ;AN000;
 32180                                  	;mov	ax,[es:bp+0Fh]
 32181 00005730 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE]		;>32mb
 32182                                  	;mov	[di-9h],ax			  ;AC000;
 32183 00005734 8945F7                  	MOV	[DI+BUFFINFO.buf_wrtcntinc-BUFINSIZ],AX 
 32184                                  					;>32mb Correct buffer info ;AC000;
 32185                                  	;Context DS			;hkn; SS is DOSDATA
 32186 00005737 16                      	push	ss
 32187 00005738 1F                      	pop	ds
 32188 00005739 30C0                    	XOR	AL,AL			;Media changed (Z), Carry clear
 32189 0000573B C3                      	retn
 32190                                  
 32191                                  FATERRJ: 
 32192 0000573C E95AFE                  	JMP	FATERR
 32193                                  
 32194                                  ;============================================================================
 32195                                  ; STDBUF.ASM
 32196                                  ;============================================================================
 32197                                  ; Retro DOS v2.0 - 12/03/2018
 32198                                  
 32199                                  ;
 32200                                  ; Standard buffer management for MSDOS
 32201                                  ;
 32202                                  
 32203                                  ;.xlist
 32204                                  ;.xcref
 32205                                  ;INCLUDE STDSW.ASM
 32206                                  ;.cref
 32207                                  ;.list
 32208                                  
 32209                                  ;TITLE	STDBUF - MSDOS buffer management
 32210                                  ;NAME	STDBUF
 32211                                  
 32212                                  ;INCLUDE BUF.ASM
 32213                                  
 32214                                  ;============================================================================
 32215                                  ; BUF.ASM
 32216                                  ;============================================================================
 32217                                  ; 31/07/2018 - Retro DOS v3.0
 32218                                  ; Retro DOS v2.0 - 12/03/2018
 32219                                  ;
 32220                                  ; buffer management for MSDOS
 32221                                  ;
 32222                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 32223                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 32224                                  ;
 32225                                  ;SUBTTL SETVISIT,SKIPVISIT -- MANAGE BUFFER SCANS
 32226                                  ;
 32227                                  ;SETVISIT:
 32228                                  ;	; 31/07/2018 - Retro DOS v3.0
 32229                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CAFh
 32230                                  ;; Inputs:
 32231                                  ;;      None
 32232                                  ;; Function:
 32233                                  ;;      Set up a scan of I/O buffers
 32234                                  ;; Outputs:
 32235                                  ;;      All visit flags = 0
 32236                                  ;;              NOTE: This pre-scan is needed because a hard disk error
 32237                                  ;;                    may cause a scan to stop in the middle leaving some
 32238                                  ;;                    visit flags set, and some not set.
 32239                                  ;;      DS:DI Points to [BUFFHEAD]
 32240                                  ;; No other registers altered
 32241                                  ;
 32242                                  ;       LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 32243                                  ;	PUSH    AX
 32244                                  ;       ;;XOR	AX,AX	  ;; MSDOS 2.11
 32245                                  ;	;mov	al,0DFh
 32246                                  ;	mov	al,~buf_visit
 32247                                  ;SETLOOP:
 32248                                  ;       ;;MOV	[DI+7],AL ;; MSDOS 2.11
 32249                                  ;	;and	[DI+5],al
 32250                                  ;	AND	[DI+BUFFINFO.buf_flags],AL
 32251                                  ;       LDS     DI,[DI]
 32252                                  ;       CMP     DI,-1
 32253                                  ;       JNZ     SHORT SETLOOP
 32254                                  ;       POP     AX ; 09/09/2018
 32255                                  ;	LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 32256                                  ;SVISIT_RETN:
 32257                                  ;       RETN
 32258                                  ;
 32259                                  ;SKIPVISIT:
 32260                                  ;	; 31/07/2018 - Retro DOS v3.0
 32261                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CC8h
 32262                                  ;
 32263                                  ;; Inputs:
 32264                                  ;;      DS:DI Points to a buffer
 32265                                  ;; Function:
 32266                                  ;;      Skip visited buffers
 32267                                  ;; Outputs:
 32268                                  ;;      DS:DI Points to next unvisited buffer
 32269                                  ;;      Zero is set if skip to LAST buffer
 32270                                  ;; No other registers altered
 32271                                  ;
 32272                                  ;       CMP     DI,-1
 32273                                  ;       ;retz
 32274                                  ;       JZ	SHORT SVISIT_RETN
 32275                                  ;
 32276                                  ;	;;CMP	BYTE [DI+7],1 ;; MSDOS 2.11
 32277                                  ;       ;;;retnz
 32278                                  ;       ;;JNZ	SHORT SVISIT_RETN
 32279                                  ;
 32280                                  ;	;test	byte [di+5],20h
 32281                                  ;	TEST	byte [DI+BUFFINFO.buf_flags],buf_visit	
 32282                                  ;	JNZ	short SKIPLOOP
 32283                                  ;	
 32284                                  ;	push	ax
 32285                                  ;	or	al,1
 32286                                  ;	pop	ax
 32287                                  ;	retn	
 32288                                  ;
 32289                                  ;SKIPLOOP:
 32290                                  ;	LDS     DI,[DI]
 32291                                  ;       JMP     SHORT SKIPVISIT
 32292                                  
 32293                                  ;============================================================================
 32294                                  ; BUF.ASM, MSDOS 6.0, 1991
 32295                                  ;============================================================================
 32296                                  ; 31/07/2018 - Retro DOS v3.0
 32297                                  ; 04/05/2019 - Retro DOS v4.0
 32298                                  
 32299                                  ;	TITLE	BUF - MSDOS buffer management
 32300                                  ;	NAME	BUF
 32301                                  
 32302                                  ;**	BUF.ASM - Low level routines for buffer cache management
 32303                                  ;
 32304                                  ;	GETCURHEAD
 32305                                  ;	ScanPlace
 32306                                  ;	PLACEBUF
 32307                                  ;	PLACEHEAD
 32308                                  ;	PointComp
 32309                                  ;	GETBUFFR
 32310                                  ;	GETBUFFRB
 32311                                  ;	FlushBuf
 32312                                  ;	BufWrite
 32313                                  ;	SET_RQ_SC_PARMS
 32314                                  ;
 32315                                  ;	Revision history:
 32316                                  ;
 32317                                  ;		AN000  version 4.00  Jan. 1988
 32318                                  ;		A004   PTM 3765 -- Disk reset failed
 32319                                  ;		M039 DB 10/17/90 - Disk write optimization
 32320                                  ;		I001   5.0 PTR 722211 - Preserve CY when in buffer in HMA
 32321                                  
 32322                                  ;Break	<GETCURHEAD -- Get current buffer header>
 32323                                  ;----------------------------------------------------------------------------
 32324                                  ; Procedure Name : GetCurHead
 32325                                  ; Inputs:
 32326                                  ;	 No Inputs
 32327                                  ; Function:
 32328                                  ;	Returns the pointer to the first buffer in Queue
 32329                                  ;	and updates FIRST_BUFF_ADDR
 32330                                  ;       and invalidates LASTBUFFER (recency pointer)
 32331                                  ; Outputs:
 32332                                  ;	DS:DI = pointer to the first buffer in Queue
 32333                                  ;	FIRST_BUFF_ADDR = offset ( DI ) of First buffer in Queue
 32334                                  ;       LASTBUFFER = -1
 32335                                  ; No other registers altered
 32336                                  ;----------------------------------------------------------------------------
 32337                                  
 32338                                  ; 04/05/2019 - Retro DOS v4.0
 32339                                  ; DOSCODE:98D2h (MSDOS 6.21, MSDOS.SYS)
 32340                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32341                                  ; DOSCODE:9876h (MSDOS 5.0, MSDOS.SYS)
 32342                                  
 32343                                  GETCURHEAD:
 32344 0000573F 36C53E[6D00]            	lds	di,[ss:BufferQueue]	; Pointer to the first buffer
 32345 00005744 36C706[1E00]FFFF        	mov	word [ss:LastBuffer],-1	; invalidate last buffer
 32346 0000574B 36893E[BB0E]            	mov	[ss:FIRST_BUFF_ADDR],di	;save first buffer addr
 32347 00005750 C3                      	retn
 32348                                  
 32349                                  ;Break	<SCANPLACE, PLACEBUF -- PUT A BUFFER BACK IN THE POOL>
 32350                                  ;----------------------------------------------------------------------------
 32351                                  ; Procedure Name : ScanPlace
 32352                                  ; Inputs:
 32353                                  ;	Same as PLACEBUF
 32354                                  ; Function:
 32355                                  ;	Save scan location and call PLACEBUF
 32356                                  ; Outputs:
 32357                                  ;	DS:DI Points to saved scan location
 32358                                  ; All registers, except DS:DI, preserved.
 32359                                  ;----------------------------------------------------------------------------
 32360                                  ;M039: Rewritten to preserve registers.
 32361                                  
 32362                                  ;SCANPLACE:
 32363                                  ;	; 31/07/2018 - Retro DOS v3.0
 32364                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 32365                                  ;	push	es
 32366                                  ;	les	si,[di]
 32367                                  ;	;les	si,[DI+BUFFINFO.buf_link]
 32368                                  ;	call	PLACEBUF
 32369                                  ;	push	es
 32370                                  ;	pop	ds
 32371                                  ;	mov	di,si
 32372                                  ;	pop	es
 32373                                  ;scanplace_retn:
 32374                                  ;	retn	
 32375                                  	
 32376                                  	; MSDOS 6.0
 32377                                  SCANPLACE:
 32378 00005751 FF35                    	push	word [di]
 32379                                  	;push	word [di+BUFFINFO.buf_next] ;Save scan location
 32380 00005753 E80200                  	call	PLACEBUF
 32381 00005756 5F                      	pop	di
 32382 00005757 C3                      	retn
 32383                                  
 32384                                  ;----------------------------------------------------------------------------
 32385                                  ; Procedure Name : PlaceBuf
 32386                                  ; Input:
 32387                                  ;	DS:DI points to buffer (DS->BUFFINFO array, DI=offset in array)
 32388                                  ; Function:
 32389                                  ;	Remove buffer from queue and re-insert it in proper place.
 32390                                  ; NO registers altered
 32391                                  ;----------------------------------------------------------------------------
 32392                                  
 32393                                  ;procedure PLACEBUF,NEAR
 32394                                  
 32395                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32396                                  	; 20/05/2019 - Retro DOS v4.0
 32397                                  PLACEBUF:
 32398                                  	; 31/07/2018 - Retro DOS v3.0
 32399                                  
 32400                                  	; MSDOS 6.0
 32401 00005758 50                      	push	AX			;Save only regs we modify	;AN000;
 32402 00005759 53                      	push	BX							;AN000;
 32403                                  	; 23/09/2023
 32404                                  	;push	SI							;AN000;
 32405                                  	
 32406 0000575A 8B05                    	mov	ax,[di]
 32407                                  	;mov	ax,[di+BUFFINFO.buf_next]
 32408 0000575C 368B1E[6D00]            	mov	bx,[ss:BufferQueue]	; bx = offset of head of list;smr;SS Override
 32409                                  	
 32410 00005761 39D8                    	cmp	ax,bx				;Buf = last?		;AN000;
 32411 00005763 7422                    	je	short nret			;Yes, special case	;AN000;
 32412 00005765 39DF                    	cmp	di,bx				;Buf = first?		;AN000;
 32413 00005767 7506                    	jne	short not_first 		;Yes, special case	;AN000;
 32414 00005769 36A3[6D00]              	mov	[ss:BufferQueue],ax		;smr;SS Override
 32415 0000576D EB18                    	jmp	short nret 			;Continue with repositioning;AN000;
 32416                                  not_first:
 32417                                  	; 23/09/2023
 32418 0000576F 56                      	push	si
 32419                                  	;mov	si,[di+2]
 32420 00005770 8B7502                  	mov	SI,[DI+BUFFINFO.buf_prev]	;No, SI = prior Buf	;AN000;
 32421 00005773 8904                    	mov	[si],ax
 32422                                  	;mov	[SI+BUFFINFO.buf_next],AX	; ax has di->buf_next	;AN000;
 32423 00005775 96                      	xchg	si,ax
 32424                                  	;mov	[si+2],ax
 32425 00005776 894402                  	mov	[SI+BUFFINFO.buf_prev],AX	;			;AN000;
 32426                                  	
 32427 00005779 8B7702                  	mov	SI,[BX+BUFFINFO.buf_prev]	;SI-> last buffer	;AN000;
 32428 0000577C 893C                    	mov	[si],di
 32429                                  	;mov	[SI+BUFFINFO.buf_next],DI	;Add Buf to end of list ;AN000;
 32430 0000577E 897F02                  	mov	[BX+BUFFINFO.buf_prev],DI				;AN000;
 32431 00005781 897502                  	mov	[DI+BUFFINFO.buf_prev],SI	;Update link in Buf too	;AN000;
 32432 00005784 891D                    	mov	[di],bx
 32433                                  	;mov	[DI+BUFFINFO.buf_next],BX				;AN000;
 32434                                  	; 23/09/2023
 32435 00005786 5E                      	pop	si
 32436                                  nret:	
 32437                                  	; 23/09/2023							;AN000;
 32438                                  	;pop	SI							;AN000;
 32439 00005787 5B                      	pop	BX							;AN000;
 32440 00005788 58                      	pop	AX							;AN000;
 32441                                  									;AN000;
 32442                                  	;cmp	byte [di+4],0FFh
 32443 00005789 807D04FF                	cmp	byte [di+BUFFINFO.buf_ID],-1	; Buffer FREE?		;AN000;
 32444 0000578D 7505                            jne	short pbx			; M039: -no, jump.
 32445 0000578F 36893E[6D00]            	mov	[ss:BufferQueue],di		; M039: -yes, make it LRU.
 32446                                  pbx:	
 32447 00005794 C3                      	retn								;AN000;
 32448                                  
 32449                                  	; 31/07/2018 - Retro DOS v3.0
 32450                                  
 32451                                  	; MSDOS 3.3
 32452                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 32453                                  
 32454                                  ;PLACEBUF:
 32455                                  ;	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 32456                                  ;	
 32457                                  ;       CALL	save_world
 32458                                  ;       LES     CX,[DI]
 32459                                  ;       CMP     CX,-1           	; Buf is LAST?
 32460                                  ;       JZ      SHORT NRET		; Buffer already last
 32461                                  ;       MOV     BP,ES           	; Pointsave = Buf.nextbuf
 32462                                  ;       PUSH    DS
 32463                                  ;       POP     ES              	; Buf is ES:DI
 32464                                  ;	; 15/03/2018
 32465                                  ;       LDS     SI,[SS:BUFFHEAD] 	; Curbuf = HEAD
 32466                                  ;       CALL    POINTCOMP       	; Buf == HEAD?
 32467                                  ;       JNZ     SHORT BUFLOOP
 32468                                  ;       MOV     [SS:BUFFHEAD],CX
 32469                                  ;       MOV     [SS:BUFFHEAD+2],BP	; HEAD = Pointsave
 32470                                  ;       JMP     SHORT LOOKEND
 32471                                  ;BUFLOOP:
 32472                                  ;	; 31/07/2018
 32473                                  ;	mov	ax,ds
 32474                                  ;	mov	bx,si
 32475                                  ;	;lds	si,[SI+BUFFINFO.buf_link]
 32476                                  ;       LDS     SI,[SI]
 32477                                  ;       CALL    POINTCOMP
 32478                                  ;       jnz	short BUFLOOP
 32479                                  ;	;
 32480                                  ;	mov	ds,ax
 32481                                  ;	mov	si,bx
 32482                                  ;	mov	[SI],cx
 32483                                  ;	;mov	[SI+BUFFINFO.buf_link],cx   ; If Curbuf.nextbuf == buf
 32484                                  ;	mov	[SI+2],bp
 32485                                  ;	;mov	[BX+BUFFINFO.buf_link+2],bp ; Curbuf.nextbuf = Pointsave
 32486                                  ;LOOKEND:
 32487                                  ;	mov	ax,ds
 32488                                  ;	mov	bx,si
 32489                                  ;       LDS     SI,[SI]
 32490                                  ;       CMP     SI,-1
 32491                                  ;       jnz     short LOOKEND
 32492                                  ;GOTHEEND:
 32493                                  ;       mov	ds,ax
 32494                                  ;	mov	[BX],di
 32495                                  ;	MOV     [BX+2],ES 		; Curbuf.nextbuf = Buf
 32496                                  ;       MOV     WORD [ES:DI],-1
 32497                                  ;	;mov	word [ES:DI+BUFFINFO.buf_link],-1
 32498                                  ;       MOV     WORD [ES:DI+2],-1 	; Buf is LAST
 32499                                  ;	;mov	word [ES:DI+BUFFINFO.buf_link+2],-1
 32500                                  ;NRET:
 32501                                  ;       CALL	restore_world
 32502                                  ;	
 32503                                  ;	;cmp	byte [di+4],-1
 32504                                  ;	cmp	byte [DI+BUFFINFO.buf_ID],-1  ; Free buffer ?
 32505                                  ;	jnz     short scanplace_retn
 32506                                  ;	call    PLACEHEAD
 32507                                  ;	retn
 32508                                  
 32509                                  ;EndProc PLACEBUF
 32510                                  
 32511                                  ;M039 - Removed PLACEHEAD.
 32512                                  ;----------------------------------------------------------------------------
 32513                                  ; places buffer at head
 32514                                  ;  NOTE:::::: ASSUMES THAT BUFFER IS CURRENTLY THE LAST
 32515                                  ;	ONE IN THE LIST!!!!!!!
 32516                                  ; BUGBUG ---- this routine can be removed because it has only
 32517                                  ; BUGBUG ---- one instruction. This routine is called from
 32518                                  ; BUGBUG ---- 3 places. ( Size = 3*3+6 = 15 bytes )
 32519                                  ; BUGBUG ---- if coded in line = 3 * 5 = 15 bytes
 32520                                  ; BUGBUG ---- But kept as it is for modularity
 32521                                  ;----------------------------------------------------------------------------
 32522                                  ;procedure   PLACEHEAD,NEAR
 32523                                  ;	mov	word ptr [BufferQueue], di
 32524                                  ;	ret
 32525                                  ;EndProc PLACEHEAD
 32526                                  ;M039
 32527                                  
 32528                                  ;----------------------------------------------------------------------------
 32529                                  ; Procedure Name : PLACEHEAD
 32530                                  ;
 32531                                  ; SAME AS PLACEBUF except places buffer at head
 32532                                  ;----------------------------------------------------------------------------
 32533                                  
 32534                                  	; MSDOS 3.3 (Retro DOS v3.0)
 32535                                  	; 05/09/2018
 32536                                  	; MSDOS 2.11 (Retro DOS v2.0)
 32537                                  ;PLACEHEAD:
 32538                                  ;	; 31/07/2018 - Retro DOS v3.0
 32539                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D4Ah
 32540                                  ;
 32541                                  ;       CALL	save_world
 32542                                  ;       PUSH	DS
 32543                                  ;       POP	ES
 32544                                  ;	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 32545                                  ;       LDS     SI,[SS:BUFFHEAD]
 32546                                  ;	; 31/07/2018 - Retro DOS v3.0 (MSDOS 3.3)
 32547                                  ;	CALL    POINTCOMP
 32548                                  ;       JZ      SHORT GOTHEEND2
 32549                                  ;	MOV	[ES:DI],SI
 32550                                  ;	;mov	[ES:DI+BUFFINFO.buf_link],si
 32551                                  ;       MOV	[ES:DI+2],DS
 32552                                  ;	;mov	[ES:DI+BUFFINFO.buf_link+2],ds
 32553                                  ;       MOV	[SS:BUFFHEAD],DI
 32554                                  ;       MOV	[SS:BUFFHEAD+2],ES
 32555                                  ;LOOKEND2:
 32556                                  ;       mov	ax,ds
 32557                                  ;	mov	bx,si
 32558                                  ;	;lds	si,[SI+BUFFINFO.buf_link]
 32559                                  ;       LDS     SI,[SI]
 32560                                  ;       CALL    POINTCOMP
 32561                                  ;       JNZ	SHORT LOOKEND2 ; 05/09/2018
 32562                                  ;       mov	ds,ax
 32563                                  ;	mov	word [bx],-1
 32564                                  ;	;mov	word [BX+BUFFINFO.buf_link],-1
 32565                                  ;	mov	word [bx+2],-1
 32566                                  ;	;mov	word [BX+BUFFINFO.buf_link+2],-1
 32567                                  ;GOTHEEND2:
 32568                                  ;      	call	restore_world
 32569                                  ;placehead_retn:
 32570                                  ;	retn
 32571                                  
 32572                                  ; 20/05/2019 - Retro DOS v4.0
 32573                                  ; DOSCODE:9928h (MSDOS 6.21, MSDOS.SYS)
 32574                                  
 32575                                  ;Break	<POINTCOMP -- 20 BIT POINTER COMPARE>
 32576                                  ;----------------------------------------------------------------------------
 32577                                  ;
 32578                                  ; Procedure Name : PointComp
 32579                                  ; Inputs:
 32580                                  ;         DS:SI & ES:DI
 32581                                  ; Function:
 32582                                  ;          Checks for ((SI==DI) && (ES==DS))
 32583                                  ;	   Assumes that pointers are normalized for the
 32584                                  ;	   same segment
 32585                                  ;
 32586                                  ; Compare DS:SI to ES:DI (or DS:DI to ES:SI) for equality
 32587                                  ; DO NOT USE FOR < or >
 32588                                  ; No Registers altered
 32589                                  ;
 32590                                  ;----------------------------------------------------------------------------
 32591                                  
 32592                                  POINTCOMP:
 32593                                  	; 31/07/2018 - Retro DOS v3.0
 32594                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D84h
 32595 00005795 39FE                    	CMP	SI,DI
 32596 00005797 750A                    	jnz	short _ret_label	; return if nz
 32597                                  	;jnz	short placehead_retn 
 32598 00005799 51                      	PUSH	CX
 32599 0000579A 52                      	PUSH	DX
 32600 0000579B 8CD9                    	MOV	CX,DS
 32601 0000579D 8CC2                    	MOV	DX,ES
 32602 0000579F 39D1                    	CMP	CX,DX
 32603 000057A1 5A                      	POP	DX
 32604 000057A2 59                      	POP	CX
 32605                                  _ret_label:
 32606 000057A3 C3                      	retn
 32607                                  
 32608                                  ; 01/08/2018 - Retro DOS v3.0
 32609                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D93h 
 32610                                  
 32611                                  ;Break	<GETBUFFR, GETBUFFRB -- GET A SECTOR INTO A BUFFER>
 32612                                  
 32613                                  ;**	GetBuffr - Get a non-FAT Sector into a Buffer
 32614                                  ;----------------------------------------------------------------------------
 32615                                  ;	GetBuffr does normal ( non-FAT ) sector buffering
 32616                                  ;	It gets the specified local sector into one of the I/O buffers
 32617                                  ;	and shuffles the queue
 32618                                  ; 
 32619                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 32620                                  ;		       ELSE no pre-read
 32621                                  ;		(DX) = Desired physical sector number	      (LOW)
 32622                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 32623                                  ;		(ES:BP) = Pointer to drive parameters
 32624                                  ;		ALLOWED set in case of INT 24
 32625                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 32626                                  ;		'C' clear if OK
 32627                                  ;		CURBUF Points to the Buffer for the sector
 32628                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 32629                                  ;	USES	AX, BX, CX, SI, DI, Flags
 32630                                  ;----------------------------------------------------------------------------
 32631                                  
 32632                                  ;**	GetBuffrb - Get a FAT Sector into a Buffer
 32633                                  ;----------------------------------------------------------------------------
 32634                                  ;	GetBuffrb reads a sector from the FAT file system's FAT table.
 32635                                  ;	It gets the specified sector into one of the I/O buffers
 32636                                  ;	and shuffles the queue. We need a special entry point so that
 32637                                  ;	we can read the alternate FAT sector if the first read fails, also
 32638                                  ;	so we can mark the buffer as a FAT sector.
 32639                                  ; 
 32640                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 32641                                  ;		       ELSE no pre-read
 32642                                  ;		(DX) = Desired physical sector number	     (LOW)
 32643                                  ;		(SI) != 0
 32644                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 32645                                  ;		(ES:BP) = Pointer to drive parameters
 32646                                  ;		ALLOWED set in case of INT 24
 32647                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 32648                                  ;		'C' clear if OK
 32649                                  ;		CUR ddBUF Points to the Buffer for the sector
 32650                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 32651                                  ;	USES	AX, BX, CX, SI, DI, Flags
 32652                                  ;----------------------------------------------------------------------------
 32653                                  
 32654                                  	; 22/09/2023 - RetroDOS v4.2 MSDOS.SYS (optimization)
 32655                                  GETBUFFRC:
 32656 000057A4 C706[0706]0000          	mov	word [HIGH_SECTOR],0
 32657                                  GETBUFFRA:
 32658 000057AA 30C0                    	xor	al,al
 32659 000057AC BE0100                  	mov	si,1
 32660 000057AF EB09                    	jmp	short GETBUFFRB
 32661                                  
 32662                                  	; 22/09/2023
 32663                                  GETBUFFER:
 32664 000057B1 30C0                    	xor	al,al
 32665                                  GETBUFFRD:
 32666                                  	;mov	byte [ALLOWED],18h
 32667 000057B3 C606[4B03]18            	mov	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 32668                                  
 32669                                  	; 20/05/2019 - Retro DOS v4.0
 32670                                  	; DOSCODE:9937h (MSDOS 6.21, MSDOS.SYS)
 32671                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32672                                  	; DOSCODE:98DBh (MSDOS 5.0, MSDOS.SYS)
 32673                                  GETBUFFR:
 32674 000057B8 31F6                    	XOR	SI,SI
 32675                                  
 32676                                  ;	This entry point is called for FAT buffering with SI != 0
 32677                                  
 32678                                  GETBUFFRB:
 32679 000057BA A3[9405]                	MOV	[PREREAD],AX			; save pre-read flag
 32680                                  	; 15/12/2022
 32681 000057BD 268A4600                	mov	al,[ES:BP]
 32682                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32683                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 32684 000057C1 C53E[1E00]              	LDS	DI,[LastBuffer]			; Get the recency pointer
 32685                                  	; MSDOS 6.0
 32686                                  ;hkn; SS override
 32687 000057C5 368B0E[0706]            	MOV	CX,[SS:HIGH_SECTOR]		; F.C. >32mb	;AN000;
 32688                                  
 32689                                  ;	See if this is the buffer that was most recently returned.
 32690                                  ;	A big performance win if it is.
 32691                                  
 32692 000057CA 83FFFF                  	CMP	DI,-1				; Recency pointer valid?
 32693 000057CD 7412                    	je	short getb5			; No
 32694                                  	;cmp	dx,[di+6]
 32695 000057CF 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 32696 000057D2 750D                    	JNZ	short getb5			; Wrong sector
 32697                                  	
 32698                                  	; MSDOS 6.0
 32699                                  	;cmp	cx,[di+8]
 32700 000057D4 3B4D08                  	CMP	CX,[DI+BUFFINFO.buf_sector+2]	; F.C. >32mb	;AN000;
 32701 000057D7 7508                    	JNZ	short getb5			; F.C. >32mb	;AN000;
 32702                                  	
 32703                                  	;cmp	al,[di+4]
 32704 000057D9 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 32705                                  	;JZ	getb35				; Just asked for same buffer
 32706 000057DC 7503                    	jnz	short getb5
 32707                                  	;jmp	getb35
 32708                                  	; 17/12/2022
 32709                                  	; 28/07/2019
 32710 000057DE E9C700                  	jmp	getb35x
 32711                                  	; 07/12/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32712                                  	;jmp	getb35
 32713                                  
 32714                                  ;	It's not the buffer most recently returned. See if it's in the
 32715                                  ;	cache.
 32716                                  ;
 32717                                  ;	(cx:dx) = sector #
 32718                                  ;	(al) = drive #
 32719                                  ;	(si) = 0 iff non fat sector, != 0 if FAT sector read
 32720                                  ;	??? list may be incomplete ???
 32721                                  
 32722                                  getb5:	
 32723                                  	; MSDOS 3.3
 32724                                  	;lds	di,[SS:BUFFHEAD]
 32725                                  	; MSDOS 6.0
 32726 000057E1 E85BFF                  	CALL	GETCURHEAD			; get Q Head
 32727                                  getb10:	
 32728                                  	;cmp	dx,[di+6]
 32729 000057E4 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 32730 000057E7 750D                    	jne	short getb12			; wrong sector lo
 32731                                  	
 32732                                  	; MSDOS 6.0
 32733                                  	;cmp	cx,[di+8]
 32734 000057E9 3B4D08                  	CMP	CX,[DI+BUFFINFO.buf_sector+2]
 32735 000057EC 7508                    	jne	short getb12			; wrong sector hi
 32736                                  	
 32737                                  	;cmp	al,[di+4]
 32738 000057EE 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 32739                                  	;je	short getb25 ; 05/09/2018	; Found the requested sector
 32740 000057F1 7503                    	jne	short getb12
 32741 000057F3 E98C00                  	jmp	getb25
 32742                                  getb12:	
 32743                                  	; MSDOS 3.3
 32744                                  	;;mov	di,[DI]
 32745                                  	;;;mov	di,[DI+BUFFINFO.buf_link]
 32746                                  	;
 32747                                  	; 15/08/2018
 32748                                  	;lds	di,[di]
 32749                                  
 32750                                  	;cmp	di,-1 ; 0FFFFh
 32751                                  	;jne	short getb10
 32752                                  	;lds	di,[SS:BUFFHEAD]
 32753                                  
 32754                                  	; MSDOS 6.0
 32755 000057F6 8B3D                    	mov	di,[di]
 32756                                  	;mov	DI,[DI+BUFFINFO.BUF_NEXT]
 32757 000057F8 363B3E[BB0E]            	cmp	DI,[SS:FIRST_BUFF_ADDR]		; back at the front again?
 32758 000057FD 75E5                    	jne	short getb10			; no, continue looking
 32759                                  
 32760                                  ;	The requested sector is not available in the buffers. DS:DI now points
 32761                                  ;	to the first buffer in the Queue. Flush the first buffer & read in the
 32762                                  ;	new sector into it.
 32763                                  ;
 32764                                  ;	BUGBUG - what goes on here? Isn't the first guy the most recently
 32765                                  ;	used guy? Shuld be for fast lookup. If he is, we shouldn't take
 32766                                  ;	him, we should take LRU. And the above lookup shouldn't be
 32767                                  ;	down a chain, but should be hashed.
 32768                                  ;
 32769                                  ;	(DS:DI) = first buffer in the queue
 32770                                  ;	(CX:DX) = sector # we want
 32771                                  ;	(si) = 0 iff non fat sector, != 0 if FAT sector read
 32772                                  
 32773                                  	; MSDOS 3.3 & MSDOS 6.0
 32774                                  ;hkn; SS override
 32775 000057FF 51                      	PUSH	CX  ; MSDOS 6.0
 32776 00005800 56                      	push	si
 32777 00005801 52                      	push	dx
 32778 00005802 55                      	push	bp
 32779 00005803 06                      	push	es
 32780 00005804 E81601                  	CALL	BUFWRITE			; Write out the dirty buffer
 32781 00005807 07                      	pop	es
 32782 00005808 5D                      	pop	bp
 32783 00005809 5A                      	pop	dx
 32784 0000580A 5E                      	pop	si
 32785 0000580B 368F06[0706]            	POP	word [SS:HIGH_SECTOR]  ; MSDOS 6.0
 32786                                  	;jc	short getbx			; if got hard error
 32787 00005810 7303                    	jnc	short getb13
 32788 00005812 E99D00                  	jmp	getbx
 32789                                  
 32790                                  getb13:
 32791                                  	; MSDOS 6.0
 32792 00005815 E88C01                  	CALL	SET_RQ_SC_PARMS 		; set parms for secondary cache
 32793                                  
 32794                                  ;	We're ready to read in the buffer, if need be. If the caller
 32795                                  ;	wanted to just *write* the buffer then we'll skip reading it in.
 32796                                  
 32797 00005818 30E4                    	XOR	AH,AH				; initial flags
 32798                                  ;hkn; SS override
 32799                                  	;test	byte [ss:PREREAD],0FFh
 32800                                  	;jnz	short getb20
 32801 0000581A 363826[9405]            	CMP	[SS:PREREAD],ah ; 0		; am to Read in the new sector?
 32802 0000581F 7549                    	JNZ	short getb20			; no, we're done
 32803                                  	;;lea	bx,[di+16] ; MSDOS 3.3
 32804                                  	;lea	bx,[di+20] ; MSDOS 6.0
 32805 00005821 8D5D14                  	LEA	BX,[DI+BUFINSIZ] 		; (ds:bx) = data address
 32806                                  	;MOV	CX,1
 32807                                  	; 22/09/2023
 32808 00005824 29C9                    	sub	cx,cx ; 0
 32809 00005826 56                      	push	si
 32810 00005827 57                      	push	di
 32811 00005828 52                      	push	dx
 32812                                  	; MSDOS 6.0
 32813 00005829 06                      	push	es ; ***
 32814                                  
 32815                                  ; Note: As far as I can tell, all disk reads into buffers go through
 32816                                  ;	this point. -mrw 10/88
 32817                                  	
 32818                                  	;cmp	byte [ss:BuffInHMA],0	; is buffers in HMA?
 32819                                  	; 22/09/2023
 32820 0000582A 36380E[7900]            	cmp	[ss:BuffInHMA],cl ; 0
 32821 0000582F 7407                    	jz	short getb14
 32822 00005831 1E                      	push	ds ; **
 32823 00005832 53                      	push	bx ; *
 32824 00005833 36C51E[7A00]            	lds	bx,[ss:LoMemBuff]	; Then let's read it into scratch buff
 32825                                  getb14:
 32826                                  ;M039: Eliminated redundant HMA code.
 32827                                  
 32828                                  	; 22/09/2023
 32829 00005838 41                      	inc	cx ; cx = 1
 32830                                  
 32831                                  	; MSDOS 3.3 (& MSDOS 6.0)
 32832 00005839 09F6                    	OR	SI,SI			; FAT sector ?
 32833 0000583B 7407                    	JZ	short getb15		
 32834                                  
 32835 0000583D E88EDD                  	call	FATSECRD
 32836                                  	;mov	ah,2
 32837 00005840 B402                    	MOV	AH,buf_isFAT		; Set buf_flags
 32838                                  
 32839 00005842 EB05                    	JMP	SHORT getb17		; Buffer is marked free if read barfs
 32840                                  
 32841                                  getb15:
 32842 00005844 E8B3DD                  	call	DREAD			; Buffer is marked free if read barfs
 32843 00005847 B400                    	MOV	AH,0			; Set buf_flags to no type, DO NOT XOR!
 32844                                  getb17:
 32845                                  	; 17/12/2022	
 32846                                  ; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32847                                  ;%if 0
 32848                                  	; MSDOS 6.0							  ;I001
 32849 00005849 9C                      	pushf								  ;I001
 32850 0000584A 36803E[7900]00          	cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ? ;I001
 32851 00005850 7411                    	jz	short not_in_hma	; no				  ;I001
 32852                                  	;mov	cx,[es:bp+2]
 32853 00005852 268B4E02                	mov	cx,[ES:BP+DPB.SECTOR_SIZE]				  ;I001
 32854 00005856 D1E9                    	shr	cx,1							  ;I001
 32855 00005858 9D                      	popf				; Retrieve possible CY from DREAD ;I001
 32856 00005859 89DE                    	mov	si,bx							  ;I001
 32857 0000585B 5F                      	pop	di ; *							  ;I001
 32858 0000585C 07                      	pop	es ; **							  ;I001
 32859 0000585D FC                      	cld								  ;I001
 32860 0000585E 9C                      	pushf				; Preserve possible CY from DREAD ;I001
 32861 0000585F F3A5                    	rep	movsw			; move the contents of scratch buf;I001
 32862 00005861 06                      	push	es							  ;I001
 32863 00005862 1F                      	pop	ds							  ;I001
 32864                                  ;%endif
 32865                                  
 32866                                  ; 17/12/2022
 32867                                  %if 0
 32868                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32869                                  	; MSDOS 5.0
 32870                                  	pushf
 32871                                  	cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ?
 32872                                  	jz	short not_in_hma	; no
 32873                                  	popf
 32874                                  	mov	cx,[ES:BP+DPB.SECTOR_SIZE]
 32875                                  	shr	cx,1
 32876                                  	mov	si,bx
 32877                                  	pop	di ; *
 32878                                  	pop	es ; **
 32879                                  	cld
 32880                                  	rep	movsw
 32881                                  	push	es
 32882                                  	pop	ds
 32883                                  	jmp	short getb19 ; 27/11/2022
 32884                                  %endif
 32885                                  
 32886                                  not_in_hma:								  ;I001
 32887 00005863 9D                      	popf							 	  ;I001
 32888                                  getb19:
 32889 00005864 07                      	pop	es ; ***
 32890 00005865 5A                      	pop	dx
 32891 00005866 5F                      	pop	di
 32892 00005867 5E                      	pop	si
 32893 00005868 7248                    	JC	short getbx
 32894                                  
 32895                                  ;	The buffer has the data setup in it (if we were to read)
 32896                                  ;	Setup the various buffer fields
 32897                                  ;
 32898                                  ;	(ds:di) = buffer address
 32899                                  ;	(es:bp) = DPB address
 32900                                  ;	(HIGH_SECTOR:DX) = sector #
 32901                                  ;	(ah) = BUF_FLAGS value
 32902                                  ;	(si) = 0 if non fat sector, != 0 if FAT sector read
 32903                                  
 32904                                  ;hkn; SS override
 32905                                  getb20:	; MSDOS 6.0
 32906 0000586A 368B0E[0706]            	MOV	CX,[SS:HIGH_SECTOR]
 32907                                  	;mov	[di+8],cx
 32908 0000586F 894D08                  	MOV	[DI+BUFFINFO.buf_sector+2],CX
 32909                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 32910                                   	;mov	[di+6],dx
 32911 00005872 895506                  	MOV	[DI+BUFFINFO.buf_sector],DX
 32912                                  	;;mov	[di+0Ah],bp  ; MSDOS 3.3
 32913                                  	;mov	[di+0Dh],bp  ; MSDOS 6.0
 32914 00005875 896D0D                  	MOV	[DI+BUFFINFO.buf_DPB],BP
 32915                                  	;;mov	[di+0Ch],es
 32916                                  	;mov	[di+0Fh],es  ; MSDOS 6.0
 32917 00005878 8C450F                  	MOV	[DI+BUFFINFO.buf_DPB+2],ES
 32918                                  	; 15/12/2022
 32919 0000587B 268A4600                	mov	al,[es:bp]
 32920                                  	;mov	al,[es:bp+0]
 32921                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 32922                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 32923                                  	;mov	[di+4],ax
 32924 0000587F 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX		; Set ID and Flags
 32925                                  getb25:	
 32926                                  	; MSDOS 3.3
 32927                                  	;mov     ax,1
 32928                                  
 32929                                  	; MSDOS 6.0
 32930                                  	;mov	byte [di+0Ah],1
 32931 00005882 C6450A01                	MOV	byte [DI+BUFFINFO.buf_wrtcnt],1	; Default to not a FAT sector ;AC000;
 32932 00005886 31C0                    	XOR	AX,AX
 32933                                  
 32934                                  	; MSDOS 3.3 (& MSDOS 6.0)
 32935 00005888 09F6                    	OR	SI,SI				; FAT sector ?
 32936 0000588A 740B                    	JZ	short getb30
 32937                                  
 32938                                  	;mov	al,[es:bp+8]
 32939 0000588C 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]	; update number of copies of
 32940                                  	
 32941                                  	; MSDOS 6.0
 32942 00005890 88450A                  	MOV	[DI+BUFFINFO.buf_wrtcnt],AL	;  this sector present on disk
 32943                                  	;mov	ax,[es:bp+0Fh]
 32944 00005893 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE]		; offset of identical FAT
 32945                                  						;  sectors
 32946                                  	; MSDOS 3.3
 32947                                  	;;mov	ah,[es:bp+0Fh]
 32948                                  	;MOV	AH,[ES:BP+DPB.FAT_SIZE]
 32949                                  
 32950                                  ;	BUGBUG - dos 6 can clean this up by not setting wrtcntinc unless wrtcnt
 32951                                  ;		is set
 32952                                  
 32953                                  getb30:	
 32954                                  	; MSDOS 6.0
 32955                                  	;mov	[di+0Bh],ax
 32956 00005897 89450B                  	MOV	[DI+BUFFINFO.buf_wrtcntinc],AX
 32957                                  
 32958                                  	; MSDOS 3.3
 32959                                  	;;mov	[di+8],ax ; 15/08/2018	
 32960                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt],AX
 32961                                  
 32962 0000589A E8BBFE                  	CALL	PLACEBUF
 32963                                  
 32964                                  ;hkn; SS override for next 4
 32965                                  getb35: 
 32966                                  	; 17/12/2022
 32967                                  	; 07/12/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32968                                  	; MSDOS 3.3 & MSDOS 5.0 & MSDOS 6.0
 32969                                  	;MOV	[SS:CURBUF+2],DS
 32970                                  	;MOV	[SS:LastBuffer+2],DS
 32971                                  	;MOV	[SS:CURBUF],DI
 32972                                  	;MOV	[SS:LastBuffer],DI
 32973                                  	;CLC
 32974                                  
 32975                                  	; 17/12/2022
 32976                                  	; 07/12/2022
 32977                                  	; Retro DOS v4.0
 32978 0000589D 368C1E[2000]            	mov	[ss:LastBuffer+2],ds
 32979 000058A2 36893E[1E00]            	mov	[ss:LastBuffer],di
 32980 000058A7 F8                      	clc
 32981                                  getb35x: ; 28/07/2019
 32982 000058A8 368C1E[E405]            	MOV	[ss:CURBUF+2],ds
 32983 000058AD 36893E[E205]            	MOV	[ss:CURBUF],di
 32984                                  
 32985                                  ;	Return with 'C' set appropriately
 32986                                  ;	(dx) = caller's original value
 32987                                  
 32988                                  getbx:	
 32989 000058B2 16                      	push	ss
 32990 000058B3 1F                      	pop	ds
 32991                                  	;retn
 32992                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32993                                  getbuffrb_retn:
 32994                                  ;flushbuf_retn:	; 17/12/2022
 32995 000058B4 C3                      	retn
 32996                                  
 32997                                  ;Break	<FLUSHBUF -- WRITE OUT DIRTY BUFFERS>
 32998                                  ;----------------------------------------------------------------------------
 32999                                  ; Input:
 33000                                  ;	DS = DOSGROUP
 33001                                  ;	AL = Physical unit number local buffers only
 33002                                  ;	   = -1 for all units and all remote buffers
 33003                                  ; Function:
 33004                                  ;	Write out all dirty buffers for unit, and flag them as clean
 33005                                  ;	Carry set if error (user FAILed to I 24)
 33006                                  ;	    Flush operation completed.
 33007                                  ; DS Preserved, all others destroyed (ES too)
 33008                                  ;----------------------------------------------------------------------------
 33009                                  
 33010                                  	; 20/05/2019 - Retro DOS v4.0
 33011                                  	; DOSCODE:9A35h (MSDOS 6.21, MSDOS.SYS)
 33012                                  
 33013                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33014                                  	; DOSCODE:99DAh (MSDOS 5.0, MSDOS.SYS)
 33015                                  FLUSHBUF:
 33016                                  	; MSDOS 3.3
 33017                                  	;;mov	ah,-1 ; 01/08/2018 - Retro DOS v3.0
 33018                                  	;lds	di,[BUFFHEAD]
 33019                                  
 33020                                  	; MSDOS 6.0
 33021 000058B5 E887FE                  	call	GETCURHEAD
 33022                                  	;TEST	word [ss:DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 33023 000058B8 36F606[1106]04          	TEST	byte [ss:DOS34_FLAG],FROM_DISK_RESET ; 4
 33024 000058BE 7508                    	jnz	short scan_buf_queue
 33025 000058C0 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0			;hkn;
 33026 000058C6 7423                    	je	short end_scan
 33027                                  	
 33028                                  scan_buf_queue:
 33029 000058C8 E82900                  	call	CHECKFLUSH
 33030                                  	;push	ax  ; MSDOS 3.3
 33031                                  	; MSDOS 6.0
 33032                                  	;mov	ah,[di+4]
 33033 000058CB 8A6504                  	mov	ah,[DI+BUFFINFO.buf_ID]
 33034 000058CE 363826[2203]            	cmp	[SS:WPERR],ah					;hkn;
 33035 000058D3 7408                    	je	short free_the_buf
 33036                                  	;TEST	word [ss:DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 33037 000058D5 36F606[1106]04          	TEST	byte [ss:DOS34_FLAG],FROM_DISK_RESET ; 4
 33038 000058DB 7405                    	jz	short dont_free_the_buf
 33039                                  	; MSDOS 3.3
 33040                                  	;;mov	al,[di+4]
 33041                                  	;mov	al,[DI+BUFFINFO.buf_ID]
 33042                                  	;cmp	[SS:WPERR],al					;hkn;
 33043                                  	; 15/08/2018
 33044                                  	;jne	short dont_free_the_buf	
 33045                                  free_the_buf:
 33046                                  	; MSDOS 6.0 (& MSDOS 3.3)
 33047 000058DD C74504FF00              	mov	word [DI+BUFFINFO.buf_ID],00FFh
 33048                                  dont_free_the_buf:
 33049                                  	;pop	ax  ; MSDOS 3.3 	   	
 33050                                  
 33051                                  	; MSDOS 3.3
 33052                                  	;mov	di,[DI]
 33053                                  	;;mov	di,[DI+BUFFINFO.buf_link] ; .buf_next
 33054                                  	;
 33055                                  	; 15/08/2018
 33056                                  	;lds	di,[di]
 33057                                  	;
 33058                                  	;cmp	di,-1 ; 0FFFFh
 33059                                  	;jnz	short scan_buf_queue 
 33060                                  	
 33061                                  	; MSDOS 6.0
 33062 000058E2 8B3D                    	mov	di,[di]
 33063                                  	;mov	di,[DI+BUFFINFO.buf_next] ; .buf_link
 33064 000058E4 363B3E[BB0E]            	cmp	di,[SS:FIRST_BUFF_ADDR]				;hkn;
 33065 000058E9 75DD                    	jne	short scan_buf_queue
 33066                                  
 33067                                  end_scan:
 33068 000058EB 16                      	push	ss
 33069 000058EC 1F                      	pop	ds
 33070                                  	; 01/08/2018 - Retro DOS v3.0
 33071                                  	;cmp	byte [FAILERR],0
 33072                                  	;jne	short bad_flush
 33073                                  	;retn
 33074                                  ;bad_flush:
 33075                                  	;stc
 33076                                  	;retn
 33077                                  
 33078                                  	; 17/12/2022
 33079                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 33080                                  	; 01/08/2018 - Retro DOS v3.0
 33081 000058ED 803E[4A03]01            	cmp	byte [FAILERR],1
 33082 000058F2 F5                      	cmc
 33083                                  flushbuf_retn:
 33084 000058F3 C3                      	retn
 33085                                  	
 33086                                  	; 17/12/2022
 33087                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 33088                                  	;cmp	byte [FAILERR],0
 33089                                  	;jne	short bad_flush
 33090                                  	;retn
 33091                                  ;bad_flush:
 33092                                  	;stc
 33093                                  	;retn
 33094                                  
 33095                                  ;----------------------------------------------------------------------------
 33096                                  ;
 33097                                  ; Procedure Name : CHECKFLUSH
 33098                                  ;
 33099                                  ; Inputs : AL - Drive number, -1 means do not check for drive
 33100                                  ;	   DS:DI - pointer to buffer
 33101                                  ;
 33102                                  ; Function : Write out a buffer if it is dirty
 33103                                  ;
 33104                                  ; Carry set if problem (currently user FAILed to I 24)
 33105                                  ;
 33106                                  ;----------------------------------------------------------------------------
 33107                                  
 33108                                  CHECKFLUSH:
 33109                                  	; MSDOS 6.0
 33110 000058F4 B4FF                    	mov	ah,-1	; 01/08/2018 Retro DOS v3.0
 33111                                  	;cmp	[di+4],ah
 33112 000058F6 386504                  	CMP	[DI+BUFFINFO.buf_ID],AH
 33113 000058F9 74F8                    	jz	short flushbuf_retn	; Skip free buffer, carry clear
 33114 000058FB 38C4                    	CMP	AH,AL			; 
 33115 000058FD 7406                    	JZ	short DOBUFFER		; do this buffer
 33116                                  	;cmp	al,[di+4]
 33117 000058FF 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 33118 00005902 F8                      	CLC
 33119 00005903 75EE                    	jnz	short flushbuf_retn	; Buffer not for this unit or SFT
 33120                                  DOBUFFER:
 33121                                  	;test	byte [di+5],40h
 33122 00005905 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 33123 00005909 74E8                    	jz	short flushbuf_retn	; Buffer not dirty, carry clear by TEST
 33124 0000590B 50                      	PUSH	AX
 33125                                  	;push	word [di+4]
 33126 0000590C FF7504                  	PUSH	WORD [DI+BUFFINFO.buf_ID]
 33127 0000590F E80B00                  	CALL	BUFWRITE
 33128 00005912 58                      	POP	AX
 33129 00005913 7206                    	JC	short LEAVE_BUF		; Leave buffer marked free (lost).
 33130                                  	;and	ah,0BFh
 33131 00005915 80E4BF                  	AND	AH,~buf_dirty		; Buffer is clean, clears carry
 33132                                  	;mov	[di+4],ax
 33133 00005918 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX
 33134                                  LEAVE_BUF:
 33135 0000591B 58                      	POP	AX			; Search info
 33136                                  checkflush_retn:
 33137 0000591C C3                      	retn
 33138                                  
 33139                                  ;Break	<BUFWRITE -- WRITE OUT A BUFFER IF DIRTY>
 33140                                  ;----------------------------------------------------------------------------
 33141                                  ;
 33142                                  ;	BufWrite writes a buffer to the disk, if it's dirty.
 33143                                  ;
 33144                                  ;	ENTRY	DS:DI Points to the buffer
 33145                                  ;
 33146                                  ;	EXIT	Buffer marked free
 33147                                  ;		Carry set if error (currently user FAILed to I 24)
 33148                                  ;
 33149                                  ;	USES	All buf DS:DI
 33150                                  ;		HIGH_SECTOR
 33151                                  ;----------------------------------------------------------------------------
 33152                                  
 33153                                  	; 20/05/2019 - Retro DOS v4.0
 33154                                  	; DOSCODE:9AA0h (MSDOS 6.21, MSDOS.SYS)
 33155                                  
 33156                                  
 33157                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33158                                  	; DOSCODE:9A45h (MSDOS 5.0, MSDOS.SYS)
 33159                                  
 33160                                  BUFWRITE:
 33161                                  	; 10/09/2018
 33162                                  	; 01/08/2018 - Retro DOS v3.0
 33163                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E94h
 33164 0000591D B8FF00                  	MOV	AX,00FFH
 33165                                  	;xchg	ax,[di+4]
 33166 00005920 874504                  	XCHG	AX,[DI+BUFFINFO.buf_ID]	; Free, in case write barfs
 33167 00005923 3CFF                    	CMP	AL,0FFH
 33168 00005925 74F5                    	jz      short checkflush_retn	; Buffer is free, carry clear.
 33169                                  	;test	ah,40h
 33170 00005927 F6C440                  	test	AH,buf_dirty
 33171 0000592A 74F0                    	jz      short checkflush_retn	; Buffer is clean, carry clear.
 33172                                  	; MSDOS 6.0
 33173 0000592C E89A00                  	call	DEC_DIRTY_COUNT 	; LB. decrement dirty count
 33174                                  
 33175                                  ;hkn; SS override
 33176 0000592F 363A06[2203]            	CMP	AL,[SS:WPERR]
 33177 00005934 74E6                    	jz      short checkflush_retn	; If in WP error zap buffer
 33178                                  
 33179                                  ;hkn; SS override
 33180                                  	; MSDOS 6.0
 33181 00005936 36A2[AF0D]              	MOV	[SS:SC_DRIVE],AL	;LB. set it for invalidation ;AN000;
 33182                                  	
 33183                                  	; 07/03/2024
 33184                                  	;;;les	bp,[di+10] ; MSDOS 3.3
 33185                                  	;;les	bp,[di+13] ; MSDOS 6.0
 33186                                  	;LES	BP,[DI+BUFFINFO.buf_DPB]
 33187                                  
 33188                                  	;;lea	bx,[di+16]
 33189                                  	;lea	bx,[di+20] ; MSDOS 6.0
 33190 0000593A 8D5D14                  	LEA	BX,[DI+BUFINSIZ]	; Point at buffer
 33191                                  
 33192                                  ; 07/03/2024
 33193                                  %if 0
 33194                                  	;mov	dx,[di+6]
 33195                                  	MOV	DX,[DI+BUFFINFO.buf_sector] ;F.C. >32mb		;AN000;
 33196                                  	
 33197                                  	; MSDOS 6.0
 33198                                  	;mov	cx,[di+8]
 33199                                  	MOV	CX,[DI+BUFFINFO.buf_sector+2] ;F.C. >32mb	;AN000;
 33200                                  
 33201                                  ;hkn; SS override
 33202                                  	MOV	[SS:HIGH_SECTOR],CX	;F.C. >32mb		;AN000;
 33203                                  %else
 33204                                  	; 07/03/2024 (PCDOS 7.1 IBMDOS.COM)
 33205                                  	;;;
 33206                                  	;les	dx,[di+6]
 33207 0000593D C45506                  	les	dx,[di+BUFFINFO.buf_sector]
 33208 00005940 368C06[0706]            	mov	[ss:HIGH_SECTOR],es
 33209                                  
 33210                                  	;;les	bp,[di+10] ; MSDOS 3.3
 33211                                  	;les	bp,[di+13] ; MSDOS 6.0
 33212 00005945 C46D0D                  	les	bp,[di+BUFFINFO.buf_DPB]
 33213                                  	;;;
 33214                                  %endif
 33215                                  
 33216 00005948 8A4D0A                  	MOV	CL,[DI+BUFFINFO.buf_wrtcnt] ;>32mb		;AC000;
 33217                                  	; MSDOS 3.3
 33218                                  	;;mov	cx,[DI+8]
 33219                                  	;mov	cx,[DI+BUFFINFO.buf_wrtcnt]
 33220                                  	;MOV	AL,CH			; [DI+BUFFINFO.buf_wrtcntinc]
 33221 0000594B 30ED                    	XOR	CH,CH
 33222                                  	;;mov	ah,ch ; MSDOS 3.3
 33223                                  
 33224                                  ;hkn; SS override for ALLOWED
 33225                                  	;mov	byte [SS:ALLOWED],18h
 33226 0000594D 36C606[4B03]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 33227                                  	;test	byte [di+5],8
 33228                                  	; MSDOS 6.0 (& Retro DOS 3.0)
 33229                                  	;test	ah,8
 33230 00005953 F6C408                  	test	AH,buf_isDATA
 33231 00005956 7406                    	JZ	short NO_IGNORE
 33232                                  	;or	byte [SS:ALLOWED],20h
 33233 00005958 36800E[4B03]20          	OR	byte [SS:ALLOWED],Allowed_IGNORE
 33234                                  NO_IGNORE:
 33235                                  	;xor	ah,ah ; 10/09/2018 (MSDOS 3.3, Retro DOS v3.0)
 33236                                  	; MSDOS 6.0
 33237                                  	;mov	ax,[di+11]
 33238 0000595E 8B450B                  	MOV	AX,[DI+BUFFINFO.buf_wrtcntinc]	;>32mb		;AC000;
 33239                                  
 33240 00005961 57                      	PUSH	DI		; Save buffer pointer
 33241 00005962 31FF                    	XOR	DI,DI		; Indicate failure
 33242                                  
 33243 00005964 1E                      	push	ds ; *
 33244 00005965 53                      	push	bx ; **
 33245                                  WRTAGAIN:
 33246 00005966 57                      	push	di ; ***
 33247 00005967 51                      	push	cx ; ****
 33248 00005968 50                      	push	ax ; *****
 33249                                  	;MOV	CX,1
 33250                                  	; 17/12/2022
 33251                                  	; ch = 0
 33252 00005969 B101                    	mov	cl,1 ; 24/07/2019
 33253                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 33254                                  	;mov	cx,1
 33255 0000596B 53                      	push	bx ; ******
 33256 0000596C 52                      	push	dx ; *******
 33257 0000596D 1E                      	push	ds ; ********
 33258                                  
 33259                                  ; Note: As far as I can tell, all disk reads into buffers go through this point. -mrw 10/88
 33260                                  
 33261                                  	; MSDOS 6.0
 33262                                  	;cmp	byte [ss:BuffInHMA],0 ; 10/06/2019
 33263                                  	; 22/09/2023
 33264 0000596E 36382E[7900]            	cmp	[ss:BuffInHMA],ch ; 0
 33265 00005973 7418                    	jz	short NBUFFINHMA
 33266 00005975 51                      	push	cx
 33267 00005976 06                      	push	es
 33268 00005977 89DE                    	mov	si,bx
 33269 00005979 268B4E02                	mov	cx,[es:bp+DPB.SECTOR_SIZE]
 33270 0000597D D1E9                    	shr	cx,1
 33271 0000597F 36C43E[7A00]            	les	di,[ss:LoMemBuff] ; 10/06/2019
 33272 00005984 89FB                    	mov	bx,di
 33273 00005986 FC                      	cld
 33274 00005987 F3A5                    	rep	movsw
 33275 00005989 06                      	push	es
 33276 0000598A 1F                      	pop	ds
 33277 0000598B 07                      	pop	es
 33278 0000598C 59                      	pop	cx
 33279                                  NBUFFINHMA:
 33280 0000598D E8CADC                  	call	DWRITE		; Write out the dirty buffer
 33281 00005990 1F                      	pop	ds ; ********
 33282 00005991 5A                      	pop	dx ; *******
 33283 00005992 5B                      	pop	bx ; ******
 33284 00005993 58                      	pop	ax ; *****
 33285 00005994 59                      	pop	cx ; ****
 33286 00005995 5F                      	pop	di ; ***
 33287 00005996 7201                    	JC	short NOSET
 33288 00005998 47                      	INC	DI		; If at least ONE write succeedes, the operation
 33289                                  NOSET:				;	succeedes.
 33290 00005999 01C2                    	ADD	DX,AX
 33291 0000599B E2C9                    	LOOP	WRTAGAIN
 33292 0000599D 5B                      	pop	bx ; **
 33293 0000599E 1F                      	pop	ds ; *
 33294                                  	;OR	DI,DI		; Clears carry
 33295                                  	;JNZ	short BWROK	; At least one write worked
 33296                                  	;STC			; DI never got INCed, all writes failed.
 33297                                  	; 22/09/2023
 33298 0000599F 83FF01                  	cmp	di,1
 33299                                  BWROK:	
 33300 000059A2 5F                      	POP	DI
 33301 000059A3 C3                      	retn
 33302                                  
 33303                                  ;**	Set_RQ_SC_Parms - Set Secondary Cache Parameters
 33304                                  ;----------------------------------------------------------------------------
 33305                                  ;	Set_RQ_SC_Parms sets the sector size and drive number value
 33306                                  ;	for the secondary cache. This updates SC_SECTOR_SIZE &
 33307                                  ;	SC_DRIVE even if SC is disabled to save the testing
 33308                                  ;	code and time
 33309                                  ;
 33310                                  ;	ENTRY	ES:BP = drive parameter block
 33311                                  ;
 33312                                  ;	EXIT	[SC_SECTOR_SIZE]= drive sector size
 33313                                  ;		[SC_DRIVE]= drive #
 33314                                  ;
 33315                                  ;	USES	Flags
 33316                                  ;----------------------------------------------------------------------------
 33317                                  
 33318                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33319                                  ; 04/05/2019 - Retro DOS v4.0
 33320                                  
 33321                                  SET_RQ_SC_PARMS:
 33322                                  ;hkn; SS override for all variables used in this procedure.
 33323 000059A4 50                      	push	ax
 33324                                  	;mov	ax,[es:bp+2]
 33325 000059A5 268B4602                	MOV	ax,[ES:BP+DPB.SECTOR_SIZE]	; save sector size
 33326 000059A9 36A3[AD0D]              	MOV	[ss:SC_SECTOR_SIZE],ax
 33327                                  	;;mov	al,[es:bp+0]
 33328                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 33329                                  	;MOV	al,[ES:BP+DPB.DRIVE]		; save drive #
 33330                                  	; 15/12/2022
 33331 000059AD 268A4600                	mov	al,[ES:BP]
 33332 000059B1 36A2[AF0D]              	MOV	[ss:SC_DRIVE],al
 33333 000059B5 58                      	pop	ax
 33334                                  srspx:	
 33335 000059B6 C3                      	retn					;LB. return
 33336                                  
 33337                                  ; 07/07/2024 - Retro DOS v4.1
 33338                                  ; 01/02/2024 - Retro DOS v5.0
 33339                                  ;----------------------------------------------------------------------------
 33340                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:AD58h
 33341                                  
 33342                                  SET_BUF_DIRTY:                          ; ...
 33343                                  	;test	byte [es:di+5],40h
 33344 000059B7 26F6450540              	test	byte [es:di+BUFFINFO.buf_flags],buf_dirty
 33345 000059BC 750A                    	jnz	short yesdirty2
 33346                                  	;or	byte [es:di+5],40h
 33347 000059BE 26804D0540              	or	byte [es:di+BUFFINFO.buf_flags],buf_dirty
 33348                                  
 33349                                  ;INC_DIRTY_COUNT:
 33350                                  ;	inc     word [ss:DirtyBufferCount]
 33351                                  ;yesdirty2:
 33352                                  ;	retn
 33353                                  
 33354                                  ;Break	<INC_DIRTY_COUNT-increment dirty count>
 33355                                  ;----------------------------------------------------------------------------
 33356                                  ; Input:
 33357                                  ;	none
 33358                                  ; Function:
 33359                                  ;	increment dirty buffers count
 33360                                  ; Output:
 33361                                  ;	dirty buffers count is incremented
 33362                                  ;
 33363                                  ; All registers preserved
 33364                                  ;----------------------------------------------------------------------------
 33365                                  
 33366                                  INC_DIRTY_COUNT:
 33367                                  ;; BUGBUG  ---- remove this routine
 33368                                  ;; BUGBUG ---- only one instruction is needed (speed win, space loose)
 33369 000059C3 36FF06[7100]            	inc	word [ss:DirtyBufferCount]	;hkn;
 33370                                  yesdirty2:	; 01/02/2024
 33371 000059C8 C3                      	retn
 33372                                  
 33373                                  ;Break	<DEC_DIRTY_COUNT-decrement dirty count>
 33374                                  ;----------------------------------------------------------------------------
 33375                                  ; Input:
 33376                                  ;	none
 33377                                  ; Function:
 33378                                  ;	decrement dirty buffers count
 33379                                  ; Output:
 33380                                  ;	dirty buffers count is decremented
 33381                                  ;
 33382                                  ; All registers preserved
 33383                                  ;----------------------------------------------------------------------------
 33384                                  
 33385                                  DEC_DIRTY_COUNT:
 33386 000059C9 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0 ;hkn;
 33387 000059CF 7405                    	jz	short ddcx		; BUGBUG - shouldn't it be an
 33388 000059D1 36FF0E[7100]            	dec	word [ss:DirtyBufferCount] 
 33389                                  					; error condition to underflow here? ;hkn;
 33390                                  ddcx:	
 33391 000059D6 C3                      	retn
 33392                                  
 33393                                  ;============================================================================
 33394                                  ; MSPROC.ASM, MSDOS 6.0, 1992
 33395                                  ;============================================================================
 33396                                  ; 02/08/2018 - Retro DOS v3.0
 33397                                  ; 29/04/2019 - Retro DOS v4.0
 33398                                  
 33399                                  ; (15/04/2018 - RetrO DOS v2.0, MSDOS 2.11 - PROC.ASM - 1983)
 33400                                  
 33401                                  ; Pseudo EXEC system call for DOS
 33402                                  
 33403                                  ;	TITLE	MSPROC - process maintenance
 33404                                  ;	NAME	MSPROC
 33405                                  
 33406                                  ; =========================================================================
 33407                                  ;**	Process related system calls and low level routines for DOS 2.X.
 33408                                  ;	I/O specs are defined in DISPATCH.
 33409                                  ;
 33410                                  ;	$WAIT
 33411                                  ;	$EXEC
 33412                                  ;	$Keep_process
 33413                                  ;	Stay_resident
 33414                                  ;	$EXIT
 33415                                  ;	$ABORT
 33416                                  ;	abort_inner
 33417                                  ;
 33418                                  ;	Modification history:
 33419                                  ;
 33420                                  ;		Created: ARR 30 March 1983
 33421                                  ;		AN000	version 4.0 jan. 1988
 33422                                  ;		A007	PTM 3957 - fake vesrion for IBMCACHE.COM
 33423                                  ;		A008	PTM 4070 - fake version for MS WINDOWS
 33424                                  ;
 33425                                  ;		M000	added support for loading programs into UMBs 7/9/90
 33426                                  ;
 33427                                  ;		M004 - MS PASCAL 3.2 support. Please see under tag M003 in 
 33428                                  ;		       dossym.inc. 7/30/90
 33429                                  ;		M005 - Support for EXE programs with out STACK segment and 
 33430                                  ;		       with resident size < 64K - 256 bytes. A 256 byte 
 33431                                  ;		       stack is provided at the end of the program. Note that
 33432                                  ;		       only SP is changed.
 33433                                  ;		M020 - Fix for Rational bug for details see exepatch.asm
 33434                                  ;
 33435                                  ;		M028 - 4b04 implementation
 33436                                  ;
 33437                                  ;		M029 - Support for EXEs without stack rewritten. If EXE is
 33438                                  ;			in memory block >= 64K, sp = 0. If memory block
 33439                                  ;			obtained is <64K, point sp at the end of the memory
 33440                                  ;			block. For EXEs smaller than 64K, 256 bytes are still
 33441                                  ;			added for a stack segment which may be needed if it
 33442                                  ;			is loaded in low memory situations.
 33443                                  ;
 33444                                  ;		M030 - Fixing bug in EXEPACPATCH & changing 4b04 to 4b05
 33445                                  ;
 33446                                  ;		M040 - Bug #3052. The environment sizing code would flag a
 33447                                  ;			a bad environment if it reached 32767 bytes. Changed
 33448                                  ;			to allow 32768 bytes of environment.
 33449                                  ;
 33450                                  ;		M047 - Release the allocated UMB when we failed to load a 
 33451                                  ;		       COM file high. Also ensure that if the biggest block
 33452                                  ;		       into which we load the com file is less than 64K then
 33453                                  ;		       we provide atleast 256 bytes of stack to the user.
 33454                                  ;
 33455                                  ;		M050 - Made Lie table search CASE insensitive
 33456                                  ;
 33457                                  ;		M060 - Removed special version table from the kernal and
 33458                                  ;                      put it in a device drive which puts the address
 33459                                  ;                      in the DOS DATA area location UU_IFS_DOS_CALL
 33460                                  ;		       as a DWORD.
 33461                                  ;
 33462                                  ;		M063 - Modified UMB support. If the HIGH_ONLY bit is set on
 33463                                  ;		       entry do not try to load low if there is no space in
 33464                                  ;		       UMBs.
 33465                                  ;
 33466                                  ;		M068 - Support for copy protect apps. Call ChkCopyProt to 
 33467                                  ;		       set a20off_count. Set bit EXECA20BIT in DOS_FLAG. Also
 33468                                  ;		       change return address to LeaveDos if AL=5.
 33469                                  ;
 33470                                  ;               20-Jul-1992 bens  Added ifdef RESTRICTED_BUILD code that
 33471                                  ;                      controls building a version of MSDOS.SYS that only
 33472                                  ;                      runs programs from a fixed list (defined in the
 33473                                  ;                      file RESTRICT.INC).  Search for "RESTRICTED_BUILD"
 33474                                  ;                      for details.  This feature is used to build a
 33475                                  ;                      "special" version of DOS that can be handed out to
 33476                                  ;                      OEM/ISV customers as part of a "service" disk.
 33477                                  ;
 33478                                  ; =========================================================================
 33479                                  
 33480                                  ;SAVEXIT  EQU  10
 33481                                  
 33482                                  ;BREAK	<$WAIT - return previous process error code>
 33483                                  ; =========================================================================
 33484                                  ;	$WAIT - Return previous process error code.
 33485                                  ;
 33486                                  ;	Assembler usage:
 33487                                  ;
 33488                                  ;	    MOV     AH, WaitProcess
 33489                                  ;	    INT     int_command
 33490                                  ;
 33491                                  ;	ENTRY	none
 33492                                  ;	EXIT	(ax) = exit code
 33493                                  ;	USES	all
 33494                                  ; =========================================================================
 33495                                  
 33496                                  	; 20/05/2019 - Retro DOS v4.0
 33497                                  	; DOSCODE:9B55h (MSDOS 6.21, MSDOS.SYS)
 33498                                  
 33499                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33500                                  	; DOSCODE:9A5Ah (MSDOS 5.0, MSDOS.SYS)	
 33501                                  _$WAIT:
 33502                                  	; 02/08/2018 - Retro DOS v3.0
 33503                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E1h
 33504                                  
 33505 000059D7 31C0                    	xor	AX,AX
 33506 000059D9 368706[3403]            	xchg	AX,[ss:exit_code]
 33507 000059DE E950AC                  	jmp	SYS_RET_OK
 33508                                  
 33509                                  ; =========================================================================
 33510                                  ;BREAK <$exec - load/go a program>
 33511                                  ;	EXEC.ASM - EXEC System Call
 33512                                  ;
 33513                                  ;
 33514                                  ; Assembler usage:
 33515                                  ;	    lds     DX, Name
 33516                                  ;	    les     BX, Blk
 33517                                  ;	    mov     AH, Exec
 33518                                  ;	    mov     AL, FUNC
 33519                                  ;	    int     INT_COMMAND
 33520                                  ;
 33521                                  ;	AL  Function
 33522                                  ;	--  --------
 33523                                  ;	 0  Load and execute the program.
 33524                                  ;	 1  Load, create the program header but do not
 33525                                  ;	    begin execution.
 33526                                  ;	 3  Load overlay. No header created.
 33527                                  ;
 33528                                  ;	    AL = 0 -> load/execute program
 33529                                  ;
 33530                                  ;	    +---------------------------+
 33531                                  ;	    | WORD segment address of	|
 33532                                  ;	    | environment.		|
 33533                                  ;	    +---------------------------+
 33534                                  ;	    | DWORD pointer to ASCIZ	|
 33535                                  ;	    | command line at 80h	|
 33536                                  ;	    +---------------------------+
 33537                                  ;	    | DWORD pointer to default	|
 33538                                  ;	    | FCB to be passed at 5Ch	|
 33539                                  ;	    +---------------------------+
 33540                                  ;	    | DWORD pointer to default	|
 33541                                  ;	    | FCB to be passed at 6Ch	|
 33542                                  ;	    +---------------------------+
 33543                                  ;
 33544                                  ;	    AL = 1 -> load program
 33545                                  ;
 33546                                  ;	    +---------------------------+
 33547                                  ;	    | WORD segment address of	|
 33548                                  ;	    | environment.		|
 33549                                  ;	    +---------------------------+
 33550                                  ;	    | DWORD pointer to ASCIZ	|
 33551                                  ;	    | command line at 80h	|
 33552                                  ;	    +---------------------------+
 33553                                  ;	    | DWORD pointer to default	|
 33554                                  ;	    | FCB to be passed at 5Ch	|
 33555                                  ;	    +---------------------------+
 33556                                  ;	    | DWORD pointer to default	|
 33557                                  ;	    | FCB to be passed at 6Ch	|
 33558                                  ;	    +---------------------------+
 33559                                  ;	    | DWORD returned value of	|
 33560                                  ;	    | CS:IP			|
 33561                                  ;	    +---------------------------+
 33562                                  ;	    | DWORD returned value of	|
 33563                                  ;	    | SS:IP			|
 33564                                  ;	    +---------------------------+
 33565                                  ;
 33566                                  ;	    AL = 3 -> load overlay
 33567                                  ;
 33568                                  ;	    +---------------------------+
 33569                                  ;	    | WORD segment address where|
 33570                                  ;	    | file will be loaded.	|
 33571                                  ;	    +---------------------------+
 33572                                  ;	    | WORD relocation factor to |
 33573                                  ;	    | be applied to the image.	|
 33574                                  ;	    +---------------------------+
 33575                                  ;
 33576                                  ; Returns:
 33577                                  ;	    AX = error_invalid_function
 33578                                  ;	       = error_bad_format
 33579                                  ;	       = error_bad_environment
 33580                                  ;	       = error_not_enough_memory
 33581                                  ;	       = error_file_not_found
 33582                                  ; =========================================================================
 33583                                  ;
 33584                                  ;   Revision history:
 33585                                  ;
 33586                                  ;	 A000	version 4.00  Jan. 1988
 33587                                  ;
 33588                                  ; =========================================================================
 33589                                  
 33590                                  Exec_Internal_Buffer		EQU	OPENBUF
 33591                                  Exec_Internal_Buffer_Size	EQU	(128+128+53+curdirLen)
 33592                                  
 33593                                  ; =========================================================================
 33594                                  
 33595                                  ;IF1		; warning message on buffers
 33596                                  ;%out	Please make sure that the following are contiguous and of the
 33597                                  ;%out	following sizes:
 33598                                  ;%out
 33599                                  ;%out	OpenBuf     128
 33600                                  ;%out	RenBuf	    128
 33601                                  ;%out	SearchBuf    53
 33602                                  ;%out	DummyCDS    curdirLen
 33603                                  ;ENDIF
 33604                                  
 33605                                  ; =========================================================================
 33606                                  
 33607                                  ; =========================================================================
 33608                                  ;
 33609                                  ; =========================================================================
 33610                                  
 33611                                  	; 20/05/2019 - Retro DOS v4.0
 33612                                  	; DOSCODE:9B5Fh (MSDOS 6.21, MSDOS.SYS)
 33613                                  
 33614                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33615                                  	; DOSCODE:9B04h (MSDOS 5.0, MSDOS.SYS)
 33616                                  	
 33617                                  _$EXEC:
 33618                                  	; 02/08/2018 - Retro DOS v3.0
 33619                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5EF1h
 33620                                  
 33621                                  EXEC001S:
 33622                                  	;LocalVar    Exec_Blk		,DWORD
 33623                                  	;LocalVar    Exec_Func		,BYTE
 33624                                  	;LocalVar    Exec_Load_High	,BYTE
 33625                                  	;LocalVar    Exec_FH		,WORD
 33626                                  	;LocalVar    Exec_Rel_Fac	,WORD
 33627                                  	;LocalVar    Exec_Res_Len_Para	,WORD
 33628                                  	;LocalVar    Exec_Environ	,WORD
 33629                                  	;LocalVar    Exec_Size		,WORD
 33630                                  	;LocalVar    Exec_Load_Block	,WORD
 33631                                  	;LocalVar    Exec_DMA		,WORD
 33632                                  	;LocalVar    ExecNameLen 	,WORD
 33633                                  	;LocalVar    ExecName		,DWORD
 33634                                  	;
 33635                                  	;LocalVar    Exec_DMA_Save	,WORD
 33636                                  	;LocalVar    Exec_NoStack	,BYTE
 33637                                  
 33638                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33639                                  	;%define	Exec_Blk	dword [bp-4]
 33640                                  	%define		Exec_Blk	[bp-4] ; 09/08/2018
 33641                                  	%define		Exec_BlkL	word [bp-4]	
 33642                                  	%define		Exec_BlkH	word [bp-2]
 33643                                  	%define		Exec_Func	byte [bp-5]
 33644                                  	%define		Exec_Load_High	byte [bp-6]
 33645                                  	%define		Exec_FH		word [bp-8]
 33646                                  	%define		Exec_Rel_Fac	word [bp-10]
 33647                                  	%define		Exec_Res_Len_Para word [bp-12]
 33648                                  	%define		Exec_Environ	word [bp-14]
 33649                                  	%define		Exec_Size	word [bp-16]
 33650                                  	%define		Exec_Load_Block	word [bp-18]
 33651                                  	%define		Exec_DMA	word [bp-20]
 33652                                  	%define		ExecNameLen	word [bp-22]
 33653                                  	;%define	ExecName	dword [bp-26]
 33654                                  	%define		ExecName	[bp-26] ; 09/08/2018
 33655                                  	%define		ExecNameL	word [bp-26]	
 33656                                  	%define		ExecNameH	word [bp-24]
 33657                                  	; MSDOS 6.0
 33658                                  	%define		Exec_DMA_Save	word [bp-28]
 33659                                  	%define		Exec_NoStack	byte [bp-29]
 33660                                  	
 33661                                  	; ==================================================================
 33662                                  	; validate function
 33663                                  	; ==================================================================
 33664                                  		      	
 33665                                  	; M068 - Start
 33666                                  	;
 33667                                  	; Reset the A20OFF_COUNT to 0. This is done as there is a 
 33668                                  	; possibility that the count may not be decremented all the way to
 33669                                  	; 0. A typical case is if the program for which we intended to keep 
 33670                                  	; the A20 off for a sufficiently long time (A20OFF_COUNT int 21 
 33671                                  	; calls), exits pre-maturely due to error conditions.
 33672                                  
 33673                                  	; MSDOS 6.0
 33674 000059E1 36C606[8500]00          	mov	byte [SS:A20OFF_COUNT], 0
 33675                                  
 33676                                  	; If al=5 (ExecReady) we'll change the return address on the stack	
 33677                                  	; to be LeaveDos in msdisp.asm. This ensures that the EXECA20OFF
 33678                                  	; bit set in DOS_FLAG by ExecReady is not cleared in msdisp.asm
 33679                                  
 33680 000059E7 3C05                    	cmp	al,5			; Q: is this ExecReady call
 33681                                  	;jne	short @f
 33682 000059E9 7505                    	jne	short Exec_@f		; N: continue
 33683                                  					; Y: change ret addr. to LeaveDos.
 33684 000059EB 59                      	pop	cx			; Note CX is not input to ExecReady
 33685 000059EC B9[0404]                	mov	cx,LeaveDOS
 33686 000059EF 51                      	push	cx
 33687                                  ;@@:
 33688                                  Exec_@f:
 33689                                  	; M068 - End
 33690                                  	
 33691                                  	;Enter
 33692                                  
 33693 000059F0 55                      	push	bp
 33694 000059F1 89E5                    	mov	bp,sp
 33695                                  	;;sub	sp,26	; MSDOS 3.3
 33696                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)	
 33697                                  	;sub	sp,29	; MSDOS 6.0 (& MSDOS 6.21)
 33698                                  	; 17/12/2022
 33699                                  	; 20/05/2019
 33700 000059F3 83EC1E                  	sub	sp,30	; Retro DOS v4.0	
 33701                                  
 33702                                  	; MSDOS 6.0
 33703 000059F6 3C05                    	cmp	AL,5			; only 0, 1, 3 or 5 are allowed ;M028
 33704                                  					; M030
 33705 000059F8 7614                    	jna	short Exec_Check_2
 33706                                  
 33707                                  	; MSDOS 3.3
 33708                                  	;cmp	AL,3
 33709                                  	;jna	short Exec_Check_2
 33710                                  
 33711                                  Exec_Bad_Fun:
 33712 000059FA 36C606[2303]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; 1
 33713                                  					; Extended Error Locus	;smr;SS Override
 33714                                  	;mov	al,1
 33715 00005A00 B001                    	mov	al,error_invalid_function
 33716                                  
 33717                                  Exec_Ret_Err:
 33718                                  	;Leave
 33719 00005A02 89EC                    	mov	sp,bp
 33720 00005A04 5D                      	pop	bp
 33721                                  	;transfer SYS_RET_ERR
 33722 00005A05 E932AC                  	jmp	SYS_RET_ERR
 33723                                  
 33724                                  	; MSDOS 6.0
 33725                                  ExecReadyJ:
 33726 00005A08 E88A17                  	call	ExecReady		; M028
 33727 00005A0B E90204                  	jmp	norm_ovl		; do a Leave & xfer sysret_OK ; M028
 33728                                  
 33729                                  Exec_Check_2:
 33730 00005A0E 3C02                    	cmp	AL,2			
 33731 00005A10 74E8                    	je	short Exec_Bad_Fun
 33732                                  
 33733                                  	; MSDOS 6.0
 33734 00005A12 3C04                    	cmp	al,4			; 2 & 4 are not allowed
 33735 00005A14 74E4                    	je	short Exec_Bad_Fun
 33736                                  	
 33737 00005A16 3C05                    	cmp	al,5			; M028 ; M030
 33738 00005A18 74EE                    	je	short ExecReadyJ	; M028
 33739                                  
 33740                                  	;mov	[bp-4],bx
 33741 00005A1A 895EFC                  	mov	Exec_BlkL,BX		; stash args
 33742                                  	;mov	[bp-2],es
 33743 00005A1D 8C46FE                  	mov	Exec_BlkH,ES
 33744                                  	;mov	[bp-5],al
 33745 00005A20 8846FB                  	mov	Exec_Func,AL
 33746                                  	;mov	byte [bp-6],0
 33747 00005A23 C646FA00                	mov	Exec_Load_High,0
 33748                                  
 33749                                  	;mov	[bp-26],dx
 33750 00005A27 8956E6                  	mov	ExecNameL,DX		; set up length of exec name
 33751                                  	;mov	[bp-24],ds
 33752 00005A2A 8C5EE8                  	mov	ExecNameH,DS
 33753 00005A2D 89D6                    	mov	SI,DX			; move pointer to convenient place
 33754                                  	;invoke	DStrLen
 33755 00005A2F E8A5B7                  	call	DStrLen
 33756                                  	;mov	[bp-22],cx
 33757 00005A32 894EEA                  	mov	ExecNameLen,CX		; save length
 33758                                  
 33759                                  	; MSDOS 6.0
 33760 00005A35 36A0[0203]              	mov	al,[ss:AllocMethod]	; M063: save alloc method in 
 33761 00005A39 36A2[8400]              	mov	[ss:ALLOCMSAVE],al	; M063: AllocMsave
 33762                                  
 33763 00005A3D 30C0                    	xor	AL,AL			; open for reading
 33764 00005A3F 55                      	push	BP
 33765                                  
 33766                                  	; MSDOS 6.0
 33767                                  	;or	byte [ss:DOS_FLAG],1
 33768 00005A40 36800E[8600]01          	or	byte [ss:DOS_FLAG],EXECOPEN ; this flag is set to indicate to 
 33769                                  					; the redir that this open call is
 33770                                  					; due to an exec.
 33771                                  
 33772                                  	;invoke	$OPEN			; is the file there?
 33773 00005A46 E8CD12                  	call	_$OPEN
 33774                                  
 33775                                  	; MSDOS 6.0
 33776 00005A49 9C                      	pushf
 33777                                  	; 02/06/2019
 33778                                  	;and	byte [ss:DOS_FLAG],0FEh
 33779 00005A4A 368026[8600]FE          	and	byte [ss:DOS_FLAG],~EXECOPEN ; reset flag
 33780 00005A50 9D                      	popf
 33781                                  
 33782 00005A51 5D                      	pop	BP
 33783                                  
 33784                                  	; MSDOS 3.3 & MSDOS 6.0
 33785 00005A52 72AE                    	jc	short Exec_Ret_Err
 33786                                  
 33787                                  	;mov	[bp-8],ax
 33788 00005A54 8946F8                  	mov	Exec_FH,AX
 33789 00005A57 89C3                    	mov	BX,AX
 33790 00005A59 30C0                    	xor	AL,AL
 33791                                  	;invoke	$Ioctl
 33792 00005A5B E8A5C7                  	call	_$IOCTL
 33793 00005A5E 7207                    	jc	short Exec_BombJ
 33794                                  
 33795                                  	;test	dl,80h
 33796 00005A60 F6C280                  	test	DL,devid_ISDEV
 33797 00005A63 740A                    	jz	short Exec_Check_Environ
 33798                                  
 33799                                  	;mov	al,2
 33800 00005A65 B002                    	mov	AL,error_file_not_found
 33801                                  Exec_BombJ:
 33802 00005A67 E9C800                  	jmp	Exec_Bomb
 33803                                  
 33804                                  BadEnv:
 33805                                  	;mov	al,0Ah
 33806 00005A6A B00A                    	mov	AL,error_bad_environment
 33807 00005A6C E9C300                  	jmp	Exec_Bomb
 33808                                  
 33809                                  Exec_Check_Environ:
 33810                                  	;mov	word [bp-18],0
 33811 00005A6F C746EE0000              	mov	Exec_Load_Block,0
 33812                                  	;mov	word [bp-14],0
 33813 00005A74 C746F20000              	mov	Exec_Environ,0
 33814                                  					; overlays... no environment
 33815                                  	;test	byte [bp-5],2
 33816 00005A79 F646FB02                	test	Exec_Func,exec_func_overlay
 33817 00005A7D 7552                    	jnz	short Exec_Read_Header
 33818                                  
 33819                                  	;lds	si,[bp-4]
 33820 00005A7F C576FC                  	lds	SI,Exec_Blk		; get block
 33821 00005A82 8B04                    	mov	ax,[SI]
 33822                                  	;mov	AX,[SI+EXEC1.ENVIRON]	; address of environ
 33823 00005A84 09C0                    	or	AX,AX
 33824 00005A86 750C                    	jnz	short Exec_Scan_Env
 33825                                  
 33826 00005A88 368E1E[3003]            	mov	DS,[SS:CurrentPDB]	;smr;SS Override
 33827                                  	;mov	ax,[44]
 33828 00005A8D A12C00                  	mov	AX,[PDB.ENVIRON]
 33829                                  
 33830                                  ; MSDOS 6.0
 33831                                  ;---------------------------------------------BUG 92 4/30/90-----------------
 33832                                  ;
 33833                                  ; Exec_environ is being correctly initialized after the environment has been
 33834                                  ; allocated and copied form the parent's env. It must not be initialized here.
 33835                                  ; Because if the call to $alloc below fails Exec_dealloc will deallocate the
 33836                                  ; parent's environment.
 33837                                  ;	mov	Exec_Environ,AX
 33838                                  ;
 33839                                  ;----------------------------------------------------------------------------
 33840                                  
 33841                                  	;mov	[bp-14],ax
 33842                                  	;mov	Exec_Environ,ax
 33843                                  
 33844 00005A90 09C0                    	or	AX,AX
 33845 00005A92 743D                    	jz	short Exec_Read_Header
 33846                                  
 33847                                  Exec_Scan_Env:
 33848 00005A94 8EC0                    	mov	ES,AX
 33849 00005A96 31FF                    	xor	DI,DI
 33850                                  	;mov	cx,7FFFh ; MSDOS 3.3
 33851 00005A98 B90080                  	mov	CX,8000h ; MSDOS 6.0	; at most 32k of environment ;M040
 33852 00005A9B 30C0                    	xor	AL,AL
 33853                                  
 33854                                  Exec_Get_Environ_Len:
 33855 00005A9D F2AE                    	repnz	scasb			; find that nul byte
 33856 00005A9F 75C9                    	jnz	short BadEnv
 33857                                  
 33858 00005AA1 49                      	dec	CX			; Dec CX for the next nul byte test
 33859 00005AA2 78C6                    	js	short BadEnv		; gone beyond the end of the environment
 33860                                  
 33861 00005AA4 AE                      	scasb				; is there another nul byte?
 33862 00005AA5 75F6                    	jnz	short Exec_Get_Environ_Len ; no, scan some more
 33863                                  
 33864 00005AA7 57                      	push	DI
 33865                                  	;lea	bx,[DI+11h]
 33866 00005AA8 8D5D11                  	lea	BX,[DI+0Fh+2]
 33867                                  	;add	bx,[bp-22]
 33868 00005AAB 035EEA                  	add	BX,ExecNameLen		; BX <- length of environment
 33869                                  					; remember argv[0] length
 33870                                  					; round up and remember argc
 33871 00005AAE B104                    	mov	CL,4
 33872 00005AB0 D3EB                    	shr	BX,CL			; number of paragraphs needed
 33873 00005AB2 06                      	push	ES
 33874                                  	;invoke	$Alloc			; can we get the space?
 33875 00005AB3 E83E06                  	call	_$ALLOC
 33876 00005AB6 1F                      	pop	DS
 33877 00005AB7 59                      	pop	CX
 33878                                  
 33879                                  	;jnc	short Exec_Save_Environ
 33880                                  	;jmp	SHORT Exec_No_Mem	; nope... cry and sob
 33881                                  	; 17/12/2022
 33882 00005AB8 7272                    	jc	short Exec_No_Mem ; 02/06/2019
 33883                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 33884                                  	;jnc	short Exec_Save_Environ
 33885                                  	;jmp	SHORT Exec_No_Mem
 33886                                  
 33887                                  Exec_Save_Environ:
 33888 00005ABA 8EC0                    	mov	ES,AX
 33889                                  	;mov	[bp-14],ax
 33890 00005ABC 8946F2                  	mov	Exec_Environ,AX 	; save him for a rainy day
 33891 00005ABF 31F6                    	xor	SI,SI
 33892 00005AC1 89F7                    	mov	DI,SI
 33893 00005AC3 F3A4                    	rep	movsb			; copy the environment
 33894 00005AC5 B80100                  	mov	AX,1
 33895 00005AC8 AB                      	stosw
 33896                                  	;lds	si,[bp-26]
 33897 00005AC9 C576E6                  	lds	SI,ExecName
 33898                                  	;mov	cx,[bp-22]
 33899 00005ACC 8B4EEA                  	mov	CX,ExecNameLen
 33900 00005ACF F3A4                    	rep	movsb
 33901                                  
 33902                                  Exec_Read_Header:
 33903                                  	; We read in the program header into the above data area and
 33904                                  	; determine where in this memory the image will be located.
 33905                                  
 33906                                  	;Context DS
 33907 00005AD1 16                      	push	ss
 33908 00005AD2 1F                      	pop	ds
 33909                                  	;mov	cx,26
 33910 00005AD3 B91A00                  	mov	CX,exec_header_len	; header size
 33911 00005AD6 BA[C80F]                	mov	DX,exec_signature
 33912 00005AD9 06                      	push	ES
 33913 00005ADA 1E                      	push	DS
 33914 00005ADB E87704                  	call	ExecRead
 33915 00005ADE 1F                      	pop	DS
 33916 00005ADF 07                      	pop	ES
 33917 00005AE0 724E                    	jc	short Exec_Bad_File
 33918                                  
 33919 00005AE2 09C0                    	or	AX,AX
 33920 00005AE4 744A                    	jz	short Exec_Bad_File
 33921                                  	;cmp	ax,26
 33922 00005AE6 83F81A                  	cmp	AX,exec_header_len	; did we read the right number?
 33923 00005AE9 7519                    	jnz	short Exec_Com_Filej	; yep... continue
 33924                                  
 33925 00005AEB F706[D40F]FFFF          	test	word [exec_max_BSS],-1 	; indicate load high?
 33926 00005AF1 7504                    	jnz	short Exec_Check_Sig
 33927                                  
 33928                                  	;mov	byte [bp-6],0FFh
 33929 00005AF3 C646FAFF                	mov	Exec_Load_High,-1
 33930                                  
 33931                                  Exec_Check_Sig:
 33932 00005AF7 A1[C80F]                	mov	AX,[exec_signature]	; rms;NSS
 33933                                  	;cmp	ax,5A4Dh ; 'MZ'
 33934 00005AFA 3D4D5A                  	cmp	AX,exe_valid_signature	; zibo arises!
 33935 00005AFD 7408                    	jz	short Exec_Save_Start 	; assume com file if no signature
 33936                                  
 33937                                  	;cmp	ax,4D5Ah ; 'ZM'
 33938 00005AFF 3D5A4D                  	cmp	AX,exe_valid_old_signature  ; zibo arises!
 33939 00005B02 7403                    	jz	short Exec_Save_Start 	; assume com file if no signature
 33940                                  
 33941                                  Exec_Com_Filej:
 33942 00005B04 E9E701                  	jmp	Exec_Com_File
 33943                                  
 33944                                  	; We have the program header... determine memory requirements
 33945                                  
 33946                                  Exec_Save_Start:
 33947 00005B07 A1[CC0F]                	mov	AX,[exec_pages]		; get 512-byte pages	;rms;NSS
 33948 00005B0A B105                    	mov	CL,5			; convert to paragraphs
 33949 00005B0C D3E0                    	shl	AX,CL
 33950 00005B0E 2B06[D00F]              	sub	AX,[exec_par_dir] 	; AX = size in paragraphs ;rms;NSS
 33951                                  	;mov	[bp-12],ax
 33952 00005B12 8946F4                  	mov	Exec_Res_Len_Para,AX
 33953                                  
 33954                                  		; Do we need to allocate memory?
 33955                                  		; Yes if function is not load-overlay
 33956                                  
 33957                                  	;test	byte [bp-5],2
 33958 00005B15 F646FB02                	test	Exec_Func,exec_func_overlay
 33959 00005B19 7443                    	jz	short Exec_Allocate	; allocation of space
 33960                                  
 33961                                  		; get load address from block
 33962                                  
 33963                                  	;les	di,[bp-4]
 33964 00005B1B C47EFC                  	les	DI,Exec_Blk
 33965                                  
 33966                                  ; 07/03/2024
 33967                                  %if 0
 33968                                  	mov	ax,[es:di]
 33969                                  	;mov	AX,[ES:DI+EXEC3.load_addr]
 33970                                  	;mov	[bp-20],ax
 33971                                  	mov	Exec_DMA,AX
 33972                                  
 33973                                  	; 17/12/2022
 33974                                  	;;mov	ax,[es:di+2]
 33975                                  	;mov	AX,[ES:DI+EXEC3.reloc_fac]
 33976                                  	;;mov	[bp-10],ax
 33977                                  	;mov	Exec_Rel_Fac,AX
 33978                                  
 33979                                  	; 17/12/2022
 33980                                  	; 30/11/2022 (!most proper code!)
 33981                                  	;mov	dx,[es:di+2]
 33982                                  	mov	dx,[ES:DI+EXEC3.reloc_fac]
 33983                                  	;mov	[bp-10],dx
 33984                                  	mov	Exec_Rel_Fac,dx
 33985                                  %else
 33986                                  	; 07/03/2024 (PCDOS 7.1 IBMDOS.COM)
 33987                                  	;;;
 33988 00005B1E 06                      	push	es
 33989 00005B1F 26C405                  	les	ax,[es:di]
 33990                                  	;les	ax,[ES:DI+EXEC3.load_addr]
 33991                                  	;mov	[bp-20],ax
 33992 00005B22 8946EC                  	mov	Exec_DMA,ax
 33993                                  	;mov	[bp-10],es
 33994 00005B25 8C46F6                  	mov	Exec_Rel_Fac,es
 33995 00005B28 07                      	pop	es
 33996                                  	;;;
 33997                                  %endif
 33998                                  	; ax = Exec_DMA
 33999 00005B29 E9DE00                  	jmp	Exec_Find_Res
 34000                                  
 34001                                  ; 17/12/2022
 34002                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 34003                                  ; 27/09/2023
 34004                                  %if 0
 34005                                  	; 02/06/2019 - Retro DOS v4.0
 34006                                  	;mov	ax,[bp-20]  ; *+*
 34007                                  	mov	AX,Exec_DMA ; *+*
 34008                                  	; 10/08/2018
 34009                                  	jmp	Exec_Find_Res		; M000
 34010                                  %endif
 34011                                  
 34012                                  Exec_No_Mem:
 34013                                  	;mov	al,8
 34014 00005B2C B008                    	mov	AL,error_not_enough_memory
 34015 00005B2E EB02                    	jmp	short Exec_Bomb
 34016                                  
 34017                                  Exec_Bad_File:
 34018                                  	;mov	al,0Bh
 34019 00005B30 B00B                    	mov	AL,error_bad_format
 34020                                  
 34021                                  Exec_Bomb:
 34022                                  	;mov	bx,[bp-8]
 34023 00005B32 8B5EF8                  	mov	BX,Exec_FH
 34024 00005B35 E83604                  	call	Exec_Dealloc
 34025                                  	;LeaveCrit CritMem
 34026 00005B38 E8C2B7                  	call	LCritMEM
 34027                                  	;save	<AX,BP>
 34028 00005B3B 50                      	push	ax
 34029 00005B3C 55                      	push	bp
 34030                                  	;invoke	$CLOSE
 34031 00005B3D E81F0A                  	call	_$CLOSE
 34032                                  	;restore <BP,AX>
 34033 00005B40 5D                      	pop	bp
 34034 00005B41 58                      	pop	ax
 34035 00005B42 E9BDFE                  	jmp	Exec_Ret_Err
 34036                                  
 34037                                  Exec_Chk_Mem: 
 34038                                  
 34039                                  	; 24/09/2023
 34040                                  	; ds = DOSDATA
 34041                                  ; 17/12/2022
 34042                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 34043                                  ;%if 0
 34044                                  	; MSDOS 6.0    			; M063 - Start
 34045                                  	;mov	al,[ss:AllocMethod]	; save current alloc method in ax
 34046                                  	; 10/06/2019
 34047 00005B45 A0[0203]                	mov	al,[AllocMethod]
 34048                                  	;mov	bl,[ss:ALLOCMSAVE]
 34049 00005B48 8A1E[8400]              	mov	bl,[ALLOCMSAVE]
 34050                                  	;mov	[ss:AllocMethod],bl	; restore original allocmethod
 34051 00005B4C 881E[0203]              	mov	[AllocMethod],bl
 34052                                  	
 34053 00005B50 F6C340                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 34054 00005B53 75D7                    	jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
 34055                                  	;				; N: continue
 34056                                  	;
 34057 00005B55 A840                    	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 34058 00005B57 74D3                    	jz	short Exec_No_Mem	; N: no memory
 34059                                  	; 02/06/2019
 34060                                  	;mov	ax,[ss:SAVE_AX]		; Y: restore ax and
 34061 00005B59 A1[8A00]                	mov	ax,[SAVE_AX]
 34062                                  	;jmp	short Exec_Norm_Alloc	;    Try again
 34063                                  					; M063 - End
 34064 00005B5C EB2B                    	jmp	short Exec_Norm_Alloc1
 34065                                  ;%endif
 34066                                  
 34067                                  ; 17/12/2022
 34068                                  %if 0
 34069                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 34070                                  	; MSDOS 6.0    			; M063 - Start
 34071                                  	mov	al,[ss:AllocMethod]	; save current alloc method in ax
 34072                                  	mov	bl,[ss:ALLOCMSAVE]
 34073                                  	mov	[ss:AllocMethod],bl	; restore original allocmethod
 34074                                  
 34075                                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 34076                                  	jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
 34077                                  	;				; N: continue
 34078                                  	;
 34079                                  	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 34080                                  	jz	short Exec_No_Mem	; N: no memory
 34081                                  
 34082                                  	mov	ax,[ss:SAVE_AX]		; Y: restore ax and
 34083                                  	jmp	short Exec_Norm_Alloc	;    Try again
 34084                                  					; M063 - End
 34085                                  %endif
 34086                                  
 34087                                  Exec_Allocate:
 34088                                  	; 09/09/2018
 34089                                  
 34090                                  	; M005 - START
 34091                                  	; If there is no STACK segment for this exe file and if this
 34092                                  	; not an overlay and the resident size is less than 64K - 
 34093                                  	; 256 bytes we shall add 256 bytes to the programs 
 34094                                  	; resident memory requirement and set Exec_SP to this value.
 34095                                  	
 34096                                  	; 17/12/2022
 34097 00005B5E 29DB                    	sub	bx,bx ; 0	
 34098                                  
 34099                                  	; MSDOS 6.0
 34100                                  	;;mov	byte [bp-29],0
 34101                                  	;mov	Exec_NoStack,0
 34102                                  	; 17/12/2022
 34103 00005B60 885EE3                  	mov	Exec_NoStack,bl ; 0
 34104 00005B63 391E[D60F]              	cmp	[exec_SS],bx ; 0
 34105                                  	;cmp	word [exec_SS],0	; Q: is there a stack seg
 34106 00005B67 7511                    	jne	short ea1		; Y: continue normal processing
 34107 00005B69 391E[D80F]              	cmp	[exec_SP],bx ; 0
 34108                                  	;cmp	word [exec_SP],0	; Q: is there a stack ptr
 34109 00005B6D 750B                    	jne	short ea1		; Y: continue normal processing
 34110                                  
 34111                                  	;inc	byte [bp-29]
 34112 00005B6F FE46E3                  	inc	Exec_NoStack
 34113 00005B72 3DF00F                  	cmp	ax,1000h-10h		; Q: is this >= 64K-256 bytes
 34114 00005B75 7303                    	jae	short ea1		; Y: don't set Exec_SP
 34115                                  
 34116 00005B77 83C010                  	add	ax,10h			; add 10h paras to mem requirement
 34117                                  ea1:
 34118                                  	; M005 - END
 34119                                  
 34120                                  	; MSDOS 6.0			; M000 - start
 34121                                  	; 20/05/2019
 34122                                  	; (ds = ss = DOSDATA)
 34123 00005B7A F606[0203]80            	test	byte [AllocMethod],HIGH_FIRST ; 80h
 34124                                  					; Q: is the alloc strat high_first
 34125 00005B7F 7405                    	jz	short Exec_Norm_Alloc	; N: normal allocate
 34126                                  					; Y: set high_only bit
 34127 00005B81 800E[0203]40            	or	byte [AllocMethod],HIGH_ONLY ; 40h
 34128                                  					; M000 - end
 34129                                  Exec_Norm_Alloc:
 34130 00005B86 A3[8A00]                	mov	[SAVE_AX],ax		; M000: save ax for possible 2nd
 34131                                  Exec_Norm_Alloc1:	; 02/06/2019
 34132                                  					; M000: attempt at allocating memory
 34133                                  	; MSDOS 3.3
 34134                                  	;push	ax			; M000
 34135                                  
 34136 00005B89 BBFFFF                  	mov	BX,0FFFFh		; see how much room in arena
 34137 00005B8C 1E                      	push	DS
 34138                                  	;invoke	$Alloc			; should have carry set and BX has max
 34139 00005B8D E86405                  	call	_$ALLOC
 34140 00005B90 1F                      	pop	DS
 34141                                  
 34142                                  	; MSDOS 6.0
 34143 00005B91 A1[8A00]                	mov	AX,[SAVE_AX]		; M000
 34144                                  	; MSDOS 3.3
 34145                                  	;pop	ax			; M000
 34146                                  
 34147 00005B94 83C010                  	add	AX,10h			; room for header
 34148 00005B97 83FB11                  	cmp	BX,11h			; enough room for a header
 34149                                  	; MSDOS 6.0
 34150 00005B9A 72A9                    	jb	short Exec_Chk_Mem	; M000
 34151                                  	; MSDOS 3.3	
 34152                                  	;jb	short Exec_No_Mem
 34153                                  
 34154 00005B9C 39D8                    	cmp	AX,BX			; is there enough for bare image?
 34155                                  	; MSDOS 6.0
 34156 00005B9E 77A5                    	ja	short Exec_Chk_Mem	; M000
 34157                                  	; MSDOS 3.3
 34158                                  	;ja	short Exec_No_Mem
 34159                                  
 34160                                  	;test	byte [bp-6],0FFh
 34161 00005BA0 F646FAFF                	test	Exec_Load_High,-1	; if load high, use max
 34162 00005BA4 7518                    	jnz	short Exec_BX_Max	; use max
 34163                                  
 34164                                  	; 09/09/2018
 34165                                  
 34166 00005BA6 0306[D20F]              	add	AX,[exec_min_BSS] 	; go for min allocation;rms;NSS
 34167                                  	; MSDOS 6.0
 34168 00005BAA 7299                    	jc	short Exec_Chk_Mem	; M000
 34169                                  	; MSDOS 3.3
 34170                                  	;jc	short Exec_No_Mem
 34171                                  
 34172 00005BAC 39D8                    	cmp	AX,BX			; enough space?
 34173                                  	; MSDOS 6.0
 34174 00005BAE 7795                    	ja	short Exec_Chk_Mem	; M000: nope...
 34175                                  	; MSDOS 3.3
 34176                                  	;ja	short Exec_No_Mem
 34177                                  
 34178 00005BB0 2B06[D20F]              	sub	AX,[exec_min_BSS] 	; rms;NSS
 34179 00005BB4 0306[D40F]              	add	AX,[exec_max_BSS] 	; go for the MAX
 34180 00005BB8 7204                    	jc	short Exec_BX_Max
 34181                                  
 34182 00005BBA 39D8                    	cmp	AX,BX
 34183 00005BBC 7602                    	jbe	short Exec_Got_Block
 34184                                  
 34185                                  Exec_BX_Max:
 34186 00005BBE 89D8                    	mov	AX,BX
 34187                                  
 34188                                  Exec_Got_Block:
 34189                                  	; 03/08/2018 - Retro DOS v3.0
 34190                                  
 34191 00005BC0 1E                      	push	DS
 34192 00005BC1 89C3                    	mov	BX,AX
 34193                                  	;mov	[bp-16],bx
 34194 00005BC3 895EF0                  	mov	Exec_Size,BX
 34195                                  	;invoke	$Alloc			; get the space
 34196 00005BC6 E82B05                  	call	_$ALLOC
 34197 00005BC9 1F                      	pop	DS
 34198                                  	; MSDOS 6.0
 34199                                  	;jc	short Exec_Chk_Mem	; M000
 34200                                  	; MSDOS 3.3
 34201                                  	;;jc	short Exec_No_Mem
 34202                                  	; 20/05/2019
 34203 00005BCA 7303                    	jnc	short ea0
 34204 00005BCC E976FF                  	jmp	Exec_Chk_Mem
 34205                                  ea0:
 34206                                  	; MSDOS 6.0
 34207 00005BCF 8A0E[8400]              	mov	cl,[ALLOCMSAVE]		; M063: 
 34208 00005BD3 880E[0203]              	mov	[AllocMethod],cl	; M063: restore allocmethod
 34209                                  
 34210                                  ;M029; Begin changes
 34211                                  ; This code does special handling for programs with no stack segment. If so,
 34212                                  ;check if the current block is larger than 64K. If so, we do not modify
 34213                                  ;Exec_SP. If smaller than 64K, we make Exec_SP = top of block. In either
 34214                                  ;case Exec_SS is not changed.
 34215                                  
 34216                                  	; MSDOS 6.0
 34217                                  	;cmp	byte [bp-29],0
 34218 00005BD7 807EE300                	cmp	Exec_NoStack,0
 34219                                  	;je	@f
 34220 00005BDB 7412                    	je	short ea2
 34221                                  
 34222 00005BDD 81FB0010                	cmp	bx,1000h		; Q: >= 64K memory block
 34223                                  	;jae	@f			; Y: Exec_SP = 0
 34224 00005BE1 730C                    	jae	short ea2
 34225                                  
 34226                                  ;Make Exec_SP point at the top of the memory block
 34227                                  
 34228 00005BE3 B104                    	mov	cl,4
 34229 00005BE5 D3E3                    	shl	bx,cl			; get byte offset
 34230 00005BE7 81EB0001                	sub	bx,100h			; take care of PSP
 34231 00005BEB 891E[D80F]              	mov	[exec_SP],bx		; Exec_SP = top of block
 34232                                  ea2:
 34233                                  ;@@:
 34234                                  ;M029; end changes
 34235                                  
 34236                                  	;mov	[bp-18],ax
 34237 00005BEF 8946EE                  	mov	Exec_Load_Block,AX
 34238 00005BF2 83C010                  	add	AX,10h
 34239                                  	;test	byte [bp-6],0FFh
 34240 00005BF5 F646FAFF                	test	Exec_Load_High,-1
 34241 00005BF9 7409                    	jz	short Exec_Use_AX	; use ax for load info
 34242                                  
 34243                                  	;add	ax,[bp-16]
 34244 00005BFB 0346F0                  	add	AX,Exec_Size		; go to end
 34245                                  	;sub	ax,[bp-12]
 34246 00005BFE 2B46F4                  	sub	AX,Exec_Res_Len_Para	; drop off header
 34247 00005C01 83E810                  	sub	AX,10h			; drop off pdb
 34248                                  
 34249                                  Exec_Use_AX:
 34250                                  	;mov	[bp-10],ax
 34251 00005C04 8946F6                  	mov	Exec_Rel_Fac,AX 	; new segment
 34252                                  	;mov	[bp-20],ax
 34253 00005C07 8946EC                  	mov	Exec_DMA,AX ; *+*	; beginning of dma
 34254                                  
 34255                                  	; Determine the location in the file of the beginning of
 34256                                  	; the resident
 34257                                  
 34258                                  ; 17/12/2022
 34259                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 34260                                  ;%if 0
 34261                                  
 34262                                  Exec_Find_Res:
 34263                                  	; MSDOS 6.0
 34264                                  	;;mov	dx,[bp-20]
 34265                                  	;mov	DX,Exec_DMA ; *+*
 34266                                  	;;mov	[bp-28],dx
 34267                                  	;mov	Exec_DMA_Save,DX
 34268                                  
 34269                                  	; 17/12/2022
 34270                                  	; AX = Exec_DMA
 34271                                  
 34272                                  	; 02/06/2019 - Retro DOS v4.0
 34273                                  	;mov	[bp-28],ax ; *+*
 34274 00005C0A 8946E4                  	mov	Exec_DMA_Save,AX ; *+*
 34275                                  
 34276                                  ;%endif
 34277                                  
 34278                                  ; 17/12/2022
 34279                                  %if 0
 34280                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 34281                                  Exec_Find_Res:
 34282                                  	;mov	dx,[bp-20]
 34283                                  	mov	DX,Exec_DMA ; *+*
 34284                                  	;mov	[bp-28],dx
 34285                                  	mov	Exec_DMA_Save,DX
 34286                                  %endif
 34287                                  
 34288                                  	; MSDOS 3.3 (& MSDOS 6.0)
 34289 00005C0D 8B16[D00F]              	mov	DX,[exec_par_dir]
 34290 00005C11 52                      	push	DX
 34291 00005C12 B104                    	mov	CL,4
 34292 00005C14 D3E2                    	shl	DX,CL			; low word of location
 34293 00005C16 58                      	pop	AX
 34294 00005C17 B10C                    	mov	CL,12
 34295 00005C19 D3E8                    	shr	AX,CL			; high word of location
 34296 00005C1B 89C1                    	mov	CX,AX			; CX <- high
 34297                                  
 34298                                  		; Read in the resident image (first, seek to it)
 34299                                  	;mov	bx,[bp-8]
 34300 00005C1D 8B5EF8                  	mov	BX,Exec_FH
 34301 00005C20 1E                      	push	DS
 34302 00005C21 30C0                    	xor	AL,AL
 34303                                  	;invoke	$Lseek			; Seek to resident
 34304 00005C23 E8A30A                  	call	_$LSEEK
 34305 00005C26 1F                      	pop	DS
 34306 00005C27 7303                    	jnc	short Exec_Big_Read
 34307                                  
 34308 00005C29 E906FF                  	jmp	Exec_Bomb
 34309                                  
 34310                                  Exec_Big_Read:				; Read resident into memory
 34311                                  	;mov	bx,[bp-12]
 34312 00005C2C 8B5EF4                  	mov	BX,Exec_Res_Len_Para
 34313 00005C2F 81FB0010                	cmp	BX,1000h		; Too many bytes to read?
 34314 00005C33 7203                    	jb	short Exec_Read_OK
 34315                                  
 34316 00005C35 BBE00F                  	mov	BX,0FE0h		; Max in one chunk FE00 bytes
 34317                                  
 34318                                  Exec_Read_OK:
 34319                                  	;sub	[bp-12],bx
 34320 00005C38 295EF4                  	sub	Exec_Res_Len_Para,BX	; We read (soon) this many
 34321 00005C3B 53                      	push	BX
 34322 00005C3C B104                    	mov	CL,4
 34323 00005C3E D3E3                    	shl	BX,CL			; Get count in bytes from paras
 34324 00005C40 89D9                    	mov	CX,BX			; Count in correct register
 34325 00005C42 1E                      	push	DS
 34326                                  	;mov	ds,[bp-20]
 34327 00005C43 8E5EEC                  	mov	DS,Exec_DMA		; Set up read buffer
 34328                                  
 34329 00005C46 31D2                    	xor	DX,DX
 34330 00005C48 51                      	push	CX			; Save our count
 34331 00005C49 E80903                  	call	ExecRead
 34332 00005C4C 59                      	pop	CX			; Get old count to verify
 34333 00005C4D 1F                      	pop	DS
 34334 00005C4E 7248                    	jc	short Exec_Bad_FileJ
 34335                                  
 34336 00005C50 39C1                    	cmp	CX,AX			; Did we read enough?
 34337 00005C52 5B                      	pop	BX			; Get paragraph count back
 34338 00005C53 7408                    	jz	short ExecCheckEnd	; and do reloc if no more to read
 34339                                  
 34340                                  	; The read did not match the request. If we are off by 512
 34341                                  	; bytes or more then the header lied and we have an error.
 34342                                  
 34343 00005C55 29C1                    	sub	CX,AX
 34344 00005C57 81F90002                	cmp	CX,512
 34345 00005C5B 733B                    	jae	short Exec_Bad_FileJ
 34346                                  
 34347                                  	; We've read in CX bytes... bump DTA location
 34348                                  
 34349                                  ExecCheckEnd:
 34350                                  	;add	[bp-20],bx
 34351 00005C5D 015EEC                  	add	Exec_DMA,BX		; Bump dma address
 34352                                  	;test	word [bp-12],0FFFFh
 34353 00005C60 F746F4FFFF              	test	Exec_Res_Len_Para,-1
 34354 00005C65 75C5                    	jnz	short Exec_Big_Read
 34355                                  
 34356                                  	; The image has now been read in. We must perform relocation
 34357                                  	; to the current location.
 34358                                  
 34359                                  exec_do_reloc:
 34360                                  	;mov	cx,[bp-10]
 34361 00005C67 8B4EF6                  	mov	CX,Exec_Rel_Fac
 34362 00005C6A A1[D60F]                	mov	AX,[exec_SS]		; get initial SS ;rms;NSS
 34363 00005C6D 01C8                    	add	AX,CX			; and relocate him
 34364 00005C6F A3[C20F]                	mov	[exec_init_SS],AX 	; rms;NSS
 34365                                  
 34366 00005C72 A1[D80F]                	mov	AX,[exec_SP]		; initial SP ;rms;NSS
 34367 00005C75 A3[C00F]                	mov	[exec_init_SP],AX 	; rms;NSS
 34368                                  
 34369 00005C78 C406[DC0F]              	les	AX,[exec_IP]		; rms;NSS
 34370 00005C7C A3[C40F]                	mov	[exec_init_IP],AX 	; rms;NSS
 34371 00005C7F 8CC0                    	mov	AX,ES			; rms;NSS
 34372 00005C81 01C8                    	add	AX,CX			; relocated...
 34373 00005C83 A3[C60F]                	mov	[exec_init_CS],AX 	; rms;NSS
 34374                                  
 34375 00005C86 31C9                    	xor	CX,CX
 34376 00005C88 8B16[E00F]              	mov	DX,[exec_rle_table]	; rms;NSS
 34377                                  	;mov	bx,[bp-8]
 34378 00005C8C 8B5EF8                  	mov	BX,Exec_FH
 34379 00005C8F 1E                      	push	DS
 34380 00005C90 31C0                    	xor	AX,AX
 34381                                  	;invoke	$Lseek
 34382 00005C92 E8340A                  	call	_$LSEEK
 34383 00005C95 1F                      	pop	DS
 34384 00005C96 7303                    	jnc	short exec_get_entries
 34385                                  
 34386                                  Exec_Bad_FileJ:
 34387 00005C98 E995FE                  	jmp	Exec_Bad_File
 34388                                  
 34389                                  exec_get_entries:
 34390 00005C9B 8B16[CE0F]              	mov	DX,[exec_rle_count]	; Number of entries left ;rms;NSS
 34391                                  
 34392                                  exec_read_reloc:
 34393 00005C9F 52                      	push	DX
 34394                                  	;mov	dx,OPENBUF
 34395 00005CA0 BA[BE03]                	mov	DX,Exec_Internal_Buffer
 34396                                  	;;mov	cx,388 ; MSDOS 3.3 ; (390>>2)<<2
 34397                                  	;mov	cx,396 ; MSDOS 6.0
 34398 00005CA3 B98C01                  	mov	CX,((Exec_Internal_Buffer_Size)/4)*4 ; (397>>2)<<2
 34399 00005CA6 1E                      	push	DS
 34400 00005CA7 E8AB02                  	call	ExecRead
 34401 00005CAA 07                      	pop	ES
 34402 00005CAB 5A                      	pop	DX
 34403 00005CAC 72EA                    	jc	short Exec_Bad_FileJ
 34404                                  
 34405                                  	;;mov	cx,97 ;  MSDOS 3.3 ; (390>>2)
 34406                                  	;mov	cx,99 ;  MSDOS 6.0
 34407 00005CAE B96300                  	mov	CX,(Exec_Internal_Buffer_Size)/4 ; (397>>2)
 34408                                  					; Pointer to byte location in header
 34409                                  	;mov	di,OPENBUF
 34410 00005CB1 BF[BE03]                	mov	DI,Exec_Internal_Buffer
 34411                                  	;mov	si,[bp-10]
 34412 00005CB4 8B76F6                  	mov	SI,Exec_Rel_Fac 	; Relocate a single address
 34413                                  
 34414                                  exec_reloc_one:
 34415 00005CB7 09D2                    	or	DX,DX			; Any more entries?
 34416 00005CB9 7416                    	jz	short Exec_Set_PDBJ
 34417                                  
 34418                                  exec_get_addr:
 34419 00005CBB 26C51D                  	lds	BX,[ES:DI]		; Get ra/sa of entry
 34420 00005CBE 8CD8                    	mov	AX,DS			; Relocate address of item
 34421                                  
 34422                                  	; MSDOS 6.0
 34423                                  ;;;;;;	add	AX,SI  ; MSDOS 3.3
 34424                                  	;add	ax,[bp-28]
 34425 00005CC0 0346E4                  	add	AX,Exec_DMA_Save
 34426                                  
 34427 00005CC3 8ED8                    	mov	DS,AX
 34428 00005CC5 0137                    	add	[BX],SI
 34429 00005CC7 83C704                  	add	DI,4
 34430 00005CCA 4A                      	dec	DX
 34431 00005CCB E2EA                    	loop	exec_reloc_one		; End of internal buffer?
 34432                                  
 34433                                  	; We've exhausted a single buffer's worth. Read in the next
 34434                                  	; piece of the relocation table.
 34435                                  
 34436 00005CCD 06                      	push	ES
 34437 00005CCE 1F                      	pop	DS
 34438 00005CCF EBCE                    	jmp	short exec_read_reloc
 34439                                  
 34440                                  Exec_Set_PDBJ:
 34441                                  	; MSDOS 6.0
 34442                                  	
 34443                                  	; We now determine if this is a buggy exe packed file and if
 34444                                  	; so we patch in the right code. Note that fixexepatch will
 34445                                  	; point to a ret if dos loads low. The load segment as
 34446                                  	; determined above will be in exec_dma_save
 34447                                  	
 34448 00005CD1 06                      	push	es
 34449 00005CD2 50                      	push	ax			; M030
 34450 00005CD3 51                      	push	cx			; M030
 34451                                  	;mov	es,[bp-28]
 34452 00005CD4 8E46E4                  	mov	es,Exec_DMA_Save
 34453 00005CD7 36A1[C60F]              	mov	ax,[ss:exec_init_CS]	; M030
 34454 00005CDB 368B0E[C40F]            	mov	cx,[ss:exec_init_IP]	; M030
 34455 00005CE0 36FF16[1212]            	call	word [ss:FixExePatch]
 34456                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34457                                  	; (MSDOS 5.0 MSDOS.SYS does not contain 'Rational386Patch')
 34458                                  	;call	word [ss:Rational386PatchPtr]
 34459 00005CE5 59                      	pop	cx			; M030
 34460 00005CE6 58                      	pop	ax			; M030
 34461 00005CE7 07                      	pop	es
 34462                                  
 34463 00005CE8 E9DD00                  	jmp	Exec_Set_PDB
 34464                                  
 34465                                  Exec_No_Memj:
 34466 00005CEB E93EFE                  	jmp	Exec_No_Mem
 34467                                  
 34468                                  	; we have a .COM file. First, determine if we are merely
 34469                                  	; loading an overlay.
 34470                                  
 34471                                  Exec_Com_File:
 34472                                  	;test	byte [bp-5],2
 34473 00005CEE F646FB02                	test	Exec_Func,exec_func_overlay
 34474 00005CF2 742D                    	jz	short Exec_Alloc_Com_File
 34475                                  	;lds	si,[bp-4]
 34476 00005CF4 C576FC                  	lds	SI,Exec_Blk		; get arg block
 34477 00005CF7 AD                      	lodsw				; get load address
 34478                                  	;mov	[bp-20],ax
 34479 00005CF8 8946EC                  	mov	Exec_DMA,AX
 34480 00005CFB B8FFFF                  	mov	AX,0FFFFh
 34481 00005CFE EB63                    	jmp	short Exec_Read_Block	; read it all!
 34482                                  
 34483                                  Exec_Chk_Com_Mem:			
 34484                                  	; MSDOS 6.0	     		; M063 - Start
 34485 00005D00 36A0[0203]              	mov	al,[ss:AllocMethod]	; save current alloc method in ax
 34486 00005D04 368A1E[8400]            	mov	bl,[ss:ALLOCMSAVE]
 34487 00005D09 36881E[0203]            	mov	[ss:AllocMethod],bl	; restore original allocmethod
 34488 00005D0E F6C340                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 34489 00005D11 75D8                    	jnz	short Exec_No_Memj	; Y: no space in UMBs. Quit
 34490                                  					; N: continue
 34491                                  	
 34492 00005D13 A840                    	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 34493 00005D15 74D4                    	jz	short Exec_No_Memj	; N: no memory
 34494                                  	
 34495                                  	;mov	ax,[bp-18]
 34496 00005D17 8B46EE                  	mov	ax,Exec_Load_Block	; M047: ax = block we just allocated
 34497 00005D1A 31DB                    	xor	bx,bx			; M047: bx => free arena
 34498 00005D1C E86B02                  	call	ChangeOwner		; M047: free this block
 34499                                  	
 34500 00005D1F EB0E                    	jmp	short Exec_Norm_Com_Alloc
 34501                                  					; M063 - End
 34502                                  	
 34503                                  	; We must allocate the max possible size block (ick!)
 34504                                  	; and set up CS=DS=ES=SS=PDB pointer, IP=100, SP=max
 34505                                  	; size of block.
 34506                                  
 34507                                  Exec_Alloc_Com_File:
 34508                                  	; MSDOS 6.0			; M000 -start
 34509 00005D21 36F606[0203]80          	test	byte [ss:AllocMethod],HIGH_FIRST ; 80h
 34510                                  					; Q: is the alloc strat high_first
 34511 00005D27 7406                    	jz	short Exec_Norm_Com_Alloc ; N: normal allocate
 34512                                  					; Y: set high_only bit
 34513 00005D29 36800E[0203]40          	or	byte [ss:AllocMethod],HIGH_ONLY ; 40h
 34514                                  					; M000 - end
 34515                                  Exec_Norm_Com_Alloc:			; M000
 34516                                  	; MSDOS 3.3 (& MSDOS 6.0)
 34517 00005D2F BBFFFF                  	mov	BX,0FFFFh
 34518                                  	;invoke	$Alloc			; largest piece available as error
 34519 00005D32 E8BF03                  	call	_$ALLOC
 34520 00005D35 09DB                    	or	BX,BX
 34521                                  	; MSDOS 6.0
 34522 00005D37 74C7                    	jz	short Exec_Chk_Com_Mem	; M000
 34523                                  	; MSDOS 3.3
 34524                                  	;jz	short Exec_No_Memj
 34525                                  
 34526                                  	;mov	[bp-16],bx
 34527 00005D39 895EF0                  	mov	Exec_Size,BX		; save size of allocation block
 34528 00005D3C 53                      	push	BX
 34529                                  	;invoke	$ALLOC			; largest piece available
 34530 00005D3D E8B403                  	call	_$ALLOC
 34531 00005D40 5B                      	pop	BX			; get size of block...
 34532                                  	;mov	[bp-18],ax
 34533 00005D41 8946EE                  	mov	Exec_Load_Block,AX
 34534                                  
 34535 00005D44 83C010                  	add	AX,10h			; increment for header
 34536                                  	;mov	[bp-20],ax
 34537 00005D47 8946EC                  	mov	Exec_DMA,AX
 34538                                  
 34539 00005D4A 31C0                    	xor	AX,AX			; presume 64K read...
 34540 00005D4C 81FB0010                	cmp	BX,1000h		; 64k or more in block?
 34541 00005D50 730E                    	jae	short Exec_Read_Com	; yes, read only 64k
 34542                                  
 34543 00005D52 89D8                    	mov	AX,BX			; convert size to bytes
 34544 00005D54 B104                    	mov	CL,4
 34545 00005D56 D3E0                    	shl	AX,CL
 34546                                  	; 17/12/2022
 34547                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34548                                  	;			(MSDOS 5.0, MSDOS.SYS compatibility)
 34549                                  	; MSDOS 5.0
 34550                                  	;cmp	AX,100h   
 34551                                  	; 02/06/2019 - Retro DOS v4.0
 34552                                  	; MSDOS 6.0
 34553                                          ; 17/12/2022
 34554 00005D58 3D0002                  	cmp	AX,200h                 ; enough memory for PSP and stack?
 34555 00005D5B 76A3                    	jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 34556                                  	;;jbe	short Exec_No_Memj	; M000: jump if not
 34557                                  	;; Retro DOS v3.0 modification (on MSDOS 6.0 code) -03/08/2018-
 34558                                  	;;jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 34559                                  	;jbe	short Exec_No_Memj	; M000: jump if not
 34560                                  
 34561                                  					; M047: size of the block is < 64K
 34562 00005D5D 2D0001                  	sub	ax,100h			; M047: reserve 256 bytes for stack
 34563                                  
 34564                                  Exec_Read_Com:
 34565                                  	; MSDOS 3.3 (& MSDOS 6.0)
 34566 00005D60 2D0001                  	sub	AX,100h 		; remember size of psp
 34567                                  Exec_Read_Block:
 34568 00005D63 50                      	push	AX			; save number to read
 34569                                  	;mov	bx,[bp-8]
 34570 00005D64 8B5EF8                  	mov	BX,Exec_FH		; of com file
 34571 00005D67 31C9                    	xor	CX,CX			; but seek to 0:0
 34572 00005D69 31C0                    	xor	AX,AX			; seek relative to beginning
 34573                                  	;mov	DX,CX
 34574                                  	; 08/03/2024
 34575 00005D6B 99                      	cwd
 34576                                  	;invoke	$Lseek			; back to beginning of file
 34577 00005D6C E85A09                  	call	_$LSEEK
 34578 00005D6F 59                      	pop	CX			; number to read
 34579                                  	;mov	ds,[bp-20]
 34580 00005D70 8E5EEC                  	mov	DS,Exec_DMA
 34581 00005D73 31D2                    	xor	DX,DX
 34582 00005D75 51                      	push	CX
 34583 00005D76 E8DC01                  	call	ExecRead
 34584 00005D79 5E                      	pop	SI			; get number of bytes to read
 34585 00005D7A 7303                    	jnc	short OkRead
 34586 00005D7C E9B1FD                  	jmp	Exec_Bad_File
 34587                                  
 34588                                  	; 10/09/2018
 34589                                  OkRead:
 34590 00005D7F 39F0                    	cmp	AX,SI			; did we read them all?
 34591                                  	; MSDOS 6.0
 34592                                  	;jz	short Exec_Chk_Com_Mem	; M00: exactly the wrong number...no
 34593                                  	; MSDOS 3.3
 34594                                  	;;jz	short Exec_No_Memj	; M00: exactly the wrong number...
 34595 00005D81 7503                    	jne	short OkRead2
 34596 00005D83 E97AFF                  	jmp	Exec_Chk_Com_Mem
 34597                                  OkRead2:
 34598                                  	; MSDOS 6.0
 34599 00005D86 368A1E[8400]            	mov	bl,[ss:ALLOCMSAVE]	; M063
 34600 00005D8B 36881E[0203]            	mov	[ss:AllocMethod],bl	; M063: restore alloc method
 34601                                  
 34602                                  	; MSDOS 3.3 (& MSDOS 6.0)
 34603                                  	;test	byte [bp-5],2
 34604 00005D90 F646FB02                	test	Exec_Func,exec_func_overlay
 34605 00005D94 7532                    	jnz	short Exec_Set_PDB	; no starto, chumo!
 34606                                  
 34607                                  	;mov	ax,[bp-20]
 34608 00005D96 8B46EC                  	mov	AX,Exec_DMA
 34609 00005D99 83E810                  	sub	AX,10h
 34610 00005D9C 36A3[C60F]              	mov	[SS:exec_init_CS],AX
 34611 00005DA0 36C706[C40F]0001        	mov	word [SS:exec_init_IP],100h ; initial IP is 100h
 34612                                  
 34613                                  	; SI is AT MOST FF00h. Add FE to account for PSP - word
 34614                                  	; of 0 on stack.
 34615                                  
 34616 00005DA7 81C6FE00                	add	SI,0FEh 		; make room for stack
 34617                                  
 34618                                  	; MSDOS 6.0
 34619 00005DAB 83FEFE                  	cmp	si,0FFFEh		; M047: Q: was there >= 64K available
 34620 00005DAE 7404                    	je	short Exec_St_Ok	; M047: Y: stack is fine
 34621 00005DB0 81C60001                	add	si,100h			; M047: N: add the xtra 100h for stack
 34622                                  
 34623                                  Exec_St_Ok:
 34624                                  	; MSDOS 3.3 (& MSDOS 6.0)
 34625 00005DB4 368936[C00F]            	mov	[SS:exec_init_SP],SI 	; max value for read is also SP!;smr;SS Override
 34626 00005DB9 36A3[C20F]              	mov	[SS:exec_init_SS],AX 					;smr;SS Override
 34627 00005DBD 8ED8                    	mov	DS,AX
 34628 00005DBF C7040000                	mov	WORD [SI],0		; 0 for return
 34629                                  
 34630                                  	; MSDOS 6.0
 34631                                  
 34632                                  	; M068
 34633                                  	;
 34634                                  	; We now determine if this is a Copy Protected App. If so the
 34635                                  	; A20OFF_COUNT is set to 6. Note that ChkCopyProt will point to
 34636                                  	; a ret if DOS is loaded low. Also DS contains the load segment.
 34637                                  
 34638 00005DC3 36FF16[6100]            	call	word [ss:ChkCopyProt]
 34639                                  
 34640                                  Exec_Set_PDB:
 34641                                  	; MSDOS 3.3 (& MSDOS 6.0)
 34642                                  	;mov	bx,[bp-8]
 34643 00005DC8 8B5EF8                  	mov	BX,Exec_FH		; we are finished with the file.
 34644 00005DCB E8A001                  	call	Exec_Dealloc
 34645 00005DCE 55                      	push	BP
 34646                                  	;invoke	$Close			; release the jfn
 34647 00005DCF E88D07                  	call	_$CLOSE
 34648 00005DD2 5D                      	pop	BP
 34649 00005DD3 E88A01                  	call	Exec_Alloc
 34650                                  	;test	byte [bp-5],2
 34651 00005DD6 F646FB02                	test	Exec_Func,exec_func_overlay
 34652 00005DDA 743A                    	jz	short Exec_Build_Header
 34653                                  
 34654                                  	; MSDOS 6.0
 34655 00005DDC E8B901                  	call	Scan_Execname
 34656 00005DDF E8CD01                  	call	Scan_Special_Entries
 34657                                  ;SR;
 34658                                  ;The current lie strategy uses the PSP to store the lie version. However,
 34659                                  ;device drivers are loaded as overlays and have no PSP. To handle them, we
 34660                                  ;use the Sysinit flag provided by the BIOS as part of a structure pointed at
 34661                                  ;by BiosDataPtr. If this flag is set, the overlay call has been issued from
 34662                                  ;Sysinit and therefore must be a device driver load. We then get the lie
 34663                                  ;version for this driver and put it into the Sysinit PSP. When the driver
 34664                                  ;issues the version check, it gets the lie version until the next overlay
 34665                                  ;call is issued.
 34666                                  
 34667 00005DE2 36803E[3F10]00          	cmp	byte [ss:DriverLoad],0	;was Sysinit processing done?
 34668 00005DE8 7426                    	je	short norm_ovl		;yes, no special handling
 34669 00005DEA 56                      	push	si
 34670 00005DEB 06                      	push	es
 34671 00005DEC 36C436[4010]            	les	si,[ss:BiosDataPtr]	;get ptr to BIOS data block
 34672                                  	 
 34673                                  	; (es:si points to 'SysinitPresent' address/flag in retrodos4.s)
 34674 00005DF1 26803C00                	cmp	byte [es:si],0		;in Sysinit?
 34675 00005DF5 7411                    	je	short sysinit_done	;no, Sysinit is finished
 34676                                  	
 34677 00005DF7 368E06[3003]            	mov	es,[ss:CurrentPDB]	;es = current PSP (Sysinit PSP)
 34678 00005DFC 36FF36[BD0E]            	push	word [ss:SPECIAL_VERSION]
 34679 00005E01 268F064000              	pop	word [es:PDB.Version]	;store lie version in Sysinit PSP
 34680                                  		;;; PDB.VERSION
 34681 00005E06 EB06                    	jmp	short setver_done
 34682                                  sysinit_done:
 34683 00005E08 36C606[3F10]00          	mov	byte [ss:DriverLoad],0	;Sysinit done,special handling off
 34684                                  setver_done:
 34685 00005E0E 07                      	pop	es
 34686 00005E0F 5E                      	pop	si
 34687                                  norm_ovl:
 34688                                  	;leave
 34689 00005E10 89EC                    	mov	sp,bp
 34690 00005E12 5D                      	pop	bp
 34691                                  
 34692                                  	;transfer SYS_RET_OK		; overlay load -> done
 34693 00005E13 E91BA8                  	jmp	SYS_RET_OK
 34694                                  
 34695                                  Exec_Build_Header:
 34696                                  	;mov	dx,[bp-18]
 34697 00005E16 8B56EE                  	mov	DX,Exec_Load_Block
 34698                                  					; assign the space to the process
 34699                                  	;mov	si,1
 34700 00005E19 BE0100                  	mov	SI,ARENA.OWNER		; pointer to owner field
 34701                                  	;mov	ax,[bp-14]
 34702 00005E1C 8B46F2                  	mov	AX,Exec_Environ 	; get environ pointer
 34703 00005E1F 09C0                    	or	AX,AX
 34704 00005E21 7405                    	jz	short No_Owner		; no environment
 34705                                  
 34706 00005E23 48                      	dec	AX			; point to header
 34707 00005E24 8ED8                    	mov	DS,AX
 34708 00005E26 8914                    	mov	[SI],DX 		; assign ownership
 34709                                  No_Owner:
 34710                                  	;mov	ax,[bp-18]
 34711                                  	;mov	AX,Exec_Load_Block	; get load block pointer
 34712                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34713                                  	; 17/12/2022
 34714 00005E28 89D0                    	mov	ax,dx ; 06/06/2019
 34715                                  	;mov	ax,Exec_Load_Block	; get load block pointer
 34716                                  	
 34717 00005E2A 48                      	dec	AX
 34718 00005E2B 8ED8                    	mov	DS,AX			; point to header
 34719 00005E2D 8914                    	mov	[SI],DX 		; assign ownership
 34720                                  
 34721                                  	; MSDOS 6.0
 34722 00005E2F 1E                      	push	DS			;AN000;MS. make ES=DS
 34723 00005E30 07                      	pop	ES			;AN000;MS.
 34724                                  	;mov	di,8
 34725 00005E31 BF0800                  	mov	DI,ARENA.NAME		;AN000;MS. ES:DI points to destination
 34726 00005E34 E86101                  	call	Scan_Execname		;AN007;MS. parse execname
 34727                                  					;	   ds:si->name, cx=name length
 34728 00005E37 51                      	push	CX			;AN007;;MS. save for fake version
 34729 00005E38 56                      	push	SI			;AN007;;MS. save for fake version
 34730                                  
 34731                                  MoveName:				;AN000;
 34732 00005E39 AC                      	lodsb				;AN000;;MS. get char
 34733 00005E3A 3C2E                    	cmp	AL,'.'			;AN000;;MS. is '.', may be name.exe
 34734 00005E3C 7408                    	jz	short Mem_Done		;AN000;;MS. no, move to header
 34735                                  					;AN000;
 34736 00005E3E AA                      	stosb				;AN000;;MS. move char
 34737                                  					; MSKK bug fix - limit length copied
 34738 00005E3F 83FF10                  	cmp	di,16 ; ARENAHEADERSIZE	; end of memory arena block?
 34739 00005E42 7302                    	jae	short Mem_Done		; jump if so
 34740                                  	;
 34741 00005E44 E2F3                    	loop	MoveName		;AN000;;MS. continue
 34742                                  Mem_Done:				;AN000;
 34743 00005E46 30C0                    	xor	AL,AL			;AN000;;MS. make ASCIIZ
 34744                                  	;cmp	di,16
 34745 00005E48 83FF10                  	cmp	DI,ARENAHEADERSIZE ; 16 ;AN000;MS. if not all filled
 34746 00005E4B 7301                    	jae	short Fill8		;AN000;MS.
 34747                                  	
 34748 00005E4D AA                      	stosb				;AN000;MS.
 34749                                  	
 34750                                  Fill8:					;AN000;
 34751 00005E4E 5E                      	pop	SI			;AN007;MS. ds:si -> file name
 34752 00005E4F 59                      	pop	CX			;AN007;MS.
 34753                                  	
 34754 00005E50 E85C01                  	call	Scan_Special_Entries	;AN007;MS.
 34755                                  
 34756                                  	; MSDOS 3.3 (& MSDOS 6.0)
 34757 00005E53 52                      	push	DX
 34758                                  	;mov	si,[bp-16]
 34759 00005E54 8B76F0                  	mov	SI,Exec_Size
 34760 00005E57 01D6                    	add	SI,DX
 34761                                  	;Invoke	$Dup_PDB		; ES is now PDB
 34762 00005E59 E819B2                  	call	_$DUP_PDB
 34763 00005E5C 5A                      	pop	DX
 34764                                  
 34765                                  	;push	word [bp-14]
 34766 00005E5D FF76F2                  	push	Exec_Environ
 34767                                  	;pop	WORD [ES:2Ch]
 34768 00005E60 268F062C00              	pop	word [ES:PDB.ENVIRON]
 34769                                  
 34770                                  	; MSDOS 6.0			; *** Added for DOS 5.00
 34771                                  					; version number in PSP
 34772 00005E65 36FF36[BD0E]             	push	word [ss:SPECIAL_VERSION] ; Set the DOS version number to
 34773 00005E6A 268F064000              	pop	word [ES:PDB.Version]	; to be used for this application
 34774                                  		; PDB.VERSION
 34775                                  
 34776                                  	; MSDOS 3.3 (& MSDOS 6.0)	; set up proper command line stuff
 34777                                  	;lds	si,[bp-4]
 34778 00005E6F C576FC                  	lds	SI,Exec_Blk		; get the block
 34779 00005E72 1E                      	push	DS			; save its location
 34780 00005E73 56                      	push	SI
 34781                                  	;lds	si,[si+6]
 34782 00005E74 C57406                  	lds	SI,[SI+EXEC0.5C_FCB]	; get the 5c fcb
 34783                                  
 34784                                  	; DS points to user space 5C FCB
 34785                                  
 34786 00005E77 B90C00                  	mov	CX,12			; copy drive, name and ext
 34787 00005E7A 51                      	push	CX
 34788 00005E7B BF5C00                  	mov	DI,5Ch
 34789 00005E7E 8A1C                    	mov	BL,[SI]
 34790 00005E80 F3A4                    	rep	movsb
 34791                                  
 34792                                  	; DI = 5Ch + 12 = 5Ch + 0Ch = 68h
 34793                                  
 34794                                  	;xor	AX,AX			; zero extent, etc for CPM
 34795 00005E82 91                      	xchg	ax,cx	; 08/03/2024
 34796 00005E83 AB                      	stosw
 34797 00005E84 AB                      	stosw
 34798                                  
 34799                                  	; DI = 5Ch + 12 + 4 = 5Ch + 10h = 6Ch
 34800                                  
 34801 00005E85 59                      	pop	CX
 34802 00005E86 5E                      	pop	SI			; get block
 34803 00005E87 1F                      	pop	DS
 34804 00005E88 1E                      	push	DS			; save (again)
 34805 00005E89 56                      	push	SI
 34806                                  	;lds	si,[si+0Ah]
 34807 00005E8A C5740A                  	lds	SI,[SI+EXEC0.6C_FCB]	; get 6C FCB
 34808                                  
 34809                                  	; DS points to user space 6C FCB
 34810                                  
 34811 00005E8D 8A3C                    	mov	BH,[SI] 		; do same as above
 34812 00005E8F F3A4                    	rep	movsb
 34813 00005E91 AB                      	stosw
 34814 00005E92 AB                      	stosw
 34815 00005E93 5E                      	pop	SI			; get block (last time)
 34816 00005E94 1F                      	pop	DS
 34817                                  	;ld	si,[si+2]
 34818 00005E95 C57402                  	lds	SI,[SI+EXEC0.COM_LINE]	; command line
 34819                                  
 34820                                  	; DS points to user space 80 command line
 34821                                  
 34822 00005E98 80C980                  	or	CL,80h
 34823 00005E9B 89CF                    	mov	DI,CX
 34824 00005E9D F3A4                    	rep	movsb			; Wham!
 34825                                  
 34826                                  	; Process BX into default AX (validity of drive specs on args).
 34827                                  	; We no longer care about DS:SI.
 34828                                  
 34829 00005E9F FEC9                    	dec	CL			; get 0FFh in CL
 34830 00005EA1 88F8                    	mov	AL,BH
 34831 00005EA3 30FF                    	xor	BH,BH
 34832                                  	;invoke	GetVisDrv
 34833 00005EA5 E8100A                  	call	GetVisDrv
 34834 00005EA8 7302                    	jnc	short Exec_BL
 34835                                  
 34836 00005EAA 88CF                    	mov	BH,CL
 34837                                  
 34838                                  Exec_BL:
 34839 00005EAC 88D8                    	mov	AL,BL
 34840 00005EAE 30DB                    	xor	BL,BL
 34841                                  	;invoke	GetVisDrv
 34842 00005EB0 E8050A                  	call	GetVisDrv
 34843 00005EB3 7302                    	jnc	short Exec_Set_Return
 34844                                  
 34845 00005EB5 88CB                    	mov	BL,CL
 34846                                  
 34847                                  Exec_Set_Return:
 34848                                  	;invoke	Get_User_Stack			; get his return address
 34849 00005EB7 E8C7A5                  	call	Get_User_Stack
 34850                                  
 34851                                  ; 08/03/2024
 34852                                  %if 0
 34853                                  	;push	word [si+14h]
 34854                                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 34855                                  	;push	word [si+12h]
 34856                                  	push	word [SI+user_env.user_IP]
 34857                                  	;push	word [si+14h]
 34858                                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 34859                                  	;push	word [si+12h]
 34860                                  	push	word [SI+user_env.user_IP]
 34861                                  	;pop	word [ES:0Ah]
 34862                                  	pop	WORD [ES:PDB.EXIT]
 34863                                  	;pop	word [ES:0Ch]
 34864                                  	pop	WORD [ES:PDB.EXIT+2]
 34865                                  %else
 34866                                  	; 07/03/2024 (PCDOS 7.1 IBMDOS.COM)
 34867                                  	;;;
 34868                                  	;lds	ax,[si+12h]
 34869 00005EBA C54412                  	lds	ax,[SI+user_env.user_IP] ; suck out the CS and IP
 34870 00005EBD 1E                      	push	ds              
 34871 00005EBE 50                      	push	ax
 34872                                  	;mov	[es:0Ah],ax
 34873 00005EBF 26A30A00                	mov	[ES:PDB.EXIT],ax
 34874                                  	;mov	[es:0Ch],ds
 34875 00005EC3 268C1E0C00              	mov	[ES:PDB.EXIT+2],ds
 34876                                  	;;;
 34877                                  %endif
 34878                                  	
 34879 00005EC8 31C0                    	xor	AX,AX
 34880 00005ECA 8ED8                    	mov	DS,AX
 34881                                  					; save them where we can get them
 34882                                  					; later when the child exits.
 34883                                  	;pop	word [88h]
 34884 00005ECC 8F068800                	pop	word [addr_int_terminate] ; 22h*4
 34885                                  	;pop	word [90h]
 34886 00005ED0 8F068A00                	pop	word [addr_int_terminate+2] ; (22h*4)+2
 34887                                  
 34888 00005ED4 36C706[2C03]8000        	mov	WORD [SS:DMAADD],80h	; SS Override
 34889 00005EDB 368E1E[3003]            	mov	DS,[SS:CurrentPDB]	; SS Override
 34890 00005EE0 368C1E[2E03]            	mov	[SS:DMAADD+2],DS	; SS Override
 34891                                  
 34892                                  	;test	byte [bp-5],1
 34893 00005EE5 F646FB01                	test	Exec_Func,exec_func_no_execute
 34894 00005EE9 7427                    	jz	short exec_go
 34895                                  
 34896 00005EEB 36C536[C00F]            	lds	SI,[SS:exec_init_SP]	; get stack SS Override
 34897                                  	;les	di,[bp-4]
 34898 00005EF0 C47EFC                  	les	DI,Exec_Blk		; and block for return
 34899                                  	;mov	[es:di+10h],ds
 34900 00005EF3 268C5D10                	mov	[ES:DI+EXEC1.SS],DS	; return SS
 34901                                  
 34902 00005EF7 4E                      	dec	SI			; 'push' default AX
 34903 00005EF8 4E                      	dec	SI
 34904 00005EF9 891C                    	mov	[SI],BX 		; save default AX reg
 34905                                  	;mov	[es:di+0Eh], si
 34906 00005EFB 2689750E                	mov	[ES:DI+EXEC1.SP],SI	; return 'SP'
 34907                                  
 34908 00005EFF 36C506[C40F]            	lds	AX,[SS:exec_init_IP]	; SS Override
 34909                                  	;mov	[es:di+14h],ds
 34910 00005F04 268C5D14                	mov	[ES:DI+EXEC1.CS],DS	; initial entry stuff
 34911                                  	;mov	[es:di+12h],ax
 34912 00005F08 26894512                	mov	[ES:DI+EXEC1.IP],AX
 34913                                  	
 34914                                  	;leave
 34915 00005F0C 89EC                    	mov	sp,bp
 34916 00005F0E 5D                      	pop	bp	
 34917                                  
 34918                                  	;transfer SYS_RET_OK
 34919 00005F0F E91FA7                  	jmp	SYS_RET_OK
 34920                                  
 34921                                  exec_go:
 34922 00005F12 36C536[C40F]            	lds	SI,[SS:exec_init_IP]	; get entry point SS Override
 34923 00005F17 36C43E[C00F]            	les	DI,[SS:exec_init_SP]	; new stack SS Override
 34924 00005F1C 8CC0                    	mov	AX,ES
 34925                                  
 34926                                  	; MSDOS 6.0
 34927 00005F1E 36803E[1112]00          	cmp	byte [SS:DosHasHMA],0	; Q: is dos in HMA (M021)
 34928 00005F24 741A                    	je	short Xfer_To_User	; N: transfer control to user
 34929                                  
 34930 00005F26 1E                      	push	ds			; Y: control must go to low mem stub
 34931                                  		
 34932 00005F27 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]		;    where we disable a20 and Xfer 
 34933                                  					;    control to user 
 34934 00005F2C 800E[8600]04            	or	byte [DOS_FLAG],EXECA20OFF ; M068:
 34935                                  					; M004: Set bit to signal int 21
 34936                                  					; ah = 25 & ah= 49. See dossym.inc 
 34937                                  					; under TAG M003 & M009 for 
 34938                                  					; explanation
 34939 00005F31 8916[6300]              	mov	[A20OFF_PSP],dx		; M068: set the PSP for which A20 is
 34940                                  					; M068: going to be turned OFF.
 34941                                  	
 34942 00005F35 8CD8                    	mov	ax,ds			; ax = segment of low mem stub
 34943 00005F37 1F                      	pop	ds
 34944                                  	
 34945 00005F38 50                      	push	ax			; ret far into the low mem stub
 34946 00005F39 B8[1511]                	mov	ax,disa20_xfer
 34947 00005F3C 50                      	push	ax
 34948 00005F3D 8CC0                    	mov	AX,ES			; restore ax
 34949 00005F3F CB                      	retf
 34950                                  
 34951                                  Xfer_To_User:
 34952                                  	; DS:SI points to entry point
 34953                                  	; AX:DI points to initial stack
 34954                                  	; DX has PDB pointer
 34955                                  	; BX has initial AX value
 34956                                  
 34957 00005F40 FA                      	cli
 34958                                  	; 15/08/2018
 34959 00005F41 36C606[2103]00          	mov	BYTE [SS:INDOS],0	; SS Override
 34960                                  
 34961 00005F47 8ED0                    	mov	SS,AX			; set up user's stack
 34962 00005F49 89FC                    	mov	SP,DI			; and SP
 34963 00005F4B FB                      	sti
 34964                                  
 34965 00005F4C 1E                      	push	DS			; fake long call to entry
 34966 00005F4D 56                      	push	SI
 34967 00005F4E 8EC2                    	mov	ES,DX			; set up proper seg registers
 34968 00005F50 8EDA                    	mov	DS,DX
 34969 00005F52 89D8                    	mov	AX,BX			; set up proper AX
 34970                                  
 34971 00005F54 CB                      	retf
 34972                                  
 34973                                  ; 04/08/2018 - Retro DOS v3.0
 34974                                  
 34975                                  ;----------------------------------------------------------------------------
 34976                                  ;
 34977                                  ;----------------------------------------------------------------------------
 34978                                  
 34979                                  ExecRead:
 34980 00005F55 E81600                  	CALL	Exec_Dealloc
 34981                                  	;mov	bx,[bp-8]
 34982 00005F58 8B5EF8                  	MOV	bx,Exec_FH
 34983                                  
 34984 00005F5B 55                      	PUSH	BP
 34985 00005F5C E80807                  	call	_$READ
 34986 00005F5F 5D                      	POP	BP
 34987                                  
 34988                                  	;CALL	Exec_Alloc
 34989                                  	;retn
 34990                                  	; 18/12/2022
 34991                                  	;jmp	short Exec_Alloc
 34992                                  
 34993                                  ; 18/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS) 
 34994                                  
 34995                                  ;----------------------------------------------------------------------------
 34996                                  ;
 34997                                  ;----------------------------------------------------------------------------
 34998                                  
 34999                                  Exec_Alloc:
 35000 00005F60 53                      	push	BX
 35001                                  	;mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
 35002                                  	; 20/05/2019 - Retro DOS v4.0
 35003                                  	; MSDOS 6.0
 35004 00005F61 368B1E[3003]            	mov	bx,[SS:CurrentPDB]  ; SS Override
 35005 00005F66 E81000                  	call	ChangeOwners
 35006 00005F69 E891B3                  	call	LCritMEM
 35007 00005F6C 5B                      	pop	BX
 35008 00005F6D C3                      	retn
 35009                                  
 35010                                  ;----------------------------------------------------------------------------
 35011                                  ;
 35012                                  ;----------------------------------------------------------------------------
 35013                                  
 35014                                  Exec_Dealloc:
 35015 00005F6E 53                      	push	BX
 35016                                  	;mov	bx,0
 35017 00005F6F 29DB                    	sub	BX,BX		; (bx) = ARENA_OWNER_SYSTEM
 35018 00005F71 E86EB3                  	call	ECritMEM
 35019 00005F74 E80200                  	call	ChangeOwners
 35020 00005F77 5B                      	pop	BX
 35021 00005F78 C3                      	retn
 35022                                  
 35023                                  ; 18/12/2022
 35024                                  %if 0
 35025                                  ;----------------------------------------------------------------------------
 35026                                  ;
 35027                                  ;----------------------------------------------------------------------------
 35028                                  
 35029                                  Exec_Alloc:
 35030                                  	push	BX
 35031                                  	;mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
 35032                                  	; 20/05/2019 - Retro DOS v4.0
 35033                                  	; MSDOS 6.0
 35034                                  	mov	bx,[SS:CurrentPDB]  ; SS Override
 35035                                  	call	ChangeOwners
 35036                                  	call	LCritMEM
 35037                                  	pop	BX
 35038                                  	retn
 35039                                  
 35040                                  %endif
 35041                                  
 35042                                  ;----------------------------------------------------------------------------
 35043                                  ;
 35044                                  ;----------------------------------------------------------------------------
 35045                                  
 35046                                  ChangeOwners:
 35047 00005F79 9C                      	pushf
 35048 00005F7A 50                      	push	AX
 35049                                  	;mov	ax,[bp-14]
 35050 00005F7B 8B46F2                  	mov	AX,Exec_Environ
 35051 00005F7E E80900                  	call	ChangeOwner
 35052                                  	;mov	ax,[bp-18]
 35053 00005F81 8B46EE                  	mov	AX,Exec_Load_Block
 35054 00005F84 E80300                  	call	ChangeOwner
 35055 00005F87 58                      	pop	AX
 35056 00005F88 9D                      	popf
 35057                                  chgown_retn:
 35058 00005F89 C3                      	retn
 35059                                  
 35060                                  ;----------------------------------------------------------------------------
 35061                                  ;
 35062                                  ;----------------------------------------------------------------------------
 35063                                  
 35064                                  ChangeOwner:
 35065 00005F8A 09C0                    	or	AX,AX			; is area allocated?
 35066 00005F8C 74FB                    	jz	short chgown_retn	; no, do nothing
 35067 00005F8E 48                      	dec	AX
 35068 00005F8F 1E                      	push	DS
 35069 00005F90 8ED8                    	mov	DS,AX
 35070 00005F92 891E0100                	mov	[ARENA.OWNER],BX
 35071 00005F96 1F                      	pop	DS
 35072 00005F97 C3                      	retn
 35073                                  
 35074                                  ;----------------------------------------------------------------------------
 35075                                  ;
 35076                                  ;----------------------------------------------------------------------------
 35077                                  
 35078                                  ; 20/05/2019 - Retro DOS v4.0
 35079                                  
 35080                                  	; MSDOS 6.0
 35081                                  Scan_Execname:
 35082 00005F98 C576E6                  	lds	SI,ExecName		; DS:SI points to name
 35083                                  Scan_Execname1:				; M028
 35084                                  Save_Begin:				;
 35085 00005F9B 89F1                    	mov	CX,SI			; CX= starting addr
 35086                                  Scan0:					;
 35087 00005F9D AC                      	lodsb				; get char
 35088                                  
 35089 00005F9E 3C3A                    	cmp	AL,':'			; is ':' , may be A:name
 35090 00005FA0 74F9                    	jz	short Save_Begin	; yes, save si
 35091 00005FA2 3C5C                    	cmp	AL,'\'                  ; is '\', may be A:\name
 35092 00005FA4 74F5                    	jz	short Save_Begin	; yes, save si
 35093 00005FA6 3C00                    	cmp	AL,0			; is end of name
 35094 00005FA8 75F3                    	jnz	short Scan0		; no, continue scanning
 35095 00005FAA 29CE                    	sub	SI,CX			; get name's length
 35096 00005FAC 87F1                    	xchg	SI,CX			; cx= length, si= starting addr
 35097                                  
 35098 00005FAE C3                      	retn
 35099                                  
 35100                                  ;----------------------------------------------------------------------------
 35101                                  ;
 35102                                  ;----------------------------------------------------------------------------
 35103                                  
 35104                                  ; 20/05/2019 - Retro DOS v4.0
 35105                                  
 35106                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35107                                  ; DOSCODE:A0EDh (MSDOS 5.0, MSDOS.SYS)
 35108                                  
 35109                                  	; MSDOS 6.0
 35110                                  
 35111                                  Scan_Special_Entries:
 35112                                  
 35113 00005FAF 49                      	dec	CX			; cx= name length
 35114                                  ;M060	mov	DI,[Special_Entries]	; es:di -> addr of special entries
 35115                                  					;reset to current version
 35116                                  	;mov	word [ss:SPECIAL_VERSION],1406h 
 35117                                  				; (MSDOS 6.21, MSDOS.SYS, DOSCODE:A14Eh)
 35118                                  	;mov	word [ss:SPECIAL_VERSION],5
 35119                                  				; (MSDOS 5.0, MSDOS.SYS, DOSCODE:A0EEh)
 35120                                  
 35121                                  				; 5 for Retro DOS 4.0 (01/12/2022, MSDOS 5.0)
 35122 00005FB0 36C706[BD0E]0616        	mov	word [ss:SPECIAL_VERSION],(MINOR_VERSION<<8)+MAJOR_VERSION
 35123                                  				; 0005h for Retro DOS v4.1 (MSDOS 5.0)
 35124                                  				; 24/09/2023
 35125                                  				; 1606h for Retro DOS v4.2 (MSDOS 6.22)
 35126                                  ;***	call	Reset_Version
 35127                                  
 35128                                  ;M060	push	SS
 35129                                  ;M060	pop	ES
 35130                                  
 35131 00005FB7 36C43E[5D00]            	les	DI,[SS:UU_IFS_DOS_CALL]	;M060; ES:DI --> Table in SETVER.SYS
 35132 00005FBC 8CC0                    	mov	AX,ES			;M060; First do a NULL ptr check to
 35133 00005FBE 09F8                    	or	AX,DI			;M060; be sure the table exists
 35134 00005FC0 7427                    	jz	short End_List		;M060; If ZR then no table
 35135                                  
 35136                                  GetEntries:
 35137 00005FC2 268A05                  	mov	AL,[ES:DI]		; end of list
 35138 00005FC5 08C0                    	or	AL,AL
 35139 00005FC7 7420                    	jz	short End_List		; yes
 35140                                  
 35141 00005FC9 36893E[0E06]            	mov	[ss:TEMP_VAR2],DI	; save di
 35142 00005FCE 38C8                    	cmp	AL,CL			; same length ?
 35143 00005FD0 751B                    	jnz	short SkipOne 		; no
 35144                                  
 35145 00005FD2 47                      	inc	DI			; es:di -> special name
 35146 00005FD3 51                      	push	CX			; save length and name addr
 35147 00005FD4 56                      	push	SI
 35148                                  
 35149                                  ; M050 - BEGIN
 35150                                  
 35151 00005FD5 50                      	push	ax			; save len
 35152                                  sse_next_char:
 35153 00005FD6 AC                      	lodsb
 35154 00005FD7 E8E3EE                  	call	UCase
 35155 00005FDA AE                      	scasb
 35156 00005FDB 750D                    	jne	short Not_Matched
 35157 00005FDD E2F7                    	loop	sse_next_char
 35158                                  	
 35159                                  ;	repz	cmpsb			; same name ?
 35160                                  ;	jnz	short Not_Matched	; no
 35161                                  
 35162 00005FDF 58                      	pop	ax			; take len off the stack
 35163                                  
 35164                                  ; M050 - END
 35165                                  
 35166 00005FE0 268B05                  	mov	AX,[ES:DI]		; get special version
 35167 00005FE3 36A3[BD0E]              	mov	[ss:SPECIAL_VERSION],AX	; save it
 35168                                  
 35169                                  ;***	mov	AL,[ES:DI+2]		; get fake count
 35170                                  ;***	mov	[ss:FAKE_COUNT],AL 	; save it
 35171                                  
 35172 00005FE7 5E                      	pop	SI
 35173 00005FE8 59                      	pop	CX
 35174                                  	; 18/12/2022
 35175                                  	;jmp	SHORT End_List
 35176                                  
 35177                                  	; 18/12/2022
 35178                                  End_List:
 35179 00005FE9 C3                      	retn
 35180                                  
 35181                                  Not_Matched:
 35182 00005FEA 58                      	pop	ax			; get len from stack ; M050
 35183 00005FEB 5E                      	pop	SI			; restore si,cx
 35184 00005FEC 59                      	pop	CX
 35185                                  
 35186                                  SkipOne:
 35187 00005FED 368B3E[0E06]            	mov	DI,[ss:TEMP_VAR2]	; restore old di use SS Override
 35188 00005FF2 30E4                    	xor	AH,AH			; position to next entry
 35189 00005FF4 01C7                    	add	DI,AX
 35190                                  
 35191 00005FF6 83C703                  	add	DI,3			; DI -> next entry length
 35192                                  ;***	add	DI,4			; DI -> next entry length
 35193                                  
 35194 00005FF9 EBC7                    	jmp	short GetEntries
 35195                                  
 35196                                  	; 18/12/2022
 35197                                  ;End_List:
 35198                                  	;retn
 35199                                  
 35200                                  ; 04/08/2018 - Retro DOS v3.0
 35201                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 633Dh
 35202                                  
 35203                                  ;----------------------------------------------------------------------------
 35204                                  ;SUBTTL Terminate and stay resident handler
 35205                                  ;
 35206                                  ; Input:    DX is an offset from CurrentPDB at which to
 35207                                  ;	    truncate the current block.
 35208                                  ;
 35209                                  ; output:   The current block is truncated (expanded) to be [DX+15]/16
 35210                                  ;	    paragraphs long. An exit is simulated via resetting CurrentPDB
 35211                                  ;	    and restoring the vectors.
 35212                                  ;
 35213                                  ;----------------------------------------------------------------------------
 35214                                  
 35215                                  	; 20/05/2019 - Retro DOS v4.0
 35216                                  	; DOSCODE:A19Bh (MSDOS 6.21, MSDOS.SYS)
 35217                                  
 35218                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 35219                                  	; DOSCODE:A13Bh (MSDOS 5.0, MSDOS.SYS)
 35220                                  
 35221                                  _$KEEP_PROCESS:
 35222 00005FFB 50                      	push	AX			; keep exit code around
 35223                                  	;mov	byte [SS:EXIT_TYPE],3
 35224 00005FFC 36C606[7C05]03          	mov	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS
 35225 00006002 368E06[3003]            	mov	ES,[SS:CurrentPDB]
 35226 00006007 83FA06                  	cmp	DX,6h			; keep enough space around for system
 35227 0000600A 7303                    	jae	short Keep_Shrink	; info
 35228                                  
 35229 0000600C BA0600                  	mov	DX,6h
 35230                                  
 35231                                  Keep_Shrink:
 35232 0000600F 89D3                    	mov	BX,DX
 35233 00006011 53                      	push	BX
 35234 00006012 06                      	push	ES
 35235 00006013 E82F02                  	call	_$SETBLOCK		; ignore return codes.
 35236 00006016 1F                      	pop	DS
 35237 00006017 5B                      	pop	BX
 35238 00006018 7207                    	jc	short Keep_Done		; failed on modification
 35239                                  
 35240 0000601A 8CD8                    	mov	AX,DS
 35241 0000601C 01D8                    	add	AX,BX
 35242                                  	;mov	[2],ax
 35243 0000601E A30200                  	mov	[PDB.BLOCK_LEN],AX	;PBUGBUG
 35244                                  
 35245                                  Keep_Done:
 35246 00006021 58                      	pop	AX
 35247 00006022 EB26                    	jmp	SHORT exit_inner	; and let abort take care of the rest
 35248                                  
 35249                                  ;----------------------------------------------------------------------------
 35250                                  ;
 35251                                  ;----------------------------------------------------------------------------
 35252                                  
 35253                                  STAY_RESIDENT:
 35254                                  	;mov	ax,3100h
 35255 00006024 B80031                  	mov	AX,(KEEP_PROCESS<<8)+0 ; Lower part is return code;PBUGBUG
 35256 00006027 83C20F                  	add	DX,15
 35257 0000602A D1DA                    	rcr	DX,1
 35258 0000602C B103                    	mov	CL,3
 35259 0000602E D3EA                    	shr	DX,CL
 35260                                  
 35261 00006030 E9D5A2                  	jmp	COMMAND
 35262                                  
 35263                                  ;----------------------------------------------------------------------------
 35264                                  ;SUBTTL $EXIT - return to parent process
 35265                                  ;   Assembler usage:
 35266                                  ;	    MOV     AL, code
 35267                                  ;	    MOV     AH, Exit
 35268                                  ;	    INT     int_command
 35269                                  ;   Error return:
 35270                                  ;	    None.
 35271                                  ;
 35272                                  ;----------------------------------------------------------------------------
 35273                                  
 35274                                  	; 20/05/2019 - Retro DOS v4.0
 35275                                  	; DOSCODE:A1D3h (MSDOS 6.21, MSDOS.SYS)
 35276                                  
 35277                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 35278                                  	; DOSCODE:A173h (MSDOS 5.0, MSDOS.SYS)
 35279                                  _$EXIT:
 35280                                  	; 04/08/2018 - Retro DOS v3.0
 35281                                  	; IBMDOSDOS.COM (MSDOS 3.3, 1987) - Offset 6375h
 35282 00006033 30E4                    	xor	AH,AH
 35283 00006035 368626[4D03]            	xchg	AH,[SS:DidCTRLC]
 35284 0000603A 08E4                    	or	AH,AH
 35285                                  	;mov	BYTE [SS:EXIT_TYPE],0
 35286 0000603C 36C606[7C05]00          	mov	BYTE [SS:EXIT_TYPE],EXIT_TERMINATE
 35287 00006042 7406                    	jz	short exit_inner
 35288                                  	;mov	BYTE [SS:EXIT_TYPE],1
 35289 00006044 36C606[7C05]01          	mov	BYTE [SS:EXIT_TYPE],EXIT_CTRL_C
 35290                                  
 35291                                  	;entry	Exit_inner
 35292                                  exit_inner:
 35293 0000604A E834A4                  	call	Get_User_Stack		;PBUGBUG
 35294                                  
 35295 0000604D 36FF36[3003]            	push	word [ss:CurrentPDB]
 35296                                  	;pop	word [si+14h]
 35297 00006052 8F4414                  	pop	word [SI+user_env.user_CS] ;PBUGBUG
 35298 00006055 EB08                    	jmp	short abort_inner
 35299                                  
 35300                                  ;BREAK <$ABORT -- Terminate a process>
 35301                                  ;----------------------------------------------------------------------------
 35302                                  ; Inputs:
 35303                                  ;	user_CS:00 must point to valid program header block
 35304                                  ; Function:
 35305                                  ;	Restore terminate and Cntrl-C addresses, flush buffers and transfer
 35306                                  ;	to the terminate address
 35307                                  ; Returns:
 35308                                  ;	TO THE TERMINATE ADDRESS
 35309                                  ;----------------------------------------------------------------------------
 35310                                  
 35311                                  _$ABORT:
 35312 00006057 30C0                    	xor	AL,AL
 35313                                  	;mov	byte [SS:EXIT_TYPE],0
 35314                                  	;mov	byte [SS:EXIT_TYPE],AL ; = 0
 35315 00006059 36C606[7C05]00          	mov	byte [SS:EXIT_TYPE],EXIT_ABORT
 35316                                  
 35317                                  	; abort_inner must have AL set as the exit code! The exit type
 35318                                  	; is retrieved from exit_type. Also, the PDB at user_CS needs
 35319                                  	; to be correct as the one that is terminating.
 35320                                  
 35321                                  abort_inner:
 35322 0000605F 368A26[7C05]            	mov	AH,[SS:EXIT_TYPE]
 35323 00006064 36A3[3403]              	mov	[SS:exit_code],AX
 35324 00006068 E816A4                  	call	Get_User_Stack
 35325                                  
 35326                                  	;mov	ds,[si+14h]
 35327 0000606B 8E5C14                  	mov	DS,[SI+user_env.user_CS] ; set up old interrupts ;PBUGBUG
 35328 0000606E 31C0                    	xor	AX,AX
 35329 00006070 8EC0                    	mov	ES,AX
 35330                                  	;mov	si,10
 35331 00006072 BE0A00                  	mov	SI,SAVEXIT
 35332                                  	;mov	di,88h
 35333 00006075 BF8800                  	mov	DI,addr_int_terminate
 35334 00006078 A5                      	movsw
 35335 00006079 A5                      	movsw
 35336 0000607A A5                      	movsw
 35337 0000607B A5                      	movsw
 35338 0000607C A5                      	movsw
 35339 0000607D A5                      	movsw
 35340 0000607E E94EF2                  	jmp	reset_environment
 35341                                  
 35342                                  ;----------------------------------------------------------------------------
 35343                                  ;
 35344                                  ; fixexepatch will point to this is DOS loads low. 
 35345                                  ;
 35346                                  ;----------------------------------------------------------------------------
 35347                                  ; MSDOS 6.0
 35348                                  
 35349                                  ; 29/04/2019 - Retro DOS v4.0
 35350                                  ; DOSCODE:A221h (MSDOS 6.21, MSDOS.SYS)
 35351                                  
 35352                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 35353                                  ; DOSCODE:A1C1h (MSDOS 5.0, MSDOS.SYS)
 35354                                  
 35355                                  RetExePatch: ; proc near
 35356                                  	
 35357 00006081 C3                      	retn
 35358                                  
 35359                                  ;============================================================================
 35360                                  ; ALLOC.ASM, MSDOS 6.0, 1991
 35361                                  ;============================================================================
 35362                                  ; 04/08/2018 - Retro DOS v3.0
 35363                                  ; 14/05/2019 - Retro DOS v4.0
 35364                                  
 35365                                  ;	TITLE ALLOC.ASM - memory arena manager	NAME Alloc
 35366                                  
 35367                                  ;**
 35368                                  ;	Microsoft Confidential
 35369                                  ;	Copyright (C) Microsoft Corporation 1991
 35370                                  ;	All Rights Reserved.
 35371                                  ;
 35372                                  ;	Memory related system calls and low level routines for MSDOS 2.X.
 35373                                  ;	I/O specs are defined in DISPATCH.
 35374                                  ;
 35375                                  ;	$ALLOC
 35376                                  ;	$SETBLOCK
 35377                                  ;	$DEALLOC
 35378                                  ;	$AllocOper
 35379                                  ;	arena_free_process
 35380                                  ;	arena_next
 35381                                  ;	check_signature
 35382                                  ;	Coalesce
 35383                                  ;
 35384                                  ;	Modification history:
 35385                                  ;
 35386                                  ;	    Created: ARR 30 March 1983
 35387                                  ;
 35388                                  ;	    Revision: M000 - added support for allocing UMBs. 7/9/90
 35389                                  ;		      M003 - added support for link/unlink UMBs from
 35390                                  ;			     DOS arena chain. 7/18/90
 35391                                  ;		      M009 - Added error returns invalid function and 
 35392                                  ;			     arena trashed in set link state call.
 35393                                  ;		      M010 - Release UMB arenas allocated to current PDB
 35394                                  ;			     if UMB_HEAD is initialized.
 35395                                  ;
 35396                                  ;		      M016 - MACE utilities mkeyrate.com version 1.0 
 35397                                  ;			     support. Please see under M009 in 
 35398                                  ;			     ..\inc\dossym.inc. 8/31/90.
 35399                                  ;
 35400                                  ;		      M061 - In GetLastArena, if linking in UMBs check to make
 35401                                  ;			     sure that umb_head arena is valid and also make
 35402                                  ;			     sure that the previous arena is pointing to 
 35403                                  ;			     umb_head.
 35404                                  ;
 35405                                  ;		      M064 - allow HIGH_ONLY bit to be set by a call to 
 35406                                  ;			     set allloc strategy.
 35407                                  ;			     use STRAT_MASK to mask out bits 6 & 7 of 
 35408                                  ;			     bx in AllocSetStrat.
 35409                                  ;
 35410                                  ;		      M068 - use a count value (A20OFF_COUNT) rather than
 35411                                  ;			     a bit to indicate to dos dispatcher to turn
 35412                                  ;			     a20 off before iret. See M016.
 35413                                  ;
 35414                                  
 35415                                  ;	BREAK	<memory allocation utility routines>
 35416                                  
 35417                                  
 35418                                  ; 15/04/2018 - Retro DOS v2.0
 35419                                  ;----------------------------------------------------------------------------
 35420                                  ; xenix memory calls for MSDOS
 35421                                  ;
 35422                                  ; CAUTION: The following routines rely on the fact that arena_signature and
 35423                                  ; arena_owner_system are all equal to zero and are contained in DI.
 35424                                  ;
 35425                                  ;INCLUDE DOSSEG.ASM
 35426                                  
 35427                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 35428                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 35429                                  
 35430                                  ;.xlist
 35431                                  ;.xcref
 35432                                  ;INCLUDE DOSSYM.ASM
 35433                                  ;INCLUDE DEVSYM.ASM
 35434                                  ;.cref
 35435                                  ;.list
 35436                                  
 35437                                  ;TITLE ALLOC.ASM - memory arena manager
 35438                                  ;NAME Alloc
 35439                                  
 35440                                  ;SUBTTL memory allocation utility routines
 35441                                  ;PAGE
 35442                                  ;
 35443                                  ; arena data
 35444                                  ;
 35445                                  ;       i_need  arena_head,WORD         ; seg address of start of arena
 35446                                  ;       i_need  CurrentPDB,WORD         ; current process data block addr
 35447                                  ;       i_need  FirstArena,WORD         ; first free block found
 35448                                  ;       i_need  BestArena,WORD          ; best free block found
 35449                                  ;       i_need  LastArena,WORD          ; last free block found
 35450                                  ;       i_need  AllocMethod,BYTE        ; how to alloc first(best)last
 35451                                  
 35452                                  	; 07/07/2024 - Retro DOS v4.2
 35453                                  	; 10/03/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 35454                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:0B443h
 35455                                  	;;;
 35456                                  test_umb_flag:
 35457 00006082 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; 1 ; Q: are umb's linked
 35458 00006088 C3                      	retn                    ; ZF=1 -> N: scan from arena_head
 35459                                  				; ZF=0 -> Y: start_arena = umb_head
 35460                                  	;;;
 35461                                  
 35462                                  ;**	Arena_Free_Process
 35463                                  ;----------------------------------------------------------------------------
 35464                                  ;	Free all arena blocks allocated to a process
 35465                                  ;
 35466                                  ;	ENTRY	(bx) = PID of process
 35467                                  ;	EXIT	none
 35468                                  ;	USES	????? BUGBUG
 35469                                  ;----------------------------------------------------------------------------
 35470                                  
 35471                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 35472                                  	; DOSCODE:A1C2h (MSDOS 5.0, MSDOS.SYS)
 35473                                  
 35474                                  arena_free_process:
 35475                                  	; 14/05/2019 - Retro DOS v4.0
 35476                                  	; 04/08/2018 - Retro DOS v3.0
 35477 00006089 36A1[2400]                      MOV	AX,[SS:arena_head]
 35478                                  arena_free_process_start:
 35479 0000608D BF0000                  	MOV     DI,ARENA.SIGNATURE ; 0
 35480                                  	;MOV	AX,[SS:arena_head] ; 15/04/2018  
 35481 00006090 E82F00                          CALL	check_signature         ; ES <- AX, check for valid block
 35482                                  
 35483                                  arena_free_process_loop:
 35484                                          ;retc
 35485 00006093 7225                            JC	SHORT AFP_RETN	; Retro DOS v2.0 - 05/03/2018
 35486 00006095 06                      	PUSH    ES
 35487 00006096 1F                              POP     DS
 35488                                  	;cmp	[1],bx 
 35489 00006097 391E0100                        CMP     [ARENA.OWNER],BX	; is block owned by pid?
 35490 0000609B 7504                            JNZ     SHORT arena_free_next	; no, skip to next
 35491                                  	;mov	[1],di
 35492 0000609D 893E0100                        MOV     [ARENA.OWNER],DI	; yes... free him
 35493                                  
 35494                                  arena_free_next:
 35495                                  	;cmp	byte [di],5Ah ;'Z'
 35496 000060A1 803D5A                          CMP     BYTE [DI],arena_signature_end
 35497                                                                          ; end of road, Jack?
 35498                                          ;retz				; never come back no more
 35499                                  	;JZ	SHORT AFP_RETN  ; MSDOS 3.3 (& MSDOS 2.11)
 35500                                  	; 14/05/2019
 35501                                  	; MSDOS 6.0
 35502 000060A4 7405                    	jz	short arena_chk_umbs
 35503                                          
 35504 000060A6 E81200                  	CALL    arena_next              ; next item in ES/AX carry set if trash
 35505 000060A9 EBE8                            JMP     SHORT arena_free_process_loop
 35506                                  
 35507                                  	; MSDOS 6.0
 35508                                  arena_chk_umbs:				; M010 - Start
 35509                                  	; 20/05/2019
 35510 000060AB 36A1[8C00]              	mov	ax,[ss:UMB_HEAD]	; ax = umb_head
 35511 000060AF 83F8FF                  	cmp	ax,0FFFFh		; Q: is umb_head initialized
 35512 000060B2 741D                    	je	short ret_label		; N: we're done
 35513                                  	
 35514 000060B4 8CDF                    	mov	di,ds			; di = last arena
 35515 000060B6 39C7                    	cmp	di,ax			; Q: is last arena above umb_head
 35516                                  	;jae	short ret_label		; Y: we've scanned umbs also. done.
 35517                                  	;jmp	short arena_free_process_start
 35518                                  					; M010 - End
 35519                                  	; 10/03/2024 (PCDOS 7.1 IBMDOS.COM)
 35520 000060B8 72D3                    	jb	short arena_free_process_start
 35521                                  
 35522                                  	; 10/03/2024
 35523                                  AFP_RETN:
 35524 000060BA C3                      	RETN
 35525                                  
 35526                                  ;	BREAK	<Arena Helper Routines>
 35527                                  
 35528                                  ;**	Arena_Next - Find Next item in Arena
 35529                                  ;----------------------------------------------------------------------------
 35530                                  ;	ENTRY	DS - pointer to block head
 35531                                  ;		(di) = 0
 35532                                  ;	EXIT	AX,ES - pointers to next head
 35533                                  ;		'C' set iff arena damaged
 35534                                  ;----------------------------------------------------------------------------
 35535                                  
 35536                                  arena_next:
 35537 000060BB 8CD8                            MOV     AX,DS                   ; AX <- current block
 35538 000060BD 03060300                        ADD     AX,[ARENA.SIZE]		; AX <- AX + current block length
 35539 000060C1 40                              INC     AX                      ; remember that header!
 35540                                  
 35541                                  ;       fall into check_signature and return
 35542                                  ;
 35543                                  ;       CALL    check_signature         ; ES <- AX, carry set if error
 35544                                  ;       RETN
 35545                                  
 35546                                  ;**	Check_Signature - Check Memory Block Signature
 35547                                  ;----------------------------------------------------------------------------
 35548                                  ;	ENTRY	(AX) = address of block header
 35549                                  ;		(di) = 0
 35550                                  ;	EXIT	 ES = AX
 35551                                  ;		'C' clear if signature good
 35552                                  ;		'C' set if signature bad
 35553                                  ;	USES	ES, Flags
 35554                                  ;----------------------------------------------------------------------------
 35555                                  
 35556                                  check_signature:        
 35557                                  
 35558 000060C2 8EC0                    	MOV     ES,AX                   ; ES <- AX
 35559                                  	;cmp	byte [es:di],4Dh ; 'M'
 35560 000060C4 26803D4D                        CMP     BYTE [ES:DI],arena_signature_normal
 35561                                                                          ; IF next signature = not_end THEN
 35562 000060C8 7407                            JZ      SHORT check_signature_ok ;   GOTO ok
 35563                                  	;cmp 	byte [es:di],5Ah ; 'Z'
 35564 000060CA 26803D5A                        CMP     BYTE [ES:DI],arena_signature_end
 35565                                                                          ; IF next signature = end then
 35566 000060CE 7401                            JZ      SHORT check_signature_ok ;   GOTO ok
 35567 000060D0 F9                              STC                             ; set error
 35568                                  ret_label: ; MSDOS 6.0
 35569                                  ;AFP_RETN:	; 10/03/2024
 35570                                   	; Retro DOS v2.0 - 05/03/2018
 35571                                  check_signature_ok:
 35572                                  COALESCE_RETN:
 35573 000060D1 C3                      	RETN
 35574                                  
 35575                                  ;**	Coalesce - Combine free blocks ahead with current block
 35576                                  ;----------------------------------------------------------------------------
 35577                                  ;	Coalesce adds the block following the argument to the argument block,
 35578                                  ;	iff it's free.  Coalesce is usually used to join free blocks, but
 35579                                  ;	some callers (such as $setblock) use it to join a free block to it's
 35580                                  ;	preceeding allocated block.
 35581                                  ;
 35582                                  ;	ENTRY	(ds) = pointer to the head of a free block
 35583                                  ;		(di) = 0
 35584                                  ;	EXIT	'C' clear if OK
 35585                                  ;		  (ds) unchanged, this block updated
 35586                                  ;		  (ax) = address of next block, IFF not at end
 35587                                  ;		'C' set if arena trashed
 35588                                  ;	USES	(cx)
 35589                                  ;----------------------------------------------------------------------------
 35590                                          
 35591                                  Coalesce:
 35592                                  	;cmp	byte [di],5Ah ; 'Z'
 35593 000060D2 803D5A                  	CMP     BYTE [DI],arena_signature_end
 35594                                                                          ; IF current signature = END THEN
 35595                                          ;retz				;   GOTO ok
 35596 000060D5 74FA                            jz	short COALESCE_RETN
 35597 000060D7 E8E1FF                  	CALL    arena_next              ; ES, AX <- next block, Carry set if error
 35598                                          ;retc				; IF no error THEN GOTO check
 35599 000060DA 72F5                    	jc	short COALESCE_RETN
 35600                                  
 35601                                  coalesce_check:
 35602                                  	;cmp	[es:1],di
 35603 000060DC 26393E0100                      CMP     [ES:ARENA.OWNER],DI
 35604                                          ;retnz				; IF next block isnt free THEN return
 35605 000060E1 75EE                            JNZ	SHORT COALESCE_RETN
 35606                                  	;mov	cx,[ES:3]
 35607 000060E3 268B0E0300              	MOV     CX,[ES:ARENA.SIZE]	; CX <- next block size
 35608 000060E8 41                              INC     CX                      ; CX <- CX + 1 (for header size)
 35609                                          ;ADD	[3],CX
 35610 000060E9 010E0300                	ADD     [ARENA.SIZE],CX		; current size <- current size + CX
 35611 000060ED 268A0D                          MOV     CL,[ES:DI]              ; move up signature
 35612 000060F0 880D                            MOV     [DI],CL
 35613 000060F2 EBDE                            JMP     SHORT Coalesce		; try again
 35614                                  
 35615                                  ; 04/08/2018 - Retro DOS v3.0
 35616                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 641Fh
 35617                                  
 35618                                  ;	BREAK  <$Alloc - allocate space in memory>
 35619                                  
 35620                                  ; MSDOS 6.0
 35621                                  ;----------------------------------------------------------------------------
 35622                                  ;**	$Alloc - Allocate Memory Space
 35623                                  ;
 35624                                  ;	$Alloc services the INT21 that allocates memory space to a program.
 35625                                  ;	Alloc returns a pointer to a free block of memory that
 35626                                  ;	has the requested size in paragraphs.
 35627                                  ;
 35628                                  ;	If the allocation strategy is HIGH_FIRST or HIGH_ONLY memory is 
 35629                                  ;	scanned from umb_head if not from arena_head. If the strategy is
 35630                                  ; 	HIGH_FIRST the scan is continued from arena_head if a block of 
 35631                                  ;	appropriate size is not found in the UMBs. If the strategy is 
 35632                                  ;	HIGH_FIRST+HIGH_ONLY only the UMBs are scanned for memory.
 35633                                  ;
 35634                                  ;	In either case if bit 0 of UmbFlag is not initialized then the scan
 35635                                  ;	starts from arena_head.
 35636                                  ;
 35637                                  ;	Assembler usage:
 35638                                  ;           MOV     BX,size
 35639                                  ;           MOV     AH,Alloc
 35640                                  ;           INT     21h
 35641                                  ;
 35642                                  ;	BUGBUG - a lot can be done to improve performance. We can set marks
 35643                                  ;	so that we start searching the arena at it's first non-trivial free
 35644                                  ;	block, we can peephole the code, etc. (We can move some subr calls
 35645                                  ;	inline, etc.) I assume that this is called rarely and that the arena
 35646                                  ;	doesn't have too many memory objects in it beyond the first free one.
 35647                                  ;	verify that this is true; if so, this can stay as is
 35648                                  ;
 35649                                  ;	ENTRY	(bx) = requested size, in bytes
 35650                                  ;		(DS) = (ES) = DOSGROUP
 35651                                  ;	EXIT	'C' clear if memory allocated
 35652                                  ;		  (ax:0) = address of requested memory
 35653                                  ;		'C' set if request failed
 35654                                  ;		  (AX) = error_not_enough_memory
 35655                                  ;		    (bx) = max size we could have allocated
 35656                                  ;		  (ax) = error_arena_trashed
 35657                                  ;	USES	All
 35658                                  ;----------------------------------------------------------------------------
 35659                                  
 35660                                  ; MSDOS 2.11 (& MSDOS 3.3)
 35661                                  ;----------------------------------------------------------------------------
 35662                                  ;SUBTTL $Alloc - allocate space in memory
 35663                                  ;
 35664                                  ;   Assembler usage:
 35665                                  ;           MOV     BX,size
 35666                                  ;           MOV     AH,Alloc
 35667                                  ;           INT     21h
 35668                                  ;         AX:0 is pointer to allocated memory
 35669                                  ;         BX is max size if not enough memory
 35670                                  ;
 35671                                  ;   Description:
 35672                                  ;           Alloc returns  a  pointer  to  a  free  block of
 35673                                  ;       memory that has the requested  size  in  paragraphs.
 35674                                  ;
 35675                                  ;   Error return:
 35676                                  ;           AX = error_not_enough_memory
 35677                                  ;              = error_arena_trashed
 35678                                  ;----------------------------------------------------------------------------
 35679                                  
 35680                                  ; DOSCODE:A28Eh (MSDOS 6.21, MSDOS.SYS)
 35681                                  
 35682                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 35683                                  ; DOSCODE:A22Eh (MSDOS 5.0, MSDOS.SYS)
 35684                                  
 35685                                  _$ALLOC:
 35686                                  	; 25/05/2019 (Procedure has been checked and confirmed)
 35687                                  	; 14/05/2019 - Retro DOS v4.0
 35688                                  	; 04/08/2018 - Retro DOS v3.0
 35689                                  	;EnterCrit critMem
 35690 000060F4 E8EBB1                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 35691                                  
 35692                                  ; 17/12/2022
 35693                                  ; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35694                                  ;%if 0
 35695                                  	; 14/05/2019
 35696 000060F7 16                      	push	ss
 35697 000060F8 1F                      	pop	ds
 35698                                  
 35699                                  	; MSDOS 6.0
 35700                                  	;mov	ax,[ss:arena_head]
 35701                                  	;mov	[ss:START_ARENA],ax	; assume LOW_FIRST
 35702                                  
 35703 000060F9 A1[2400]                	mov	ax,[arena_head]
 35704 000060FC A3[8E00]                	mov	[START_ARENA],ax
 35705                                  	
 35706                                  	;test	byte [ss:AllocMethod],HIGH_FIRST+HIGH_ONLY
 35707 000060FF F606[0203]C0            	test	byte [AllocMethod],HIGH_FIRST+HIGH_ONLY
 35708                                  					; Q: should we start scanning from
 35709                                  					;    UMB's
 35710 00006104 740B                    	jz	short norm_alloc	; N: scan from arena_head
 35711                                  		
 35712                                  	;;cmp	word [ss:UMB_HEAD],-1	; Q: Has umb_head been initialized
 35713                                  	;cmp	word [UMB_HEAD],-1
 35714                                  	;je	short norm_alloc	; N: scan from arena_head
 35715                                  
 35716                                  ; 07/07/2024
 35717                                  %if 0
 35718                                  	;;cmp	word [ss:UMB_HEAD],-1	; Q: Has umb_head been initialized
 35719                                  	;cmp	word [UMB_HEAD],-1
 35720                                  	;je	short norm_alloc	; N: scan from arena_head
 35721                                  
 35722                                  	;test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 35723                                  	test	byte [UMBFLAG],LINKSTATE ; 1
 35724                                  	jz	short norm_alloc	; N: scan from arena_head
 35725                                  %else
 35726                                  	; 10/03/2024 (PCDOS 7.1 IBMDOS.COM)
 35727                                  	;;;
 35728 00006106 E879FF                  	call	test_umb_flag
 35729 00006109 7406                    	jz      short norm_alloc
 35730                                  	;;;
 35731                                  %endif
 35732                                  	
 35733                                  	;mov	ax,[ss:UMB_HEAD]
 35734                                  	;mov	[ss:START_ARENA],ax	; start_arena = umb_head
 35735 0000610B A1[8C00]                	mov	ax,[UMB_HEAD]
 35736 0000610E A3[8E00]                	mov	[START_ARENA],ax
 35737                                  					; M000 - end
 35738                                  norm_alloc:
 35739 00006111 31C0                            XOR     AX,AX
 35740 00006113 89C7                            MOV     DI,AX
 35741                                  	; 15/03/2018
 35742                                          ;MOV	[SS:FirstArena],AX	; init the options
 35743                                          ;MOV	[SS:BestArena],AX
 35744                                          ;MOV	[SS:LastArena],AX
 35745                                  	; 14/05/2019
 35746 00006115 A3[4003]                	MOV	[FirstArena],AX		; init the options
 35747 00006118 A3[4203]                        MOV	[BestArena],AX
 35748 0000611B A3[4403]                        MOV	[LastArena],AX
 35749 0000611E 50                              PUSH    AX                      ; alloc_max <- 0
 35750                                  	; 04/08/2018
 35751                                  start_scan:
 35752                                  	;MOV	AX,[SS:arena_head]	; AX <- beginning of arena
 35753                                  	;MOV	AX,[arena_head]
 35754                                  
 35755                                  	; 14/05/2019	
 35756                                  	; MSDOS 6.0
 35757                                  	;mov	ax,[SS:START_ARENA]	; M000: AX <- beginning of arena
 35758 0000611F A1[8E00]                	mov	ax,[START_ARENA]
 35759                                  
 35760                                  	; 27/09/2023 (BugFix) (*)
 35761                                  	; ( jump from 'alloc_chk' (ds<>ss, ax = [SS:START_ARENA]))
 35762                                  start_scan_x:
 35763                                  
 35764 00006122 E89DFF                  	CALL    check_signature         ; ES <- AX, carry set if error
 35765 00006125 7233                            JC      SHORT alloc_err		; IF error THEN GOTO err
 35766                                  
 35767                                  ;%endif
 35768                                  
 35769                                  ; 17/12/2022
 35770                                  %if 0
 35771                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35772                                  
 35773                                  	; MSDOS 6.0
 35774                                  	mov	ax,[ss:arena_head]
 35775                                  	mov	[ss:START_ARENA],ax	; assume LOW_FIRST
 35776                                  
 35777                                  	test	byte [ss:AllocMethod],HIGH_FIRST+HIGH_ONLY
 35778                                  					; Q: should we start scanning from
 35779                                  					;    UMB's
 35780                                  	jz	short norm_alloc	; N: scan from arena_head
 35781                                  		
 35782                                  	;cmp	word [ss:UMB_HEAD],-1	; Q: Has umb_head been initialized
 35783                                  	;je	short norm_alloc	; N: scan from arena_head
 35784                                  
 35785                                  	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 35786                                  	jz	short norm_alloc	; N: scan from arena_head
 35787                                  	
 35788                                  	mov	ax,[ss:UMB_HEAD]
 35789                                  	mov	[ss:START_ARENA],ax	; start_arena = umb_head
 35790                                  					; M000 - end
 35791                                  norm_alloc:
 35792                                          XOR     AX,AX
 35793                                          MOV     DI,AX
 35794                                  	; 15/03/2018
 35795                                  	MOV	[SS:FirstArena],AX	; init the options
 35796                                  	MOV	[SS:BestArena],AX
 35797                                  	MOV	[SS:LastArena],AX
 35798                                          PUSH    AX                      ; alloc_max <- 0
 35799                                  	; 04/08/2018
 35800                                  start_scan:
 35801                                  	;MOV	AX,[SS:arena_head]	; AX <- beginning of arena
 35802                                  	; 14/05/2019	
 35803                                  	; MSDOS 6.0
 35804                                  	mov	ax,[SS:START_ARENA]	; M000: AX <- beginning of arena
 35805                                  	CALL    check_signature         ; ES <- AX, carry set if error
 35806                                          JC      SHORT alloc_err		; IF error THEN GOTO err
 35807                                  %endif
 35808                                  
 35809                                  alloc_scan:
 35810 00006127 06                              PUSH    ES
 35811 00006128 1F                              POP     DS                      ; DS <- ES
 35812 00006129 393E0100                        CMP     [ARENA.OWNER],DI ; 0
 35813 0000612D 7466                            JZ      SHORT alloc_free	; IF current block is free THEN examine
 35814                                  
 35815                                  alloc_next:
 35816                                  
 35817                                  ; 07/07/2024
 35818                                  %if 0
 35819                                  	; MSDOS 6.0			; M000 - start
 35820                                  	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 35821                                  	jz	short norm_strat	; N: see if we reached last arena
 35822                                  %else
 35823                                  	; 10/03/2024 (PCDOS 7.1 IBMDOS.COM)
 35824                                  	;;;
 35825 0000612F E850FF                  	call	test_umb_flag
 35826 00006132 741C                    	jz      short norm_strat
 35827                                  	;;;
 35828                                  %endif
 35829 00006134 36F606[0203]80          	test	byte [ss:AllocMethod],HIGH_FIRST
 35830                                  					; Q: is alloc strategy high_first
 35831 0000613A 7414                    	jz	short norm_strat	; N: see if we reached last arena
 35832 0000613C 36A1[8E00]              	mov	ax,[ss:START_ARENA]
 35833 00006140 363B06[2400]            	cmp	ax,[ss:arena_head]	; Q: did we start scan from 
 35834                                  					;    arena_head
 35835 00006145 7509                    	jne	short norm_strat	; N: see if we reached last arena
 35836 00006147 8CD8                    	mov	ax,ds			; ax = current block
 35837 00006149 363B06[8C00]            	cmp	ax,[ss:UMB_HEAD]	; Q: check against umb_head 
 35838 0000614E EB03                    	jmp	short alloc_chk_end
 35839                                  
 35840                                  norm_strat:
 35841                                  	;cmp	byte [di],5Ah ; 'Z'
 35842 00006150 803D5A                          CMP     BYTE [DI],arena_signature_end
 35843                                                                          ; IF current block is last THEN
 35844                                  alloc_chk_end:
 35845 00006153 740E                            JZ      SHORT alloc_end		;   GOTO end
 35846 00006155 E863FF                          CALL    arena_next              ; AX, ES <- next block, Carry set if error
 35847 00006158 73CD                            JNC     SHORT alloc_scan	; IF no error THEN GOTO scan
 35848                                  
 35849                                  alloc_err:
 35850 0000615A 58                              POP     AX
 35851                                  
 35852                                  alloc_trashed:
 35853                                  	;LeaveCrit critMem
 35854 0000615B E89FB1                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 35855                                          ;error	error_arena_trashed
 35856                                  	;mov	al,7
 35857 0000615E B007                    	MOV	AL,error_arena_trashed
 35858                                  alloc_errj:
 35859 00006160 E9D7A4                  	JMP	SYS_RET_ERR
 35860                                  
 35861                                  alloc_end:
 35862                                  	; 18/05/2019
 35863 00006163 36833E[4003]00                  CMP	WORD [SS:FirstArena],0
 35864 00006169 7403                    	jz	short alloc_chk 
 35865 0000616B E98400                  	jmp	alloc_do_split
 35866                                  
 35867                                  alloc_chk:
 35868                                  	; MSDOS 6.0
 35869 0000616E 36A1[2400]              	mov	ax,[ss:arena_head]
 35870 00006172 363B06[8E00]            	cmp	ax,[ss:START_ARENA]	; Q: started scanning from arena_head
 35871 00006177 740E                    	je	short alloc_fail	; Y: not enough memory
 35872                                  					; N:
 35873                                  					; Q: is the alloc strat HIGH_ONLY
 35874 00006179 36F606[0203]40          	test 	byte [ss:AllocMethod],HIGH_ONLY
 35875 0000617F 7506                    	jnz	short alloc_fail	; Y: return size of largest UMB
 35876                                  	
 35877 00006181 36A3[8E00]              	mov	[ss:START_ARENA],ax	; N: start scanning from arena_head
 35878                                  	; 27/09/2023 (*)
 35879 00006185 EB9B                    	jmp	short start_scan_x ; (*) ; (BugFix)
 35880                                  	;jmp	short start_scan
 35881                                  					; M000 - end
 35882                                  
 35883                                  alloc_fail:
 35884                                          ;invoke Get_User_Stack
 35885 00006187 E8F7A2                          CALL	Get_User_Stack
 35886 0000618A 5B                      	POP     BX
 35887                                          ;MOV	[SI].user_BX,BX
 35888                                  	;MOV	[SI+2],BX
 35889 0000618B 895C02                  	mov	[SI+user_env.user_BX],bx
 35890                                  	;LeaveCrit critMem
 35891 0000618E E86CB1                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 35892                                  	;error	error_not_enough_memory
 35893                                  	;mov	al,8
 35894 00006191 B008                    	MOV	AL,error_not_enough_memory
 35895                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35896 00006193 EBCB                    	jmp	short alloc_errj
 35897                                  	;JMP	SYS_RET_ERR
 35898                                  
 35899                                  alloc_free:
 35900 00006195 E83AFF                          CALL    Coalesce		; add following free block to current
 35901 00006198 72C0                            JC	SHORT alloc_err		; IF error THEN GOTO err
 35902 0000619A 8B0E0300                        MOV     CX,[ARENA.SIZE]
 35903 0000619E 5A                              POP     DX                      ; check for max found size
 35904 0000619F 39D1                            CMP     CX,DX
 35905 000061A1 7602                            JNA     SHORT alloc_test
 35906 000061A3 89CA                            MOV     DX,CX
 35907                                  
 35908                                  alloc_test:
 35909 000061A5 52                              PUSH    DX
 35910 000061A6 39CB                            CMP     BX,CX                   ; IF BX > size of current block THEN
 35911 000061A8 7785                    	JA      SHORT alloc_next	;   GOTO next
 35912                                  
 35913                                  	; 15/03/2018
 35914 000061AA 36833E[4003]00                  CMP     WORD [SS:FirstArena],0
 35915 000061B0 7505                    	JNZ	SHORT alloc_best
 35916 000061B2 368C1E[4003]                    MOV     [SS:FirstArena],DS	; save first one found	
 35917                                  alloc_best:
 35918 000061B7 36833E[4203]00                  CMP     WORD [SS:BestArena],0
 35919 000061BD 740E                            JZ      SHORT alloc_make_best	; initial best
 35920 000061BF 06                              PUSH	ES
 35921 000061C0 368E06[4203]                    MOV     ES,[SS:BestArena]
 35922 000061C5 26390E0300                      CMP     [ES:ARENA.SIZE],CX	; is size of best larger than found?
 35923 000061CA 07                              POP	ES
 35924 000061CB 7605                            JBE     SHORT alloc_last
 35925                                  alloc_make_best:
 35926 000061CD 368C1E[4203]                    MOV     [SS:BestArena],DS	; assign best
 35927                                  alloc_last:
 35928 000061D2 368C1E[4403]                    MOV     [SS:LastArena],DS 	; assign last
 35929 000061D7 E955FF                          JMP     alloc_next
 35930                                  ;
 35931                                  ; split the block high
 35932                                  ;
 35933                                  alloc_do_split_high:
 35934 000061DA 368E1E[4403]                    MOV     DS,[SS:LastArena]
 35935 000061DF 8B0E0300                        MOV     CX,[ARENA.SIZE]
 35936 000061E3 29D9                            SUB     CX,BX
 35937 000061E5 8CDA                            MOV     DX,DS
 35938 000061E7 7449                            JE      SHORT alloc_set_owner	; sizes are equal, no split
 35939 000061E9 01CA                            ADD     DX,CX                   ; point to next block
 35940 000061EB 8EC2                            MOV     ES,DX                   ; no decrement!
 35941 000061ED 49                              DEC     CX
 35942 000061EE 87D9                            XCHG    BX,CX                   ; bx has size of lower block
 35943 000061F0 EB2B                            JMP     SHORT alloc_set_sizes	; cx has upper (requested) size
 35944                                  ;
 35945                                  ; we have scanned memory and have found all appropriate blocks
 35946                                  ; check for the type of allocation desired; first and best are identical
 35947                                  ; last must be split high
 35948                                  ;
 35949                                  alloc_do_split:
 35950                                  
 35951                                  ; 17/12/2022
 35952                                  ; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35953                                  ;%if 0
 35954                                  	; 14/05/2019
 35955                                  	; MSDOS 6.0			; M000 - start
 35956                                  	;xor	cx,cx
 35957 000061F2 368A0E[0203]            	mov	cl,[ss:AllocMethod]
 35958                                  	;and	cx,STRAT_MASK ; 0FF3Fh	; mask off bit 7
 35959 000061F7 80E13F                  	and	cl,3Fh
 35960                                  	;cmp	cx,BEST_FIT ; 1		; Q; is the alloc strategy best_fit
 35961 000061FA 80F901                  	cmp	cl,BEST_FIT
 35962 000061FD 77DB                    	ja	short alloc_do_split_high
 35963                                  ;%endif
 35964                                  
 35965                                  	; 17/12/2022
 35966                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35967                                  	; MSDOS 6.0 & MSDOS 5.0
 35968                                  	;xor	cx,cx
 35969                                  	;mov	cl,[ss:AllocMethod]
 35970                                  	;and	cx,STRAT_MASK ; 0FF3Fh	; mask off bit 7
 35971                                  	;cmp	cx,BEST_FIT ; 1		; Q; is the alloc strategy best_fit
 35972                                  	;ja	short alloc_do_split_high
 35973                                  
 35974                                  	; 15/03/2018
 35975                                          ;;CMP	BYTE [SS:AllocMethod], 1
 35976                                  	; 04/08/2018
 35977                                  	;CMP	BYTE [SS:AllocMethod],BEST_FIT
 35978                                          ;JA	SHORT alloc_do_split_high
 35979                                          
 35980 000061FF 368E1E[4003]            	MOV     DS,[SS:FirstArena]
 35981 00006204 7205                    	JB      SHORT alloc_get_size
 35982 00006206 368E1E[4203]            	MOV     DS,[SS:BestArena]
 35983                                  
 35984                                  alloc_get_size:
 35985 0000620B 8B0E0300                        MOV     CX,[ARENA.SIZE]
 35986 0000620F 29D9                            SUB     CX,BX                   ; get room left over
 35987 00006211 8CD8                            MOV     AX,DS
 35988 00006213 89C2                            MOV     DX,AX                   ; save for owner setting
 35989 00006215 741B                            JE      SHORT alloc_set_owner	; IF BX = size THEN (don't split)
 35990 00006217 01D8                            ADD     AX,BX
 35991 00006219 40                              INC     AX                      ; remember the header
 35992 0000621A 8EC0                            MOV     ES,AX                   ; ES <- DS + BX (new header location)
 35993 0000621C 49                              DEC     CX                      ; CX <- size of split block
 35994                                  alloc_set_sizes:
 35995 0000621D 891E0300                        MOV     [ARENA.SIZE],BX		; current size <- BX
 35996 00006221 26890E0300                      MOV     [ES:ARENA.SIZE],CX      ; split size <- CX
 35997                                  	;mov	bl,4Dh ; 'M'
 35998 00006226 B34D                            MOV     BL,arena_signature_normal
 35999 00006228 861D                            XCHG    BL,[DI]			; current signature <- 4D
 36000 0000622A 26881D                          MOV     [ES:DI],BL		; new block sig <- old block sig
 36001 0000622D 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 36002                                  
 36003                                  alloc_set_owner:
 36004 00006232 8EDA                            MOV     DS,DX
 36005 00006234 36A1[3003]                      MOV     AX,[SS:CurrentPDB] ; 15/03/2018
 36006 00006238 A30100                          MOV     [ARENA.OWNER],AX
 36007 0000623B 8CD8                            MOV     AX,DS
 36008 0000623D 40                              INC     AX
 36009 0000623E 5B                              POP     BX
 36010                                  	;LeaveCrit critMem
 36011 0000623F E8BBB0                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 36012                                  	
 36013                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36014                                  alloc_ok:
 36015                                          ;transfer SYS_RET_OK
 36016 00006242 E9ECA3                  	JMP	SYS_RET_OK
 36017                                  
 36018                                  ;	BREAK $SETBLOCK - change size of an allocated block (if possible)
 36019                                  
 36020                                  ; MSDOS 6.0
 36021                                  ;----------------------------------------------------------------------------
 36022                                  ;**	$SETBLOCK - Change size of an Allocated Block
 36023                                  ;
 36024                                  ;	Setblock changes the size of an allocated block. First, we coalesce
 36025                                  ;	any following free space onto this block; then we try to trim the
 36026                                  ;	block down to the size requested.
 36027                                  ;
 36028                                  ;	Note that if the guy wants to grow the block but that growth fails,
 36029                                  ;	we still go ahead and coalesce any trailing free blocks onto it.
 36030                                  ;	Thus the maximum-size-possible value that we return has already
 36031                                  ;	been allocated! This is a bug, dare we fix it? BUGBUG
 36032                                  ;
 36033                                  ;	NOTE - $SETBLOCK is in bed with $ALLOC and jumps into $ALLOC to
 36034                                  ;		finish it's work. For this reason we build the allocsf
 36035                                  ;		structure on the frame, to make us compatible with $ALLOCs
 36036                                  ;		code.
 36037                                  ;
 36038                                  ;	ENTRY	(es) = segment of old block
 36039                                  ;		(bx) = newsize
 36040                                  ;		(ah) = SETBLOCK
 36041                                  ;
 36042                                  ;	EXIT	'C' clear if OK
 36043                                  ;		'C' set if error
 36044                                  ;		  (ax) = error_invalid_block
 36045                                  ;		       = error_arena_trashed
 36046                                  ;		       = error_not_enough_memory
 36047                                  ;		       = error_invalid_function
 36048                                  ;		  (bx) = maximum size possible, iff (ax) = error_not_enough_memory
 36049                                  ;	USES	???? BUGBUG
 36050                                  ;----------------------------------------------------------------------------
 36051                                  
 36052                                  ; MSDOS 2.11 (& MSDOS 3.3)
 36053                                  ;----------------------------------------------------------------------------
 36054                                  ;SUBTTL $SETBLOCK - change size of an allocated block (if possible)
 36055                                  ;
 36056                                  ;   Assembler usage:
 36057                                  ;           MOV     ES,block
 36058                                  ;           MOV     BX,newsize
 36059                                  ;           MOV     AH,setblock
 36060                                  ;           INT     21h
 36061                                  ;         if setblock fails for growing, BX will have the maximum
 36062                                  ;         size possible
 36063                                  ;   Error return:
 36064                                  ;           AX = error_invalid_block
 36065                                  ;              = error_arena_trashed
 36066                                  ;              = error_not_enough_memory
 36067                                  ;              = error_invalid_function
 36068                                  ;----------------------------------------------------------------------------
 36069                                  
 36070                                  _$SETBLOCK:        
 36071                                  	; 04/08/2018 - Retro DOS v3.0
 36072                                  	;EnterCrit   critMem
 36073 00006245 E89AB0                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 36074                                  
 36075 00006248 BF0000                  	MOV     DI,ARENA.SIGNATURE
 36076 0000624B 8CC0                            MOV     AX,ES
 36077 0000624D 48                              DEC     AX
 36078 0000624E E871FE                          CALL    check_signature
 36079 00006251 7303                            JNC     SHORT setblock_grab
 36080                                  
 36081                                  setblock_bad:
 36082 00006253 E905FF                          JMP     alloc_trashed
 36083                                  
 36084                                  setblock_grab:
 36085 00006256 8ED8                            MOV     DS,AX
 36086 00006258 E877FE                          CALL    Coalesce
 36087 0000625B 72F6                            JC      SHORT setblock_bad
 36088 0000625D 8B0E0300                        MOV     CX,[ARENA.SIZE]
 36089 00006261 51                              PUSH    CX
 36090 00006262 39CB                            CMP     BX,CX
 36091 00006264 76A5                            JBE     SHORT alloc_get_size
 36092 00006266 E91EFF                          JMP     alloc_fail
 36093                                  
 36094                                  ;	BREAK $DEALLOC - free previously allocated piece of memory
 36095                                  
 36096                                  ; MSDOS 6.0
 36097                                  ;----------------------------------------------------------------------------
 36098                                  ;**	$DEALLOC - Free Heap Memory
 36099                                  ;
 36100                                  ;	ENTRY	(es) = address of item
 36101                                  ;
 36102                                  ;	EXIT	'C' clear of OK
 36103                                  ;		'C' set if error
 36104                                  ;		  (AX) = error_invalid_block
 36105                                  ;	USES	???? BUGBUG
 36106                                  
 36107                                  ; MSDOS 2.11 (& MSDOS 3.3)
 36108                                  ;----------------------------------------------------------------------------
 36109                                  ;SUBTTL $DEALLOC - free previously allocated piece of memory
 36110                                  ;
 36111                                  ;   Assembler usage:
 36112                                  ;           MOV     ES,block
 36113                                  ;           MOV     AH,dealloc
 36114                                  ;           INT     21h
 36115                                  ;
 36116                                  ;   Error return:
 36117                                  ;           AX = error_invalid_block
 36118                                  ;              = error_arena_trashed
 36119                                  ;---------------------------------------------------------------------------- 
 36120                                  
 36121                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36122                                  _$DEALLOC:
 36123                                  	; 14/05/2019 - Retro DOS v4.0    
 36124                                  	; 04/08/2018 - Retro DOS v3.0
 36125                                  	;EnterCrit   critMem
 36126 00006269 E876B0                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 36127                                  
 36128                                  	; MSDOS 6.0			; M016, M068 - Start
 36129 0000626C 36F606[8600]04          	test	byte [ss:DOS_FLAG],EXECA20OFF
 36130                                  					; Q: was the previous call an int 21
 36131                                  					;    exec call
 36132 00006272 740D                    	jz	short deallocate	; N: continue
 36133 00006274 36803E[8500]00          	cmp	byte [ss:A20OFF_COUNT], 0 ; Q: is count 0
 36134 0000627A 7505                    	jne	short deallocate	; N: continue
 36135                                  	;mov	byte [ss:A20OFF_COUNT], 1 ; Y: set count to 1
 36136                                  	; 25/09/2023
 36137 0000627C 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]
 36138                                  deallocate:				; M016, M068 - End
 36139 00006281 BF0000                  	MOV     DI,ARENA.SIGNATURE ; = 0
 36140 00006284 8CC0                            MOV     AX,ES
 36141 00006286 48                              DEC     AX
 36142 00006287 E838FE                          CALL    check_signature
 36143 0000628A 720A                            JC      SHORT dealloc_err
 36144 0000628C 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 36145                                  	;LeaveCrit critMem
 36146 00006291 E869B0                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 36147                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36148                                          ;transfer SYS_RET_OK
 36149                                  dealloc_ok:
 36150 00006294 EBAC                    	jmp	short alloc_ok
 36151                                  	;JMP	SYS_RET_OK
 36152                                  
 36153                                  dealloc_err:
 36154                                  	;LeaveCrit critMem
 36155 00006296 E864B0                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 36156                                          ;error	error_invalid_block
 36157                                  	;mov	al,9
 36158 00006299 B009                    	MOV	AL,error_invalid_block
 36159                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36160                                  dealloc_errj:
 36161                                  AllocOperErrj:	; 17/12/2022
 36162 0000629B E99CA3                  	JMP	SYS_RET_ERR
 36163                                  
 36164                                  ;	BREAK $AllocOper - get/set allocation mechanism
 36165                                  
 36166                                  ; MSDOS 6.0
 36167                                  ;----------------------------------------------------------------------------
 36168                                  ;**	$AllocOper - Get/Set Allocation Mechanism
 36169                                  ;
 36170                                  ;	Assembler usage:
 36171                                  ;           MOV     AH,AllocOper
 36172                                  ;           MOV     BX,method
 36173                                  ;           MOV     AL,func
 36174                                  ;           INT     21h
 36175                                  ;
 36176                                  ;	ENTRY	
 36177                                  ;		(al) = 0
 36178                                  ;		  Get allocation Strategy in (ax)
 36179                                  ;
 36180                                  ;		(al) = 1, (bx) = method = zw0000xy
 36181                                  ;		  Set allocation strategy.
 36182                                  ;		   w  = 1  => HIGH_ONLY
 36183                                  ;		   z  = 1  => HIGH_FIRST
 36184                                  ;		   xy = 00 => FIRST_FIT
 36185                                  ;		      = 01 => BEST_FIT
 36186                                  ;		      = 10 => LAST_FIT
 36187                                  ;
 36188                                  ;		(al) = 2
 36189                                  ;		  Get UMB link state in (al)
 36190                                  ;
 36191                                  ;		(al) = 3
 36192                                  ;		  Set UMB link state
 36193                                  ;		   (bx) = 0 => Unlink UMBs
 36194                                  ;		   (bx) = 1 => Link UMBs
 36195                                  ;
 36196                                  ;
 36197                                  ;	EXIT	'C' clear if OK
 36198                                  ;
 36199                                  ;		 if (al) = 0
 36200                                  ;		  (ax) = existing method
 36201                                  ;		 if (al) = 1
 36202                                  ;		  Sets allocation strategy
 36203                                  ;		 if (al) = 2
 36204                                  ;		  (al) = 0 => UMBs not linked
 36205                                  ;		  (al) = 1 => UMBs linked in
 36206                                  ;		 if (al) = 3
 36207                                  ;		  Links/Unlinks the UMBs into DOS chain
 36208                                  ;
 36209                                  ;		'C' set if error
 36210                                  ;		  AX = error_invalid_function
 36211                                  ;
 36212                                  ;	Rev. M000 - added support for HIGH_FIRST in (al) = 1. 7/9/90
 36213                                  ; 	Rev. M003 - added functions (al) = 2 and (al) = 3. 7/18/90
 36214                                  ;	Rev. M009 - (al) = 3 will return 'invalid function' in ax if
 36215                                  ;		    umbhead has'nt been initialized by sysinit and 'trashed
 36216                                  ;		    arena' if an arena sig is damaged.
 36217                                  ;----------------------------------------------------------------------------
 36218                                  
 36219                                  ; MSDOS 2.11 (& MSDOS 3.3)
 36220                                  ;----------------------------------------------------------------------------
 36221                                  ;SUBTTL $AllocOper - get/set allocation mechanism
 36222                                  ;
 36223                                  ;   Assembler usage:
 36224                                  ;           MOV     AH,AllocOper
 36225                                  ;           MOV     BX,method
 36226                                  ;           MOV     AL,func
 36227                                  ;           INT     21h
 36228                                  ;
 36229                                  ;   Error return:
 36230                                  ;           AX = error_invalid_function
 36231                                  ;----------------------------------------------------------------------------
 36232                                  
 36233                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36234                                  _$ALLOCOPER:
 36235                                  	; 14/05/2019 - Retro DOS v4.0
 36236                                  	; MSDOS 6.0
 36237 0000629E 08C0                    	or	al,al ; 0
 36238 000062A0 741E                    	jz	short AllocGetStrat
 36239                                  	; 17/12/2022
 36240                                  	;cmp	al,1
 36241                                  	;jz	short AllocSetStrat
 36242                                  
 36243                                  	; 01/12/2022
 36244                                  	;cmp	al, 2
 36245                                  	;jb	short AllocSetStrat
 36246                                  	;ja	short AllocSetLink
 36247                                  	;;jmp	short AllocGetLink
 36248                                  ;AllocGetLink:
 36249                                  	; MSDOS 6.0
 36250                                  	;mov	al,[ss:UMBFLAG]		; return link state in al
 36251                                  	;and 	al,LINKSTATE
 36252                                  	;;transfer SYS_RET_OK
 36253                                  	;jmp	SYS_RET_OK
 36254                                  
 36255 000062A2 3C02                    	cmp	al,2
 36256                                  	; 17/12/2022
 36257 000062A4 7223                    	jb	short AllocSetStrat ; al = 1
 36258 000062A6 7432                    	je	short AllocGetLink
 36259                                  
 36260                                  	;cmp	al,2
 36261                                  	;jz	short AllocGetLink
 36262 000062A8 3C03                    	cmp	al,3
 36263 000062AA 7436                    	jz	short AllocSetLink
 36264                                  
 36265                                  	; 15/04/2018
 36266                                  	;CMP	AL,1
 36267                                          ;JB	SHORT AllocOperGet
 36268                                          ;JZ	SHORT AllocOperSet
 36269                                  
 36270                                  AllocOperError:
 36271                                  	; 04/08/2018 - Retro DOS v3.0
 36272                                  	; MSDOS 3.3 (& MSDOS 6.0)	; Extended Error Locus
 36273                                  	;mov	byte [ss:EXTERR_LOCUS],5
 36274 000062AC 36C606[2303]05                  MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 36275                                  	;error	error_invalid_function
 36276                                  	;mov	al,1
 36277 000062B2 B001                    	MOV	AL,error_invalid_function
 36278                                  	; 17/12/2022
 36279                                  ;AllocOperErrj:
 36280                                  	;JMP	SYS_RET_ERR
 36281                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36282                                  	;jmp	short dealloc_errj
 36283                                  	; 17/12/2022
 36284 000062B4 EBE5                    	jmp	short AllocOperErrj
 36285                                  
 36286                                  AllocArenaError:
 36287                                  	; MSDOS 6.0
 36288 000062B6 36C606[2303]05          	MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 36289                                  					; M009: Extended Error Locus
 36290                                  	;error	error_arena_trashed	; M009:
 36291                                  	;mov	al,7
 36292 000062BC B007                    	MOV	AL,error_arena_trashed
 36293                                  	;JMP	SYS_RET_ERR
 36294 000062BE EBDB                    	jmp	short AllocOperErrj ; 17/12/2022
 36295                                  
 36296                                  AllocGetStrat: 
 36297                                  	; MSDOS 6.0
 36298                                  AllocOperGet:
 36299 000062C0 36A0[0203]                      MOV     AL,[SS:AllocMethod]
 36300 000062C4 30E4                            XOR     AH,AH
 36301                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36302                                  	;transfer SYS_RET_OK
 36303                                  AllocOperOk:
 36304                                  	; 17/12/2022
 36305                                  	;jmp	short dealloc_ok
 36306 000062C6 E968A3                  	JMP	SYS_RET_OK
 36307                                  
 36308                                  AllocSetStrat: 
 36309                                  	; 14/05/2019
 36310                                  	; MSDOS 6.0
 36311 000062C9 53                      	push	bx			; M000 - start
 36312                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36313                                  	;and	bx,STRAT_MASK ; 0FF3Fh	; M064: mask off bit 6 & 7
 36314                                  	; 17/12/2022
 36315 000062CA 80E33F                  	and	bl,3Fh
 36316 000062CD 83FB02                  	cmp	bx,2			; BX must be 0-2
 36317                                  	;cmp	bl,2
 36318 000062D0 5B                      	pop	bx			; M000 - end
 36319 000062D1 77D9                    	ja	short AllocOperError
 36320                                  
 36321                                  AllocOperSet:
 36322 000062D3 36881E[0203]                    MOV     [SS:AllocMethod],BL
 36323                                    	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36324                                  	;transfer SYS_RET_OK
 36325                                  AllocOperOkj:
 36326 000062D8 EBEC                    	jmp	short AllocOperOk
 36327                                  	;JMP	SYS_RET_OK
 36328                                  
 36329                                  AllocGetLink:
 36330                                  	; MSDOS 6.0
 36331 000062DA 36A0[8900]              	mov	al,[ss:UMBFLAG]		; return link state in al
 36332                                  	;and	al,1
 36333 000062DE 2401                    	and 	al,LINKSTATE
 36334                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36335                                  	;transfer SYS_RET_OK
 36336                                  AllocOperOkj2:
 36337                                  	; 17/12/2022
 36338 000062E0 EBE4                    	jmp	short AllocOperOk
 36339                                  	;jmp	short AllocOperOkj
 36340                                  	;;JMP	SYS_RET_OK
 36341                                  
 36342                                  AllocSetLink:
 36343                                  	; MSDOS 6.0			; M009 - start
 36344 000062E2 368B0E[8C00]            	mov	cx,[ss:UMB_HEAD]	; cx = umb_head
 36345 000062E7 83F9FF                  	cmp	cx,0FFFFh		; Q: has umb_head been initialized
 36346 000062EA 74C0                    	je	short AllocOperError	; N: error
 36347                                  					; Y: continue
 36348                                  					; M009 - end
 36349 000062EC 83FB01                  	cmp	bx,1
 36350                                  	;jb	short UnlinkUmbs
 36351                                  	;jz	short LinkUmbs
 36352                                  	;jmp	short AllocOperError
 36353                                  	; 10/03/2024
 36354 000062EF 7417                    	jz	short LinkUmbs
 36355 000062F1 77B9                    	ja	short AllocOperError
 36356                                  
 36357                                  UnlinkUmbs:
 36358                                  
 36359                                  ; 07/07/2024
 36360                                  %if 0
 36361                                  	;test	byte [ss:UMBFLAG],1
 36362                                  	test	byte [ss:UMBFLAG],LINKSTATE ; Q: umbs unlinked?
 36363                                  	jz	short unlinked		; Y: return
 36364                                  	
 36365                                  	call	GetLastArena		; get arena before umb_head in DS
 36366                                  	jc	short AllocArenaError	; M009: arena trashed
 36367                                  %else
 36368                                  	; 10/03/2024 - Retro DOS v5.0
 36369                                  	; (PCDOS 7.1 IBMDOS.COM)
 36370                                  	;;;
 36371 000062F3 E88CFD                  	call	test_umb_flag	; test byte [ss:UMBFLAG],LINKSTATE
 36372                                  				; Q: umbs unlinked?
 36373 000062F6 740E                    	jz	short unlinked	; Y: return
 36374 000062F8 E82200                  	call	GetLastArena	; get arena before umb_head in DS
 36375                                  	;;;	
 36376                                  %endif
 36377                                  					; make it last
 36378 000062FB C60600005A              	mov	byte [0],arena_signature_end
 36379                                  	
 36380                                  	;and	byte [ss:UMBFLAG],0FEh
 36381 00006300 368026[8900]FE          	and	byte [ss:UMBFLAG],~LINKSTATE ; indicate unlink'd state in umbflag
 36382                                  	
 36383                                  unlinked:
 36384                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36385                                  	;transfer SYS_RET_OK
 36386                                  	; 17/12/2022
 36387 00006306 EBBE                    	jmp	short AllocOperOk
 36388                                  	;jmp	short AllocOperOkj2
 36389                                  	;;JMP	SYS_RET_OK
 36390                                  
 36391                                  LinkUmbs:
 36392                                  
 36393                                  ; 07/07/2024
 36394                                  %if 0
 36395                                  	test	byte [ss:UMBFLAG],LINKSTATE ; Q: umbs linked?
 36396                                  	jnz	short linked		; Y: return
 36397                                  	
 36398                                  	call	GetLastArena		; get arena before umb_head
 36399                                  	jc	short AllocArenaError	; M009: arena trashed
 36400                                  %else
 36401                                  	; 10/03/2024 - Retro DOS v5.0
 36402                                  	; (PCDOS 7.1 IBMDOS.COM)
 36403                                  	;;;
 36404 00006308 E877FD                  	call	test_umb_flag	; Q: umbs linked?
 36405 0000630B 750E                    	jnz	short linked	; Y: return
 36406 0000630D E80D00                  	call	GetLastArena	; get arena before umb_head
 36407                                  	;;;
 36408                                  %endif
 36409                                  					; make it normal. M061: ds points to
 36410                                  					; arena before umb_head
 36411 00006310 C60600004D              	mov	byte [0],arena_signature_normal
 36412                                  	
 36413 00006315 36800E[8900]01          	or	byte [ss:UMBFLAG],LINKSTATE ; indicate link'd state in umbflag
 36414                                  linked:
 36415                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36416                                  	;transfer SYS_RET_OK
 36417                                  	; 17/12/2022
 36418 0000631B EBA9                    	jmp	short AllocOperOk
 36419                                  	;jmp	short unlinked
 36420                                  	;;JMP	SYS_RET_OK
 36421                                  
 36422                                  ; MSDOS 6.0
 36423                                  ;--------------------------------------------------------------------------
 36424                                  ; Procedure Name : GetLastArena		-  M003
 36425                                  ;
 36426                                  ; Inputs	 : cx = umb_head
 36427                                  ;
 36428                                  ;
 36429                                  ; Outputs	 : If UMBs are linked
 36430                                  ;			ES = umb_head
 36431                                  ;			DS = arena before umb_head
 36432                                  ;		   else
 36433                                  ;			DS = last arena
 36434                                  ;			ES = next arena. will be umb_head if NC.
 36435                                  ;
 36436                                  ;		   CY if error
 36437                                  ;
 36438                                  ; Uses		 : DS, ES, DI, BX
 36439                                  ;--------------------------------------------------------------------------
 36440                                  
 36441                                  ; 14/05/2019 - Retro DOS v4.0
 36442                                  ; DOSCODE:A4D6h (MSDOS 6.21, MSDOS.SYS)
 36443                                  
 36444                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36445                                  ; DOSCODE:A476h (MSDOS 5.0, MSDOS.SYS)
 36446                                  	
 36447                                  GetLastArena:
 36448 0000631D 50                      	push	ax			; save ax
 36449                                  
 36450 0000631E 36A1[2400]              	mov	ax,[ss:arena_head]
 36451 00006322 8EC0                    	mov	es,ax			; es = arena_head
 36452 00006324 31FF                    	xor	di,di
 36453                                  
 36454 00006326 26803D5A                	cmp     byte [es:di],arena_signature_end
 36455                                  					; Q: is this the last arena
 36456 0000632A 7416                    	je	short GLA_done		; Y: return last arena in ES
 36457                                  
 36458                                  GLA_next:
 36459 0000632C 8ED8                    	mov	ds,ax
 36460 0000632E E88AFD                  	call	arena_next		; ax, es -> next arena
 36461                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36462                                  	;jc	short GLA_err
 36463                                  	; 17/12/2022
 36464 00006331 7222                    	jc	short GLA_err2
 36465                                  
 36466                                  ; 07/07/2024
 36467                                  %if 0
 36468                                  	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are UMBs linked
 36469                                  	jnz	short GLA_chkumb	; Y: terminating condition is
 36470                                  					;    umb_head
 36471                                  					; N: terminating condition is 05Ah
 36472                                  %else
 36473                                  	; 10/03/2024 (PCDOS 7.1 IBMDOS.COM)
 36474                                  	;;;
 36475 00006333 E84CFD                  	call	test_umb_flag
 36476 00006336 7506                    	jnz	short GLA_chkumb
 36477                                  	;;;
 36478                                  %endif
 36479 00006338 26803D5A                	cmp     byte [es:di],arena_signature_end
 36480                                  					; Q: is this the last arena
 36481 0000633C EB02                    	jmp	short GLA_@f
 36482                                  GLA_chkumb:
 36483 0000633E 39C8                    	cmp	ax,cx			; Q: is this umb_head
 36484                                  GLA_@f:
 36485 00006340 75EA                    	jne	short GLA_next		; N: get next arena
 36486                                  
 36487                                  GLA_done:
 36488                                  
 36489                                  ; 07/07/2024
 36490                                  %if 0
 36491                                  					; M061 - Start
 36492                                  	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are UMBs linked
 36493                                  	jnz	short GLA_ret		; Y: we're done
 36494                                  					; N: let us confirm that the next
 36495                                  					;    arena is umb_head
 36496                                  %else
 36497                                  	; 10/03/2024 (PCDOS 7.1 IBMDOS.COM)
 36498                                  	;;;
 36499 00006342 E83DFD                  	call	test_umb_flag
 36500 00006345 750B                    	jnz	short GLA_ret ; cf=0
 36501                                  	;;;
 36502                                  %endif
 36503 00006347 8ED8                    	mov	ds,ax
 36504 00006349 E86FFD                  	call	arena_next		; ax, es -> next arena
 36505                                  	;jc	short GLA_err
 36506 0000634C 7207                    	jc	short GLA_err2
 36507 0000634E 39C8                    	cmp	ax,cx			; Q: is this umb_head
 36508 00006350 7502                    	jne	short GLA_err		; N: error
 36509                                  					; M061 - End
 36510                                  GLA_ret:
 36511                                  	; 17/12/2022
 36512                                  	;clc
 36513                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36514                                  	;clc
 36515 00006352 58                      	pop	ax			; M061
 36516 00006353 C3                      	retn				; M061
 36517                                  
 36518                                  GLA_err:
 36519 00006354 F9                      	stc				; M061
 36520                                  GLA_err2:
 36521 00006355 58                      	pop	ax
 36522 00006356 C3                      	retn
 36523                                  
 36524                                  ;============================================================================
 36525                                  ; SRVCALL.ASM, MSDOS 6.0, 1991
 36526                                  ;============================================================================
 36527                                  ; 04/08/2018 - Retro DOS v3.0
 36528                                  
 36529                                  ;	TITLE SRVCALL - Server DOS call
 36530                                  ;	NAME  SRVCALL
 36531                                  
 36532                                  ;**	SRVCALL.ASM - Server DOS call functions
 36533                                  ;
 36534                                  ;
 36535                                  ;	$ServerCall
 36536                                  ;
 36537                                  ;	Modification history:
 36538                                  ;
 36539                                  ;	    Created: ARR 08 August 1983
 36540                                  
 36541                                  ;AsmVars <Installed>
 36542                                  
 36543                                  ;include dpl.asm
 36544                                  
 36545                                  ;Installed = TRUE
 36546                                  
 36547                                  ; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 36548                                  ; ---------------------------------------------------------------------------
 36549                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36550                                  
 36551                                  ;BREAK <ServerCall -- Server DOS call>
 36552                                  
 36553                                  ; DOSCODE:A517h (MSDOS 6.21, MSDOS.SYS)
 36554                                  ; DOSCODE:A4B7h (MSDOS 5.0, MSDOS.SYS)
 36555                                  
 36556                                  ;hkn; TABLE	SEGMENT
 36557                                  ;Public SRVC001S,SRVC001E
 36558                                  ;SRVC001S label byte
 36559                                  
 36560                                  SRVC001S:
 36561                                  
 36562 00006357 [5B63]                  SERVERTAB:	dw	SERVER_DISP
 36563 00006359 [AD63]                  SERVERLEAVE:	dw	SERVERRETURN
 36564 0000635B 0B                      SERVER_DISP:	db	(SERVER_DISP_END-SERVER_DISP-1)/2 ; = 11
 36565 0000635C [1364]                  		dw	SRV_CALL	; 0
 36566 0000635E [AE63]                  		dw	COMMIT_ALL	; 1
 36567 00006360 [E463]                  		dw	CLOSE_NAME	; 2
 36568 00006362 [ED63]                  		dw	CLOSE_UID	; 3
 36569 00006364 [F463]                  		dw	CLOSE_UID_PID	; 4
 36570 00006366 [FB63]                  		dw	GET_LIST	; 5
 36571 00006368 [5464]                  		dw	GET_DOS_DATA	; 6
 36572 0000636A [7864]                  		dw	SPOOL_OPER	; 7
 36573 0000636C [7864]                  		dw	SPOOL_OPER	; 8
 36574 0000636E [7864]                  		dw	SPOOL_OPER	; 9
 36575 00006370 [8464]                  		dw	_$SetExtendedError  ; 10
 36576                                  
 36577                                  SERVER_DISP_END:  ;  LABEL BYTE
 36578                                  
 36579                                  ;SRVC001E label byte
 36580                                  
 36581                                  SRVC001E:
 36582                                  
 36583                                  ;hkn; TABLE	ENDS
 36584                                  
 36585                                  ;----------------------------------------------------------------------------
 36586                                  ;
 36587                                  ; Procedure Name : $ServerCall
 36588                                  ;
 36589                                  ; Inputs:
 36590                                  ;	DS:DX -> DPL  (except calls 7,8,9)
 36591                                  ; Function:
 36592                                  ;	AL=0	Server DOS call
 36593                                  ;	AL=1	Commit All files
 36594                                  ;	AL=2	Close file by name (SHARING LOADED ONLY) DS:DX in DPL -> name
 36595                                  ;	AL=3	Close all files for DPL_UID
 36596                                  ;	AL=4	Close all files for DPL_UID/PID_PID
 36597                                  ;	AL=5	Get open file list entry
 36598                                  ;		    IN: BX File Index
 36599                                  ;			CX User Index
 36600                                  ;		    OUT:ES:DI -> Name
 36601                                  ;			BX = UID
 36602                                  ;		    CX = # locked blocks held by this UID
 36603                                  ;	AL=6	Get DOS data area
 36604                                  ;		    OUT: DS:SI -> Start
 36605                                  ;			CX size in bytes of swap if indos
 36606                                  ;			DX size in bytes of swap always
 36607                                  ;	AL=7	Get truncate flag
 36608                                  ;	AL=8	Set truncate flag
 36609                                  ;	AL=9	Close all spool files
 36610                                  ;	AL=10	SetExtendedError
 36611                                  ;
 36612                                  ;----------------------------------------------------------------------------
 36613                                  
 36614                                  _$ServerCall:
 36615                                  	; 13/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36616                                  	; DOSCODE:A4D2h (MSDOS 5.0 MSDOS.SYS)		
 36617                                  	; 10/06/2019
 36618                                  	; 29/04/2019 - Retro DOS v4.0
 36619                                  	; DOSCODE:A532h (MSDOS 6.21 MSDOS.SYS)
 36620                                  
 36621                                  	; 05/08/2018 - Retro DOS v3.0
 36622                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 657Bh
 36623 00006372 3C07                    	CMP	AL,7
 36624 00006374 7204                    	JB	short SET_STUFF
 36625 00006376 3C09                    	CMP	AL,9
 36626 00006378 761A                    	JBE	short NO_SET_ID		; No DPL on calls 7,8,9
 36627                                  SET_STUFF:
 36628 0000637A 89D6                    	MOV	SI,DX			; Point to DPL with DS:SI
 36629                                  	;mov	bx,[si+12h]
 36630 0000637C 8B5C12                  	MOV	BX,[SI+DPL.UID]
 36631                                  
 36632                                  	; MSDOS 6.0
 36633                                  ;SR;
 36634                                  ; WIN386 updates the USER_ID itself. If WIN386 is present we skip the updating
 36635                                  ; of USER_ID
 36636                                  
 36637 0000637F 36F606[3010]01          	test	byte [SS:IsWin386],1
 36638 00006385 7505                    	jnz	short skip_win386
 36639                                  
 36640                                  ;hkn; SS override for user_id and proc_id
 36641                                  	; 15/08/2018
 36642 00006387 36891E[3E03]            	MOV	[SS:USER_ID],BX		; Set UID
 36643                                  
 36644                                  skip_win386:
 36645 0000638C 8B5C14                  	MOV	BX,[SI+DPL.PID]
 36646 0000638F 36891E[3C03]            	MOV	[SS:PROC_ID],BX		; Set process ID
 36647                                  NO_SET_ID:
 36648                                  	; 10/06/2019 - Retro DOS v4.0
 36649 00006394 2EFF36[5963]            	PUSH	word [cs:SERVERLEAVE]	; push return address
 36650 00006399 2EFF36[5763]            	PUSH	word [cS:SERVERTAB]	; push table address
 36651 0000639E 50                      	PUSH	AX
 36652 0000639F E85CAE                  	call	TableDispatch
 36653                                  
 36654                                  ;hkn; SS override
 36655                                  	;mov 	byte [SS:EXETERR_LOCUS],1
 36656 000063A2 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 36657                                  	;error	error_invalid_function
 36658                                  	;mov	al,1
 36659 000063A8 B001                    	MOV	AL,error_invalid_function
 36660                                  servercall_error:
 36661 000063AA E98DA2                  	JMP	SYS_RET_ERR
 36662                                  
 36663                                  SERVERRETURN:
 36664 000063AD C3                      	retn
 36665                                  
 36666                                  ; Commit - iterate through the open file list and make sure that the
 36667                                  ; directory entries are correctly updated.
 36668                                  
 36669                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36670                                  COMMIT_ALL:
 36671 000063AE 31DB                    	XOR	BX,BX			;   for (i=0; ThisSFT=getSFT(i); i++)
 36672 000063B0 16                      	push	ss
 36673 000063B1 1F                      	pop	ds
 36674 000063B2 E82DAF                  	call	ECritSFT		; Gonna scan SFT cache, lock it down
 36675                                  CommitLoop:
 36676 000063B5 53                      	push	bx
 36677 000063B6 E82201                  	call	SFFromSFN
 36678 000063B9 7222                    	JC	short CommitDone
 36679 000063BB 26833D00                	cmp	word [es:di],0
 36680                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],0
 36681                                  					; if (ThisSFT->refcount != 0)
 36682 000063BF 7418                    	JZ	short CommitNext
 36683                                  	;cmp	word [es:di],0FFFFh ; -1
 36684 000063C1 26833DFF                	cmp	word [ES:DI],sf_busy
 36685                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],sf_busy  
 36686                                  					; BUSY SFTs have god knows what
 36687 000063C5 7412                    	JZ	short CommitNext	;   in them.
 36688                                  	; 17/12/2022
 36689 000063C7 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8) ; 80h
 36690                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet ; 8000h
 36691 000063CC 750B                    	JNZ	short CommitNext	;  Skip Network SFTs so the SERVER
 36692                                  					;	doesn't deadlock
 36693 000063CE 893E[9E05]              	MOV	[THISSFT],DI
 36694 000063D2 8C06[A005]              	MOV	[THISSFT+2],ES
 36695 000063D6 E8D3CB                  	call	DOS_COMMIT		;	DOSCommit ();
 36696                                  CommitNext:
 36697 000063D9 5B                      	pop	bx
 36698 000063DA 43                      	INC	BX
 36699 000063DB EBD8                    	JMP	short CommitLoop
 36700                                  CommitDone:
 36701 000063DD E81DAF                  	call	LCritSFT
 36702 000063E0 5B                      	pop	bx
 36703                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36704                                  Commit_Ok:
 36705 000063E1 E94DA2                  	jmp	SYS_RET_OK
 36706                                  	
 36707                                  CLOSE_NAME:
 36708                                  
 36709                                  ;if installed
 36710                                  
 36711                                  ;hkn; SS override
 36712                                  	;call	far [ss:MFTcloN]
 36713 000063E4 36FF1E[A400]            	Call	far [SS:JShare+(5*4)] ; 5 = MFTcloN
 36714                                  ;else
 36715                                  ;	Call	MFTcloN
 36716                                  ;endif
 36717                                  
 36718                                  CheckReturns:
 36719                                  
 36720                                  ; 10/03/2024
 36721                                  %if 0
 36722                                  	JC	short func_err
 36723                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36724                                  	;transfer SYS_RET_OK
 36725                                  Commit_Okj:
 36726                                  	jmp	short Commit_Ok
 36727                                  	;jmp	SYS_RET_OK
 36728                                  %else
 36729 000063E9 73F6                    	jnc	short Commit_Ok
 36730                                  %endif
 36731                                  
 36732                                  func_err:
 36733                                  	;transfer SYS_RET_ERR
 36734                                  	;jmp	SYS_RET_ERR
 36735 000063EB EBBD                    	jmp	short servercall_error
 36736                                  
 36737                                  CLOSE_UID:
 36738                                  
 36739                                  ;if installed
 36740                                  ;hkn; SS override
 36741                                  	;call	far [ss:MFTclU]
 36742 000063ED 36FF1E[9C00]            	Call	far [SS:JShare+(3*4)] ; 3 = MTFTclu
 36743                                  ;else
 36744                                  ;	Call	MFTclU
 36745                                  ;endif
 36746 000063F2 EBF5                    	JMP	short CheckReturns
 36747                                  
 36748                                  CLOSE_UID_PID:
 36749                                  
 36750                                  ;if installed
 36751                                  ;hkn; SS override
 36752                                  	;call	far [ss:MFTCloseP]
 36753 000063F4 36FF1E[A000]            	Call	far [SS:JShare+(4*4)] ; 4 = MFTCloseP
 36754                                  ;else
 36755                                  ;	Call	MFTCloseP
 36756                                  ;endif
 36757 000063F9 EBEE                    	JMP	short CheckReturns
 36758                                  
 36759                                  GET_LIST:
 36760                                  
 36761                                  ;if installed
 36762                                  ;hkn; SS override
 36763                                  	;call	far [ss:MFT_get]
 36764 000063FB 36FF1E[B400]            	Call	far [SS:JShare+(9*4)] ; 9 = MFT_get
 36765                                  ;else
 36766                                  ;	Call	MFT_get
 36767                                  ;endif
 36768 00006400 72E9                    	JC	short func_err
 36769 00006402 E87CA0                  	call	Get_User_Stack
 36770                                  	;mov	[si+2],bx
 36771 00006405 895C02                  	MOV	[SI+user_env.user_BX],BX
 36772                                  	;mov	[si+10],di
 36773 00006408 897C0A                  	MOV	[SI+user_env.user_DI],DI
 36774                                  	;mov	[si+16],es
 36775 0000640B 8C4410                  	MOV	[SI+user_env.user_ES],ES
 36776                                  SetCXOK:
 36777                                  	;mov	[si+4],cx
 36778 0000640E 894C04                  	MOV	[SI+user_env.user_CX],CX
 36779                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36780                                  	;transfer SYS_RET_OK
 36781                                  Commit_Okj2:
 36782                                  	; 17/12/2022
 36783 00006411 EBCE                    	jmp	short Commit_Ok
 36784                                  	;jmp	short Commit_Okj
 36785                                  	;;jmp	SYS_RET_OK
 36786                                  
 36787                                  SRV_CALL:
 36788 00006413 58                      	POP	AX			; get rid of call to $srvcall
 36789 00006414 1E                      	push	ds
 36790 00006415 56                      	push	si
 36791 00006416 E868A0                  	call	Get_User_Stack
 36792 00006419 5F                      	pop	di
 36793 0000641A 07                      	pop	es
 36794                                  
 36795                                  ; DS:SI point to stack
 36796                                  ; ES:DI point to DPL
 36797                                  
 36798 0000641B E8BFAD                  	call	XCHGP
 36799                                  
 36800                                  ; DS:SI point to DPL
 36801                                  ; ES:DI point to stack
 36802                                  ;
 36803                                  ; We now copy the registers from DPL to save stack
 36804                                  
 36805 0000641E 56                      	push	si
 36806 0000641F B90600                  	MOV	CX,6
 36807 00006422 F3A5                    	REP	MOVSW			; Put in AX,BX,CX,DX,SI,DI
 36808 00006424 47                      	INC	DI
 36809 00006425 47                      	INC	DI			; Skip user_BP
 36810 00006426 A5                      	MOVSW				; DS
 36811 00006427 A5                      	MOVSW				; ES
 36812 00006428 5E                      	pop	si			; DS:SI -> DPL
 36813 00006429 8B04                    	mov	ax,[SI]
 36814                                  	;MOV	AX,[SI+DPL.AX]
 36815                                  	;mov	bx,[si+2]
 36816 0000642B 8B5C02                  	MOV	BX,[SI+DPL.BX]
 36817                                  	;mov	cx,[si+4]
 36818 0000642E 8B4C04                  	MOV	CX,[SI+DPL.CX]
 36819                                  	;mov	dx,[si+6]
 36820 00006431 8B5406                  	MOV	DX,[SI+DPL.DX]
 36821                                  	;mov	di,[si+10]
 36822 00006434 8B7C0A                  	MOV	DI,[SI+DPL.DI]
 36823                                  	;mov	es,[si+14]
 36824 00006437 8E440E                  	MOV	ES,[SI+DPL.ES]
 36825                                  	;push	word [si+8]
 36826 0000643A FF7408                  	PUSH	word [SI+DPL.SI]
 36827                                  	;mov	ds,[si+12]
 36828 0000643D 8E5C0C                  	MOV	DS,[SI+DPL.DS]
 36829 00006440 5E                      	POP	SI
 36830                                  
 36831                                  ;hkn; SS override for next 3
 36832 00006441 368C1E[EC05]            	MOV	[SS:SAVEDS],DS
 36833 00006446 36891E[EA05]            	MOV	[SS:SAVEBX],BX
 36834 0000644B 36C606[7205]FF          	MOV	byte [SS:FSHARING],-1	; set no redirect flag
 36835 00006451 E9349F                  	jmp	REDISP
 36836                                  
 36837                                  GET_DOS_DATA:
 36838 00006454 16                      	push	ss
 36839 00006455 07                      	pop	es
 36840 00006456 BF[2003]                	MOV     DI,SWAP_START
 36841 00006459 B9[AC0A]                	MOV     CX,SWAP_END
 36842 0000645C BA[3A03]                	MOV     DX,SWAP_ALWAYS
 36843 0000645F 29F9                    	SUB     CX,DI
 36844 00006461 29FA                    	SUB     DX,DI
 36845 00006463 D1E9                    	SHR     CX,1                    ; div by 2, remainder in carry
 36846 00006465 83D100                  	ADC     CX,0                    ; div by 2 + round up
 36847 00006468 D1E1                    	SHL     CX,1                    ; round up to 2 boundary.
 36848 0000646A E814A0                  	call	Get_User_Stack
 36849                                  	;mov	[si+14],es
 36850 0000646D 8C440E                  	MOV     [SI+user_env.user_DS],ES
 36851                                  	;mov	[si+8],di
 36852 00006470 897C08                  	MOV     [SI+user_env.user_SI],DI
 36853                                  	;mov	[si+6],dx
 36854 00006473 895406                  	MOV     [SI+user_env.user_DX],DX
 36855 00006476 EB96                    	JMP	short SetCXOK
 36856                                  
 36857                                  SPOOL_OPER:
 36858                                  	;CallInstall NETSpoolOper,MultNET,37,AX,BX
 36859                                  
 36860 00006478 50                      	push    ax
 36861 00006479 B82511                  	mov     ax,1125h
 36862 0000647C CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
 36863                                  			; STACK: WORD subfunction
 36864                                  			; Return: CF set on error, AX = error code
 36865                                  			; STACK unchanged
 36866 0000647E 5B                      	pop	bx
 36867                                  	; 17/12/2022
 36868                                  	;JC	short func_err2
 36869 0000647F 7390                    	jnc	short Commit_Okj2
 36870                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36871                                  	;;jmp	SYS_RET_OK
 36872                                  	;jmp	short Commit_Okj2
 36873                                  	
 36874                                  func_err2:
 36875 00006481 E9B6A1                  	jmp	SYS_RET_ERR
 36876                                  
 36877                                  ;Break	<$SetExtendedError - set extended error for later retrieval>
 36878                                  ;--------------------------------------------------------------------------
 36879                                  ;
 36880                                  ; Procedure Name : $SetExtendedError
 36881                                  ;
 36882                                  ; $SetExtendedError takes extended error information and loads it up for the
 36883                                  ; next extended error call. This is used by interrupt-level proccessors to
 36884                                  ; mask their actions.
 36885                                  ;
 36886                                  ;   Inputs: DS:SI points to DPL which contains all registers
 36887                                  ;   Outputs: none
 36888                                  ;
 36889                                  ;---------------------------------------------------------------------------
 36890                                  
 36891                                  _$SetExtendedError:
 36892                                  
 36893                                  ;hkn; SS override for all variables used
 36894                                  
 36895 00006484 8B04                    	mov	ax,[si]
 36896                                  	;MOV	AX,[SI+DPL.AX]
 36897 00006486 36A3[2403]              	MOV	[SS:EXTERR],AX
 36898                                  	;mov	ax,[si+10]
 36899 0000648A 8B440A                  	MOV	AX,[SI+DPL.DI]
 36900 0000648D 36A3[2803]              	MOV	[SS:EXTERRPT],AX
 36901                                  	;mov	ax,[si+14]
 36902 00006491 8B440E                  	MOV	AX,[SI+DPL.ES]
 36903 00006494 36A3[2A03]              	MOV	[SS:EXTERRPT+2],AX
 36904                                  	;mov	ax,[si+2]
 36905 00006498 8B4402                  	MOV	AX,[SI+DPL.BX]
 36906 0000649B 36A3[2603]              	MOV	[SS:EXTERR_ACTION],AX
 36907                                  	;mov	ax,[si+4]
 36908 0000649F 8B4404                  	MOV	AX,[SI+DPL.CX]
 36909 000064A2 368826[2303]            	MOV	[SS:EXTERR_LOCUS],AH
 36910 000064A7 C3                      	retn
 36911                                  
 36912                                  ;============================================================================
 36913                                  ; UTIL.ASM, MSDOS 6.0, 1991
 36914                                  ;============================================================================
 36915                                  ; 05/08/2018 - Retro DOS v3.0
 36916                                  ; 05/05/2019 - Retro DOS v4.0
 36917                                  
 36918                                  ;**	Handle related utilities for MSDOS 2.X.
 36919                                  ;----------------------------------------------------------------------------
 36920                                  ;	pJFNFromHandle	written
 36921                                  ;	SFFromHandle	written
 36922                                  ;	SFFromSFN	written
 36923                                  ;	JFNFree 	written
 36924                                  ;	SFNFree 	written
 36925                                  ;
 36926                                  ;	Modification history:
 36927                                  ;
 36928                                  ;	    Created: MZ 1 April 1983
 36929                                  ;----------------------------------------------------------------------------
 36930                                  
 36931                                  ;	BREAK	<pJFNFromHandle - return pointer to JFN table entry>
 36932                                  
 36933                                  ;**	pJFNFromHandle - Translate Handle to Pointer to JFN
 36934                                  ;----------------------------------------------------------------------------
 36935                                  ;	pJFNFromHandle takes a file handle and turns that into a pointer to
 36936                                  ;	the JFN entry (i.e., to a byte holding the internal file handle #)
 36937                                  ;
 36938                                  ;	NOTE:
 36939                                  ;	  This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 36940                                  ;	  at DOSINIT time with SS NOT DOSGROUP
 36941                                  ;
 36942                                  ;	ENTRY	(bx) = handle
 36943                                  ;	EXIT	'C' clear if ok
 36944                                  ;		  (es:di) = address of JFN value
 36945                                  ;		'C' set if error
 36946                                  ;		  (ax) = error code
 36947                                  ;	USES	AX, DI, ES, Flags
 36948                                  ;----------------------------------------------------------------------------
 36949                                  
 36950                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36951                                  
 36952                                  pJFNFromHandle:
 36953                                  	; 05/05/2019 - Retro DOS v4.0
 36954                                  	;getdseg <es>			; es -> dosdata
 36955 000064A8 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 36956                                  	
 36957                                  	;MOV	ES,[cs:CurrentPDB]	; get user process data block
 36958 000064AD 268E06[3003]            	mov	es,[es:CurrentPDB]
 36959                                  
 36960                                  	;cmp	bx,[ES:32h]
 36961 000064B2 263B1E3200              	CMP	BX,[ES:PDB.JFN_Length]	; is handle greater than allocated
 36962 000064B7 7204                    	JB	short pjfn10		; no, get offset
 36963                                  ReturnCarry_inv_hndl: ; 05/08/2018 - Retro DOS v3.0
 36964                                  	;mov	al,6
 36965 000064B9 B006                    	MOV     AL,error_invalid_handle ; appropriate error
 36966                                  ReturnCarry:
 36967 000064BB F9                      	STC                             ; signal error
 36968 000064BC C3                      	retn				; go back
 36969                                  pjfn10: 
 36970                                  	;les	di,[es:34h]
 36971 000064BD 26C43E3400              	LES	DI,[ES:PDB.JFN_Pointer]	; get pointer to beginning of table
 36972 000064C2 01DF                    	ADD	DI,BX			; add in offset, clear 'C'
 36973                                  	;clc
 36974                                  pJFNFromHandle_error:
 36975 000064C4 C3                      	retn
 36976                                  
 36977                                  ;BREAK <SFFromHandle - return pointer (or error) to SF entry from handle>
 36978                                  ;----------------------------------------------------------------------------
 36979                                  ;
 36980                                  ; Procedure Name : SFFromHandle
 36981                                  ;
 36982                                  ; SFFromHandle - Given a handle, get JFN and then index into SF table
 36983                                  ;
 36984                                  ;   Input:      BX has handle
 36985                                  ;   Output:     Carry Set
 36986                                  ;                   AX has error code
 36987                                  ;               Carry Reset
 36988                                  ;                   ES:DI has pointer to SF entry
 36989                                  ;   Registers modified: If error, AX,ES, else ES:DI
 36990                                  ; NOTE:
 36991                                  ;   This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 36992                                  ;       at DOSINIT time with SS NOT DOSGROUP
 36993                                  ;
 36994                                  ;----------------------------------------------------------------------------
 36995                                  
 36996                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36997                                  
 36998                                  SFFromHandle:
 36999 000064C5 E8E0FF                  	CALL	pJFNFromHandle		; get jfn pointer
 37000                                  	;retc				; return if error
 37001 000064C8 72FA                    	jc	short pJFNFromHandle_error
 37002 000064CA 26803DFF                	CMP     BYTE [ES:DI],-1		; unused handle
 37003                                  	;JNZ	short GetSF		; nope, suck out SF
 37004                                  	;;mov	al,6
 37005                                  	;MOV	AL,error_invalid_handle ; appropriate error
 37006                                  	;jmp	short ReturnCarry	; signal it
 37007                                  	; 17/12/2022
 37008                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37009 000064CE 74E9                    	jz	short ReturnCarry_inv_hndl ; Retro DOS v3.0 modification
 37010                                  	;JNZ	short GetSF		; nope, suck out SF
 37011                                  	;;mov	al,6
 37012                                  	;MOV	AL,error_invalid_handle ; appropriate error
 37013                                  	;jmp	short ReturnCarry	; signal it
 37014                                  GetSF:
 37015 000064D0 53                      	push	bx			; save handle
 37016 000064D1 268A1D                  	MOV     BL,[ES:DI]		; get SFN
 37017 000064D4 30FF                    	XOR     BH,BH                   ; ignore upper half
 37018 000064D6 E80200                  	CALL    SFFromSFN               ; get real sf spot
 37019 000064D9 5B                      	pop	bx			; restore
 37020 000064DA C3                      	retn                        	; say goodbye
 37021                                  
 37022                                  ;BREAK <SFFromSFN - index into SF table for SFN>
 37023                                  
 37024                                  ;**	SFFromSFN - Get an SF Table entry from an SFN
 37025                                  ;----------------------------------------------------------------------------
 37026                                  ;	SFFromSfn uses an SFN to index an entry into the SF table. This
 37027                                  ;	is more than just a simple index instruction because the SF table
 37028                                  ;	can be made up of multiple pieces chained together. We follow the
 37029                                  ;	chain to the right piece and then do the index operation.
 37030                                  ;
 37031                                  ;   NOTE:
 37032                                  ;	This routine is called from SFFromHandle which is called
 37033                                  ;       at DOSINIT time with SS NOT DOSGROUP
 37034                                  ;
 37035                                  ;	ENTRY	BX has SF index
 37036                                  ;	EXIT	'C' clear if OK
 37037                                  ;		  ES:DI points to SF entry
 37038                                  ;		'C' set if index too large
 37039                                  ;	USES	BX, DI, ES
 37040                                  ;----------------------------------------------------------------------------
 37041                                  
 37042                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37043                                  
 37044                                  SFFromSFN:
 37045                                  	; 05/05/2019 - Retro DOS v4.0
 37046                                  	;getdseg <es>			; es -> dosdata
 37047 000064DB 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 37048                                  
 37049                                  	;LES	DI,[CS:SFT_ADDR]	; (es:di) = start of SFT table
 37050 000064E0 26C43E[2A00]            	les	di,[es:SFT_ADDR]
 37051                                  sfsfn5:	
 37052                                  	;cmp	bx,[es:di+4]
 37053 000064E5 263B5D04                	CMP	BX,[ES:DI+SFT.SFCount]	; is handle in this table?
 37054 000064E9 720E                    	JB	short sfsfn7		; yes, go grab it
 37055                                  	;sub	bx,[es:di+4]
 37056 000064EB 262B5D04                	SUB     BX,[ES:DI+SFT.SFCount]
 37057 000064EF 26C43D                  	les	di,[es:di] ; 14/08/2018
 37058                                  	;LES	DI,[ES:DI+SFT.SFLink]	; get next table segment
 37059 000064F2 83FFFF                  	CMP     DI,-1                   ; end of tables?
 37060 000064F5 75EE                    	JNZ	short sfsfn5		; no, try again
 37061 000064F7 F9                      	STC
 37062 000064F8 C3                      	retn				; return with error, not found
 37063                                  sfsfn7:
 37064 000064F9 50                      	push	ax
 37065                                  	;mov	ax,53 ; MSDOS 3.3
 37066                                  	;mov	ax,59 ; MSDOS 6.0
 37067                                  	;MOV	AX,SF_ENTRY.size	; put it in a nice place
 37068                                  	
 37069                                  	; 17/12/2022
 37070 000064FA B03B                    	mov	al,SF_ENTRY.size ; 28/05/2019
 37071                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37072                                  	;mov	ax,SF_ENTRY.size ; 59
 37073                                  	
 37074 000064FC F6E3                    	MUL	BL			; (ax) = offset into this SF block
 37075 000064FE 01C7                    	ADD	DI,AX			; add base of SF block
 37076 00006500 58                      	pop	ax
 37077                                  	;add	di,6
 37078 00006501 83C706                  	ADD	DI,SFT.SFTable		; offset into structure, 'C' cleared
 37079 00006504 C3                      	retn				; return with 'C' clear
 37080                                  
 37081                                  ;	BREAK <JFNFree - return a jfn pointer if one is free>
 37082                                  
 37083                                  ;**	JFNFree - Find a Free JFN Slot
 37084                                  ;----------------------------------------------------------------------------
 37085                                  ;	JFNFree scansthrough the JFN table and returnsa pointer to a free slot
 37086                                  ;
 37087                                  ;	ENTRY	(ss) = DOSDATA
 37088                                  ;	EXIT	'C' clear if OK
 37089                                  ;		  (bx) = new handle
 37090                                  ;		  (es:di) = pointer to JFN slot
 37091                                  ;		'C' set if error
 37092                                  ;		  (al) = error code
 37093                                  ;	USES	bx, di, es, flags
 37094                                  ;----------------------------------------------------------------------------
 37095                                  
 37096                                  JFNFree:
 37097 00006505 31DB                    	XOR	BX,BX			; (bx) = initial JFN to try
 37098                                  jfnf1:	
 37099 00006507 E89EFF                  	CALL	pJFNFromHandle		; get the appropriate handle
 37100 0000650A 7209                    	JC	short jfnf5		; no more handles
 37101 0000650C 26803DFF                	CMP     BYTE [ES:DI],-1		; free?
 37102 00006510 7405                    	je	short jfnfx		; yes, carry is clear
 37103 00006512 43                      	INC     BX                      ; no, next handle
 37104 00006513 EBF2                    	JMP	short jfnf1		; and try again
 37105                                  
 37106                                  	; Error. 'C' set
 37107                                  jfnf5:	
 37108                                  	;mov	al,4
 37109 00006515 B004                    	MOV	AL,error_too_many_open_files
 37110                                  jfnfx:	
 37111 00006517 C3                      	retn				; bye
 37112                                  
 37113                                  ;	BREAK <SFNFree - Allocate a free SFN>
 37114                                  
 37115                                  ;**	SFNFree - Allocate a Free SFN/SFT
 37116                                  ;----------------------------------------------------------------------------
 37117                                  ;	SFNFree scans through the sf table looking for a free entry
 37118                                  ;	If it finds one it partially allocates it by setting SFT_REF_COUNT = -1
 37119                                  ;
 37120                                  ;	The problem is that we want to mark the SFT busy so that other threads
 37121                                  ;	can't allocate the SFT before we're finished marking it up.  However,
 37122                                  ;	we can't just mark it busy because we may get blown out of our open
 37123                                  ;	by INT24 and leave the thing orphaned.	To solve this we mark it
 37124                                  ;	"allocation in progress" by setting SFT_REF_COUNT = -1.  If we see
 37125                                  ;	an SFT with this value we look to see if it belongs to this user
 37126                                  ;	and process.  If it does belong to us then it must be an orphan
 37127                                  ;	and we reclaim it.
 37128                                  ;
 37129                                  ;	BUGBUG - improve the performance. I guess it's smaller to call SFFromSFN
 37130                                  ;		over and over, but we could at least set a high water mark...
 37131                                  ;		cause an N^2 loop calling slow SFFromSFN is real slow, too slow
 37132                                  ;		even though this is not a frequently called routine - jgl
 37133                                  ;
 37134                                  ;	ENTRY	(ss) = DOSDATA
 37135                                  ;	EXIT	'C' clear if no error
 37136                                  ;		  (bx) = SFN
 37137                                  ;		  (es:di) = pointer to SFT
 37138                                  ;		  es:[di].SFT_REF_COUNT = -1
 37139                                  ;		'C' set if error
 37140                                  ;		  (al) = error code
 37141                                  ;	USES	bx, di, es, Flags
 37142                                  ;----------------------------------------------------------------------------
 37143                                  
 37144                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37145                                  	; DOSCODE:A682h (MSDOS 5.0 MSDOS.SYS)
 37146                                  
 37147                                  SFNFree:
 37148                                  	; 12/08/2018
 37149                                  	; 05/08/2018 - Retro DOS v3.0
 37150                                  	;
 37151                                  	; MSDOS 6.0
 37152 00006518 50                      	push	ax
 37153 00006519 31DB                    	xor	bx,bx			; (bx) = SFN to consider
 37154                                  sfnf5:	
 37155 0000651B 53                      	push	bx
 37156 0000651C E8BCFF                  	call	SFFromSFN		; get the potential handle
 37157 0000651F 5B                      	pop	bx
 37158 00006520 723A                    	jc	short sfnf95		; no more free SFNs
 37159 00006522 26833D00                	cmp	word [ES:DI],0
 37160                                  	;cmp	word [ES:DI+SF_ENTRY.sf_Ref_Count],0 ; free?
 37161 00006526 741D                    	je	short sfnf20			; yep, got one
 37162                                  	
 37163                                  	;cmp	word [es:di],0FFFFh ; -1
 37164 00006528 26833DFF                	cmp	word [ES:DI],sf_busy
 37165                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 37166 0000652C 7403                    	je	short sfnf10		; special busy mark
 37167                                  sfnf7:	
 37168 0000652E 43                      	inc	bx			; try the next one
 37169 0000652F EBEA                    	jmp	short sfnf5
 37170                                  
 37171                                  ;	The SFT has the special "busy" mark; if it belongs to us then
 37172                                  ;	it was abandoned during a earlier call and we can use it.
 37173                                  ;
 37174                                  ;	(bx)	= SFN
 37175                                  ;	(es:di) = pointer to SFT
 37176                                  ;	(TOS)	= caller's (ax)
 37177                                  
 37178                                  sfnf10:	
 37179 00006531 36A1[3E03]              	mov	ax,[SS:USER_ID]
 37180                                  	;cmp	[es:di+2Fh],ax
 37181 00006535 2639452F                	cmp	[ES:DI+SF_ENTRY.sf_UID],ax
 37182 00006539 75F3                    	jnz	short sfnf7		; not ours
 37183 0000653B 36A1[3C03]              	mov	ax,[SS:PROC_ID]
 37184                                  	;cmp	[es:di+31h],ax
 37185 0000653F 26394531                	cmp	[ES:DI+SF_ENTRY.sf_PID],ax
 37186 00006543 75E9                    	jnz	short sfnf7		; can't use this one, try the next
 37187                                  
 37188                                  ;	We have an SFT to allocate
 37189                                  ;
 37190                                  ;	(bx)	= SFN
 37191                                  ;	(es:di) = pointer to SFT
 37192                                  ;	(TOS)	= caller's (ax)
 37193                                  
 37194                                  sfnf20:
 37195                                  	; cf = 0 ;; Retro DOS v3.0
 37196                                  
 37197                                  	;mov	word [es:di],0FFFFh
 37198 00006545 26C705FFFF              	mov	word [ES:DI],sf_busy
 37199                                  					; make sure that this is allocated
 37200                                  	;mov	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 37201                                  
 37202 0000654A 36A1[3E03]              	mov	ax,[SS:USER_ID]
 37203                                  	;mov	[es:di+2Fh],ax
 37204 0000654E 2689452F                	mov	[ES:DI+SF_ENTRY.sf_UID],ax
 37205 00006552 36A1[3C03]              	mov	ax,[SS:PROC_ID]
 37206                                  	;mov	[es:di+31h],ax
 37207 00006556 26894531                	mov	[ES:DI+SF_ENTRY.sf_PID],ax
 37208                                  sfnf21: ;; Retro DOS v3.0
 37209                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37210                                  	;pop	ax
 37211                                  	;;clc
 37212                                  	;retn				; return with no error
 37213                                  	; 17/12/2022
 37214 0000655A 58                      	pop	ax
 37215                                  	;clc
 37216 0000655B C3                      	retn
 37217                                  
 37218                                  ;**	Error - no more free SFNs
 37219                                  ;
 37220                                  ;	'C' set
 37221                                  ;	(TOS) = saved ax
 37222                                  
 37223                                  sfnf95: 
 37224 0000655C 58                      	pop	ax
 37225                                  
 37226                                  ; 11/03/2024
 37227                                  %if 0
 37228                                  	;mov	al,4
 37229                                  	mov	al,error_too_many_open_files
 37230                                  	retn				; return with 'C' and error
 37231                                  %else
 37232                                  	; 11/03/2024
 37233 0000655D EBB6                    	jmp	short jfnf5
 37234                                  %endif
 37235                                  
 37236                                  ;============================================================================
 37237                                  ; HANDLE.ASM, MSDOS 6.0, 1991
 37238                                  ;============================================================================
 37239                                  ; 13/07/2018 - Retro DOS v3.0
 37240                                  ; 20/05/2019 - Retro DOS v4.0
 37241                                  
 37242                                  ; DOSCODE:A72Bh (MSDOS 6.21, MSDOS.SYS)
 37243                                  
 37244                                  ;	BREAK <$Close - return a handle to the system>
 37245                                  ;----------------------------------------------------------------------------
 37246                                  ;
 37247                                  ;**	$Close - Close a file Handle
 37248                                  ;
 37249                                  ;	BUGBUG - close gets called a LOT with invalid handles - sizzle that
 37250                                  ;		path
 37251                                  ;
 37252                                  ;	Assembler usage:
 37253                                  ;	    MOV     BX, handle
 37254                                  ;	    MOV     AH, Close
 37255                                  ;	    INT     int_command
 37256                                  ;
 37257                                  ;	ENTRY	(bx) = handle
 37258                                  ;	EXIT	<normal INT21 return convention>
 37259                                  ;	USES	all
 37260                                  ;
 37261                                  ;----------------------------------------------------------------------------
 37262                                  
 37263                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37264                                  ; DOSCODE:A6CBh (MSDOS 5.0 MSDOS.SYS)
 37265                                  
 37266                                  _$CLOSE:
 37267                                  ;	Grab the SFT pointer from the JFN.
 37268                                  
 37269 0000655F E84802                  	call	CheckOwner		; get system file entry
 37270 00006562 722B                    	jc	short CloseError	; error return
 37271 00006564 16                      	push	ss
 37272 00006565 1F                      	pop	ds			; For DOS_CLOSE
 37273 00006566 893E[9E05]              	MOV	[THISSFT],DI		; save offset of pointer
 37274 0000656A 8C06[A005]              	MOV	[THISSFT+2],ES		; save segment value
 37275                                  
 37276                                  ; DS:SI point to JFN table entry.
 37277                                  ; ES:DI point to SFT
 37278                                  ;
 37279                                  ; We now examine the user's JFN entry; If the file was a 70-mode file (network
 37280                                  ; FCB, we examine the ref count on the SFT; if it was 1, we free the JFN.
 37281                                  ; If the file was not a net FCB, we free the JFN too.
 37282                                  
 37283                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],1
 37284 0000656E 26833D01                	cmp	word [ES:DI],1		; will the SFT become free?
 37285 00006572 740A                    	jz	short FreeJFN 		; yes, free JFN anyway.
 37286                                  	;mov	al,[ES:DI+2]
 37287 00006574 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 37288                                  	;and	al,0F0h
 37289 00006578 24F0                    	AND	AL,SHARING_MASK
 37290                                  	;cmp	al,70h
 37291 0000657A 3C70                    	CMP	AL,SHARING_NET_FCB
 37292 0000657C 7407                    	JZ	short PostFree		; 70-mode and big ref count => free it
 37293                                  
 37294                                  ; The JFN must be freed. Get the pointer to it and replace the contents with
 37295                                  ; -1.
 37296                                  
 37297                                  FreeJFN:
 37298 0000657E E827FF                  	call	pJFNFromHandle		; d = pJFN (handle);
 37299 00006581 26C605FF                	MOV	BYTE [ES:DI],0FFh	; release the JFN
 37300                                  PostFree:
 37301                                  
 37302                                  ; ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_CLOSE!
 37303                                  
 37304 00006585 E8E3C8                  	call	DOS_CLOSE
 37305                                  
 37306                                  ; DOS_Close may return an error. If we see such an error, we report it but
 37307                                  ; the JFN stays closed because DOS_Close always frees the SFT!
 37308                                  
 37309 00006588 7205                    	JC	short CloseError
 37310                                  	;mov	ah,3Eh
 37311 0000658A B43E                    	MOV	AH,CLOSE		; MZ Bogus multiplan fix
 37312                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37313                                  CloseOk:
 37314 0000658C E9A2A0                  	jmp	SYS_RET_OK
 37315                                  CloseError:
 37316                                  CommitError:	; 11/03/2024
 37317 0000658F E9A8A0                  	jmp	SYS_RET_ERR
 37318                                  
 37319                                  ;	BREAK <$Commit - commit the file>
 37320                                  ;----------------------------------------------------------------------------
 37321                                  ;
 37322                                  ;**	$Commit - Commit a File
 37323                                  ;
 37324                                  ;	$Commit "commits" a file to disk - all of it's buffers are
 37325                                  ;	flushed out. BUGBUG - I'm pretty sure that $Commit doesn't update
 37326                                  ;	the directory entry, etc., so this commit is pretty useless. check
 37327                                  ;	and fix this!! jgl
 37328                                  ;
 37329                                  ;	Assembler usage:
 37330                                  ;	    MOV     BX, handle
 37331                                  ;	    MOV     AH, Commit
 37332                                  ;	    INT     int_command
 37333                                  ;
 37334                                  ;	ENTRY	(bx) = handle
 37335                                  ;	EXIT	none
 37336                                  ;	USES	all
 37337                                  ;;----------------------------------------------------------------------------
 37338                                  
 37339                                  _$COMMIT:
 37340                                  ;	Grab the SFT pointer from the JFN.
 37341                                  
 37342 00006592 E81502                  	call	CheckOwner		; get system file entry
 37343                                  	;JC	short CommitError	; error return
 37344                                  	; 11/03/2024
 37345 00006595 72F8                    	jc	short CommitError
 37346                                  
 37347 00006597 16                      	push	ss
 37348 00006598 1F                      	pop	ds			; For DOS_COMMIT
 37349 00006599 893E[9E05]              	MOV	[THISSFT],DI		; save offset of pointer
 37350 0000659D 8C06[A005]              	MOV	[THISSFT+2],ES		; save segment value
 37351                                  
 37352                                  ;	ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_COMMIT
 37353                                  ;
 37354                                  ;	ES:DI point to SFT
 37355                                  
 37356 000065A1 E808CA                  	call	DOS_COMMIT
 37357 000065A4 72E9                    	JC	short CommitError
 37358                                  	; 07/12/2022
 37359                                  	;jc	short CloseError
 37360                                  	;mov	ah,68h
 37361 000065A6 B468                    	MOV	AH,COMMIT
 37362                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37363                                  	;jmp	SYS_RET_OK
 37364                                  CommitOk:
 37365 000065A8 EBE2                    	jmp	short CloseOk
 37366                                  
 37367                                  ; 11/03/2024
 37368                                  ;CommitError:
 37369                                  ;	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37370                                  ;	;jmp	SYS_RET_ERR
 37371                                  ;	jmp	short CloseError
 37372                                  
 37373                                  ;	BREAK <$ExtHandle - extend handle count>
 37374                                  
 37375                                  ;**	$ExtHandle - Extend Handle Count
 37376                                  ;----------------------------------------------------------------------------
 37377                                  ;	Assembler usage:
 37378                                  ;	    MOV     BX, Number of Opens Allowed (MAX=65534;66535 is
 37379                                  ;	    MOV     AX, 6700H			 reserved to mark SFT
 37380                                  ;	    INT     int_command 		 busy )
 37381                                  ;
 37382                                  ;	ENTRY	(bx) = new number of handles
 37383                                  ;	EXIT	'C' clear if OK
 37384                                  ;		'C' set iff err
 37385                                  ;		  (ax) = error code
 37386                                  ;			 AX = error_not_enough_memory
 37387                                  ;			      error_too_many_open_files
 37388                                  ;	USES	all
 37389                                  ;----------------------------------------------------------------------------
 37390                                  
 37391                                  _$ExtHandle:
 37392 000065AA 31ED                    	XOR	BP,BP			; 0: enlarge  1: shrink  2:psp
 37393                                  	;cmp	bx,20
 37394 000065AC 83FB14                  	CMP	BX,FILPERPROC
 37395 000065AF 7303                    	JAE	short exth2		; Don't set less than FilPerProc no
 37396 000065B1 BB1400                  	MOV	BX,FILPERPROC
 37397                                  exth2:	
 37398 000065B4 368E06[3003]            	MOV	ES,[ss:CurrentPDB]	; get user process data block;smr;SS Override
 37399                                  	;mov	cx,[ES:32h]
 37400 000065B9 268B0E3200              	MOV	CX,[ES:PDB.JFN_Length]	; get number of handle allowed
 37401 000065BE 39CB                    	CMP	BX,CX			; the requested == current
 37402                                  	;JE	short ok_done 		; yes and exit
 37403                                  	; 11/03/2024
 37404 000065C0 74CA                    	je	short CloseOk
 37405 000065C2 771E                    	JA	short larger		; go allocate new table
 37406                                  
 37407                                  ;	We're going to shrink the # of handles available
 37408                                  
 37409                                  	;MOV	BP,1			; shrink
 37410                                  	; 11/03/2024
 37411 000065C4 45                      	inc	bp
 37412                                  	;mov	ds,[ES:36h]
 37413 000065C5 268E1E3600              	MOV	DS,[ES:PDB.JFN_Pointer+2] ;
 37414 000065CA 89DE                    	MOV	SI,BX			;
 37415 000065CC 29D9                    	SUB	CX,BX			; get difference
 37416                                  
 37417                                  ;	BUGBUG - code a SCASB here, should be a bit smaller
 37418                                  chck_handles:
 37419 000065CE 803CFF                  	CMP	BYTE [SI],-1		; scan through handles to ensure close
 37420 000065D1 753A                    	JNZ	short too_many_files	; status
 37421 000065D3 46                      	INC	SI
 37422 000065D4 E2F8                    	LOOP	chck_handles
 37423 000065D6 83FB14                  	CMP	BX,FILPERPROC		; = 20
 37424 000065D9 7707                    	JA	short larger		; no
 37425                                  
 37426                                  	;MOV	BP,2			; psp
 37427                                  	; 11/03/2024
 37428 000065DB 45                      	inc	bp
 37429                                  	;mov	di,24
 37430 000065DC BF1800                  	MOV	DI,PDB.JFN_TABLE	; es:di -> jfn table in psp
 37431 000065DF 53                      	PUSH	BX
 37432 000065E0 EB1C                    	JMP	short movhandl
 37433                                  
 37434                                  larger:
 37435 000065E2 83FBFF                  	CMP	BX,-1			; 65535 is not allowed
 37436 000065E5 747C                    	JZ	short invalid_func	; 10/08/2018
 37437 000065E7 F8                      	CLC
 37438 000065E8 53                      	PUSH	BX			; save requested number
 37439 000065E9 83C30F                  	ADD	BX,0FH			; adjust to paragraph boundary
 37440 000065EC B104                    	MOV	CL,4
 37441                                  	;ror	bx,cl			; MSDOS 3.3
 37442 000065EE D3DB                    	RCR	BX,CL			; DOS 4.00 fix		;AC000;
 37443                                  	;AND	BX,1FFFH		; clear most 3 bits
 37444                                  	; 01/07/2024
 37445 000065F0 80E71F                  	and	bh,1Fh
 37446                                  
 37447 000065F3 55                      	PUSH	BP
 37448 000065F4 E8FDFA                  	call	_$ALLOC			; allocate memory
 37449 000065F7 5D                      	POP	BP
 37450 000065F8 7264                    	JC	short no_memory		; not enough memory
 37451                                  
 37452 000065FA 8EC0                    	MOV	ES,AX			; es:di points to new table memory
 37453 000065FC 31FF                    	XOR	DI,DI
 37454                                  movhandl:
 37455 000065FE 368E1E[3003]            	MOV	DS,[ss:CurrentPDB] 	; get user PDB address	;smr;SS Override
 37456                                  
 37457 00006603 F7C50300                	test	BP,3			; enlarge ?
 37458 00006607 7409                    	JZ	short enlarge 		; yes
 37459 00006609 59                      	POP	CX			; cx = the amount you shrink
 37460 0000660A 51                      	PUSH	CX
 37461 0000660B EB09                    	JMP	short copy_hand
 37462                                  
 37463                                  ;	Done.  'C' clear
 37464                                  
 37465                                  ; 17/12/2022
 37466                                  ;ok_done:
 37467                                  ;	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37468                                  ;	;jmp	short CommitOk
 37469                                  ;	; 17/12/2022
 37470                                  ;	jmp	SYS_RET_OK
 37471                                  
 37472                                  too_many_files:
 37473                                  	;mov	al,4
 37474 0000660D B004                    	MOV	AL,error_too_many_open_files
 37475                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37476                                  	;jmp	SYS_RET_ERR
 37477                                  CommitErrorj:
 37478                                  	;jmp	short CommitError
 37479                                  	; 17/12/2022
 37480 0000660F E928A0                  	jmp	SYS_RET_ERR
 37481                                  
 37482                                  ; 11/03/2024
 37483                                  ; 17/12/2022
 37484                                  ;ok_done:
 37485                                  ;	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37486                                  ;	;jmp	short CommitOk
 37487                                  ;	; 17/12/2022
 37488                                  ;	jmp	SYS_RET_OK
 37489                                  
 37490                                  enlarge:
 37491                                  	;mov	cx,[32h]
 37492 00006612 8B0E3200                	MOV	CX,[PDB.JFN_Length]	; get number of old handles
 37493                                  copy_hand:
 37494 00006616 89CA                    	MOV	DX,CX
 37495                                  	;lds	si,[34h]
 37496 00006618 C5363400                	LDS	SI,[PDB.JFN_Pointer]	; get old table pointer
 37497 0000661C F3A4                    	REP	MOVSB			; copy information to new table
 37498 0000661E 59                      	POP	CX			; get new number of handles
 37499 0000661F 51                      	PUSH	CX			; save it again
 37500 00006620 29D1                    	SUB	CX,DX			; get the difference
 37501 00006622 B0FF                    	MOV	AL,-1			; set availability to handles
 37502 00006624 F3AA                    	REP	STOSB
 37503 00006626 368E1E[3003]            	MOV	DS,[ss:CurrentPDB] 	; get user process data block;smr;SS Override
 37504                                  	;cmp	word [34h],0
 37505 0000662B 833E340000              	CMP	WORD [PDB.JFN_Pointer],0 ; check if original table pointer
 37506 00006630 750D                    	JNZ	short update_info	; yes, go update PDB entries
 37507 00006632 55                      	PUSH	BP
 37508 00006633 1E                      	PUSH	DS			; save old table segment
 37509 00006634 06                      	PUSH	ES			; save new table segment
 37510 00006635 8E063600                	MOV	ES,[PDB.JFN_Pointer+2]	; get old table segment
 37511 00006639 E82DFC                  	call	_$DEALLOC		; deallocate old table memory
 37512 0000663C 07                      	POP	ES			; restore new table segment
 37513 0000663D 1F                      	POP	DS			; restore old table segment
 37514 0000663E 5D                      	POP	BP
 37515                                  
 37516                                  update_info:
 37517 0000663F F7C50200                	test	BP,2			; psp?
 37518 00006643 7408                    	JZ	short non_psp 		; no
 37519                                  	;mov	word [34h],18h ; 24
 37520 00006645 C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE ; restore
 37521 0000664B EB06                    	JMP	short final
 37522                                  non_psp:
 37523                                  	;mov	word [34h],0
 37524 0000664D C70634000000            	MOV	WORD [PDB.JFN_Pointer],0 ; new table pointer offset always 0
 37525                                  final:
 37526                                  	;mov	[36h],es	
 37527 00006653 8C063600                	MOV	[PDB.JFN_Pointer+2],ES	; update table pointer segment
 37528                                  	;pop	word [32h]
 37529 00006657 8F063200                	POP	word [PDB.JFN_Length]	; restore new number of handles
 37530                                  	; 11/03/2024
 37531                                  ok_done:
 37532                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37533 0000665B E9D39F                  	jmp	SYS_RET_OK
 37534                                  ;ok_done_j:
 37535                                  ;	jmp	short ok_done
 37536                                  
 37537                                  no_memory:
 37538 0000665E 5B                      	POP	BX			; clean stack
 37539                                  	;mov	al,8
 37540 0000665F B008                    	MOV	AL,error_not_enough_memory
 37541                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37542                                  	;jmp	SYS_RET_ERR
 37543                                  CommitErrorj2:
 37544 00006661 EBAC                    	jmp	short CommitErrorj
 37545                                  
 37546                                  invalid_func:
 37547                                  	;mov	al,1
 37548 00006663 B001                    	MOV	AL,error_invalid_function
 37549                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37550                                  	;jmp	SYS_RET_ERR
 37551                                  CommitErrorj3:
 37552                                  	;jmp	short CommitErrorj2
 37553                                  	; 17/12/2022
 37554 00006665 EBA8                    	jmp	short CommitErrorj
 37555                                  
 37556                                  ; 20/05/2019 - Retro DOS v4.0
 37557                                  ; DOSCODE:A83Ah (MSDOS 6.21, MSDOS.SYS)
 37558                                  
 37559                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37560                                  ; DOSCODE:A7DAh (MSDOS 5.0 MSDOS.SYS)
 37561                                  
 37562                                  ;	BREAK <$READ - Read from a file handle>
 37563                                  ;----------------------------------------------------------------------------
 37564                                  ;
 37565                                  ;**	$Read - Read from a File Handle
 37566                                  ;
 37567                                  ;   Assembler usage:
 37568                                  ;
 37569                                  ;	LDS	DX, buf
 37570                                  ;	MOV	CX, count
 37571                                  ;	MOV	BX, handle
 37572                                  ;	MOV	AH, Read
 37573                                  ;	INT	int_command
 37574                                  ;	  AX has number of bytes read
 37575                                  ;
 37576                                  ;	ENTRY	(bx) = file handle
 37577                                  ;		(cx) = byte count
 37578                                  ;		(ds:dx) = buffer address
 37579                                  ;	EXIT	Through system call return so that to user:
 37580                                  ;		  'C' clear if OK
 37581                                  ;		    (ax) = bytes read
 37582                                  ;		  'C' set if error
 37583                                  ;		    (ax) = error code
 37584                                  ;
 37585                                  ;----------------------------------------------------------------------------
 37586                                  
 37587                                  	; 12/03/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
 37588                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:0A83Ah
 37589                                  
 37590                                  	; (PCDOS 7.1 IBMDOS.COM - DOSCODE:0BA2Eh)
 37591                                  	; (Windows ME IO.SYS - BIOSCODE:0A256h)
 37592                                  
 37593                                  _$READ:
 37594 00006667 BE[F031]                	MOV	SI,DOS_READ
 37595                                  ReadDo:
 37596 0000666A E83BFE                  	call	pJFNFromHandle
 37597 0000666D 7208                    	JC	short ReadError
 37598                                  
 37599 0000666F 268A05                  	MOV	AL,[ES:DI]
 37600 00006672 E83501                  	call	CheckOwner		; get the handle
 37601 00006675 7303                    	JNC	short ReadSetup		; no errors do the operation
 37602                                  
 37603                                  ;	Have an error. 'C' set
 37604                                  
 37605                                  ReadError:
 37606                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37607                                  	;;jmp	SYS_RET_ERR		; go to error traps
 37608                                  	;jmp	short CommitErrorj3
 37609                                  	; 17/12/2022
 37610 00006677 E9C09F                  	jmp	SYS_RET_ERR
 37611                                  
 37612                                  ReadSetup:
 37613 0000667A 36893E[9E05]            	MOV	[ss:THISSFT],DI		; save offset of pointer;smr;SS Override
 37614 0000667F 368C06[A005]            	MOV	[ss:THISSFT+2],ES	; save segment value	;smr;SS Override
 37615                                  	; 20/05/2019 - Retro DOS v4.0
 37616                                  	; MSDOS 6.0 
 37617                                  ;; Extended Open
 37618                                  	;test	byte [es:di+3],20h
 37619 00006684 26F6450320              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],(INT_24_ERROR>>8)
 37620                                  						 ;AN000;;EO. need i24
 37621 00006689 7406                    	JZ	short needi24 		     	 ;AN000;;EO. yes
 37622 0000668B 36800E[F605]02          	OR	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF ; 2
 37623                                  					;AN000;;EO. set it off;smr;SS Override
 37624                                  needi24:				;AN000;
 37625                                  
 37626                                  ; 12/03/2024
 37627                                  %if 0
 37628                                  
 37629                                  ;; Extended Open
 37630                                  	push	word [SS:DMAADD]
 37631                                  	push	word [SS:DMAADD+2]	;smr;SS Override
 37632                                  
 37633                                  ;;;;;	BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 37634                                  
 37635                                  	; 26/07/2019
 37636                                  
 37637                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37638                                  	;
 37639                                  	; (It is not necessary to call 'Align_Buffer' proc here/below because
 37640                                  	; there is not another caller; it is better to put the code in this proc
 37641                                   	; here instead of calling it as a subroutine; but I have modified code
 37642                                  	; here for MSDOS 5.0 MSDOS.SYS address compatibility)
 37643                                  
 37644                                  	; MSDOS 6.0
 37645                                  	CALL	Align_Buffer		;AN000;MS. align user's buffer
 37646                                  	
 37647                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37648                                  	; MSDOS 3.3
 37649                                  	;MOV	BX,DX			; copy offset
 37650                                  	;push	cx			; don't stomp on count
 37651                                  	;MOV	CL,4			; bits to shift bytes->para
 37652                                  	;SHR	BX,CL			; get number of paragraphs
 37653                                  	;pop	cx			; get count back
 37654                                  	;MOV	AX,DS			; get original segment
 37655                                  	;ADD	AX,BX			; get new segment
 37656                                  	;MOV	DS,AX			; in seg register
 37657                                  	;AND	DX,0Fh			; normalize offset
 37658                                  	;MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 37659                                  	;MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 37660                                  						;smr;SS Override
 37661                                  %else
 37662                                  	; 12/03/2024 (PCDOS 7.1 IBMDOS.COM)
 37663                                  	;;;
 37664 00006691 8CD8                    	mov	ax,ds			; original segment
 37665 00006693 36C51E[2C03]            	lds	bx,[ss:DMAADD]
 37666 00006698 53                      	push	bx
 37667 00006699 1E                      	push	ds
 37668 0000669A 89D3                    	mov	bx,dx
 37669 0000669C D1EB                    	shr	bx,1
 37670 0000669E D1EB                    	shr 	bx,1
 37671 000066A0 D1EB                    	shr	bx,1
 37672 000066A2 D1EB                    	shr	bx,1
 37673 000066A4 01D8                    	add	ax,bx			; new segment
 37674 000066A6 83E20F                  	and	dx,0Fh			; normalize offset
 37675                                  	;mov	[ss:DMAADD],dx		; use user DX as offset
 37676                                  	; 23/03/2024
 37677 000066A9 36A3[2E03]              	mov	[ss:DMAADD+2],ax 	; use user DS as segment for DMA
 37678                                  	;;;
 37679                                  
 37680                                  %endif
 37681                                  
 37682                                  ;;;;;	END BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 37683                                  	
 37684 000066AD 16                      	push	ss			; go for DOS addressability
 37685 000066AE 1F                      	pop	ds
 37686                                  
 37687                                  	; 12/03/2024 - Retro DOS v4.2
 37688                                  	;;;
 37689 000066AF 8916[2C03]              	mov	[DMAADD],dx	
 37690                                  	;;;
 37691                                  
 37692 000066B3 FFD6                    	CALL	SI ; DOS_READ		; indirect call to operation
 37693                                  
 37694 000066B5 8F06[2E03]              	pop	word [DMAADD+2]
 37695 000066B9 8F06[2C03]              	pop	word [DMAADD]
 37696                                  	;JNC	short READ_OK		;AN002;
 37697                                  	;JMP	short ReadError		;AN002; if error, say bye bye
 37698                                  	; 17/12/2022
 37699 000066BD 72B8                    	jc	short ReadError
 37700                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37701                                  	;jnc	short READ_OK		;AN002;
 37702                                  	;jmp	short ReadError
 37703                                  
 37704                                  READ_OK:
 37705 000066BF 89C8                    	MOV	AX,CX			; get correct return in correct reg
 37706                                  Read_Okj:
 37707                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37708                                  	;;jmp	SYS_RET_OK		; successful return
 37709                                  	;jmp	short ok_done_j
 37710                                  	; 17/12/2022
 37711 000066C1 E96D9F                  	jmp	SYS_RET_OK
 37712                                  
 37713                                  ; 13/07/2018 - Retro DOS v3.0
 37714                                  
 37715                                  ;----------------------------------------------------------------------------
 37716                                  
 37717                                  ; 12/03/2024
 37718                                  %if 0
 37719                                  
 37720                                  ;   Input: DS:DX points to user's buffer addr
 37721                                  ;   Function: rearrange segment and offset for READ/WRITE buffer
 37722                                  ;   Output: [DMAADD] set
 37723                                  
 37724                                  ; 20/05/2019 - Retro DOS v4.0
 37725                                  ; 26/07/2019
 37726                                  ;	; MSDOS 6.0
 37727                                  ;Align_Buffer:
 37728                                  ;	MOV	BX,DX			; copy offset
 37729                                  ;	push	cx			; don't stomp on count
 37730                                  ;	MOV	CL,4			; bits to shift bytes->para
 37731                                  ;	SHR	BX,CL			; get number of paragraphs
 37732                                  ;	pop	cx			; get count back
 37733                                  ;	MOV	AX,DS			; get original segment
 37734                                  ;	ADD	AX,BX			; get new segment
 37735                                  ;	MOV	DS,AX			; in seg register
 37736                                  ;	AND	DX,0Fh			; normalize offset
 37737                                  ;	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 37738                                  ;	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 37739                                  ;						;smr;SS Override
 37740                                  ;	retn
 37741                                  
 37742                                  ; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37743                                  Align_Buffer:
 37744                                  	MOV	BX,DX			; copy offset
 37745                                  	push	cx			; don't stomp on count
 37746                                  	MOV	CL,4			; bits to shift bytes->para
 37747                                  	SHR	BX,CL			; get number of paragraphs
 37748                                  	pop	cx			; get count back
 37749                                  	MOV	AX,DS			; get original segment
 37750                                  	ADD	AX,BX			; get new segment
 37751                                  	MOV	DS,AX			; in seg register
 37752                                  	AND	DX,0Fh			; normalize offset
 37753                                  	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 37754                                  	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 37755                                  						;smr;SS Override
 37756                                  	retn
 37757                                  
 37758                                  %endif
 37759                                  
 37760                                  ; 20/05/2019 - Retro DOS v4.0
 37761                                  ; DOSCODE:A8A0h (MSDOS 6.21, MSDOS.SYS)
 37762                                  
 37763                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37764                                  ; DOSCODE:A840h (MSDOS 5.0 MSDOS.SYS)
 37765                                  
 37766                                  ; 12/03/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
 37767                                  ; MSDOS 6.22 MSDOS.SYS - DOSCODE:0A8A0h
 37768                                  
 37769                                  ; (PCDOS 7.1 IBMDOS.COM - DOSCODE:0BA8Ch)
 37770                                  ; (Windows ME IO.SYS - BIOSCODE:0A2B9h)
 37771                                  
 37772                                  ;BREAK <$WRITE - write to a file handle>
 37773                                  ;----------------------------------------------------------------------------
 37774                                  ;
 37775                                  ;   Assembler usage:
 37776                                  ;	    LDS     DX, buf
 37777                                  ;	    MOV     CX, count
 37778                                  ;	    MOV     BX, handle
 37779                                  ;	    MOV     AH, Write
 37780                                  ;	    INT     int_command
 37781                                  ;	  AX has number of bytes written
 37782                                  ;   Errors:
 37783                                  ;	    AX = write_invalid_handle
 37784                                  ;	       = write_access_denied
 37785                                  ;
 37786                                  ;   Returns in register AX
 37787                                  ;
 37788                                  ;----------------------------------------------------------------------------
 37789                                  
 37790                                  _$WRITE:
 37791 000066C4 BE[F033]                	MOV	SI,DOS_WRITE
 37792 000066C7 EBA1                    	JMP	short ReadDo
 37793                                  
 37794                                  ;BREAK <$LSEEK - move r/w pointer>
 37795                                  ;----------------------------------------------------------------------------
 37796                                  ;
 37797                                  ;   Assembler usage:
 37798                                  ;	    MOV     DX, offsetlow
 37799                                  ;	    MOV     CX, offsethigh
 37800                                  ;	    MOV     BX, handle
 37801                                  ;	    MOV     AL, method
 37802                                  ;	    MOV     AH, LSeek
 37803                                  ;	    INT     int_command
 37804                                  ;	  DX:AX has the new location of the pointer
 37805                                  ;   Error returns:
 37806                                  ;	    AX = error_invalid_handle
 37807                                  ;	       = error_invalid_function
 37808                                  ;   Returns in registers DX:AX
 37809                                  ;
 37810                                  ;----------------------------------------------------------------------------
 37811                                  
 37812                                  ; 21/05/2019 - Retro DOS v4.0
 37813                                  ; DOSCODE:A8A5h (MSDOS 6.21, MSDOS.SYS)
 37814                                  
 37815                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37816                                  ; DOSCODE:A845h (MSDOS 5.0 MSDOS.SYS)
 37817                                  
 37818                                  _$LSEEK:
 37819 000066C9 E8DE00                  	call	CheckOwner		; get system file entry
 37820                                  
 37821                                  	; 17/12/2022
 37822                                  ;LSeekError:
 37823                                  	;JNC	short CHKOWN_OK		;AN002;
 37824                                  	;JMP	short ReadError		;AN002; error return
 37825                                  	; 17/12/2022
 37826                                  	; 02/06/2019
 37827 000066CC 72A9                    	jc	short ReadError
 37828                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37829                                  	;JNC	short CHKOWN_OK		;AN002;
 37830                                  	;JMP	short ReadError		;AN002; error return
 37831                                  
 37832                                  CHKOWN_OK:
 37833                                  					;AN002;
 37834 000066CE 3C02                    	CMP	AL,2			; is the seek value correct?
 37835 000066D0 760A                    	JBE	short LSeekDisp		; yes, go dispatch
 37836                                  	;mov	byte [ss:EXTERR_LOCUS],1 
 37837 000066D2 36C606[2303]01          	MOV	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 37838                                  					;smr;SS Override
 37839                                  	;mov	al,1
 37840 000066D8 B001                    	mov	al,error_invalid_function ; invalid method
 37841                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37842                                  LSeekError2:
 37843 000066DA EB9B                    	jmp	short ReadError
 37844                                  
 37845                                  LSeekDisp:
 37846 000066DC 3C01                    	CMP	AL,1			; best way to dispatch; check middle
 37847 000066DE 720A                    	JB	short LSeekStore	; just store CX:DX
 37848 000066E0 771B                    	JA	short LSeekEOF		; seek from end of file
 37849                                  	;add	dx,[es:di+21]
 37850 000066E2 26035515                	ADD	DX,[ES:DI+SF_ENTRY.sf_position]
 37851                                  	;adc	cx,[es:di+23]
 37852 000066E6 26134D17                	ADC	CX,[ES:DI+SF_ENTRY.sf_position+2]
 37853                                  LSeekStore:
 37854 000066EA 89C8                    	MOV	AX,CX			; AX:DX
 37855 000066EC 92                      	XCHG	AX,DX			; DX:AX is the correct value
 37856                                  LSeekSetpos:
 37857                                  	;mov	[es:di+21],ax
 37858 000066ED 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 37859                                  	;mov	[es:di+23],dx
 37860 000066F1 26895517                	MOV	[ES:DI+SF_ENTRY.sf_position+2],DX
 37861 000066F5 E8899D                  	call	Get_User_Stack
 37862                                  	;mov	[si+6],dx
 37863 000066F8 895406                  	MOV	[SI+user_env.user_DX],DX ; return DX:AX
 37864                                  	;jmp	SYS_RET_OK		; successful return
 37865                                  	; 25/06/2019
 37866                                  	;jmp	SYS_RET_OK_clc
 37867                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37868                                  	;jmp	SYS_RET_OK_clc
 37869                                  LSeekOk:
 37870 000066FB EBC4                    	jmp     short Read_Okj
 37871                                  
 37872                                  LSeekEOF:
 37873                                  	;;test	word [es:di+5],8000h
 37874                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 37875                                  	; 21/05/2019 - Retro DOS v4.0
 37876 000066FD 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 37877 00006702 750A                    	JNZ	short Check_LSeek_Mode	; Is Net
 37878                                  LOCAL_LSeek:
 37879                                  	;add	dx,[es:di+17]
 37880 00006704 26035511                	ADD	DX,[ES:DI+SF_ENTRY.sf_size]
 37881                                  	;adc	cx,[es:di+19]
 37882 00006708 26134D13                	ADC	CX,[ES:DI+SF_ENTRY.sf_size+2]
 37883 0000670C EBDC                    	JMP	short LSeekStore	; go and set the position
 37884                                  
 37885                                  Check_LSeek_Mode:
 37886                                  	;;test	word [es:di+2],8000h
 37887                                  	;test	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 37888                                  	; 21/05/2019
 37889 0000670E 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 37890 00006713 75EF                    	JNZ	short LOCAL_LSeek	; FCB treated like local file
 37891                                  	;mov	ax,[es:di+2]
 37892 00006715 268B4502                	MOV	AX,[ES:DI+SF_ENTRY.sf_mode]
 37893                                  	;and	ax,0F0h
 37894 00006719 25F000                  	AND	AX,SHARING_MASK
 37895                                  	;cmp	ax,40h
 37896 0000671C 83F840                  	CMP	AX,SHARING_DENY_NONE
 37897 0000671F 7405                    	JZ	short NET_LSEEK		; LSEEK exported in this mode
 37898                                  	;cmp	ax,30h
 37899 00006721 83F830                  	CMP	AX,SHARING_DENY_READ
 37900 00006724 75DE                    	JNZ	short LOCAL_LSeek	; Treated like local Lseek
 37901                                  NET_LSEEK:
 37902                                  ;	JMP	short LOCAL_LSeek
 37903                                  ; REMOVE ABOVE INSTRUCTION TO ENABLE DCR 142
 37904                                  	;CallInstall Net_Lseek,MultNET,33
 37905                                  	;JNC	short LSeekSetPos
 37906                                  
 37907 00006726 B82111                  	mov     ax,1121h
 37908 00006729 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE
 37909                                  			; CX:DX = offset (in bytes) from end
 37910                                  			; ES:DI -> SFT, SFT DPB field -> DPB of drive with file
 37911                                  			; SS = DOS CS
 37912                                  			; Return: CF set on error
 37913                                  			; CF clear if successful, DX:AX = new file position
 37914 0000672B 73C0                    	jnb     short LSeekSetpos
 37915                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37916                                  	;jmp	SYS_RET_ERR
 37917                                  ;LSeekError3:
 37918                                  	; 17/12/2022
 37919                                  LSeekError:
 37920                                  	;jmp	short LSeekError2
 37921                                  DupErr:	; 17/12/2022
 37922 0000672D E90A9F                  	jmp	SYS_RET_ERR
 37923                                  
 37924                                  ;BREAK <FileTimes - modify write times on a handle>
 37925                                  ;----------------------------------------------------------------------------
 37926                                  ;
 37927                                  ;   Assembler usage:
 37928                                  ;	    MOV AH, FileTimes (57H)
 37929                                  ;	    MOV AL, func
 37930                                  ;	    MOV BX, handle
 37931                                  ;	; if AL = 1 then then next two are mandatory
 37932                                  ;	    MOV CX, time
 37933                                  ;	    MOV DX, date
 37934                                  ;	    INT 21h
 37935                                  ;	; if AL = 0 then CX/DX has the last write time/date
 37936                                  ;	; for the handle.
 37937                                  ;
 37938                                  ;	AL=02		 get extended attributes
 37939                                  ;	   BX=handle
 37940                                  ;	   CX=size of buffer (0, return max size )
 37941                                  ;	   DS:SI query list (si=-1, selects all EA)
 37942                                  ;	   ES:DI buffer to hold EA list
 37943                                  ;
 37944                                  ;	AL=03		 get EA name list
 37945                                  ;	   BX=handle
 37946                                  ;	   CX=size of buffer (0, return max size )
 37947                                  ;	   ES:DI buffer to hold name list
 37948                                  ;
 37949                                  ;	AL=04		 set extended attributes
 37950                                  ;	   BX=handle
 37951                                  ;	   ES:DI buffer of EA list
 37952                                  ;
 37953                                  ;
 37954                                  ;   Error returns:
 37955                                  ;	    AX = error_invalid_function
 37956                                  ;	       = error_invalid_handle
 37957                                  ;
 37958                                  ;----------------------------------------------------------------------------
 37959                                  
 37960                                  ; 21/05/2019 - Retro DOS v4.0
 37961                                  ; DOSCODE:A90Dh (MSDOS 6.21, MSDOS.SYS)
 37962                                  
 37963                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37964                                  ; DOSCODE:A8ADh (MSDOS 5.0 MSDOS.SYS)
 37965                                  
 37966                                  _$FILE_TIMES:
 37967                                  	; 13/07/2018 - Retro DOS v3.0
 37968                                  
 37969                                  	; MSDOS 3.3
 37970                                  	;cmp	al,2			; correct subfunction ?
 37971                                  	;jb	short ft1
 37972                                  
 37973                                  	;;mov	byte [ss:EXTERR_LOCUS], 1
 37974                                  	;mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 37975                                  						;SS Overr
 37976                                  	;;mov	al,1
 37977                                  	;mov	al,error_invalid_function ; give bad return
 37978                                  	;jmp	SYS_RET_ERR
 37979                                  
 37980                                  	; MSDOS 6.0
 37981 00006730 3C02                    	cmp	al,2			; correct subfunction ?
 37982 00006732 7340                    	jae	short inval_func
 37983                                  ;ft1:
 37984 00006734 E87300                  	call	CheckOwner		; get sft
 37985                                  	; 17/12/2022
 37986 00006737 72F4                    	jc	short LSeekError	; bad handle
 37987                                  
 37988 00006739 08C0                    	or	al,al			; get time/date ?
 37989 0000673B 7515                    	jnz	short ft_set_time
 37990                                  
 37991                                  ;------ here we get the time & date from the sft for the user
 37992                                  
 37993 0000673D FA                      	cli				; is this cli/sti reqd ? BUGBUG
 37994                                  	;mov	cx,[es:di+13]
 37995 0000673E 268B4D0D                	mov	cx,[es:di+SF_ENTRY.sf_time] ; get the time
 37996                                  	;mov	dx,[es:di+15]
 37997 00006742 268B550F                	mov	dx,[es:di+SF_ENTRY.sf_date] ;  & date
 37998 00006746 FB                      	sti
 37999 00006747 E8379D                  	call	Get_User_Stack
 38000                                  	;mov	[si+4],cx
 38001 0000674A 894C04                  	mov	[si+user_env.user_CX],cx
 38002                                  	;mov	[si+6],dx
 38003 0000674D 895406                  	mov	[si+user_env.user_DX],dx
 38004 00006750 EB1F                    	jmp	short ok_ret
 38005                                  
 38006                                  ;------ here we set the time in sft
 38007                                  
 38008                                  ft_set_time:
 38009 00006752 E88DAB                  	call    ECritSFT
 38010                                  	;mov	[es:di+13],cx
 38011 00006755 26894D0D                	mov	[es:di+SF_ENTRY.sf_time],cx ; drop in new time
 38012                                  	;mov	[es:di+15],dx
 38013 00006759 2689550F                	mov	[es:di+SF_ENTRY.sf_date],dx ;  and date	
 38014                                  
 38015 0000675D 31C0                    	xor	ax, ax
 38016 0000675F 36FF1E[C800]            	call	far [ss:JShare+(14*4)] ; 14 = ShSU	; SS Override
 38017                                  
 38018                                  ;------ set the flags in SFT entry
 38019                                  	;and	word [es:di+5],0FFBFh
 38020                                  	; 18/12/2022
 38021                                  	;and	byte [es:di+5],0BFh
 38022 00006764 26806505BF              	and	byte [es:di+SF_ENTRY.sf_flags],~devid_file_clean
 38023                                  	;and	word [es:di+SF_ENTRY.sf_flags],~devid_file_clean 
 38024                                  							; mark file as dirty
 38025                                  	;or	word [es:di+5],4000h
 38026                                  	; 17/12/2022
 38027                                  	;or	byte [es:di+6],40h
 38028 00006769 26804D0640              	or	byte [es:di+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8)
 38029                                  	;or	word [es:di+SF_ENTRY.sf_flags],sf_close_nodate
 38030                                  							; ask close not to
 38031                                  							;   bother about date
 38032                                  							;   and time
 38033 0000676E E88CAB                  	call	LCritSFT
 38034                                  ok_ret:
 38035                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38036                                  	; 17/12/2022
 38037 00006771 E9BD9E                  	jmp	SYS_RET_OK
 38038                                  	;jmp	short LSeekOk
 38039                                  
 38040                                  inval_func:
 38041                                  	;mov	byte [ss:EXTERR_LOCUS],1
 38042 00006774 36C606[2303]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 38043                                  						;SS Overr
 38044                                  	;mov	al,1
 38045 0000677A B001                    	mov	al,error_invalid_function ; give bad return
 38046                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38047                                  ft_error:
 38048                                  	;;jmp	SYS_RET_ERR
 38049                                  	;jmp	short LSeekError3
 38050                                  	; 17/12/2022
 38051 0000677C EBAF                    	jmp	short LSeekError
 38052                                  
 38053                                  ; 21/05/2019 - Retro DOS v4.0
 38054                                  ; DOSCODE:A95Bh (MSDOS 6.21, MSDOS.SYS)
 38055                                  
 38056                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38057                                  ; DOSCODE:A8FBh (MSDOS 5.0 MSDOS.SYS)
 38058                                  
 38059                                  ;BREAK <$DUP - duplicate a jfn>
 38060                                  ;----------------------------------------------------------------------------
 38061                                  ;
 38062                                  ;   Assembler usage:
 38063                                  ;	    MOV     BX, fh
 38064                                  ;	    MOV     AH, Dup
 38065                                  ;	    INT     int_command
 38066                                  ;	  AX has the returned handle
 38067                                  ;   Errors:
 38068                                  ;	    AX = dup_invalid_handle
 38069                                  ;	       = dup_too_many_open_files
 38070                                  ;
 38071                                  ;----------------------------------------------------------------------------
 38072                                  
 38073                                  _$DUP:
 38074 0000677E 89D8                    	MOV	AX,BX			; save away old handle in AX
 38075 00006780 E882FD                  	call	JFNFree 		; free handle? into ES:DI, new in BX
 38076                                  DupErrorCheck:
 38077 00006783 72A8                    	JC	short DupErr		; nope, bye
 38078 00006785 06                      	push	es
 38079 00006786 57                      	push	di			; save away SFT
 38080 00006787 5E                      	pop	si			; into convenient place DS:SI
 38081 00006788 1F                      	pop	ds
 38082 00006789 93                      	XCHG	AX,BX			; get back old handle
 38083 0000678A E81D00                  	call	CheckOwner		; get sft in ES:DI
 38084 0000678D 729E                    	JC	short DupErr		; errors go home
 38085 0000678F E8F2C1                  	call	DOS_Dup_Direct
 38086 00006792 E813FD                  	call	pJFNFromHandle		; get pointer
 38087 00006795 268A1D                  	MOV	BL,[ES:DI]		; get SFT number
 38088 00006798 881C                    	MOV	[SI],BL			; stuff in new SFT
 38089                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38090                                  	;jmp	SYS_RET_OK		; and go home
 38091 0000679A EBD5                    	jmp	short ok_ret
 38092                                  
 38093                                  	; 17/12/2022
 38094                                  ;DupErr:
 38095                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38096                                  	;;jmp	SYS_RET_ERR
 38097                                  	;jmp	short ft_error
 38098                                  
 38099                                  ;BREAK <$DUP2 - force a dup on a particular jfn>
 38100                                  ;----------------------------------------------------------------------------
 38101                                  ;
 38102                                  ;   Assembler usage:
 38103                                  ;	    MOV     BX, fh
 38104                                  ;	    MOV     CX, newfh
 38105                                  ;	    MOV     AH, Dup2
 38106                                  ;	    INT     int_command
 38107                                  ;   Error returns:
 38108                                  ;	    AX = error_invalid_handle
 38109                                  ;
 38110                                  ;----------------------------------------------------------------------------
 38111                                  
 38112                                  _$DUP2:
 38113 0000679C 53                      	push	bx
 38114 0000679D 51                      	push	cx			; save source
 38115 0000679E 89CB                    	MOV	BX,CX			; get one to close
 38116 000067A0 E8BCFD                  	call	_$CLOSE			; close destination handle
 38117 000067A3 5B                      	pop	bx
 38118 000067A4 58                      	pop	ax			; old in AX, new in BX
 38119 000067A5 E800FD                  	call	pJFNFromHandle		; get pointer
 38120 000067A8 EBD9                    	JMP	short DupErrorCheck	; check error and do dup
 38121                                  
 38122                                  ;Break	<CheckOwner - verify ownership of handles from server>
 38123                                  ;----------------------------------------------------------------------------
 38124                                  ;   CheckOwner - Due to the ability of the server to close file handles for a
 38125                                  ;   process without the process knowing it (delete/rename of open files, for
 38126                                  ;   example), it is possible for the redirector to issue a call to a handle
 38127                                  ;   that it soes not rightfully own. We check here to make sure that the
 38128                                  ;   issuing process is the owner of the SFT. At the same time, we do a
 38129                                  ;   SFFromHandle to really make sure that the SFT is good.
 38130                                  ;
 38131                                  ;	ENTRY	BX has the handle
 38132                                  ;		User_ID is the current user
 38133                                  ;	EXIT	Carry Clear => ES:DI points to SFT
 38134                                  ;		Carry Set => AX has error code
 38135                                  ;	USES	none
 38136                                  ;----------------------------------------------------------------------------
 38137                                  
 38138                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38139                                  	; 21/05/2019 - Retro DOS v4.0
 38140                                  CheckOwner:
 38141                                  	; 13/07/2018 - Retro DOS v3.0
 38142                                  
 38143 000067AA E818FD                  	call	SFFromHandle
 38144 000067AD 721B                    	jc	short co_ret_label	; retc
 38145                                  
 38146 000067AF 50                      	push	ax
 38147                                  
 38148                                  	; MSDOS 6.0
 38149                                  
 38150                                  ;SR; WIN386 patch - Do not check for USER_ID for using handles since these 
 38151                                  ;SR; are shared across multiple VMs in win386.
 38152                                  
 38153 000067B0 36F606[3010]01          	test	byte [ss:IsWin386],1 ; 02/06/2019
 38154 000067B6 7404                    	jz	short no_win386		;win386 is not present
 38155 000067B8 31C0                    	xor	ax,ax			;set the zero flag
 38156 000067BA EB08                    	jmp	short _skip_win386	
 38157                                  
 38158                                  no_win386:
 38159 000067BC 36A1[3E03]              	mov	ax,[SS:USER_ID]		;smr;SS Override
 38160                                  	;cmp	ax,[es:di+47]
 38161 000067C0 263B452F                	cmp	ax,[es:di+SF_ENTRY.sf_UID]
 38162                                  
 38163                                  _skip_win386:
 38164 000067C4 58                      	pop	ax
 38165                                  	
 38166                                  	; 17/12/2022
 38167 000067C5 7403                    	jz	short co_ret_label
 38168                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38169                                  	;jnz	short CheckOwner_err
 38170                                  	;retn
 38171                                  	
 38172                                  CheckOwner_err:
 38173                                  	;mov	al,6
 38174 000067C7 B006                    	mov	al,error_invalid_handle
 38175 000067C9 F9                      	stc
 38176                                  
 38177                                  co_ret_label:
 38178 000067CA C3                      	retn
 38179                                  
 38180                                  ;============================================================================
 38181                                  ; MACRO.ASM, MSDOS 6.0, 1991
 38182                                  ;============================================================================
 38183                                  ; Retro	DOS v3.0 - 11/07/2018
 38184                                  ; 21/05/2019 - Retro DOS v4.0
 38185                                  
 38186                                  ;	TITLE	MACRO - Pathname and macro related internal routines
 38187                                  ;	NAME	MACRO
 38188                                  
 38189                                  ;	Microsoft Confidential
 38190                                  ;	Copyright (C) Microsoft Corporation 1991
 38191                                  ;	All Rights Reserved.
 38192                                  
 38193                                  ;**	MACRO.ASM
 38194                                  ;
 38195                                  ;	$AssignOper
 38196                                  ;	FIND_DPB
 38197                                  ;	InitCDS
 38198                                  ;	$UserOper
 38199                                  ;	GetVisDrv
 38200                                  ;	GetThisDrv
 38201                                  ;	GetCDSFromDrv
 38202                                  ;
 38203                                  ;   Revision history:
 38204                                  ;
 38205                                  ;	Created: MZ 4 April 1983
 38206                                  ;		 MZ 18 April 1983   Make TransFCB handle extended FCBs
 38207                                  ;		 AR 2 June 1983     Define/Delete macro for NET redir.
 38208                                  ;		 MZ 3 Nov 83	    Fix InitCDS to reset length to 2
 38209                                  ;		 MZ 4 Nov 83	    Fix NetAssign to use STRLEN only
 38210                                  ;		 MZ 18 Nov 83	    Rewrite string processing for subtree
 38211                                  ;				    aliasing.
 38212                                  ;
 38213                                  ;   MSDOS performs several types of name translation. First, we maintain for
 38214                                  ;   each valid drive letter the text of the current directory on that drive.
 38215                                  ;   For invalid drive letters, there is no current directory so we pretend to
 38216                                  ;   be at the root. A current directory is either the raw local directory
 38217                                  ;   (consisting of drive:\path) or a local network directory (consisting of
 38218                                  ;   \\machine\path. There is a limit on the point to which a .. is allowed.
 38219                                  ;
 38220                                  ;   Given a path, MSDOS will transform this into a real from-the-root path
 38221                                  ;   without . or .. entries. Any component that is > 8.3 is truncated to
 38222                                  ;   this and all * are expanded into ?'s.
 38223                                  ;
 38224                                  ;   The second part of name translation involves subtree aliasing. A list of
 38225                                  ;   subtree pairs is maintained by the external utility SUBST. The results of
 38226                                  ;   the previous 'canonicalization' are then examined to see if any of the
 38227                                  ;   subtree pairs is a prefix of the user path. If so, then this prefix is
 38228                                  ;   replaced with the other subtree in the pair.
 38229                                  ;
 38230                                  ;   A third part involves mapping this "real" path into a "physical" path.  A
 38231                                  ;   list of drive/subtree pairs are maintained by the external utility JOIN.
 38232                                  ;   The output of the previous translation is examined to see if any of the
 38233                                  ;   subtrees in this list are a prefix of the string. If so, then the prefix
 38234                                  ;   is replaced by the appropriate drive letter. In this manner, we can
 38235                                  ;   'mount' one device under another.
 38236                                  ;
 38237                                  ;   The final form of name translation involves the mapping of a user's
 38238                                  ;   logical drive number into the internal physical drive. This is
 38239                                  ;   accomplished by converting the drive number into letter:CON, performing
 38240                                  ;   the above translation and then converting the character back into a drive
 38241                                  ;   number.
 38242                                  ;
 38243                                  ;   There are two main entry points: TransPath and TransFCB. TransPath will
 38244                                  ;   take a path and form the real text of the pathname with all . and ..
 38245                                  ;   removed. TransFCB will translate an FCB into a path and then invoke
 38246                                  ;   TransPath.
 38247                                  ;
 38248                                  ;	A000	version 4.00  Jan. 1988
 38249                                  
 38250                                  ;Installed = TRUE
 38251                                  
 38252                                  ;	I_need	ThisCDS,DWORD		; pointer to CDS used
 38253                                  ;	I_need	CDSAddr,DWORD		; pointer to CDS table
 38254                                  ;	I_need	CDSCount,BYTE		; number of CDS entries
 38255                                  ;	I_need	CurDrv,BYTE		; current macro assignment (old
 38256                                  ;					; current drive)
 38257                                  ;	I_need	NUMIO,BYTE		; Number of physical drives
 38258                                  ;	I_need	fSharing,BYTE		; TRUE => no redirection allowed
 38259                                  ;	I_need	DummyCDS,80h		; buffer for dummy cds
 38260                                  ;	I_need	DIFFNAM,BYTE		; flag for MyName being set
 38261                                  ;	I_need	MYNAME,16		; machine name
 38262                                  ;	I_need	MYNUM,WORD		; machine number
 38263                                  ;	I_need	DPBHEAD,DWORD		; beginning of DPB chain
 38264                                  ;	I_need	EXTERR_LOCUS,BYTE	; Extended Error Locus
 38265                                  ;	I_need	DrvErr,BYTE		; drive error
 38266                                  
 38267                                  ;BREAK <$AssignOper -- Set up a Macro>
 38268                                  ;----------------------------------------------------------------------------
 38269                                  ; Inputs:
 38270                                  ;	AL = 00 get assign mode 		    (ReturnMode)
 38271                                  ;	AL = 01 set assign mode 		    (SetMode)
 38272                                  ;	AL = 02 get attach list entry		    (GetAsgList)
 38273                                  ;	AL = 03 Define Macro (attch start)
 38274                                  ;	    BL = Macro type
 38275                                  ;	       = 0 alias
 38276                                  ;	       = 1 file/device
 38277                                  ;	       = 2 drive
 38278                                  ;	       = 3 Char device -> network
 38279                                  ;	       = 4 File device -> network
 38280                                  ;	    DS:SI -> ASCIZ source name
 38281                                  ;	    ES:DI -> ASCIZ destination name
 38282                                  ;	AL = 04 Cancel Macro
 38283                                  ;	    DS:SI -> ASCIZ source name
 38284                                  ;	AL = 05 Modified get attach list entry
 38285                                  ;	AL = 06 Get ifsfunc item
 38286                                  ;	AL = 07 set in_use of a drive's CDS
 38287                                  ;	     DL = drive number, 0=default  0=A,,
 38288                                  ;	AL = 08 reset in_use of a drive's CDS
 38289                                  ;	     DL = drive number, 0=A, 1=B,,,
 38290                                  ; Function:
 38291                                  ;	Do macro stuff
 38292                                  ; Returns:
 38293                                  ;	Std Xenix style error return
 38294                                  ;----------------------------------------------------------------------------
 38295                                  
 38296                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38297                                  	; 21/05/2019 - Retro DOS v4.0
 38298                                  _$AssignOper:
 38299                                  	; MSDOS 6.0
 38300 000067CB 3C07                    	CMP	AL,7			      ; set in_use ?		;AN000;
 38301 000067CD 7525                    	JNZ	short chk08		      ; no			;AN000;
 38302                                  srinuse:								;AN000;
 38303 000067CF 50                      	PUSH	AX			      ; save al 		;AN000;
 38304 000067D0 88D0                    	MOV	AL,DL			      ; AL= drive id		;AN000;
 38305 000067D2 E85401                  	CALL	GetCDSFromDrv		      ; ds:si -> cds		;AN000;
 38306 000067D5 58                      	POP	AX			      ; 			;AN000;
 38307 000067D6 7216                    	JC	short baddrv		      ; bad drive		;AN000;
 38308                                  	;cmp	word [si+45h],0
 38309 000067D8 837C4500                	CMP	WORD [SI+curdir.devptr],0     ; dpb ptr =0 ?		;AN000;
 38310 000067DC 7410                    	JZ	short baddrv		      ;     no			;AN000;
 38311 000067DE 3C07                    	CMP	AL,7			      ; set ?			;AN000;
 38312 000067E0 7506                    	JNZ	short resetdrv		      ; no			;AN000;
 38313                                  	;or	word [si+43h],4000h
 38314                                  	; 17/12/2022
 38315                                  	;or	byte [si+44h],40h
 38316 000067E2 804C4440                	or	byte [SI+curdir.flags+1],(curdir_inuse>>8)
 38317                                  	;OR	word [SI+curdir.flags],curdir_inuse ; set in_use	;AN000;
 38318 000067E6 EB19                    	JMP	SHORT okdone		      ; 			;AN000;
 38319                                  resetdrv:
 38320                                  	;and	word [si+43h],0BFFFh									;AN000;
 38321                                  	; 18/12/2022
 38322 000067E8 806444BF                	and	byte [SI+curdir.flags+1],0BFh ; (~curdir_inuse)>>8
 38323                                  	;AND	word [SI+curdir.flags],~curdir_inuse ; reset in_use	;AN000;
 38324 000067EC EB13                    	JMP	SHORT okdone		      ; 			;AN000;
 38325                                  
 38326                                  	; 17/12/2022
 38327                                  baddrv: 								;AN000;
 38328 000067EE B80F00                  	MOV	AX,error_invalid_drive	      ; error			;AN000;
 38329                                  
 38330                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38331                                  	;JMP	SHORT ASS_ERR		      ; 			;AN000;
 38332                                  	; 17/12/2022
 38333                                  	; 21/05/2019
 38334                                  ASS_ERR:
 38335 000067F1 E9469E                  	jmp	SYS_RET_ERR
 38336                                  
 38337                                  chk08:									;AN000;
 38338 000067F4 3C08                    	CMP	AL,8			      ; reset inuse ?		;AN000;
 38339 000067F6 74D7                    	JZ	short srinuse 		      ; yes			;AN000;
 38340                                  
 38341                                    ;IF	NOT INSTALLED
 38342                                  	;transfer NET_ASSOPER
 38343                                    ;ELSE
 38344                                  	; MSDOS 3.3 (& MSDOS 6.0)
 38345 000067F8 50                      	PUSH	AX
 38346                                  	;mov	ax,111Eh
 38347                                  	;MOV	AX,(MultNET SHL 8) OR 30
 38348 000067F9 B81E11                  	mov	ax,(MultNET*256)+30
 38349 000067FC CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
 38350                                  			; SS = DOS CS
 38351                                  			; STACK: WORD function to execute
 38352                                  			; Return: CF set on error, AX = error code
 38353                                  			; STACK unchanged
 38354 000067FE 5B                      	POP	BX			; Don't zap error code in AX
 38355 000067FF 72F0                    	JC	short ASS_ERR
 38356                                  okdone:
 38357 00006801 E92D9E                  	jmp	SYS_RET_OK
 38358                                  
 38359                                  	; 17/12/2022
 38360                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38361                                  ;ASS_ERR:
 38362                                  	;jmp	SYS_RET_ERR
 38363                                  
 38364                                    ;ENDIF
 38365                                  
 38366                                  ;Break <FIND_DPB - Find a DPB from a drive number>
 38367                                  ;----------------------------------------------------------------------------
 38368                                  ;**	FIND_DPB - Find a DPB from a Drive #
 38369                                  ;
 38370                                  ;	ENTRY	AL has drive number A = 0
 38371                                  ;	EXIT	'C' set
 38372                                  ;		    No DPB for this drive number
 38373                                  ;		'C' clear
 38374                                  ;		    DS:SI points to DPB for drive
 38375                                  ;	USES	SI, DS, Flags
 38376                                  ;----------------------------------------------------------------------------
 38377                                  
 38378                                  	; 21/05/2019 - Retro DOS v4.0
 38379                                  FIND_DPB:
 38380 00006804 36C536[2600]            	LDS	SI,[SS:DPBHEAD]		;smr;SS Override
 38381                                  fdpb5:	
 38382 00006809 83FEFF                  	CMP	SI,-1
 38383 0000680C 7409                    	JZ	short fdpb10
 38384 0000680E 3A04                    	cmp	al,[si]
 38385                                  	;CMP	AL,[SI+DPB.DRIVE]
 38386 00006810 7406                    	jz	short ret_label15	; Carry clear (retz)
 38387                                  	;;lds	si,[si+18h] ; MSDOS 3.3
 38388                                  	;lds	si,[si+19h] ; MSDOS 6.0
 38389 00006812 C57419                  	LDS	SI,[SI+DPB.NEXT_DPB]
 38390 00006815 EBF2                    	JMP	short fdpb5
 38391                                  fdpb10:	
 38392 00006817 F9                      	STC
 38393                                  ret_label15:
 38394 00006818 C3                      	retn
 38395                                  
 38396                                  ;	Break <InitCDS - set up an empty CDS>
 38397                                  ;----------------------------------------------------------------------------
 38398                                  ;**	InitCDS - Setup an Empty CDS
 38399                                  ;
 38400                                  ;	ENTRY	ThisCDS points to CDS
 38401                                  ;		AL has uppercase drive letter
 38402                                  ;	EXIT	ThisCDS is now empty
 38403                                  ;		(ES:DI) = CDS
 38404                                  ;		'C' set if no DPB associated with drive
 38405                                  ;	USES	AH,ES,DI, Flags
 38406                                  ;----------------------------------------------------------------------------
 38407                                  
 38408                                  ; 21/05/2019 - Retro DOS v4.0
 38409                                  ; DOSCODE:A9FDh (MSDOS 6.21, MSDOS.SYS)
 38410                                  
 38411                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38412                                  ; DOSCODE:A99Dh (MSDOS 5.0, MSDOS.SYS)
 38413                                  
 38414                                  InitCDS:
 38415                                  	; 19/08/2018
 38416                                  	; 05/08/2018 - Retro DOS v3.0
 38417                                  	; MSDOS 6.0
 38418 00006819 50                      	push	ax			; save (AL) for caller
 38419 0000681A 36C43E[A205]            	LES	DI,[SS:THISCDS]		; (es:di) = CDS address
 38420                                  	;mov	word [es:di+67],0
 38421 0000681F 26C745430000            	MOV	word [ES:DI+curdir.flags],0 ; "free" CDS
 38422 00006825 2C40                    	SUB	AL,"A"-1                ; A = 1
 38423 00006827 363806[4600]            	CMP	[SS:NUMIO],AL		;smr;SS Override
 38424 0000682C 7236                    	JC	short icdsx		; Drive does not map a physical drive
 38425 0000682E 48                      	dec	ax			; (AL) = 0 if A, 1 if B, etc.
 38426 0000682F 50                      	PUSH	AX			; save drive number for later
 38427 00006830 0441                    	add	al,"A"
 38428 00006832 B43A                    	MOV	AH,':'
 38429 00006834 268905                  	mov	[ES:DI],ax
 38430                                  	;MOV	[ES:DI+curdir.text],AX 	; set "x:"
 38431                                  	;mov	ax,"\"
 38432                                  	;mov	[es:di+2],ax
 38433                                  	;MOV	word [ES:DI+curdir.text+2],"\"	; NUL terminate
 38434 00006837 26C745025C00            	mov	word [ES:DI+curdir.text+2],005Ch ; 19/08/2018
 38435                                  	;or	word [es:di+67],4000h
 38436                                  	;or	byte [es:di+68],40h
 38437 0000683D 26804D4440              	OR	byte [ES:DI+curdir.flags+1],(curdir_inuse>>8)
 38438 00006842 29C0                    	sub	ax,ax
 38439                                  	;MOV	[es:di+73],ax ; 0
 38440 00006844 26894549                	MOV	[ES:DI+curdir.ID],ax
 38441                                  	;mov	[es:di+75],ax ; 0
 38442 00006848 2689454B                	MOV	[ES:DI+curdir.ID+2],ax
 38443 0000684C B002                    	mov	al,2
 38444                                  	;mov	[es:di+79],aX ; 2
 38445 0000684E 2689454F                	MOV	[ES:DI+curdir.end],ax
 38446 00006852 58                      	POP	AX			; (al) = drive number
 38447 00006853 1E                      	push	ds
 38448 00006854 56                      	push	si
 38449 00006855 E8ACFF                  	call	FIND_DPB
 38450 00006858 7208                    	JC	short icds5		; OOOOPPPPPSSSS!!!!
 38451                                  	;mov	[es:di+69],si
 38452 0000685A 26897545                	MOV	[ES:DI+curdir.devptr],SI
 38453                                  	;mov	[es:di+71],ds
 38454 0000685E 268C5D47                	MOV	[ES:DI+curdir.devptr+2],DS
 38455                                  icds5:	
 38456 00006862 5E                      	pop	si
 38457 00006863 1F                      	pop	ds
 38458                                  icdsx:	
 38459 00006864 58                      	pop	ax
 38460                                  RET45:
 38461 00006865 C3                      	retn
 38462                                  
 38463                                  ;Break <$UserOper - get/set current user ID (for net)>
 38464                                  ;----------------------------------------------------------------------------
 38465                                  ;   $UserOper - retrieve or initiate a user id string.	MSDOS will only
 38466                                  ;	maintain this string and do no verifications.
 38467                                  ;
 38468                                  ;   Inputs:	AL has function type (0-get 1-set 2-printer-set 3-printer-get
 38469                                  ;				      4-printer-set-flags,5-printer-get-flags)
 38470                                  ;		DS:DX is user string pointer (calls 1,2)
 38471                                  ;		ES:DI is user buffer (call 3)
 38472                                  ;		BX is assign index (calls 2,3,4,5)
 38473                                  ;		CX is user number (call 1)
 38474                                  ;		DX is flag word (call 4)
 38475                                  ;   Outputs:	If AL = 0 then the current user string is written to DS:DX
 38476                                  ;			and user CX is set to the user number
 38477                                  ;		If AL = 3 then CX bytes have been put at input ES:DI
 38478                                  ;		If AL = 5 then DX is flag word
 38479                                  ;----------------------------------------------------------------------------
 38480                                  
 38481                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38482                                  	; 21/05/2019 - Retro DOS v4.0
 38483                                  _$UserOper:
 38484                                  	; 05/08/2018 - Retro DOS v3.0
 38485                                  	; MSDOS 6.0 (& MSDOS 3.3)
 38486                                  	;PUSH	AX
 38487                                  	;SUB	AL,1			; quick dispatch on 0,1
 38488                                  	;POP	AX
 38489                                  	; 01/07/2024
 38490 00006866 3C01                    	cmp	al,1
 38491 00006868 7211                    	JB	short UserGet 		; return to user the string
 38492 0000686A 742E                    	JZ	short UserSet 		; set the current user
 38493 0000686C 3C05                    	CMP	AL,5			; test for 2,3,4 or 5
 38494 0000686E 763D                    	JBE	short UserPrint		; yep
 38495                                  	;mov	byte [ss:EXTERR_LOCUS],1
 38496 00006870 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ;smr;SS Override 
 38497                                  					; Extended Error Locus
 38498                                  	;error	error_invalid_function	; not 0,1,2,3
 38499                                  	;mov	al,1
 38500 00006876 B001                    	MOV	AL,error_invalid_function
 38501                                  useroper_error:
 38502                                  	; 17/12/2022
 38503                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38504 00006878 E9BF9D                  	JMP	SYS_RET_ERR
 38505                                  	;jmp	short ASS_ERR
 38506                                  
 38507                                  UserGet:
 38508                                  ; Transfer MYNAME to DS:DX
 38509                                  ; Set Return CX to MYNUM
 38510 0000687B 1E                      	PUSH	DS			; switch registers
 38511 0000687C 07                      	POP	ES
 38512 0000687D 89D7                    	MOV	DI,DX			; destination
 38513 0000687F 368B0E[0E00]            	MOV	CX,[SS:MYNUM]		; Get number	;smr;SS Override
 38514 00006884 E8FA9B                  	call	Get_User_Stack
 38515                                  	;mov	[si+4],cx
 38516 00006887 894C04                  	MOV	[SI+user_env.user_CX],CX ; Set number return
 38517 0000688A 16                      	push	ss			; point to DOSDATA
 38518 0000688B 1F                      	pop	ds
 38519 0000688C BE[0503]                	MOV	SI,MYNAME		; point source to user string
 38520                                  UserMove:
 38521 0000688F B90F00                  	MOV	CX,15
 38522 00006892 F3A4                    	REP	MOVSB			; blam.
 38523 00006894 31C0                    	XOR	AX,AX			; 16th byte is 0
 38524 00006896 AA                      	STOSB
 38525                                  UserBye:
 38526 00006897 E9979D                  	jmp	SYS_RET_OK		; no errors here
 38527                                  
 38528                                  UserSet:
 38529                                  ; Transfer DS:DX to MYNAME
 38530                                  ; CX to MYNUM
 38531 0000689A 36890E[0E00]            	MOV	[SS:MYNUM],CX				;smr;SS Override
 38532 0000689F 89D6                    	MOV	SI,DX			; user space has source
 38533 000068A1 16                      	push	ss
 38534 000068A2 07                      	pop	es
 38535 000068A3 BF[0503]                	MOV	DI,MYNAME		; point dest to user string
 38536 000068A6 36FE06[0403]            	INC	byte [SS:DIFFNAM]	; signal change ;smr;SS Override
 38537 000068AB EBE2                    	JMP	short UserMove
 38538                                  
 38539                                  UserPrint:
 38540                                  
 38541                                    ;IF NOT Installed
 38542                                    ;	transfer PRINTER_GETSET_STRING
 38543                                    ;ELSE
 38544 000068AD 50                      	PUSH	AX
 38545                                  	;mov	ax,111Fh
 38546                                  	;MOV	AX,(MultNET SHL 8) OR 31
 38547 000068AE B81F11                  	mov	ax,(MultNET<<8)|31
 38548 000068B1 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
 38549                                  			; STACK: WORD function
 38550                                  			; Return: CF set on error, AX = error code
 38551                                  			; STACK unchanged
 38552 000068B3 5A                      	POP	DX			; Clean stack
 38553                                  	;JNC	short OKPA
 38554 000068B4 73E1                    	jnc	short UserBye ; 21/05/2019
 38555                                  	; 17/12/2022
 38556 000068B6 EBC0                    	jmp	short useroper_error
 38557                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38558                                  	;jnb     short OKPA
 38559                                  	;jmp     short useroper_error
 38560                                  
 38561                                  	; 17/12/2022
 38562                                  ;OKPA:
 38563                                  ;	jmp	short UserBye
 38564                                  
 38565                                    ;ENDIF
 38566                                  
 38567                                  
 38568                                  ;Break	<GetVisDrv - return visible drive>
 38569                                  ;----------------------------------------------------------------------------
 38570                                  ;   GetVisDrv - correctly map non-spliced inuse drives
 38571                                  ;
 38572                                  ;   Inputs:	AL has drive identifier (0=default)
 38573                                  ;   Outputs:	Carry Set - invalid drive/macro
 38574                                  ;		Carry Clear - AL has physical drive (0=A)
 38575                                  ;		    ThisCDS points to CDS
 38576                                  ;   Registers modified: AL
 38577                                  ;----------------------------------------------------------------------------
 38578                                  
 38579                                  	; 21/05/2019 - Retro DOS v4.0
 38580                                  	; DOSCODE:AA9Fh (MSDOS 6.21, MSDOS.SYS)
 38581                                  
 38582                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38583                                  	; DOSCODE:AA3Fh (MSDOS 5.0, MSDOS.SYS)	
 38584                                  GetVisDrv:
 38585                                  	; 05/08/2018 - Retro DOS v3.0
 38586                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6839h
 38587 000068B8 E81900                  	CALL	GETTHISDRV		; get inuse drive
 38588 000068BB 72A8                    	jc	short RET45
 38589 000068BD 1E                      	push	ds
 38590 000068BE 56                      	push	si
 38591 000068BF 36C536[A205]            	LDS	SI,[SS:THISCDS]		;smr;SS Override
 38592                                  	;test	word [si+67],2000h
 38593                                  	; 17/12/2022
 38594                                  	;test	byte [si+68],20h
 38595 000068C4 F6444420                	test	byte [SI+curdir.flags+1],(curdir_splice>>8)
 38596                                  	;TEST	word [SI+curdir.flags],curdir_splice
 38597 000068C8 5E                      	pop	si
 38598 000068C9 1F                      	pop	ds
 38599 000068CA 7499                    	jz	short RET45		; if not spliced, return OK
 38600                                  	; MSDOS 6.0
 38601                                  	;mov	byte [ss:DrvErr],0Fh
 38602 000068CC 36C606[1006]0F          	MOV	byte [SS:DrvErr],error_invalid_drive ;IFS. ;AN000;smr;SS Override
 38603 000068D2 F9                      	STC				; signal error
 38604 000068D3 C3                      	retn
 38605                                  
 38606                                  ;Break <Getthisdrv - map a drive designator (0=def, 1=A...)>
 38607                                  ;----------------------------------------------------------------------------
 38608                                  ;   GetThisDrv - look through a set of macros and return the current drive and
 38609                                  ;	macro pointer
 38610                                  ;
 38611                                  ;   Inputs:	AL has drive identifier (1=A, 0=default)
 38612                                  ;   Outputs:
 38613                                  ;		Carry Set - invalid drive/macro
 38614                                  ;		Carry Clear - AL has physical drive (0=A)
 38615                                  ;		   ThisCDS points to macro
 38616                                  ;   Registers modified: AL
 38617                                  ;----------------------------------------------------------------------------
 38618                                  
 38619                                  	; 21/05/2019 - Retro DOS v4.0
 38620                                  	; DOSCODE:AABCh (MSDOS 6.21, MSDOS.SYS)
 38621                                  
 38622                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38623                                  	; DOSCODE:AA5Ch (MSDOS 5.0, MSDOS.SYS)
 38624                                  GETTHISDRV:
 38625                                  	; 05/08/2018
 38626                                  	; 12/07/2018 - Retro DOS v3.0
 38627                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6850h
 38628                                  	; MSDOS 3.3 (& MSDOS 6.0)
 38629 000068D4 08C0                    	OR	AL,AL			; are we using default drive?
 38630 000068D6 7505                    	JNZ	SHORT GTD10		; no, go get the CDS pointers
 38631 000068D8 36A0[3603]              	MOV	AL,[SS:CURDRV]		; get the current drive
 38632                                  	;INC	ax			; Counteract next instruction
 38633                                  	; 04/09/2018
 38634                                  	;inc	al
 38635                                  	; 07/12/2022
 38636 000068DC 40                      	inc	ax
 38637                                  GTD10:	
 38638                                  	;DEC	AX
 38639                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38640 000068DD 48                      	dec	ax			; 0 = A
 38641                                  	;dec	al
 38642 000068DE 1E                      	PUSH	DS			; save world
 38643 000068DF 56                      	PUSH	SI
 38644                                  	;mov	byte [ss:EXTERR_LOCUS],2
 38645 000068E0 36C606[2303]02          	MOV	BYTE [SS:EXTERR_LOCUS],errLOC_Disk		;smr;SS Override
 38646                                  
 38647                                  	;TEST	BYTE [SS:FSHARING],-1	; Logical or Physical?	;smr;SS Override
 38648                                  	;JZ	SHORT GTD20		; Logical
 38649                                  	; 13/03/2024 (PCDOS71. IBMDOS.COM)
 38650                                  	;;;
 38651 000068E6 36803E[7205]00          	cmp	byte [ss:FSHARING],0
 38652 000068EC 7420                    	jz	short GTD20
 38653                                  	;;;
 38654                                  
 38655 000068EE 50                      	PUSH	AX
 38656 000068EF 06                      	PUSH	ES
 38657 000068F0 57                      	PUSH	DI
 38658 000068F1 36C706[A205][F304]      	MOV	WORD [SS:THISCDS],DUMMYCDS ;smr;SS Override
 38659                                  	;mov	[SS:THISCDS+2],CS ; MSDOS 3.3
 38660 000068F8 368C16[A405]            	MOV	[SS:THISCDS+2],SS ; MSDOS 6.0 ;ThisCDS = &DummyCDS;smr;
 38661 000068FD 0441                    	ADD	AL,'A'
 38662 000068FF E817FF                  	CALL	InitCDS			; InitCDS(c);
 38663                                  	;test	word [es:di+67],4000h
 38664                                  	; 17/12/2022
 38665                                  	;test	byte [es:di+68],40h
 38666 00006902 26F6454440              	test	byte [ES:DI+curdir.flags+1],(curdir_inuse>>8)
 38667                                  	;TEST	WORD [ES:DI+curdir.flags],curdir_inuse	; Clears carry
 38668 00006907 5F                      	POP	DI
 38669 00006908 07                      	POP	ES
 38670 00006909 58                      	POP	AX
 38671 0000690A 740D                    	JZ	SHORT GTD30		; Not a physical drive.
 38672 0000690C EB18                    	JMP	SHORT GTDX		; carry clear
 38673                                  GTD20:
 38674 0000690E E81800                  	CALL	GetCDSFromDrv
 38675 00006911 7206                    	JC	SHORT GTD30	; Unassigned CDS -> return error already set
 38676                                  	;test	word [si+43h],4000h
 38677                                  	; 17/12/2022
 38678                                  	;test	byte [si+44h],40h
 38679 00006913 F6444440                	test	byte [SI+curdir.flags+1],(curdir_inuse>>8)
 38680                                  	;TEST	WORD [SI+curdir.flags],curdir_inuse ; Clears Carry
 38681 00006917 750D                    	JNZ	SHORT GTDX		; carry clear
 38682                                  GTD30:	
 38683                                  	; 21/05/2019
 38684                                  	; MSDOS 6.0
 38685 00006919 B00F                    	MOV	AL,error_invalid_drive	; invalid FAT drive
 38686 0000691B 36A2[1006]              	MOV	BYTE [ss:DrvErr],AL	; save this for IOCTL
 38687                                  	; MSDOS 3.3 (.& MSDOS 6.0)
 38688 0000691F 36C606[2303]01          	MOV	BYTE [ss:EXTERR_LOCUS],errLOC_Unk
 38689 00006925 F9                      	STC
 38690                                  GTDX:	
 38691 00006926 5E                      	POP	SI			; restore world
 38692 00006927 1F                      	POP	DS
 38693 00006928 C3                      	RETN
 38694                                  
 38695                                  ;Break <GetCDSFromDrv - convert a drive number to a CDS pointer>
 38696                                  ;----------------------------------------------------------------------------
 38697                                  ;   GetCDSFromDrv - given a physical drive number, convert it to a CDS
 38698                                  ;	pointer, returning an error if the drive number is greater than the
 38699                                  ;	number of CDS's
 38700                                  ;
 38701                                  ;   Inputs:	AL is physical unit # A=0...
 38702                                  ;   Outputs:	Carry Set if Bad Drive
 38703                                  ;		Carry Clear
 38704                                  ;		    DS:SI -> CDS
 38705                                  ;		    [THISCDS] = DS:SI
 38706                                  ;   Registers modified: DS,SI
 38707                                  ;----------------------------------------------------------------------------
 38708                                  
 38709                                  	; 21/05/2019 - Retro DOS v4.0
 38710                                  GetCDSFromDrv:
 38711 00006929 363A06[4700]            	CMP	AL,[SS:CDSCOUNT]	; is this a valid designator;smr;SS Override
 38712                                  	;JB	SHORT GetCDS	; cf=1	; yes, go get the macro
 38713                                  	;STC				; signal error
 38714                                  	;RETN				; bye
 38715                                  	; 23/09/2023
 38716 0000692E F5                      	cmc	; cf=1 <-> cf=0
 38717 0000692F 7217                    	jc	short GetCDS_retn
 38718                                  GetCDS:
 38719                                  	; 23/09/2023
 38720                                  	;PUSH	BX
 38721 00006931 50                      	PUSH	AX
 38722 00006932 36C536[3C00]            	LDS	SI,[SS:CDSADDR]		; get pointer to table	;smr;SS Override
 38723                                  	;mov	bl,81 ; MSDOS 3.3
 38724                                  	;mov	bl,88 ; MSDOS 6.0 
 38725                                  	; 23/09/2023
 38726                                  	;MOV	BL,curdir.size		; size in convenient spot
 38727                                  	;MUL	BL			; get net offset
 38728 00006937 B458                    	mov	ah,curdir.size
 38729 00006939 F6E4                    	mul	ah
 38730 0000693B 01C6                    	ADD	SI,AX ; *		; convert to true pointer
 38731 0000693D 368936[A205]            	MOV	[SS:THISCDS],SI		; store convenient offset;smr;SS Override
 38732 00006942 368C1E[A405]            	MOV	[SS:THISCDS+2],DS	; store convenient segment;smr;SS Override
 38733 00006947 58                      	POP	AX
 38734                                  	; 23/09/2023
 38735                                  	;POP	BX
 38736                                  	; (cf must be 0 here) ; *
 38737                                  	;CLC				; no error
 38738                                  GetCDS_retn:
 38739 00006948 C3                      	RETN				; bye!
 38740                                  
 38741                                  ;============================================================================
 38742                                  ; MACRO2.ASM, MSDOS 6.0, 1991
 38743                                  ;============================================================================
 38744                                  ; Retro	DOS v3.0 - 12/07/2018
 38745                                  ; 22/05/2019 - Retro DOS v4.0
 38746                                  
 38747                                  ;BREAK <TransFCB - convert an FCB into a path, doing substitution>
 38748                                  ;----------------------------------------------------------------------------
 38749                                  ;   TransFCB - Copy an FCB from DS:DX into a reserved area doing all of the
 38750                                  ;       gritty substitution.
 38751                                  ;
 38752                                  ;   Inputs:     DS:DX - pointer to FCB
 38753                                  ;               ES:DI - point to destination
 38754                                  ;   Outputs:    Carry Set - invalid path in final map
 38755                                  ;               Carry Clear - FCB has been mapped into ES:DI
 38756                                  ;                   Sattrib is set from possibly extended FCB
 38757                                  ;                   ExtFCB set if extended FCB found
 38758                                  ;   Registers modified: most
 38759                                  ;----------------------------------------------------------------------------
 38760                                  
 38761                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38762                                  TransFCB:
 38763                                  	; 22/05/2019 - Retro DOS v4.0
 38764                                  	; 12/07/2018 - Retro DOS v3.0
 38765                                  	;LocalVar FCBTmp,16
 38766                                  	;ENTER
 38767 00006949 55                      	push	bp
 38768 0000694A 89E5                    	mov	bp,sp
 38769                                  	;sub	sp,15	; MSDOS 3.3
 38770 0000694C 83EC10                  	sub	sp,16	; MSDOS 6.0
 38771 0000694F 16                      	push	ss
 38772 00006950 07                      	pop	es
 38773 00006951 06                      	push	es
 38774 00006952 57                      	push	di
 38775                                  	;lea	di,[bp-15] ; MSDOS 3.3
 38776                                  	;LEA	DI,FCBTmp 
 38777 00006953 8D7EF0                  	lea	di,[bp-16]		; point to FCB temp area
 38778 00006956 36C606[6C05]00          	mov	byte [SS:EXTFCB],0	; no extended FCB found ;smr;SS Override
 38779 0000695C 36C606[6D05]00          	mov	byte [SS:SATTRIB],0	; default search attributes;smr;SS Override
 38780 00006962 E8B8B2                  	call	GetExtended             ; get FCB, extended or not
 38781                                  	; 06/12/2022
 38782 00006965 740D                    	jz	short GetDrive		; not an extended FCB, get drive
 38783 00006967 8A44FF                  	mov	AL,[SI-1]               ; get attributes
 38784 0000696A 36A2[6D05]              	mov	[SS:SATTRIB],AL		; store search attributes;smr;SS Override
 38785 0000696E 36C606[6C05]FF          	mov	byte [SS:EXTFCB],-1	; signal extended FCB  ;smr;SS Override
 38786                                  GetDrive:
 38787 00006974 AC                      	lodsb				; get drive byte
 38788 00006975 E85CFF                  	call	GETTHISDRV
 38789 00006978 722A                    	jc	short BadPack
 38790 0000697A E86F03                  	call	TextFromDrive           ; convert 0-based drive to text
 38791                                  
 38792                                  ; Scan the source to see if there are any illegal chars
 38793                                  
 38794                                  	;mov	bx,CharType		; load lookup table
 38795 0000697D B90B00                  	mov	cx,11
 38796 00006980 56                      	push	si			; back over name, ext
 38797                                  FCBScan:
 38798 00006981 AC                      	lodsb				; get a byte
 38799                                  	
 38800                                  	; 09/08/2018
 38801                                  	;;xlat	byte [es:bx]
 38802                                  	;es	xlat
 38803                                  
 38804                                  	; 22/05/2019 - Retro DOS v4.0	
 38805 00006982 E870E5                  	call	GetCharType		; get flags
 38806                                  
 38807                                  	;test	al,8	
 38808 00006985 A808                    	test	al,FFCB
 38809 00006987 741B                    	jz	short BadPack
 38810                                  NextCh: 
 38811 00006989 E2F6                    	loop	FCBScan
 38812 0000698B 5E                      	pop	si
 38813 0000698C 89FB                    	mov	bx,di
 38814 0000698E E8C7B6                  	call	PackName                ; crunch the path
 38815 00006991 5F                      	pop	di			; get original destination
 38816 00006992 07                      	pop	es
 38817 00006993 16                      	push	ss			; get DS addressability
 38818 00006994 1F                      	pop	ds
 38819                                  	;lea	si,[bp-15] ; MSDOS 3.3
 38820                                  	;LEA	SI,FCBTmp		; point at new pathname
 38821 00006995 8D76F0                  	lea	si,[bp-16]
 38822 00006998 803F00                  	cmp	byte [bx],0
 38823 0000699B 7407                    	jz	short BadPack
 38824 0000699D 55                      	push	bp
 38825 0000699E E80E00                  	call	TransPathSet            ; convert the path
 38826 000069A1 5D                      	pop	bp
 38827 000069A2 7303                    	jnc	short FCBRet		; bye with transPath error code
 38828                                  BadPack:
 38829 000069A4 F9                      	STC
 38830                                  	;mov	al,3
 38831 000069A5 B003                    	MOV     AL,error_path_not_found
 38832                                  FCBRet: 
 38833                                  	;LEAVE
 38834 000069A7 89EC                    	mov	sp,bp
 38835 000069A9 5D                      	pop	bp
 38836                                  TransPath_retn:
 38837 000069AA C3                      	retn
 38838                                  
 38839                                  ; 12/07/2018 - Retro DOS v3.0
 38840                                  
 38841                                  ;BREAK <TransPath - copy a path, do string sub and put in current dir>
 38842                                  ;----------------------------------------------------------------------------
 38843                                  ;
 38844                                  ;   TransPath - copy a path from DS:SI to ES:DI, performing component string
 38845                                  ;       substitution, insertion of current directory and fixing . and ..
 38846                                  ;       entries. Perform splicing. Allow input string to match splice
 38847                                  ;       exactly.
 38848                                  ;
 38849                                  ;   TransPathSet - Same as above except No splicing is performed if input path
 38850                                  ;       matches splice.
 38851                                  ;
 38852                                  ;   TransPathNoSet - No splicing/local using is performed at all.
 38853                                  ;
 38854                                  ;   The following anomalous behaviour is required:
 38855                                  ;
 38856                                  ;       Drive letters on devices are ignored. (set up DummyCDS)
 38857                                  ;       Paths on devices are ignored. (truncate to 0-length)
 38858                                  ;       Raw net I/O sets ThisCDS => NULL.
 38859                                  ;       fSharing => dummyCDS and no subst/splice. Only canonicalize.
 38860                                  ;
 38861                                  ;   Other behaviour:
 38862                                  ;
 38863                                  ;       ThisCDS set up.
 38864                                  ;       FatRead done on local CDS.
 38865                                  ;       ValidateCDS done on local CDS.
 38866                                  ;
 38867                                  ;   Brief flowchart:
 38868                                  ;
 38869                                  ;       if fSharing then
 38870                                  ;           set up DummyCDS (ThisCDS)
 38871                                  ;           canonicalize (sets cMeta)
 38872                                  ;           splice
 38873                                  ;           fatRead
 38874                                  ;           return
 38875                                  ;       if \\ or d:\\ lead then
 38876                                  ;           set up null CDS (ThisCDS)
 38877                                  ;           canonicalize (sets cMeta)
 38878                                  ;           return
 38879                                  ;       if device then
 38880                                  ;           set up dummyCDS (ThisCDS)
 38881                                  ;           canonicalize (sets cMeta)
 38882                                  ;           return
 38883                                  ;       if file then
 38884                                  ;           getCDS (sets (ThisCDS) from name)
 38885                                  ;           validateCDS (may reset current dir)
 38886                                  ;           Copy current dir
 38887                                  ;           canonicalize (set cMeta)
 38888                                  ;           splice
 38889                                  ;           generate correct CDS (ThisCDS)
 38890                                  ;           if local then
 38891                                  ;               fatread
 38892                                  ;           return
 38893                                  ;
 38894                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 38895                                  ;               DI - point to buffer in DOSDATA
 38896                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 38897                                  ;                   syntax, etc. or user FAILed to I 24.
 38898                                  ;               WFP_Start - points to beginning of buffer
 38899                                  ;               Curr_Dir_End - points to end of current dir in path
 38900                                  ;               DS - DOSDATA
 38901                                  ;   Registers modified: most
 38902                                  ;
 38903                                  ;----------------------------------------------------------------------------
 38904                                  
 38905                                  ; 22/05/2019
 38906                                  ; 13/05/2019 - Retro DOS v4.0
 38907                                  ; DOSCODE:AB99h (MSDOS 6.21, MSDOS.SYS)
 38908                                  
 38909                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38910                                  ; DOSCODE:AB39h (MSDOS 5.0, MSDOS.SYS)
 38911                                  
 38912                                  TransPath:
 38913 000069AB 30C0                    	XOR     AL,AL
 38914 000069AD EB02                    	JMP     SHORT SetSplice
 38915                                  TransPathSet:
 38916 000069AF B0FF                    	MOV     AL,-1
 38917                                  SetSplice:
 38918 000069B1 36A2[4C03]              	MOV	[SS:NoSetDir],AL	; NoSetDir = !fExact;	;smr;SS Override
 38919 000069B5 B0FF                    	MOV     AL,-1
 38920                                  TransPathNoSet:
 38921 000069B7 36A2[7105]              	MOV	[SS:FSPLICE],AL		; fSplice = TRUE;	;smr;SS Override
 38922 000069BB 36C606[7A05]FF          	MOV	byte [ss:CMETA],-1      			;smr;SS Override
 38923 000069C1 36893E[B205]            	MOV     [SS:WFP_START],DI 				;smr;SS Override
 38924 000069C6 36C706[B605]FFFF        	MOV	word [SS:CURR_DIR_END],-1 ; crack from start	;smr;SS Override
 38925 000069CD 16                      	push	ss
 38926 000069CE 07                      	pop	es
 38927                                  	;lea	bp,[di+134]
 38928 000069CF 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; end of buffer
 38929                                  ;
 38930                                  ; if this is through the server dos call, fsharing is set. We set up a
 38931                                  ; dummy cds and let the operation go.
 38932                                  ;
 38933                                  	;TEST	byte [SS:FSHARING],-1	; if no sharing		;smr;SS Override
 38934                                  	;JZ	short CheckUNC		; skip to UNC check
 38935                                  	; 13/03/2024 (PCDOS 7.1 IBMDOS.COM)
 38936                                  	;;;
 38937 000069D3 36803E[7205]00          	cmp	byte [ss:FSHARING],0
 38938 000069D9 7435                    	jz	short CheckUNC
 38939                                  	;;;
 38940                                  ;
 38941                                  ; ES:DI point to buffer
 38942                                  ;
 38943 000069DB E8F802                  	CALL	DriveFromText           ; get drive and advance DS:SI
 38944 000069DE E8F3FE                  	call	GETTHISDRV              ; Set ThisCDS and convert to 0-based
 38945 000069E1 722A                    	jc	short NoPath
 38946 000069E3 E80603                  	CALL	TextFromDrive		; drop in new
 38947 000069E6 8D5D01                  	LEA	BX,[DI+1]               ; backup limit
 38948 000069E9 E83401                  	CALL	Canonicalize            ; copy and canonicalize
 38949 000069EC 72BC                    	jc	short TransPath_retn	; errors
 38950                                  ;
 38951                                  ; Perform splices for net guys.
 38952                                  ;
 38953 000069EE 16                      	push	ss
 38954 000069EF 1F                      	pop	ds
 38955 000069F0 8B36[B205]              	MOV     SI,[WFP_START] 		; point to name
 38956 000069F4 F606[7105]FF            	TEST	byte [FSPLICE],-1
 38957 000069F9 7403                    	JZ	short NoServerSplice
 38958 000069FB E82D02                  	CALL    Splice
 38959                                  NoServerSplice:
 38960 000069FE 16                      	push	ss
 38961 000069FF 1F                      	pop	ds                      ; for FATREAD
 38962 00006A00 C43E[A205]              	LES     DI,[THISCDS]		; for fatread
 38963 00006A04 E8DBA8                  	call	ECritDisk
 38964 00006A07 E838EB                  	call	FATREAD_CDS
 38965 00006A0A E8F0A8                  	call	LCritDisk
 38966                                  NoPath:
 38967                                  	;mov	al,3
 38968 00006A0D B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 38969 00006A0F C3                      	retn				; any errors are in Carry flag
 38970                                  
 38971                                  ; Let the network decide if the name is for a spooled device. It will map
 38972                                  ; the name if so.
 38973                                  
 38974                                  CheckUNC:
 38975 00006A10 36C706[A205]FFFF        	MOV     WORD [SS:THISCDS],-1	; NULL thisCDS		;smr;SS Override
 38976                                  	;CallInstall NetSpoolCheck,MultNET,35
 38977 00006A17 B82311                  	mov	ax,1123h
 38978 00006A1A CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
 38979                                  			; DS:SI -> ASCIZ filename to canonicalize
 38980                                  			; ES:DI -> 128-byte buffer for qualified name
 38981                                  			; Return: CF set if not resolved
 38982 00006A1C 7329                    	JNC	short UNCDone
 38983                                  
 38984                                  ; At this point the name is either a UNC-style name (prefixed with two leading
 38985                                  ; \\s) or is a local file/device. Remember that if a net-spooled device was
 38986                                  ; input, then the name has been changed to the remote spooler by the above net
 38987                                  ; call. Also, there may be a drive in front of the \\.
 38988                                  
 38989                                  NO_CHECK:
 38990 00006A1E E8B502                  	CALL    DriveFromText		; eat drive letter
 38991 00006A21 50                      	PUSH    AX                      ; save it
 38992 00006A22 8B04                    	MOV     AX,[SI]			; get first two bytes of path
 38993 00006A24 E8EBE4                  	call    PATHCHRCMP              ; convert to normal form
 38994 00006A27 86E0                    	XCHG    AH,AL                   ; swap for second byte
 38995 00006A29 E8E6E4                  	call    PATHCHRCMP              ; convert to normal form
 38996 00006A2C 751F                    	JNZ	short CheckDevice	; not a path char
 38997 00006A2E 38C4                    	CMP     AH,AL                   ; are they same?
 38998 00006A30 751B                    	JNZ	short CheckDevice	; nope
 38999                                  
 39000                                  ; We have a UNC request. We must copy the string up to the beginning of the
 39001                                  ; local machine root path
 39002                                  
 39003 00006A32 58                      	POP     AX
 39004 00006A33 A5                      	MOVSW                           ; get the lead \\.
 39005                                  UNCCpy:
 39006 00006A34 AC                      	LODSB                           ; get a byte
 39007 00006A35 E885E4                   	call	UCase                   ;AN000;; convert the char
 39008 00006A38 08C0                    	OR      AL,AL
 39009 00006A3A 740E                    	JZ	short UNCTerm		; end of string. All done.
 39010 00006A3C E8D3E4                  	call    PATHCHRCMP              ; is it a path char?
 39011 00006A3F 89FB                    	MOV     BX,DI                   ; backup position
 39012 00006A41 AA                      	STOSB
 39013 00006A42 75F0                    	JNZ	short UNCCpy		; no, go copy
 39014 00006A44 E8D900                  	CALL    Canonicalize            ; wham (and set cMeta)
 39015                                  UNCDone:
 39016 00006A47 16                      	push	ss
 39017 00006A48 1F                      	pop	ds
 39018 00006A49 C3                       	retn				; return error code
 39019                                  UNCTerm:
 39020 00006A4A AA                      	STOSB                           ;AN000;
 39021 00006A4B EBFA                    	JMP	short UNCDone		;AN000;
 39022                                  
 39023                                  CheckDevice:
 39024                                  
 39025                                  ; Check DS:SI for device. First eat any path stuff
 39026                                  
 39027 00006A4D 58                      	POP     AX                      ; retrieve drive info
 39028 00006A4E 803C00                  	CMP     BYTE [SI],0		; check for null file
 39029 00006A51 7504                    	JNZ	short CheckPath
 39030                                  	;mov	al,2 
 39031 00006A53 B002                    	MOV     AL,error_file_not_found ; bad file error
 39032 00006A55 F9                      	STC                             ; signal error on null input
 39033 00006A56 C3                      	RETN				; bye!
 39034                                  CheckPath:
 39035 00006A57 50                      	push	ax
 39036 00006A58 55                      	push	bp			; save drive number
 39037                                  
 39038                                  ; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39039                                  %if 0
 39040                                  	; MSDOS 6.0
 39041                                  ;;;BUGBUG BUG 10-26-1992 scottq
 39042                                  ;;;This is a hack for the CDROM extensions (2.1) who scan looking
 39043                                  ;;;for the following POP BP == 5Dh (restore <bp,ax>).
 39044                                  ;;;The problem is that a direct call to CheckThisDevice can (and did)
 39045                                  ;;;end up having a 5D in the opcode's displacement field. The
 39046                                  ;;;scanning code would choke on this thinking it was a POP BP instruction.
 39047                                  ;;;
 39048                                  ;;;What we do here is do a call to a function that is less than 5Dh
 39049                                  ;;;bytes away (and assert its not exactly 5D away) that jmps (transfers)
 39050                                  ;;;to the correct function. This cannot accidently insert a 5Dh.
 39051                                  ;;;
 39052                                  ;;;More info:
 39053                                  ;;;  This particular scan is begun at the UNCdone label for 32 bytes
 39054                                  ;;;looking for pop BP, so you cannot put a 5D between here and there.
 39055                                  ;;;
 39056                                  	call	no5Dshere
 39057                                  start5Dhack:
 39058                                  ;following is replaced with 5Dhack code--Invoke CheckThisDevice
 39059                                  backfrom5Dhack:
 39060                                  
 39061                                  %endif
 39062                                  
 39063                                  ; 13/03/2024
 39064                                  ; MSDOS 6.22 MSDOS.SYS - DOSCODE:AC47h
 39065                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:BECBh
 39066                                  ; (Windows ME IO.SYS - BIOSCODE:A6C2h)
 39067                                  %if 0
 39068                                  	call	no5Dshere
 39069                                  %else
 39070                                  ; 13/03/2024 - Retro DOS v4.2
 39071                                  
 39072                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39073                                  	; Note: 'call no5Dshere' is not required for MSDOS 5.0 MSDOS.SYS
 39074 00006A59 E864D7                  	call    CheckThisDevice	; E8h,6Fh,0D6h
 39075                                  %endif
 39076 00006A5C 5D                      	pop	bp
 39077 00006A5D 58                      	pop	ax			; get drive letter back
 39078 00006A5E 731C                    	JNC	short DoFile		; yes we have a file.
 39079                                  
 39080                                  ; We have a device. AX has drive letter. At this point we may fake a CDS ala
 39081                                  ; sharing DOS call. We know by getting here that we are NOT in a sharing DOS
 39082                                  ; call.
 39083                                  
 39084 00006A60 36C606[7205]FF          	MOV	byte [SS:FSHARING],-1	; simulate sharing dos call;smr;SS Override
 39085 00006A66 E86BFE                  	call	GETTHISDRV              ; set ThisCDS and init DUMMYCDS
 39086 00006A69 36C606[7205]00          	MOV     byte [SS:FSHARING],0	;                       ;smr;SS Override
 39087                                  
 39088                                  ; Now that we have noted that we have a device, we put it into a form that
 39089                                  ; getpath can understand. Normally getpath requires d:\ to begin the input
 39090                                  ; string. We relax this to state that if the d:\ is present then the path
 39091                                  ; may be a file. If D:/ (note the forward slash) is present then we have
 39092                                  ; a device.
 39093                                  
 39094 00006A6F E87A02                  	CALL    TextFromDrive
 39095 00006A72 B02F                    	MOV     AL,'/'                  ; path sep.
 39096 00006A74 AA                      	STOSB
 39097 00006A75 E839A7                  	call	StrCpy			; move remainder of string
 39098                                  
 39099 00006A78 F8                      	CLC                             ; everything OK.
 39100 00006A79 16                      	push	ss
 39101 00006A7A 1F                      	pop	ds                      ; remainder of OK stuff
 39102                                  DoFile_retn:
 39103 00006A7B C3                      	retn
 39104                                  
 39105                                  ; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39106                                  %if 0
 39107                                  
 39108                                  no5Dshere:
 39109                                  	; 10/08/2018
 39110                                  	jmp	CheckThisDevice		; snoop for device
 39111                                  %endif
 39112                                  
 39113                                  ;.erre (no5Dshere - start5Dhack - 5D)
 39114                                  
 39115                                  ; We have a file. Get the raw CDS.
 39116                                  
 39117                                  DoFile:
 39118                                  	; MSDOS 3.3 (& MSDOS 6.0)
 39119                                  
 39120 00006A7C E839FE                  	call	GetVisDrv               ; get proper CDS
 39121                                  	;mov	al,3 
 39122 00006A7F B003                    	MOV     AL,error_path_not_found ; Set up for possible bad file error
 39123 00006A81 72F8                    	jc	short DoFile_retn  ; CARRY set -> bogus drive/spliced
 39124                                  
 39125                                  ; ThisCDS has correct CDS. DS:SI advanced to point to beginning of path/file.
 39126                                  ; Make sure that CDS has valid directory; ValidateCDS requires a temp buffer
 39127                                  ; Use the one that we are going to use (ES:DI).
 39128                                  
 39129                                  	;SAVE    <DS,SI,ES,DI>		; save all string pointers.
 39130 00006A83 1E                      	push	ds
 39131 00006A84 56                      	push	si
 39132 00006A85 06                      	push	es
 39133 00006A86 57                      	push	di
 39134 00006A87 E87FD6                  	call	ValidateCDS             ; poke CDS and make everything OK
 39135                                  	;RESTORE <DI,ES,SI,DS>		; get back pointers
 39136 00006A8A 5F                      	pop	di
 39137 00006A8B 07                      	pop	es
 39138 00006A8C 5E                      	pop	si
 39139 00006A8D 1F                      	pop	ds
 39140                                  	;mov	al,3
 39141 00006A8E B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 39142                                  	;retc				; someone failed an operation
 39143 00006A90 72E9                    	jc	short DoFile_retn
 39144                                  
 39145                                  ; ThisCDS points to correct CDS. It contains the correct text of the
 39146                                  ; current directory. Copy it in.
 39147                                  
 39148 00006A92 1E                      	push	ds
 39149 00006A93 56                      	push	si
 39150 00006A94 36C536[A205]            	LDS     SI,[SS:THISCDS]		; point to CDS	;smr;SS Override
 39151 00006A99 89FB                    	MOV     BX,DI                   ; point to destination
 39152                                  	;add	bx,[si+79] ; MSDOS 6.0
 39153 00006A9B 035C4F                  	ADD     BX,[SI+curdir.end]	; point to backup limit
 39154                                  	;lea	bp,[di+134]
 39155 00006A9E 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; regenerate end of buffer
 39156                                  					;AN000;
 39157 00006AA2 E81BA7                  	call	FStrCpy                 ; copy string. ES:DI point to end
 39158 00006AA5 4F                      	DEC     DI                      ; point to NUL byte
 39159                                  
 39160                                  ; Make sure that there is a path char at end.
 39161                                  
 39162 00006AA6 B05C                    	MOV     AL,'\'
 39163 00006AA8 263845FF                	CMP     [ES:DI-1],AL
 39164 00006AAC 7401                    	JZ	short GetOrig
 39165 00006AAE AA                      	STOSB
 39166                                  
 39167                                  ; Now get original string.
 39168                                  
 39169                                  GetOrig:
 39170 00006AAF 4F                      	DEC     DI                      ; point to path char
 39171 00006AB0 5E                      	pop	si
 39172 00006AB1 1F                      	pop	ds
 39173                                  
 39174                                  ; BX points to the end of the root part of the CDS (at where a path char
 39175                                  ; should be). Now, we decide whether we use this root or extend it with the
 39176                                  ; current directory. See if the input string begins with a leading 
 39178 00006AB2 E8CE00                  	CALL    PathSep                 ; is DS:SI a path sep?
 39179 00006AB5 7511                    	JNZ	short PathAssure	; no, DI is correct. Assure a path char
 39180 00006AB7 08C0                    	OR      AL,AL                   ; end of string?
 39181 00006AB9 7410                    	JZ	short DoCanon		; yes, skip.
 39182                                  ;
 39183                                  ; The string does begin with a \. Reset the beginning of the canonicalization
 39184                                  ; to this root. Make sure that there is a path char there and advance the
 39185                                  ; source string over all leading \'s.
 39186                                  ;
 39187 00006ABB 89DF                    	MOV     DI,BX                   ; back up to root point.
 39188                                  SkipPath:
 39189 00006ABD AC                      	LODSB
 39190 00006ABE E851E4                  	call    PATHCHRCMP
 39191 00006AC1 74FA                    	JZ	short SkipPath
 39192 00006AC3 4E                      	DEC     SI
 39193 00006AC4 08C0                    	OR      AL,AL
 39194 00006AC6 7403                    	JZ	short DoCanon
 39195                                  
 39196                                  ; DS:SI start at some file name. ES:DI points at some path char. Drop one in
 39197                                  ; for yucks.
 39198                                  
 39199                                  PathAssure:
 39200 00006AC8 B05C                    	MOV     AL,'\'	; 5Ch
 39201 00006ACA AA                      	STOSB
 39202                                  
 39203                                  ; ES:DI point to the correct spot for canonicalization to begin.
 39204                                  ; BP is the max extent to advance DI
 39205                                  ; BX is the backup limit for ..
 39206                                  
 39207                                  DoCanon:
 39208 00006ACB E85200                  	CALL    Canonicalize            ; wham.
 39209                                  	;retc				; badly formatted path.
 39210 00006ACE 72AB                    	jc	short DoFile_retn
 39211                                  
 39212                                  ; The string has been moved to ES:DI. Reset world to DOS context, pointers
 39213                                  ; to wfp_start and do string substitution. BP is still the max position in
 39214                                  ; buffer.
 39215                                  
 39216 00006AD0 16                      	push	ss
 39217 00006AD1 1F                      	pop	ds
 39218 00006AD2 8B3E[B205]              	MOV     DI,[WFP_START]		; DS:SI point to string
 39219 00006AD6 C536[A205]              	LDS     SI,[THISCDS]		; point to CDS
 39220 00006ADA E81702                  	CALL    PathPref                ; is there a prefix?
 39221 00006ADD 7514                    	JNZ	short DoSplice		; no, do splice
 39222                                  
 39223                                  ; We have a match. Check to see if we ended in a path char.
 39224                                  
 39225 00006ADF 8A44FF                  	MOV     AL,[SI-1]		; last char to match
 39226 00006AE2 E82DE4                  	call    PATHCHRCMP              ; did we end on a path char? (root)
 39227 00006AE5 740C                    	JZ	short DoSplice		; yes, no current dir here.
 39228                                  Pathline:                               ; 2/13/KK
 39229 00006AE7 26803D00                	CMP     BYTE [ES:DI],0		; end at NUL?
 39230 00006AEB 7406                    	JZ	short DoSplice
 39231 00006AED 47                      	INC     DI                      ; point to after current path char
 39232 00006AEE 36893E[B605]            	MOV     [SS:CURR_DIR_END],DI	; point to correct spot ;smr;SS Override
 39233                                  
 39234                                  ; Splice the result.
 39235                                  
 39236                                  DoSplice:
 39237 00006AF3 16                      	push	ss
 39238 00006AF4 1F                      	pop	ds			; back to DOSDATA
 39239 00006AF5 8B36[B205]              	MOV     SI,[WFP_START]		; point to beginning of string
 39240 00006AF9 31C9                    	XOR     CX,CX
 39241 00006AFB F606[7105]FF            	TEST	byte [FSPLICE],-1
 39242 00006B00 7403                    	JZ	short SkipSplice
 39243 00006B02 E82601                  	CALL    Splice                  ; replaces in place.
 39244                                  SkipSplice:
 39245                                  
 39246                                  ; The final thing is to assure ourselves that a FATREAD is done on the local
 39247                                  ; device.
 39248                                  
 39249 00006B05 16                      	push	ss
 39250 00006B06 1F                      	pop	ds
 39251 00006B07 C43E[A205]              	LES     DI,[THISCDS]		; point to correct drive
 39252                                  	;test	word [es:di+67],8000h
 39253                                  	; 17/12/2022
 39254                                  	;test	byte [es:di+68],80h
 39255 00006B0B 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8 ; 04/12/2022
 39256                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet ; 8000h
 39257 00006B10 750D                    	JNZ	short Done		; net, no fatread necessary (retnz)
 39258 00006B12 E30B                    	JCXZ    Done
 39259 00006B14 E8CBA7                  	call	ECritDisk
 39260 00006B17 E828EA                  	call	FATREAD_CDS
 39261 00006B1A E8E0A7                  	call	LCritDisk
 39262                                  	;mov	al, 3
 39263 00006B1D B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 39264                                  Done:   
 39265 00006B1F C3                      	retn                         ; any errors in carry flag.
 39266                                  
 39267                                  ; 13/07/2018
 39268                                  
 39269                                  ;BREAK <Canonicalize - copy a path and remove . and .. entries>
 39270                                  ;----------------------------------------------------------------------------
 39271                                  ;   Canonicalize - copy path removing . and .. entries.
 39272                                  ;
 39273                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 39274                                  ;               ES:DI - point to buffer
 39275                                  ;               BX - backup limit (offset from ES) points to slash
 39276                                  ;               BP - end of buffer
 39277                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 39278                                  ;                   syntax, etc.
 39279                                  ;               Carry Clear -
 39280                                  ;                   DS:DI - advanced to end of string
 39281                                  ;                   ES:DI - advanced to end of canonicalized form after nul
 39282                                  ;   Registers modified: AX CX DX (in addition to those above)
 39283                                  ;----------------------------------------------------------------------------
 39284                                  
 39285                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39286                                  
 39287                                  Canonicalize:
 39288                                  
 39289                                  ; We copy all leading path separators.
 39290                                  
 39291 00006B20 AC                      	LODSB                           ;   while (PathChr (*s))
 39292 00006B21 E8EEE3                  	call    PATHCHRCMP
 39293 00006B24 7507                    	JNZ	short CanonDec
 39294 00006B26 39EF                    	CMP     DI,BP                   ;       if (d > dlim)
 39295 00006B28 7319                    	JAE	short CanonBad		;           goto error;
 39296 00006B2A AA                      	STOSB
 39297 00006B2B EBF3                    	JMP	short Canonicalize	;           *d++ = *s++;
 39298                                  CanonDec:
 39299 00006B2D 4E                      	DEC     SI
 39300                                  
 39301                                  ; Main canonicalization loop. We come here with DS:SI pointing to a textual
 39302                                  ; component (no leading path separators) and ES:DI being the destination
 39303                                  ; buffer.
 39304                                  
 39305                                  CanonLoop:
 39306                                  
 39307                                  ; If we are at the end of the source string, then we need to check to see that
 39308                                  ; a potential drive specifier is correctly terminated with a path sep char.
 39309                                  ; Otherwise, do nothing
 39310                                  
 39311 00006B2E 31C0                    	XOR     AX,AX
 39312 00006B30 3804                    	CMP     [SI],AL                 ;       if (*s == 0) {
 39313 00006B32 751A                    	JNZ	short DoComponent
 39314 00006B34 26807DFF3A              	CMP     BYTE [ES:DI-1],':'	;           if (d[-1] == ':')
 39315 00006B39 7505                    	JNZ	short DoTerminate
 39316 00006B3B B05C                    	MOV     AL,'\'                  ;               *d++ = '\';
 39317 00006B3D AA                      	STOSB
 39318 00006B3E 88E0                    	MOV     AL,AH
 39319                                  DoTerminate:
 39320 00006B40 AA                      	STOSB                           ;           *d++ = 0;
 39321 00006B41 F8                      	CLC                             ;           return (0);
 39322 00006B42 C3                      	retn
 39323                                  
 39324                                  CanonBad:
 39325 00006B43 E8C701                  	CALL	ScanPathChar            ; check for path chars in rest of string
 39326                                  	;mov	al,3
 39327 00006B46 B003                    	MOV     AL,error_path_not_found ; Set up for bad path error
 39328 00006B48 7402                    	JZ	short PathEnc		; path character encountered in string
 39329                                  	;mov	al,2
 39330 00006B4A B002                    	MOV     AL,error_file_not_found ; Set bad file error
 39331                                  PathEnc:
 39332 00006B4C F9                      	STC
 39333                                  CanonBad_retn:
 39334 00006B4D C3                      	retn
 39335                                  
 39336                                  ; We have a textual component that we must copy. We uppercase it and truncate
 39337                                  ; it to 8.3
 39338                                  
 39339                                  DoComponent:                            ;           }
 39340 00006B4E E84C00                  	CALL    CopyComponent		;       if (!CopyComponent (s, d))
 39341 00006B51 72FA                    	jc	short CanonBad_retn	;           return (-1);
 39342                                  
 39343                                  ; We special case the . and .. cases. These will be backed up.
 39344                                  
 39345                                  	;CMP	WORD PTR ES:[DI],'.' + (0 SHL 8)
 39346 00006B53 26833D2E                	CMP	WORD [ES:DI],002Eh
 39347 00006B57 7408                    	JZ	short Skip1
 39348                                  	;CMP	WORD PTR ES:[DI],'..'
 39349 00006B59 26813D2E2E              	CMP     WORD [ES:DI],2E2Eh
 39350 00006B5E 7508                    	JNZ	short CanonNormal
 39351 00006B60 4F                      	DEC     DI                      ;           d--;
 39352                                  Skip1:  
 39353 00006B61 E82800                  	CALL    SkipBack                ;           SkipBack ();
 39354                                  	;;mov	al,3
 39355                                  	; 07/07/2024 (*)
 39356                                  	;MOV    AL,error_path_not_found ; Set up for possible bad path error
 39357 00006B64 72E7                    	jc	short CanonBad_retn ; AL=3 (*)
 39358 00006B66 EB02                    	JMP     short CanonPath         ;           }
 39359                                  
 39360                                  ; We have a normal path. Advance destination pointer over it.
 39361                                  
 39362                                  CanonNormal:                            ;       else
 39363 00006B68 01CF                    	ADD     DI,CX                   ;           d += ct;
 39364                                  
 39365                                  ; We have successfully copied a component. We are now pointing at a path
 39366                                  ; sep char or are pointing at a nul or are pointing at something else.
 39367                                  ; If we point at something else, then we have an error.
 39368                                  
 39369                                  CanonPath:
 39370 00006B6A E81600                  	CALL    PathSep
 39371 00006B6D 75D4                    	JNZ	short CanonBad		; something else...
 39372                                  
 39373                                  ; Copy the first path char we see.
 39374                                  
 39375 00006B6F AC                      	LODSB                           ; get the char
 39376 00006B70 E89FE3                  	call    PATHCHRCMP              ; is it path char?
 39377 00006B73 75B8                    	JNZ	short CanonDec		; no, go test for nul
 39378 00006B75 39EF                    	CMP     DI,BP                   ; beyond buffer end?
 39379 00006B77 73CA                    	JAE	short CanonBad		; yep, error.
 39380 00006B79 AA                      	STOSB                           ; copy the one byte
 39381                                  
 39382                                  ; Skip all remaining path chars
 39383                                  
 39384                                  CanonPathLoop:
 39385 00006B7A AC                      	LODSB                           ; get next byte
 39386 00006B7B E894E3                  	call    PATHCHRCMP              ; path char again?
 39387 00006B7E 74FA                    	JZ	short CanonPathLoop	; yep, grab another
 39388 00006B80 4E                      	DEC     SI                      ; back up
 39389 00006B81 EBAB                    	JMP	short  CanonLoop	; go copy component
 39390                                  
 39391                                  ;BREAK <PathSep - determine if char is a path separator>
 39392                                  ;----------------------------------------------------------------------------
 39393                                  ;   PathSep - look at DS:SI and see if char is / \ or NUL
 39394                                  ;   Inputs:     DS:SI - point to a char
 39395                                  ;   Outputs:    AL has char from DS:SI (/ => \)
 39396                                  ;               Zero set if AL is / \ or NUL
 39397                                  ;               Zero reset otherwise
 39398                                  ;   Registers modified: AL
 39399                                  ;----------------------------------------------------------------------------
 39400                                  
 39401                                  PathSep:
 39402 00006B83 8A04                    	MOV     AL,[SI]                 ; get the character
 39403                                  PathSepGotCh:				; already have character
 39404 00006B85 08C0                    	OR      AL,AL                   ; test for zero
 39405 00006B87 74C4                    	jz	short CanonBad_retn	; return if equal to zero (NUL)
 39406                                  	;call	PATHCHRCMP              ; check for path character
 39407                                  	;retn				; and return HIS determination
 39408                                  	; 18/12/2022
 39409 00006B89 E986E3                  	jmp	PATHCHRCMP
 39410                                  
 39411                                  ;BREAK <SkipBack - move backwards to a path separator>
 39412                                  ;----------------------------------------------------------------------------
 39413                                  ;   SkipBack - look at ES:DI and backup until it points to a / ;   Inputs:     ES:DI - point to a char
 39415                                  ;               BX has current directory back up limit (point to a / \)
 39416                                  ;   Outputs:    ES:DI backed up to point to a path char
 39417                                  ;               AL has char from output ES:DI (path sep if carry clear)
 39418                                  ;               Carry set if illegal backup
 39419                                  ;               Carry Clear if ok
 39420                                  ;   Registers modified: DI,AL
 39421                                  ;----------------------------------------------------------------------------
 39422                                  
 39423                                  SkipBack:
 39424 00006B8C 39DF                    	CMP     DI,BX                   ;   while (TRUE) {
 39425 00006B8E 720A                    	JB	short SkipBad		;       if (d < dlim)
 39426 00006B90 4F                      	DEC     DI                      ;           goto err;
 39427 00006B91 268A05                  	MOV     AL,[ES:DI]		;       if (pathchr (*--d))
 39428 00006B94 E87BE3                  	call    PATHCHRCMP              ;           break;
 39429 00006B97 75F3                    	JNZ	short SkipBack		;       }
 39430                                  	;CLC				;   return (0);
 39431                                  	; 01/07/2024
 39432                                  	; cf=0
 39433 00006B99 C3                      	retn				;
 39434                                  SkipBad:                                ;err:
 39435                                  	;mov	al,3
 39436 00006B9A B003                    	MOV     AL,error_path_not_found ; bad path error
 39437                                  	;STC				;   return (-1);
 39438                                  	; 01/07/2024
 39439                                  	; cf=1
 39440 00006B9C C3                      	retn
 39441                                  
 39442                                  ;Break <CopyComponent - copy out a file path component>
 39443                                  ;----------------------------------------------------------------------------
 39444                                  ;   CopyComponent - copy a file component from a path string (DS:SI) into ES:DI
 39445                                  ;
 39446                                  ;   Inputs:     DS:SI - source path
 39447                                  ;               ES:DI - destination
 39448                                  ;               ES:BP - end of buffer
 39449                                  ;   Outputs:    Carry Set - too long
 39450                                  ;               Carry Clear - DS:SI moved past component
 39451                                  ;                   CX has length of destination
 39452                                  ;   Registers modified: AX,CX,DX
 39453                                  ;----------------------------------------------------------------------------
 39454                                  
 39455                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39456                                  
 39457                                  CopyComponent:
 39458                                  
 39459                                  %define CopyBP	 [BP]		; word
 39460                                  %define CopyD	 [BP+2]		; dword
 39461                                  %define CopyDoff [BP+2]		; word
 39462                                  %define CopyS	 [BP+6]		; dword
 39463                                  %define CopySoff [BP+6]		; word
 39464                                  %define CopyTemp [BP+10]	; byte
 39465                                  
 39466 00006B9D 83EC0E                  	SUB     SP,14                   ; room for temp buffer
 39467 00006BA0 1E                      	push	ds
 39468 00006BA1 56                      	push	si
 39469 00006BA2 06                      	push	es
 39470 00006BA3 57                      	push	di
 39471 00006BA4 55                      	push	bp
 39472 00006BA5 89E5                    	MOV     BP,SP
 39473 00006BA7 B42E                    	MOV     AH,'.'
 39474 00006BA9 AC                      	LODSB
 39475 00006BAA AA                      	STOSB
 39476 00006BAB 38E0                    	CMP     AL,AH                   ;   if ((*d++=*s++) == '.') {
 39477 00006BAD 7518                    	JNZ	short NormalComp
 39478 00006BAF E8D1FF                  	CALL    PathSep                 ;       if (!pathsep(*s))
 39479 00006BB2 740B                    	JZ	short NulTerm
 39480                                  TryTwoDot:
 39481 00006BB4 AC                      	LODSB                           ;           if ((*d++=*s++) != '.'
 39482 00006BB5 AA                      	STOSB
 39483 00006BB6 38E0                    	CMP     AL,AH
 39484 00006BB8 7557                    	JNZ	short CopyBad
 39485 00006BBA E8C6FF                  	CALL    PathSep
 39486 00006BBD 7552                    	JNZ	short CopyBad		;               || !pathsep (*s))
 39487                                  NulTerm:                                ;               return -1;
 39488 00006BBF 30C0                    	XOR     AL,AL                   ;       *d++ = 0;
 39489 00006BC1 AA                      	STOSB
 39490 00006BC2 897606                  	MOV     CopySoff,SI
 39491 00006BC5 EB47                    	JMP     SHORT _GoodRet		;       }
 39492                                  NormalComp:                             ;   else {
 39493 00006BC7 8B7606                  	MOV     SI,CopySoff ; [bp+6]
 39494 00006BCA E887E2                  	call	NameTrans               ;       s = NameTrans (s, Name1);
 39495 00006BCD 3B7606                  	CMP     SI,CopySoff             ;       if (s == CopySOff)
 39496 00006BD0 743F                    	JZ	short CopyBad		;           return (-1);
 39497 00006BD2 36F606[7205]FF          	TEST	byte [SS:FSHARING],-1	;       if (!fSharing) {;smr;SS Override
 39498 00006BD8 7510                    	JNZ	short DoPack
 39499 00006BDA 80E201                  	AND     DL,1                    ;           cMeta += fMeta;
 39500 00006BDD 360016[7A05]            	ADD	[ss:CMETA],DL		;           if (cMeta > 0);smr;SS Override
 39501 00006BE2 7F2D                    	JG	short CopyBad		;               return (-1);
 39502 00006BE4 7504                    	JNZ	short DoPack		;           else
 39503 00006BE6 08D2                    	OR      DL,DL                   ;           if (cMeta == 0 && fMeta == 0)
 39504 00006BE8 742F                    	JZ	short CopyBadPath	;               return (-1);
 39505                                  DoPack:                                 ;           }
 39506 00006BEA 897606                  	MOV     CopySoff,SI ; [bp+6]
 39507 00006BED 16                      	push	ss
 39508 00006BEE 1F                      	pop	ds
 39509 00006BEF BE[4B05]                	MOV     SI,NAME1
 39510 00006BF2 8D7E0A                  	LEA     DI,CopyTemp ; [bp+10]
 39511 00006BF5 57                      	push	di
 39512 00006BF6 E85FB4                  	call	PackName                ;       PackName (Name1, temp);
 39513 00006BF9 5F                      	pop	di
 39514 00006BFA E8CCA5                  	call	StrLen                  ;       if (strlen(temp)+d > bp)
 39515 00006BFD 49                      	DEC     CX
 39516 00006BFE 034E02                  	ADD     CX,CopyDoff ; [bp+2]
 39517                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39518                                  	;cmp	cx,[bp+0]
 39519                                  	; 15/12/2022
 39520                                  	;cmp	cx,[bp]
 39521 00006C01 3B4E00                  	CMP	CX,CopyBP   ; [bp+0]
 39522 00006C04 730B                    	JAE	short CopyBad		;           return (-1);
 39523 00006C06 89FE                    	MOV     SI,DI                   ;       strcpy (d, temp);
 39524 00006C08 C47E02                  	LES     DI,CopyD    ; [bp+2]	
 39525 00006C0B E8B2A5                  	call	FStrCpy
 39526                                  _GoodRet:				;       }
 39527 00006C0E F8                      	CLC
 39528 00006C0F EB0B                    	JMP     SHORT CopyEnd           ;   return 0;
 39529                                  CopyBad:
 39530 00006C11 F9                      	STC
 39531 00006C12 E8F800                  	CALL    ScanPathChar            ; check for path chars in rest of string
 39532                                  	;mov	al,2
 39533 00006C15 B002                    	MOV     AL,error_file_not_found ; Set up for bad file error
 39534 00006C17 7503                    	JNZ	short CopyEnd
 39535                                  CopyBadPath:
 39536 00006C19 F9                      	STC
 39537                                  	;mov	al,3
 39538 00006C1A B003                    	MOV     AL,error_path_not_found ; Set bad path error
 39539                                  CopyEnd:
 39540 00006C1C 5D                      	pop	bp
 39541 00006C1D 5F                      	pop	di
 39542 00006C1E 07                      	pop	es
 39543 00006C1F 5E                      	pop	si
 39544 00006C20 1F                      	pop	ds
 39545 00006C21 9F                      	LAHF
 39546 00006C22 83C40E                  	ADD     SP,14                   ; reclaim temp buffer
 39547 00006C25 E8A1A5                  	call	StrLen
 39548 00006C28 49                      	DEC     CX
 39549 00006C29 9E                      	SAHF
 39550 00006C2A C3                      	retn
 39551                                  
 39552                                  ; 14/05/2019 - Retro DOS v4.0
 39553                                  ; DOSCODE:AE22h (MSDOS 6.21, MSDOS.SYS)
 39554                                  
 39555                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39556                                  ; DOSCODE:ADBFh (MSDOS 5.0, MSDOS.SYS)
 39557                                  
 39558                                  ;Break <Splice - pseudo mount by string substitution>
 39559                                  ;----------------------------------------------------------------------------
 39560                                  ;   Splice - take a string and substitute a prefix if one exists. Change
 39561                                  ;       ThisCDS to point to physical drive CDS.
 39562                                  ;   Inputs:     DS:SI point to string
 39563                                  ;               NoSetDir = TRUE => exact matches with splice fail
 39564                                  ;   Outputs:    DS:SI points to thisCDS
 39565                                  ;               ES:DI points to DPB
 39566                                  ;               String at DS:SI may be reduced in length by removing prefix
 39567                                  ;               and substituting drive letter.
 39568                                  ;               CX = 0 If no splice done
 39569                                  ;               CX <> 0 otherwise
 39570                                  ;               ThisCDS points to proper CDS if spliced, otherwise it is
 39571                                  ;                   left alone
 39572                                  ;               ThisDPB points to proper DPB
 39573                                  ;   Registers modified: DS:SI, ES:DI, BX,AX,CX
 39574                                  ;----------------------------------------------------------------------------
 39575                                  
 39576                                  Splice:
 39577 00006C2B 36F606[5A00]FF          	TEST	byte [SS:SPLICES],-1	;smr;SS Override
 39578 00006C31 7469                    	JZ	short AllDone
 39579 00006C33 36FF36[A205]            	push	word [SS:THISCDS]
 39580 00006C38 36FF36[A405]            	push	word [SS:THISCDS+2]	; TmpCDS = ThisCDS;smr;SS Override
 39581 00006C3D 1E                      	push	ds
 39582 00006C3E 56                      	push	si
 39583 00006C3F 5F                      	pop	di
 39584 00006C40 07                      	pop	es
 39585 00006C41 31C0                    	XOR     AX,AX                   ;   for (i=1; s = GetCDSFromDrv (i); i++)
 39586                                  SpliceScan:
 39587 00006C43 E8E3FC                  	call	GetCDSFromDrv
 39588 00006C46 724A                    	JC	short SpliceDone
 39589 00006C48 FEC0                    	INC     AL
 39590                                  	; 17/12/2022
 39591                                  	;test	byte [si+68],20h
 39592 00006C4A F6444420                	test	byte [si+curdir.flags+1],curdir_splice>>8 ; 04/12/2022
 39593                                  	;;test	word [si+67],2000h
 39594                                  	;TEST	word [SI+curdir.flags],curdir_splice
 39595 00006C4E 74F3                    	JZ	short SpliceScan 	;       if ( Spliced (i) ) {
 39596 00006C50 57                      	push	di
 39597 00006C51 E8A000                  	CALL    PathPref                ;           if (!PathPref (s, d))
 39598 00006C54 7403                    	JZ	short SpliceFound	;
 39599                                  SpliceSkip:
 39600 00006C56 5F                      	pop	di
 39601 00006C57 EBEA                    	JMP	short SpliceScan	;               continue;
 39602                                  SpliceFound:
 39603 00006C59 26803D00                	CMP     BYTE [ES:DI],0		;           if (*s || NoSetDir) {
 39604 00006C5D 7508                    	JNZ	short SpliceDo
 39605 00006C5F 36F606[4C03]FF          	TEST	byte [ss:NoSetDir],-1			;smr;SS Override
 39606 00006C65 75EF                    	JNZ	short SpliceSkip
 39607                                  SpliceDo:
 39608 00006C67 89FE                    	MOV     SI,DI                   ;               p = src + strlen (p);
 39609 00006C69 06                      	push	es
 39610 00006C6A 1F                      	pop	ds
 39611 00006C6B 5F                      	pop	di
 39612 00006C6C E87F00                  	CALL	TextFromDrive1          ;               src = TextFromDrive1(src,i);
 39613 00006C6F 36A1[B605]              	MOV     AX,[SS:CURR_DIR_END]			;smr;SS Override
 39614 00006C73 09C0                    	OR      AX,AX
 39615 00006C75 7808                    	JS	short NoPoke
 39616 00006C77 01F8                    	ADD     AX,DI                   ;               curdirend += src-p;
 39617 00006C79 29F0                    	SUB     AX,SI
 39618 00006C7B 36A3[B605]              	MOV     [SS:CURR_DIR_END],AX			;smr;SS Override
 39619                                  NoPoke:
 39620 00006C7F 803C00                  	CMP     BYTE [SI],0		;               if (*p)
 39621 00006C82 7503                    	JNZ	short SpliceCopy	;                   *src++ = '\\';
 39622 00006C84 B05C                    	MOV     AL,"\"
 39623 00006C86 AA                      	STOSB
 39624                                  SpliceCopy:                             ;               strcpy (src, p);
 39625 00006C87 E836A5                  	call	FStrCpy
 39626 00006C8A 83C404                  	ADD     SP,4                    ; throw away saved stuff
 39627 00006C8D 80C901                  	OR      CL,1                    ; signal splice done.
 39628 00006C90 EB0C                    	JMP     SHORT DoSet             ;               return;
 39629                                  SpliceDone:                             ;               }
 39630 00006C92 368F06[A405]            	pop	word [SS:THISCDS+2]     ;   ThisCDS = TmpCDS;
 39631 00006C97 368F06[A205]            	pop	word [SS:THISCDS]			;smr;SS Override
 39632                                  AllDone:
 39633 00006C9C 31C9                    	XOR     CX,CX
 39634                                  DoSet:
 39635 00006C9E 36C536[A205]            	LDS     SI,[SS:THISCDS]		;   ThisDPB = ThisCDS->devptr;;smr;SS Override
 39636                                  	;les	di,[si+69]
 39637 00006CA3 C47C45                  	LES     DI,[SI+curdir.devptr]	
 39638 00006CA6 36893E[8A05]            	MOV	[SS:THISDPB],DI				;smr;SS Override
 39639 00006CAB 368C06[8C05]            	MOV	[SS:THISDPB+2],ES			;smr;SS Override
 39640                                  Splice_retn:
 39641 00006CB0 C3                      	retn
 39642                                  
 39643                                  ; 15/05/2019 - Retro DOS v4.0
 39644                                  ; DOSCODE:AEA9h (MSDOS 6.21, MSDOS.SYS)
 39645                                  
 39646                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39647                                  ; DOSCODE:AE46h (MSDOS 5.0, MSDOS.SYS)
 39648                                  
 39649                                  ;Break <$NameTrans - partially process a name>
 39650                                  ;----------------------------------------------------------------------------
 39651                                  ;   $NameTrans - allow users to see what names get mapped to. This call
 39652                                  ;   performs only string substitution and canonicalization, not splicing.  Due
 39653                                  ;   to Transpath playing games with devices, we need to insure that the output
 39654                                  ;   has drive letter and : in it.
 39655                                  ;
 39656                                  ;   Inputs:     DS:SI - source string for translation
 39657                                  ;               ES:DI - pointer to buffer
 39658                                  ;   Outputs:
 39659                                  ;       Carry Clear
 39660                                  ;               Buffer at ES:DI is filled in with data
 39661                                  ;               ES:DI point byte after nul byte at end of dest string in buffer
 39662                                  ;       Carry Set
 39663                                  ;               AX = error_path_not_found
 39664                                  ;   Registers modified: all
 39665                                  ;----------------------------------------------------------------------------
 39666                                  
 39667                                  _$NameTrans:
 39668 00006CB1 1E                      	push	ds
 39669 00006CB2 56                      	push	si
 39670 00006CB3 06                      	push	es
 39671 00006CB4 57                      	push	di
 39672 00006CB5 51                      	push	cx ; MSDOS 6.0
 39673                                  	
 39674                                  	; MSDOS 6.0	
 39675                                  ; M027 - Start
 39676                                  ;
 39677                                  ; Sattrib must be set up with default values here. Otherwise, the value from
 39678                                  ; a previous DOS call is used for attrib and DevName thinks it is not a 
 39679                                  ; device if the old call set the volume attribute bit. Note that devname in
 39680                                  ; dir2.asm gets ultimately called by Transpath. See also M026. Also save
 39681                                  ; and restore CX.
 39682                                  
 39683                                  	;mov	ch,16h
 39684 00006CB6 B516                    	mov     ch,attr_hidden+attr_system+attr_directory
 39685 00006CB8 E8B402                  	call	SetAttrib
 39686                                  
 39687                                  ; M027 - End
 39688                                  
 39689                                  	; MSDOS 3.3 (& MSDOS 6.0)
 39690 00006CBB BF[BE03]                	MOV     DI,OPENBUF
 39691 00006CBE E8EAFC                  	CALL    TransPath               ; to translation (everything)
 39692 00006CC1 59                      	pop	cx ; MSDOS 6.0
 39693 00006CC2 5F                      	pop     di
 39694 00006CC3 07                      	pop	es
 39695 00006CC4 5E                      	pop     si
 39696 00006CC5 1F                      	pop     ds
 39697 00006CC6 7303                    	JNC	short TransOK
 39698 00006CC8 E96F99                  	jmp	SYS_RET_ERR
 39699                                  TransOK:
 39700 00006CCB BE[BE03]                	MOV     SI,OPENBUF
 39701 00006CCE 16                      	push	ss
 39702 00006CCF 1F                      	pop	ds
 39703                                  ;GotText:
 39704 00006CD0 E8EDA4                  	call	FStrCpy
 39705 00006CD3 E95B99                  	jmp	SYS_RET_OK
 39706                                  
 39707                                  ;Break   <DriveFromText - return drive number from a text string>
 39708                                  ;----------------------------------------------------------------------------
 39709                                  ;   DriveFromText - examine DS:SI and remove a drive letter, advancing the
 39710                                  ;   pointer.
 39711                                  ;
 39712                                  ;   Inputs:     DS:SI point to a text string
 39713                                  ;   Outputs:    AL has drive number
 39714                                  ;               DS:SI advanced
 39715                                  ;   Registers modified: AX,SI.
 39716                                  ;----------------------------------------------------------------------------
 39717                                  
 39718                                  DriveFromText:
 39719 00006CD6 30C0                    	XOR     AL,AL                   ;       drive = 0;
 39720                                  	;CMP	BYTE [SI],0		;       if (*s &&
 39721                                  	; 23/09/2023
 39722 00006CD8 3804                    	cmp	[si],al ; 0
 39723 00006CDA 74D4                    	jz	short Splice_retn
 39724 00006CDC 807C013A                	CMP     BYTE [SI+1],':'		;           s[1] == ':') {
 39725 00006CE0 75CE                    	jnz	short Splice_retn
 39726 00006CE2 AD                      	LODSW                           ;           drive = (*s | 020) - 'a'+1;
 39727 00006CE3 0C20                    	OR      AL,20h
 39728                                  	;sub	al,60h
 39729 00006CE5 2C60                    	SUB     AL,'a'-1                ;           s += 2;
 39730 00006CE7 75C7                    	jnz	short Splice_retn
 39731 00006CE9 B0FF                    	MOV	AL,-1                   ; nuke AL...
 39732                                  	; 23/09/2023
 39733                                  	;dec	al ; -1
 39734 00006CEB C3                      	retn				;           }
 39735                                  
 39736                                  ;Break   <TextFromDrive - convert a drive number to a text string>
 39737                                  ;----------------------------------------------------------------------------
 39738                                  ;   TextFromDrive - turn AL into a drive letter: and put it at es:di with
 39739                                  ;   trailing :. TextFromDrive1 takes a 1-based number.
 39740                                  ;
 39741                                  ;   Inputs:     AL has 0-based drive number
 39742                                  ;   Outputs:    ES:DI advanced
 39743                                  ;   Registers modified: AX
 39744                                  ;----------------------------------------------------------------------------
 39745                                  
 39746                                  TextFromDrive:
 39747 00006CEC FEC0                    	INC     AL
 39748                                  TextFromDrive1:
 39749                                  	;add	al,40h
 39750 00006CEE 0440                    	ADD     AL,'A'-1                ;   *d++ = drive-1+'A';
 39751 00006CF0 B43A                    	MOV     AH,":"	; 3Ah           ;   strcat (d, ":");
 39752 00006CF2 AB                      	STOSW
 39753                                  PathPref_retn:
 39754 00006CF3 C3                      	retn
 39755                                  
 39756                                  ;Break   <PathPref - see if one path is a prefix of another>
 39757                                  ;----------------------------------------------------------------------------
 39758                                  ;   PathPref - compare DS:SI with ES:DI to see if one is the prefix of the
 39759                                  ;   other.  Remember that only at a pathchar break are we allowed to have a
 39760                                  ;   prefix: A:\ and A:\FOO
 39761                                  ;
 39762                                  ;   Inputs:     DS:SI potential prefix
 39763                                  ;               ES:DI string
 39764                                  ;   Outputs:    Zero set => prefix found
 39765                                  ;                   DI/SI advanced past matching part
 39766                                  ;               Zero reset => no prefix, DS/SI garbage
 39767                                  ;   Registers modified: CX
 39768                                  ;----------------------------------------------------------------------------
 39769                                  
 39770                                  PathPref:
 39771 00006CF4 E8E0A4                  	call	DStrLen                 ; get length
 39772 00006CF7 49                      	DEC     CX                      ; do not include nul byte
 39773 00006CF8 F3A6                    	REPZ    CMPSB                   ; compare
 39774 00006CFA 75F7                    	jnz	short PathPref_retn	; if NZ then return NZ
 39775 00006CFC 50                      	push	ax			; save char register
 39776 00006CFD 8A44FF                  	MOV     AL,[SI-1]               ; get last byte to match
 39777 00006D00 E80FE2                  	call    PATHCHRCMP              ; is it a path char (Root!)
 39778 00006D03 7406                    	JZ	short Prefix		; yes, match root (I hope)
 39779                                  NotSep:                                 ; 2/13/KK
 39780 00006D05 268A05                  	MOV     AL,[ES:DI]		; get next char to match
 39781 00006D08 E87AFE                  	CALL    PathSepGotCh            ; was it a pathchar?
 39782                                  Prefix:
 39783 00006D0B 58                      	pop	ax			; get back original
 39784 00006D0C C3                      	retn
 39785                                  
 39786                                  ;Break   <ScanPathChar - see if there is a path character in a string>
 39787                                  ;----------------------------------------------------------------------------
 39788                                  ;     ScanPathChar - search through the string (pointed to by DS:SI) for
 39789                                  ;     a path separator.
 39790                                  ;
 39791                                  ;     Input:    DS:SI target string (null terminated)
 39792                                  ;     Output:   Zero set => path separator encountered in string
 39793                                  ;               Zero clear => null encountered
 39794                                  ;     Registers modified: SI
 39795                                  ;----------------------------------------------------------------------------
 39796                                  
 39797                                  ScanPathChar:
 39798 00006D0D AC                      	LODSB                           ; fetch a character
 39799 00006D0E E874FE                  	call    PathSepGotCh
 39800 00006D11 75FA                    	JNZ	short ScanPathChar	; not \, / or NUL => go back for more
 39801                                  	;call	PATHCHRCMP              ; path separator?
 39802                                  	;retn
 39803                                  	; 18/12/2022
 39804 00006D13 E9FCE1                  	jmp	PATHCHRCMP
 39805                                  
 39806                                  ;============================================================================
 39807                                  ; FILE.ASM, MSDOS 6.0, 1991
 39808                                  ;============================================================================
 39809                                  ; 14/07/2018 - Retro DOS v3.0
 39810                                  
 39811                                  ; 13/05/2019 - Retro DOS v4.0
 39812                                  ; DOSCODE:AF10h (MSDOS 6.21, MSDOS.SYS)
 39813                                  
 39814                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39815                                  ; DOSCODE:AEADh (MSDOS 5.0, MSDOS.SYS)
 39816                                  
 39817                                  ; MSDOS 2.11
 39818                                  ;BREAK <$Open - open a file handle>
 39819                                  ;----------------------------------------------------------------------------
 39820                                  ;   Assembler usage:
 39821                                  ;           LDS     DX, Name
 39822                                  ;           MOV     AH, Open
 39823                                  ;           MOV     AL, access
 39824                                  ;           INT     int_command
 39825                                  ;
 39826                                  ;       ACCESS          Function
 39827                                  ;       ------          --------
 39828                                  ;       open_for_read   file is opened for reading
 39829                                  ;       open_for_write  file is opened for writing
 39830                                  ;       open_for_both   file is opened for both reading and writing.
 39831                                  ;
 39832                                  ;   Error returns:
 39833                                  ;           AX = error_invalid_access
 39834                                  ;              = error_file_not_found
 39835                                  ;              = error_access_denied
 39836                                  ;              = error_too_many_open_files
 39837                                  ;----------------------------------------------------------------------------
 39838                                  
 39839                                  ; MSDOS 6.0
 39840                                  ;	BREAK <$Open - open a file from a path string>
 39841                                  ;----------------------------------------------------------------------------
 39842                                  ;
 39843                                  ;**	$OPen - Open a File
 39844                                  ;
 39845                                  ;	given a path name in DS:DX and an open mode in AL, $Open opens the
 39846                                  ;	file and and returns a handle
 39847                                  ;
 39848                                  ;	ENTRY	(DS:DX) = pointer to asciz name
 39849                                  ;		(AL) = open mode
 39850                                  ;	EXIT	'C' clear if OK
 39851                                  ;		  (ax) = file handle
 39852                                  ;		'C' set if error
 39853                                  ;		  (ax) = error code
 39854                                  ;	USES	all
 39855                                  ;
 39856                                  ;----------------------------------------------------------------------------
 39857                                  
 39858                                  ; 13/05/2019 - Retro DOS v4.0
 39859                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39860                                  
 39861                                  _$OPEN:       
 39862 00006D16 30E4                    	xor	ah,ah  ; MSDOS 6.0	
 39863                                  _$Open2:
 39864                                  	;mov	ch,16h
 39865 00006D18 B516                    	mov	ch,attr_hidden+attr_system+attr_directory
 39866 00006D1A E85202                  	call	SetAttrib
 39867 00006D1D B9[B62A]                	mov	cx,DOS_OPEN
 39868                                  
 39869                                  	;xor	ah,ah  ; MSDOS 3.3
 39870                                  
 39871 00006D20 50                      	push	ax
 39872                                  
 39873                                  ;*	General file open/create code. The $CREATE call and the various
 39874                                  ;	$OPEN calls all come here.
 39875                                  ;
 39876                                  ;	We'll share a lot of the standard stuff of allocating SFTs, cracking
 39877                                  ;	path names, etc., and then dispatch to our individual handlers.
 39878                                  ;	WARNING - this info and list is just a guess, not definitive - jgl
 39879                                  ;
 39880                                  ;	(TOS) = create mode
 39881                                  ;	(CX) = address of routine to call to do actual function
 39882                                  ;	(DS:DX) = ASCIZ name
 39883                                  ;	SAttrib = Attribute mask
 39884                                  
 39885                                  ;	Get a free SFT and mark it "being allocated"
 39886                                  
 39887                                  AccessFile:
 39888 00006D21 E8BEA5                  	call	ECritSFT
 39889 00006D24 E8F1F7                  	call	SFNFree			; get a free sfn
 39890 00006D27 E8D3A5                  	call	LCritSFT
 39891 00006D2A 7214                    	jc	short OpenFailJ		; oops, no free sft's
 39892 00006D2C 36891E[AA05]            	MOV	[SS:SFN],BX		; save the SFN for later;smr;SS Override
 39893 00006D31 36893E[9E05]            	MOV	[SS:THISSFT],DI		; save the SF offset	;smr;SS Override
 39894 00006D36 368C06[A005]            	MOV	[SS:THISSFT+2],ES	; save the SF segment	;smr;SS Override
 39895                                  
 39896                                  ;	Find a free area in the user's JFN table.
 39897                                  
 39898 00006D3B E8C7F7                  	call	JFNFree			; get a free jfn
 39899 00006D3E 7303                    	jnc	short SaveJFN
 39900                                  OpenFailJ:
 39901 00006D40 E99300                  	JMP	OpenFail		; there were free JFNs... try SFN
 39902                                  
 39903                                  SaveJFN:
 39904 00006D43 36893E[AE05]            	mov	[ss:PJFN],DI		; save the jfn offset	;smr;SS Override
 39905 00006D48 368C06[B005]            	MOV	[ss:PJFN+2],ES		; save the jfn segment	;smr;SS Override
 39906 00006D4D 36891E[AC05]            	MOV	[ss:JFN],BX		; save the jfn itself	;smr;SS Override
 39907                                  
 39908                                  ;	We have been given an JFN. We lock it down to prevent other tasks from
 39909                                  ;	reusing the same JFN.
 39910                                  
 39911 00006D52 368B1E[AA05]            	MOV	BX,[ss:SFN]					;smr;SS Override
 39912 00006D57 26881D                  	MOV	[ES:DI],BL		; assign the JFN
 39913 00006D5A 89D6                    	MOV	SI,DX			; get name in appropriate place
 39914 00006D5C BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 39915 00006D5F 51                      	push	cx			; save routine to call
 39916 00006D60 E848FC                  	call	TransPath		; convert the path
 39917 00006D63 5B                      	pop	bx			; (bx) = routine to call
 39918                                  
 39919 00006D64 36C536[9E05]            	LDS	SI,[SS:THISSFT]					;smr;SS Override
 39920                                  	;JC	short OpenCleanJ	; no error, go and open file
 39921                                  	; 14/03/2024
 39922 00006D69 725C                    	jc	short OpenClean
 39923                                  
 39924 00006D6B 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1				;smr;SS Override
 39925 00006D71 7404                    	JZ	short SetSearch
 39926                                  	;mov	al,2
 39927 00006D73 B002                    	MOV	AL,error_file_not_found ; no meta chars allowed
 39928                                  OpenCleanJ:
 39929 00006D75 EB50                    	JMP	short OpenClean
 39930                                  
 39931                                  SetSearch:
 39932 00006D77 58                      	pop	ax			; Mode (Open), Attributes (Create)
 39933                                  
 39934                                  ;	We need to get the new inheritance bits.
 39935                                  
 39936 00006D78 31C9                    	xor	cx,cx
 39937                                  	; MSDOS 6.0
 39938                                  	;mov	[si+2],cx ; 0
 39939 00006D7A 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],cx ; initialize mode field to 0
 39940                                  	;mov    [si+51],cx ; 0
 39941 00006D7D 894C33                  	MOV	[SI+SF_ENTRY.sf_MFT],cx	 ; clean out sharing info
 39942                                  	;
 39943 00006D80 81FB[B62A]              	CMP	BX,DOS_OPEN
 39944 00006D84 7509                    	JNZ	short _DoOper
 39945                                  	;test   al,80h
 39946 00006D86 A880                    	test	AL,SHARING_NO_INHERIT	; look for no inher
 39947 00006D88 7405                    	JZ	short _DoOper ; 10/08/2018
 39948 00006D8A 247F                    	AND	AL,7Fh			; mask off inherit bit
 39949                                  	;mov	cx,1000h
 39950 00006D8C B90010                  	MOV	CX,sf_no_inherit
 39951                                  _DoOper:
 39952                                  	;; MSDOS 3.3
 39953                                  	;;mov	word [si+2], 0
 39954                                  	;;mov	word [si+33h], 0
 39955                                  	;MOV	word [SI+SF_ENTRY.sf_mode],0
 39956                                  	;MOV	word [SI+SF_ENTRY.sf_MFT],0
 39957                                  
 39958                                  	; MSDOS 6.0
 39959                                  ;**	Check if this is an extended open. If so you must set the
 39960                                  ;	modes in sf_mode. Call Set_EXT_mode to do all this. See
 39961                                  ;	Set_EXT_mode in creat.asm
 39962                                  
 39963                                  	; MSDOS 6.0
 39964                                  	;SAVE	<di, es>                ;M022 conditional removed here
 39965 00006D8F 57                      	push	di
 39966 00006D90 06                      	push	es
 39967 00006D91 1E                      	push	ds
 39968 00006D92 07                      	pop	es
 39969 00006D93 56                      	push	si
 39970 00006D94 5F                      	pop	di			; (es:di) = SFT address
 39971 00006D95 E80ABD                  	call	Set_EXT_mode
 39972                                  	;RESTORE <es, di>
 39973 00006D98 07                      	pop	es
 39974 00006D99 5F                      	pop	di
 39975                                  
 39976                                  	;Context DS
 39977 00006D9A 16                      	push	ss
 39978 00006D9B 1F                      	pop	ds	
 39979                                  
 39980 00006D9C 51                      	push	cx
 39981 00006D9D FFD3                    	CALL	BX			; blam!
 39982 00006D9F 59                      	pop	cx
 39983 00006DA0 C536[9E05]              	LDS	SI,[THISSFT]
 39984 00006DA4 721A                    	JC	short OpenE2		;AN000;FT. chek extended open hooks first
 39985                                  	;jc	short OpenE ; MSDOS 3.3
 39986                                  
 39987                                  ;	The SFT was successfully opened. Remove busy mark.
 39988                                  
 39989                                  OpenOK:
 39990                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],1
 39991 00006DA6 C7040100                	mov	word [SI],1
 39992                                  	;or	[SI+5],cx
 39993 00006DAA 094C05                  	OR	[SI+SF_ENTRY.sf_flags],CX ; set no inherit bit if necessary
 39994                                  
 39995                                  ; If the open mode is 70, we scan the system for other SFT's with the same
 39996                                  ; contents. If we find one, then we can 'collapse' thissft onto the already
 39997                                  ; opened one. Otherwise we use this new one. We compare uid/pid/mode/mft
 39998                                  ;
 39999                                  ; Since this is only relevant on sharer systems, we stick this code into the
 40000                                  ; sharer.
 40001                                  
 40002 00006DAD 36A1[AC05]              	MOV	AX,[ss:JFN]				;smr;SS Override
 40003 00006DB1 36FF1E[C000]            	Call	far [ss:JShare+(12*4)]	; 12 = ShCol	;smr;SS Override
 40004                                  
 40005 00006DB6 36C706[AA05]FFFF        	MOV	word [ss:SFN],-1	; clear out sfn pointer	;smr;SS Override
 40006                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40007                                  OpenOkj:
 40008 00006DBD E97198                  	jmp	SYS_RET_OK		; bye with no errors
 40009                                  
 40010                                  	; MSDOS 6.0
 40011                                  ;Extended Open hooks check
 40012                                  OpenE2:					;AN000;;EO.
 40013 00006DC0 83F857                  	CMP	AX,error_invalid_parameter ;AN000;;EO. IFS extended open ?
 40014 00006DC3 7503                    	JNZ	short OpenE		;AN000;;EO. no.
 40015 00006DC5 EB11                    	JMP	short OpenCritLeave	;AN000;;EO. keep handle
 40016                                  
 40017                                  ;	Extended Open hooks check
 40018                                  ;
 40019                                  ;	AL has error code. Stack has argument to dos_open/dos_create.
 40020                                  
 40021                                  OpenClean:
 40022 00006DC7 5B                      	pop	bx			; clean off stack
 40023                                  OpenE:
 40024                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],0 ; release SFT
 40025 00006DC8 C7040000                	mov	word [SI],0
 40026 00006DCC 36C536[AE05]            	LDS	SI,[ss:PJFN]		;smr;SS Override
 40027 00006DD1 C604FF                  	MOV	BYTE [SI],0FFh		; free the SFN...
 40028 00006DD4 EB02                    	JMP	SHORT OpenCritLeave
 40029                                  
 40030                                  OpenFail:
 40031 00006DD6 FB                      	STI
 40032 00006DD7 59                      	pop	cx			; Clean stack
 40033                                  OpenCritLeave:
 40034 00006DD8 36C706[AA05]FFFF        	MOV	word [SS:SFN],-1	; remove mark.
 40035                                  
 40036                                  	; MSDOS 6.0
 40037                                  ; File Tagging DOS 4.00
 40038 00006DDF 36833E[2403]25          	CMP	word [SS:EXTERR],error_Code_Page_Mismatched
 40039                                  					;AN000;;FT. code page mismatch
 40040 00006DE5 7503                    	JNZ	short NORERR	  	;AN000;;FT. no
 40041 00006DE7 E95898                  	jmp	From_GetSet		;AN000;;FT. yes
 40042                                  NORERR: 				;AN000;
 40043                                  ; File Tagging DOS 4.00
 40044                                  
 40045 00006DEA E94D98                  	jmp	SYS_RET_ERR		; no free, return error
 40046                                  
 40047                                  ; MSDOS 2.11
 40048                                  ;BREAK <$CREAT - creat a new file and open him for input>
 40049                                  ;----------------------------------------------------------------------------
 40050                                  ;   Assembler usage:
 40051                                  ;           LDS     DX, name
 40052                                  ;           MOV     AH, Creat
 40053                                  ;           MOV     CX, access
 40054                                  ;           INT     21h
 40055                                  ;       ; AX now has the handle
 40056                                  ;
 40057                                  ;   Error returns:
 40058                                  ;           AX = error_access_denied
 40059                                  ;              = error_path_not_found
 40060                                  ;              = error_too_many_open_files
 40061                                  ;----------------------------------------------------------------------------
 40062                                  
 40063                                  ; MSDOS 6.0
 40064                                  ;	BREAK <$Creat - create a brand-new file>
 40065                                  ;----------------------------------------------------------------------------
 40066                                  ;
 40067                                  ;**	$Creat - Create a File
 40068                                  ;
 40069                                  ;	$Creat creates the directory entry specified in DS:DX and gives it the
 40070                                  ;	initial attributes contained in CX
 40071                                  ;
 40072                                  ;	ENTRY	(DS:DX) = ASCIZ path name
 40073                                  ;		(CX) = initial attributes
 40074                                  ;	EXIT	'C' set if error
 40075                                  ;		  (ax) = error code
 40076                                  ;		'C' clear if OK
 40077                                  ;		  (ax) = file handle
 40078                                  ;	USES	all
 40079                                  ;
 40080                                  ;----------------------------------------------------------------------------
 40081                                  
 40082                                  _$CREAT:
 40083 00006DED 51                      	push	cx			; Save attributes on stack
 40084 00006DEE B9[9029]                	mov	CX,DOS_CREATE		; routine to call
 40085                                  AccessSet:
 40086                                  	;mov	byte [ss:SATTRIB],6
 40087 00006DF1 36C606[6D05]06          	mov	byte [ss:SATTRIB],attr_hidden+attr_system ;smr;SS Override
 40088                                  	; 10/08/2018
 40089 00006DF7 E927FF                  	JMP	AccessFile		; use good ol' open
 40090                                  
 40091                                  ; MSDOS 6.0 (MSDOS 3.3)
 40092                                  ;	BREAK <$CHMOD - change file attributes>
 40093                                  ;----------------------------------------------------------------------------
 40094                                  ;
 40095                                  ;**	$CHMOD - Change File Attributes
 40096                                  ;
 40097                                  ;   Assembler usage:
 40098                                  ;	    LDS     DX, name
 40099                                  ;	    MOV     CX, attributes
 40100                                  ;	    MOV     AL,func (0=get, 1=set)
 40101                                  ;	    INT     21h
 40102                                  ;   Error returns:
 40103                                  ;	    AX = error_path_not_found
 40104                                  ;	    AX = error_access_denied
 40105                                  ;
 40106                                  ;----------------------------------------------------------------------------
 40107                                  
 40108                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40109                                  _$CHMOD:
 40110                                  	; 05/08/2018 - Retro DOS v3.0
 40111                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6FCCh ,
 40112 00006DFA BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 40113 00006DFD 50                      	push	ax
 40114 00006DFE 51                      	push	cx			; save function and attributes
 40115 00006DFF 89D6                    	MOV	SI,DX			; get things in appropriate places
 40116 00006E01 E8ABFB                  	call	TransPathSet		; get correct path
 40117 00006E04 59                      	pop	cx
 40118 00006E05 58                      	pop	ax			; and get function and attrs back
 40119 00006E06 7257                    	JC	short ChModErr		; errors get mapped to path not found
 40120 00006E08 16                      	push	ss			; set up for later possible calls
 40121 00006E09 1F                      	pop	ds
 40122 00006E0A 803E[7A05]FF            	CMP	byte [CMETA],-1
 40123 00006E0F 754E                    	JNZ	short ChModErr
 40124                                  	;mov	byte [SATTRIB],16h
 40125 00006E11 C606[6D05]16            	MOV	byte [SATTRIB],attr_hidden+attr_system+attr_directory
 40126 00006E16 2C01                    	SUB	AL,1			; fast way to discriminate
 40127 00006E18 720B                    	JB	short ChModGet		; 0 -> go get value
 40128 00006E1A 7417                    	JZ	short ChModSet		; 1 -> go set value
 40129                                  	;mov	byte [EXTERR_LOCUS],1
 40130 00006E1C C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 40131                                  	;mov	al,1
 40132 00006E21 B001                    	mov	al,error_invalid_function ; bad value
 40133                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40134                                  chmod_errj:	
 40135                                  	;;jmp	SYS_RET_ERR
 40136                                  	;jmp	short ChModE	
 40137 00006E23 EBC5                    	jmp	short NORERR	; 06/12/2022
 40138                                  ChModGet:
 40139 00006E25 E85FBA                  	call	GET_FILE_INFO		; suck out the ol' info
 40140 00006E28 7237                    	JC	short ChModE		; error codes are already set for ret
 40141 00006E2A E85496                  	call	Get_User_Stack		; point to user saved vaiables
 40142                                  	;mov	[SI+4],ax
 40143 00006E2D 894404                  	MOV	[SI+user_env.user_CX],AX ; return the attributes
 40144                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility
 40145                                  OpenOkj2:
 40146                                  	; 17/12/2022
 40147                                  	;;jmp	SYS_RET_OK		; say sayonara
 40148                                  	;jmp	short OpenOkj
 40149                                  	; 25/06/2019
 40150 00006E30 E90198                  	jmp	SYS_RET_OK_clc
 40151                                  
 40152                                  ChModSet:
 40153 00006E33 89C8                    	MOV	AX,CX			; get attrs in position
 40154 00006E35 E8ADBA                  	call	SET_FILE_ATTRIBUTE	; go set
 40155 00006E38 7227                    	JC	short ChModE		; errors are set
 40156                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility
 40157                                  	;jmp	SYS_RET_OK
 40158                                  OpenOkj3:
 40159                                  	;jmp	short OpenOkj2
 40160                                  	; 17/12/2022
 40161 00006E3A E9F497                  	jmp	SYS_RET_OK
 40162                                  
 40163                                  ; 17/12/2022
 40164                                  %if 0
 40165                                  ChModErr:
 40166                                  NotFound:	; 17/12/2022
 40167                                  	;mov	al,3
 40168                                  	mov	al,error_path_not_found
 40169                                  ChModE:
 40170                                  UnlinkE:	; 17/12/2022
 40171                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40172                                  	;;jmp	SYS_RET_ERR
 40173                                  	;jmp	short chmod_errj
 40174                                  	; 17/12/2022
 40175                                  	jmp	short NORERR
 40176                                  %endif
 40177                                  
 40178                                  ; 22/05/2019 - Retro DOS v4.0
 40179                                  ; DOSCODE:B039h (MSDOS 6.21, MSDOS.SYS)
 40180                                  
 40181                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40182                                  ; DOSCODE:AFD6h (MSDOS 5.0, MSDOS.SYS)
 40183                                  
 40184                                  ;	BREAK <$UNLINK - delete a file entry>
 40185                                  ;----------------------------------------------------------------------------
 40186                                  ;
 40187                                  ;**	$UNLINK - Delete a File
 40188                                  ;
 40189                                  ;
 40190                                  ;	Assembler usage:
 40191                                  ;	    LDS     DX, name
 40192                                  ;	    IF VIA SERVER DOS CALL
 40193                                  ;	     MOV     CX,SEARCH_ATTRIB
 40194                                  ;	    MOV     AH, Unlink
 40195                                  ;	    INT     21h
 40196                                  ;
 40197                                  ;	ENTRY	(ds:dx) = path name
 40198                                  ;		(cx) = search_attribute, if via server_dos
 40199                                  ;	EXIT	'C' clear if no error
 40200                                  ;		'C' set if error
 40201                                  ;		  (ax) = error code
 40202                                  ;			= error_file_not_found
 40203                                  ;			= error_access_denied
 40204                                  ;
 40205                                  ;----------------------------------------------------------------------------
 40206                                  
 40207                                  _$UNLINK:
 40208 00006E3D 51                      	push	cx			; Save possible CX input parm
 40209 00006E3E 89D6                    	MOV	SI,DX			; Point at input string
 40210 00006E40 BF[BE03]                	MOV	DI,OPENBUF		; temp spot for path
 40211 00006E43 E869FB                  	call	TransPathSet		; go get normalized path
 40212 00006E46 59                      	pop	cx
 40213 00006E47 7216                    	JC	short ChModErr		; badly formed path
 40214 00006E49 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1	; meta chars?	;smr;SS Override
 40215 00006E4F 750E                    	JNZ	short NotFound
 40216 00006E51 16                      	push	ss
 40217 00006E52 1F                      	pop	ds
 40218                                  	;mov	ch,6
 40219 00006E53 B506                    	mov	ch,attr_hidden+attr_system ; unlink appropriate files
 40220 00006E55 E81701                  	call	SetAttrib
 40221 00006E58 E846B6                  	call	DOS_DELETE		; remove that file
 40222                                  	;JC	short UnlinkE 		; error is there
 40223                                  	; 17/12/2022
 40224 00006E5B 728D                    	jc	short NORERR
 40225                                  
 40226                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40227                                  UnlinkOk:
 40228                                  	;jmp	SYS_RET_OK		; okey doksy
 40229 00006E5D EBDB                    	jmp	short OpenOkj3
 40230                                  
 40231                                  	; 17/12/2022
 40232                                  ChModErr:	; 17/12/2022
 40233                                  NotFound:
 40234                                  	;mov	al,3
 40235 00006E5F B003                    	MOV	AL,error_path_not_found
 40236                                  ChModE:		; 17/12/2022
 40237                                  UnlinkE:
 40238                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40239                                  	;;jmp	SYS_RET_ERR		; bye
 40240                                  	;jmp	short ChModE
 40241                                  	; 17/12/2022
 40242 00006E61 EB87                    	jmp	short NORERR
 40243                                  
 40244                                  ;BREAK <$RENAME - move directory entries around>
 40245                                  ;----------------------------------------------------------------------------
 40246                                  ;
 40247                                  ;   Assembler usage:
 40248                                  ;	    LDS     DX, source
 40249                                  ;	    LES     DI, dest
 40250                                  ;	    IF VIA SERVER DOS CALL
 40251                                  ;	      MOV   CX,SEARCH_ATTRIB
 40252                                  ;	    MOV     AH, Rename
 40253                                  ;	    INT     21h
 40254                                  ;
 40255                                  ;   Error returns:
 40256                                  ;	    AX = error_file_not_found
 40257                                  ;	       = error_not_same_device
 40258                                  ;	       = error_access_denied
 40259                                  ;
 40260                                  ;----------------------------------------------------------------------------
 40261                                  
 40262                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40263                                  _$RENAME:
 40264                                  	; MSDOS 3.3 (& MSDOS 6.0)
 40265 00006E63 51                      	push	cx
 40266 00006E64 1E                      	push	ds
 40267 00006E65 52                      	push	dx			; save source and possible CX arg
 40268 00006E66 06                      	PUSH	ES
 40269 00006E67 1F                      	POP	DS			; move dest to source
 40270 00006E68 89FE                    	MOV	SI,DI			; save for offsets
 40271 00006E6A BF[3E04]                	MOV	DI,RENBUF
 40272 00006E6D E83FFB                  	call	TransPathSet		; munge the paths
 40273 00006E70 36FF36[B205]            	PUSH	word [ss:WFP_START]	; get pointer	;smr;SS Override
 40274 00006E75 368F06[B405]            	POP	word [ss:REN_WFP]	; stash it	;smr;SS Override
 40275 00006E7A 5E                      	pop	si
 40276 00006E7B 1F                      	pop	ds
 40277 00006E7C 59                      	pop	cx			; get back source and possible CX arg
 40278                                  epjc2:	
 40279 00006E7D 72E0                    	JC	short ChModErr		; get old error
 40280 00006E7F 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1			;smr;SS Override
 40281 00006E85 75D8                    	JNZ	short NotFound
 40282 00006E87 51                      	push	cx			; Save possible CX arg
 40283 00006E88 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 40284 00006E8B E821FB                  	call	TransPathSet		; wham
 40285 00006E8E 59                      	pop	cx
 40286                                  	;JC	short epjc2
 40287                                  	; 15/03/2024
 40288 00006E8F 72CE                    	jc	short ChModErr
 40289                                  
 40290 00006E91 16                      	push	ss
 40291 00006E92 1F                      	pop	ds
 40292 00006E93 803E[7A05]FF            	CMP	byte [CMETA],-1
 40293 00006E98 72C5                    	JB	short NotFound
 40294                                  
 40295                                  	; MSDOS 6.0
 40296                                  	;PUSH	WORD [THISCDS]		   ;AN000;;MS.save thiscds
 40297                                  	;PUSH	WORD [THISCDS+2]	   ;AN000;;MS.
 40298                                  	; 15/03/2024
 40299                                  	;;;
 40300 00006E9A C43E[A205]              	les	di,[THISCDS]
 40301 00006E9E 57                      	push	di
 40302 00006E9F 06                      	push	es
 40303                                  	;;;
 40304                                  
 40305 00006EA0 BF[BE03]                	MOV	DI,OPENBUF		   ;AN000;;MS.
 40306 00006EA3 16                      	PUSH	SS			   ;AN000;;MS.
 40307 00006EA4 07                      	POP	ES			   ;AN000;;MS.es:di-> source
 40308 00006EA5 30C0                    	XOR	AL,AL			   ;AN000;;MS.scan all CDS
 40309                                  rnloop:					   ;AN000;
 40310 00006EA7 E87FFA                  	call	GetCDSFromDrv		   ;AN000;;MS.
 40311 00006EAA 720F                    	JC	short dorn		   ;AN000;;MS.	end of CDS
 40312 00006EAC E8E0A2                  	call	StrCmp			   ;AN000;;MS.	current dir ?
 40313 00006EAF 7404                    	JZ	short rnerr		   ;AN000;;MS.	yes
 40314 00006EB1 FEC0                    	INC	AL			   ;AN000;;MS.	next
 40315 00006EB3 EBF2                    	JMP	short rnloop		   ;AN000;;MS.
 40316                                  rnerr:					   ;AN000;
 40317                                  	;ADD	SP,4			   ;AN000;;MS. pop thiscds
 40318                                  	; 15/03/2024 (PCDOS 7.1 IBMDOS.COM)
 40319 00006EB5 58                      	pop	ax
 40320 00006EB6 58                      	pop	ax
 40321                                  
 40322                                  	;error	error_current_directory    ;AN000;;MS.
 40323 00006EB7 B010                    	mov	al,error_current_directory 
 40324                                  	;jmp	SYS_RET_ERR
 40325                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40326 00006EB9 EBA6                    	jmp	short UnlinkE
 40327                                  dorn:
 40328                                  
 40329                                  ; 15/03/2024
 40330                                  %if 0					   ;AN000;
 40331                                  	POP	WORD [SS:THISCDS+2]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 40332                                  	POP	WORD [SS:THISCDS]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 40333                                  %endif
 40334 00006EBB 16                      	push	ss
 40335 00006EBC 1F                      	pop	ds
 40336                                  
 40337                                  ; 15/03/2024
 40338                                  %if 1
 40339 00006EBD 8F06[A405]              	pop	word [THISCDS+2]
 40340 00006EC1 8F06[A205]              	pop	word [THISCDS]
 40341                                  %endif
 40342                                  	; MSDOS 3.3 (& MSDOS 6.0)
 40343                                  	;mov	ch,16h
 40344 00006EC5 B516                    	mov	ch,attr_directory+attr_hidden+attr_system
 40345                                  					; rename appropriate files
 40346 00006EC7 E8A500                  	call	SetAttrib
 40347 00006ECA E8A8B7                  	call	DOS_RENAME		; do the deed
 40348 00006ECD 7292                    	JC	short UnlinkE 		; errors
 40349                                  
 40350                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40351                                  	;jmp	SYS_RET_OK
 40352 00006ECF EB8C                    	jmp	short UnlinkOk
 40353                                  
 40354                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40355                                  
 40356                                  ; 14/07/2018 - Retro DOS v3.0
 40357                                  ; MSDOS 3.3 (& MSDOS 6.0)
 40358                                  
 40359                                  ;Break <$CreateNewFile - Create a new directory entry>
 40360                                  ;----------------------------------------------------------------------------
 40361                                  ;   CreateNew - Create a new directory entry.  Return a file handle if there
 40362                                  ;	was no previous directory entry, and fail if a directory entry with
 40363                                  ;	the same name existed previously.
 40364                                  ;
 40365                                  ;   Inputs:	DS:DX point to an ASCIZ file name
 40366                                  ;		CX contains default file attributes
 40367                                  ;   Outputs:	Carry Clear:
 40368                                  ;		    AX has file handle opened for read/write
 40369                                  ;		Carry Set:
 40370                                  ;		    AX has error code
 40371                                  ;   Registers modified: All
 40372                                  ;----------------------------------------------------------------------------
 40373                                  
 40374                                  _$CreateNewFile:
 40375 00006ED1 51                      	push	cx			; Save attributes on stack
 40376 00006ED2 B9[592A]                	MOV	CX,DOS_Create_New	; routine to call
 40377 00006ED5 E919FF                  	JMP	AccessSet		; use good ol' open
 40378                                  
 40379                                  ;**	BinToAscii - convert a number to a string.
 40380                                  ;----------------------------------------------------------------------------
 40381                                  ;	BinToAscii converts a 16 bit number into a 4 ascii characters.
 40382                                  ;	This routine is used to generate temp file names so we don't spend
 40383                                  ;	the time and code needed for a true hex number, we just use
 40384                                  ;	A thorugh O.
 40385                                  ;
 40386                                  ;	ENTRY	(ax) = value
 40387                                  ;		(es:di) = destination
 40388                                  ;	EXIT	(es:di) updated by 4
 40389                                  ;	USES	cx, di, flags
 40390                                  ;----------------------------------------------------------------------------
 40391                                  
 40392                                  ; MSDOS 3.3
 40393                                  ;BinToAscii:
 40394                                  ;	mov     cx,4
 40395                                  ;bta5:
 40396                                  ;	push    cx
 40397                                  ;	mov     cl,4
 40398                                  ;	rol     ax,cl
 40399                                  ;	push    ax
 40400                                  ;	and     al,0Fh
 40401                                  ;	add     al,'0'
 40402                                  ;	cmp     al,'9'
 40403                                  ;	jbe     short bta6
 40404                                  ;	add     al,7
 40405                                  ;bta6: 
 40406                                  ;	stosb
 40407                                  ;	pop     ax
 40408                                  ;	pop     cx
 40409                                  ;	loop    bta5
 40410                                  ;	retn
 40411                                  
 40412                                  ; 15/03/2024
 40413                                  ; MSDOS 5.0-6.22 & Windows ME
 40414                                  ; (MSDOS 6.22 MSDOS.SYS - DOSCODE:0B0D9h)
 40415                                  ; (Windows ME IO.SYS - BIOSCODE:0ABA4h)
 40416                                  %if 1
 40417                                  
 40418                                  ; MSDOS 6.0
 40419                                  BinToAscii:
 40420 00006ED8 B90404                  	mov	cx,404h			; (ch) = digit counter, (cl) = shift cnt
 40421                                  bta5:	
 40422 00006EDB D3C0                    	ROL	AX,CL			; move leftmost nibble into rightmost
 40423 00006EDD 50                      	push	ax			; preserve remainder of digits
 40424 00006EDE 240F                    	AND	AL,0Fh			; grab low nibble
 40425 00006EE0 0441                    	ADD	AL,'A'			; turn into ascii
 40426 00006EE2 AA                      	STOSB				; drop in the character
 40427 00006EE3 58                      	pop	ax			; (ax) = shifted number
 40428 00006EE4 FECD                    	dec	ch
 40429 00006EE6 75F3                    	jnz	short bta5		; process 4 digits
 40430 00006EE8 C3                      	retn
 40431                                  %else
 40432                                  ; 15/03/2024
 40433                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:0C385h
 40434                                  
 40435                                  BinToAscii:
 40436                                  	push	ax		; convert a number to a string ; ax = value
 40437                                  	xchg	ah,al
 40438                                  	;db	0D4h,10h
 40439                                  	aam	10h		; AH = AL / 16 and AL = remainder
 40440                                  	add	ax,4141h	; 'AA'
 40441                                  	stosw
 40442                                  	pop	ax
 40443                                  	;db	0D4h,10h
 40444                                  	aam	10h
 40445                                  	add	ax,4141h	; add ax,'AA'
 40446                                  	stosw
 40447                                  	retn	
 40448                                  %endif
 40449                                  
 40450                                  ;Break	<$CreateTempFile - create a unique name>
 40451                                  ;----------------------------------------------------------------------------
 40452                                  ;   $CreateTemp - given a directory, create a unique name in that directory.
 40453                                  ;	Method used is to get the current time, convert to a name and attempt
 40454                                  ;	a create new. Repeat until create new succeeds.
 40455                                  ;
 40456                                  ;   Inputs:	DS:DX point to a null terminated directory name.
 40457                                  ;		CX  contains default attributes
 40458                                  ;   Outputs:	Unique name is appended to DS:DX directory.
 40459                                  ;		AX has handle
 40460                                  ;   Registers modified: all
 40461                                  ;----------------------------------------------------------------------------
 40462                                  
 40463                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40464                                  
 40465                                  _$CreateTempFile:
 40466                                  	;Enter
 40467 00006EE9 55                      	push	bp
 40468 00006EEA 89E5                    	mov	bp,sp
 40469                                  
 40470                                  	;LocalVar  EndPtr,DWORD
 40471                                  	;LocalVar  FilPtr,DWORD
 40472                                  	;LocalVar  Attr,WORD
 40473                                  
 40474 00006EEC 83EC0A                  	sub	sp,10
 40475                                  
 40476                                  	;test	cx,0FFD8h
 40477 00006EEF F7C1D8FF                	test	CX,~attr_changeable
 40478 00006EF3 7405                    	JZ	short OKatts		; Ok if no non-changeable bits set
 40479                                  
 40480                                  ; We need this "hook" here to detect these cases (like user sets one both of
 40481                                  ; vol_id and dir bits) because of the structure of the or $CreateNewFile loop
 40482                                  ; below. The code loops on error_access_denied, but if one of the non
 40483                                  ; changeable attributes is specified, the loop COULD be infinite or WILL be
 40484                                  ; infinite because CreateNewFile will fail with access_denied always. Thus we
 40485                                  ; need to detect these cases before getting to the loop.
 40486                                  
 40487                                  	;mov	ax, 5
 40488 00006EF5 B80500                  	MOV	AX,error_access_denied
 40489 00006EF8 EB69                    	JMP	SHORT SETTMPERR
 40490                                  
 40491                                  OKatts:
 40492                                  	;MOV	attr,CX 		; save attribute
 40493 00006EFA 894EF6                  	mov     [bp-10],cx
 40494                                  	;MOV	FilPtrL,DX		; pointer to file
 40495 00006EFD 8956F8                  	mov	[bp-8],dx
 40496                                  	;MOV	FilPtrH,DS
 40497 00006F00 8C5EFA                  	mov	[bp-6],ds
 40498                                  	;MOV	EndPtrH,DS		; seg pointer to end of dir
 40499 00006F03 8C5EFE                  	mov	[bp-2],ds
 40500 00006F06 1E                      	PUSH	DS
 40501 00006F07 07                      	POP	ES			; destination for nul search
 40502 00006F08 89D7                    	MOV	DI,DX
 40503 00006F0A 89F9                    	MOV	CX,DI
 40504 00006F0C F7D9                    	NEG	CX			; number of bytes remaining in segment
 40505                                  	; MSDOS 6.0
 40506 00006F0E 09C9                    	OR	CX,CX			;AN000;MS. cx=0 ? ds:dx on segment boundary
 40507 00006F10 7501                    	JNZ	short okok		;AN000;MS. no
 40508                                  	;MOV	CX,-1			;AN000;MS.
 40509                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40510                                  	; 17/12/2022
 40511 00006F12 49                      	dec	cx  ; mov cx,-1
 40512                                  	;mov	cx,-1 ; 0FFFh
 40513                                  okok:					;AN000;
 40514 00006F13 31C0                    	XOR	AX,AX			;AN000;
 40515 00006F15 F2AE                    	REPNZ	SCASB			;AN000;
 40516                                  					;AN000;
 40517 00006F17 4F                      	DEC	DI			; point back to the null
 40518 00006F18 268A45FF                	MOV	AL,[ES:DI-1]		; Get char before the NUL
 40519 00006F1C E8F3DF                  	call	PATHCHRCMP		; Is it a path separator?
 40520 00006F1F 7403                    	JZ	short SETENDPTR		; Yes
 40521                                  STOREPTH:
 40522 00006F21 B05C                    	MOV	AL,'\'
 40523 00006F23 AA                      	STOSB				; Add a path separator (and INC DI)
 40524                                  SETENDPTR:
 40525                                  	;MOV	EndPtrL,DI		; pointer to the tail
 40526                                  	; 09/07/2024 (Retro DOS v4 BugFix - Erdogan Tan - Istanbul)
 40527                                  	; (Note: I find this Retro DOS v4 Kernel bug while searching the reason
 40528                                  	;  of the AutoCAD R12 running/startup problem. Now it is solved here.)
 40529                                  	;mov	[bp-4],dl ; (Retro DOS v4 !Bug!)
 40530 00006F24 897EFC                  	mov	[bp-4],di ; !Fix!
 40531                                  CreateLoop:
 40532 00006F27 16                      	push	ss			; let ReadTime see variables
 40533 00006F28 1F                      	pop	ds
 40534 00006F29 55                      	push	bp
 40535 00006F2A E8DD9B                  	call	READTIME		; go get time
 40536 00006F2D 5D                      	pop	bp
 40537                                  ;
 40538                                  ; Time is in CX:DX. Go drop it into the string.
 40539                                  ;
 40540                                  	;les	di,EndPtr		; point to the string
 40541 00006F2E C47EFC                  	les	di,[BP-4]
 40542 00006F31 89C8                    	mov	ax,cx
 40543 00006F33 E8A2FF                  	call	BinToAscii		; store upper word
 40544 00006F36 89D0                    	mov	ax,dx
 40545 00006F38 E89DFF                  	call	BinToAscii		; store lower word
 40546 00006F3B 30C0                    	xor	al,al
 40547 00006F3D AA                      	STOSB				; nul terminate
 40548                                  	;LDS	DX,FilPtr		; get name
 40549 00006F3E C556F8                  	lds	dx,[bp-8]
 40550                                  	;MOV	CX,Attr 		; get attr
 40551 00006F41 8B4EF6                  	mov	cx,[bp-10]
 40552 00006F44 55                      	push	bp
 40553 00006F45 E889FF                  	CALL	_$CreateNewFile		; try to create a new file
 40554 00006F48 5D                      	pop	bp
 40555 00006F49 7319                    	JNC	short CreateDone	; failed, go try again
 40556                                  
 40557                                  ; The operation failed and the error has been mapped in AX. Grab the extended
 40558                                  ; error and figure out what to do.
 40559                                  
 40560                                  	;; MSDOS 3.3			; M049 - start
 40561                                  ;;	mov	ax,[ss:EXTERR]				;smr;SS Override
 40562                                  ;;	cmp	al,error_file_exists
 40563                                  ;;	jz	short CreateLoop	; file existed => try with new name
 40564                                  ;;	cmp	al,error_access_denied
 40565                                  ;;	jz	short CreateLoop	; access denied (attr mismatch)
 40566                                  
 40567                                  	; MSDOS 6.0
 40568                                  	;cmp	al,50h
 40569 00006F4B 3C50                    	CMP	AL,error_file_exists	; Q: did file already exist
 40570 00006F4D 74D8                    	JZ	short CreateLoop	; Y: try again
 40571                                  	;cmp	al,5
 40572 00006F4F 3C05                    	CMP	AL,error_access_denied	; Q: was it access denied
 40573 00006F51 7510                    	JNZ	short SETTMPERR		; N: Error out
 40574                                  					; Y: Check to see if we got this due
 40575                                  					;    to the network drive. Note that
 40576                                  					;    the redir will set the exterr
 40577                                  					;    to error_cannot_make if this is 
 40578                                  					;    so. 
 40579 00006F53 36803E[2403]41          	CMP	byte [SS:EXTERR],error_net_access_denied ; M069
 40580                                  					; See if it's REALLY an att mismatch
 40581 00006F59 7408                    	je	short SETTMPERR		; no, network error, stop
 40582                                  ;M070
 40583                                  ; If the user failed on an I24, we do not want to try again
 40584                                  ;
 40585 00006F5B 36803E[2403]53          	cmp	byte [SS:EXTERR],error_FAIL_I24 ;User failed on I24? ;M070
 40586                                  	;je	short SETTMPERR		;yes, do not try again ;M070
 40587                                  
 40588                                  	;jmp	short CreateLoop	;attr mismatch, try again ;M070
 40589                                  	; 17/12/2022
 40590 00006F61 75C4                    	jne	short CreateLoop ; 10/06/2019 
 40591                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40592                                  	;jz	short SETTMPERR
 40593                                  	;jmp	short CreateLoop
 40594                                  
 40595                                  ;;	MOV	AL,error_access_denied	; Return this "extended" error
 40596                                  					; M049 - end
 40597                                  SETTMPERR:
 40598 00006F63 F9                      	STC
 40599                                  CreateDone:
 40600                                  	;Leave
 40601 00006F64 89EC                    	mov	sp,bp
 40602 00006F66 5D                      	pop	bp
 40603 00006F67 7203                    	JC	short CreateFail
 40604 00006F69 E9C596                  	jmp	SYS_RET_OK		; success!
 40605                                  CreateFail:
 40606 00006F6C E9CB96                  	jmp	SYS_RET_ERR
 40607                                  
 40608                                  ;   SetAttrib will set the search attribute (SAttrib) either to the normal
 40609                                  ;   (CH) or to the value in CL if the current system call is through
 40610                                  ;   serverdoscall.
 40611                                  ;
 40612                                  ;   Inputs:	fSharing == FALSE => set sattrib to CH
 40613                                  ;		fSharing == TRUE => set sattrib to CL
 40614                                  ;   Outputs:	none
 40615                                  ;   Registers changed:	CX
 40616                                  
 40617                                  SetAttrib:
 40618                                  	;test	byte [SS:FSHARING],-1		;smr;SS Override
 40619                                  	;jnz	short Set
 40620                                  	; 15/03/2024
 40621 00006F6F 36803E[7205]00          	cmp	byte [ss:FSHARING],0
 40622 00006F75 7502                    	jnz	short Set
 40623                                  
 40624 00006F77 88E9                    	mov	cl,ch
 40625                                  Set:
 40626 00006F79 36880E[6D05]            	mov	byte [ss:SATTRIB],cl		;smr;SS Override
 40627 00006F7E C3                      	retn
 40628                                  
 40629                                  ;----------------------------------------------------------------------------
 40630                                  	; 16/03/2024 - Retro DOS v4.2
 40631                                  ext_inval2:
 40632                                  	;mov	al,1
 40633 00006F7F B001                    	mov	al,error_invalid_function
 40634                                  eo_err:
 40635                                  	;jmp	SYS_RET_ERR
 40636 00006F81 EBE9                    	jmp	short CreateFail
 40637                                  
 40638                                  ; 14/07/2018 - Retro DOS v3.0
 40639                                  ; MSDOS 6.0
 40640                                  
 40641                                  ; 29/04/2019 - Retro DOS v4.0
 40642                                  
 40643                                  ;Break	<Extended_Open- Extended open the file>
 40644                                  ;----------------------------------------------------------------------------
 40645                                  ; Input: AL= 0 reserved  AH=6CH
 40646                                  ;	 BX= mode
 40647                                  ;	 CL= create attribute  CH=search attribute (from server)
 40648                                  ;	 DX= flag
 40649                                  ;	 DS:SI = file name
 40650                                  ;	 ES:DI = parm list
 40651                                  ;			   DD  SET EA list (-1) null
 40652                                  ;			   DW  n  parameters
 40653                                  ;			   DB  type (TTTTTTLL)
 40654                                  ;			   DW  IOMODE
 40655                                  ; Function: Extended Open
 40656                                  ; Output: carry clear
 40657                                  ;		     AX= handle
 40658                                  ;		     CX=1 file opened
 40659                                  ;			2 file created/opened
 40660                                  ;			3 file replaced/opened
 40661                                  ;	  carry set: AX has error code
 40662                                  ;----------------------------------------------------------------------------
 40663                                  
 40664                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40665                                  _$Extended_Open:			  ;AN000;
 40666                                  	;ASSUME	CS:DOSCODE,SS:DOSDATA	  ;AN000;
 40667 00006F83 368916[F405]            	MOV	[SS:EXTOPEN_FLAG],DX	  ;AN000;EO. save ext. open flag;smr;SS Override
 40668 00006F88 36C706[F705]0000        	MOV	word [SS:EXTOPEN_IO_MODE],0 ;AN000;EO. initialize IO mode;smr;SS Override
 40669                                  	; 17/12/2022
 40670 00006F8F F6C6FE                  	test	dh,0FEh ; 04/12/2022 
 40671                                  	;;test	dx,0FE00h
 40672                                  	;TEST	DX,RESERVED_BITS_MASK	  ;AN000;EO. reserved bits 0 ?
 40673 00006F92 75EB                    	JNZ	short ext_inval2	  ;AN000;EO. no
 40674 00006F94 88D4                    	MOV	AH,DL			  ;AN000;EO. make sure flag is right
 40675 00006F96 80FA00                  	CMP	DL,0			  ;AN000;EO. all fail ?
 40676 00006F99 74E4                    	JZ	short ext_inval2	  ;AN000;EO. yes, error
 40677                                  	;and	dl,0Fh
 40678 00006F9B 80E20F                  	AND	DL,EXISTS_MASK		  ;AN000;EO. get exists action byte
 40679 00006F9E 80FA02                  	CMP	DL,2			  ;AN000;EO, > 2
 40680 00006FA1 77DC                    	JA	short ext_inval2	  ;AN000;EO. yes, error
 40681                                  	;and	ah,0F0h
 40682 00006FA3 80E4F0                  	AND	AH,NOT_EXISTS_MASK	  ;AN000;EO. get no exists action byte
 40683 00006FA6 80FC10                  	CMP	AH,10H			  ;AN000;EO. > 10
 40684 00006FA9 77D4                    	JA	short ext_inval2	  ;AN000;EO. yes, error
 40685                                  
 40686 00006FAB 368C06[FB05]            	MOV	[SS:SAVE_ES],ES		  ;AN000;EO. save API parms;smr;SS Override
 40687 00006FB0 36893E[F905]            	MOV	[SS:SAVE_DI],DI		  ;AN000;EO.;smr;SS Override
 40688 00006FB5 36FF36[F405]            	PUSH	word [SS:EXTOPEN_FLAG]	  ;AN000;EO.;smr;SS Override
 40689 00006FBA 368F06[FD05]            	POP	word [SS:SAVE_DX]	  ;AN000;EO.;smr;SS Override
 40690 00006FBF 36890E[FF05]            	MOV	[SS:SAVE_CX],CX		  ;AN000;EO.;smr;SS Override
 40691 00006FC4 36891E[0106]            	MOV	[SS:SAVE_BX],BX		  ;AN000;EO.;smr;SS Override
 40692 00006FC9 368C1E[0506]            	MOV	[SS:SAVE_DS],DS		  ;AN000;EO.;smr;SS Override
 40693 00006FCE 368936[0306]            	MOV	[SS:SAVE_SI],SI		  ;AN000;EO.;smr;SS Override
 40694 00006FD3 89F2                    	MOV	DX,SI			  ;AN000;EO. ds:dx points to file name
 40695 00006FD5 89D8                    	MOV	AX,BX			  ;AN000;EO. ax= mode
 40696                                  ; 16/03/2024
 40697                                  %if 0
 40698                                  	JMP	SHORT goopen2		  ;AN000;;EO. do normal
 40699                                  ext_inval2:				  ;AN000;;EO.
 40700                                  	;mov	al,1
 40701                                  	mov	al,error_invalid_function ;AN000;EO.. invalid function
 40702                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40703                                  eo_err:
 40704                                  	;jmp	SYS_RET_ERR
 40705                                  	jmp	short CreateFail
 40706                                  %endif
 40707                                  
 40708                                  ; 16/03/2024
 40709                                  %if 0
 40710                                  ext_inval_parm:				  ;AN000;EO..
 40711                                  	POP	CX			  ;AN000;EO..  pop up satck
 40712                                  	POP	SI			  ;AN000;EO..
 40713                                  	;error	error_invalid_data	  ;AN000;EO..  invalid parms
 40714                                  	;mov	al,13
 40715                                  	mov	al,error_invalid_data
 40716                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40717                                  	;;jmp	SYS_RET_ERR
 40718                                  	;jmp	short eo_err
 40719                                  	; 17/12/2022
 40720                                  	jmp	short CreateFail
 40721                                  %endif
 40722                                  	; 17/12/2022	
 40723                                  ;error_return:				  ;AN000;EO.
 40724                                  ;	retn				  ;AN000;EO.. return with error
 40725                                  
 40726                                  goopen2:				  ;AN000;
 40727                                  	; 17/12/2022
 40728                                  	;test	bh,20h				 
 40729 00006FD7 F6C720                  	test	bh,INT_24_ERROR>>8 ; 04/12/2022
 40730                                  	;;test	bx,2000h
 40731                                  	;TEST	BX,INT_24_ERROR		  ;AN000;EO.. disable INT 24 error ?
 40732 00006FDA 7406                    	JZ	short goopen		  ;AN000;EO.. no
 40733                                  	;or	byte [SS:EXTOPEN_ON],2
 40734 00006FDC 36800E[F605]02          	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_I24_OFF ;AN000;EO.. set bit to disable;smr;SS Override
 40735                                  goopen:					  ;AN000;
 40736                                  	;or	byte [SS:EXTOPEN_ON],1 
 40737 00006FE2 36800E[F605]01          	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_ON  ;AN000;EO.. set Extended Open active;smr;SS Override
 40738                                  	;AND	word [SS:EXTOPEN_FLAG],0FFh  ;AN000;EO.create new ?;smr;SS Override
 40739                                  	; 18/12/2022
 40740 00006FE8 36C606[F505]00          	mov	byte [SS:EXTOPEN_FLAG+1],0 ; AND word [SS:EXTOPEN_FLAG],0FFh
 40741                                  	;cmp	word [SS:EXTOPEN_FLAG],10h
 40742 00006FEE 36833E[F405]10          	CMP	word [SS:EXTOPEN_FLAG],EXT_EXISTS_FAIL+EXT_NEXISTS_CREATE ;AN000;FT.;smr;SS Override
 40743 00006FF4 7516                    	JNZ	short chknext 		  ;AN000;;EO. no
 40744 00006FF6 E8D8FE                  	call	_$CreateNewFile		  ;AN000;;EO. yes
 40745 00006FF9 723F                    	JC	short error_return	  ;AN000;;EO. error
 40746                                  
 40747 00006FFB 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 40748 00007001 7438                    	JZ	short ok_return2	  ;AN000;;EO. yes
 40749                                  
 40750                                  	;mov	word [SS:EXTOPEN_FLAG],2
 40751 00007003 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED ;AN000;EO. created/opened;smr;SS Override
 40752 0000700A EB7F                    	JMP	short setXAttr ; 16/03/2024 ;AN000;;EO. set XAs
 40753                                  
 40754                                  	; 17/12/2022
 40755                                  ;ok_return2:
 40756                                  ;	jmp	SYS_RET_OK		  ;AN000;;EO.
 40757                                  
 40758                                  chknext:
 40759                                  	; 17/12/2022
 40760 0000700C 36F606[F405]01          	test	byte [SS:EXTOPEN_FLAG],EXT_EXISTS_OPEN ; 1
 40761                                  	;;test	word [SS:EXTOPEN_FLAG],1
 40762                                  	;TEST	word [SS:EXTOPEN_FLAG],EXT_EXISTS_OPEN ;AN000;;EO. exists open;smr;SS Override
 40763 00007012 752A                    	JNZ	short exist_open	  ;AN000;;EO. yes
 40764 00007014 E8D6FD                  	call	_$CREAT			  ;AN000;;EO. must be replace open
 40765 00007017 7221                    	JC	short error_return	  ;AN000;;EO. return with error
 40766 00007019 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 40767 0000701F 741A                    	JZ	short ok_return2	  ;AN000;;EO. yes
 40768 00007021 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED ;AN000;EO. prsume create/open;smr;SS Override
 40769 00007028 36F606[F605]04          	TEST	byte [SS:EXTOPEN_ON],EXT_FILE_NOT_EXISTS ;AN000;;EO. file not exists ?;smr;SS Override
 40770 0000702E 755B                    	JNZ	short setXAttr		  ;AN000;;EO. no
 40771 00007030 36C706[F405]0300        	MOV	word [SS:EXTOPEN_FLAG],ACTION_REPLACED_OPENED ;AN000;;EO. replaced/opened;smr;SS Override
 40772 00007037 EB52                    	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 40773                                  
 40774                                  error_return2:
 40775 00007039 F9                      	STC 				  ; Set Carry again to flag error ;AN001;
 40776                                  error_return:	 ; 17/12/2022
 40777 0000703A C3                      	retn				  ;AN000;;EO. return with error
 40778                                  
 40779                                  	; 17/12/2022
 40780                                  ok_return:
 40781                                  ok_return2:
 40782 0000703B E9F395                  	jmp	SYS_RET_OK
 40783                                  
 40784                                  exist_open:				  ;AN000;
 40785                                  	;test	byte [SS:FSHARING],-1	  ;AN000;;EO. server doscall?;smr;SS Override
 40786                                  	;jz	short noserver		  ;AN000;;EO. no
 40787                                  	; 16/03/2024
 40788                                  	;;;
 40789 0000703E 36803E[7205]00          	cmp	byte [ss:FSHARING],0	; server doscall?
 40790 00007044 7402                    	jz	short noserver		; no
 40791                                  	;;;
 40792 00007046 88E9                    	MOV	CL,CH			  ;AN000;;EO. cl=search attribute
 40793                                  noserver:
 40794 00007048 E8CDFC                  	call	_$Open2			  ;AN000;;EO. do open
 40795 0000704B 732F                    	JNC	short ext_ok		  ;AN000;;EO.
 40796 0000704D 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. error and IFS call;smr;SS Override
 40797 00007053 74E4                    	JZ	short error_return2	  ;AN000;;EO. return with error
 40798                                  local_extopen:
 40799                                  	;cmp	ax,2
 40800 00007055 83F802                  	CMP	AX,error_file_not_found   ;AN000;;EO. file not found error
 40801 00007058 75DF                    	JNZ	short error_return2	  ;AN000;;EO. no,
 40802                                  	;;test	word [SS:EXTOPEN_FLAG],10h
 40803                                  	; 17/12/2022
 40804 0000705A 36F606[F405]10          	test	byte [SS:EXTOPEN_FLAG],EXT_NEXISTS_CREATE ; 10h
 40805                                  	;TEST	word [SS:EXTOPEN_FLAG],EXT_NEXISTS_CREATE ;AN000;;EO. want to fail;smr;SS Override
 40806                                  	;JNZ	short do_creat		  ;AN000;;EO. yes
 40807                                  	;JMP	short extexit 		  ;AN000;;EO. yes
 40808                                  	; 17/12/2022
 40809 00007060 7446                    	jz	short extexit ; 10/06/2019
 40810                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40811                                  	;jnz	short do_creat
 40812                                  	;jmp	short extexit
 40813                                  do_creat:
 40814 00007062 368B0E[FF05]            	MOV	CX,[SS:SAVE_CX]		  ;AN000;;EO. get ds:dx for file name;smr;SS Override
 40815 00007067 36C536[0306]            	LDS	SI,[SS:SAVE_SI]		  ;AN000;;EO. cx = attribute;smr;SS Override
 40816 0000706C 89F2                    	MOV	DX,SI			  ;AN000;;EO.
 40817 0000706E E87CFD                  	call	_$CREAT			  ;AN000;;EO. do create
 40818 00007071 7235                    	JC	short extexit 		  ;AN000;;EO. error
 40819                                  	;mov	word [SS:EXTOPEN_FLAG],2
 40820 00007073 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED
 40821                                  					  ;AN000;;EO. is created/opened;smr;SS Override
 40822 0000707A EB0F                    	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 40823                                  
 40824                                  ext_ok:
 40825 0000707C 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS call ?;smr;SS Override
 40826 00007082 74B7                    	JZ	short ok_return		  ;AN000;;EO. yes
 40827                                  	;mov	word [SS:EXTOPEN_FLAG],1
 40828 00007084 36C706[F405]0100        	MOV	word [SS:EXTOPEN_FLAG],ACTION_OPENED ;AN000;;EO. opened;smr;SS Override
 40829                                  setXAttr:
 40830                                  	; 29/04/2019
 40831 0000708B 50                      	push	ax
 40832 0000708C E8F293                  	call	Get_User_Stack		  ;AN000;;EO.
 40833 0000708F 36A1[F405]              	MOV	AX,[SS:EXTOPEN_FLAG]	  ;AN000;;EO.;smr;SS Override
 40834                                  	;mov	[si+4],ax
 40835 00007093 894404                  	MOV	[SI+user_env.user_CX],AX  ;AN000;;EO. set action code for cx
 40836 00007096 58                      	pop	ax			  ;AN000;;EO.
 40837 00007097 8904                    	mov	[si],ax
 40838                                  	;MOV	[SI+user_env.user_AX],AX  ;AN000;;EO. set handle for ax
 40839                                  	; 17/12/2022
 40840 00007099 EBA0                    	jmp	short ok_return
 40841                                  ;ok_return:				  ;AN000;
 40842                                  	;jmp	SYS_RET_OK		  ;AN000;;EO.
 40843                                  
 40844                                  ; 16/03/2024
 40845                                  %if 0
 40846                                  extexit2:				  ;AN000; ERROR RECOVERY
 40847                                  	POP	BX			  ;AN000;EO. close the handle
 40848                                  	PUSH	AX			  ;AN000;EO. save error code from set XA
 40849                                  	;cmp	word [SS:EXTOPEN_FLAG],2
 40850                                  	CMP	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED
 40851                                  					  ;AN000;EO. from create;smr;SS Override
 40852                                  	JNZ	short justopen		  ;AN000;EO.
 40853                                  	LDS	SI,[SS:SAVE_SI]		  ;AN000;EO. cx = attribute;smr;SS Override
 40854                                  	LDS	DX,[SI]			  ;AN000;EO.
 40855                                  	call	_$UNLINK 		  ;AN000;EO. delete the file
 40856                                  	JMP	SHORT reserror		  ;AN000;EO.
 40857                                  
 40858                                  justopen:				  ;AN000;
 40859                                  	call	_$CLOSE			  ;AN000;EO. pretend never happend
 40860                                  reserror:				  ;AN000;
 40861                                  	POP	AX			  ;AN000;EO. restore error code from set XA
 40862                                  
 40863                                  	JMP	SHORT extexit		  ;AN000;EO.
 40864                                  
 40865                                  ext_file_unfound:			  ;AN000;
 40866                                  	;mov	ax,2
 40867                                  	MOV	AX,error_file_not_found   ;AN000;EO.
 40868                                  	JMP	SHORT extexit		  ;AN000;EO.
 40869                                  ext_inval:				  ;AN000;
 40870                                  	;mov	ax,1
 40871                                  	MOV	AX,error_invalid_function ;AN000;EO.
 40872                                  
 40873                                  lockoperr:	; 17/12/2022
 40874                                  extexit:
 40875                                  	jmp	SYS_RET_ERR		  ;AN000;EO.
 40876                                  
 40877                                  %endif
 40878                                  
 40879                                  ;============================================================================
 40880                                  ; LOCK.ASM, MSDOS 6.0, 1991
 40881                                  ;============================================================================
 40882                                  ; 14/07/2018 - Retro DOS v3.0
 40883                                  ; 22/05/2019 - Retro DOS v4.0
 40884                                  
 40885                                  ;BREAK <$LockOper - Lock Calls>
 40886                                  ;----------------------------------------------------------------------------
 40887                                  ;
 40888                                  ;   Assembler usage:
 40889                                  ;	    MOV     BX, Handle	       (DOS 3.3)
 40890                                  ;	    MOV     CX, OffsetHigh
 40891                                  ;	    MOV     DX, OffsetLow
 40892                                  ;	    MOV     SI, LengthHigh
 40893                                  ;	    MOV     DI, LengthLow
 40894                                  ;	    MOV     AH, LockOper
 40895                                  ;	    MOV     AL, Request
 40896                                  ;	    INT     21h
 40897                                  ;
 40898                                  ;   Error returns:
 40899                                  ;	    AX = error_invalid_handle
 40900                                  ;	       = error_invalid_function
 40901                                  ;	       = error_lock_violation
 40902                                  ;
 40903                                  ;   Assembler usage:
 40904                                  ;	    MOV     AX, 5C??	       (DOS 4.00)
 40905                                  ;
 40906                                  ;				    0? lock all
 40907                                  ;				    8? lock write
 40908                                  ;				    ?2 lock multiple
 40909                                  ;				    ?3 unlock multiple
 40910                                  ;				    ?4 lock/read
 40911                                  ;				    ?5 write/unlock
 40912                                  ;				    ?6 add (lseek EOF/lock/write/unlock)
 40913                                  ;	    MOV     BX, Handle
 40914                                  ;	    MOV     CX, count or size
 40915                                  ;	    LDS     DX, buffer
 40916                                  ;	    INT     21h
 40917                                  ;
 40918                                  ;   Error returns:
 40919                                  ;	    AX = error_invalid_handle
 40920                                  ;	       = error_invalid_function
 40921                                  ;	       = error_lock_violation
 40922                                  ;
 40923                                  ;----------------------------------------------------------------------------
 40924                                  
 40925                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40926                                  
 40927                                  	; 17/03/2024
 40928                                  	; 16/03/2024 - Retro DOS v4.2
 40929                                  _$LockOper:
 40930 0000709B 3C01                    	CMP	AL,1
 40931 0000709D 770C                    	JA	short lock_bad_func
 40932                                  
 40933 0000709F 57                      	PUSH	DI			       ; Save LengthLow
 40934 000070A0 E822F4                  	call	SFFromHandle		       ; ES:DI -> SFT
 40935 000070A3 731E                    	JNC	short lock_do 		       ; have valid handle
 40936 000070A5 5F                      	POP	DI			       ; Clean stack
 40937                                  	;mov	al,6
 40938 000070A6 B006                    	mov	al,error_invalid_handle
 40939                                  
 40940                                  	; 16/03/2024
 40941                                  extexit:
 40942                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40943                                  lockoperr:
 40944 000070A8 E98F95                  	jmp	SYS_RET_ERR
 40945                                  	; 17/12/2022
 40946                                  	;jmp	short lockoperr ; jmp SYS_RET_ERR
 40947                                  
 40948                                  lock_bad_func:
 40949                                  	;mov	byte [ss:EXTERR_LOCUS],1
 40950 000070AB 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus;smr;SS Override
 40951                                  	;mov	al,1
 40952 000070B1 B001                    	mov	al,error_invalid_function
 40953                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40954                                  lockoperrj:
 40955                                  	;jmp	SYS_RET_ERR
 40956 000070B3 EBF3                    	jmp	short lockoperr
 40957                                  
 40958                                  	; 22/05/2019 - Retro DOS v4.0
 40959                                  
 40960                                  	; MSDOS 6.0 
 40961                                  ; Align_buffer call has been deleted, since it corrupts the DTA (6/5/88) P5013
 40962                                  ; Dead code deleted, MD, 23 Mar 90
 40963                                  
 40964                                  ;lock_do:
 40965                                  ;	; MSDOS 3.3
 40966                                  ;	or	al,al
 40967                                  ;	pop	ax
 40968                                  ;	jz	short DOS_Lock
 40969                                  ;DOS_Unlock:
 40970                                  ;	;test	word [es:di+5],8000h
 40971                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 40972                                  ;	JZ	short LOCAL_UNLOCK
 40973                                  ;	push    ax
 40974                                  ;	mov     ax,110Bh
 40975                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 40976                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 40977                                  ;			; STACK: WORD low word of size, ES:DI -> SFT for file
 40978                                  ;			; SFT DPB field -> DPB of drive containing file
 40979                                  ;			; Return: CF set error
 40980                                  ;	pop     bx
 40981                                  ;	jmp     short ValChk
 40982                                  ;
 40983                                  ;LOCAL_UNLOCK:
 40984                                  ;	Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 40985                                  ;ValChk:
 40986                                  ;	JNC	short Lock_OK
 40987                                  ;lockerror:
 40988                                  ;	jmp	SYS_RET_ERR
 40989                                  ;Lock_OK:
 40990                                  ;	;MOV	AX,[SS:Temp_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 40991                                  ;	jmp	SYS_RET_OK
 40992                                  ;DOS_Lock:
 40993                                  ;	;test	word [es:di+5],8000h
 40994                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 40995                                  ;	JZ	short LOCAL_LOCK
 40996                                  ;	;CallInstall NET_XLock,MultNET,10
 40997                                  ;	mov     ax, 110Ah
 40998                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 40999                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 41000                                  ;			; STACK: WORD low word of size, ES:DI -> SFT
 41001                                  ;			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 41002                                  ;			; Return: CF set error
 41003                                  ;	JMP	short ValChk
 41004                                  ;
 41005                                  ;LOCAL_LOCK:
 41006                                  ;	Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 41007                                  ;	JMP	short ValChk
 41008                                  
 41009                                  ; 17/12/2022
 41010                                  LOCAL_UNLOCK:
 41011                                  	; MSDOS 3.3
 41012                                  	;Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 41013                                  	; MSDOS 6.0
 41014 000070B5 FF1E[AC00]              	Call	far [JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 41015                                  ValChk:
 41016 000070B9 7302                    	JNC	short Lock_OK
 41017                                  lockerror:
 41018                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41019                                  	;;jmp	SYS_RET_ERR
 41020                                  	;jmp	short lockoperrj
 41021                                  	; 17/12/2022
 41022 000070BB EBEB                    	jmp	short lockoperr	; jmp SYS_RET_ERR
 41023                                  Lock_OK:
 41024                                  	;MOV	AX,[SS:TEMP_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 41025                                  	; 10/06/2019
 41026 000070BD A1[0C06]                	mov	ax,[TEMP_VAR]
 41027 000070C0 E96E95                  	jmp	SYS_RET_OK
 41028                                  
 41029                                  	; 22/05/2019
 41030                                  lock_do:
 41031                                  	; MSDOS 6.0
 41032 000070C3 89C3                    	MOV	BX,AX				; save AX
 41033 000070C5 BD[A903]                	MOV	BP,Lock_Buffer			; get DOS LOCK buffer
 41034                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41035                                  	;;mov	[bp+0],dx
 41036                                  	;MOV	[BP+LockBuf.Lock_position],DX	; set low offset
 41037                                  	; 15/12/2022
 41038 000070C8 895600                  	mov	[bp],dx
 41039                                  	;mov	[bp+2],cx
 41040 000070CB 894E02                  	MOV	[BP+LockBuf.Lock_position+2],CX; set high offset
 41041                                  
 41042                                  	; 16/03/2024
 41043                                  	;POP	CX				; get low length
 41044                                  	;;mov	[bp+4],cx
 41045                                  	;MOV	[BP+LockBuf.Lock_length],CX	; set low length
 41046 000070CE 8F4604                  	pop	word [bp+LockBuf.Lock_length]
 41047                                  
 41048                                  	;mov	[bp+6],si
 41049 000070D1 897606                  	MOV	[BP+LockBuf.Lock_length+2],SI	; set high length
 41050 000070D4 B90100                  	MOV	CX,1				; one range
 41051                                  
 41052                                  ;	PUSH	CS				;
 41053                                  ;	POP	DS				; DS:DX points to
 41054                                  
 41055 000070D7 16                      	push	ss
 41056 000070D8 1F                      	pop	ds
 41057                                  
 41058 000070D9 89EA                    	MOV	DX,BP				; Lock_Buffer
 41059                                  	;test	al,1
 41060 000070DB A801                    	TEST	AL,UNLOCK_ALL			; function 1
 41061                                  	;JNZ	short DOS_Unlock		; yes
 41062                                  	;JMP	short DOS_Lock			; function 0
 41063                                  	; 17/12/2022
 41064                                  	; 10/06/2019
 41065 000070DD 740E                    	jz	short DOS_Lock
 41066                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41067                                  	;JNZ	short DOS_Unlock
 41068                                  	;JMP	short DOS_Lock
 41069                                  
 41070                                  DOS_Unlock:
 41071                                  	;;test	word [es:di+5],8000h
 41072                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 41073 000070DF 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 41074 000070E4 74CF                    	JZ	short LOCAL_UNLOCK
 41075                                  
 41076                                  ; 17/03/2024
 41077                                  ;lock_unlock: ; 22/05/2019
 41078                                  
 41079                                  	;CallInstall Net_Xlock,MultNET,10
 41080                                  ;	
 41081                                  ;	; MSDOS 3.3
 41082                                  ;	;mov     ax,110Bh
 41083                                  ;	;int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 41084                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 41085                                  ;			; STACK: WORD low word of size, ES:DI -> SFT for file
 41086                                  ;			; SFT DPB field -> DPB of drive containing file
 41087                                  ;			; Return: CF set error
 41088                                  
 41089                                  ; 17/03/2024 - Retro DOS v4.2
 41090                                  lock_unlock:
 41091                                  
 41092                                  	; MSDOS 6.0
 41093 000070E6 B80A11                  	mov     ax,110Ah
 41094 000070E9 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 41095                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 41096                                  			; STACK: WORD low word of size, ES:DI -> SFT
 41097                                  			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 41098                                  			; Return: CF set error
 41099                                  
 41100 000070EB EBCC                    	JMP	SHORT ValChk
 41101                                  
 41102                                  ; 17/12/2022
 41103                                  %if 0
 41104                                  LOCAL_UNLOCK:
 41105                                  	; MSDOS 3.3
 41106                                  	;Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 41107                                  	; MSDOS 6.0
 41108                                  	Call	far [JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 41109                                  ValChk:
 41110                                  	JNC	short Lock_OK
 41111                                  lockerror:
 41112                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41113                                  	;jmp	SYS_RET_ERR
 41114                                  	jmp	short lockoperrj
 41115                                  Lock_OK:
 41116                                  	;MOV	AX,[SS:TEMP_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 41117                                  	; 10/06/2019
 41118                                  	mov	ax,[TEMP_VAR]
 41119                                  	jmp	SYS_RET_OK
 41120                                  %endif
 41121                                  
 41122                                  DOS_Lock:
 41123                                  	;;test	word [es:di+5],8000h
 41124                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 41125 000070ED 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 41126                                  	;JZ	short LOCAL_LOCK
 41127                                  	; 17/03/2024
 41128 000070F2 75F2                    	jnz	short lock_unlock
 41129                                  
 41130                                  	;CallInstall NET_XLock,MultNET,10
 41131                                  
 41132 000070F4 B80A11                  	mov     ax,110Ah
 41133 000070F7 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 41134                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 41135                                  			; STACK: WORD low word of size, ES:DI -> SFT
 41136                                  			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 41137                                  			; Return: CF set error
 41138                                  
 41139 000070F9 EBBE                    	JMP	short ValChk
 41140                                  
 41141                                  LOCAL_LOCK:
 41142                                  	; MSDOS 3.3
 41143                                  	;Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 41144                                  	; MSDOS 6.0
 41145 000070FB FF1E[A800]              	Call	far [JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 41146                                  
 41147 000070FF EBB8                    	JMP	short ValChk
 41148                                  
 41149                                  ; 14/07/2018 - Retro DOS v3.0
 41150                                  ; LOCK_CHECK
 41151                                  ;MSDOS 6.0 (& MSDOS 3.3)
 41152                                  
 41153                                  ;----------------------------------------------------------------------------
 41154                                  ; Inputs:
 41155                                  ;	Outputs of SETUP
 41156                                  ;	[USER_ID] Set
 41157                                  ;	[PROC_ID] Set
 41158                                  ; Function:
 41159                                  ;	Check for lock violations on local I/O
 41160                                  ;	Retries are attempted with sleeps in between
 41161                                  ; Outputs:
 41162                                  ;    Carry clear
 41163                                  ;	Operation is OK
 41164                                  ;    Carry set
 41165                                  ;	A lock violation detected
 41166                                  ; Outputs of SETUP preserved
 41167                                  ;----------------------------------------------------------------------------
 41168                                  
 41169                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41170                                  	; 22/05/2019 - Retro DOS v4.0
 41171                                  LOCK_CHECK:
 41172 00007101 8B1E[1A00]              	MOV	BX,[RetryCount]	; Number retries
 41173                                  LockRetry:
 41174 00007105 53                      	push	bx		; save regs
 41175 00007106 50                      	push	ax ; MSDOS 6.0
 41176                                  
 41177                                  	;MSDOS 3.3
 41178                                  	;Call	far [ss:JShare+(8*4)]	; 8 = chk_block
 41179                                  	;MSDOS 6.0
 41180 00007107 FF1E[B000]              	Call	far [JShare+(8*4)]	; 8 = chk_block
 41181                                  
 41182 0000710B 58                      	pop	ax ; MSDOS 6.0
 41183 0000710C 5B                      	pop	bx		; restrore regs
 41184 0000710D 7307                    	jnc	short lc_ret_label ; There are no locks (retnc)
 41185                                  LockN:
 41186 0000710F E8D2A0                  	call	Idle		; wait a while
 41187 00007112 4B                      	DEC	BX		; remember a retry
 41188 00007113 75F0                    	JNZ	short LockRetry	; more retries left...
 41189 00007115 F9                      	STC
 41190                                  lc_ret_label:
 41191 00007116 C3                      	retn
 41192                                  
 41193                                  ; 14/07/2018 - Retro DOS v3.0
 41194                                  ; LOCK_VIOLATION
 41195                                  ;MSDOS 6.0 (& MSDOS 3.3)
 41196                                  
 41197                                  ;----------------------------------------------------------------------------
 41198                                  ; Inputs:
 41199                                  ;	[THISDPB] set
 41200                                  ;	[READOP] indicates whether error on read or write
 41201                                  ; Function:
 41202                                  ;	Handle Lock violation on compatibility (FCB) mode SFTs
 41203                                  ; Outputs:
 41204                                  ;	Carry set if user says FAIL, causes error_lock_violation
 41205                                  ;	Carry clear if user wants a retry
 41206                                  ;
 41207                                  ; DS, ES, DI, CX preserved, others destroyed
 41208                                  ;----------------------------------------------------------------------------
 41209                                  
 41210                                  LOCK_VIOLATION:
 41211 00007117 1E                      	PUSH	DS
 41212 00007118 06                      	PUSH	ES
 41213 00007119 57                      	PUSH	DI
 41214 0000711A 51                      	PUSH	CX
 41215                                  	;mov	ax,21h
 41216 0000711B B82100                  	MOV	AX,error_lock_violation
 41217                                  	;mov	byte [ALLOWED],18h
 41218 0000711E C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 41219 00007123 C42E[8A05]              	LES	BP,[THISDPB]
 41220 00007127 BF0100                  	MOV	DI,1		; Fake some registers
 41221 0000712A 89F9                    	MOV	CX,DI
 41222                                  	;mov	dx,[es:bp+11]
 41223 0000712C 268B560B                	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 41224 00007130 E844E0                  	call	HARDERR
 41225 00007133 59                      	POP	CX
 41226                                  share_v_@:	; 01/07/2024
 41227 00007134 5F                      	POP	DI
 41228 00007135 07                      	POP	ES
 41229 00007136 1F                      	POP	DS
 41230 00007137 3C01                    	CMP	AL,1
 41231 00007139 74DB                    	jz	short lc_ret_label ; 1 = retry, carry clear
 41232 0000713B F9                      	STC
 41233 0000713C C3                      	retn
 41234                                  
 41235                                  ; 14/07/2018 - Retro DOS v3.0
 41236                                  
 41237                                  ;----------------------------------------------------------------------------
 41238                                  
 41239                                  ;	do a retz to return error
 41240                                  
 41241                                  	; 22/05/2019 - Retro DOS v4.0
 41242                                  CheckShare:
 41243                                  	; MSDOS 3.3
 41244                                  	;cmp	byte [cs:fShare],0
 41245                                  	;retn
 41246                                  
 41247                                  	; MSDOS 6.0
 41248 0000713D 1E                      	push	ds			;smr;
 41249                                  	;getdseg <ds>			; ds -> dosdata
 41250 0000713E 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 41251 00007143 803E[0303]00            	cmp	byte [fShare],0
 41252 00007148 1F                      	pop	ds			;smr;
 41253 00007149 C3                      	retn
 41254                                  	
 41255                                  ;============================================================================
 41256                                  ; SHARE.ASM, MSDOS 6.0, 1991
 41257                                  ;============================================================================
 41258                                  ; 14/07/2018 - Retro DOS v3.0
 41259                                  ; 22/05/2019 - Retro DOS v4.0
 41260                                  
 41261                                  ; SHARE_CHECK
 41262                                  ;----------------------------------------------------------------------------
 41263                                  ; Inputs:
 41264                                  ;       [THISSFT] Points to filled in local file/device SFT for new
 41265                                  ;               instance of file sf_mode ALWAYS has mode (even on FCB SFTs)
 41266                                  ;       [WFP_START] has full path of name
 41267                                  ;       [USER_ID] Set
 41268                                  ;       [PROC_ID] Set
 41269                                  ; Function:
 41270                                  ;       Check for sharing violations on local file/device access
 41271                                  ; Outputs:
 41272                                  ;    Carry clear
 41273                                  ;       Sharing approved
 41274                                  ;    Carry set
 41275                                  ;       A sharing violation detected
 41276                                  ;           AX is error code
 41277                                  ; USES    ALL but DS
 41278                                  ;----------------------------------------------------------------------------
 41279                                  
 41280                                  	; 22/05/2019 - Retro DOS v4.0
 41281                                  SHARE_CHECK:
 41282                                  	; 26/07/2019
 41283 0000714A FF1E[9400]              	call	far [JShare+(1*4)] 	; 1 = MFT_Enter
 41284                                  shchk_retn:
 41285 0000714E C3                      	retn
 41286                                  
 41287                                  ; SHARE_VIOLATION
 41288                                  ;----------------------------------------------------------------------------
 41289                                  ; Inputs:
 41290                                  ;       [THISDPB] Set
 41291                                  ;       AX has error code
 41292                                  ; Function:
 41293                                  ;       Handle Sharing errors
 41294                                  ; Outputs:
 41295                                  ;       Carry set if user says FAIL, causes error_sharing_violation
 41296                                  ;       Carry clear if user wants a retry
 41297                                  ;
 41298                                  ; DS, ES, DI preserved, others destroyed
 41299                                  ;----------------------------------------------------------------------------
 41300                                  
 41301                                  SHARE_VIOLATION:
 41302 0000714F 1E                      	PUSH    DS
 41303 00007150 06                      	PUSH	ES
 41304 00007151 57                      	PUSH    DI
 41305 00007152 C606[7505]00            	MOV     byte [READOP],0		; All share errors are reading
 41306                                  	;mov	byte [ALLOWED],18h
 41307 00007157 C606[4B03]18            	MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 41308 0000715C C42E[8A05]              	LES     BP,[THISDPB]
 41309 00007160 BF0100                  	MOV     DI,1			; Fake some registers
 41310 00007163 89F9                    	MOV     CX,DI
 41311                                  	;mov	dx,[es:bp+17]
 41312 00007165 268B5611                	MOV     DX,[ES:BP+DPB.DIR_SECTOR]
 41313 00007169 E80BE0                  	call	HARDERR
 41314                                  ; 01/07/2024
 41315                                  %if 0
 41316                                  	POP	DI
 41317                                  	POP	ES
 41318                                  	POP	DS
 41319                                  	CMP	AL,1
 41320                                  	jz	short shchk_retn	; 1 = retry, carry clear
 41321                                  	STC
 41322                                  	retn
 41323                                  %else
 41324 0000716C EBC6                    	jmp	short share_v_@
 41325                                  %endif
 41326                                  ;----------------------------------------------------------------------------
 41327                                  ;   ShareEnd - terminate sharing info on a particular SFT/UID/PID. This does
 41328                                  ;       NOT perform a close, it merely asserts that the sharing information
 41329                                  ;       for the SFT/UID/PID may be safely released.
 41330                                  ;
 41331                                  ;   Inputs:     ES:DI points to an SFT
 41332                                  ;   Outputs:    None
 41333                                  ;   Registers modified: all except DS,ES,DI
 41334                                  ;----------------------------------------------------------------------------
 41335                                  
 41336                                  ShareEnd:
 41337                                  	; 26/07/2019
 41338 0000716E FF1E[9800]              	call	far [JShare+(2*4)]	; 2 = MFTClose
 41339 00007172 C3                      	retn
 41340                                  
 41341                                  ;Break <ShareEnter - attempt to enter a node into the sharing set>
 41342                                  ;----------------------------------------------------------------------------
 41343                                  ;   ShareEnter - perform a retried entry of a nodde into the sharing set. If
 41344                                  ;   the max number of retries is exceeded, we notify the user via int 24.
 41345                                  ;
 41346                                  ;   Inputs:     ThisSFT points to the SFT
 41347                                  ;               WFP_Start points to the WFP
 41348                                  ;   Outputs:    Carry clear => successful entry
 41349                                  ;               Carry set => failed system call
 41350                                  ;   Registers modified: all
 41351                                  ;----------------------------------------------------------------------------
 41352                                  
 41353                                  ShareEnter:
 41354 00007173 51                      	push	cx
 41355                                  retry:
 41356 00007174 8B0E[1A00]              	mov     cx,[RetryCount]
 41357                                  attempt:
 41358 00007178 C43E[9E05]              	les     di,[THISSFT]		; grab sft
 41359 0000717C 31C0                    	XOR     AX,AX
 41360                                   	;mov	[es:di+51],ax
 41361 0000717E 26894533                	MOV     [ES:DI+SF_ENTRY.sf_MFT],AX ; indicate free SFT
 41362 00007182 51                      	push	cx
 41363 00007183 E8C4FF                  	call    SHARE_CHECK             ; attempt to enter into the sharing set
 41364 00007186 59                      	pop	cx
 41365 00007187 730A                    	jnc	short done		; success, let the user see this
 41366 00007189 E858A0                  	call	Idle                    ; wait a while
 41367 0000718C E2EA                    	loop    attempt                 ; go back for another attempt
 41368 0000718E E8BEFF                  	call    SHARE_VIOLATION         ; signal the problem to the user
 41369 00007191 73E1                    	jnc	short retry		; user said to retry, go do it
 41370                                  done:
 41371 00007193 59                      	pop	cx
 41372 00007194 C3                      	retn
 41373                                  
 41374                                  ;============================================================================
 41375                                  ; EXEPATCH.ASM (MSDOS 6.0, 1991)
 41376                                  ;============================================================================
 41377                                  ; 29/04/2019 - Retro DOS 4.0
 41378                                  
 41379                                  ;** EXEPATCH.ASM 
 41380                                  ;----------------------------------------------------------------------------
 41381                                  ;	Contains the foll:
 41382                                  ;
 41383                                  ;		- code to find and overlay buggy unpack code
 41384                                  ;		- new code to be overlayed on buggy unpack code 
 41385                                  ;		- old code sequence to identify buggy unpack code
 41386                                  ;
 41387                                  ;	Revision history:
 41388                                  ;
 41389                                  ;		Created: 5/14/90
 41390                                  ;----------------------------------------------------------------------------
 41391                                  
 41392                                  ;----------------------------------------------------------------------------
 41393                                  ;
 41394                                  ; M020 : Fix for rational bug - for details see routine header
 41395                                  ; M028 : 4b04 implementation
 41396                                  ; M030 : Fixing bug in EXEPACKPATCH (EXEC_CS is an un-relocated value)
 41397                                  ; M032 : set turnoff bit only if DOS in HMA.
 41398                                  ; M033 : if IP < 2 then not exepacked.
 41399                                  ; M046 : support for a 4th version of exepacked files.
 41400                                  ; M068 : support for copy protected apps.
 41401                                  ; M071 : use A20OFF_COUNT of 10.
 41402                                  ;
 41403                                  ;----------------------------------------------------------------------------
 41404                                  
 41405                                  PATCH1_COM_OFFSET	EQU	06CH
 41406                                  PATCH1_OFFSET		EQU	028H
 41407                                  PATCH1_CHKSUM		EQU	0EF4EH
 41408                                  CHKSUM1_LEN		EQU	11CH/2 ; 142
 41409                                  
 41410                                  PATCH2_COM_OFFSET	EQU	076H
 41411                                  PATCH2_OFFSET		EQU	032H
 41412                                  
 41413                                  	; The strings that start at offset 076h have two possible 
 41414                                  	; check sums that are defined as PATCH2_CHKSUM PATCH2A_CHKSUM
 41415                                  
 41416                                  PATCH2_CHKSUM		EQU	78B2H
 41417                                  CHKSUM2_LEN		EQU	119H/2
 41418                                  PATCH2A_CHKSUM		EQU	1C47H		; M046
 41419                                  CHKSUM2A_LEN		EQU	103H/2		; M046
 41420                                  
 41421                                  PATCH3_COM_OFFSET	EQU	074H
 41422                                  PATCH3_OFFSET		EQU	032H
 41423                                  PATCH3_CHKSUM		EQU	4EDEH
 41424                                  CHKSUM3_LEN		EQU	117H/2
 41425                                  
 41426                                  ;**	Data structure passed for ExecReady call
 41427                                  ;
 41428                                  ;struc ERStruc
 41429                                  ; .ER_Reserved:	resw	1	; reserved, should be zero
 41430                                  ; .ER_Flags:	resw	1
 41431                                  ; .ER_ProgName:	resd	1	; ptr to ASCIIZ str of prog name
 41432                                  ; .ER_PSP:	resw	1	; PSP of the program
 41433                                  ; .ER_StartAddr: resd	1	; Start CS:IP of the program
 41434                                  ; .ER_ProgSize:	resd	1	; Program size including PSP
 41435                                  ; .size:
 41436                                  ;endstruc
 41437                                  
 41438                                  ;DOSCODE SEGMENT
 41439                                  
 41440                                  	; 22/05/2019 - Retro DOS v4.0
 41441                                  	; DOSCODE:B3DDh (MSDOS 6.21, MSDOS.SYS)
 41442                                  
 41443                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41444                                  	; DOSCODE:B37Ah (MSDOS 5.0, MSDOS.SYS)
 41445                                  
 41446                                  ; M028 - BEGIN
 41447                                  
 41448                                  ;--------------------------------------------------------------------------
 41449                                  ;
 41450                                  ;	Procedure Name		: ExecReady
 41451                                  ;
 41452                                  ;	Input			: DS:DX -> ERStruc (see exe.inc)
 41453                                  ;
 41454                                  ;--------------------------------------------------------------------------
 41455                                  
 41456                                  ExecReady:
 41457 00007195 89D6                    	mov	si,dx			; move the pointer into a friendly one
 41458                                  	;;test	word [si+2],1
 41459                                  	; 17/12/2022
 41460 00007197 F6440201                	test	byte [si+ERStruc.ER_Flags],ER_EXE ; 1
 41461                                  	;test	word [si+ERStruc.ER_Flags],ER_EXE ; COM or EXE ?
 41462 0000719B 7413                    	jz	short er_setver		; only setver for .COM files
 41463                                  
 41464                                  	;mov	ax,[si+8]
 41465 0000719D 8B4408                  	mov	ax,[si+ERStruc.ER_PSP]
 41466 000071A0 83C010                  	add	ax,10h
 41467 000071A3 8EC0                    	mov	es,ax
 41468                                  
 41469                                  	;mov	cx,[si+10]
 41470 000071A5 8B4C0A                  	mov	cx,[si+ERStruc.ER_StartAddr]   ; M030
 41471                                  	;mov	ax,[si+12]	; 11/04/2024
 41472 000071A8 8B440C                  	mov	ax,[si+ERStruc.ER_StartAddr+2] ; M030
 41473                                  
 41474                                  	;call	[ss:FixExePatch]
 41475 000071AB 36FF16[1212]            	call	word [ss:FixExePatch] ; 28/12/2022
 41476                                  	
 41477                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41478                                  	;call	[ss:Rational386PatchPtr]
 41479                                  
 41480                                  er_setver:
 41481                                  	;;test	word [si+2],2		; Q: is this an overlay
 41482                                  	; 17/12/2022
 41483 000071B0 F6440202                	test	byte [si+ERStruc.ER_Flags],ER_OVERLAY ; 2
 41484                                  	;test	word [si+ERStruc.ER_Flags],ER_OVERLAY
 41485 000071B4 7518                    	jnz	short er_chkdoshi	; Y: set A20OFF_COUNT if DOS high
 41486                                  					; N: set up lie version first
 41487 000071B6 1E                      	push	ds
 41488 000071B7 56                      	push	si
 41489                                  	;lds	si,[si+4]
 41490 000071B8 C57404                  	lds	si,[si+ERStruc.ER_ProgName]
 41491 000071BB E8DDED                  	call	Scan_Execname1
 41492 000071BE E8EEED                  	call	Scan_Special_Entries
 41493 000071C1 5E                      	pop	si
 41494 000071C2 1F                      	pop	ds
 41495                                  	;mov	es,[si+8]
 41496 000071C3 8E4408                  	mov	es,[si+ERStruc.ER_PSP]
 41497 000071C6 36A1[BD0E]              	mov	ax,[ss:SPECIAL_VERSION]
 41498 000071CA 26A34000                	mov	[es:PDB.Version],ax
 41499                                  
 41500                                  er_chkdoshi:
 41501 000071CE 36803E[1112]00          	cmp	byte [ss:DosHasHMA],0	; M032: Q: is dos in HMA (M021)
 41502 000071D4 741F                    	je	short er_done		; M032: N: done
 41503                                  
 41504                                  					; M068 - Start
 41505                                  	;mov	ax,[si+8]
 41506 000071D6 8B4408                  	mov	ax,[si+ERStruc.ER_PSP]	; ax = PSP
 41507                                  
 41508                                  	;or	byte [ss:DOS_FLAG],4
 41509 000071D9 36800E[8600]04          	or	byte [ss:DOS_FLAG],EXECA20OFF ; Set bit to signal int 21
 41510                                  					; ah = 25 & ah= 49. See dossym.inc 
 41511                                  					; under TAG M003 & M009 for 
 41512                                  					; explanation
 41513                                  	;;test	word [si+2],1
 41514                                  	; 17/12/2022
 41515 000071DF F6440201                	test	byte [si+ERStruc.ER_Flags],ER_EXE ; 1
 41516                                  	;test	word [si+ERStruc.ER_Flags],ER_EXE ; Q: COM file
 41517 000071E3 7507                    	jnz	short er_setA20		; N: inc a20off_count, set 
 41518                                  					;    a20off_psp and ret
 41519 000071E5 1E                         	push	ds
 41520 000071E6 8ED8                    	mov	ds,ax			; DS = load segment of com file.
 41521 000071E8 E87D02                  	call	IsCopyProt		; check if copy protected
 41522 000071EB 1F                      	pop	ds
 41523                                  
 41524                                  er_setA20:
 41525                                  	; We need to inc the A20OFF_COUNT here. Note that if the count
 41526                                  	; is non-zero at this point it indicates that the A20 is to be 
 41527                                  	; turned off for that many int 21 calls made by the app. In 
 41528                                  	; addition the A20 has to be turned off when we exit from this 
 41529                                  	; call. Hence the inc.
 41530                                  
 41531 000071EC 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]		
 41532 000071F1 36A3[6300]              	mov	[ss:A20OFF_PSP],ax	; set the PSP for which A20 is to be
 41533                                  					; turned OFF.
 41534                                  er_done:				; M068 - End
 41535 000071F5 31C0                    	xor	ax,ax
 41536 000071F7 C3                      	retn
 41537                                  
 41538                                  ; M028 - END
 41539                                  
 41540                                  ; 23/03/2024
 41541                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41542                                  %if 0
 41543                                  
 41544                                  ;----------------------------------------------------------------------------
 41545                                  ;
 41546                                  ; procedure : Rational386Patch
 41547                                  ;
 41548                                  ; Older versions of the Rational DOS Extender have several bugs which trash
 41549                                  ; 386 registers (usually just the high word of 32 bit registers) during
 41550                                  ; interrupt processing. Lotus 123 3.1+ is a popular application that uses a
 41551                                  ; version of the Rational extender with the 32 bit register trashing bugs.
 41552                                  ;
 41553                                  ; This routine applies patches to the Rational DOS Extender to work around
 41554                                  ; most of the register trashing bugs.
 41555                                  ;
 41556                                  ; Note that there are additional register trashing bugs not fixed by these
 41557                                  ; patches. In particular, the high word of ESP and the FS and GS registers
 41558                                  ; may be modified on interrupts.
 41559                                  ;
 41560                                  ; There are two different Rational DOS Extender patchs in this module.
 41561                                  ; Rational386Patch is to correct 386 register trashing bugs on 386 or later
 41562                                  ; processors. This patch code is executed when MS-DOS is running on a 386
 41563                                  ; or later processor, regardless of whether MS-DOS is running in the HMA
 41564                                  ; or not.
 41565                                  ;
 41566                                  ; The other Rational patch routine (RationalPatch, below) fixes a register
 41567                                  ; trashing problem on 286 processors, and is only executed if MS-DOS is
 41568                                  ; running in the HMA.
 41569                                  ;
 41570                                  ; This patch detection and replacement is based on an example supplied by
 41571                                  ; Ben Williams at Rational.
 41572                                  ;
 41573                                  ;----------------------------------------------------------------------------
 41574                                  
 41575                                  ; 22/05/2019 - Retro DOS v4.0
 41576                                  ; DOSCODE:B448h (MSDOS 6.21, MSDOS.SYS)
 41577                                  
 41578                                  ;----------------------------------------------------------------------------
 41579                                  ;
 41580                                  ; INPUT : ES = segment where program got loaded
 41581                                  ;
 41582                                  ;----------------------------------------------------------------------------
 41583                                  
 41584                                  rpFind1:
 41585                                  	db	0FAh, 0E4h, 21h, 60h, 33h, 0C0h, 0E6h, 43h, 8Bh, 16h
 41586                                  
 41587                                  rpFind1Len equ	$ - rpFind1
 41588                                  
 41589                                  ;	cli
 41590                                  ;	in	al, 21h
 41591                                  ;	pusha
 41592                                  ;	xor	ax, ax
 41593                                  ;	out	43h, al
 41594                                  ;	mov	dx, ...
 41595                                  
 41596                                  rpFind1a:
 41597                                  	db	0B0h, 0Eh, 0E6h, 37h, 33h, 0C0h, 0E6h, 0F2h
 41598                                  
 41599                                  rpFind1aLen equ	$ - rpFind1a
 41600                                  
 41601                                  ;	mov	al, 0Eh
 41602                                  ;	out	37h, al
 41603                                  ;	xor	ax, ax
 41604                                  ;	out	0F2h, al
 41605                                  
 41606                                  ; bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI
 41607                                  
 41608                                  rpFind2:
 41609                                  	db	0Fh, 20h, 0C0h
 41610                                  
 41611                                  rpFind2Len equ	$ - rpFind2
 41612                                  
 41613                                  ;	mov	eax, cr0	;may be preceeded by PUSH CX (51h)
 41614                                  
 41615                                  rpFind3:
 41616                                  	db	0Fh, 22h, 0C0h, 0EAh
 41617                                  
 41618                                  rpFind3Len equ	$ - rpFind3
 41619                                  
 41620                                  ;	mov	cr0, eax	;may be preceeded by POP CX (59h)
 41621                                  ;	jmp	far ptr xxx	;change far ptr to go to replace3
 41622                                  ;	mov	ss, bx		;8E D3 ... and come back at or after this
 41623                                  
 41624                                  ; note, there is no rpRepl1 string
 41625                                  
 41626                                  rpRepl2:
 41627                                   	db	66h, 50h, 51h, 0Fh, 20h, 0C0h
 41628                                  
 41629                                  rpRepl2Len equ	$ - rpRepl2
 41630                                  
 41631                                  ;	push	eax
 41632                                  ;	push	cx
 41633                                  ;	mov	eax, cr0
 41634                                  
 41635                                  rpRepl3:
 41636                                  	db	8Eh, 0D3h, 59h, 66h, 58h
 41637                                  
 41638                                  rpRepl3Len equ	$ - rpRepl3
 41639                                  
 41640                                  ;	mov	ss, bx
 41641                                  ;	pop	cx
 41642                                  ;	pop	eax
 41643                                  
 41644                                  ; bug # 2 -- loss of high EAX and ESI on 386+ only if VCPI
 41645                                  
 41646                                  rpFind4:
 41647                                  	db	93h, 58h, 8Bh, 0CCh
 41648                                  
 41649                                  rpFind4Len equ	$ - rpFind4
 41650                                  
 41651                                  ;	xchg	bx, ax
 41652                                  ;	pop	ax
 41653                                  ;	mov	cx, sp
 41654                                  
 41655                                  rpFind5:
 41656                                  	db	0B8h, 0Ch, 0DEh, 0CDh, 67h, 8Bh, 0E1h, 0FFh, 0E3h
 41657                                  
 41658                                  rpFind5Len equ	$ - rpFind5
 41659                                  
 41660                                  ;	mov	ax, DE0Ch
 41661                                  ;	int	67h
 41662                                  ;	mov	sp, cx
 41663                                  ;	jmp	bx
 41664                                  
 41665                                  rpRepl4:
 41666                                  	db	93h, 58h, 8Bh, 0CCh
 41667                                  	db	02Eh, 066h, 0A3h
 41668                                  
 41669                                  rpRepl4o1Len equ $ - rpRepl4
 41670                                  
 41671                                  	db	00h, 00h
 41672                                  	db	02Eh, 066h, 89h, 36h
 41673                                  
 41674                                  rpRepl4o2Len equ $ - rpRepl4
 41675                                  
 41676                                  	db	00h, 00h
 41677                                  
 41678                                  rpRepl4Len equ	$ - rpRepl4
 41679                                  
 41680                                  ;	xchg	bx, ax
 41681                                  ;	pop	ax
 41682                                  ;	mov	cx, sp
 41683                                  ;	mov	dword ptr cs:[xxxx], eax
 41684                                  ;	mov	dword ptr cs:[xxxx], esi
 41685                                  
 41686                                  rpRepl5:
 41687                                  	db	8Bh, 0E1h
 41688                                  	db	2Eh, 66h, 0A1h
 41689                                  
 41690                                  rpRepl5o1Len equ $ - rpRepl5
 41691                                  
 41692                                  	db	00h, 00h
 41693                                  	db	2Eh, 66h, 8Bh, 36h
 41694                                  
 41695                                  rpRepl5o2Len equ $ - rpRepl5
 41696                                  
 41697                                  	db	00h, 00h
 41698                                  	db	0FFh, 0E3h
 41699                                  
 41700                                  rpRepl5Len equ	$ - rpRepl5
 41701                                  
 41702                                  ;	mov	sp, cx
 41703                                  ;	mov	eax, dword ptr cs:[xxxx]
 41704                                  ;	mov	esi, dword ptr cs:[xxxx]
 41705                                  ;	jmp	bx
 41706                                  
 41707                                  ; bug # 3 -- loss of high EAX, EBX, ECX, EDX on 386+ only if VCPI
 41708                                  
 41709                                  rpFind6:
 41710                                  	db	0FAh, 52h, 51h
 41711                                  
 41712                                  rpFind6Len equ	$ - rpFind6
 41713                                  
 41714                                  ;	cli
 41715                                  ;	push	dx
 41716                                  ;	push	cx
 41717                                  
 41718                                  rpFind7a:
 41719                                  	db	0B8h, 0Ch, 0DEh, 66h, 26h, 0FFh, 1Eh
 41720                                  
 41721                                  rpFind7aLen equ	$ - rpFind7a
 41722                                  
 41723                                  ;	mov	ax, 0DE0Ch
 41724                                  ;	call	fword ptr es:[xxxx]
 41725                                  
 41726                                  rpFind7b:
 41727                                  	db	59h, 5Ah, 5Bh
 41728                                  
 41729                                  rpFind7bLen equ	$ - rpFind7b
 41730                                  
 41731                                  ;	pop	cx
 41732                                  ;	pop	dx
 41733                                  ;	pop	bx
 41734                                  
 41735                                  rpRepl6:
 41736                                  	db	0FAh, 66h, 50h, 66h, 53h, 66h, 51h, 66h, 52h
 41737                                  
 41738                                  rpRepl6Len equ	$ - rpRepl6
 41739                                  
 41740                                  ;	cli
 41741                                  ;	push	eax
 41742                                  ;	push	ebx
 41743                                  ;	push	ecx
 41744                                  ;	push	edx
 41745                                  
 41746                                  rpRepl7:
 41747                                  	db	66h, 5Ah, 66h, 59h, 66h, 5Bh, 66h, 58h, 5Bh
 41748                                  
 41749                                  rpRepl7Len equ	$ - rpRepl7
 41750                                  
 41751                                  ;	pop	edx
 41752                                  ;	pop	ecx
 41753                                  ;	pop	ebx
 41754                                  ;	pop	eax
 41755                                  ;	pop	bx
 41756                                  
 41757                                  ; bug # 4 -- loss of high EAX and EBX on 386+ only if VCPI
 41758                                  
 41759                                  rpFind8:
 41760                                   	db	60h, 06h, 1Eh, 0B8h, 00h, 00h, 8Eh, 0D8h
 41761                                  
 41762                                  rpFind8Len equ	$ - rpFind8
 41763                                  
 41764                                  ;	pusha
 41765                                  ;	push	es
 41766                                  ;	push	ds
 41767                                  ;	mov	ax, dgroup	;jump back to here from replace8
 41768                                  ;	mov	ds, ax
 41769                                  
 41770                                  rpFind9 :
 41771                                  	db	1Fh, 07h, 61h
 41772                                  
 41773                                  rpFind9Len equ	$ - rpFind9
 41774                                  
 41775                                  ;	pop	ds
 41776                                  ;	pop	es
 41777                                  ;	popa
 41778                                  
 41779                                  rpRepl8:
 41780                                   	db	66h, 60h, 06h, 1Eh
 41781                                  
 41782                                  rpRepl8Len equ	$ - rpRepl8
 41783                                  
 41784                                  ;	pushad
 41785                                  ;	push	es
 41786                                  ;	push	ds
 41787                                  
 41788                                  rpRepl9:
 41789                                  	db	1Fh, 07h, 66h, 61h, 0C3h
 41790                                  
 41791                                  rpRepl9Len equ	$ - rpRepl9
 41792                                  
 41793                                  ;	pop	ds
 41794                                  ;	pop	es
 41795                                  ;	popad
 41796                                  ;	retn			;no need to jmp back to main-line
 41797                                  
 41798                                  ;----------------------------------------------------------------------------
 41799                                  
 41800                                  struc SearchPair
 41801                                   .sp_off1: resw 1	; offset of 1st search string
 41802                                   .sp_len1: resw 1	; length of 1st search string
 41803                                   .sp_off2: resw 1	; 2nd string
 41804                                   .sp_len2: resw 1	; 2nd string
 41805                                   .sp_diff: resw 1	; max difference between offsets
 41806                                   .size:
 41807                                  endstruc
 41808                                  
 41809                                  ;rpBug1Strs SearchPair	<offset rpFind2, rpFind2Len, offset rpFind3, rpFind3Len, 20h>
 41810                                  
 41811                                  rpBug1Strs:
 41812                                  	dw	rpFind2
 41813                                  	dw	rpFind2Len ; 3
 41814                                  	dw	rpFind3
 41815                                  	dw	rpFind3Len ; 4
 41816                                  	dw	20h
 41817                                  
 41818                                  ;rpBug2Strs SearchPair	<offset rpFind4, rpFind4Len, offset rpFind5, rpFind5Len, 80h>
 41819                                  
 41820                                  rpBug2Strs:
 41821                                  	dw	rpFind4
 41822                                  	dw	rpFind4Len ; 4
 41823                                  	dw	rpFind5
 41824                                  	dw	rpFind5Len ; 9
 41825                                  	dw	80h
 41826                                  
 41827                                  ;rpBug3Strs SearchPair	<offset rpFind6, rpFind6Len, offset rpFind7a, rpFind7aLen, 80h>
 41828                                  
 41829                                  rpBug3Strs:
 41830                                  	dw	rpFind6
 41831                                  	dw	rpFind6Len ; 3
 41832                                  	dw	rpFind7a
 41833                                  	dw	rpFind7aLen ; 7
 41834                                  	dw	80h
 41835                                  
 41836                                  ;rpBug4Strs SearchPair	<offset rpFind8, 4, offset rpFind9, rpFind9Len, 80h>
 41837                                  
 41838                                  rpBug4Strs:
 41839                                  	dw	rpFind8
 41840                                  	dw	4
 41841                                  	dw	rpFind9
 41842                                  	dw	rpFind9Len ; 3
 41843                                  	dw	80h
 41844                                  
 41845                                  ;----------------------------------------------------------------------------
 41846                                  
 41847                                  struc StackVars
 41848                                   .sv_wVersion:	resw 1		; Rational extender version #
 41849                                   .sv_cbCodeSeg: resw 1		; code seg size to scan
 41850                                   .sv_pPatch:	resw 1		; offset of next avail patch byte
 41851                                   .size:
 41852                                  endstruc
 41853                                  
 41854                                  ;----------------------------------------------------------------------------
 41855                                  
 41856                                  ; 22/05/2019 - Retro DOS v4.0
 41857                                  
 41858                                  Rational386Patch:
 41859                                  	; Do a few quick checks to see if this looks like a Rational
 41860                                  	; Extended application. Hopefully this will quickly weed out
 41861                                  	; most non Rational apps.
 41862                                  
 41863                                  	cmp	word [es:0],395		; version number goes here - versions
 41864                                  	jae	short rp3QuickOut	;   3.95+ don't need patching
 41865                                  
 41866                                  	cmp	word [es:0Ch],20h	; always has this value here
 41867                                  	jne	short rp3QuickOut
 41868                                  
 41869                                  	push	ax
 41870                                  
 41871                                  	mov	ax,18h 			; extender has 18h at
 41872                                  	cmp	[es:24],ax		;   offsets 24, 28, & 36
 41873                                  	jne	short rp3QO_ax
 41874                                  	cmp	[es:28],ax
 41875                                  	jne	short rp3QO_ax
 41876                                  	cmp	[es:36],ax
 41877                                  	je	short rp3Maybe
 41878                                  rp3QO_ax:
 41879                                  	pop	ax
 41880                                  rp3QuickOut:
 41881                                  	retn
 41882                                  
 41883                                  ; It might be the rational extender, do more extensive checking
 41884                                  
 41885                                  rp3Maybe:
 41886                                  	cld
 41887                                  	push	bx			; note ax pushed above
 41888                                  	push	cx
 41889                                  	push	dx
 41890                                  	push	si
 41891                                  	push	di
 41892                                  	push	es
 41893                                  	push	ds			; we use all of them
 41894                                  	push	bp
 41895                                  	sub	sp,StackVars.size  ; 6	; make space for stack variables
 41896                                  	mov	bp,sp
 41897                                  
 41898                                  	push	cs
 41899                                  	pop	ds
 41900                                  
 41901                                  	mov	ax,[es:0]		; save version #
 41902                                  	;mov	[bp+StackVars.sv_wVersion],ax
 41903                                  	mov	[bp],ax	
 41904                                  					; check that binary version # matches
 41905                                  	call	VerifyVersion		;   ascii string
 41906                                  	jne	short rp3Exit_j
 41907                                  
 41908                                  ; Looks like this is it, find where to put the patch code.  The
 41909                                  ; patch will be located on top of Rational code specific to 80286
 41910                                  ; processors, so these patchs MUST NOT be applied if running on
 41911                                  ; an 80286 system.
 41912                                  
 41913                                  	; Rational says the code to patch will never be beyond offset 46xxh
 41914                                  
 41915                                  	mov	cx,4500h		; force search len to 4700h (searches
 41916                                  	;mov	[bp+2],cx
 41917                                  	mov	[bp+StackVars.sv_cbCodeSeg],cx	; start at offset 200h)
 41918                                  
 41919                                  	mov	es,[es:20h]		; es=code segment
 41920                                  
 41921                                  	mov	si,rpFind1		; string to find
 41922                                  	mov	dx,rpFind1Len ; 10	; length to match
 41923                                  	call	ScanCodeSeq		; look for code seq
 41924                                  	jz	short rpGotPatch
 41925                                  
 41926                                  ; According to Rational, some very old versions of the extender may not
 41927                                  ; have the find1 code sequence. If the find1 code wasn't found above,
 41928                                  ; try an alternative patch area which is on top of NEC 98xx switching code.
 41929                                  
 41930                                  	mov	si,rpFind1a
 41931                                  	mov	dx,rpFind1aLen  ;8
 41932                                  	call	ScanCodeSeq
 41933                                  	jz	short rpGotPatch
 41934                                  
 41935                                  rp3Exit_j:
 41936                                  	jmp	rp3Exit
 41937                                  
 41938                                  ; Found the location to write patch code! DI = offset in code seg.
 41939                                  
 41940                                  rpGotPatch:
 41941                                  	;mov	[bp+4],di
 41942                                  	mov	[bp-StackVars.sv_pPatch],di	; save patch pointer
 41943                                  
 41944                                  ;----------------------------------------------------------------------------
 41945                                  ; Bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI
 41946                                  
 41947                                  	;cmp	word [bp+0],381
 41948                                  	;cmp	word [bp+StackVars.sv_wVersion],381 ; only need bug 1 if version
 41949                                  	cmp	word [bp],381
 41950                                  	jae	short rpBug2			;   < 3.81
 41951                                  
 41952                                  	mov	bx,rpBug1Strs			; locate find2 & find3 code
 41953                                  	call	FindBadCode
 41954                                  	jc	short rpBug2
 41955                                  
 41956                                  ; si = rpFind2 offset, di = rpFind3 offset
 41957                                  
 41958                                  	push	di
 41959                                  	mov	di,si				; rpFind2 offset
 41960                                  	mov	dx,rpFind2Len ; 3
 41961                                  
 41962                                  	cmp	byte [es:di-1],51h	 	; find2 preceeded by push cx?
 41963                                  	jne	short rp_no_cx
 41964                                  
 41965                                  	dec	di				;   yes, gobble up push cx too
 41966                                  	inc	dx
 41967                                  rp_no_cx:
 41968                                  	mov	si,rpRepl2			; patch out find2 sequence
 41969                                  	mov	cx,rpRepl2Len  ; 6
 41970                                  	call	GenPatch
 41971                                  
 41972                                  	pop	di				; rpFind3 offset
 41973                                  	cmp	byte [es:di-1],59h 		; find3 preceeded by pop cx?
 41974                                  	jne	short rp_no_cx2
 41975                                  
 41976                                  	mov	byte [es:di-1],90h		;   yes, no-op it
 41977                                  rp_no_cx2:
 41978                                  	;mov	ax,[bp+4]
 41979                                  	mov	ax,[bp+StackVars.sv_pPatch]	; change offset of far jmp
 41980                                  	;mov	[es:di+4],ax
 41981                                  	mov	[es:di+rpFind3Len],ax		;   to go to patch code
 41982                                  
 41983                                  	push	di				; save find3 offset
 41984                                  	mov	si,rpRepl3			; copy repl3 to patch area
 41985                                  	mov	cx,rpRepl3Len ; 5
 41986                                  	call	CopyPatch
 41987                                  
 41988                                  	pop	bx				; find3 offset
 41989                                  	add	bx,rpFind3Len+4	 ; 8		; skip over find3 and far jmp
 41990                                  	call	GenJump 			; jmp back from patch area
 41991                                  	;mov	[bp+4],di
 41992                                  	mov	[bp+StackVars.sv_pPatch], di	;   to main-line, update patch
 41993                                  						;   area pointer
 41994                                  
 41995                                  ;----------------------------------------------------------------------------
 41996                                  ; Bug # 2 -- loss of high regs on 386+ under VCPI only
 41997                                  
 41998                                  rpBug2:
 41999                                  	mov	bx,rpBug2Strs			; locate find4 & find5 code
 42000                                  	call	FindBadCode
 42001                                  	jc	short rpBug3
 42002                                  
 42003                                  ; si = rpFind4 offset, di = rpFind5 offset
 42004                                  
 42005                                  	;push	word [bp+4]
 42006                                  	push	word [bp+StackVars.sv_pPatch]	; save current patch pointer
 42007                                  						;   (where repl4 goes)
 42008                                  	push	di				; save find5 offset
 42009                                  
 42010                                  	mov	di,si
 42011                                  	mov	dx,rpFind4Len ; 4
 42012                                  	mov	si,rpRepl4
 42013                                  	mov	cx,rpRepl4Len ; 15
 42014                                  	call	GenPatch			; patch out find4 code
 42015                                  
 42016                                  	pop	di				; find5 offset
 42017                                  	add	di,5				; keep 5 bytes of find5 code
 42018                                  	;mov	bx,[bp+4]
 42019                                  	mov	bx,[bp+StackVars.sv_pPatch]	; jump to patch area
 42020                                  	push	bx				; save repl5 location
 42021                                  	call	GenJump
 42022                                  
 42023                                  	mov	si,rpRepl5			; copy repl5 code to patch
 42024                                  	mov	cx,rpRepl5Len  ; 15		;   area -- it has a jmp bx
 42025                                  	call	CopyPatch			;   so no need to jmp back to
 42026                                  						;   main-line code
 42027                                  
 42028                                  ; patches have been made, now update the patch code to store/load dwords just
 42029                                  ; after the code in the patch area
 42030                                  
 42031                                  	pop	di				; repl5 location
 42032                                  	pop	si				; repl4 location
 42033                                  
 42034                                  	;mov	ax,[bp+4]
 42035                                  	mov	ax,[bp+StackVars.sv_pPatch]	; (where dwords go)
 42036                                  
 42037                                  	;mov	[es:si+7],ax
 42038                                  	mov	[es:si+rpRepl4o1Len],ax		; offset for EAX
 42039                                  	;mov	[es:di+5],ax
 42040                                  	mov	[es:di+rpRepl5o1Len],ax
 42041                                  	add	ax,4
 42042                                  	;mov	[es:si+0Dh],ax
 42043                                  	mov	[es:si+rpRepl4o2Len],ax		; offset for ESI
 42044                                  	;mov	[es:di+0Bh],ax
 42045                                  	mov	[es:di+rpRepl5o2Len],ax
 42046                                  
 42047                                  	;add	word [bp+4],8
 42048                                  	add	word [bp+StackVars.sv_pPatch],8	; reserve space for 2 dwords in
 42049                                  						; patch area
 42050                                  
 42051                                  ;----------------------------------------------------------------------------
 42052                                  ; Bug # 3 -- loss of high regs on 386+ under VCPI only
 42053                                  
 42054                                  rpBug3:
 42055                                  	mov	bx,rpBug3Strs			; locate find6 & find7a code
 42056                                  	call	FindBadCode
 42057                                  	jc	short rpBug4
 42058                                  
 42059                                  	;add	di,9
 42060                                  	add	di,rpFind7aLen + 2		; skip over offset in find7a
 42061                                  	push	si				;   code and locate find7b
 42062                                  	mov	si,rpFind7b			;   sequence
 42063                                  	mov	dx,rpFind7bLen ; 3
 42064                                  	call	ScanCodeSeq_di
 42065                                  	pop	si
 42066                                  	jnz	short rpBug4
 42067                                  
 42068                                  	push	di				; save find7b code offset
 42069                                  
 42070                                  	mov	di,si
 42071                                  	mov	dx,rpFind6Len ; 3
 42072                                  	mov	si,rpRepl6
 42073                                  	mov	cx,rpRepl6Len ; 9
 42074                                  	call	GenPatch			; patch out find6 code
 42075                                  
 42076                                  	pop	di
 42077                                  	mov	dx,rpFind7bLen ; 3
 42078                                  	mov	si,rpRepl7
 42079                                  	mov	cx,rpRepl7Len ; 9
 42080                                  	call	GenPatch			; patch out find7b code
 42081                                  
 42082                                  ;----------------------------------------------------------------------------
 42083                                  ; Bug # 4 -- loss of high regs on 386+ under VCPI only
 42084                                  
 42085                                  rpBug4:
 42086                                  	;cmp	word [bp+0],360
 42087                                  	;cmp	word [bp+StackVars.sv_wVersion],360 ; only applies if 
 42088                                  	cmp	word [bp],360
 42089                                  	jbe	short rp3Exit 			; version > 3.60 and < 3.95
 42090                                  
 42091                                  	mov	bx,rpBug4Strs			; locate find8 & find9 code
 42092                                  	call	FindBadCode
 42093                                  	jc	short rp3Exit
 42094                                  
 42095                                  	push	di				; save find9 code offset
 42096                                  
 42097                                  	mov	di,si
 42098                                  	mov	dx,3
 42099                                  	mov	si,rpRepl8
 42100                                  	mov	cx,rpRepl8Len ; 4
 42101                                  	call	GenPatch			; patch out find8 code
 42102                                  
 42103                                  	pop	di				; find9 offset
 42104                                  	;mov	bx,[bp+4]
 42105                                  	mov	bx,[bp+StackVars.sv_pPatch]	; patch find9 to jmp to
 42106                                  	call	GenJump 			;   patch area
 42107                                  
 42108                                  	mov	si,rpRepl9			; copy replacement code to
 42109                                  	mov	cx,rpRepl9Len ; 5		;   patch area--it does a RET
 42110                                  	call	CopyPatch			;   so no jmp back to main-line
 42111                                  
 42112                                  rp3Exit:
 42113                                  	add	sp,StackVars.size
 42114                                  	pop	bp
 42115                                  	pop	ds
 42116                                  	pop	es
 42117                                  	pop	di
 42118                                  	pop	si
 42119                                  	pop	dx
 42120                                  	pop	cx
 42121                                  	pop	bx
 42122                                  	pop	ax
 42123                                  	retn
 42124                                  
 42125                                  ;----------------------------------------------------------------------------
 42126                                  ;
 42127                                  ; FindBadCode
 42128                                  ;
 42129                                  ; Searches Rational code segment looking for a pair of find strings (all
 42130                                  ; patches have at least two find strings).
 42131                                  ;
 42132                                  ; Entry:
 42133                                  ;	ES    = code segment to search
 42134                                  ;	DS:BX = search pair structure for this search
 42135                                  ;	[bp].sv_cbCodeSeg = length of code seg to search
 42136                                  ;
 42137                                  ; Exit:
 42138                                  ;	CY flag clear if both strings found, and
 42139                                  ;	SI    = offset in ES of 1st string
 42140                                  ;	DI    = offset in ES of 2nd string
 42141                                  ;	CY set if either string not found, or strings too far apart
 42142                                  ;
 42143                                  ; Used:
 42144                                  ;	CX
 42145                                  ;
 42146                                  ;----------------------------------------------------------------------------
 42147                                  
 42148                                  ;struc SearchPair
 42149                                  ; .sp_off1: resw 1	; offset of 1st search string
 42150                                  ; .sp_len1: resw 1	; length of 1st search string
 42151                                  ; .sp_off2: resw 1	; 2nd string
 42152                                  ; .sp_len2: resw 1	; 2nd string
 42153                                  ; .sp_diff: resw 1	; max difference between offsets
 42154                                  ; .size:
 42155                                  ;endstruc
 42156                                  
 42157                                  FindBadCode:
 42158                                  	;mov	cx,[bp+2]
 42159                                  	mov	cx,[bp+StackVars.sv_cbCodeSeg]	; search length
 42160                                  
 42161                                  	mov	si,[bx]	; mov si,[bx+0]
 42162                                  	;mov	si,[bx+Searchpair.sp_off1] ; ds:si -> search string
 42163                                  	
 42164                                  	;mov	dx,[bx+2]
 42165                                  	mov	dx,[bx+SearchPair.sp_len1] ; dx = search len
 42166                                  	call	ScanCodeSeq
 42167                                  	jnz	short fbc_error		; done if 1st not found
 42168                                  
 42169                                  	push	di			; save 1st string offset
 42170                                  
 42171                                  	;mov	si,[bx+4]
 42172                                  	mov	si,[bx+SearchPair.sp_off2]
 42173                                  	;mov	dx,[bx+6]
 42174                                  	mov	dx,[bx+SearchPair.sp_len2]
 42175                                  	call	ScanCodeSeq_di		; don't change flags after this!
 42176                                  
 42177                                  	pop	si			; restore 1st string offset
 42178                                  	jnz	short fbc_error
 42179                                  
 42180                                  	mov	ax,di			; sanity check that
 42181                                  	sub	ax,si			;   si < di && di - si <= allowed diff
 42182                                  	jc	short fbc_error
 42183                                  	;cmp	ax,[bx+8]
 42184                                  	cmp	ax,[bx+SearchPair.sp_diff]
 42185                                  	ja	short fbc_error
 42186                                  
 42187                                  	clc
 42188                                  	retn
 42189                                  
 42190                                  fbc_error:
 42191                                  	stc
 42192                                  	retn
 42193                                  
 42194                                  ;----------------------------------------------------------------------------
 42195                                  ;
 42196                                  ; GenPatch
 42197                                  ;
 42198                                  ; Generate a patch sequence. 1) insert a jump at the buggy code location
 42199                                  ; (jumps to the patch code area), 2) copy the selected patch code to the
 42200                                  ; patch area, 3) insert a jump from the patch area back to the main-line
 42201                                  ; code.
 42202                                  ;
 42203                                  ; Entry:
 42204                                  ;	ES:DI = start of buggy code to be patched
 42205                                  ;	DX    = length of buggy code to be patched
 42206                                  ;	DS:SI = replacement patch code
 42207                                  ;	CX    = length of replacement patch code
 42208                                  ;	[bp].sv_pPatch = offset in ES of where to copy patch code
 42209                                  ;
 42210                                  ; Exit:
 42211                                  ;	DI, [bp].sv_pPatch = byte after generated patch code
 42212                                  ;
 42213                                  ; Used:
 42214                                  ;	AX, BX, SI, Flags
 42215                                  ;
 42216                                  ;----------------------------------------------------------------------------
 42217                                  
 42218                                  GenPatch:
 42219                                  	push	di			;save offset of buggy code
 42220                                  
 42221                                  	;mov	bx,[bp+4]
 42222                                  	mov	bx,[bp+StackVars.sv_pPatch]
 42223                                  					;jump from buggy code to patch area
 42224                                  	call	GenJump
 42225                                  
 42226                                  	call	CopyPatch		;copy replacement code to patch area
 42227                                  
 42228                                  	pop	bx			;offset of buggy code + buggy code
 42229                                  	add	bx,dx			;  length = return from patch offset
 42230                                  
 42231                                  	call	GenJump 		;jump from patch area back to main-
 42232                                  	;mov	[bp+4],di
 42233                                  	mov	[bp+StackVars.sv_pPatch],di
 42234                                  					;  line code, update patch pointer
 42235                                  	retn
 42236                                  
 42237                                  ;----------------------------------------------------------------------------
 42238                                  ;
 42239                                  ; CopyPatch
 42240                                  ;
 42241                                  ; Copies patch code to patch location.
 42242                                  ;
 42243                                  ; Entry:
 42244                                  ;	DS:SI = patch code to be copied
 42245                                  ;	ES    = segment of code to patch
 42246                                  ;	CX    = length of code to copy
 42247                                  ;	[bp].sv_pPatch = offset in ES of where to copy patch code
 42248                                  ;
 42249                                  ; Exit:
 42250                                  ;	DI, [bp].sv_pPatch = byte after copied patch code
 42251                                  ;
 42252                                  ; Used:
 42253                                  ;	SI, Flags
 42254                                  ;
 42255                                  ;----------------------------------------------------------------------------
 42256                                  
 42257                                  CopyPatch:
 42258                                  	push	cx
 42259                                  	;mov	di,[bp+4]
 42260                                  	mov	di,[bp+StackVars.sv_pPatch] ;patch pointer is the dest offset
 42261                                  	cld
 42262                                  	rep movsb
 42263                                  	pop	cx
 42264                                  	;mov	[bp+4],di
 42265                                  	mov	[bp+StackVars.sv_pPatch],di ;update net pointer location
 42266                                  	retn
 42267                                  
 42268                                  ;----------------------------------------------------------------------------
 42269                                  ;
 42270                                  ; GenJump
 42271                                  ;
 42272                                  ; Generates a rel16 JMP instruction at location 'from' to location 'to'.
 42273                                  ;
 42274                                  ; Entry:
 42275                                  ;	ES:DI = from location (where to put jmp instruction)
 42276                                  ;	BX    = to location (where to jump to)
 42277                                  ;
 42278                                  ; Exit:
 42279                                  ;	DI = byte after generated jump
 42280                                  ;
 42281                                  ; Used:
 42282                                  ;	AX
 42283                                  ;
 42284                                  ;----------------------------------------------------------------------------
 42285                                  
 42286                                  GenJump:
 42287                                  	mov	al,0E9h		; jmp rel16 opcode
 42288                                  	stosb
 42289                                  
 42290                                  	mov	ax,bx		; calc offset to 'to' location
 42291                                  	sub	ax,di
 42292                                  	sub	ax,2
 42293                                  
 42294                                  	stosw			; output offset
 42295                                  
 42296                                  	retn
 42297                                  
 42298                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42299                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
 42300                                  
 42301                                  ; DOSCODE:B6D8h (MSDOS 5.0, MSDOS.SYS)
 42302                                  ; 21/03/2024 - Retro DOS v4.2
 42303                                  ; DOSCODE:B6BEh (MSDOS 6.22, MSDOS.SYS)
 42304                                  
 42305                                  ;----------------------------------------------------------------------------
 42306                                  ;
 42307                                  ; ScanCodeSeq
 42308                                  ;
 42309                                  ; Looks for a pattern pointed to by DS:SI & len DX in ES:200 to ES:200+CX-1
 42310                                  ;
 42311                                  ; returns in ES:DI the start of the pattern if Zero flag is set
 42312                                  ;
 42313                                  ;----------------------------------------------------------------------------
 42314                                  
 42315                                  ScanCodeSeq:
 42316                                  	mov	di,200h
 42317                                  ScanCodeSeq_di:
 42318                                  	push	cx
 42319                                  	sub	cx,dx
 42320                                  	inc	cx
 42321                                  scsagain:
 42322                                  	push	si
 42323                                  	push	di
 42324                                  	push	cx
 42325                                  	mov	cx,dx
 42326                                  	rep	cmpsb
 42327                                  	pop	cx
 42328                                  	pop	di
 42329                                  	pop	si
 42330                                  	je	short scsfound
 42331                                  	inc	di
 42332                                  	loop	scsagain
 42333                                  scsfound:
 42334                                  	pop	cx
 42335                                  vvexit:		; 18/12/2022
 42336                                  	retn
 42337                                  
 42338                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42339                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
 42340                                  
 42341                                  ; DOSCODE:B6F0h (MSDOS 5.0, MSDOS.SYS)
 42342                                  ; 21/03/2024 - Retro DOS v4.2
 42343                                  ; DOSCODE:B6D6h (MSDOS 6.22, MSDOS.SYS)
 42344                                  	
 42345                                  ;----------------------------------------------------------------------------
 42346                                  ;
 42347                                  ; VerifyVersion
 42348                                  ;
 42349                                  ; Checks whether the binary version from ES:0 matches the ASCII version
 42350                                  ; from ES:2A.
 42351                                  ;
 42352                                  ;       Entry: AX = binary version number 
 42353                                  ;       Exit : Z flag set if version numbers match
 42354                                  ;
 42355                                  ;----------------------------------------------------------------------------
 42356                                  
 42357                                  VerifyVersion:
 42358                                  	mov	si,[es:2Ah]		; offset of version number
 42359                                  					;  in ascii
 42360                                  	mov	bl,10
 42361                                  	add	si,3			; point to last digit
 42362                                  
 42363                                  	call	VVDigit
 42364                                  	jne	short vvexit
 42365                                  	call	VVDigit
 42366                                  	jne	short vvexit
 42367                                  	cmp	byte [es:si],'.'
 42368                                  	jne	short vvexit
 42369                                  	dec	si
 42370                                  	;call	VVDigit
 42371                                  	; 18/12/2022
 42372                                  	;jmp	short VVDigit
 42373                                  ;vvexit:
 42374                                  	;retn
 42375                                  VVDigit:
 42376                                  	div	bl
 42377                                  	add	ah,'0'
 42378                                  	dec	si
 42379                                  	cmp	[es:si+1],ah
 42380                                  	mov	ah,0			; do not xor or sub we need Z
 42381                                  	retn
 42382                                  
 42383                                  %endif
 42384                                  
 42385                                  ;-----------------------------------------------------------------------
 42386                                  
 42387                                  ; 23/05/2019 - Retro DOS v4.0
 42388                                  ; DOSCODE:B702h (MSDOS 6.21, MSDOS.SYS)
 42389                                  
 42390                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42391                                  ; DOSCODE:B3E0h (MSDOS 5.0, MSDOS.SYS)
 42392                                  
 42393                                  exepatch_start:	 ; label byte
 42394                                  
 42395                                  	; The following is the code that'll be layed over the buggy unpack
 42396                                  	; code.
 42397                                  str1:
 42398 000071F8 06                      	db  06h	  		;push	es
 42399 000071F9 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 42400                                  
 42401                                  first_stop equ	$-str1
 42402                                  			
 42403 000071FB 2BC2                    	db  2Bh, 0C2h		;sub	ax,dx
 42404                                  
 42405                                  first:  ; label	byte
 42406                                  
 42407 000071FD 8ED8                    	db  8Eh,0D8h		;mov	ds,ax
 42408 000071FF 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 42409 00007201 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 42410 00007204 57                      	db  57h	    		;push	di
 42411 00007205 B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 42412 00007208 B0FF                    	db  0B0h,0FFh 		;mov	al,0FFH
 42413 0000720A F3AE                    	db  0F3h,0AEh 		;repz	scasb
 42414 0000720C 47                      	db  47h	    		;inc	di
 42415 0000720D 8BF7                    	db  8Bh,0F7h  		;mov	si,di
 42416 0000720F 5F                      	db  5Fh	    		;pop	di
 42417 00007210 58                      	db  58h	    		;pop	ax
 42418                                  
 42419                                  second_stop equ	$-first
 42420                                  
 42421 00007211 2BC2                    	db  2Bh,0C2h  		;sub	ax,dx
 42422                                  
 42423                                  second: ; label	byte
 42424                                  
 42425 00007213 8EC0                    	db  8Eh,0C0h  		;mov	es,ax
 42426                                  		    		;NextRec:
 42427 00007215 B90402                  	db  0B9h,04h,02h	;mov	cx,0204h
 42428                                  		    		;norm_agn:
 42429 00007218 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 42430 0000721A F7D0                    	db  0F7h,0D0h		;not	ax
 42431 0000721C D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 42432 0000721E 7413                    	db  74h,13h		;jz	short SI_ok
 42433 00007220 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 42434 00007222 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H
 42435 00007225 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 42436 00007227 7308                    	db  73h,08h		;jnc	short SItoDS
 42437 00007229 F7DA                    	db  0F7h,0DAh		;neg	dx
 42438 0000722B D3E2                    	db  0D3h,0E2h		;shl	dx,cl
 42439 0000722D 2BF2                    	db  2Bh,0F2h		;sub	si,dx
 42440 0000722F 33D2                    	db  33h,0D2h		;xor	dx,dx
 42441                                  				;SItoDS:
 42442 00007231 8EDA                    	db  8Eh,0DAh		;mov	ds,dx
 42443                                  				;SI_ok:
 42444 00007233 87F7                    	db  87h,0F7h		;xchg	si,di
 42445 00007235 1E                      	db  1Eh			;push	ds
 42446 00007236 06                      	db  06h			;push	es
 42447 00007237 1F                      	db  1Fh			;pop	ds
 42448 00007238 07                      	db  07h			;pop	es
 42449 00007239 FECD                    	db  0FEh,0CDh		;dec	ch
 42450 0000723B 75DB                    	db  75h,0DBh		;jnz	short norm_agn
 42451 0000723D AC                      	db  0ACh		;lodsb
 42452 0000723E 92                      	db  92h			;xchg	dx,ax
 42453 0000723F 4E                      	db  4Eh			;dec	si
 42454 00007240 AD                      	db  0ADh		;lodsw
 42455 00007241 8BC8                    	db  8Bh,0C8h		;mov	cx,ax
 42456 00007243 46                      	db  46h			;inc	si
 42457 00007244 8AC2                    	db  8Ah,0C2h		;mov	al,dl
 42458 00007246 24FE                    	db  24h,0FEh		;and	al,0FEH
 42459 00007248 3CB0                    	db  3Ch,0B0h		;cmp	al,RPTREC
 42460 0000724A 7505                    	db  75h,05h		;jne	short TryEnum
 42461 0000724C AC                      	db  0ACh		;lodsb
 42462 0000724D F3AA                    	db  0F3h,0AAh		;rep stosb
 42463                                  
 42464                                  ;	db  0EBh,07h,90h	;jmp	short TryNext
 42465 0000724F EB06                    	db  0EBh,06h		;jmp	short TryNext
 42466                                  
 42467                                  				;TryEnum:
 42468 00007251 3CB2                    	db  3Ch,0B2h		;cmp	al,ENMREC
 42469 00007253 756C                    	db  75h,6Ch		;jne	short CorruptExe
 42470 00007255 F3A4                    	db  0F3h,0A4h		;rep movsb
 42471                                  				;TryNext:
 42472                                  
 42473 00007257 92                      	db  92h			;xchg	dx,ax
 42474                                  ;	db  8Ah,0C2h		;mov	al,dl
 42475                                  
 42476 00007258 A801                    	db  0A8h,01h		;test	al,1
 42477 0000725A 74B9                    	db  74h,0B9h		;jz	short NextRec
 42478 0000725C 9090                    	db  90h,90h		;nop,nop
 42479                                  	
 42480                                  last_stop equ $-second
 42481                                  size_str1 equ $-str1
 42482                                  
 42483                                  	; The following is the code that we need to look for in the exe
 42484                                  	; file.
 42485                                  
 42486                                  scan_patch1: ; label byte
 42487                                  
 42488 0000725E 8CC3                    	db  8Ch,0C3h		;mov	bx,es
 42489 00007260 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 42490 00007262 2BC2                    	db  2Bh,0C2h		;sub	ax,dx
 42491 00007264 8ED8                    	db  8Eh,0D8h		;mov	ds,ax
 42492 00007266 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 42493 00007268 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 42494 0000726B B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 42495 0000726E B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 42496 00007270 F3AE                    	db  0F3h,0AEh		;repz	scasb
 42497 00007272 47                      	db  47h			;inc	di
 42498 00007273 8BF7                    	db  8Bh,0F7h		;mov	si,di
 42499 00007275 8BC3                    	db  8Bh,0C3h		;mov	ax,bx
 42500 00007277 2BC2                    	db  2Bh,0C2h		;sub	ax, dx
 42501 00007279 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 42502 0000727B BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 42503                                  				;NextRec:
 42504 0000727E B104                    	db  0B1h,04h		;mov	cl,4
 42505 00007280 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 42506 00007282 F7D0                    	db  0F7h,0D0h		;not	ax
 42507 00007284 D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 42508 00007286 7409                    	db  74h,09h		;jz	short SI_ok
 42509 00007288 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 42510 0000728A 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 42511 0000728C 8EDA                    	db  8Eh,0DAh		;mov	ds,dx
 42512 0000728E 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H
 42513                                  	       			;SI_ok:
 42514 00007291 8BC7                    	db  8Bh,0C7h		;mov	ax,di
 42515 00007293 F7D0                    	db  0F7h,0D0h		;not	ax
 42516 00007295 D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 42517 00007297 7409                    	db  74h,09h		;jz	short DI_ok
 42518 00007299 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 42519 0000729B 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 42520 0000729D 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 42521 0000729F 83CFF0                  	db  83h,0CFh,0F0h	;or	di,0FFF0H
 42522                                  				;DI_ok:
 42523                                  
 42524                                  size_scan_patch1 equ $-scan_patch1
 42525                                  
 42526                                  scan_patch2: ; label byte
 42527                                  			
 42528 000072A2 8CC3                    	db  8Ch,0C3h		;mov	bx,es
 42529 000072A4 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 42530 000072A6 48                      	db  48h			;dec	ax
 42531 000072A7 8ED8                    	db  8Eh,0D8h		;mov	ds,ax
 42532 000072A9 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 42533 000072AB BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 42534 000072AE B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 42535 000072B1 B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 42536 000072B3 F3AE                    	db  0F3h,0AEh		;repz	scasb
 42537 000072B5 47                      	db  47h			;inc	di
 42538 000072B6 8BF7                    	db  8Bh,0F7h		;mov	si,di
 42539 000072B8 8BC3                    	db  8Bh,0C3h		;mov	ax,bx
 42540 000072BA 48                      	db  48h			;dec	ax
 42541 000072BB 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 42542 000072BD BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 42543                                  				;NextRec:
 42544 000072C0 B104                    	db  0B1h,04h		;mov	cl,4
 42545 000072C2 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 42546 000072C4 F7D0                    	db  0F7h,0D0h		;not	ax
 42547 000072C6 D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 42548 000072C8 740A                    	db  74h,0Ah		;jz	short SI_ok
 42549 000072CA 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 42550 000072CC 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 42551 000072CE 8EDA                    	db  8Eh,0DAh		;mov	ds,dx
 42552 000072D0 81CEF0FF                	db  81h,0CEh,0F0h,0FFh
 42553                                  				;or	si,0FFF0H
 42554                                  				;SI_ok:
 42555 000072D4 8BC7                    	db  8Bh,0C7h		;mov	ax,di
 42556 000072D6 F7D0                    	db  0F7h,0D0h		;not	ax
 42557 000072D8 D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 42558 000072DA 740A                    	db  74h,0Ah		;jz	short DI_ok
 42559 000072DC 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 42560 000072DE 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 42561 000072E0 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 42562 000072E2 81CFF0FF                	db  81h,0CFh,0F0h,0FFh
 42563                                  				;or	di,0FFF0H
 42564                                  				;DI_ok:
 42565                                  
 42566                                  size_scan_patch2 equ $-scan_patch2
 42567                                  
 42568                                  scan_patch3: ; label byte
 42569                                  
 42570 000072E6 8CC3                    	db  8Ch,0C3h		;mov	bx,es
 42571 000072E8 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 42572 000072EA 48                      	db  48h			;dec	ax
 42573 000072EB 8ED8                    	db  8Eh,0D8h		;mov	ds,ax
 42574 000072ED 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 42575 000072EF BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 42576 000072F2 B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 42577 000072F5 B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 42578 000072F7 F3AE                    	db  0F3h,0AEh		;repz	scasb
 42579 000072F9 47                      	db  47h			;inc	di
 42580 000072FA 8BF7                    	db  8Bh,0F7h		;mov	si,di
 42581 000072FC 8BC3                    	db  8Bh,0C3h		;mov	ax,bx
 42582 000072FE 48                      	db  48h			;dec	ax
 42583 000072FF 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 42584 00007301 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 42585                                  				;NextRec:
 42586 00007304 B104                    	db  0B1h,04h		;mov	cl,4
 42587 00007306 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 42588 00007308 F7D0                    	db  0F7h,0D0h		;not	ax
 42589 0000730A D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 42590 0000730C 7409                    	db  74h,09h		;jz	short SI_ok
 42591 0000730E 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 42592 00007310 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 42593 00007312 8EDA                    	db  8Eh,0DAh		;mov	ds,dx
 42594 00007314 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H
 42595                                  				;SI_ok:
 42596 00007317 8BC7                    	db  8Bh,0C7h		;mov	ax,di
 42597 00007319 F7D0                    	db  0F7h,0D0h		;not	ax
 42598 0000731B D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 42599 0000731D 7409                    	db  74h,09h		;jz	short DI_ok
 42600 0000731F 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 42601 00007321 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 42602 00007323 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 42603 00007325 83CFF0                  	db  83h,0CFh,0F0h	;or	di,0FFF0H
 42604                                  				;DI_ok:
 42605                                  
 42606                                  size_scan_patch3 equ $-scan_patch3
 42607                                  
 42608                                  scan_com: ; label byte
 42609                                  
 42610 00007328 AC                      	db  0ACh		;lodsb
 42611 00007329 8AD0                    	db  8Ah,0D0h		;mov	dl,al
 42612 0000732B 4E                      	db  4Eh			;dec	si
 42613 0000732C AD                      	db  0ADh		;lodsw
 42614 0000732D 8BC8                    	db  8Bh,0C8h		;mov	cx,ax
 42615 0000732F 46                      	db  46h			;inc	si
 42616 00007330 8AC2                    	db  8Ah,0C2h		;mov	al,dl
 42617 00007332 24FE                    	db  24h,0FEh		;and	al,0FEH
 42618 00007334 3CB0                    	db  3Ch,0B0h		;cmp	al,RPTREC
 42619 00007336 7506                    	db  75h,06h		;jne	short TryEnum
 42620 00007338 AC                      	db  0ACh		;lodsb
 42621 00007339 F3AA                    	db  0F3h,0AAh		;rep stosb
 42622 0000733B EB0790                  	db  0EBh,07h,90h	;jmp	short TryNext
 42623                                  				;TryEnum:
 42624 0000733E 3CB2                    	db  3Ch,0B2h		;cmp	al,ENMREC
 42625 00007340 756B                    	db  75h,6Bh		;jne	short CorruptExe
 42626 00007342 F3A4                    	db  0F3h,0A4h		;rep movsb
 42627                                  				;TryNext:
 42628 00007344 8AC2                    	db  8Ah,0C2h		;mov	al,dl
 42629 00007346 A801                    	db  0A8h,01h		;test	al,1
 42630                                  ;	db  74h,0BAh		;jz	short NextRec
 42631                                  
 42632                                  size_scan_com	equ	$-scan_com
 42633                                  
 42634                                  ;-----------------------------------------------------------------------
 42635                                  
 42636                                  ; 23/05/2019 - Retro DOS v4.0
 42637                                  ; DOSCODE:B852h (MSDOS 6.21, MSDOS.SYS)
 42638                                  
 42639                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42640                                  ; DOSCODE:B530h (MSDOS 5.0, MSDOS.SYS)
 42641                                  
 42642                                  ExePatch:
 42643                                  	; 28/12/2022 - Retro DOS v4.1
 42644                                  	;call	ExePackPatch
 42645                                  	;;call	word [ss:RationalPatchPtr]
 42646                                  	;retn
 42647                                  	; 28/12/2022
 42648                                  	;jmp	short ExePackPatch
 42649                                  
 42650                                  ;-----------------------------------------------------------------------
 42651                                  ;
 42652                                  ; Procedure Name 	: ExePackPatch
 42653                                  ;
 42654                                  ; Inputs	 	: DS 			-> DOSDATA
 42655                                  ;			  ES:0 			-> read in image
 42656                                  ;			  ax:cx = start cs:ip of program
 42657                                  ; Output		:		
 42658                                  ;
 42659                                  ;	1. If ES <= 0fffh
 42660                                  ;	   2. if exepack signature ('RB') found
 42661                                  ;	      3. if common code to patch compares (for 3 diff. versions)
 42662                                  ;	       	 4. if rest of the code & checksum compares
 42663                                  ;	  	    5. overlay buggy code with code in 
 42664                                  ;		       doscode:str1.
 42665                                  ;		 6. endif
 42666                                  ;	      7. endif
 42667                                  ;	   8. endif
 42668                                  ;	9. endif
 42669                                  ;
 42670                                  ;
 42671                                  ; Uses			: NONE
 42672                                  ;
 42673                                  ;-----------------------------------------------------------------------
 42674                                  
 42675                                  	; 21/03/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
 42676                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42677                                  	; 23/05/2019 - Retro DOS v4.0	
 42678                                  ExePackPatch:
 42679 00007348 53                      	push	bx
 42680 00007349 8CC3                    	mov	bx,es			; bx has load segment
 42681 0000734B 81FBFF0F                	cmp	bx,0FFFh		; Q: is the load segment > 64K
 42682 0000734F 7602                    	jbe	short ep_cont		; N: 
 42683 00007351 5B                      	pop	bx			; Y: no need to patch
 42684 00007352 C3                      	retn
 42685                                  ep_cont:
 42686 00007353 1E                      	push	ds
 42687 00007354 06                      	push	es
 42688 00007355 50                      	push	ax
 42689 00007356 51                      	push	cx
 42690 00007357 56                      	push	si
 42691 00007358 57                      	push	di
 42692                                  	
 42693                                  		; M033 - start
 42694                                  		; exepacked programs have an IP of 12h (>=2)
 42695                                  
 42696 00007359 83E902                  	sub	cx,2			; Q: is IP >=2
 42697 0000735C 7303                    	jnb	short epp_1		; N: exit
 42698 0000735E E9B500                  	jmp	ep_notpacked
 42699                                  					; ax:cx now points to location of
 42700                                  					; 'RB' if this is an exepacked file.
 42701                                  		; M033 - end
 42702                                  epp_1:
 42703 00007361 89CF                    	mov	di,cx
 42704 00007363 8EC0                    	mov	es,ax
 42705 00007365 36893E[8700]            	mov	[ss:UNPACK_OFFSET],di	; save pointer to 'RB' in
 42706                                  					; unpack_offset
 42707                                  
 42708 0000736A 26813D5242              	cmp	word [es:di],'RB' ; 4252h
 42709                                  	;ljne	ep_notpacked
 42710 0000736F 7403                    	je	short epp_2
 42711 00007371 E9A200                  	jmp	ep_notpacked
 42712                                  epp_2:
 42713 00007374 0E                      	push	cs
 42714 00007375 1F                      	pop	ds			; set ds to cs
 42715                                  
 42716                                  	;add	di,6Ch
 42717 00007376 83C76C                  	add	di,PATCH1_COM_OFFSET	; es:di -> points to place in packed
 42718                                  					;          file where we hope to find
 42719                                  					;	   scan string. 
 42720                                  
 42721 00007379 E8A200                  	call	chk_common_str		; check for match
 42722                                  
 42723 0000737C 7521                    	jnz	short ep_chkpatch2	; Q: does the patch match
 42724                                  					; N: check at patch2_offset
 42725                                  					; Y: check for rest of patch string
 42726 0000737E BE[5E72]                	mov	si,scan_patch1
 42727                                  					; ds:si -> scan string 
 42728 00007381 368B3E[8700]            	mov	di,[ss:UNPACK_OFFSET]	; restore di to point to 'RB'
 42729                                  
 42730                                  	;add	di,28h
 42731                                  	; 07/12/2022
 42732 00007386 83C728                  	add	di,PATCH1_OFFSET	; es:di -> points to place in packed
 42733                                  					;          file where we hope to find
 42734                                  					;	   scan string. 
 42735                                  	;;mov	cx,68
 42736                                  	;mov	cx,size_scan_patch1
 42737                                  	; 21/03/2024
 42738 00007389 B144                    	mov	cl,size_scan_patch1 ; 68
 42739                                  
 42740                                  	;mov	bx,142
 42741 0000738B BB8E00                  	mov	bx,CHKSUM1_LEN
 42742                                  	;mov	ax,0EF4Eh
 42743 0000738E B84EEF                  	mov	ax,PATCH1_CHKSUM
 42744 00007391 E89E00                  	call	chk_patchsum		; check if patch and chk sum compare
 42745 00007394 7207                    	jc	short ep_done1		; Q: did we pass the test
 42746                                  					; N: exit
 42747                                  					; Y: overlay code with new 
 42748 00007396 BE[F871]                	mov	si,str1
 42749                                  	;;mov	cx,102
 42750                                  	;mov	cx,size_str1
 42751                                  	; 21/03/2024
 42752 00007399 B166                    	mov	cl,size_str1 ; 102
 42753                                  
 42754 0000739B F3A4                    	rep	movsb
 42755                                  ep_done1:
 42756 0000739D EB77                    	jmp	short ep_done ; 21/03/2024
 42757                                  
 42758                                  ep_chkpatch2:
 42759                                  	;mov	di,76h
 42760 0000739F BF7600                  	mov	di,PATCH2_COM_OFFSET	; es:di -> possible location of patch
 42761                                  					; in another version of unpack
 42762 000073A2 E87900                  	call	chk_common_str		; check for match
 42763                                  
 42764 000073A5 753D                    	jnz	short ep_chkpatch3	; Q: does the patch match
 42765                                  					; N: check for patch3_offset
 42766                                  					; Y: check for rest of patch string
 42767                                  
 42768 000073A7 BE[A272]                	mov	si,scan_patch2
 42769                                  					; ds:si -> scan string
 42770                                  	;mov	di,32h
 42771 000073AA BF3200                  	mov	di,PATCH2_OFFSET	; es:di -> points to place in packed
 42772                                  					;          file where we hope to find
 42773                                  	;;mov	cx,68			;	   scan string.
 42774                                  	;mov	cx,size_scan_patch2
 42775                                  	; 21/03/2024
 42776 000073AD B144                    	mov	cl,size_scan_patch2 ; 68
 42777                                  	;mov	bx,140
 42778 000073AF BB8C00                  	mov	bx,CHKSUM2_LEN
 42779                                  	;mov	ax,78B2h
 42780 000073B2 B8B278                  	mov	ax,PATCH2_CHKSUM
 42781 000073B5 E87A00                  	call	chk_patchsum		; check if patch and chk sum compare
 42782                                  
 42783                                  					; M046 - Start
 42784                                  					; Q: did we pass the test
 42785 000073B8 7310                    	jnc	short ep_patchcode2	; Y: overlay code with new
 42786                                  					; N: try with a different chksum
 42787                                  
 42788 000073BA BE[A272]                	mov	si,scan_patch2
 42789                                  					; ds:si -> scan string
 42790                                  	;;mov	cx,68
 42791                                  	;mov	cx,size_scan_patch2
 42792                                  	; 21/03/2024
 42793 000073BD B144                    	mov	cl,size_scan_patch2 ; 68
 42794                                  	;mov	bx,129
 42795 000073BF BB8100                  	mov	bx,CHKSUM2A_LEN
 42796                                  	;mov	ax,1C47h
 42797 000073C2 B8471C                  	mov	ax,PATCH2A_CHKSUM
 42798 000073C5 E86A00                  	call	chk_patchsum		; check if patch and chk sum compare
 42799                                  					; Q: did we pass the test
 42800 000073C8 724C                    	jc	short ep_notpacked	; N: try with a different chksum
 42801                                  					; Y: overlay code with new
 42802                                  						
 42803                                  ep_patchcode2:			       	; M046 - End
 42804 000073CA BE[F871]                	mov	si,str1
 42805                                  	;;mov	cx,3
 42806                                  	;mov	cx,first_stop
 42807                                  	; 21/03/2024
 42808 000073CD B103                    	mov	cl,first_stop ; 3
 42809 000073CF F3A4                    	rep	movsb
 42810 000073D1 B89048                  	mov	ax,4890h		; ax = opcodes for dec ax, nop
 42811 000073D4 AB                      	stosw
 42812                                  	;add	si,2
 42813                                  	; 21/03/2024
 42814 000073D5 46                      	inc	si
 42815 000073D6 46                      	inc	si	
 42816                                  	;;mov	cx,20
 42817                                  	;mov	cx,second_stop
 42818                                  	; 21/03/2024
 42819 000073D7 B114                    	mov	cl,second_stop ; 20
 42820 000073D9 F3A4                    	rep	movsb
 42821 000073DB AB                      	stosw				; put in dec ax and nop
 42822                                  	;add	si,2
 42823                                  	; 21/03/2024
 42824 000073DC 46                      	inc	si
 42825 000073DD 46                      	inc	si
 42826                                  	;;mov	cx,75
 42827                                  	;mov	cx,last_stop
 42828                                  	; 21/03/2024
 42829 000073DE B14B                    	mov	cl,last_stop ; 75
 42830 000073E0 F3A4                    	rep	movsb
 42831 000073E2 EB32                    	jmp	short ep_done
 42832                                  
 42833                                  ep_chkpatch3:
 42834                                  	;mov	di,74h
 42835 000073E4 BF7400                  	mov	di,PATCH3_COM_OFFSET	; es:di -> possible location of patch
 42836                                  					; in another version of unpack
 42837 000073E7 E83400                  	call	chk_common_str		; check for match
 42838                                  
 42839 000073EA 752A                    	jnz	short ep_notpacked	; Q: does the patch match
 42840                                  					; N: exit
 42841                                  					; Y: check for rest of patch string
 42842 000073EC BE[E672]                	mov	si,scan_patch3
 42843                                  					; ds:si -> scan string
 42844                                  	;mov	di,32h
 42845 000073EF BF3200                  	mov	di,PATCH3_OFFSET	; es:di -> points to place in packed
 42846                                  					;          file where we hope to find
 42847                                  					;	   scan string. 
 42848                                  	;;mov	cx,66
 42849                                  	;mov	cx,size_scan_patch3
 42850                                  	; 21/03/2024
 42851 000073F2 B142                    	mov	cl,size_scan_patch3 ; 66
 42852                                  	;mov	bx,139
 42853 000073F4 BB8B00                  	mov	bx,CHKSUM3_LEN
 42854                                  	;mov	ax,4EDEh
 42855 000073F7 B8DE4E                  	mov	ax,PATCH3_CHKSUM
 42856 000073FA E83500                  	call	chk_patchsum		; check if patch and chk sum compare
 42857 000073FD 7217                    	jc	short ep_notpacked	; Q: did we pass the test
 42858                                  					; N: exit
 42859                                  					; Y: overlay code with new
 42860 000073FF BE[F871]                	mov	si,str1
 42861                                  	;;mov	cx,3
 42862                                  	;mov	cx,first_stop
 42863                                  	; 21/03/2024
 42864 00007402 B103                    	mov	cl,first_stop ; 3
 42865 00007404 F3A4                    	rep	movsb
 42866 00007406 B048                    	mov	al,48h			; al = opcode for dec ax
 42867 00007408 AA                      	stosb
 42868                                  	;add	si,2
 42869                                  	; 21/03/2024
 42870 00007409 46                      	inc	si
 42871 0000740A 46                      	inc	si
 42872                                  	;;mov	cx,20
 42873                                  	;mov	cx,second_stop
 42874                                  	; 21/03/2024
 42875 0000740B B114                    	mov	cl,second_stop ; 20
 42876 0000740D F3A4                    	rep	movsb
 42877 0000740F AA                      	stosb				; put in dec ax
 42878                                  	;add	si,2
 42879                                  	; 21/03/2024
 42880 00007410 46                      	inc	si
 42881 00007411 46                      	inc	si
 42882                                  	;;mov	cx,75
 42883                                  	;mov	cx,last_stop
 42884                                  	; 21/03/2024
 42885 00007412 B14B                    	mov	cl,last_stop ; 75
 42886 00007414 F3A4                    	rep	movsb
 42887                                  
 42888                                  ep_notpacked:
 42889                                  	;stc
 42890                                  ep_done:
 42891 00007416 5F                      	pop	di
 42892 00007417 5E                      	pop	si
 42893 00007418 59                      	pop	cx
 42894 00007419 58                      	pop	ax
 42895 0000741A 07                      	pop	es
 42896 0000741B 1F                      	pop	ds
 42897 0000741C 5B                      	pop	bx
 42898 0000741D C3                      	retn
 42899                                  
 42900                                  ;-------------------------------------------------------------------------
 42901                                  ;
 42902                                  ; 	Procedure Name	: chk_common_str
 42903                                  ;
 42904                                  ;	Input		: DS = DOSCODE
 42905                                  ;			; ES:DI points to string in packed file
 42906                                  ;
 42907                                  ;	Output		; Z if match else NZ
 42908                                  ;
 42909                                  ;-------------------------------------------------------------------------
 42910                                  
 42911                                  	; 23/05/2019 - Retro DOS v4.0
 42912                                  chk_common_str:
 42913 0000741E BE[2873]                	mov	si,scan_com
 42914                                  					; ds:si -> scan string
 42915                                  	;mov	cx,32
 42916 00007421 B92000                  	mov	cx,size_scan_com
 42917                                  
 42918 00007424 F3A6                    	repe	cmpsb
 42919                                  
 42920                                  					; M046 - start
 42921                                  	; a fourth possible version of these exepacked programs have a
 42922                                  	; 056h instead of 06Bh. See scan_com above
 42923                                  	;
 42924                                  	; 	db  75h, 6Bh		;jne CorruptExe
 42925                                  	;
 42926                                  	; If the mismatch at this point is due to a 56h instead of 6Bh
 42927                                  	; we shall try to match the rest of the string
 42928                                  	;
 42929                                  
 42930 00007426 7409                    	jz	short ccs_done
 42931 00007428 26807DFF56              	cmp	byte [es:di-1],56h
 42932 0000742D 7502                    	jnz	short ccs_done
 42933                                  
 42934 0000742F F3A6                    	repe	cmpsb
 42935                                  ccs_done:				; M046 - end
 42936 00007431 C3                      	retn
 42937                                  
 42938                                  ;-------------------------------------------------------------------------
 42939                                  ;
 42940                                  ;	Procedure Name	: chk_patchsum
 42941                                  ;
 42942                                  ;	Input		: DS:SI -> string we're looking for
 42943                                  ;			: ES:DI -> offset in packed file
 42944                                  ;			: CX 	= scan length
 42945                                  ;			: BX	= length of check sum
 42946                                  ;			: AX 	= value of check sum
 42947                                  ;
 42948                                  ;	Output		: if patch & check sum compare
 42949                                  ;				NC
 42950                                  ;			  else
 42951                                  ;				CY
 42952                                  ;
 42953                                  ;	Uses		: AX, BX, CX, SI
 42954                                  ;
 42955                                  ;-------------------------------------------------------------------------
 42956                                  
 42957                                  	; 23/05/2019 - Retro DOS v4.0
 42958                                  chk_patchsum:
 42959 00007432 57                      	push	di
 42960                                  
 42961 00007433 F3A6                    	repe	cmpsb
 42962                                  
 42963 00007435 7517                    	jnz	short cp_fail		; Q: does the patch match
 42964                                  					; N: exit
 42965                                  					; Y:
 42966                                  
 42967                                  		; we do a check sum starting from the location of the
 42968                                  		; exepack signature 'RB' up to 11c/2 bytes, the end of the
 42969                                  		; unpacking code.
 42970                                  
 42971 00007437 368B3E[8700]            	mov	di,[ss:UNPACK_OFFSET]	; di -> start of unpack code
 42972 0000743C 89D9                    	mov	cx,bx			; cx = length of check sum
 42973                                  
 42974 0000743E 89C3                    	mov	bx,ax			; save check sum passed to us in bx
 42975 00007440 31C0                    	xor	ax,ax
 42976                                  ep_chksum:
 42977 00007442 260305                  	add	ax,[es:di]
 42978                                  	;add	di,2
 42979                                  	; 01/07/2024
 42980 00007445 47                      	inc	di
 42981 00007446 47                      	inc	di
 42982 00007447 E2F9                    	loop	ep_chksum
 42983                                  
 42984 00007449 5F                      	pop	di			; restore di
 42985                                  
 42986 0000744A 39D8                    	cmp	ax,bx		 	; Q: does the check sum match
 42987                                  	;jne	short cp_fail		; N: exit
 42988                                  					; Y:
 42989                                  	; 25/09/2023
 42990                                  	;clc
 42991                                  	;retn
 42992 0000744C 74E3                    	je	short ccs_done ; cf=0
 42993                                  	
 42994                                  cp_fail:
 42995 0000744E F9                      	stc
 42996 0000744F C3                      	retn
 42997                                  
 42998                                  ; 28/12/2022 - Retro DOS v4.1
 42999                                  %if 0
 43000                                  ;--------------------------------------------------------------------------- 
 43001                                  
 43002                                  
 43003                                  ; M020 : BEGIN
 43004                                  ;
 43005                                  ;---------------------------------------------------------------------------
 43006                                  ;
 43007                                  ; procedure : RationalPatch
 43008                                  ;
 43009                                  ; A routine (in Ration DOS extender) which is invoked at hardware interrupts
 43010                                  ; clobbers CX register on 286 machines. (123 release 3 uses Rational DOS
 43011                                  ; extender). This routine identifies Buggy Rational EXEs and fixes the bug.
 43012                                  ;
 43013                                  ; THE BUG is in the following code sequence:
 43014                                  ;
 43015                                  ;8b 0e 10 00	mov	cx, ds:[10h]		; delay count
 43016                                  ;90		even				; word align
 43017                                  ;e2 fe		loop	$			; wait		CLOBBERS CX
 43018                                  ;e8 xx xx	call	set_A20			; enable A20
 43019                                  ;
 43020                                  ; This patch routine replaces the mov & the loop with a far call into a
 43021                                  ; routine in DOS data segment which is in low memory (because A20 line
 43022                                  ; is off). The routine (RatBugCode) in DOS data saves & restores CX around
 43023                                  ; a mov & loop.
 43024                                  ;
 43025                                  ; Identification of Buggy Rational EXE
 43026                                  ; ====================================
 43027                                  ;
 43028                                  ; (ALL OFFSETS ARE IN THE PROGRAM SECTION - EXCLUDING THE EXE HEADER)
 43029                                  ;
 43030                                  ; OFFSET				Contains
 43031                                  ; ------				--------
 43032                                  ; 0000h			100 times Version number in binary
 43033                                  ;			bug exists in version 3.48 thru 3.83 (both inclusive)
 43034                                  ;
 43035                                  ; 000ah			the WORDS : 0000h, 0020h, 0000h, 0040h, 0001h
 43036                                  ;
 43037                                  ; 002ah			offset where version number is stored in ASCII
 43038                                  ;				e.g. '3.48A'
 43039                                  ;
 43040                                  ; 0030h			offset of copyright string. Copyright strings either
 43041                                  ;			start with "DOS/16M Copyright...." or
 43042                                  ;			"Copyright.....". The string contains
 43043                                  ;			"Rational Systems, Inc."
 43044                                  ;
 43045                                  ; 0020h			word : Paragraph offset of the buggy code segment
 43046                                  ;				from the program image
 43047                                  ; 0016h			word : size of buggy code segment
 43048                                  ;
 43049                                  ;	Buggy code is definite to start after offset 200h in its segment
 43050                                  ;
 43051                                  ;----------------------------------------------------------------------------
 43052                                  
 43053                                  ; 23/05/2019 - Retro DOS v4.0
 43054                                  ; DOSCODE:B976h (MSDOS 6.21, MSDOS.SYS)
 43055                                  
 43056                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43057                                  ; DOSCODE:B654h (MSDOS 5.0, MSDOS.SYS)
 43058                                  
 43059                                  RScanPattern1:
 43060                                  	db	0, 0, 20h, 0, 0, 0, 40h, 0, 1, 0
 43061                                  
 43062                                  RLen1 equ $ - RScanPattern1
 43063                                  
 43064                                  RScanPattern2:
 43065                                  	db	8Bh, 0Eh, 10h, 00h, 90h, 0E2h, 0FEh, 0E8h
 43066                                  
 43067                                  RLen2 equ $ - RScanPattern2
 43068                                  
 43069                                  RScanPattern3:
 43070                                  	db	8Bh, 0Eh, 10h, 00h, 0E2h, 0FEh, 0E8h
 43071                                  
 43072                                  RLen3 equ $ - RScanPattern2
 43073                                  
 43074                                  ; DOSCODE:B98Fh (MSDOS 6.21, MSDOS.SYS)
 43075                                  ; DOSCODE:B66Dh (MSDOS 5.0, MSDOS.SYS)
 43076                                  
 43077                                  ;----------------------------------------------------------------------------
 43078                                  ;
 43079                                  ; INPUT : ES = segment where program got loaded
 43080                                  ;
 43081                                  ;----------------------------------------------------------------------------
 43082                                  
 43083                                  RationalPatch:
 43084                                  	cld
 43085                                  
 43086                                  ; 21/03/2024
 43087                                  %if 0
 43088                                  	push	ax
 43089                                  	push	bx
 43090                                  	push	cx
 43091                                  	push	dx
 43092                                  	push	si
 43093                                  	push	di
 43094                                  %else
 43095                                  	; 21/03/2024 (PCDOS 7.1 IBMDOS.COM)
 43096                                  	;;;
 43097                                  	pusha
 43098                                  	;;;
 43099                                  %endif
 43100                                  	push	es
 43101                                  	push	ds			; we use all of them
 43102                                  	mov	di,0Ah			; look for pat1 at offset 0Ah
 43103                                  	push	cs
 43104                                  	pop	ds
 43105                                  	
 43106                                  	mov	si,RScanPattern1
 43107                                  	;mov	cx,10
 43108                                  	mov	cx,RLen1
 43109                                  	rep	cmpsb			; do we have the pattern ?
 43110                                  	jne	short rpexit
 43111                                  	mov	ax,[es:0]
 43112                                  	cmp	ax,348			; is it a buggy version ?
 43113                                  	jb	short rpexit
 43114                                  	cmp	ax,383			; is it a buggy version ?
 43115                                  	ja	short rpexit
 43116                                  
 43117                                  	call	VerifyVersion
 43118                                  	jne	short rpexit
 43119                                  
 43120                                  	mov	cx,[es:16h]		; Length of buggy code seg
 43121                                  	sub	cx,200h			; Length we search (we start
 43122                                  					;  at offset 200h)
 43123                                  	mov	es,[es:20h]		; es=buggy code segment
 43124                                  	mov	si,RScanPattern2
 43125                                  	;mov	dx,8	
 43126                                  	mov	dx,RLen2
 43127                                  	call	ScanCodeSeq		; look for code seq with nop
 43128                                  	jz	short rpfound
 43129                                  
 43130                                  	mov	si,RScanPattern3
 43131                                  	;mov	dx,15
 43132                                  	mov	dx,RLen3
 43133                                  	call	ScanCodeSeq		; look for code seq w/o nop
 43134                                  	jnz	short rpexit
 43135                                  
 43136                                  rpfound:
 43137                                  	
 43138                                  ;	we set up a far call into DOS data
 43139                                  ;	dx has the length of the code seq we were searching for
 43140                                  
 43141                                  	mov	al,9Ah			; far call opcode
 43142                                  	stosb
 43143                                  	mov	ax,RatBugCode
 43144                                  	stosw
 43145                                  	mov	ax,ss
 43146                                  	stosw
 43147                                  	mov	cx,dx
 43148                                  	sub	cx,6			; filler (with NOPs)
 43149                                  	mov	al,90h
 43150                                  	rep	stosb
 43151                                  rpexit:
 43152                                  	pop	ds
 43153                                  	pop	es
 43154                                  
 43155                                  ; 21/03/2024
 43156                                  %if 0
 43157                                  	pop	di
 43158                                  	pop	si
 43159                                  	pop	dx
 43160                                  	pop	cx
 43161                                  	pop	bx
 43162                                  	pop	ax
 43163                                  %else
 43164                                  	; 21/03/2024 (PCDOS 7.1 IBMDOS.COM)
 43165                                  	;;;
 43166                                  	popa
 43167                                  	;;;
 43168                                  %endif
 43169                                  	retn
 43170                                  
 43171                                  ; M020 END
 43172                                  
 43173                                  ;--------------------------------------------------------------------------- 
 43174                                  %endif	; 28/12/2022
 43175                                  
 43176                                  ;---------------------------------------------------------------------------
 43177                                  ;
 43178                                  ;	M068
 43179                                  ;
 43180                                  ; 	Procedure Name	: IsCopyProt
 43181                                  ;
 43182                                  ;	Inputs		: DS:100 -> start of com file just read in
 43183                                  ;
 43184                                  ;	Outputs		: sets the A20OFF_COUNT variable to 10 if 
 43185                                  ;			  the program loaded in DS:100 uses a MICROSOFT
 43186                                  ;			  copy protect scheme that relies on the A20 line
 43187                                  ;			  being turned off for it's scheme to work.
 43188                                  ;
 43189                                  ;			  Note: The int 21 function dispatcher will turn 
 43190                                  ;				a20 off, if the A20OFF_COUNT is non-zero 
 43191                                  ;				and dec the A20OFF_COUNT before	iretting 
 43192                                  ;				to the user. 
 43193                                  ;
 43194                                  ;	Uses		: ES, DI, SI, CX
 43195                                  ;
 43196                                  ;---------------------------------------------------------------------------
 43197                                  
 43198                                  ; 23/05/2019 - Retro DOS v4.0
 43199                                  
 43200                                  CPStartOffset	EQU	0175h
 43201                                  CPID1Offset	EQU	011Bh
 43202                                  CPID2Offset	EQU	0173h
 43203                                  CPID3Offset	EQU	0146h
 43204                                  CPID4Offset	EQU	0124h
 43205                                  ID1		EQU	05343h
 43206                                  ID2		EQU	05044h
 43207                                  ID3		EQU	0F413h
 43208                                  ID4		EQU	08000h
 43209                                  
 43210                                  ; DOSCODE:B9FAh (MSDOS 6.21, MSDOS.SYS)
 43211                                  
 43212                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43213                                  ; DOSCODE:B71Ch (MSDOS 5.0, MSDOS.SYS)
 43214                                  
 43215                                  CPScanPattern:
 43216 00007450 89264801                	db	89h,26h,48h,01h		 ; mov [148],sp
 43217 00007454 8C0E4C01                	db	8Ch,0Eh,4Ch,01h		 ; mov [14C],cs
 43218 00007458 C7064A010001            	db	0C7h,06h,4Ah,01h,00h,01h ; mov [14A],100h 
 43219 0000745E 8C0E1301                	db 	8Ch,0Eh,13h,01h		 ; mov [113],cs
 43220 00007462 B82001                  	db	0B8h,20h,01h		 ; mov ax,120h
 43221 00007465 BE0001                  	db	0BEh,00h,01h		 ; mov si,100h
 43222                                  
 43223                                  CPSPlen	EQU $ - CPScanPattern
 43224                                  
 43225                                  ; DOSCODE:BA12h (MSDOS 6.21, MSDOS.SYS)
 43226                                  ; DOSCODE:B734h (MSDOS 5.0, MSDOS.SYS)
 43227                                  
 43228                                  IsCopyProt:
 43229 00007468 813E1B014353            	cmp	word [CPID1Offset],ID1
 43230 0000746E 752D                    	jne	short CP_done
 43231                                  
 43232 00007470 813E73014450            	cmp	word [CPID2Offset],ID2
 43233 00007476 7525                    	jne	short CP_done
 43234                                  
 43235 00007478 813E460113F4            	cmp	word [CPID3Offset],ID3
 43236 0000747E 751D                    	jne	short CP_done
 43237                                  
 43238 00007480 813E24010080            	cmp	word [CPID4Offset],ID4
 43239 00007486 7515                    	jne	short CP_done
 43240                                  
 43241 00007488 0E                      	push	cs
 43242 00007489 07                      	pop	es
 43243 0000748A BF[5074]                	mov	di,CPScanPattern	; es:di -> Pattern to find
 43244                                  
 43245 0000748D BE7501                  	mov	si,CPStartOffset	; ds:si -> possible location 
 43246                                  					; of pattern
 43247                                  
 43248 00007490 B91800                  	mov	cx,CPSPlen ; 24		; cx = length of pattern
 43249 00007493 F3A6                    	repe	cmpsb
 43250 00007495 7506                    	jnz	short CP_done
 43251                                  
 43252 00007497 36C606[8500]0A          	mov	byte [ss:A20OFF_COUNT],0Ah ; M071
 43253                                  CP_done:
 43254 0000749D C3                      	retn
 43255                                  	
 43256                                  ;DOSCODE ENDS
 43257                                  
 43258                                  	;END
 43259                                  
 43260                                  ;----------------------------------------------------------------------------
 43261                                  
 43262                                  ;align 2 ; 05/09/2018 (Error!)
 43263                                  
 43264                                  ; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43265                                  ;align 16 ; 08/09/2018 (OK.)
 43266                                  align 2
 43267                                  
 43268                                  ; 06/08/2018 - Retro DOS v3.0
 43269                                  ;============================================================================
 43270                                  ; MSINIT.ASM
 43271                                  ;============================================================================
 43272                                  ; 22/04/2019 - Retro DOS v4.0 (MSINIT.ASM, MSDOS 6.0, 1991)
 43273                                  ;
 43274                                  ; MAIN ENTRY FOR DOS INITIALIZATION
 43275                                  ;
 43276                                  	; 15/07/2018 - Retro DOS v3.0
 43277                                  	; (MSDOS 3.3, IBMDOS.COM, 1987)
 43278                                  
 43279                                  ; temp iret instruction
 43280                                  
 43281                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43282                                  ; DOSCODE:B76Ah (MSDOS 5.0, MSDOS.SYS)
 43283                                  
 43284                                  initiret: ; MSDOS 6.0
 43285                                  SYSBUF:
 43286                                  ;IRETT: ; 06/05/2019
 43287 0000749E CF                      	iret
 43288                                  
 43289                                  ; 22/04/2019 - Retro DOS v4.0
 43290                                  
 43291                                  ; pointer to the BIOS data segment that will be available just to the
 43292                                  ; initialization code
 43293                                  
 43294 0000749F 7000                    InitBioDataSeg:	dw 70h ; KERNEL_SEGMENT = 0070h
 43295                                  
 43296                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43297                                  ; DOSCODE:B76Dh (MSDOS 5.0, MSDOS.SYS)
 43298                                  
 43299                                  ; Convert AX from a number of bytes to a number of paragraphs (round up).
 43300                                  
 43301                                  ParaRound:
 43302 000074A1 83C00F                  	add	ax, 15
 43303 000074A4 D1D8                    	rcr	ax, 1
 43304 000074A6 D1E8                    	shr	ax, 1
 43305 000074A8 D1E8                    	shr	ax, 1
 43306 000074AA D1E8                    	shr	ax, 1
 43307 000074AC C3                      	retn
 43308                                  
 43309                                  ; MAIN ENTRY FOR DOS INITIALIZATION
 43310                                  
 43311                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43312                                  	; DOSCODE:B779h (MSDOS 5.0, MSDOS.SYS)
 43313                                  	
 43314                                  	; 30/05/2019
 43315                                  	; 22/04/2019 - Retro DOS v4.0
 43316                                  	; 07/07/2018 - Retro DOS v3.0
 43317                                  	; Retro DOS v2.0 - 03/03/2018
 43318                                  	; 03/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43319                                  	; MSDOS 5.0 - MSDOS.SYS, offset 79A9h
 43320                                  DOSINIT:
 43321                                  	; MSDOS 6.21 - MSDOS.SYS, offset 7C77h
 43322                                  	;
 43323                                  	; Far call from SYSINIT
 43324                                  	; DX = Memory size in paragraphs
 43325                                  	; DS:SI = [DEVICE_LIST] (SYSINIT.S) 
 43326                                  	;	  (Retro DOS v2.0, 16/03/2018)
 43327                                  	;
 43328                                  	; ES:DI = ptr to BIOS communication block (sysinit3.s)
 43329                                  	;	  (Retro DOS v4.0, 20/04/2019)
 43330                                  
 43331 000074AD FA                              CLI
 43332 000074AE FC                              CLD
 43333                                  
 43334                                  	; 03/11/2022
 43335                                  	;push	dx ; 30/05/2019		; save parameters from BIOS
 43336                                  	
 43337                                  	; 17/12/2022
 43338                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43339                                  	;push	dx ; =*=		; save parameters from BIOS
 43340                                  	
 43341 000074AF 56                      	push	si
 43342 000074B0 1E                      	push	ds
 43343 000074B1 57                      	push	di			;save di (ptr to BiosComBlock)
 43344                                  
 43345 000074B2 8CC3                    	mov	bx,es			;bx:di = ptr to BiosComBlock
 43346                                  
 43347                                  ; First, move the DOS data segment to its final location in low memory
 43348                                  
 43349                                  	;;mov	ax,0BF69h ; MSDOS 6.21 MSDOS.SYS, file offset 7C7Fh
 43350                                  	;mov	ax,0BC77h ; MSDOS 5.0 MSDOS.SYS, file offset 79B1h
 43351 000074B4 B8[2379]                	mov	ax,MEMSTRT		; get offset of end of init code
 43352                                  
 43353                                  	;add	ax,15	; 0Fh		; round to nearest paragraph
 43354                                  	;and	ax,~15	; 0FFF0h	; boundary
 43355                                  
 43356                                  	;mov	si,ax			; si = offset of DOSDATA in current
 43357                                  					; code segment
 43358                                  
 43359                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43360 000074B7 83C00F                  	add	ax,15			; round to nearest paragraph
 43361                                  	;and	ax,~15			; boundary
 43362                                  	; 12/04/2024
 43363 000074BA 24F0                    	and	al,0F0h
 43364                                  
 43365 000074BC 89C6                    	mov	si,ax			; si = offset of DOSDATA in current
 43366                                  					; code segment
 43367                                  	; 05/12/2022
 43368                                  	; 30/04/2019 - Retro DOS v4.0
 43369                                  	;xor	si,si
 43370                                  	
 43371                                  	;mov	ax,cs
 43372                                  	;mov	ds,ax			; ds = current code segment
 43373                                  					; DS:SI now points to dosdata
 43374                                  	; 22/03/2024
 43375 000074BE 0E                      	push	cs
 43376 000074BF 1F                      	pop	ds
 43377                                  
 43378                                  	;mov	es,[cs:0BA49h] ; MSDOS 6.21 IO.SYS, offset 7C8Eh 
 43379                                  	;mov	es,[cs:InitBioDataSeg]	; First access to DosDataSg in
 43380                                  					;  BData segment. Cannot use
 43381                                  					;  getdseg macro here!!!
 43382                                  	; 17/12/2022
 43383 000074C0 8E06[9F74]              	mov	es,[InitBioDataSeg]
 43384                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43385                                  	;mov	es,[cs:InitBioDataSeg]  ; ds = cs !
 43386                                  
 43387                                  	;mov	es,[es:3]
 43388 000074C4 268E060300              	mov	es,[es:DosDataSg]	; Get free location in low memory
 43389                                  
 43390 000074C9 31FF                    	xor	di,di			; ES:DI now points to RAM data
 43391                                  
 43392                                  	;mov	cx,4970  ; Offset 0BA78h in MSDOS 6.21 MSDOS.SYS)
 43393                                  	;mov	cx,4976  ; 25/05/2019
 43394                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43395                                  	;mov	cx,4962
 43396                                  	;mov	cx,MSDAT001E		; get end of dosdata = size of dosdata
 43397 000074CB B9CF12                  	mov	cx,DOSDATASIZE ; = 4962 for MSDOS 5.0 MSDOS.SYS
 43398 000074CE F3A4                    	rep	movsb			; move data to final location
 43399                                  	
 43400 000074D0 5F                      	pop	di			; restore ptr to BiosComBlock
 43401 000074D1 1F                      	pop	ds			; restore parms from BIOS
 43402 000074D2 5E                      	pop	si
 43403                                  	; 17/12/2022
 43404                                  	;pop	dx ; 30/05/2019
 43405                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43406                                  	;pop	dx ; =*=
 43407                                  
 43408 000074D3 06                      	push	es
 43409 000074D4 1E                      	push	ds
 43410 000074D5 07                      	pop	es			; es:si -> device chain
 43411 000074D6 1F                      	pop	ds			; ds points to dosdata
 43412                                  
 43413                                  ;SR;
 43414                                  ;We get a ptr to the BIOS exchange data block. This has been setup right
 43415                                  ;now so that the EXEC call knows when SysInit is present to do the special
 43416                                  ;lie table handling for device drivers. This can be expanded later on to
 43417                                  ;establish a communication block from the BIOS to the DOS.
 43418                                  
 43419                                  	;mov	[1040h],di	; Offset 0BA87h in MSDOS 6.21 MSDOS.SYS)
 43420                                  	;mov	[1042h],bx
 43421 000074D7 893E[4010]              	mov	[BiosDataPtr],di
 43422 000074DB 891E[4210]              	mov	[BiosDataPtr+2],bx	; save ptr to BiosComBlock
 43423                                  
 43424 000074DF 2E8C1E[0700]            	mov	[cs:DosDSeg],ds		; set pointer to dosdata in code seg
 43425                                  
 43426                                  	; Set the segment of Lowint23/24/28Addr in msctrlc.asm to dosdata
 43427                                  
 43428 000074E4 2E8C1E[214F]            	mov	[cs:LowInt23Addr+2],ds	; set pointers in code seg
 43429 000074E9 2E8C1E[254F]            	mov	[cs:LowInt24Addr+2],ds
 43430 000074EE 2E8C1E[294F]            	mov	[cs:LowInt28Addr+2],ds
 43431                                  
 43432                                  	;mov	[346h],dx	; MSDOS 6.21 DOSDATA addresses
 43433                                  	;mov	[584h],sp
 43434                                  	;mov	[586h],ss
 43435 000074F3 8916[4603]                  	mov	[ENDMEM],dx	; =*=
 43436 000074F7 8926[8405]              	mov	[USER_SP],sp
 43437 000074FB 8C16[8605]              	mov	[USER_SS],ss
 43438                                  
 43439                                  	;mov	ax,ds		; set up ss:sp to dosdata:dskstack
 43440                                  	;mov	ss,ax
 43441                                  	; 01/07/2024
 43442 000074FF 1E                      	push	ds
 43443 00007500 17                      	pop	ss
 43444                                  
 43445                                  	;mov	sp,920h		; MSDOS 6.21 DOSDATA address
 43446                                  	;mov	sp,offset dosdata:dskstack
 43447 00007501 BC[2009]                	mov	sp,DSKSTACK
 43448                                  
 43449                                  ;M023
 43450                                  ; Init patch ptrs to default values
 43451                                  
 43452                                  ; 22/03/2024
 43453                                  %if 0
 43454                                  	;mov	word [1212h],RetExePatch
 43455                                  	;mov	word [1214h],RetExePatch
 43456                                  	;mov	word [61h],RetExePatch
 43457                                  	mov	word [FixExePatch],RetExePatch	; M023
 43458                                  	; 28/12/2022 - Retro DOS v4.1
 43459                                  	;mov	word [RationalPatchPtr],RetExePatch ; M023
 43460                                  	mov	word [ChkCopyProt],RetExePatch	; M068
 43461                                  %else
 43462                                  	; 22/03/2024 (PCDOS 7.1 IBMDOS.COM)
 43463                                  	;;;	
 43464 00007504 B8[8160]                	mov	ax,RetExePatch
 43465 00007507 A3[1212]                	mov	[FixExePatch],ax
 43466                                  	;mov	[RationalPatchPtr],ax
 43467 0000750A A3[6100]                	mov	[ChkCopyProt],ax
 43468                                  	;;;
 43469                                  %endif
 43470                                  
 43471                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43472                                  %if 0	; 19/09/2023
 43473                                  
 43474                                  ; Setup to call 386 Rational DOS Extender patch routine if running on
 43475                                  ; a 386 or later. Unlike other patches, this is not dependent on MS-DOS
 43476                                  ; running in the HMA.
 43477                                  
 43478                                  	call	WhatCPUType	; get cpu type (0 < 286,1==286,2 >= 386)
 43479                                  	cmp	al,2		;   386 or later?
 43480                                  	mov	ax,Rational386Patch
 43481                                  	jae	short di_set_patch
 43482                                  	mov	ax,RetExePatch	; < 386, don't need this patch
 43483                                  di_set_patch:
 43484                                  	mov	[Rational386PatchPtr],ax ; patch routine or RET instr.
 43485                                  
 43486                                  %endif
 43487                                  	; Set up the variable temp_dosloc to point to the dos code segment
 43488                                  
 43489 0000750D 8CC8                    	mov	ax,cs		; ax = current segment of DOS code
 43490                                  
 43491                                  	; ax now holds segment of DOS code
 43492 0000750F A3[AA0A]                	mov	[TEMP_DOSLOC],ax   ; store temp location of DOS
 43493                                  
 43494 00007512 8C06[4A00]              	mov	word [NULDEV+2],es ; nuldev -> points to device chain
 43495 00007516 8936[4800]              	mov	word [NULDEV],si
 43496                                  ;SR;
 43497                                  ; There are some locations in the Win386 instance data structures
 43498                                  ; which need to be set up with the DOS data segment. First, initialize
 43499                                  ; the segment part of the instance table pointer in the SIS.
 43500                                  
 43501                                  	;mov	[0FF2h],ds ; [Win386_Info+14+2]
 43502 0000751A 8C1E[F20F]              	mov	[Win386_Info+Win386_SIS.Instance_Data_Ptr+2],ds
 43503                                  
 43504                                  ; Now initialize the segment part of the pointer to the data in each
 43505                                  ; instance table entry.
 43506                                  
 43507 0000751E 56                      	push	si		; preserve pointer to device chain
 43508                                  	; 18/12/2022
 43509                                  	; cx = 0
 43510 0000751F B107                    	mov	cl,7
 43511                                  	;mov	cx,7		; There are 7 entries in the instance table
 43512                                  				; M019
 43513                                  	;mov	si,0FF6h ; offset (dosdata:Instance_Table+2)
 43514 00007521 BE[F60F]                	mov	si,Instance_Table+2 ; point si to segment field
 43515                                  Instance_init_loop:
 43516 00007524 8C1C                    	mov	[si],ds		; set offset in instance entry
 43517                                  	;add	si,6
 43518 00007526 83C606                  	add	si,size_of_Win386_IIS ; move on to next entry
 43519 00007529 E2F9                    	loop	Instance_init_loop
 43520                                  
 43521                                  ;Initialize the WIN386 2.xx instance table with the DOS data segment value
 43522                                  
 43523                                  	; 18/12/2022
 43524 0000752B B105                    	mov	cl,5
 43525                                  	;mov	cx,5		; There are five entries in the instance table
 43526                                  
 43527                                  	;mov	si,(offset dosdata:OldInstanceJunk) + 6
 43528                                  	;mov	si,11EDh	; point si to segment field
 43529 0000752D BE[ED11]                	mov	si,OldInstanceJunk+6
 43530                                  OldInstance_init_loop:
 43531 00007530 8C1C                    	mov	[si],ds		; set offset in instance entry
 43532 00007532 83C606                  	add	si,6		; move on to next entry
 43533 00007535 E2F9                    	loop	OldInstance_init_loop
 43534 00007537 5E                      	pop	si		; restore pointer to device chain
 43535                                  
 43536                                  ; End of WIN386 2.xx compatibility bullshit
 43537                                  
 43538                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43539                                  %if 0	
 43540                                     	; 30/04/2019
 43541                                  	;push	es
 43542                                  	;pop	ds
 43543                                  			; ds:si points to console device
 43544                                  
 43545                                  	; 24/04/2019 - Retro DOS v4.0
 43546                                  
 43547                                  	; 15/07/2018
 43548                                  	; MSDOS 3.3 (IBMDOS.COM, 1987)
 43549                                  	; (Set INT 2Ah handler address to an 'IRET')
 43550                                  
 43551                                  	; need crit vector inited to use deviocall
 43552                                  	;push	ds			; preserve segment of device chain
 43553                                  	push	es ; 30/04/2019
 43554                                  
 43555                                  %endif
 43556                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43557 00007538 06                      	push	es
 43558                                  	; 17/12/2022
 43559                                  	;pop	ds
 43560                                  	;push	ds
 43561                                  
 43562 00007539 31C0                    	xor	ax,ax
 43563 0000753B 8ED8                    	mov	ds,ax			; point DS to int vector table
 43564 0000753D B8[9E74]                	mov	ax,initiret
 43565                                  	;mov	[0A8h],ax  ; [2Ah*4]
 43566 00007540 A3A800                  	mov	[addr_int_ibm],ax
 43567 00007543 8CC8                    	mov	ax,cs
 43568                                  	;mov	[0AAh],ax  ; [(2Ah*4)+2]
 43569 00007545 A3AA00                  	mov	[addr_int_ibm+2],ax
 43570 00007548 1F                      	pop	ds			; restore segment of device chain
 43571                                  
 43572 00007549 E81A02                  	call	CHARINIT  		; initialize console driver
 43573 0000754C 56                      	push	si			; save pointer to header
 43574                                  
 43575 0000754D 16                      	push	ss			; move pointer to dos data...
 43576 0000754E 07                      	pop	es			; ...into ES
 43577                                  
 43578                                  	;initialize sft for file 0 (CON)
 43579                                  
 43580                                          ; 07/07/2018 - Retro DOS v3.0
 43581                                  	; 24/04/2019 - Retro DOS v4.0
 43582                                  	;mov	di,SFTABL+6 
 43583 0000754F BF[D200]                	MOV	DI,SFTABL+SFT.SFTable	; Point to sft 0
 43584 00007552 B80300                  	MOV	AX,3
 43585 00007555 AB                      	STOSW           	; Refcount
 43586                                          ;DEC	AL
 43587                                  	; 22/03/2024
 43588 00007556 48                      	dec	ax
 43589 00007557 AB                      	STOSW			; Access rd/wr, compatibility
 43590 00007558 30C0                    	XOR	AL,AL
 43591 0000755A AA                      	STOSB           	; attribute
 43592                                  	;mov	al,0C3h
 43593 0000755B B0C3                    	mov	al,devid_device_EOF|devid_device|ISCIN|ISCOUT
 43594 0000755D AB                      	STOSW			; flags
 43595 0000755E 89F0                    	mov	ax,si
 43596 00007560 AB                      	stosw			; device pointer in devptr
 43597 00007561 8CD8                    	mov	ax,ds
 43598 00007563 AB                      	stosw
 43599 00007564 31C0                    	xor	ax,ax	; 0
 43600 00007566 AB                      	stosw			; firclus
 43601 00007567 AB                      	stosw			; time
 43602 00007568 AB                      	stosw			; date
 43603 00007569 48                      	dec	ax	; -1
 43604 0000756A AB                      	stosw			; size
 43605 0000756B AB                      	stosw
 43606 0000756C 40                      	inc	ax	; 0
 43607 0000756D AB                      	stosw			; position
 43608 0000756E AB                      	stosw
 43609                                  	;add	di,7
 43610 0000756F 83C707                  	add	di,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
 43611                                  				; point at name
 43612                                  	;add	si,10
 43613 00007572 83C60A                  	add	si,SYSDEV.NAME	; sdevname
 43614                                  				; point to name
 43615 00007575 B90400                  	mov	cx,4
 43616 00007578 F3A5                    	rep	movsw		; name
 43617 0000757A B103                    	mov	cl,3
 43618 0000757C B020                    	mov	al," "
 43619 0000757E F3AA                    	rep	stosb		; extension
 43620                                  
 43621 00007580 5E                      	pop	si		; get back pointer to header
 43622                                  
 43623                                  				; mark device as CON I/O
 43624                                  	; 15/07/2018
 43625                                          ;OR	BYTE [SI+4],ISCIN|ISCOUT ; or byte [si+4],3
 43626 00007581 804C0403                	OR	BYTE [SI+SYSDEV.ATT],ISCIN|ISCOUT
 43627                                  	; 12/03/2018
 43628                                  	;mov	[ss:32h],si
 43629 00007585 368936[3200]            	MOV     [SS:BCON],SI
 43630                                  	;mov	[ss:34h],ds
 43631 0000758A 368C1E[3400]                    MOV     [SS:BCON+2],DS
 43632                                  
 43633                                  	; initialize each device until the clock device is found
 43634                                  
 43635                                  CHAR_INIT_LOOP:
 43636 0000758F C534                            LDS     SI,[SI]			; AUX device
 43637 00007591 E8D201                  	call	CHARINIT
 43638                                         	;15/07/2018
 43639                                  	;test	byte [SI+4],8
 43640 00007594 F6440408                	TEST    BYTE [SI+SYSDEV.ATT],ISCLOCK
 43641 00007598 74F5                            JZ      SHORT CHAR_INIT_LOOP
 43642                                  	; 12/03/2018
 43643                                  	;mov	[ss:2Eh],si
 43644 0000759A 368936[2E00]                    MOV     [SS:BCLOCK],SI
 43645                                  	;mov	[ss:30h],ds
 43646 0000759F 368C1E[3000]                    MOV     [SS:BCLOCK+2],DS
 43647                                          ;MOV	BP,MEMSTRT ; Retro DOS 3.0 ; ES:BP points to DPB
 43648                                  
 43649                                  	;mov	bp,4970			; bp = pointer to free mem
 43650                                  	;mov	bp,4976  ; 25/05/2019 - Retro DOS v4.0
 43651                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
 43652                                  	;mov	bp,4962 ; (MSDOS 5.0 MSDOS.SYS)
 43653 000075A4 BDCF12                  	mov	bp,MSDAT001E		; es:bp points to dpb area
 43654                                  
 43655 000075A7 36892E[2600]            	mov	[ss:DPBHEAD],bp		; set offset of pointer to DPB's
 43656 000075AC 368C06[2800]            	mov	[ss:DPBHEAD+2],es	; set segment of pointer to DPB's
 43657                                  PERDRV:
 43658                                  	;lds	si,[SI+SYSDEV.NEXT] ; 15/07/2018
 43659 000075B1 C534                            LDS	SI,[SI]			; Next device
 43660 000075B3 83FEFF                          CMP	SI,-1	; 0FFFFh
 43661 000075B6 7479                    	JZ	SHORT CONTINIT
 43662                                  
 43663 000075B8 E8AB01                          call	CHARINIT
 43664                                  
 43665                                  	; Retro DOS v2.0 - 16/03/2018 (NOTE for 'CHARINIT' return):
 43666                                  	; [CALLUNIT] = Number of drives for (Disk) Block Dev Driver ([DRVMAX])
 43667                                  	;           (..When the command is 'DSK$INIT', as in 'CHARINIT')
 43668                                  	; [CALLBPB] = [DEVCALL.COUNT] = Address of the BPB (DEVCALL offset 18) 
 43669                                  	; (REF: MSDOS 3.3 MSBIO2.ASM, MSDATA.INC, MSDISK.ASM, MSBIO1.ASM)
 43670                                  	; (.. !DSK$IN' in MSBIO1.ASM)
 43671                                  	; DEVCALL.MEDIA = CALLUNIT (DEVCALL offset 13)
 43672                                  
 43673                                          ; 15/07/2018
 43674                                  	;test	word [SI+4],8000h		; DEVTYP
 43675                                          ; 17/12/2022
 43676                                  	;test	byte [SI+5],80h
 43677 000075BB F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8) ; 80h
 43678                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP ; 8000h
 43679 000075BF 75F0                    	JNZ     SHORT PERDRV			; Skip any other character devs
 43680                                  
 43681 000075C1 368A0E[6703]                    MOV	CL,[SS:CALLUNIT] ; 12/03/2018
 43682 000075C6 30ED                    	XOR     CH,CH
 43683                                          ; 07/07/2018
 43684                                  	;MOV	[SI+10],CL		; Number of units in name field
 43685 000075C8 884C0A                  	mov	[si+SYSDEV.NAME],cl	; sdevname
 43686 000075CB 368A16[4600]            	MOV     DL,[SS:NUMIO]	; 15/03/2018
 43687 000075D0 30F6                    	XOR     DH,DH
 43688 000075D2 36000E[4600]            	ADD	[SS:NUMIO],CL	; 12/03/2018
 43689 000075D7 1E                      	PUSH    DS
 43690 000075D8 56                              PUSH    SI
 43691 000075D9 36C51E[6C03]            	LDS	BX,[SS:CALLBPB]	; 12/03/2018
 43692                                  
 43693                                  PERUNIT:
 43694 000075DE 8B37                            MOV     SI,[BX]                 ; DS:SI Points to BPB
 43695 000075E0 43                              INC     BX
 43696 000075E1 43                              INC     BX                      ; On to next BPB
 43697                                  	; 15/12/2022
 43698                                  	; 07/07/2018
 43699                                          ;mov	[ES:BP+DPB.DRIVE],DL
 43700 000075E2 26885600                	MOV     [ES:BP],DL
 43701                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43702                                  	;;mov	[ES:BP+0],DL
 43703                                  	;mov	[ES:BP+DPB.DRIVE],DL
 43704                                  
 43705                                  	;MOV	[ES:BP+1],DH
 43706 000075E6 26887601                	MOV	[ES:BP+DPB.UNIT],DH
 43707 000075EA 53                              PUSH    BX
 43708 000075EB 51                              PUSH    CX
 43709 000075EC 52                              PUSH    DX
 43710                                  
 43711                                          ;invoke	$SETDPB
 43712 000075ED E8BE99                          CALL	_$SETDPB		; build DPB!
 43713                                  
 43714                                  	; 07/07/2018
 43715                                  	;MOV	AX,[ES:BP+2]
 43716 000075F0 268B4602                	mov	ax,[ES:BP+DPB.SECTOR_SIZE]
 43717                                          ; 12/03/2018
 43718 000075F4 363B06[3600]            	CMP	AX,[SS:MAXSEC]		; Q:is this the largest sector so far
 43719 000075F9 7604                    	JBE     SHORT NOTMAX		; N:
 43720 000075FB 36A3[3600]              	MOV	[SS:MAXSEC],AX		; Y: save it in maxsec
 43721                                  NOTMAX:					
 43722                                  	; set the next dpb field in the currently built bpb
 43723                                  	; and mark as never accessed
 43724                                          
 43725                                  	; 24/04/2019
 43726 000075FF 89E8                    	mov	ax,bp			; get pointer to DPB
 43727                                  	;add	ax,33
 43728 00007601 83C021                  	add	ax,DPBSIZ		; advance pointer to next DPB
 43729                                  					; set seg & offset of next DPB
 43730                                  	;mov	[es:bp+25],ax
 43731 00007604 26894619                	mov	[es:bp+DPB.NEXT_DPB],ax
 43732                                  	;mov	[es:bp+27],es
 43733 00007608 268C461B                	mov	[es:bp+DPB.NEXT_DPB+2],es
 43734                                  					; mark as never accessed
 43735                                  	;mov	byte [es:bp+24],0FFh
 43736 0000760C 26C64618FF              	mov	byte [es:bp+DPB.FIRST_ACCESS],-1
 43737                                  
 43738 00007611 5A                      	POP     DX
 43739 00007612 59                              POP     CX
 43740 00007613 5B                              POP     BX
 43741 00007614 8CD8                            MOV     AX,DS                   ; save segment of bpb array
 43742 00007616 5E                              POP     SI
 43743 00007617 1F                              POP     DS
 43744                                  					; ds:si -> device header
 43745                                  					; store it in the corresponding dpb
 43746                                  	; 07/07/2018
 43747                                  	;MOV	[ES:BP+19],SI ; 24/04/2019
 43748 00007618 26897613                	mov	[ES:BP+DPB.DRIVER_ADDR],si
 43749                                  	;MOV	[ES:BP+21],DS ; 24/04/2019
 43750 0000761C 268C5E15                	mov	[ES:BP+DPB.DRIVER_ADDR+2],ds
 43751                                  
 43752 00007620 1E                      	PUSH	DS			; save pointer to device header
 43753 00007621 56                      	PUSH	SI
 43754 00007622 FEC6                    	INC	DH			; inc unit #
 43755 00007624 FEC2                    	INC	DL			; inc drive #
 43756 00007626 8ED8                    	MOV	DS,AX			; restore segment of BPB array
 43757                                  	;add	bp,33 ; 24/04/2019
 43758 00007628 83C521                  	ADD	BP,DPBSIZ		; advance pointer to next dpb
 43759 0000762B E2B1                    	LOOP	PERUNIT			; process all units in each driver
 43760                                  
 43761 0000762D 5E                      	POP     SI			; restore pointer to device header
 43762 0000762E 1F                      	POP     DS
 43763 0000762F EB80                    	JMP	PERDRV			; process all drivers in chain
 43764                                  
 43765                                  CONTINIT:
 43766                                  	; 24/04/2019
 43767                                  	;sub	bp,33			; set link in last DPB to -1
 43768 00007631 83ED21                  	sub	bp,DPBSIZ		; back up to last dpb
 43769                                  					; set last link offset & segment
 43770                                  ; 23/03/2024 - Retro DOS v4.2
 43771                                  %if 0
 43772                                  	;mov	word [bp+25],0FFFFh
 43773                                  	mov	word [bp+DPB.NEXT_DPB],-1
 43774                                  	;mov	word [bp+27],0FFFFh
 43775                                  	mov	word [bp+DPB.NEXT_DPB+2],-1
 43776                                  %else
 43777                                  	; 23/03/2024 (PCDOS 7.1 IBMDOS.COM)
 43778                                  	;;;
 43779 00007634 B8FFFF                  	mov	ax,0FFFFh ; -1
 43780                                  	;mov	word [bp+25],ax
 43781 00007637 894619                  	mov	word [bp+DPB.NEXT_DPB],ax ; -1
 43782                                  	;mov	word [bp+27],ax
 43783 0000763A 89461B                  	mov	word [bp+DPB.NEXT_DPB+2],ax ; -1
 43784                                  	;;;
 43785                                  %endif
 43786                                  	;add	bp,33
 43787 0000763D 83C521                  	add	BP,DPBSIZ		; advance to free memory again
 43788                                  					; the DPB chain is done.
 43789 00007640 16                      	push	ss
 43790 00007641 1F                      	pop	ds
 43791                                  
 43792 00007642 89E8                    	mov	ax,bp
 43793 00007644 E85AFE                  	call	ParaRound		; round up to segment
 43794                                  
 43795 00007647 8CDA                    	mov	dx,ds			; dx = dosdata segment
 43796 00007649 01C2                    	add	dx,ax			; dx = ds+ax first free segment
 43797                                  
 43798 0000764B BB0F00                  	mov	bx,0Fh
 43799                                  	
 43800                                  	; 24/05/2019
 43801                                  	;mov	cx,[ENDMEM]
 43802                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43803                                  	; 17/12/2022
 43804                                  	;mov	cx,[ENDMEM] 
 43805                                  					; set seg inpacketto dosdata
 43806 0000764E 8C1E[A203]              	mov	[DSKCHRET+3],ds ; mov [DOSSEG_INIT],ds
 43807                                  
 43808                                  ; Patch in the segments of the interrupt vectors with current code segment.
 43809                                  ; Also patch in the segment of the pointers in the dosdata area.
 43810                                  ;
 43811                                  ; Note: Formerly, temp_dosloc was initialized to -1 until after these
 43812                                  ; calls were done. The procedure patch_misc_segments is called multiple
 43813                                  ; times, and relies on temp_dosloc being initialized to -1 as a flag
 43814                                  ; for the first invocation. Thus, we must set it to -1 for this call.
 43815                                  
 43816 00007652 52                      	push	dx			; preserve first free segment
 43817                                  
 43818 00007653 A1[AA0A]                	mov	ax,[TEMP_DOSLOC]	; ax = segment to patch in 
 43819 00007656 8EC0                    	mov	es,ax			; es = segment of DOS
 43820 00007658 C706[AA0A]FFFF          	mov	word [TEMP_DOSLOC],-1	; -1 means first call to patch_misc_segments
 43821                                  
 43822 0000765E E8AF01                  	call	patch_vec_segments	; uses AX as doscode segment
 43823 00007661 E8E401                  	call	patch_misc_segments	; patch in segments for sharer and
 43824                                  					; other tables with seg in ES.
 43825                                  	; 17/12/2022
 43826                                  	; cx = 0
 43827 00007664 8C06[AA0A]              	mov	[TEMP_DOSLOC],es	; put back segment of dos code
 43828                                  
 43829 00007668 5A                      	pop	dx			; restore first free segment
 43830                                  
 43831                                  ; We shall now proceed to set the offsets of the interrupt vectors handled
 43832                                  ; by DOS to their appropriate values in DOSCODE. In case the DOS loads in
 43833                                  ; HIMEM the offsets also will be patched to their appropriate values in the
 43834                                  ; low_mem_stub by seg_reinit.
 43835                                  
 43836                                  	;xor	ax,ax ; 0
 43837                                  	;mov	ds,ax
 43838                                  	;mov	es,ax
 43839                                  	; 17/12/2022
 43840                                  	; cx = 0
 43841                                  	;xor	cx,cx ; 0
 43842 00007669 8ED9                    	mov	ds,cx
 43843 0000766B 8EC1                    	mov	es,cx
 43844                                  
 43845                                  	; set the segment of int 24 vector that was
 43846                                  	; left out by patch_vec_segments above.
 43847                                  
 43848                                  	; 17/12/2022
 43849                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43850                                  ;%if 0
 43851                                  	; 24/05/2019
 43852                                  	;;mov	di,90h
 43853                                  	;;mov	di,4*int_fatal_abort
 43854                                  	;mov	di,addr_int_fatal_abort
 43855 0000766D BF9200                  	mov	di,addr_int_fatal_abort+2 ; 24/05/2019
 43856                                  
 43857 00007670 36A1[AA0A]              	mov	ax,[ss:TEMP_DOSLOC]
 43858                                  	;mov	[di+2],ax  ; int 24h segment
 43859 00007674 8905                    	mov	[di],ax ; 24/05/2019
 43860                                  
 43861                                  	;;mov	di,82h
 43862                                  	;mov	di,INTBASE+2
 43863                                  
 43864                                  ;%endif
 43865                                  	; 17/12/2022
 43866                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43867                                  	;;mov	di,90h
 43868                                  	;;mov	di,4*int_fatal_abort
 43869                                  	;mov	di,addr_int_fatal_abort
 43870                                  	;mov	ax,[ss:TEMP_DOSLOC]
 43871                                  	;mov	[di+2],ax  ; int 24h segment
 43872                                  	;;mov	di,82h
 43873                                  	;mov	di,INTBASE+2
 43874                                  
 43875                                  	; set default divide trap offset
 43876                                  
 43877                                  	;mov	word ptr ds:[0],offset doscode:divov
 43878 00007676 C7060000[F850]          	mov	word [0],DIVOV
 43879                                  
 43880                                  	; set vectors 20-28 and 2a-3f to point to iret.
 43881                                  
 43882                                  	;mov	di,80h
 43883 0000767C BF8000                  	mov	di,INTBASE
 43884                                  	;mov	ax,offset doscode:irett
 43885 0000767F B8[E202]                	mov	ax,IRETT
 43886                                  
 43887                                  	; 17/12/2022
 43888                                  	; cx = 0
 43889 00007682 B109                    	mov	cl,9
 43890                                  	;mov	cx,9			; set 9 offsets (skip 2 between each)
 43891                                  					;   sets offsets for ints 20h-28h
 43892                                  iset1:
 43893 00007684 AB                      	stosw
 43894                                  	;add	di,2
 43895                                  	; 20/09/2023
 43896 00007685 47                      	inc	di
 43897 00007686 47                      	inc	di
 43898 00007687 E2FB                    	loop	iset1
 43899                                  
 43900 00007689 83C704                  	add	di,4			; skip vector 29h
 43901                                  
 43902                                  ;	mov	cx,6			; set 6 offsets (skip 2 between each)
 43903                                  ;					;   sets offsets for ints 2ah-2fh
 43904                                  ;iset2:
 43905                                  ;	stosw
 43906                                  ;	add	di,2
 43907                                  ;	loop	iset2
 43908                                  
 43909                                  ; 30h & 31H is the CPM call entry point whose segment address is set up by
 43910                                  ; patch_vec_segments above. So skip it.
 43911                                  
 43912                                  ;	add	di,8			; skip vector 30h & 31h 
 43913                                  
 43914                                  	;;;
 43915                                  	; 06/05/2019 - Retro DOS v4.0
 43916                                  	;mov	cx,5			; set offsets for int 2Ah-2Eh
 43917                                  	; 17/12/2022
 43918 0000768C B105                    	mov	cl,5 ; 28/06/2019
 43919                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43920                                  	;mov	cx,6
 43921                                  iset2:
 43922 0000768E AB                      	stosw
 43923                                  	;add	di,2
 43924                                  	; 20/09/2023
 43925 0000768F 47                      	inc	di
 43926 00007690 47                      	inc	di
 43927 00007691 E2FB                    	loop	iset2
 43928                                  
 43929                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43930                                  	; 17/12/2022
 43931 00007693 83C70C                  	add	di,12			; skip vectors 2Fh, 30h & 31h
 43932                                  	;add	di,8
 43933                                  	;;;
 43934                                  
 43935                                  	; 17/12/2022
 43936 00007696 B10E                    	mov	cl,14
 43937                                  	;mov	cx,14			; set 14 offsets (skip 2 between each)
 43938                                  					;   sets offsets for ints 32h-3fh
 43939                                  iset3:
 43940 00007698 AB                      	stosw
 43941                                  	;add	di,2
 43942                                  	; 20/09/2023
 43943 00007699 47                      	inc	di
 43944 0000769A 47                      	inc	di
 43945 0000769B E2FB                    	loop	iset3
 43946                                  
 43947                                  ;if installed
 43948                                  	; set the offset of int2f handler
 43949                                  	;mov	word [0BCh],INT2F
 43950 0000769D C706BC00[FD06]          	mov	word [02Fh*4],INT2F
 43951                                  	; set segment to doscode as we have to do int 2f to check for XMS
 43952 000076A3 36A1[AA0A]              	mov	ax,[ss:TEMP_DOSLOC]	; get segment of doscode
 43953                                  	;mov	[0BEh],ax
 43954 000076A7 A3BE00                  	mov	[(02Fh*4)+2],ax
 43955                                  ;endif
 43956                                  	; set up entry point call at vectors 30-31h. Note the segment of the 
 43957                                  	; long jump will be patched in by seg_reinit
 43958                                  
 43959                                  	;mov	byte [C0h],0EAh
 43960 000076AA C606C000EA              	mov	byte [ENTRYPOINT],mi_long_jmp
 43961                                  	;mov	byte [C1h],CALL_ENTRY
 43962 000076AF C706C100[E302]          	mov	word [ENTRYPOINT+1],CALL_ENTRY
 43963                                  
 43964 000076B5 C7068000[DC02]          	mov	word [addr_int_abort],QUIT	; INT 20h
 43965 000076BB C7068400[0803]          	mov	word [addr_int_command],COMMAND ; INT 21h
 43966 000076C1 C70688000001            	mov	word [addr_int_terminate],100h	; INT 22h
 43967 000076C7 89168A00                	mov	word [addr_int_terminate+2],dx
 43968 000076CB C7069400[2D05]          	mov	word [addr_int_disk_read],ABSDRD   ; INT 25h
 43969 000076D1 C7069800[B405]          	mov	word [addr_int_disk_write],ABSDWRT ; INT 26h 
 43970 000076D7 C7069C00[2460]          	mov	word [addr_int_keep_process],STAY_RESIDENT ; INT 27h
 43971                                  
 43972 000076DD 16                      	push	ss
 43973 000076DE 1F                      	pop	ds
 43974                                  	
 43975                                  	; 24/05/2019
 43976                                  	;push	ss
 43977                                  	;pop	es
 43978                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43979                                  	; 17/12/2022
 43980                                  	;push	ss
 43981                                  	;pop	es
 43982                                  
 43983 000076DF 52                      	push	dx			; remember address of arena
 43984                                  
 43985 000076E0 42                      	inc	dx			; leave room for arena header
 43986                                  	;mov	[330h],dx
 43987 000076E1 8916[3003]              	mov     [CurrentPDB],dx		; set current pdb
 43988                                  
 43989 000076E5 31FF                    	xor	di,di			; point es:di at end of memory
 43990 000076E7 8EC2                    	mov	es,dx			; ...where psp will be
 43991 000076E9 31C0                    	xor	ax,ax
 43992                                  	;mov	cx,80h			; psp is 128 words
 43993                                  	; 17/12/2022
 43994 000076EB B180                    	mov	cl,128 ; 28/06/2019
 43995                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43996                                  	;mov	cx,128
 43997                                  
 43998 000076ED F3AB                    	rep	stosw			; zero out psp area
 43999 000076EF A1[4603]                        mov     ax,[ENDMEM]
 44000                                  	
 44001                                  	; 17/12/2022
 44002                                  	; cx = 0
 44003 000076F2 E8079A                  	call	SETMEM         	 	; build psp at dx; ax is memory size
 44004                                  
 44005                                  	; ds, es now point to PSP
 44006                                  
 44007 000076F5 16                      	push	ss
 44008 000076F6 1F                      	pop	ds
 44009                                  
 44010                                  	;mov	di,24
 44011 000076F7 BF1800                  	mov	di,PDB.JFN_TABLE	; es:di -> pdb_jfn_table in psp
 44012 000076FA 31C0                    	xor	ax,ax
 44013 000076FC AB                      	stosw
 44014 000076FD AA                      	stosb				; 0,1 and 2 are con device
 44015 000076FE B0FF                    	mov	al,0FFh
 44016                                  	;mov	cx,FILPERPROC-3 ; 17
 44017                                  	; 17/12/2022
 44018                                  	; cx = 4
 44019 00007700 B111                    	mov	cl,FILPERPROC-3 ; 17
 44020 00007702 F3AA                    	rep	stosb			; rest are unused
 44021                                  
 44022 00007704 16                      	push	ss
 44023 00007705 07                      	pop	es
 44024                                  					; must be set to print messages
 44025 00007706 8C1E[2C00]              	mov	[SFT_ADDR+2],ds
 44026                                  
 44027                                  ; after this point the char device functions for con will work for
 44028                                  ; printing messages
 44029                                  
 44030                                  	; 24/04/2019 - Retro DOS v4.0
 44031                                  
 44032                                  ; 12/05/2019
 44033                                  ;
 44034                                  ;write_version_msg:
 44035                                  ;
 44036                                  ;	;if	(not ibm)
 44037                                  ;	;mov	si,offset doscode:header
 44038                                  ;	mov	si,HEADER
 44039                                  ;outmes:
 44040                                  ;	;lods	cs:byte ptr [si]
 44041                                  ;	cs
 44042                                  ;	lodsb
 44043                                  ;	cmp	al,"$"
 44044                                  ;	je	short outdone
 44045                                  ;	call	OUTT
 44046                                  ;	jmp	short outmes
 44047                                  ;outdone:
 44048                                  ;	push	ss			; out stomps on segments
 44049                                  ;	pop	ds
 44050                                  ;	push	ss
 44051                                  ;	pop	es
 44052                                  ;	;endif
 44053                                  
 44054                                  	; at this point es is dosdata
 44055                                  
 44056                                  	; Fill in the segment addresses of sysinitvar and country_cdpg 
 44057                                  	; in sysinittable (ms_data.asm)
 44058                                  
 44059                                  	;mov	si,0D28h
 44060 0000770A BE[280D]                	mov	si,SysInitTable
 44061                                  
 44062                                  	; 17/12/2022
 44063                                  	; ds = es = ss
 44064                                  
 44065                                  	; 17/12/2022
 44066                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 44067                                  ;%if 0
 44068                                  	;;mov	[es:si+6],es
 44069                                  	;mov	[es:si+SYSI_EXT.Country_Tab+2],es
 44070                                  	;;mov	[es:si+2],es
 44071                                  	;mov	[es:si+SYSI_EXT.SysInitVars+2],es
 44072                                  	
 44073 0000770D 8C4406                  	mov	[si+SYSI_EXT.Country_Tab+2],es
 44074 00007710 8C4402                  	mov	[si+SYSI_EXT.SysInitVars+2],es
 44075                                  
 44076                                  	; buffhead -> dosdata:hashinitvar
 44077                                  
 44078                                  	;mov	[es:BUFFHEAD+2],es	; BUGBUG - unused, remove this
 44079 00007713 8C06[3A00]              	mov	[BUFFHEAD+2],es
 44080                                  	;mov	si,offset dosdata:hashinitvar ; and all other references
 44081                                  	;mov	si,6Dh
 44082 00007717 BE[6D00]                	mov	si,HASHINITVAR
 44083                                  	;mov	[es:BUFFHEAD],si
 44084 0000771A 8936[3800]              	mov	[BUFFHEAD],si
 44085                                  
 44086 0000771E 5A                              pop     dx                      ; restore address of arena
 44087                                  
 44088                                  	;mov	[032Ch+2],dx
 44089 0000771F 8916[2E03]                      mov     [DMAADD+2],dx
 44090                                  
 44091                                  	;mov	[es:arena_head],dx
 44092 00007723 8916[2400]              	mov	[arena_head],dx
 44093                                  
 44094                                  ;%endif
 44095                                  
 44096                                  ; 17/12/2022
 44097                                  %if 0
 44098                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 44099                                  	;;;
 44100                                  	;mov	[es:si+6],es
 44101                                  	mov	[es:si+SYSI_EXT.Country_Tab+2],es
 44102                                  	;mov	[es:si+2],es
 44103                                  	mov	[es:si+SYSI_EXT.SysInitVars+2],es
 44104                                  
 44105                                  	; buffhead -> dosdata:hashinitvar 
 44106                                  
 44107                                  	mov	[es:BUFFHEAD+2],es	; BUGBUG - unused, remove this
 44108                                  	;mov	si,offset dosdata:hashinitvar ; and all other references
 44109                                  	;mov	si,6Dh
 44110                                  	mov	si,HASHINITVAR
 44111                                  	mov	[es:BUFFHEAD],si
 44112                                  
 44113                                          pop     dx                      ; restore address of arena
 44114                                  
 44115                                  	;mov	[032Ch+2],dx
 44116                                          mov     [DMAADD+2],dx
 44117                                  
 44118                                  	mov	[es:arena_head],dx
 44119                                  	;;;
 44120                                  %endif
 44121                                  
 44122 00007727 8EDA                            mov     ds,dx
 44123                                  
 44124                                  	;mov	byte [0],'Z'
 44125 00007729 C60600005A              	mov     byte [ARENA.SIGNATURE],arena_signature_end
 44126                                          ;mov	word [1],0
 44127 0000772E C70601000000            	mov     word [ARENA.OWNER],arena_owner_system
 44128                                  
 44129 00007734 36A1[4603]                      mov     ax,[ss:ENDMEM]
 44130 00007738 29D0                    	sub	ax,dx
 44131 0000773A 48                              dec     ax
 44132 0000773B A30300                          mov     [ARENA.SIZE],ax
 44133                                  
 44134                                  	; point to sft 0
 44135                                  
 44136                                  	;mov	di,offset dosdata:sftabl + sftable
 44137                                  	;mov	di,SFTABL+6
 44138 0000773E BF[D200]                	mov	di,SFTABL+SFT.SFTable
 44139 00007741 B80300                          mov     ax,3
 44140 00007744 AB                              stosw           		; adjust refcount
 44141                                  
 44142                                  	; es:di is shared data area i.e., es:di -> dosdata:sysinttable
 44143                                  
 44144                                  	;mov	di,offset dosdata:sysinittable
 44145                                  	;mov	di,0D28h
 44146 00007745 BF[280D]                	mov	di,SysInitTable	
 44147                                  
 44148 00007748 42                      	inc	dx			; advance dx from arena to psp
 44149 00007749 8EDA                    	mov	ds,dx			; point ds to psp
 44150                                  
 44151                                  					; pass the address os seg_reinit
 44152                                  					; in dx
 44153 0000774B BA[B977]                	mov	dx,seg_reinit
 44154 0000774E B9[F871]                	mov	cx,exepatch_start
 44155 00007751 81E9[0000]              	sub	cx,_$STARTCODE		; cx = (doscode - exepatch) - dosinit
 44156                                  
 44157 00007755 B8[9E74]                	mov	ax,SYSBUF
 44158 00007758 2D[0000]                	sub	ax,_$STARTCODE		; ax = size of doscode - dosinit
 44159                                  	
 44160 0000775B 368B26[8405]                    mov     sp,[ss:USER_SP]		; use ss override for next 2
 44161 00007760 368E16[8605]                    mov     ss,[ss:USER_SS]
 44162                                  
 44163 00007765 CB                              retf
 44164                                  
 44165                                  ;
 44166                                  ; END OF DOSINIT
 44167                                  ;
 44168                                  ;--------------------------------------------------------------------------
 44169                                  
 44170                                  CHARINIT:
 44171                                  	; 24/04/2019 - Retro DOS v4.0
 44172                                  	; 07/07/2018 - Retro DOS v3.0
 44173                                  	;mov	byte [ss:035Ah],26 ; 1Ah
 44174 00007766 36C606[5A03]1A                  MOV	BYTE [SS:DEVCALL_REQLEN],DINITHL
 44175                                  	;mov	byte [ss:035Bh],0
 44176 0000776C 36C606[5B03]00                  MOV	BYTE [SS:DEVCALL_REQUNIT],0
 44177                                  	;mov	byte [ss:035Ch],0
 44178 00007772 36C606[5C03]00                  MOV	BYTE [SS:DEVCALL_REQFUNC],DEVINIT
 44179                                  	;mov	word [ss:035BD],0
 44180 00007778 36C706[5D03]0000                MOV	WORD [SS:DEVCALL_REQSTAT],0
 44181 0000777F 06                              PUSH	ES
 44182 00007780 53                              PUSH	BX
 44183 00007781 50                              PUSH	AX
 44184 00007782 BB[5A03]                        MOV	BX,DEVCALL
 44185                                          ;PUSH	CS
 44186 00007785 16                      	PUSH	SS ; 30/04/2019
 44187 00007786 07                              POP	ES
 44188 00007787 E87FCD                          CALL	DEVIOCALL2
 44189 0000778A 58                      	POP	AX
 44190 0000778B 5B                              POP	BX
 44191 0000778C 07                              POP	ES
 44192 0000778D C3                              RETN
 44193                                  
 44194                                  ; 25/04/2019 - Retro DOS v4.0
 44195                                  
 44196                                  ;-----------------------------------------------------------------------------
 44197                                  ;
 44198                                  ;	check_XMM: routine to check presence of XMM driver
 44199                                  ;
 44200                                  ;	Exit:   Sets up the XMM entry point in XMMcontrol in DOSDATA
 44201                                  ;
 44202                                  ;	USED:	none
 44203                                  ;
 44204                                  ;-----------------------------------------------------------------------------
 44205                                  
 44206                                  check_XMM: ; proc near
 44207                                  ;
 44208                                  ; determine whether or not an XMM driver is installed
 44209                                  ;
 44210 0000778E 50                      	push	ax
 44211                                  	;mov	ax,(XMM_MULTIPLEX<<8)+XMM_INSTALL_CHECK
 44212 0000778F B80043                  	mov	ax,4300h
 44213 00007792 CD2F                    	int	2Fh
 44214                                  		; - Multiplex - XMS - INSTALLATION CHECK
 44215                                  		; Return: AL = 80h XMS driver installed
 44216                                  		; AL <> 80h no driver
 44217 00007794 3C80                    	cmp	al,80h			; Q: installed
 44218 00007796 751D                    	jne	short cXMM_no_driver	; N: set error, quit
 44219                                  ;
 44220                                  ; get the XMM control functions entry point, save it, we
 44221                                  ; need to call it later.
 44222                                  ;
 44223 00007798 53                      	push	bx
 44224 00007799 52                      	push	dx
 44225 0000779A 1E                      	push	ds
 44226 0000779B 06                      	push	es
 44227                                  	;mov	ax,(XMM_MULTIPLEX<<8)+XMM_FUNCTION_ADDR
 44228 0000779C B81043                  	mov	ax,4310h
 44229 0000779F CD2F                    	int	2Fh
 44230                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
 44231                                  		; Return: ES:BX -> driver entry point
 44232                                  
 44233 000077A1 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 44234                                  
 44235 000077A6 891E[6311]              	mov	[XMMcontrol],bx
 44236 000077AA 8C06[6511]              	mov	[XMMcontrol+2],es
 44237                                  cXMMexit:
 44238 000077AE F8                      	clc
 44239 000077AF 07                      	pop	es
 44240 000077B0 1F                      	pop	ds
 44241 000077B1 5A                      	pop	dx
 44242 000077B2 5B                      	pop	bx
 44243 000077B3 58                      	pop	ax
 44244 000077B4 C3                      	retn				; done
 44245                                  ;
 44246                                  ; set carry if XMM driver not present
 44247                                  ;
 44248                                  cXMM_no_driver:
 44249 000077B5 F9                      	stc
 44250 000077B6 58                      	pop	ax
 44251 000077B7 C3                      	retn
 44252                                  
 44253                                  ;-----------------------------------------------------------------------------
 44254                                  ;
 44255                                  ; Procedure Name : seg_reinit
 44256                                  ;
 44257                                  ; Inputs	 : ES has final dos code location
 44258                                  ;		   AX = 0 / 1
 44259                                  ;
 44260                                  ; Outputs	 : Patch in the sharer and other tables with seg in ES
 44261                                  ;		   if AX =0
 44262                                  ;		      if first entry
 44263                                  ;			 patch segment & offset of vectors with stub
 44264                                  ;			 and stub with segment in ES
 44265                                  ;		      else
 44266                                  ;			 patch stub with segment in ES
 44267                                  ;
 44268                                  ;		   else if AX = 1
 44269                                  ;			patch segment of vectors with segment in ES	
 44270                                  ;
 44271                                  ; NOTE		 : This routine can be called at most twice!
 44272                                  ;
 44273                                  ; Regs Mod.	 : es, ax, di, cx, bx
 44274                                  ;-----------------------------------------------------------------------------
 44275                                  
 44276 000077B8 00                      num_entry: db	0		; keeps track of the # of times this routine
 44277                                  				; has been called. (0 or 1)
 44278                                  
 44279                                  	; 04/11/2022 - Retro DOS v4.0 (ref: MSDOS 5.0)
 44280                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BAB7h
 44281                                  	; 25/05/2019 - Retro DOS v4.0 (ref: MSDOS 6.21)
 44282                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:0BDA5h
 44283                                  
 44284                                  seg_reinit:	; proc	far
 44285 000077B9 1E                      	push	ds
 44286                                  
 44287 000077BA 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 44288                                  
 44289 000077BF E88600                  	call	patch_misc_segments	; patch in segments for sharer and 
 44290                                  					; other tables with seg in ES.
 44291                                  	; 17/12/2022
 44292                                  	; cx = 0
 44293 000077C2 39C8                    	cmp	ax,cx ; 0
 44294                                  	;cmp	ax,0
 44295 000077C4 753D                    	jne	short patch_vec_seg	; patch vectors with segment in es
 44296                                  
 44297                                  	; 17/12/2022
 44298 000077C6 2E380E[B877]            	cmp	[cs:num_entry],cl ; 0
 44299                                  	;cmp	byte [cs:num_entry],0	; Q: is it the first call to this 
 44300 000077CB 7508                    	jne	short second_entry	; N: just patch the stub with 
 44301                                  					;    segment in ES
 44302                                  					; Y: patch the vectors with stub 
 44303 000077CD 8CD8                    	mov	ax,ds
 44304 000077CF E83E00                  	call	patch_vec_segments	; patch the segment of vectors
 44305 000077D2 E8BD00                  	call	patch_offset		; patch the offsets of vectors 
 44306                                  					; with those in the stub.
 44307                                  	; 17/12/2022
 44308                                  	; cx = 0
 44309                                  second_entry:
 44310 000077D5 8CC0                    	mov	ax,es			; patch the stub with segment in es
 44311                                  
 44312                                  	;mov	di,OFFSET DOSDATA:DOSINTTABLE
 44313                                  	;mov	di,1062h	; (same table addr for MSDOS 5.0 and MSDOS 6.21)
 44314 000077D7 BF[6210]                	mov	di,DOSINTTABLE
 44315                                  	; 17/12/2022
 44316                                  	; cx = 0
 44317                                  	;mov	cx,9
 44318 000077DA B109                    	mov	cl,9
 44319 000077DC 1E                      	push	ds			
 44320 000077DD 07                      	pop	es			; es:di -> DOSINTTABLE
 44321                                  
 44322                                  dosinttabloop:
 44323                                  	;add	di,2
 44324                                  	; 19/06/2023
 44325 000077DE 47                      	inc	di
 44326 000077DF 47                      	inc	di
 44327 000077E0 AB                      	stosw
 44328 000077E1 E2FB                    	loop	dosinttabloop	
 44329                                  
 44330                                  ; For ROMDOS, this routine will only be called when the DOS wants to
 44331                                  ; use the HMA, so we don't want to check CS
 44332                                  
 44333                                  ;ifndef ROMDOS
 44334 000077E3 3D00F0                  	cmp	ax,0F000h		; Q: is the DOS running in the HMA
 44335 000077E6 7220                    	jb	short sr_done		; N: done
 44336                                  ;endif
 44337 000077E8 E8A3FF                  	call	check_XMM		; Y: set up the XMS entry point
 44338 000077EB 721B                    	jc	short sr_done		; failed to set up XMS do not do
 44339                                  					; A20 toggling in the stub.
 44340                                  	; 17/12/2022
 44341                                  	; cx = 0
 44342 000077ED E81D01                  	call	patch_in_nops		; enable the stub to check A20 state
 44343                                  ; M021-
 44344                                  	;mov	byte [1211h],1
 44345 000077F0 C606[1112]01            	mov	byte [DosHasHMA],1	; set flag telling DOS control of HMA 
 44346                                  				
 44347                                  					; set pointer to the routine that 
 44348                                  					; patches buggy exepacked code.
 44349                                  	;mov	[FixExePatch],offset DOSCODE:ExePatch
 44350 000077F5 C706[1212][4873]        	mov	word [FixExePatch],ExePatch
 44351                                  					; M068: set pointer to the routine 
 44352                                  					; M068: that detects copy protected
 44353                                  					; M068: apps
 44354                                  	;mov	[ChkCopyProt],offset DOSCODE:IsCopyProt
 44355 000077FB C706[6100][6874]        	mov	word [ChkCopyProt],IsCopyProt
 44356                                  
 44357                                  	; 19/09/2023
 44358 00007801 EB05                    	jmp	short sr_done
 44359                                  
 44360                                  ; 28/12/2022 - Retro DOS v4.1
 44361                                  %if 0
 44362                                  ;----------------------------------------------------------------------------
 44363                                  
 44364                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:0BDF1h
 44365                                  
 44366                                  ;	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 44367                                  ;
 44368                                  ;; M020 - begin
 44369                                  ;
 44370                                  ;	call	WhatCPUType
 44371                                  ;	cmp	al,1
 44372                                  ;	jne	short sr_done 		; we need Rational Patch only
 44373                                  ;					;  on 286 systems
 44374                                  ;	;mov	[RationalPatchPtr],offset DOSCODE:RationalPatch
 44375                                  ;	mov	word [RationalPatchPtr],RationalPatch
 44376                                  ;
 44377                                  ;; M020 - end
 44378                                  ;
 44379                                  ;	jmp	short sr_done
 44380                                  ;
 44381                                  ;patch_vec_seg:				; patch vectors with segment in es
 44382                                  ;	mov	ax,es
 44383                                  ;	call	patch_vec_segments	; patch in DOSCODE for the segments
 44384                                  ;					; NOTE we don't have to patch the 
 44385                                  ;					; offsets as they have been already
 44386                                  ;					; set to the doscode offsets at
 44387                                  ;					; DOSINIT.
 44388                                  ;sr_done:
 44389                                  ;	mov	byte [cs:num_entry],1
 44390                                  ;	pop	ds
 44391                                  ;	retf	; ! far return !
 44392                                  
 44393                                  ;----------------------------------------------------------------------------
 44394                                  ;
 44395                                  ; Procedure Name : WhatCPUType
 44396                                  ;
 44397                                  ; Inputs	 : none
 44398                                  ;
 44399                                  ; Outputs	 : AL = 0 if CPU <  286
 44400                                  ;		      = 1 if CPU == 286
 44401                                  ;		      = 2 if CPU >= 386
 44402                                  ;
 44403                                  ; Regs. Mod.	 : AX
 44404                                  ;
 44405                                  ;----------------------------------------------------------------------------
 44406                                  
 44407                                  WhatCPUType:
 44408                                  	; 25/04/2019 - Retro DOS v4.0
 44409                                  	;get_cpu_type	; done with a MACRO which can't be generated > once
 44410                                  
 44411                                  	;CPUTYPE.INC (MSDOS 6.0, 1991)
 44412                                  
 44413                                  ; Note: this must be a macro, and not a subroutine in the BIOS since
 44414                                  ; 	it is called from both CODE and SYSINITSEG.
 44415                                  ;
 44416                                  ;------GET_CPU_TYPE-----------------------------------May, 88 by M.Williamson
 44417                                  ;  Returns: AX = 0 if 8086 or 8088
 44418                                  ;              = 1 if 80286
 44419                                  ;              = 2 if 80386
 44420                                  
 44421                                  	; 04/11/2022
 44422                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BB03h
 44423                                  
 44424                                  Get_CPU_Type:	;macro
 44425                                  	pushf
 44426                                  	push	bx			; preserve bx
 44427                                  	xor	bx,bx			; init bx to zero
 44428                                  
 44429                                  	xor	ax,ax			; 0000 into AX
 44430                                  	push	ax			; put it on the stack...
 44431                                  	popf				; ...then shove it into the flags
 44432                                  	pushf				; get it back out of the flags...
 44433                                  	pop	ax			; ...and into ax
 44434                                  	and	ax,0F000h		; mask off high four bits
 44435                                  	cmp	ax,0F000h		; was it all 1's?
 44436                                  	je	short cpu_8086		; aye; it's an 8086 or 8088
 44437                                  
 44438                                  	mov	ax,0F000h		; now try to set the high four bits..
 44439                                  	push	ax
 44440                                  	popf
 44441                                  	pushf
 44442                                  	pop	ax			; ...and see what happens
 44443                                  	and	ax,0F000h		; any high bits set ?
 44444                                  	jz	short cpu_286		; nay; it's an 80286
 44445                                  
 44446                                  cpu_386:				; bx starts as zero
 44447                                  	inc	bx			; inc twice if 386
 44448                                  cpu_286:				; just inc once if 286
 44449                                  	inc	bx
 44450                                  cpu_8086:				; don't inc at all if 086
 44451                                  	mov	ax,bx			; put CPU type value in ax
 44452                                  	pop	bx			; restore original bx
 44453                                  	popf
 44454                                  	
 44455                                  	;endm
 44456                                  
 44457                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS)
 44458                                  	retn	; 19/09/2023
 44459                                  
 44460                                  ; 19/09/2023
 44461                                  ;	; 04/11/2022
 44462                                  ;	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BB27h
 44463                                  ;	cmp	al,1
 44464                                  ;	jne	short sr_done 		; we need Rational Patch only
 44465                                  ;					;  on 286 systems
 44466                                  ;	mov	word [RationalPatchPtr],RationalPatch
 44467                                  
 44468                                  ;----------------------------------------------------------------------------
 44469                                  %endif	; 28/12/2022
 44470                                  
 44471                                  	; 19/09/2023
 44472                                  	;jmp	short sr_done
 44473                                  
 44474                                  patch_vec_seg:				; patch vectors with segment in es
 44475 00007803 8CC0                    	mov	ax,es
 44476 00007805 E80800                  	call	patch_vec_segments	; patch in DOSCODE for the segments
 44477                                  					; NOTE we don't have to patch the 
 44478                                  					; offsets as they have been already
 44479                                  					; set to the doscode offsets at
 44480                                  					; DOSINIT.
 44481                                  sr_done:
 44482 00007808 2EC606[B877]01          	mov	byte [cs:num_entry],1
 44483 0000780E 1F                      	pop	ds
 44484 0000780F CB                      	retf	; ! far return !
 44485                                  
 44486                                  ;----------------------------------------------------------------------------
 44487                                  ;
 44488                                  ; Procedure Name : patch_vec_segments
 44489                                  ;
 44490                                  ; Inputs	 : ax -> has segment address to patch in
 44491                                  ;		   ds -> DOSDATA
 44492                                  ;
 44493                                  ; Outputs	 : Patches in AX as the segment for the following vectors:
 44494                                  ;			
 44495                                  ;			0,20-28,3a-3f
 44496                                  ;
 44497                                  ; Regs. Mod.	 : DI,CX,DX,AX
 44498                                  ;
 44499                                  ;----------------------------------------------------------------------------
 44500                                  
 44501                                  patch_vec_segments:
 44502                                  
 44503 00007810 06                      	push	es
 44504                                  
 44505 00007811 31C9                    	xor	cx,cx ; 0
 44506 00007813 8EC1                    	mov	es,cx
 44507                                  
 44508                                  	;mov	di,82h
 44509 00007815 BF8200                  	mov	di,INTBASE+2		; di -> segment of int 20 vector
 44510                                  
 44511 00007818 26A30200                	mov	[es:2],ax		; segment of default divide trap handler
 44512                                  
 44513                                  					; set vectors 20 & 21
 44514                                  	; 04/11/2022
 44515                                  	;mov	cx,2
 44516                                  	; 17/12/2022
 44517                                  	;mov	cl,2
 44518                                  ps_set1:
 44519 0000781C AB                      	stosw	; int 20h segment
 44520                                  	;add	di,2
 44521                                  	; 17/12/2022
 44522 0000781D 47                      	inc	di
 44523 0000781E 47                      	inc	di
 44524                                  	;loop	ps_set1
 44525                                  
 44526                                  	; 17/12/2022
 44527 0000781F AB                      	stosw	; int 21h segment
 44528                                  	;inc	di
 44529                                  	;inc	di
 44530                                  
 44531                                  	;add	di,4			; skip int 22h vector
 44532 00007820 83C706                  	add	di,6 ; *
 44533                                  
 44534 00007823 AB                      	stosw				; set int 23h
 44535 00007824 83C706                  	add	di,6			; skip int 24h
 44536                                  
 44537                                  					; set vectors 25-28 and 2a-3f
 44538                                  	; 04/11/2022
 44539                                  	;mov	cx,4			; set 4 segments
 44540                                  	; 17/12/2022
 44541 00007827 B104                    	mov	cl,4
 44542                                  ps_set2:
 44543 00007829 AB                      	stosw
 44544                                  	;add	di,2
 44545                                  	; 17/12/2022
 44546 0000782A 47                      	inc	di
 44547 0000782B 47                      	inc	di
 44548 0000782C E2FB                    	loop	ps_set2
 44549                                  
 44550 0000782E 83C704                  	add	di,4			; skip int 29h vector (fast con) as it may
 44551                                  					;   already be set.
 44552                                  	; 04/11/2022
 44553                                  	;mov	cx,6			; set 6 segs (skip 2 between each)
 44554                                  	; 17/12/2022
 44555 00007831 B106                    	mov	cl,6			;  set segs for ints 2ah-2fh
 44556                                  ps_set3:
 44557 00007833 AB                      	stosw
 44558                                  	;add	di,2
 44559                                  	; 17/12/2022
 44560 00007834 47                      	inc	di
 44561 00007835 47                      	inc	di
 44562 00007836 E2FB                    	loop	ps_set3
 44563                                  
 44564                                  ; 30h & 31H is the CPM call entry point whose segment address is set up by
 44565                                  ; below. So skip it.
 44566                                  
 44567 00007838 83C708                  	add	di,8			; skip vector 30h & 31h 
 44568                                  	
 44569                                  	; 04/11/2022
 44570                                  	;mov	cx,14			; set 14 segs (skip 2 between each)
 44571                                  	; 17/12/2022
 44572 0000783B B10E                    	mov	cl,14			;  sets segs for ints 32h-3fh
 44573                                  ps_set4:
 44574 0000783D AB                      	stosw
 44575                                  	;add	di,2
 44576                                  	; 17/12/2022
 44577 0000783E 47                      	inc	di
 44578 0000783F 47                      	inc	di
 44579 00007840 E2FB                    	loop	ps_set4
 44580                                  
 44581                                  ; set offset of int2f
 44582                                  
 44583                                  ;if installed
 44584                                  ;	mov	word ptr es:[02fh * 4],offset doscode:int2f
 44585                                  ;endif
 44586                                  	;mov	[es:0C3h],ax
 44587 00007842 26A3C300                	mov	[es:ENTRYPOINT+3],ax
 44588                                  	; 17/12/2022
 44589                                  	; cx = 0
 44590 00007846 07                      	pop	es
 44591 00007847 C3                      	retn
 44592                                  
 44593                                  ;---------------------------------------------------------------------------
 44594                                  ;
 44595                                  ; Procedure Name : patch_misc_segments
 44596                                  ;
 44597                                  ; Inputs	 : es = segment to patch in
 44598                                  ;		   ds = dosdata
 44599                                  ;
 44600                                  ; outputs	 : patches in the sharer and other tables in the dos
 44601                                  ;		   with right dos code segment in es
 44602                                  ;
 44603                                  ; Regs Mod	 : DI,SI,CX
 44604                                  ;
 44605                                  ;---------------------------------------------------------------------------
 44606                                  
 44607                                  patch_misc_segments:
 44608                                  
 44609 00007848 53                      	push	bx
 44610 00007849 06                      	push	es
 44611 0000784A 50                      	push	ax
 44612                                  
 44613 0000784B 8CC0                    	mov	ax,es			; ax - > DOS segment
 44614                                  	
 44615 0000784D 1E                      	push	ds
 44616 0000784E 07                      	pop	es			; es -> DOSDATA
 44617                                  	
 44618                                  ; initialize the jump table for the sharer...
 44619                                  
 44620                                  	;mov	di,offset dosdata:jshare
 44621                                  	;mov	di,90h
 44622 0000784F BF[9000]                	mov	di,JShare
 44623                                  	;mov	bx,[0AAAh]
 44624 00007852 8B1E[AA0A]              	mov	bx,[TEMP_DOSLOC]	; bx = location to which the share
 44625                                  					; table was patched during the first
 44626                                  					; call to this routine
 44627 00007856 B90F00                  	mov	cx,15
 44628                                  jumptabloop:
 44629                                  	;add	di,2			; skip offset
 44630                                  	; 17/12/2022
 44631 00007859 47                      	inc	di
 44632 0000785A 47                      	inc	di
 44633 0000785B 83FBFF                  	cmp	bx,-1 ; 0FFFFh		; Q: is this called for the 1st time
 44634 0000785E 7405                    	je	short share_patch	; Y: patch in sharer table
 44635                                  					; N: 
 44636 00007860 263B1D                  	cmp	bx,[es:di]		; Q: has share been installed
 44637 00007863 7501                    	jne	short no_share_patch	; Y: don't patch in sharer table
 44638                                  share_patch:
 44639 00007865 AB                      	stosw				; drop in segment
 44640                                  no_share_patch:
 44641 00007866 E2F1                    	loop	jumptabloop
 44642                                  					; BUGBUG patching the country info 
 44643                                  					; with dosdata can be done inline
 44644                                  					; in dosinit.
 44645                                  					; for dos 3.3 country info
 44646                                  					; table address
 44647                                  
 44648                                  	;mov	si,offset dosdata:country_cdpg
 44649                                  	;mov	si,122Ah   
 44650 00007868 BE[2A12]                	mov	si,COUNTRY_CDPG
 44651                                  					; initialize double word
 44652                                  					; pointers with dosdata in ds
 44653                                  	;mov	[si+4Fh],ds
 44654                                  	;mov	[si+54h],ds
 44655                                  	;mov	[si+59h],ds
 44656                                  	;mov	[si+5Eh],ds
 44657                                  	;mov	[si+80h],ds
 44658                                  	;mov	[si+63h],ds
 44659 0000786B 8C5C4F                  	mov	[si+DOS_CCDPG.ccUcase_ptr+2],ds    
 44660 0000786E 8C5C54                  	mov	[si+DOS_CCDPG.ccFileUcase_ptr+2],ds 
 44661 00007871 8C5C59                  	mov	[si+DOS_CCDPG.ccFileChar_ptr+2],ds
 44662 00007874 8C5C5E                  	mov	[si+DOS_CCDPG.ccCollate_ptr+2],ds
 44663 00007877 8C9C8000                	mov	[si+DOS_CCDPG.ccMono_ptr+2],ds
 44664 0000787B 8C5C63                  	mov	[si+DOS_CCDPG.ccDBCS_ptr+2],ds	
 44665                                  
 44666                                  					; fastopen routines are in doscode
 44667                                  					; so patch with doscode seg in ax
 44668                                  
 44669                                  	;mov	si,offset dosdata:fastopentable
 44670                                  	;mov	si,0D30h
 44671 0000787E BE[300D]                	mov	si,FastOpenTable
 44672                                  
 44673                                  	; 17/12/2022
 44674                                  	; bx = [TEMP_DOSLOC]
 44675 00007881 83FBFF                  	cmp	bx,-1
 44676                                  	;cmp	word [TEMP_DOSLOC],-1	; Q: first time 
 44677 00007884 7405                    	je	short fast_patch	; Y: patch segment
 44678                                  	;mov	cx,[TEMP_DOSLOC]
 44679                                  					; Q: has fastopen patched in it's
 44680                                  					;    segment
 44681                                  	; 17/12/2022
 44682 00007886 3B5C04                  	cmp	bx,[si+fastopen_entry.name_caching+2]
 44683                                  	;;cmp	cx,[si+4]
 44684                                  	;cmp	cx,[si+fastopen_entry.name_caching+2]
 44685 00007889 7503                    	jne	short no_fast_patch	; Y: don't patch in doscode seg
 44686                                  
 44687                                  fast_patch:
 44688                                  	;mov	[si+4],ax
 44689 0000788B 894404                  	mov	[si+fastopen_entry.name_caching+2],ax
 44690                                  no_fast_patch:
 44691                                  	; 17/12/2022
 44692                                  	; cx = 0
 44693 0000788E 58                      	pop	ax
 44694 0000788F 07                      	pop	es
 44695 00007890 5B                      	pop	bx
 44696                                  
 44697 00007891 C3                      	retn
 44698                                  
 44699                                  ;--------------------------------------------------------------------------
 44700                                  ;
 44701                                  ; Procedure Name : patch_offset
 44702                                  ; 
 44703                                  ; Inputs	 : NONE
 44704                                  ;
 44705                                  ; Outputs	 : Patches in the offsets in the low_mem_stub for vectors
 44706                                  ;		   0,20-28,3a-3f, and 30,31
 44707                                  ;
 44708                                  ;
 44709                                  ; Regs. Mod	 : AX,DI,CX
 44710                                  ;--------------------------------------------------------------------------
 44711                                  
 44712                                  patch_offset:
 44713 00007892 06                      	push	es		; preserve es
 44714                                  
 44715 00007893 31C0                    	xor	ax,ax
 44716 00007895 8EC0                    	mov	es,ax
 44717                                  				; set default divide trap address
 44718                                  	;mov	word ptr es:[0],offset dosdata:ldivov
 44719                                  	;mov	word [es:0],108Ah
 44720 00007897 26C7060000[8A10]        	mov	word [es:0],ldivov
 44721                                  
 44722                                  	;mov	di,80h
 44723 0000789E BF8000                  	mov	di,INTBASE	; di-> offset of int 20 handler
 44724                                  	;mov	ax,offset dosdata:lirett
 44725                                  	;mov	ax,10DAh
 44726 000078A1 B8[DA10]                	mov	ax,lirett
 44727                                  				; set vectors 20 & 21 to point to iret.
 44728                                  	; 17/12/2022
 44729                                  	; cx = 0
 44730                                  
 44731                                  	;mov	cx,2		; set 2 offsets (skip 2 between each)
 44732                                  po_iset1:
 44733 000078A4 AB                      	stosw	; int 20h offset
 44734                                  	;add	di,2 ; *
 44735                                  	;loop	po_iset1
 44736                                  	; 17/12/2022
 44737 000078A5 47                      	inc	di
 44738 000078A6 47                      	inc	di
 44739 000078A7 AB                      	stosw	; int 21h offset
 44740                                  
 44741                                  	;add	di,4		; skip vector 22h
 44742                                  	; 17/12/2022
 44743 000078A8 83C706                  	add	di,6 ; *
 44744                                  
 44745 000078AB AB                      	stosw			; set offset of 23h
 44746                                  	;add	di,6		; skip 24h
 44747                                  	; 19/09/2023
 44748 000078AC 83C712                  	add	di,18		; skip 23h segment and int 24-25-26-27h
 44749                                  
 44750                                  				; set vectors 25-28 and 2a-3f to iret.
 44751                                  	; 04/11/2022
 44752                                  	;mov	cx,4		; set 4 offsets (skip 2 between each)
 44753                                  	; 19/09/2023
 44754                                  	; 17/12/2022
 44755                                  	;mov	cl,4		; sets offsets for ints 25h-28h
 44756                                  po_iset2:
 44757 000078AF AB                      	stosw		; set offset for int 28h ; 19/09/2023
 44758                                  	;add	di,2
 44759                                  	; 19/09/2023
 44760                                  	; 17/12/2022
 44761                                  	;inc	di
 44762                                  	;inc	di
 44763                                  	; 19/09/2023
 44764                                  	;loop	po_iset2
 44765                                  
 44766                                  	;add	di,4		; skip vector 29h
 44767                                  	; 19/09/2023
 44768 000078B0 83C706                  	add	di,6	; skip int 28h segment and int 29h ; 19/09/2023
 44769                                  
 44770                                  	; 04/11/2022
 44771                                  	;mov	cx,6		; set 6 offsets (skip 2 between each)
 44772                                  	; 17/12/2022
 44773                                  	;mov	cl,6		; sets offsets for ints 2ah-2fh
 44774 000078B3 B105                    	mov	cl,5		; sets offsets for ints 2Ah-2Eh
 44775                                  po_iset3:
 44776 000078B5 AB                      	stosw
 44777                                  	;add	di,2
 44778                                  	; 17/12/2022
 44779 000078B6 47                      	inc	di
 44780 000078B7 47                      	inc	di
 44781 000078B8 E2FB                    	loop	po_iset3
 44782                                  
 44783                                  ; 30h & 31H is the CPM call entry point whose offset address is set up by
 44784                                  ; below. So skip it.
 44785                                  
 44786                                  	;add	di,8		; skip vector 30h & 31h
 44787                                  	; 17/12/2022
 44788 000078BA 83C70C                  	add	di,12		; skip vector 2Fh, 30h & 31h
 44789                                  
 44790                                  	; 04/11/2022
 44791                                  	;mov	cx,14		; set 14 offsets (skip 2 between each)
 44792                                  				;  sets offsets for ints 32h-3fh
 44793                                  	; 17/12/2022
 44794 000078BD B10E                    	mov	cl,14 ; 26/06/2019
 44795                                  po_iset4:
 44796 000078BF AB                      	stosw
 44797                                  	;add	di,2
 44798                                  	; 17/12/2022
 44799 000078C0 47                      	inc	di
 44800 000078C1 47                      	inc	di
 44801 000078C2 E2FB                    	loop	po_iset4
 44802                                  
 44803                                  ;if installed
 44804                                  	;mov	word ptr es:[02fh * 4],offset dosdata:lint2f
 44805                                  	;mov	word [es:0BCh],10C6h ; (MSDOS 5.0 & 6.21)
 44806 000078C4 26C706BC00[C610]        	mov	word [es:(2Fh*4)],lint2f
 44807                                  ;endif
 44808                                  
 44809                                  ; set up entry point call at vectors 30-31h
 44810                                  	;mov	byte [es:0C0h],0EAh
 44811 000078CB 26C606C000EA            	mov	byte [es:ENTRYPOINT],mi_long_jmp
 44812                                  	;mov	word [es:0C1h],10D0h
 44813                                  
 44814 000078D1 26C706C100[D010]        	mov	word [es:ENTRYPOINT+1],lcall_entry
 44815                                  
 44816                                  							; 19/09/2023
 44817                                  	;mov	word [es:80h],1094h
 44818 000078D8 26C7068000[9410]        	mov	word [es:addr_int_abort],lquit		; int 20h
 44819                                  	;mov	word [es:84h],109Eh
 44820 000078DF 26C7068400[9E10]        	mov	word [es:addr_int_command],lcommand	; int 21h
 44821                                  	;mov	word [es:94h],10A8h
 44822 000078E6 26C7069400[A810]        	mov	word [es:addr_int_disk_read],labsdrd	; int 25h  
 44823                                  	;mov	word [es:98h],10B2h
 44824 000078ED 26C7069800[B210]        	mov	word [es:addr_int_disk_write],labsdwrt	; int 26h
 44825                                  	;mov	word [es:9Ch],10BCh
 44826 000078F4 26C7069C00[BC10]        	mov	word [es:addr_int_keep_process],lstay_resident	; int 27h
 44827                                  
 44828                                  	; 17/12/2022
 44829                                  	; CX = 0
 44830 000078FB 07                      	pop	es		; restore es
 44831 000078FC C3                      	retn
 44832                                  
 44833                                  ;--------------------------------------------------------------------------
 44834                                  ;
 44835                                  ; 	Procedure Name	:	patch_in_nops
 44836                                  ;
 44837                                  ; 	Entry		: 	ES -> DOSDATA
 44838                                  ;
 44839                                  ;	Regs Mod	: 	cx, di
 44840                                  ;
 44841                                  ;	Description:
 44842                                  ;		This routine patches in 2 nops at the offsets specified in 
 44843                                  ;	patch_table. This basically enables the low mem stub to start 
 44844                                  ;	making XMS calls.
 44845                                  ;
 44846                                  ;--------------------------------------------------------------------------
 44847                                  
 44848                                  	; 04/11/2022
 44849                                  	; (MSDOS 5.0 MSDOS.SYS)
 44850                                  	; DOSCODE:0BC50h
 44851                                  
 44852                                  patch_table:	; label	byte
 44853                                  	;dw	offset dosdata:i0patch
 44854                                  	;dw	offset dosdata:i20patch
 44855                                  	;dw	offset dosdata:i21patch
 44856                                  	;dw	offset dosdata:i25patch
 44857                                  	;dw	offset dosdata:i26patch
 44858                                  	;dw	offset dosdata:i27patch
 44859                                  	;dw	offset dosdata:i2fpatch
 44860                                  	;dw	offset dosdata:cpmpatch
 44861 000078FD [8A10]                  	dw	i0patch
 44862 000078FF [9410]                  	dw	i20patch
 44863 00007901 [9E10]                  	dw	i21patch
 44864 00007903 [A810]                  	dw	i25patch
 44865 00007905 [B210]                  	dw	i26patch
 44866 00007907 [BC10]                  	dw	i27patch
 44867 00007909 [C610]                  	dw	i2fpatch
 44868 0000790B [D010]                  	dw	cpmpatch
 44869                                  
 44870                                  patch_table_size equ ($-patch_table)/2
 44871                                  
 44872                                  patch_in_nops:
 44873 0000790D 50                      	push	ax
 44874 0000790E 56                      	push	si
 44875 0000790F BE[FD78]                	mov	si,patch_table
 44876 00007912 B89090                  	mov	ax,9090h ; nop, nop
 44877                                  	; 17/12/2022
 44878                                  	; cx = 0
 44879                                  	;mov	cx,8
 44880                                  	;mov	cx,patch_table_size ; 8
 44881 00007915 B108                    	mov	cl,patch_table_size ; 8
 44882                                  pin_loop:
 44883 00007917 2E8B3C                  	mov	di,[cs:si]
 44884 0000791A AB                      	stosw
 44885                                  	;add	si,2
 44886                                  	; 17/12/2022
 44887 0000791B 46                      	inc	si
 44888 0000791C 46                      	inc	si
 44889 0000791D E2F8                    	loop	pin_loop
 44890 0000791F 5E                      	pop	si
 44891 00007920 58                      	pop	ax
 44892 00007921 C3                      	retn
 44893                                  
 44894                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 44895                                  ; ---------------------------------------------------------------------------
 44896                                  ; MSDOS 5.0 - MSDOS.SYS offset BC77h, file offset 7EA7h
 44897                                  ; ---------------------------------------------------------------------------
 44898                                  ; 23/03/2024 - Retro DOS v4.2
 44899                                  ; MSDOS 6.22 MSDOS.SYS - DOSCODE:0BF69h
 44900                                  ; (PCDOS 7.1 IBMDOS.COM - DOSCODE:0D20Fh)
 44901                                  
 44902                                  	; 05/12/2022 - temporary ; (paragraph alinment)
 44903                                  DOSCODE_END:
 44904                                  	; 23/03/2024
 44905                                  	;times	7 db 0	; MSDOS 6.22 MSDOS.SYS
 44906                                  
 44907                                  	; 23/03/2024
 44908                                  	;times	9 db 0	; db 9 dup(0)
 44909                                  	; 18/12/2022
 44910                                  	;dw	0	; times 2 db 0
 44911                                  
 44912                                  	; 23/03/2024 - Retro DOS v4.2		
 44913                                  	; 23/03/2024 - Retro DOS v5.0
 44914 00007922 00                      	db	0	; PCDOS 7.1 IBMDOS.COM
 44915                                  
 44916                                  ;align 16
 44917                                  	; DOSCODE:BC80h	(MSDOS 5.0 MSDOS.SYS file offset 7EB0h)
 44918                                  	; MSDOS.SYS file offset: 32432 (start of DOSDATA)
 44919                                  
 44920                                  	; 23/03/2024 - Retro DOS v4.2
 44921                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:0BF70h
 44922                                  	; (PCDOS 7.1 IBMDOS.COM - DOSCODE:0D210h)
 44923                                  
 44924                                  ; ---------------------------------------------------------------------------
 44925                                  
 44926                                  ;memstrt label word
 44927                                  ; ---------------------------------------------------------------------------
 44928                                  ; MSDOS 6.21 - MSDOS.SYS offset BF69h, file offset 8189h
 44929                                  ; ---------------------------------------------------------------------------
 44930                                  
 44931                                  MEMSTRT: ; 25/04/2019 - Retro DOS v4.0
 44932                                  
 44933                                  ; if not ROMDOS, then we close the dos code segment, otherwise we close
 44934                                  ; the dos initialization segment
 44935                                  
 44936                                  ;ifndef ROMDOS
 44937                                  
 44938                                  ;doscode ends
 44939                                  
 44940                                  ;else
 44941                                  
 44942                                  ;;dosinitseg ends
 44943                                  
 44944                                  ;endif ; ROMDOS
 44945                                  
 44946                                  ;============================================================================
 44947                                  
 44948                                  ; DPUBLIC <ParaRound, cXMM_no_driver, cXMMexit, char_init_loop, charinit>
 44949                                  ; DPUBLIC <check_XMM, continit, dosinttabloop, endlist>
 44950                                  ; DPUBLIC <initiret, iset1, iset2, jumptabloop, nxtentry>
 44951                                  ; DPUBLIC <notmax,  patch_offset, perdrv>
 44952                                  ; DPUBLIC <perunit, po_iset1, po_iset2, po_iset3>
 44953                                  ; DPUBLIC <ps_set1, ps_set2, ps_set3, seg_reinit>
 44954                                  ; DPUBLIC <sr_done, version_fake_table, xxx>
 44955                                  
 44956                                  ;; burasý doscode sonu
 44957                                  
 44958                                  ;============================================================================
 44959                                  ; DOSDATA
 44960                                  ;============================================================================
 44961                                  ; 29/04/2019 - Retro DOS 4.0
 44962                                  
 44963                                  ;[BITS 16]
 44964                                  
 44965                                  ;[ORG 0]
 44966                                  
 44967                                  ; 25/04/2019 - Retro DOS v4.0
 44968                                  
 44969                                  ;============================================================================
 44970                                  ; DOSDATA - MSDOS 6.21 - MSDOS.SYS Offset 0BF70h, file offset 8190h
 44971                                  ;============================================================================
 44972                                  
 44973                                  ;align 16
 44974                                  	; DOSDATA (MSDOS.SYS kernel DATA) segment starts here...
 44975                                  	; (4970 bytes for MSDOS 6.21)
 44976                                  	; (4976 bytes for Retro DOS v4.0, 25/05/2019 modification.)
 44977                                  
 44978                                  ;============================================================================
 44979                                  ; MSCONST.ASM (MSDOS 6.0, 1991)
 44980                                  ;============================================================================
 44981                                  ; 03/11/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 44982                                  ; 25/04/2019 - Retro DOS 4.0 (MSDOS 6.21)
 44983                                  ; 16/07/2018 - Retro DOS 3.0	
 44984                                  
 44985                                  ;Break <Initialized data and data used at DOS initialization>
 44986                                  ;----------------------------------------------------------------------------
 44987                                  
 44988                                  ; We need to identify the parts of the data area that are relevant to tasks
 44989                                  ; and those that are relevant to the system as a whole. Under 3.0, the system
 44990                                  ; data will be gathered with the system code. The process data under 2.x will
 44991                                  ; be available for swapping and under 3.0 it will be allocated per-process.
 44992                                  ;
 44993                                  ; The data that is system data will be identified by [SYSTEM] in the comments
 44994                                  ; describing that data item.
 44995                                  
 44996                                  ;DOSDATA SEGMENT
 44997                                  
 44998                                  ; 04/11/2022
 44999                                  ;[ORG 0]
 45000                                  
 45001                                  ; ----------------------------------------------------------------------------
 45002                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45003                                  ; ----------------------------------------------------------------------------
 45004                                  ; DOSDATA segment start offset from beginning of MSDOS.SYS file: 32432 (7EB0h)
 45005                                  ; (3DD0h+7EB0h = 0BC80h) - for MSDOS 5.0 kernel file -
 45006                                  ; ----------------------------------------------------------------------------
 45007                                  
 45008                                  ; 04/11/2022
 45009                                  
 45010                                  ;DOSDATA:0000h
 45011                                  
 45012 00007923 90<rep Dh>              align 16
 45013                                  
 45014                                  ; ----------------------------------------------------------------------------
 45015                                  ; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45016                                  ; ----------------------------------------------------------------------------
 45017                                  
 45018                                  segment .data  vstart=0 ; 06/12/2022
 45019                                  								
 45020                                  ; ============================================================================
 45021                                  
 45022                                  ; 06/12/2022
 45023                                  ;DOSDATASTART equ $
 45024                                  DOSDATASTART:
 45025                                  
 45026                                  
 45027                                  ;hkn; add 4 bytes to get correct offsets since jmp has been removed in START
 45028                                  
 45029                                  	;; 03/11/2022
 45030                                  	;jmp	DOSINIT		; MSDOS 5.0 - MSDOS.SYS (DOSDATA:0000h)
 45031                                  
 45032                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45033                                  	;db	4 dup (?)	
 45034 00000000 00<rep 4h>              	times	4 db 0
 45035                                  
 45036                                  	; 29/04/2019 - Retro DOS v4.0 modification
 45037                                  	;dw 	_$STARTCODE ; DOSCODE offset and/or size of DOSDATA
 45038                                  	;dw	0
 45039                                  
 45040                                  	;EVEN
 45041                                  
 45042                                  ;align 2
 45043                                  
 45044                                  ; WANGO!!! The following word is used by SHARE and REDIR to determin data
 45045                                  ; area compatability. This location must be incremented EACH TIME the data
 45046                                  ; area here gets mucked with.
 45047                                  ;
 45048                                  ; Also, do NOT change this position relative to DOSDATA:0.
 45049                                  
 45050                                  MSCT001S:	; LABEL BYTE
 45051                                  	
 45052                                  DataVersion:	
 45053 00000004 0100                    	dw	1	;AC000; [SYSTEM] version number for DOS DATA
 45054                                  
 45055                                  ;hkn; add 8 bytes to get correct offsets since BugTyp, BugLev and "BUG " has 
 45056                                  ;hkn; been removed to DOSCODE above
 45057                                  
 45058                                  ;M044
 45059                                  ; First part of save area for saving last para of Window memory
 45060                                  
 45061                                  WinoldPatch1:	; db 8 dup (?)	;M044
 45062 00000006 00<rep 8h>              	times	8 db 0
 45063                                  
 45064                                  	; MSDOS 6.21 DOSDATA:000Eh
 45065                                  MYNUM:			; Offset 000Eh
 45066 0000000E 0000                    	dw	0	; [SYSTEM] A number that goes with MYNAME
 45067                                  FCBLRU: 		; [SYSTEM] LRU count for FCB cache
 45068 00000010 0000                    	dw	0
 45069                                  OpenLRU:
 45070 00000012 0000                    	dw	0	; [SYSTEM] LRU count for FCB cache opens
 45071                                  OEM_HANDLER: 		
 45072 00000014 FFFFFFFF                	dd	-1	; [SYSTEM] Pointer to OEM handler code	
 45073                                  
 45074                                  ;	BUGBUG - who uses LeaveAddr?  What if we want to rework the
 45075                                  ;;			way that we leave DOS???? - jgl
 45076                                  
 45077                                  LeaveAddr:
 45078 00000018 [0404]                  	dw	LeaveDOS  ; <<OFFSET DOSCODE:LeaveDOS>> ; [SYSTEM]
 45079                                  RetryCount:		
 45080 0000001A 0300                    	dw	3	; [SYSTEM] Share retries
 45081                                  RetryLoop:
 45082 0000001C 0100                    	dw	1	; [SYSTEM] Share retries
 45083                                  LastBuffer:
 45084 0000001E FFFFFFFF                	dd	-1	; [SYSTEM] Buffer queue recency pointer
 45085                                  CONTPOS:
 45086 00000022 0000                    	dw	0	; [SYSTEM] location in buffer of next read
 45087                                  arena_head:
 45088 00000024 0000                    	dw	0	; [SYSTEM] Segment # of first arena in memory
 45089                                  
 45090                                  ;; 16/07/2018
 45091                                  ;;***************************************************************************
 45092                                  ;; NOTE: INT 21H AH=52H !  (http://stanislavs.org/helppc/int_21-52.html)
 45093                                  ;;***************************************************************************
 45094                                  ;; INT 21,52 - Get Pointer to DOS "INVARS" (Undocumented)
 45095                                  ;;
 45096                                  ;;	AH = 52h
 45097                                  ;;
 45098                                  ;;	on return:
 45099                                  ;;	ES:BX = pointer to DOS "invars", a table of pointers used by DOS.
 45100                                  ;;		Known "invars" fields follow (varies with DOS version):
 45101                                  ;;
 45102                                  ;;	Offset Size		 Description
 45103                                  ;;
 45104                                  ;;	 -12   word   sharing retry count (DOS 3.1-3.3)
 45105                                  ;;	 -10   word   sharing retry delay  (DOS 3.1-3.3)
 45106                                  ;;	  -8   dword  pointer to current disk buffer (DOS 3.x)
 45107                                  ;;	  -4   word   pointer in DOS code segment of unread CON input;
 45108                                  ;;		      0 indicates no unread input (DOS 3.x)
 45109                                  ;;	  -2   word   segment of first Memory Control Block (MCB)
 45110                                  ;;	  00   dword  pointer to first DRIVE PARAMETER TABLE (A:) in chain
 45111                                  ;;	  04   dword  pointer to DOS System File Table (SFT)
 45112                                  ;;	  08   dword  pointer to $CLOCK device driver
 45113                                  ;;	  0C   dword  pointer to CON device driver
 45114                                  ;;	  10   byte   number of logical drives in system
 45115                                  ;;	  11   word   maximum bytes/block of any block device
 45116                                  ;;	  13   dword  pointer to DOS cache buffer header
 45117                                  ;;	  17 18bytes  NUL device header, first 4 bytes of device header
 45118                                  ;;		      point to the next device in device chain
 45119                                  ;;
 45120                                  ;;***************************************************************************
 45121                                  
 45122                                  ; The following block of data is used by SYSINIT. 
 45123                                  ; Do not change the order or size of this block
 45124                                  
 45125                                  ;SYSINITVAR:
 45126                                  ;----------------------------------------------------------------------------
 45127                                  SYSINITVARS:
 45128                                  DPBHEAD:
 45129 00000026 00000000                	dd	0	; [SYSTEM] Pointer to head of DPB-FAT list
 45130                                  SFT_ADDR:
 45131 0000002A [CC000000]              	dd	SFTABL	; [SYSTEM] Pointer to first SFT table
 45132                                  BCLOCK:
 45133 0000002E 00000000                	dd	0	; [SYSTEM] The CLOCK device
 45134                                  BCON:
 45135 00000032 00000000                	dd	0	; [SYSTEM] Console device entry points
 45136                                  MAXSEC:
 45137 00000036 8000                    	dw	128	; [SYSTEM] Maximum allowed sector size
 45138                                  BUFFHEAD:
 45139 00000038 00000000                	dd	0	; [SYSTEM] Pointer to head of buffer queue
 45140                                  CDSADDR:
 45141 0000003C 00000000                	dd	0	; [SYSTEM] Pointer to curdir structure table
 45142                                  SFTFCB:
 45143 00000040 00000000                	dd	0	; [SYSTEM] pointer to FCB cache table
 45144                                  KEEPCOUNT:
 45145 00000044 0000                    	dw	0	; [SYSTEM] count of FCB opens to keep
 45146                                  NUMIO:
 45147 00000046 00                      	db	0	; [SYSTEM] Number of disk tables
 45148                                  CDSCOUNT:
 45149 00000047 00                      	db	0	; [SYSTEM] Number of CDS structures in above
 45150                                  
 45151                                  ; A fake header for the NUL device
 45152                                  NULDEV:
 45153 00000048 00000000                	dd	0	; [SYSTEM] Link to rest of device list
 45154                                  	;dw	8004h
 45155 0000004C 0480                    	dw	DEVTYP|ISNULL ; [SYSTEM] Null device attributes
 45156 0000004E [C60D]                  	dw	SNULDEV	; [SYSTEM] Strategy entry point
 45157 00000050 [CC0D]                  	dw	INULDEV	; [SYSTEM] Interrupt entry point
 45158 00000052 4E554C2020202020        	db	"NUL     " ; [SYSTEM] Name of null device
 45159                                  SPLICES:
 45160 0000005A 00                      	db	0	; [SYSTEM] TRUE => splices being done
 45161                                  
 45162                                  Special_Entries:
 45163 0000005B 0000                    	dw	0	; [SYSTEM] address of special entries ;AN000;
 45164                                  UU_IFS_DOS_CALL:
 45165 0000005D 00000000                	dd	0	; [SYSTEM] entry for IFS DOS service ;AN000;
 45166                                  ; 
 45167                                  ; UU_IFS_HEADER:
 45168                                  ; 	dd	0	; [SYSTEM] IFS header chain ;AN000;
 45169                                  
 45170                                  ChkCopyProt:
 45171 00000061 0000                    	dw	0	; M068
 45172                                  A20OFF_PSP:
 45173 00000063 0000                    	dw	0	; M068
 45174                                  BUFFERS_PARM1:
 45175 00000065 0000                    	dw	0	; [SYSTEM] value of BUFFERS= ,m	;AN000;
 45176                                  BUFFERS_PARM2:
 45177 00000067 0000                    	dw	0	; [SYSTEM] value of BUFFERS= ,n ;AN000;
 45178                                  BOOTDRIVE:
 45179 00000069 00                      	db	0	; [SYSTEM] the boot drive ;AN000;
 45180                                  DDMOVE:
 45181 0000006A 00                      	db	0 	; [SYSTEM] 1 if we need DWORD move ;AN000;
 45182                                  EXT_MEM_SIZE:
 45183 0000006B 0000                    	dw	0	; [SYSTEM] extended memory size	;AN000;
 45184                                  
 45185                                  HASHINITVAR: ; LABEL   WORD	; AN000;
 45186                                  ;
 45187                                  ; Replaced by next two declarations
 45188                                  ;
 45189                                  ;UU_BUF_HASH_PTR:
 45190                                  ;	dd	0	; [SYSTEM] buffer Hash table addr
 45191                                  ;UU_BUF_HASH_COUNT:
 45192                                  ;	dw	1	; [SYSTEM] number of Hash entries
 45193                                  
 45194                                  BufferQueue:
 45195 0000006D 00000000                	dd	0	; [SYSTEM] Head of the buffer Queue
 45196                                  DirtyBufferCount:
 45197 00000071 0000                    	dw	0	; [SYSTEM] Count of Dirty buffers in the Que
 45198                                  			; BUGBUG ---- change to byte
 45199                                  SC_CACHE_PTR:
 45200 00000073 00000000                	dd	0	; [SYSTEM] secondary cache pointer
 45201                                  SC_CACHE_COUNT:
 45202 00000077 0000                    	dw	0 	; [SYSTEM] secondary cache count
 45203                                  BuffInHMA:
 45204 00000079 00                      	db	0	; Flag to indicate that buffs are in HMA
 45205                                  LoMemBuff:
 45206 0000007A 00000000                	dd	0	; Ptr to intermediate buffer
 45207                                  			;  in Low mem when buffs are in HMA
 45208                                  ;
 45209                                  ; All variables which have UU_ as prefix can be reused for other
 45210                                  ; purposes and can be renamed. All these variables were used for
 45211                                  ; EMS support of Buffer Manager. Now they are useless for Buffer
 45212                                  ; manager ---- MOHANS
 45213                                  ;
 45214                                  	;I_am	UU_BUF_EMS_FIRST_PAGE,3,<0,0,0>  
 45215                                  UU_BUF_EMS_FIRST_PAGE:	
 45216 0000007E 000000                  	db	0,0,0	; holds the first page above 640K
 45217                                  
 45218                                  	;;I_am	UU_BUF_EMS_NPA640,WORD,<0> ; holds the number of pages 
 45219                                  ;UU_BUF_EMS_NPA640:			   ; above 640K	
 45220                                  ;	dw	0			
 45221                                  
 45222                                  CL0FATENTRY:
 45223 00000081 FFFF                    	dw	-1	; M014:	Holds the data that
 45224                                  			; is used in pack/unpack rts.
 45225                                  			; in fat.asm if cluster 0 is specified.
 45226                                  			; SR;
 45227                                  IoStatFail:
 45228 00000083 00                      	db	0	; IoStatFail has been added to 
 45229                                  			; record a fail on an I24 
 45230                                  			; issued from IOFUNC on a status call. 
 45231                                  
 45232                                  ;***	I_am	UU_BUF_EMS_MODE,BYTE,<-1>	; EMS mode 	;AN000;
 45233                                  ;***	I_am	UU_BUF_EMS_HANDLE,BYTE		; buffer EMS handle ;AN000;
 45234                                  ;***	I_am	UU_BUF_EMS_PAGE_FRAME,WORD ,<-1>; EMS page frame # ;AN000;
 45235                                  ;***	I_am	UU_BUF_EMS_SEG_CNT,WORD,<1>	; EMS seg count	;AN000;
 45236                                  ;***	I_am	UU_BUF_EMS_PFRAME,WORD		; EMS page frame seg address ;AN000;
 45237                                  ;***	I_am	UU_BUF_EMS_RESERV,WORD,<0> 	; reserved	;AN000;
 45238                                  ;
 45239                                  ;***	I_am	UU_BUF_EMS_MAP_BUFF,1,<0>	; this is not used to save the 
 45240                                  						; state of the 	buffers page.
 45241                                  						; This one byte is retained to 
 45242                                  						; keep the size of this data 
 45243                                  						; block the same.;
 45244                                  ALLOCMSAVE:
 45245 00000084 00                      	db	0	; M063: temp var. used to 
 45246                                  			; M063: save alloc method in
 45247                                  			; M063: msproc.asm
 45248                                  A20OFF_COUNT:
 45249 00000085 00                      	db	0	; M068: indiactes the # of 
 45250                                  			; M068: int 21 calls for 
 45251                                  			; M068: which A20 is off
 45252                                  DOS_FLAG:
 45253 00000086 00                      	db	0	; see DOSSYM.INC for Bit 
 45254                                  			; definitions
 45255                                  UNPACK_OFFSET:
 45256 00000087 0000                    	dw	0	; saves pointer to the start
 45257                                  			; of unpack code in exepatch.
 45258                                  			; asm.
 45259                                  UMBFLAG:
 45260 00000089 00                      	db	0 	; M003: bit 0 indicates the 
 45261                                  			; M003: link state of the UMBs
 45262                                  			; M003: whether linked or not 
 45263                                  			; M003: to the DOS arena chain
 45264                                  SAVE_AX:
 45265 0000008A 0000                    	dw	0	; M000: temp varibale to store ax
 45266                                  			; M000: in msproc.asm
 45267                                  UMB_HEAD:
 45268 0000008C FFFF                    	dw	-1	; M000: this is initialized to  
 45269                                  			; M000: the first umb arena by 
 45270                                  			; M000: BIOS sysinit.
 45271                                  START_ARENA:
 45272 0000008E 0100                    	dw	1	; M000: this is the first arena 
 45273                                  			; M000: from which DOS will 
 45274                                  			; M000: start its scan for alloc.
 45275                                  
 45276                                  ; End of SYSINITVar block
 45277                                  ;----------------------------------------------------------------------------
 45278                                  
 45279                                  ; 25/04/2019 - Retro DOS v4.0
 45280                                  
 45281                                  ; 16/07/2018
 45282                                  ; MSDOS 3.3 (& MDOS 6.0)
 45283                                  
 45284                                  ;
 45285                                  ; Sharer jump table
 45286                                  ;
 45287                                  
 45288                                  ;PUBLIC	JShare
 45289                                  	;EVEN
 45290                                  
 45291                                  ;JShare	LABEL	DWORD
 45292                                  ;	DW	OFFSET DOSCODE:BadCall, 0
 45293                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	1   MFT_enter
 45294                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	2   MFTClose
 45295                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	3   MFTclU
 45296                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	4   MFTCloseP
 45297                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	5   MFTCloN
 45298                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	6   set_block
 45299                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	7   clr_block
 45300                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	8   chk_block
 45301                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	9   MFT_get
 45302                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	10  ShSave
 45303                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	11  ShChk
 45304                                  ;	DW	OFFSET DOSCODE:OKCall , 0  ;	12  ShCol
 45305                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	13  ShCloseFile
 45306                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	14  ShSU
 45307                                  
 45308                                  align 2
 45309                                  
 45310                                  JShare:
 45311 00000090 [F706]0000              		DW	BadCall,0
 45312 00000094 [FB06]0000              MFT_enter:	DW	OKCall, 0  ; 1   MFT_enter
 45313 00000098 [FB06]0000              MFTClose:	DW	OKCall, 0  ; 2   MFTClose
 45314 0000009C [F706]0000              MFTclU:		DW	BadCall,0  ; 3   MFTclU
 45315 000000A0 [F706]0000              MFTCloseP:	DW	BadCall,0  ; 4   MFTCloseP
 45316 000000A4 [F706]0000              MFTCloN:	DW	BadCall,0  ; 5   MFTCloN
 45317 000000A8 [F706]0000              set_block:	DW	BadCall,0  ; 6   set_block
 45318 000000AC [F706]0000              clr_block:	DW	BadCall,0  ; 7   clr_block
 45319 000000B0 [FB06]0000              chk_block:	DW	OKCall, 0  ; 8   chk_block
 45320 000000B4 [F706]0000              MFT_get:	DW	BadCall,0  ; 9   MFT_get
 45321 000000B8 [F706]0000              ShSave:		DW	BadCall,0  ; 10  ShSave
 45322 000000BC [F706]0000              ShChk:		DW	BadCall,0  ; 11  ShChk
 45323 000000C0 [FB06]0000              ShCol:		DW	OKCall, 0  ; 12  ShCol
 45324 000000C4 [F706]0000              ShCloseFile:	DW	BadCall,0  ; 13  ShCloseFile
 45325 000000C8 [F706]0000              ShSU:		DW	BadCall,0  ; 14  ShSU
 45326                                  
 45327                                  
 45328                                  ;============================================================================
 45329                                  ; CONST2.ASM (MSDOS 6.0, 1991)
 45330                                  ;============================================================================
 45331                                  ; 25/04/2019 - Retro DOS 4.0 
 45332                                  ; 16/07/2018 - Retro DOS 3.0	
 45333                                  
 45334                                  ;Break <Initialized data and data used at DOS initialization>
 45335                                  ;----------------------------------------------------------------------------
 45336                                  
 45337                                  ; We need to identify the parts of the data area that are relevant to tasks
 45338                                  ; and those that are relevant to the system as a whole.  Under 3.0, the system
 45339                                  ; data will be gathered with the system code.  The process data under 2.x will
 45340                                  ; be available for swapping and under 3.0 it will be allocated per-process.
 45341                                  ;
 45342                                  ; The data that is system data will be identified by [SYSTEM] in the comments
 45343                                  ; describing that data item.
 45344                                  
 45345                                  ;DOSDATA SEGMENT WORD PUBLIC 'DATA'
 45346                                  
 45347                                  ;
 45348                                  ; Table of routines for assignable devices
 45349                                  ;
 45350                                  ; MSDOS allows assignment if the following standard devices:
 45351                                  ;   stdin  (usually CON input)
 45352                                  ;   stdout (usually CON output)
 45353                                  ;   auxin  (usually AUX input)
 45354                                  ;   auxout (usually AUX output)
 45355                                  ;   stdlpt (usually PRN output)
 45356                                  ;
 45357                                  ; SPECIAL NOTE:
 45358                                  ;   Status of a file is a strange idea. We choose to handle it in this manner:
 45359                                  ;   If we're not at end-of-file, then we always say that we have a character.
 45360                                  ;   Otherwise, we return ^Z as the character and set the ZERO flag. In this
 45361                                  ;   manner we can support program written under the old DOS (they use ^Z as EOF
 45362                                  ;   on devices) and programs written under the new DOS (they use the ZERO flag
 45363                                  ;   as EOF).
 45364                                  
 45365                                  ; Default SFTs for boot up
 45366                                  
 45367                                  		;PUBLIC	SFTABL
 45368                                  
 45369                                  SFTABL:	   ; LABEL   DWORD		; [SYSTEM] file table
 45370 000000CC FFFF                    		DW -1			; [SYSTEM] link to next table
 45371 000000CE FFFF                    		DW -1			; [SYSTEM] link seg to next table
 45372 000000D0 0500                    		DW sf_default_number	; [SYSTEM] Number of entries in table
 45373                                  		;times 295 db 0 ; MSDOS 6.0
 45374 000000D2 00<rep 127h>            		times (sf_default_number*sf_entry_size) db 0
 45375                                  
 45376                                  ; the next two variables relate to the position of the logical stdout/stdin
 45377                                  ; cursor. They are only meaningful when stdin/stdout are assigned to the
 45378                                  ; console.
 45379                                  		; DOSDATA:01F9h (MSDOS 6.21)
 45380 000001F9 00                      CARPOS:		db 0			; [SYSTEM] cursor position in stdin
 45381 000001FA 00                      STARTPOS:	db 0			; [SYSTEM] position of cursor at beginning
 45382                                  					;	   of buffered input call
 45383 000001FB 00<rep 80h>             INBUF:		times 128 db 0		; [SYSTEM] general device input buffer
 45384 0000027B 00<rep 83h>             CONBUF:		times 131 db 0		; [SYSTEM] The rest of INBUF and console buffer
 45385                                  		; DOSDATA:02FEh (MSDOS 6.21)
 45386 000002FE 00                      PFLAG:		db 0			; [SYSTEM] printer echoing flag
 45387 000002FF 00                      VERFLG:		db 0			; [SYSTEM] Initialize with verify off
 45388 00000300 03                      CHARCO:		db 00000011b		; [SYSTEM] Allows statchks every 4 chars...
 45389                                  switch_character:
 45390 00000301 2F                      chSwitch:	db '/'			; UNUSED - obsolete datum, can be reused
 45391 00000302 00                      AllocMethod:	db 0			; [SYSTEM] how to alloc first(best)last
 45392 00000303 00                      fShare:		db 0			; [SYSTEM] TRUE => sharing installed
 45393 00000304 01                      DIFFNAM:	db 1			; [SYSTEM] Indicates when MYNAME has changed
 45394 00000305 20<rep 10h>             MYNAME:		times 16 db 20h		; [SYSTEM] My network name
 45395                                  
 45396                                  ; The following table is a list of addresses that the sharer patches to be
 45397                                  ; PUSH AX to enable the critical sections
 45398                                  
 45399                                  		; DOSDATA:0315h (MSDOS 6.21)
 45400                                  
 45401                                  ;PUBLIC	CritPatch
 45402                                  
 45403                                  CritPatch:	; LABEL WORD
 45404                                  
 45405                                  ;IRP sect,<critDisk,critDevice>
 45406                                  
 45407                                  ;IF (NOT REDIRECTOR) AND (NOT SHAREF)
 45408                                  ;
 45409                                  ;SR; Change code patch address to a variable in data segment
 45410                                  ;
 45411                                  ;       dw OFFSET DOSDATA: redir_patch
 45412                                  ;       dw OFFSET DOSDATA: redir_patch
 45413                                  ;
 45414                                  ;;hkn	Short_Addr  E&sect
 45415                                  ;;hkn	Short_Addr  L&sect
 45416                                  ;
 45417                                  ;ELSE
 45418                                  ;	DW	0
 45419                                  ;	DW	0
 45420                                  ;ENDIF
 45421                                  ;ENDM
 45422                                  ;	DW	0
 45423                                  
 45424                                  	; 25/07/2019 - Retro DOS v4.0 (MSDOS 6.21)
 45425                                   
 45426 00000315 [0C0D]                  	dw 	redir_patch
 45427 00000317 [0C0D]                  	dw 	redir_patch			
 45428 00000319 [0C0D]                  	dw	redir_patch
 45429 0000031B [0C0D]                  	dw 	redir_patch
 45430                                  
 45431 0000031D 0000                    	dw	0
 45432                                  
 45433                                  ; WARNING!!! PRINT and PSPRINT *REQUIRE* ErrorMode to precede INDOS.
 45434                                  ; Also, IBM server 1.0 requires this also.
 45435                                  
 45436                                  	;EVEN			; Force swap area to start on word boundry
 45437 0000031F 90                      align 2
 45438                                  	;PUBLIC	SWAP_START
 45439                                  SWAP_START:	; LABEL BYTE
 45440 00000320 00                      ERRORMODE:	db 0		; Flag for INT 24 processing
 45441 00000321 00                      INDOS:		db 0		; DOS status for interrupt processing
 45442 00000322 FF                      WPERR:		db -1		; Write protect error flag
 45443 00000323 00                      EXTERR_LOCUS:	db 0		; Extended Error Locus
 45444 00000324 0000                    EXTERR:		dw 0		; Extended Error code
 45445                                  
 45446                                  ;WARNING Following two bytes Accessed as word in $GetExtendedError
 45447 00000326 00                      EXTERR_ACTION:	db 0		; Extended Error Action
 45448 00000327 00                      EXTERR_CLASS:	db 0		; Extended Error Class
 45449                                  ; end warning
 45450                                   
 45451 00000328 00000000                EXTERRPT:	dd 0		; Extended Error pointer
 45452                                  
 45453 0000032C 80000000                DMAADD:		dd 80h		; User's disk transfer address (disp/seg)
 45454 00000330 0000                    CurrentPDB:	dw 0		; Current process identifier
 45455 00000332 0000                    ConC_Spsave:	dw 0		; saved SP before ^C
 45456 00000334 0000                    exit_code:	dw 0		; exit code of last proc.
 45457 00000336 00                      CURDRV:		db 0		; Default drive (init A)
 45458 00000337 00                      CNTCFLAG:	db 0		; ^C check in dispatch disabled
 45459                                  ;				; F.C. 2/17/86
 45460 00000338 00                      CPSWFLAG:	db 0		; Code Page Switching Flag  DOS 4.00
 45461 00000339 00                      CPSWSAVE:	db 0		; copy of above in case of ABORT
 45462                                  ;align 2
 45463                                  SWAP_ALWAYS:	; 05/08/2018
 45464 0000033A 0000                    USER_IN_AX:	dw 0		; User INPUT AX value (used for
 45465                                  				;   extended error type stuff.
 45466                                  				;   NOTE: does not have Correct value on
 45467                                  				;   1-12, OEM, Get/Set CurrentPDB,
 45468                                  				;   GetExtendedError system calls)
 45469 0000033C 0000                    PROC_ID:	dw 0		; PID for sharing (0 = local)
 45470 0000033E 0000                    USER_ID:	dw 0		; Machine for sharing (0 = local)
 45471 00000340 0000                    FirstArena:	dw 0		; first free block found
 45472 00000342 0000                    BestArena:	dw 0		; best free block found
 45473 00000344 0000                    LastArena:	dw 0		; last free block found
 45474 00000346 0000                    ENDMEM:		dw 0		; End of memory used in DOSINIT
 45475 00000348 0000                    LASTENT:	dw 0		; Last entry for directory search
 45476 0000034A 00                      FAILERR:	db 0		; NZ if user did FAIL on I 24
 45477 0000034B 00                      ALLOWED:	db 0		; Allowed I 24 answers (see allowed_)
 45478 0000034C 00                      NoSetDir:	db 0		; true -> do not set directory
 45479 0000034D 00                      DidCTRLC:	db 0		; true -> we did a ^C exit
 45480 0000034E 00                      SpaceFlag:	db 0		; true -> embedded spaces are allowed in FC
 45481                                  
 45482                                  ; Warning!  The following items are accessed as a WORD in TIME.ASM
 45483                                  	;EVEN
 45484 0000034F 90                      align 2
 45485                                  		; DOSDATA:0350h (MSDOS 6.21)
 45486 00000350 00                      DAY:		db 0		; Day of month
 45487 00000351 00                      MONTH:		db 0		; Month of year
 45488 00000352 0000                    YEAR:		dw 0		; Year (with century)
 45489 00000354 FFFF                    DAYCNT:		dw -1		; Day count from beginning of year
 45490 00000356 00                      WEEKDAY:	db 0		; Day of week
 45491                                  ; end warning
 45492                                  
 45493 00000357 00                      CONSWAP:	db 0		; TRUE => console was swapped during device read
 45494 00000358 01                      IDLEINT:	db 1		; TRUE => idle int is allowed
 45495 00000359 00                      fAborting:	db 0		; TRUE => abort in progress
 45496                                  
 45497                                  ; Combination of all device call parameters
 45498                                  	;PUBLIC	DEVCALL 	;
 45499                                  ;DEVCALL SRHEAD	<>		; basic header for disk packet
 45500                                  DEVCALL: ; 08/08/2018
 45501 0000035A 00                      DEVCALL_REQLEN:  db 0 		;Length in bytes of request block
 45502 0000035B 00                      DEVCALL_REQUNIT: db 0		;Device unit number
 45503 0000035C 00                      DEVCALL_REQFUNC: db 0		;Type of request
 45504 0000035D 0000                    DEVCALL_REQSTAT: dw 0		;Status Word
 45505 0000035F 00<rep 8h>                       times 8 db 0		;Reserved for queue links
 45506                                  
 45507                                  	;PUBLIC	CALLUNIT
 45508                                  CALLUNIT: ; LABEL   BYTE	; unit number for disk
 45509                                  CALLFLSH: ; LABEL   WORD	;
 45510 00000367 00                      CALLMED:	db 0		; media byte
 45511                                  CALLBR:	  ; LABEL   DWORD	;
 45512                                  	;PUBLIC	CALLXAD 	;
 45513                                  CALLXAD:  ; LABEL   DWORD	;
 45514 00000368 00                      CALLRBYT:	db 0		;
 45515                                  	;PUBLIC	CALLVIDM	;
 45516                                  CALLVIDM: ; LABEL   DWORD	;
 45517 00000369 00<rep 3h>              	times 3 db 0	;
 45518                                  	;PUBLIC CallBPB		;
 45519                                  CALLBPB:  ; LABEL   DWORD	;
 45520                                  CALLSCNT:			;
 45521 0000036C 0000                    		dw 0		;
 45522                                  	;PUBLIC	CALLSSEC	;
 45523                                  CALLSSEC: ; LABEL   WORD	;
 45524 0000036E 0000                    		dw 0		;
 45525 00000370 00000000                CALLVIDRW:	dd 0		;
 45526                                  ;MSDOS 6.0
 45527 00000374 00000000                CALLNEWSC:	dd 0		; starting sector for >32mb
 45528 00000378 00000000                CALLDEVAD:	dd 0		; stash for device entry point
 45529                                  
 45530                                  ; Same as above for I/O calls	;
 45531                                  				;
 45532                                  	;PUBLIC	IOCall		;
 45533                                  ;IOCALL	SRHEAD	<>		;
 45534                                  IOCALL:	; 07/08/2018
 45535 0000037C 00                      IOCALL_REQLEN:	db 0		;Length in bytes of request block	
 45536 0000037D 00                      IOCALL_REQUNIT:	db 0		;Device unit number
 45537 0000037E 00                      IOCALL_REQFUNC: db 0		;Type of request
 45538 0000037F 0000                    IOCALL_REQSTAT: dw 0		;Status Word
 45539 00000381 00<rep 8h>              	times 8	db 0		;Reserved for queue links
 45540                                  IOFLSH:	  ; LABEL   WORD	;
 45541                                          ;PUBLIC  IORCHR		;
 45542                                  IORCHR:	  ; LABEL   BYTE	;
 45543 00000389 00                      IOMED:		db 0		;
 45544 0000038A 00000000                IOXAD:		dd 0		;
 45545 0000038E 0000                    IOSCNT:		dw 0		;	
 45546 00000390 0000                    IOSSEC:		dw 0		;
 45547                                  
 45548                                  ; Call struct for DSKSTATCHK	;
 45549 00000392 0E                      DSKSTCALL:	db DRDNDHL 	; = 14
 45550 00000393 00                      		db 0
 45551 00000394 05                      DSKSTCOM:	db DEVRDND	; = 5
 45552 00000395 0000                    DSKSTST:	dw 0		;
 45553 00000397 00<rep 8h>              	times 8	db 0		;
 45554 0000039F 00                      DSKCHRET:	db 0		;
 45555                                  
 45556                                  ;hkn; short_addr has been changed to provide offset in DOSCODE.
 45557                                  ;hkn; deviobuf is in DATA seg (DOSDATA)
 45558                                  ;hkn   short_addr  DEVIOBUF	;
 45559                                  	
 45560 000003A0 [BC03]                  DEVIOBUF_PTR	dw DEVIOBUF
 45561 000003A2 0000                    DOSSEG_INIT	dw 0		; DOS segment set at Init
 45562 000003A4 0100                    DSKSTCNT:	dw 1		;
 45563 000003A6 0000                    		dw 0		;
 45564                                  
 45565 000003A8 00                      CreatePDB:	db 0		; flag for creating a process
 45566                                  
 45567                                  ;MSDOS 6.0
 45568                                  Lock_Buffer:	; LABEL  DWORD	;MS. DOS Lock Buffer for Ext Lock
 45569 000003A9 00000000                		dd 0		;MS. position
 45570 000003AD 00000000                		dd 0		;MS. length
 45571                                  
 45572                                  ;hkn; the foll. was moved from dosmes.asm.
 45573                                  
 45574                                  	;EVEN
 45575 000003B1 90                      align 2				; needed to maintain offsets
 45576                                  
 45577                                  		; DOSDATA:03B2h (MSDOS 6.21)
 45578                                  USERNUM:
 45579 000003B2 0000                     		dw 0		; 24 bit user number
 45580 000003B4 00                      		db 0
 45581                                  ;IF IBM
 45582                                  ;IF IBMCOPYRIGHT
 45583                                  ;OEMNUM:	DB 0		; 8 bit OEM number
 45584                                  ;ELSE
 45585                                  ;OEMNUM:	DB 0FFh		; 8 bit OEM number
 45586                                  ;ENDIF
 45587                                  ;ELSE
 45588 000003B5 FF                      OEMNUM:		DB 0FFh
 45589                                  ;ENDIF
 45590                                  
 45591                                  ;============================================================================
 45592                                  ; MS_DATA.ASM (MSDOS 6.0, 1991)
 45593                                  ;============================================================================
 45594                                  ; 25/04/2019 - Retro DOS 4.0
 45595                                  
 45596                                  ; Retro DOS v4.0 NOTE: (by Erdogan Tan, 25/04/2019)
 45597                                  ; ----------------------------------------------------------
 45598                                  ; This data section which was named as uninitialized data
 45599                                  ; (as overlayed by initialization code) but follows 
 45600                                  ; initialized data section from DOSDATA:03B6h address
 45601                                  ; (in otherwords, the method is different than MSDOS 3.3,
 45602                                  ; and there is not overlaying..)
 45603                                  ; **********************************************************
 45604                                  ; Reference: MSDOS 6.21 kernel DOSDATA section (4970 bytes)
 45605                                  ; follows DOSCODE section in the kernel file (MSDOS.SYS) 
 45606                                  ; (it is located at offset 0BF70h, file offset 0BF70h-3DE0h) 
 45607                                  ; but starts from offset 0 (ORG 0) and ends at offset 1370h.
 45608                                  ; TIMEBUF is at offset 03B6h.
 45609                                  ; **********************************************************	
 45610                                  
 45611                                  ;Break <Uninitialized data overlayed by initialization code>
 45612                                  ;----------------------------------------------------------------------------
 45613                                  ;DOSDATA    SEGMENT WORD PUBLIC 'DATA'
 45614                                  ; Init code overlaps with data area below
 45615                                  
 45616                                  ; 	ORG     0
 45617                                  
 45618                                  MSDAT001S:	; label byte
 45619                                  
 45620                                  ; DOSDATA:03B6h	; MSDOS 6.21 (MSDOS.SYS, file offset 0BF70h-3DE0h+3B6h)
 45621                                  TIMEBUF: ;	times 6 db 0
 45622 000003B6 0000<rep 3h>            	times 3 dw	0		; Time read from clock device
 45623 000003BC 0000                    DEVIOBUF:	dw	0		; Buffer for I/O under file assignment
 45624                                  
 45625                                  ; The following areas are used as temp buffer in EXEC system call
 45626                                  
 45627                                  ; DOSDATA:03BEh
 45628                                  OPENBUF: ;times 64  dw	0
 45629 000003BE 00<rep 80h>             	times	128 db	0		; buffer for name operations
 45630                                  RENBUF:	
 45631 0000043E 00<rep 80h>             	times	128 db	0		; buffer for rename destination
 45632                                  
 45633                                  ; Buffer for search calls
 45634                                  SEARCHBUF:	
 45635 000004BE 00<rep 35h>             	times	53  db	0		; internal search buffer
 45636                                  DUMMYCDS:  ;times 88 db 0
 45637 000004F3 00<rep 58h>             	times	curdirLen db 0
 45638                                  
 45639                                  ; End of contiguous buffer
 45640                                   
 45641                                  ; Temporary directory entry for use by many routines. Device directory
 45642                                  ; entries (bogus) are built here.
 45643                                  
 45644                                  ; DOSDATA:054Bh
 45645                                  
 45646                                  DEVFCB:	; LABEL   BYTE			; Uses NAME1, NAME2, combined
 45647                                  
 45648                                  ; WARNING..  do not alter position of NAME1 relative to DEVFCB
 45649                                  ; without first examining BUILD_DEVICE_ENT. Look carefully at DOS_RENAME
 45650                                  ; as well as it is the only guy who uses NAME2 and DESTSTART.
 45651                                  
 45652                                  NAME1:	
 45653 0000054B 00<rep Ch>                      times 	12 db	0		; File name buffer
 45654                                  NAME2:
 45655 00000557 00<rep Dh>              	times	13 db	0 		;
 45656                                  DESTSTART:
 45657 00000564 0000                    	dw	0			;
 45658                                          ;DB      ((SIZE DIR_ENTRY) - ($ - DEVFCB)) DUP (?)
 45659                                  	;times	5  db	0
 45660 00000566 00<rep 5h>              	times	((dir_entry.size)-($-DEVFCB)) db 0
 45661                                  
 45662                                  ; End Temporary directory entry.
 45663                                  
 45664 0000056B 00                      ATTRIB:	db	0		; storage for file attributes
 45665                                  EXTFCB:	
 45666 0000056C 00                      	db	0		; TRUE => extended FCB in use
 45667                                  SATTRIB:
 45668 0000056D 00                      	db	0		; Storage for search attributes
 45669                                  OPEN_ACCESS:
 45670 0000056E 00                      	db	0		; access of open system call
 45671                                  FOUNDDEL:
 45672 0000056F 00                      	db	0		; true => file was deleted
 45673                                  FOUND_DEV:
 45674 00000570 00                      	db	0		; true => search found a device
 45675                                  FSPLICE:
 45676 00000571 00                      	db	0		; true => do a splice in transpath
 45677                                  FSHARING:
 45678 00000572 00                      	db	0		; TRUE => no redirection
 45679                                  SECCLUSPOS:
 45680 00000573 00                      	db	0		; Position of first sector within cluster
 45681 00000574 00                      TRANS:	db	0		;
 45682 00000575 00                      READOP:	db	0		;
 45683                                  THISDRV:
 45684 00000576 00                      	db	0		;
 45685                                  CLUSFAC:
 45686 00000577 00                      	db	0		;
 45687                                  CLUSSPLIT:
 45688 00000578 00                      	db	0		;
 45689                                  INSMODE:
 45690 00000579 00                      	db	0		; true => insert mode in buffered read
 45691 0000057A 00                      CMETA:	db	0		; count of meta'ed components found
 45692 0000057B 00                      VOLID:	db	0		;
 45693                                  EXIT_TYPE:
 45694 0000057C 00                      	db	0		; type of exit...
 45695                                   
 45696                                  	;EVEN
 45697                                  
 45698 0000057D 90                      align 2
 45699                                  
 45700                                  ; DOSDATA:057Eh
 45701                                  
 45702                                  ; WARNING - the following two items are accessed as a word
 45703                                  
 45704                                  CREATING:
 45705 0000057E 00                      	db	0		; true => creating a file
 45706 0000057F 00                      DELALL:	db	0		; = 0 iff BUGBUG
 45707                                  				; = DIRFREE iff BUGBUG
 45708                                  EXITHOLD:
 45709 00000580 00000000                	dd	0		; Temp location for proc terminate
 45710                                  USER_SP:
 45711 00000584 0000                    	dw	0		; User SP for system call
 45712                                  USER_SS:
 45713 00000586 0000                    	dw	0		; User SS for system call
 45714                                  CONTSTK:
 45715 00000588 0000                    	dw	0		;
 45716                                  THISDPB:
 45717 0000058A 00000000                	dd	0		;
 45718                                  CLUSSAVE:
 45719 0000058E 0000                    	dw	0		;
 45720                                  CLUSSEC:
 45721 00000590 00000000                	dd	0		;>32mb			AC0000
 45722                                  PREREAD:
 45723 00000594 0000                    	dw	0		; 0 means preread; 1 means optional
 45724 00000596 0000                    FATBYT:	dw	0		; Used by ALLOCATE
 45725                                  FATBYTE:
 45726 00000598 0000                    	dw	0		; Used by $SLEAZEFUNC
 45727                                  ; DOSDATA:059Ah
 45728 0000059A 00000000                DEVPT:	dd	0		;
 45729                                  THISSFT:
 45730 0000059E 00000000                	dd	0		; Address of user SFT
 45731                                  THISCDS:
 45732 000005A2 00000000                	dd	0		; Address of current CDS
 45733                                  THISFCB:
 45734 000005A6 00000000                	dd	0		; Address of user FCB
 45735 000005AA FFFF                    SFN:	dw	-1		; SystemFileNumber found for accessfile
 45736 000005AC 0000                    JFN:	dw	0		; JobFileNumber found for accessfile
 45737 000005AE 00000000                PJFN:	dd	0		; PointerJobFileNumber found for accessfile
 45738                                  WFP_START:
 45739 000005B2 0000                    	dw	0		;
 45740                                  REN_WFP:
 45741 000005B4 0000                    	dw	0		;
 45742                                  CURR_DIR_END:
 45743 000005B6 0000                    	dw	0		;
 45744                                  NEXTADD:
 45745 000005B8 0000                    	dw	0		;
 45746                                  LASTPOS:
 45747 000005BA 0000                    	dw	0		;
 45748                                  CLUSNUM:
 45749 000005BC 0000                    	dw	0		;
 45750 000005BE 00000000                DIRSEC:	dd	0		;>32mb			AC0000
 45751                                  DIRSTART:
 45752 000005C2 0000                    	dw	0		;
 45753 000005C4 00000000                SECPOS:	dd	0		;>32mb Position of first sector accessed
 45754 000005C8 00000000                VALSEC:	dd	0		;>32mb Number of valid (previously written)
 45755                                                                  ; sectors
 45756                                  BYTSECPOS:
 45757 000005CC 0000                    	dw	0		; Position of first byte within sector
 45758                                  BYTPOS: ;times	4 db 0		; Byte position in file of access
 45759 000005CE 0000<rep 2h>                    times	2 dw 0
 45760                                  BYTCNT1:
 45761 000005D2 0000                    	dw	0		; No. of bytes in first sector
 45762                                  BYTCNT2:
 45763 000005D4 0000                    	dw	0		; No. of bytes in last sector
 45764 000005D6 0000                    SECCNT:	dw	0		; No. of whole sectors
 45765                                  ; DOSDATA:05D8h
 45766                                  ENTFREE:
 45767 000005D8 0000                    	dw	0		;
 45768                                  ENTLAST:
 45769 000005DA 0000                    	dw	0		;
 45770                                  NXTCLUSNUM:
 45771 000005DC 0000                    	dw	0		;
 45772                                  GROWCNT:
 45773 000005DE 00000000                	dd	0		;
 45774 000005E2 00000000                CURBUF:	dd	0		;
 45775 000005E6 00000000                CONSFT:	dd	0		; SFT of console swapped guy.
 45776 000005EA 0000                    SAVEBX:	dw	0		;
 45777 000005EC 0000                    SAVEDS:	dw	0		;
 45778                                  RESTORE_TMP:
 45779 000005EE 0000                    	dw	0		; return address for restore world
 45780 000005F0 0000                    NSS:	dw	0
 45781 000005F2 0000                    NSP:	dw	0
 45782                                  ; DOSDATA:05F4h
 45783                                  EXTOPEN_FLAG:
 45784 000005F4 0000                    	dw	0		;FT. extended open input flag	;AN000;
 45785                                  EXTOPEN_ON:
 45786 000005F6 00                      	db	0		;FT. extended open conditional flag ;AN000;
 45787                                  EXTOPEN_IO_MODE:
 45788 000005F7 0000                    	dw	0		;FT. extended open io mode	;AN000;
 45789                                  SAVE_DI:
 45790 000005F9 0000                    	dw	0		;FT. extended open saved DI	;AN000;
 45791                                  SAVE_ES:
 45792 000005FB 0000                    	dw	0		;FT. extended open saved ES	;AN000;
 45793                                  SAVE_DX:
 45794 000005FD 0000                    	dw	0		;FT. extended open saved DX	;AN000;
 45795                                  SAVE_CX:
 45796 000005FF 0000                    	dw	0		;FT. extended open saved CX	;AN000;
 45797                                  SAVE_BX:
 45798 00000601 0000                    	dw	0		;FT. extended open saved BX	;AN000;
 45799                                  SAVE_SI:
 45800 00000603 0000                    	dw	0		;FT. extended open saved SI	;AN000;
 45801                                  SAVE_DS:
 45802 00000605 0000                    	dw	0		;FT. extended open saved DS	;AN000;
 45803                                  
 45804                                  ; DOSDATA:0607h
 45805                                  
 45806                                  ; HIGH_SECTOR is a hack to allow passing 32-bit sector numbers where
 45807                                  ; we used to just pass 16 bits in a register. Now High_SECTOR holds
 45808                                  ; the high 16, the low 16 are still in the register.
 45809                                  
 45810                                  HIGH_SECTOR:	
 45811 00000607 0000                    	dw	0		;>32mb higher sector #		;AN000;
 45812                                  	; 25/09/2023
 45813                                  OffsetMagicPatch:
 45814                                  	;dw	MagicPatch	;scottq 8/6/92
 45815                                  	; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45816 00000609 0000                    	dw	0
 45817                                  				;see dos\mpatch.asm
 45818                                  DISK_FULL:
 45819 0000060B 00                      	db	0		;>32mb indicating disk full when 1 ;AN000;
 45820                                  TEMP_VAR:
 45821 0000060C 0000                    	dw	0		; temporary variable for everyone ;AN000;
 45822                                  TEMP_VAR2:
 45823 0000060E 0000                    	dw	0		; temporary variable 2 for everyone ;AN000;
 45824 00000610 00                      DrvErr:	db	0		; used to save drive error	;AN000;
 45825                                  DOS34_FLAG:
 45826 00000611 0000                    	dw	0		; common flag for DOS 3.4	;AN000;
 45827                                  NO_FILTER_PATH:
 45828 00000613 00000000                	dd	0		; pointer to original path	;AN000;
 45829                                  NO_FILTER_DPATH:
 45830 00000617 00000000                	dd	0		; pointer to original path of destination ;AN000;
 45831                                  ; M008
 45832                                  AbsRdWr_SS:
 45833 0000061B 0000                    	dw	0		; INT 25/26 user stack segment
 45834                                  AbsRdWr_SP:
 45835 0000061D 0000                    	dw	0		; INT 25/26 user stack offset
 45836                                  
 45837                                  	; I_am  UU_Callback_flag,BYTE,<0>  ; Unused
 45838                                  ; M008
 45839                                  	; 24/03/2024
 45840                                  	; MSDOS 6.22 MSDOS.SYS - DOSDATA:061Fh
 45841                                  	; MSDOS 5.0 MSDOS.SYS - DOSDATA:061Fh
 45842                                  	; PCDOS 7.1 IBMDOS.COM - DOSDATA:061Fh
 45843 0000061F 00                      	db 	0
 45844                                   
 45845                                  ; make those pushes fast!!!
 45846                                  ;EVEN
 45847                                  
 45848                                  align 2
 45849                                  
 45850                                  StackSize   equ 180h  ; 384	; gross but effective
 45851                                  
 45852                                  ;StackSize  equ 300h  ;	768	; This is a "trial" change IBM hasn't
 45853                                  ;				; made up their minds about
 45854                                   
 45855                                  ; WARNING!!!! DskStack may grow into AUXSTACK due to interrupt service.
 45856                                  ; This is NO problem as long as AUXSTACK comes immediately before DSKSTACK
 45857                                  
 45858                                  RENAMEDMA:	; LABEL   BYTE	; See DOS_RENAME
 45859                                   
 45860 00000620 00<rep 180h>                    times	StackSize db	0	;
 45861                                  AUXSTACK:			; LABEL   BYTE
 45862                                   
 45863 000007A0 00<rep 180h>                    times	StackSize db 	0	;
 45864                                  DSKSTACK:			; LABEL   BYTE
 45865                                   
 45866 00000920 00<rep 180h>                    times	StackSize db	0	;
 45867                                  IOSTACK:			; LABEL   BYTE
 45868                                  
 45869                                  ; DOSDATA:0AA0h 
 45870                                   
 45871                                  ; patch space for Boca folks.
 45872                                  ; Say What????!!! This does NOT go into the swappable area!
 45873                                  ; NOTE: We include the decl of ibmpatch in ms-dos even though it is not needed.
 45874                                  ;       This allows the REDIRector to work on either IBM or MS-DOS.
 45875                                   
 45876                                  IBMPATCH: ; label byte
 45877                                  PRINTER_FLAG:
 45878 00000AA0 00                      	db	0		; [SYSTEM] status of PRINT utility
 45879                                  VOLCHNG_FLAG:
 45880 00000AA1 00                      	db	0		; [SYSTEM] true if volume label created
 45881                                  VIRTUAL_OPEN:
 45882 00000AA2 00                      	db	0		; [SYSTEM] non-zero if we opened a virtual file
 45883                                   
 45884                                  ; Following 4 variables moved to MSDATA.asm from MSTABLE.asm (P4986)
 45885                                  
 45886                                  FSeek_drive:
 45887 00000AA3 00                      	db	0		;AN000; fastseek drive #
 45888                                  FSeek_firclus:
 45889 00000AA4 0000                    	dw	0		;AN000; fastseek first cluster #
 45890                                  FSeek_logclus:
 45891 00000AA6 0000                    	dw	0		;AN000; fastseek logical cluster #
 45892                                  FSeek_logsave:
 45893 00000AA8 0000                    	dw	0		;AN000; fastseek returned log clus #
 45894                                  
 45895                                  ; DOSDATA:0AAAh
 45896                                  
 45897                                  TEMP_DOSLOC:
 45898 00000AAA FFFF                    	dw	-1		;stores the temporary location of dos
 45899                                  				;at SYSINIT time.
 45900                                  SWAP_END:  ; LABEL   BYTE
 45901                                   
 45902                                  ; THE FOLLOWING BYTE MUST BE HERE, IMMEDIATELY FOLLOWING SWAP_END. IT CANNOT
 45903                                  ; BE USED. If the size of the swap data area is ODD, it will be rounded up
 45904                                  ; to include this byte.
 45905                                   
 45906 00000AAC 00                      	db	0
 45907                                  
 45908                                  ; DOSDATA:0AADh
 45909                                   
 45910                                  ;hkn;	DB	(512+80+32-(SWAP_END-ibmpatch)) DUP (?)
 45911                                  
 45912                                  ;DOSDATA    ENDS
 45913                                  
 45914                                  ;============================================================================
 45915                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
 45916                                  ;============================================================================
 45917                                  ; 27/04/2019 - Retro DOS 4.0
 45918                                  ; 16/07/2018 - Retro DOS 3.0
 45919                                  
 45920                                  ;DOSDATA Segment
 45921                                  
 45922                                  ; DOSDATA:0AADh (MSDOS 6.21, MSDOS.SYS)
 45923                                  
 45924                                  ;
 45925                                  ; upper case table
 45926                                  ; ---------------------------------------------------------------------------
 45927                                  UCASE_TAB:	; label   byte
 45928 00000AAD 8000                    	dw	128
 45929 00000AAF 809A45418E418F80        	db	128,154,069,065,142,065,143,128 
 45930 00000AB7 4545454949498E8F        	db	069,069,069,073,073,073,142,143
 45931 00000ABF 9092924F994F5555        	db	144,146,146,079,153,079,085,085
 45932 00000AC7 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
 45933 00000ACF 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
 45934 00000AD7 A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
 45935 00000ADF B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 45936 00000AE7 B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 45937 00000AEF C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 45938 00000AF7 C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 45939 00000AFF D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 45940 00000B07 D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 45941 00000B0F E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
 45942 00000B17 E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 45943 00000B1F F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 45944 00000B27 F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 45945                                  ;
 45946                                  ; file upper case table
 45947                                  ; ---------------------------------------------------------------------------
 45948                                  FILE_UCASE_TAB:	; label  byte
 45949 00000B2F 8000                    	dw	128
 45950 00000B31 809A45418E418F80        	db	128,154,069,065,142,065,143,128
 45951 00000B39 4545454949498E8F        	db	069,069,069,073,073,073,142,143
 45952 00000B41 9092924F994F5555        	db	144,146,146,079,153,079,085,085
 45953 00000B49 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
 45954 00000B51 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
 45955 00000B59 A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
 45956 00000B61 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 45957 00000B69 B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 45958 00000B71 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 45959 00000B79 C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 45960 00000B81 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 45961 00000B89 D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 45962 00000B91 E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
 45963 00000B99 E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 45964 00000BA1 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 45965 00000BA9 F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 45966                                  ;
 45967                                  ; file char list
 45968                                  ; ---------------------------------------------------------------------------
 45969                                  FILE_CHAR_TAB:	; label  byte
 45970 00000BB1 1600                    	dw	22				; length
 45971 00000BB3 0100FF                  	db	1,0,255 			; include all
 45972 00000BB6 000020                  	db	0,0,20h 			; exclude 0 - 20h
 45973 00000BB9 020E2E222F5C5B5D3A-     	db	2,14,'."/\[]:|<>+=;,'           ; exclude 14 special
 45973 00000BC2 7C3C3E2B3D3B2C     
 45974                                  	;db	24 dup (?)			; reserved
 45975 00000BC9 00<rep 18h>             	times	24 db 0
 45976                                  
 45977                                  ;
 45978                                  ; collate table
 45979                                  ; ---------------------------------------------------------------------------
 45980                                  COLLATE_TAB:	; label   byte
 45981 00000BE1 0001                    	dw	256
 45982 00000BE3 0001020304050607        	db	0,1,2,3,4,5,6,7
 45983 00000BEB 08090A0B0C0D0E0F        	db	8,9,10,11,12,13,14,15
 45984 00000BF3 1011121314151617        	db	16,17,18,19,20,21,22,23
 45985 00000BFB 18191A1B1C1D1E1F        	db	24,25,26,27,28,29,30,31
 45986 00000C03 2021222324252627        	db	" ","!",'"',"#","$","%","&","'"
 45987 00000C0B 28292A2B2C2D2E2F        	db	"(",")","*","+",",","-",".","/"
 45988 00000C13 3031323334353637        	db	"0","1","2","3","4","5","6","7"
 45989 00000C1B 38393A3B3C3D3E3F        	db	"8","9",":",";","<","=",">","?"
 45990 00000C23 4041424344454647        	db	"@","A","B","C","D","E","F","G"
 45991 00000C2B 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
 45992 00000C33 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
 45993 00000C3B 58595A5B5C5D5E5F        	db	"X","Y","Z","[","\","]","^","_"
 45994 00000C43 6041424344454647        	db	"`","A","B","C","D","E","F","G"
 45995 00000C4B 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
 45996 00000C53 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
 45997 00000C5B 58595A7B7C7D7E7F        	db	"X","Y","Z","{","|","}","~",127
 45998 00000C63 4355454141414143        	db	"C","U","E","A","A","A","A","C"
 45999 00000C6B 4545454949494141        	db	"E","E","E","I","I","I","A","A"
 46000 00000C73 4541414F4F4F5555        	db	"E","A","A","O","O","O","U","U"
 46001 00000C7B 594F552424242424        	db	"Y","O","U","$","$","$","$","$"
 46002 00000C83 41494F554E4EA6A7        	db	"A","I","O","U","N","N",166,167
 46003 00000C8B 3FA9AAABAC212222        	db	"?",169,170,171,172,"!",'"','"'
 46004 00000C93 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 46005 00000C9B B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 46006 00000CA3 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 46007 00000CAB C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 46008 00000CB3 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 46009 00000CBB D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 46010 00000CC3 E053                    	db	224,"S"
 46011 00000CC5 E2E3E4E5E6E7            	db	226,227,228,229,230,231
 46012 00000CCB E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 46013 00000CD3 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 46014 00000CDB F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 46015                                  
 46016                                  ; ------------------------------------------------<MSKK01>----------------------
 46017                                  
 46018                                  ; DOSDATA:0CE3h
 46019                                  
 46020                                  ; 29/04/2019
 46021                                  
 46022                                  ; dbcs is not supported in DOS 3.3
 46023                                  ;		   DBCS_TAB	    CC_DBCS <>
 46024                                  ;
 46025                                  ; DBCS for DOS 4.00			   2/12/KK
 46026                                  
 46027                                  DBCS_TAB:	; label byte		;AN000;  2/12/KK
 46028                                  ; ------------------------------------------------<MSKK01>----------------------
 46029                                  ;ifdef	DBCS
 46030                                  ; ifdef	  JAPAN
 46031                                  ;		dw	6		; <MSKK01>
 46032                                  ;		db	081h,09fh	; <MSKK01>
 46033                                  ;		db	0e0h,0fch	; <MSKK01>
 46034                                  ;		db	0,0		; <MSKK01>
 46035                                  ;
 46036                                  ;		db	0,0,0,0,0,0,0,0,0,0	; <MSKK01>
 46037                                  ; endif
 46038                                  ; ifdef	  TAIWAN
 46039                                  ;		dw	4		; <TAIWAN>
 46040                                  ;		db	081h,0FEh	; <TAIWAN>
 46041                                  ;		db	0,0		; <TAIWAN>
 46042                                  ;
 46043                                  ;		db	0,0,0,0,0,0,0,0,0,0,0,0
 46044                                  ; endif
 46045                                  ; ifdef   KOREA                         ; Keyl
 46046                                  ;               dw      4               ; <KOREA>
 46047                                  ;               db      0A1h,0FEh       ; <KOREA>
 46048                                  ;               db      0,0             ; <KOREA>
 46049                                  ;
 46050                                  ;		db	0,0,0,0,0,0,0,0,0,0,0,0
 46051                                  ;  endif
 46052                                  ;else
 46053 00000CE3 0000                    		dw	0		;AN000;  2/12/KK      max number
 46054                                  		;db	16 dup(0)	;AN000;  2/12/KK
 46055 00000CE5 00<rep 10h>             		times	16 db 0
 46056                                  
 46057                                  ;		dw	6		;  2/12/KK
 46058                                  ;		db	081h,09Fh	;  2/12/KK
 46059                                  ;		db	0E0h,0FCh	;  2/12/KK
 46060                                  ;		db	0,0		;  2/12/KK
 46061                                  ;
 46062                                  ;endif
 46063                                  ; ------------------------------------------------<MSKK01>----------------------
 46064                                  
 46065                                  ; DOSDATA:0CF5h
 46066                                  
 46067                                  ; ---------------------------------------------------------------------------
 46068                                  ;
 46069                                  ;CASE MAPPER ROUTINE FOR 80H-FFH character range, DOS 3.3
 46070                                  ;     ENTRY: AL = Character to map
 46071                                  ;     EXIT:  AL = The converted character
 46072                                  ; Alters no registers except AL and flags.
 46073                                  ; The routine should do nothing to chars below 80H.
 46074                                  ; ---------------------------------------------------------------------------
 46075                                  ; Example:
 46076                                  
 46077                                  MAP_CASE:
 46078                                  ;Procedure MAP_CASE,FAR
 46079                                  
 46080 00000CF5 3C80                    	CMP	AL,80h
 46081 00000CF7 7301                    	JAE	short Map1	;Map no chars below 80H ever
 46082 00000CF9 CB                      	RETF
 46083                                  Map1:
 46084 00000CFA 2C80                    	SUB	AL,80h		;Turn into index value
 46085 00000CFC 1E                      	PUSH	DS
 46086 00000CFD 53                      	PUSH	BX
 46087 00000CFE BB[AF0A]                	MOV	BX,UCASE_TAB+2
 46088                                  FINISH:
 46089 00000D01 0E                      	PUSH	CS		;Move to DS
 46090 00000D02 1F                      	POP	DS
 46091 00000D03 D7                      	XLAT			;Get upper case character
 46092 00000D04 5B                      	POP	BX
 46093 00000D05 1F                      	POP	DS
 46094                                  L_RET:	
 46095 00000D06 CB                      	RETF
 46096                                  
 46097                                  ;EndProc MAP_CASE
 46098                                  
 46099                                  ; ---------------------------------------------------------------------------
 46100                                  
 46101                                  ; The variables for ECS version are moved here for the same data alignments
 46102                                  ; as IBM-DOS and MS-DOS.
 46103                                  
 46104                                  InterChar:
 46105 00000D07 00                      	db	0	; Interim character flag ( 1= interim)  ;AN000;
 46106                                  ;------- NOTE: NEXT TWO BYTES SOMETIMES USED AS A WORD !! -------------------
 46107                                  DUMMY:	; LABEL   WORD
 46108                                  InterCon:  
 46109 00000D08 00                      	db	0	; Console in Interim mode ( 1= interim) ;AN000;
 46110                                  SaveCurFlg:
 46111 00000D09 00                      	db	0	; Print, do not advance cursor flag     ;AN000;
 46112                                  
 46113                                  ; ---------------------------------------------------------------------------
 46114                                  
 46115 00000D0A 0000                    TEMPSEG:  dw	0	;hkn; used to store ds.
 46116                                  redir_patch:
 46117 00000D0C 00                      	  db	0
 46118                                  
 46119                                  ; DOSDATA:0D0Dh
 46120                                  
 46121                                  Mark1:	; label byte
 46122                                  
 46123                                  ;IF2
 46124                                  ;	IF ((OFFSET MARK1) GT (OFFSET MSVERSION) )
 46125                                  ;		%OUT !DATA CORRUPTION!MARK1 OFFSET TOO BIG. RE-ORGANIZE DATA.
 46126                                  ;	ENDIF
 46127                                  ;ENDIF
 46128                                  
 46129 00000D0D 00<rep 5h>              	  times 5 db 0
 46130                                  
 46131                                  ;############################################################################
 46132                                  ;
 46133                                  ; ** HACK FOR DOS 4.0 REDIR **
 46134                                  ; 
 46135                                  ; The redir requires the following:
 46136                                  ;
 46137                                  ;	MSVERS	offset D12H
 46138                                  ;	YRTAB	offset D14H
 46139                                  ; 	MONTAB	offset D1CH
 46140                                  ;
 46141                                  ; WARNING! WARNING!
 46142                                  ; 
 46143                                  ; MARK1 SHOULD NOT BE >= 0D12H. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
 46144                                  ; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
 46145                                  ;
 46146                                  ; CURRENTLY MARK1 = 0D0DH
 46147                                  ;
 46148                                  ;############################################################################
 46149                                  
 46150                                  	;ORG	0D12h
 46151                                  
 46152                                  ; DOSDATA:0D12h (MSDOS 6.21, MSDOS.SYS)
 46153                                  
 46154                                  	;db	6
 46155                                  	;db	20
 46156                                  
 46157                                  	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
 46158                                  MSVERSION:				; MS-DOS version in hex for $GET_VERSION
 46159 00000D12 06                      MSMAJORV: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
 46160 00000D13 16                      MSMINORV: DB	MINOR_VERSION	; DOS_MINOR_VERSION
 46161                                  
 46162                                  ; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
 46163                                  ;
 46164                                  ;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>
 46165                                  ;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31>
 46166                                  
 46167                                  ; Days in year
 46168                                  
 46169                                  YRTAB:   
 46170 00000D14 C8A6                    	DB	200,166			; Leap year
 46171 00000D16 C8A5                    	DB	200,165
 46172 00000D18 C8A5                    	DB	200,165
 46173 00000D1A C8A5                    	DB	200,165
 46174                                  
 46175                                  ; Days of each month
 46176                                  
 46177                                  MONTAB:        
 46178 00000D1C 1F                      	DB      31                      ; January
 46179                                  february:
 46180 00000D1D 1C                      	DB	28 			; February--reset each 
 46181                                  					; time year changes
 46182 00000D1E 1F                              DB      31                      ; March
 46183 00000D1F 1E                              DB      30                      ; April
 46184 00000D20 1F                              DB      31                      ; May
 46185 00000D21 1E                              DB      30                      ; June
 46186 00000D22 1F                              DB      31                      ; July
 46187 00000D23 1F                              DB      31                      ; August
 46188 00000D24 1E                              DB      30                      ; September
 46189 00000D25 1F                              DB      31                      ; October
 46190 00000D26 1E                              DB      30                      ; November
 46191 00000D27 1F                              DB      31                      ; December
 46192                                  
 46193                                  ;----------------THE FOLL. BLOCK MOVED FROM TABLE SEG IN MS_TABLE.ASM-------
 46194                                  
 46195                                  ; SYS init extended table,   DOS 3.3   F.C. 5/29/86
 46196                                  
 46197                                  SysInitTable:
 46198                                  	;dw	SYSINITVAR
 46199 00000D28 [2600]                  	dw	SYSINITVARS	; pointer to sysinit var
 46200 00000D2A 0000                            dw      0		; segment
 46201 00000D2C [2A12]                          dw	COUNTRY_CDPG	; pointer to country tabl
 46202 00000D2E 0000                            dw      0		; segment of pointer
 46203                                  
 46204                                  ; DOS 3.3 F.C. 6/12/86
 46205                                  ; FASTOPEN communications area DOS 3.3   F.C. 5/29/86
 46206                                  
 46207                                  FastTable:				; a better name
 46208                                  FastOpenTable:
 46209 00000D30 0200                    	dw      2                       ; number of entries
 46210 00000D32 [8212]                  	dw      FastRet			; pointer to ret instr.
 46211 00000D34 0000                    	dw      0                       ; and will be modified by
 46212 00000D36 [8212]                  	dw      FastRet			; FASTxxx when loaded in
 46213 00000D38 0000                    	dw      0                       
 46214                                  
 46215                                  ; DOS 3.3 F.C. 6/12/86
 46216                                  
 46217                                  FastFlg:				; flags
 46218                                  FastOpenFlg:
 46219 00000D3A 00                      	db	0			; don't change the foll: order
 46220                                  
 46221                                  ; FastOpen_Ext_Info is used as a temporary storage for saving dirpos,dirsec
 46222                                  ; and clusnum which are filled by DOS 3.nc when calling FastOpen Insert
 46223                                  ; or filled by FastOPen when calling FastOpen Lookup
 46224                                  
 46225                                  FastOpen_Ext_Info: ; label  byte	;dirpos
 46226                                  	;db	SIZE FASTOPEN_EXTENDED_INFO dup(0)
 46227                                  	;times	11 db 0
 46228 00000D3B 00<rep Bh>              	times	FEI.size db 0
 46229                                  
 46230                                  ; Dir_Info_Buff is a dir entry buffer which is filled by FastOPen
 46231                                  ; when calling FastOpen Lookup
 46232                                  
 46233                                  Dir_Info_Buff:	; label  byte
 46234                                  	;db   	SIZE dir_entry dup (0)
 46235                                  	;times	32 db 0
 46236 00000D46 00<rep 20h>             	times	dir_entry.size db 0
 46237                                  
 46238                                  Next_Element_Start:
 46239 00000D66 0000                    	dw	0			; save next element start offset
 46240                                  Del_ExtCluster:
 46241 00000D68 0000                    	dw	0			; for dos_delete
 46242                                  
 46243                                  ; The following is a stack and its pointer for interrupt 2F which is used
 46244                                  ; by NLSFUNC. There is no significant use of this stack, we are just trying
 46245                                  ; not to destroy the INT 21 stack saved for the user.
 46246                                  
 46247                                  USER_SP_2F:	; LABEL  WORD
 46248 00000D6A [6C0D]                  	dw    	FAKE_STACK_2F
 46249                                  
 46250                                  Packet_Temp:	; label  word		; temporary packet used by readtime
 46251                                  DOS_TEMP:	; label  word		; temporary word
 46252                                  FAKE_STACK_2F:  
 46253                                  	; dw  14 dup (0)		; 12 register temporary storage
 46254 00000D6C 0000<rep Eh>            	times 14 dw 0
 46255                                  
 46256                                  Hash_Temp: 	;label  word		; temporary word
 46257                                  	;dw	4 dup (0)		; temporary hash table during config.sys
 46258 00000D88 0000<rep 4h>            	times	4 dw 0
 46259                                  
 46260                                  SCAN_FLAG:
 46261 00000D90 00                      	db     0			; flag to indicate key ALT_Q
 46262                                  DATE_FLAG:
 46263 00000D91 0000                    	dw     0                	; flag to update the date
 46264                                  
 46265                                  FETCHI_TAG:	; label  word		; OBSOLETE - no longer used
 46266 00000D93 0000                    	dw     0			; formerly part of IBM's piracy protection
 46267                                  
 46268                                  MSG_EXTERROR:	; label  DWORD		; for system message addr
 46269 00000D95 00000000                	dd     0               		; for extended error
 46270 00000D99 00000000                	dd     0			; for parser
 46271 00000D9D 00000000                	dd     0			; for critical errror
 46272 00000DA1 00000000                	dd     0			; for IFS
 46273 00000DA5 00000000                	dd     0			; for code reduction
 46274                                  
 46275                                  SEQ_SECTOR:	; label  DWORD 		; last sector read
 46276 00000DA9 FFFFFFFF                	dd     -1   
 46277                                  SC_SECTOR_SIZE:
 46278 00000DAD 0000                    	dw	0			; sector size for SC
 46279                                  SC_DRIVE:
 46280 00000DAF 00                      	db	0			; drive # for secondary cache
 46281                                  CurSC_DRIVE:
 46282 00000DB0 FF                      	db	-1			; current SC drive
 46283                                  CurSC_SECTOR:
 46284 00000DB1 00000000                	dd	0			; current SC starting sector
 46285                                  SC_STATUS:
 46286 00000DB5 0000                    	dw	0			; SC status word
 46287                                  SC_FLAG:
 46288 00000DB7 00                      	db	0			; SC flag
 46289                                  AbsDskErr:
 46290 00000DB8 0000                    	dw	0			; Storage for Abs dsk read/write err
 46291                                  
 46292                                  NO_NAME_ID:	; label byte
 46293 00000DBA 4E4F204E414D452020-     	db	'NO NAME    '		; null media id
 46293 00000DC3 2020               
 46294                                  
 46295                                  ;hkn; moved from TABLE segment in kstrin.asm
 46296                                  
 46297                                  KISTR001S:	; label	byte		; 2/17/KK
 46298 00000DC5 00                      LOOKSIZ: DB	0			; 0 if byte, NZ if word	2/17/KK
 46299                                  KISTR001E:	; label	byte		; 2/17/KK
 46300                                  
 46301                                  ; the nul device driver used to be part of the code. However, since the
 46302                                  ; header is in the data, and the entry points are only given as an offset,
 46303                                  ; the strategy and interrupt entry points must also be in the data now.
 46304                                  
 46305                                  ; DOSDATA:0DC6h
 46306                                  
 46307                                  SNULDEV:
 46308                                  ;procedure snuldev,far
 46309                                  	;or	word [es:bx+3],100h
 46310                                  	; 17/12/2022
 46311                                  	;or	byte [es:bx+4],01h
 46312                                  	; 05/01/2024 (Original MSDOS and RetroDOS DATA address compatibility)
 46313                                  	;or	byte [es:bx+SRHEAD.REQSTAT+1],(STDON>>8)
 46314 00000DC6 26814F030001            	or	word [es:bx+SRHEAD.REQSTAT],STDON ; set done bit
 46315                                  INULDEV:
 46316 00000DCC CB                      	retf				; must not be a return!
 46317                                  ;endproc snuldev
 46318                                  
 46319                                  ;M044
 46320                                  ; Second part of save area for saving last para of Windows memory
 46321                                  
 46322                                  WinoldPatch2:
 46323                                  	;db	8 dup (?)	; M044
 46324 00000DCD 00<rep 8h>              	times	8 db 0	
 46325                                  UmbSave2:
 46326                                  	;db	5 dup (?)	; M062
 46327 00000DD5 00<rep 5h>              	times	5 db 0
 46328                                  UmbSaveFlag:
 46329 00000DDA 00                      	db	0		; M062
 46330                                  
 46331                                  ; DOSDATA:0DDBh
 46332                                  
 46333                                  Mark2:	; label byte
 46334                                  
 46335                                  ;IF2
 46336                                  ;	IF ((OFFSET MARK2) GT (OFFSET ERR_TABLE_21) )
 46337                                  ;		%OUT !DATA CORRUPTION!MARK2 OFFSET TOO BIG. RE-ORGANIZE DATA.
 46338                                  ;	ENDIF
 46339                                  ;ENDIF
 46340                                  
 46341                                  ;############################################################################
 46342                                  ;
 46343                                  ; ** HACK FOR DOS 4.0 REDIR **
 46344                                  ; 
 46345                                  ; The redir requires the following:
 46346                                  ;
 46347                                  ;	ERR_TABLE_21	offset DDBH
 46348                                  ;	ERR_TABLE_24	offset E5BH
 46349                                  ; 	ErrMap24	offset EABH
 46350                                  ;
 46351                                  ; WARNING! WARNING!
 46352                                  ;
 46353                                  ; MARK2 SHOULD NOT BE >= 0DDBH. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
 46354                                  ; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
 46355                                  ;
 46356                                  ; CURRENTLY MARK2 = 0DD0H
 46357                                  ;
 46358                                  ;############################################################################
 46359                                  
 46360                                  	;ORG	0DDBh
 46361                                  
 46362                                  ; DOSDATA:0DDBh (MSDOS 6.21, MSDOS.SYS)
 46363                                  
 46364                                  ; ---------------------------------------------------------------------------
 46365                                  ;
 46366                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 21H
 46367                                  ; errors. Each entry is 4 bytes long:
 46368                                  ;
 46369                                  ;       Err#,Class,Action,Locus
 46370                                  ;
 46371                                  ; A value of 0FFh indicates a call specific value (ie. should already
 46372                                  ; be set). AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
 46373                                  ; THE END, IT IS ASSUMES THAT CLASS, ACTION, LOCUS IS ALREADY SET.
 46374                                  ;
 46375                                  ; ---------------------------------------------------------------------------
 46376                                  
 46377                                  ;ErrTab  Macro   err,class,action,locus
 46378                                  ;ifidn <locus>,<0FFh>
 46379                                  ;    DB  error_&err,errCLASS_&class,errACT_&action,0FFh
 46380                                  ;ELSE
 46381                                  ;    DB  error_&err,errCLASS_&class,errACT_&action,errLOC_&locus
 46382                                  ;ENDIF
 46383                                  ;ENDM
 46384                                  
 46385                                  ERR_TABLE_21: ; LABEL   BYTE
 46386 00000DDB 010704FF                    DB  error_invalid_function,       errCLASS_Apperr,    errACT_Abort,    0FFh
 46387 00000DDF 02080302                    DB  error_file_not_found,         errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 46388 00000DE3 03080302                    DB  error_path_not_found,         errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 46389 00000DE7 04010401                    DB  error_too_many_open_files,    errCLASS_OutRes,    errACT_Abort,    errLOC_Unk
 46390 00000DEB 050303FF                    DB  error_access_denied,          errCLASS_Auth,      errACT_User,     0FFh
 46391 00000DEF 06070401                    DB  error_invalid_handle,         errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 46392 00000DF3 07070505                    DB  error_arena_trashed,          errCLASS_Apperr,    errACT_Panic,    errLOC_Mem
 46393 00000DF7 08010405                    DB  error_not_enough_memory,      errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 46394 00000DFB 09070405                    DB  error_invalid_block,          errCLASS_Apperr,    errACT_Abort,    errLOC_Mem
 46395 00000DFF 0A070405                    DB  error_bad_environment,        errCLASS_Apperr,    errACT_Abort,    errLOC_Mem
 46396 00000E03 0B090301                    DB  error_bad_format,             errCLASS_BadFmt,    errACT_User,     errLOC_Unk
 46397 00000E07 0C070401                    DB  error_invalid_access,         errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 46398 00000E0B 0D090401                    DB  error_invalid_data,           errCLASS_BadFmt,    errACT_Abort,    errLOC_Unk
 46399 00000E0F 0F080302                    DB  error_invalid_drive,          errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 46400 00000E13 10030302                    DB  error_current_directory,      errCLASS_Auth,      errACT_User,     errLOC_Disk
 46401 00000E17 110D0302                    DB  error_not_same_device,        errCLASS_Unk,       errACT_User,     errLOC_Disk
 46402 00000E1B 12080302                    DB  error_no_more_files,          errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 46403 00000E1F 500C0302                    DB  error_file_exists,            errCLASS_Already,   errACT_User,     errLOC_Disk
 46404 00000E23 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 46405 00000E27 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 46406 00000E2B 540104FF                    DB  error_out_of_structures,      errCLASS_OutRes,    errACT_Abort,    0FFh
 46407 00000E2F 56030301                    DB  error_invalid_password,       errCLASS_Auth,      errACT_User,     errLOC_Unk
 46408 00000E33 52010402                    DB  error_cannot_make,            errCLASS_OutRes,    errACT_Abort,    errLOC_Disk
 46409 00000E37 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,     errLOC_Net
 46410 00000E3B 550C0303                    DB  error_already_assigned,       errCLASS_Already,   errACT_User,     errLOC_Net
 46411 00000E3F 57090301                    DB  error_invalid_parameter,      errCLASS_BadFmt,    errACT_User,     errLOC_Unk
 46412 00000E43 530D0401                    DB  error_FAIL_I24,               errCLASS_Unk,       errACT_Abort,    errLOC_Unk
 46413 00000E47 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 46414                                      ; MSDOS 6.0
 46415 00000E4B 26010401                    DB  error_handle_EOF,             errCLASS_OutRes,    errACT_Abort,    errLOC_Unk ;AN000;
 46416 00000E4F 27010401                    DB  error_handle_Disk_Full,       errCLASS_OutRes,    errACT_Abort,    errLOC_Unk ;AN000;
 46417 00000E53 5A0D0402                    DB  error_sys_comp_not_loaded,    errCLASS_Unk,       errACT_Abort,    errLOC_Disk ;AN001;
 46418 00000E57 FFFFFFFF                    DB  0FFh,                         0FFH,       	  0FFH,       	   0FFh
 46419                                  
 46420                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D2Ah
 46421                                  ;ERR_TABLE_21:	db 1,7,4,0FFh
 46422                                  ;		db 2,8,3,2
 46423                                  ;		db 3,8,3,2
 46424                                  ;		db 4,1,4,1
 46425                                  ;		db 5,3,3,0FFh
 46426                                  ;		db 6,7,4,1
 46427                                  ;		db 7,7,5,5
 46428                                  ;		db 8,1,4,5
 46429                                  ;		db 9,7,4,5
 46430                                  ;		db 0Ah,7,4,5
 46431                                  ;		db 0Bh,9,3,1
 46432                                  ;		db 0Ch,7,4,1
 46433                                  ;		db 0Dh,9,4,1
 46434                                  ;		db 0Fh,8,3,2
 46435                                  ;		db 10h,3,3,2
 46436                                  ;		db 11h,0Dh,3,2
 46437                                  ;		db 12h,8,3,2
 46438                                  ;		db 50h,0Ch,3,2
 46439                                  ;		db 20h,0Ah,2,2
 46440                                  ;		db 21h,0Ah,2,2
 46441                                  ;		db 54h,1,4,0FFh
 46442                                  ;		db 56h,3,3,1
 46443                                  ;		db 52h,1,4,2
 46444                                  ;		db 32h,9,3,3
 46445                                  ;		db 55h,0Ch,3,3
 46446                                  ;		db 57h,9,3,1
 46447                                  ;		db 53h,0Dh,4,1
 46448                                  ;		db 24h,1,4,5
 46449                                  ; MSDOS 6.0 (MSDOS 6.21)
 46450                                  ;		db 26h,1,4,1
 46451                                  ;		db 27h,1,4,1
 46452                                  ;		db 5Ah,0Dh,4,2
 46453                                  ; MSDOS 6.0 & MSDOS 3.3
 46454                                  ;		db 0FFh,0FFh,0FFh,0FFh
 46455                                  
 46456                                  ; DOSDATA:0E5Bh (MSDOS 6.21, MSDOS.SYS)
 46457                                  
 46458                                  ; ---------------------------------------------------------------------------
 46459                                  ;
 46460                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 24H
 46461                                  ; errors. Each entry is 4 bytes long:
 46462                                  ;
 46463                                  ;       Err#,Class,Action,Locus
 46464                                  ;
 46465                                  ; A Locus value of 0FFh indicates a call specific value (ie. should already
 46466                                  ; be set). AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
 46467                                  ; THE END.
 46468                                  ;
 46469                                  ; ---------------------------------------------------------------------------
 46470                                  
 46471                                  ERR_TABLE_24: ; LABEL   BYTE
 46472 00000E5B 130B0702                    DB  error_write_protect,          errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 46473 00000E5F 14040501                    DB  error_bad_unit,               errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 46474 00000E63 150507FF                    DB  error_not_ready,              errCLASS_HrdFail,   errACT_IntRet,   0FFh
 46475 00000E67 16040501                    DB  error_bad_command,            errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 46476 00000E6B 170B0402                    DB  error_CRC,                    errCLASS_Media,     errACT_Abort,    errLOC_Disk
 46477 00000E6F 18040501                    DB  error_bad_length,             errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 46478 00000E73 19050102                    DB  error_seek,                   errCLASS_HrdFail,   errACT_Retry,    errLOC_Disk
 46479 00000E77 1A0B0702                    DB  error_not_DOS_disk,           errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 46480 00000E7B 1B0B0402                    DB  error_sector_not_found,       errCLASS_Media,     errACT_Abort,    errLOC_Disk
 46481 00000E7F 1C020704                    DB  error_out_of_paper,           errCLASS_TempSit,   errACT_IntRet,   errLOC_SerDev
 46482 00000E83 1D0504FF                    DB  error_write_fault,            errCLASS_HrdFail,   errACT_Abort,    0FFh
 46483 00000E87 1E0504FF                    DB  error_read_fault,             errCLASS_HrdFail,   errACT_Abort,    0FFh
 46484 00000E8B 1F0D04FF                    DB  error_gen_failure,            errCLASS_Unk,       errACT_Abort,    0FFh
 46485 00000E8F 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 46486 00000E93 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 46487 00000E97 220B0702                    DB  error_wrong_disk,             errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 46488 00000E9B 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,     errLOC_Net
 46489 00000E9F 23070401                    DB  error_FCB_unavailable,        errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 46490 00000EA3 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 46491 00000EA7 FF0D05FF                    DB	0FFh,                         errCLASS_Unk,       errACT_Panic,    0FFh
 46492                                  
 46493                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D9Eh
 46494                                  ;ERR_TABLE_24:	db 13h,0Bh,7,2
 46495                                  ;		db 14h,4,5,1
 46496                                  ;		db 15h,5,7,0FFh
 46497                                  ;		db 16h,4,5,1
 46498                                  ;		db 17h,0Bh,4,2
 46499                                  ;		db 18h,4,5,1
 46500                                  ;		db 19h,5,1,2
 46501                                  ;		db 1Ah,0Bh,7,2
 46502                                  ;		db 1Bh,0Bh,4,2
 46503                                  ;		db 1Ch,2,7,4
 46504                                  ;		db 1Dh,5,4,0FFh
 46505                                  ;		db 1Eh,5,4,0FFh
 46506                                  ;		db 1Fh,0Dh,4,0FFh
 46507                                  ;		db 20h,0Ah,2,2
 46508                                  ;		db 21h,0Ah,2,2
 46509                                  ;		db 22h,0Bh,7,2
 46510                                  ;		db 32h,9,3,3
 46511                                  ;		db 23h,7,4,1
 46512                                  ;		db 24h,1,4,5
 46513                                  ;		db 0FFh,0Dh,5,0FFh
 46514                                  
 46515                                  ; DOSDATA:0EABh (MSDOS 6.21, MSDOS.SYS)
 46516                                  
 46517                                  ; ---------------------------------------------------------------------------
 46518                                  ;
 46519                                  ; We need to map old int 24 errors and device driver errors into the new set
 46520                                  ; of errors. The following table is indexed by the new errors
 46521                                  ;
 46522                                  ; ---------------------------------------------------------------------------
 46523                                  
 46524                                  ;Public  ErrMap24
 46525                                  ErrMap24: ; Label   BYTE
 46526 00000EAB 13                          DB  error_write_protect	; 0
 46527 00000EAC 14                          DB  error_bad_unit		; 1
 46528 00000EAD 15                          DB  error_not_ready		; 2
 46529 00000EAE 16                          DB  error_bad_command	; 3
 46530 00000EAF 17                          DB  error_CRC		; 4
 46531 00000EB0 18                          DB  error_bad_length	; 5
 46532 00000EB1 19                          DB  error_seek		; 6
 46533 00000EB2 1A                          DB  error_not_DOS_disk	; 7
 46534 00000EB3 1B                          DB  error_sector_not_found	; 8
 46535 00000EB4 1C                          DB  error_out_of_paper	; 9
 46536 00000EB5 1D                          DB  error_write_fault	; A
 46537 00000EB6 1E                          DB  error_read_fault	; B
 46538 00000EB7 1F                          DB  error_gen_failure	; C
 46539 00000EB8 1F                          DB  error_gen_failure	; D  RESERVED
 46540 00000EB9 1F                          DB  error_gen_failure	; E  RESERVED
 46541 00000EBA 22                          DB  error_wrong_disk	; F
 46542                                  
 46543                                  ;ErrMap24: db 13h, 14h, 15h, 16h, 17h, 18h, 19h, 1Ah
 46544                                  ;	   db 1Bh, 1Ch, 1Dh, 1Eh, 1Fh, 1Fh, 1Fh, 22h
 46545                                  	
 46546                                  ErrMap24End: ; LABEL   BYTE
 46547                                  
 46548                                  ; DOSDATA:0EBBh (MSDOS 6.21, MSDOS.SYS)
 46549                                  
 46550                                  ; ---------------------------------------------------------------------------
 46551                                  
 46552                                  ; 27/04/2019 - Retro DOS v4.0
 46553                                  
 46554                                  FIRST_BUFF_ADDR:
 46555 00000EBB 0000                    	dw	0			; first buffer address
 46556                                  SPECIAL_VERSION:
 46557 00000EBD 0000                    	dw	0			;AN006; used by INT 2F 47H
 46558                                  FAKE_COUNT:
 46559 00000EBF 00<rep FFh>             	times 255 db 0			;AN008; fake version count
 46560                                  OLD_FIRSTCLUS:
 46561 00000FBE 0000                    	dw	0			;AN011; save old first cluster for fastopen
 46562                                  
 46563                                  ; ---------------------------------------------------------------------------
 46564                                  
 46565                                  ;smr; moved from TABLE segment in exec.asm
 46566                                  
 46567 00000FC0 0000                    exec_init_SP: dw 0
 46568 00000FC2 0000                    exec_init_SS: dw 0
 46569 00000FC4 0000                    exec_init_IP: dw 0
 46570 00000FC6 0000                    exec_init_CS: dw 0
 46571                                  
 46572                                  exec_signature:
 46573 00000FC8 0000                    	dw	0	; must contain 4D5A (yay zibo!)
 46574                                  exec_len_mod_512:
 46575 00000FCA 0000                    	dw	0	; low 9 bits of length
 46576                                  exec_pages:
 46577 00000FCC 0000                    	dw	0	; number of 512b pages in file
 46578                                  exec_rle_count:
 46579 00000FCE 0000                    	dw	0	; count of reloc entries
 46580                                  exec_par_dir:
 46581 00000FD0 0000                    	dw	0	; number of paragraphs before image
 46582                                  exec_min_BSS:
 46583 00000FD2 0000                    	dw	0	; minimum number of para of BSS
 46584                                  exec_max_BSS:
 46585 00000FD4 0000                    	dw	0	; max number of para of BSS
 46586                                  exec_SS:
 46587 00000FD6 0000                    	dw	0	; stack of image
 46588                                  exec_SP:
 46589 00000FD8 0000                    	dw	0	; SP of image
 46590                                  exec_chksum:
 46591 00000FDA 0000                    	dw	0	; checksum of file (ignored)
 46592                                  exec_IP:
 46593 00000FDC 0000                    	dw	0	; IP of entry
 46594                                  exec_CS:
 46595 00000FDE 0000                    	dw	0	; CS of entry
 46596                                  exec_rle_table:
 46597 00000FE0 0000                    	dw	0	; byte offset of reloc table
 46598                                  
 46599                                  exec_header_len	equ $-exec_signature			;PBUGBUG
 46600                                  
 46601                                  ;smr; eom
 46602                                  
 46603                                  ; ---------------------------------------------------------------------------
 46604                                  
 46605                                  ;SR;
 46606                                  ; WIN386 instance table for DOS
 46607                                  
 46608                                  Win386_Info:
 46609 00000FE2 0300                    	db	3, 0
 46610 00000FE4 000000000000000000-     	dd	0, 0, 0
 46610 00000FED 000000             
 46611 00000FF0 [F40F]0000              	dw	Instance_Table, 0
 46612                                  
 46613                                  Instance_Table:
 46614 00000FF4 [2200]00000200          	dw	CONTPOS, 0, 2
 46615 00000FFA [3200]00000400          	dw	BCON, 0, 4
 46616 00001000 [F901]00000601          	dw	CARPOS, 0, 106h
 46617 00001006 [0003]00000100          	dw	CHARCO, 0, 1
 46618 0000100C [C00F]00002200          	dw	exec_init_SP, 0, 34	; M074
 46619 00001012 [8900]00000100          	dw	UMBFLAG,0,1		; M019
 46620 00001018 [8C00]00000200          	dw	UMB_HEAD,0,2		; M019
 46621 0000101E 00000000                	dw	0, 0
 46622                                  
 46623                                  ; M001; SR;
 46624                                  ; M001; On DOSMGR call ( cx == 0 ), we need to return a table of offsets of
 46625                                  ; M001; some DOS variables. Note that the only really important variable in
 46626                                  ; M001; this is User_Id. The other variables are needed only to patch stuff
 46627                                  ; M001; which does not need to be done in DOS 5.0. 
 46628                                  
 46629                                  ; 29/12/2022
 46630                                  ; (MSDOS 6.21 MSDOS.SYS DOSDATA:1022h)
 46631                                  
 46632                                  Win386_DOSVars:
 46633 00001022 05                      	db	5	;Major version 5 ; M001
 46634 00001023 00                      	db	0	;Minor version 0 ; M001
 46635 00001024 [EC05]                  	dw	SAVEDS	; M001
 46636 00001026 [EA05]                  	dw	SAVEBX	; M001
 46637 00001028 [2103]                  	dw	INDOS	; M001
 46638 0000102A [3E03]                  	dw	USER_ID	; M001
 46639 0000102C [1503]                  	dw	CritPatch ; M001
 46640 0000102E [8C00]                  	dw	UMB_HEAD ; M012
 46641                                  
 46642                                  ;SR;
 46643                                  ; Flag to indicate whether WIN386 is running or not
 46644                                  
 46645 00001030 00                      IsWin386: db	0
 46646                                  
 46647                                  ;M018
 46648                                  ; This variable contains the path to the VxD device needed for Win386
 46649                                  
 46650 00001031 633A5C77696E613230-     VxDpath:  db	'c:\wina20.386',0	;M018
 46650 0000103A 2E33383600         
 46651                                  
 46652                                  ;End WIN386 support
 46653                                  
 46654                                  ; ---------------------------------------------------------------------------
 46655                                  
 46656                                  ;SR;
 46657                                  ; These variables have been added for the special lie support for device
 46658                                  ;drivers.
 46659                                  ;
 46660                                  
 46661                                  DriverLoad:	
 46662 0000103F 01                      	db	1	;initialized to do special handling
 46663                                  BiosDataPtr:
 46664 00001040 00000000                	dd	0
 46665                                  
 46666                                  ; 25/03/2024
 46667                                  %if 1
 46668                                  ; 29/12/2022 - Retro DOS v4.1
 46669                                  ;%if 0
 46670                                  
 46671                                  ; 27/04/2019 - Retro DOS v4.0
 46672                                  ; 04/11/2022
 46673                                  ; DOSDATA:1044h (MSDOS 6.21 & MSDOS 5.0, MSDOS.SYS)
 46674                                  
 46675                                  ;------------------------------------------------------------------------
 46676                                  ; Patch for Sidekick
 46677                                  ;
 46678                                  ; A documented method for finding the offset of the Errormode flag in the
 46679                                  ; dos swappable data area if for the app to scan in the dos segment (data)
 46680                                  ; for the following sequence of instructions.
 46681                                  ;
 46682                                  ; Ref: Part C, Article 11, pg 356 of MSDOS Encyclopedia
 46683                                  ;
 46684                                  ; The Offset of Errormode flag is 0320h
 46685                                  ;
 46686                                  ;------------------------------------------------------------------------
 46687                                  
 46688 00001044 36F6062003FF            	db	036h, 0F6h, 06h, 020h, 03h, 0FFh ; test ss:[errormode], -1
 46689 0000104A 750C                    	db	075h, 0Ch			 ; jnz  NearLabel
 46690 0000104C 36FF365803              	db	036h, 0FFh, 036h, 058h, 03h	 ; push ss:[NearWord]
 46691 00001051 CD28                    	db	0CDh, 028h			 ; int  28h
 46692                                  
 46693                                  ;--------------------------------------------------------------------------
 46694                                  ; Patch for PortOfEntry - M036
 46695                                  ;
 46696                                  ; PortOfEntry by Sector Technology uses an un documented way of determining
 46697                                  ; the offset of Errormode flag. The following patch is to support them in 
 46698                                  ; DOS 5.0. The corresponding code is actually in msdisp.asm
 46699                                  ;
 46700                                  ;---------------------------------------------------------------------------
 46701                                  
 46702 00001053 803E200300              	db 	080h, 03Eh, 020h, 03h, 00h 	 ; cmp 	[errormode], 0
 46703 00001058 7537                    	db	075h, 037h			 ; jnz	NearLabel
 46704 0000105A BCA00A                  	db 	0BCh, 0A0h, 0Ah		  	 ; mov	sp, dosdata:iostack
 46705                                  
 46706                                  %endif ; 29/12/2022
 46707                                  
 46708                                  ; DOSDATA:105Dh (MSDOS 6.21, MSDOS.SYS)
 46709                                  
 46710                                  ;--------------------------------------------------------------------------
 46711                                  
 46712                                  ;*** New FCB Implementation
 46713                                  ; This variable is used as a cache in the new FCB implementation to remember
 46714                                  ;the address of a local SFT that can be recycled for a regenerate operation
 46715                                  
 46716 0000105D 00000000                LocalSFT: dd	0		; 0 to indicate invalid pointer
 46717                                  
 46718                                  ;DOSDATA ENDS
 46719                                  
 46720                                  ;============================================================================
 46721                                  ; LMSTUB.ASM (MSDOS 6.0, 1991)
 46722                                  ;============================================================================
 46723                                  ; 27/04/2019 - Retro DOS 4.0
 46724                                  
 46725                                  ;DOSDATA  SEGMENT WORD PUBLIC 'DATA'
 46726                                  
 46727                                  ;---------------------------------------------------------------------------
 46728                                  ;	Low Memory Stub for DOS when DOS runs in HMA
 46729                                  ;----------------------------------------------------------------------------
 46730                                  	
 46731                                  	;db	90h
 46732                                  
 46733                                  	;EVEN
 46734 00001061 90                      align 2
 46735                                  
 46736                                  ; DOSDATA:1062h (MSDOS 6.21, MSDOS.SYS)
 46737                                  
 46738                                  DOSINTTABLE:	; LABEL	DWORD
 46739                                  
 46740                                  	;DW	OFFSET DOSCODE:DIVOV 		, 0
 46741                                  	;DW	OFFSET DOSCODE:QUIT 		, 0
 46742                                  	;DW	OFFSET DOSCODE:COMMAND		, 0
 46743                                  	;DW	OFFSET DOSCODE:ABSDRD		, 0
 46744                                  	;DW	OFFSET DOSCODE:ABSDWRT		, 0
 46745                                  	;DW	OFFSET DOSCODE:Stay_resident	, 0
 46746                                  	;DW	OFFSET DOSCODE:INT2F		, 0
 46747                                  	;DW	OFFSET DOSCODE:CALL_ENTRY	, 0
 46748                                  	;DW	OFFSET DOSCODE:IRETT		, 0
 46749                                  	
 46750 00001062 [F850]0000              	dw	DIVOV 		, 0  ; DOSINTTABLE+0
 46751 00001066 [DC02]0000              	dw	QUIT 		, 0  ; DOSINTTABLE+4
 46752 0000106A [0803]0000              	dw	COMMAND		, 0  ; DOSINTTABLE+8
 46753 0000106E [2D05]0000              	dw	ABSDRD		, 0  ; DOSINTTABLE+12
 46754 00001072 [B405]0000              	dw	ABSDWRT		, 0  ; DOSINTTABLE+16
 46755 00001076 [2460]0000              	dw	STAY_RESIDENT	, 0  ; DOSINTTABLE+20
 46756 0000107A [FD06]0000              	dw	INT2F		, 0  ; DOSINTTABLE+24
 46757 0000107E [E302]0000              	dw	CALL_ENTRY	, 0  ; DOSINTTABLE+28
 46758 00001082 [E202]0000              	dw	IRETT		, 0  ; DOSINTTABLE+32
 46759                                  
 46760 00001086 0000                    SS_Save: dw	0		; save user's stack segment
 46761 00001088 0000                    SP_Save: dw	0		; save user's stack offset
 46762                                  
 46763                                  ;-------------------------------------------------------------------------
 46764                                  ;
 46765                                  ; LOW MEM STUB:
 46766                                  ;
 46767                                  ; The low mem stub contains the entry points into DOS for all interrupts
 46768                                  ; handled by DOS. This stub is installed if the user specifies that the
 46769                                  ; DOS load in HIMEM. Each entry point does this.
 46770                                  ;
 46771                                  ; 	1. if jmp to 8 has been patched out
 46772                                  ;	   2. if A20 OFF
 46773                                  ;	      3. Enable A20
 46774                                  ;	   4. else 
 46775                                  ;	      5. just go to dos entry
 46776                                  ;	   6. endif
 46777                                  ;	7. else
 46778                                  ;	   8. just go to dos entry
 46779                                  ;	9. endif
 46780                                  ;
 46781                                  ;--------------------------------------------------------------------------
 46782                                  
 46783                                  ; 27/04/2019 - Retro DOS v4.0
 46784                                  
 46785                                  ; DOSDATA:108Ah (MSDOS 6.21, MSDOS.SYS)
 46786                                  
 46787                                  ;--------------------------------------------------------------------------
 46788                                  ;
 46789                                  ; DIVIDE BY 0 handler
 46790                                  ;
 46791                                  ;--------------------------------------------------------------------------
 46792                                  
 46793                                  ldivov:
 46794                                  	; The following jump, skipping the XMS calls will be patched to
 46795                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 46796                                  	; needed because the stub is installed even before the XMS driver
 46797                                  	; is loaded if the user specifies dos=high in the config.sys
 46798                                  i0patch:
 46799 0000108A EB03                    	jmp	short divov_cont
 46800                                  
 46801 0000108C E8E000                  	call	EnsureA20ON		; we must turn on A20 if OFF
 46802                                  divov_cont:
 46803 0000108F 2EFF2E[6210]            	jmp	far [cs:DOSINTTABLE]	; jmp to DOS
 46804                                  
 46805                                  ;------------------------------------------------------------------------
 46806                                  ;
 46807                                  ; INT 20 Handler
 46808                                  ;
 46809                                  ; Here we do not have to set up the stack to return here as the abort call
 46810                                  ; will return to the address after the int 21 ah=4b call. This would be the
 46811                                  ; common exit point if A20 had been OFF (for TOGGLE DOS) and the A20 line
 46812                                  ; will be restored then.
 46813                                  ;
 46814                                  ;-------------------------------------------------------------------------
 46815                                  
 46816                                  lquit:
 46817                                  	; The following jump, skipping the XMS calls will be patched to
 46818                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 46819                                  	; needed because the stub is installed even before the XMS driver
 46820                                  	; is loaded if the user specifies dos=high in the config.sys
 46821                                  i20patch:
 46822 00001094 EB03                    	jmp	short quit_cont
 46823                                  
 46824 00001096 E8D600                  	call	EnsureA20ON		; we must turn on A20 if OFF
 46825                                  quit_cont:
 46826 00001099 2EFF2E[6610]            	jmp	far [cs:DOSINTTABLE+4]	; jump to DOS
 46827                                  
 46828                                  ;--------------------------------------------------------------------------
 46829                                  ;
 46830                                  ; INT 21 Handler
 46831                                  ;
 46832                                  ;--------------------------------------------------------------------------
 46833                                  
 46834                                  lcommand:
 46835                                  	; The following jump, skipping the XMS calls will be patched to
 46836                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 46837                                  	; needed because the stub is installed even before the XMS driver
 46838                                  	; is loaded if the user specifies dos=high in the config.sys
 46839                                  i21patch:
 46840 0000109E EB03                    	jmp	short command_cont
 46841                                  
 46842 000010A0 E8CC00                  	call	EnsureA20ON		; we must turn on A20 if OFF
 46843                                  command_cont:
 46844 000010A3 2EFF2E[6A10]            	jmp	far [cs:DOSINTTABLE+8]	; jmp to DOS
 46845                                  
 46846                                  ;------------------------------------------------------------------------
 46847                                  ;
 46848                                  ; INT 25 
 46849                                  ;
 46850                                  ;----------------------------------------------------------------------------
 46851                                  
 46852                                  labsdrd:
 46853                                  	; The following jump, skipping the XMS calls will be patched to
 46854                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 46855                                  	; needed because the stub is installed even before the XMS driver
 46856                                  	; is loaded if the user specifies dos=high in the config.sys
 46857                                  i25patch:
 46858 000010A8 EB03                    	jmp	short absdrd_cont
 46859                                  
 46860 000010AA E8C200                  	call	EnsureA20ON		; we must turn on A20 if OFF
 46861                                  absdrd_cont:
 46862 000010AD 2EFF2E[6E10]            	jmp	far [cs:DOSINTTABLE+12]	; jmp to DOS
 46863                                  
 46864                                  ;-------------------------------------------------------------------------
 46865                                  ;
 46866                                  ; INT 26
 46867                                  ;
 46868                                  ;-----------------------------------------------------------------------
 46869                                  
 46870                                  labsdwrt:
 46871                                  	; The following jump, skipping the XMS calls will be patched to
 46872                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 46873                                  	; needed because the stub is installed even before the XMS driver
 46874                                  	; is loaded if the user specifies dos=high in the config.sys
 46875                                  i26patch:
 46876 000010B2 EB03                    	jmp	short absdwrt_cont
 46877                                  
 46878 000010B4 E8B800                  	call	EnsureA20ON		; we must turn on A20 if OFF
 46879                                  absdwrt_cont:
 46880 000010B7 2EFF2E[7210]            	jmp	far [cs:DOSINTTABLE+16]	; jmp to DOS
 46881                                  
 46882                                  ;------------------------------------------------------------------------
 46883                                  ;
 46884                                  ; INT 27
 46885                                  ;
 46886                                  ;-----------------------------------------------------------------------
 46887                                  
 46888                                  lstay_resident:
 46889                                  	; The following jump, skipping the XMS calls will be patched to
 46890                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 46891                                  	; needed because the stub is installed even before the XMS driver
 46892                                  	; is loaded if the user specifies dos=high in the config.sys
 46893                                  i27patch:
 46894 000010BC EB03                    	jmp	short sr_cont
 46895                                  
 46896 000010BE E8AE00                  	call	EnsureA20ON		; we must turn on A20 if OFF
 46897                                  sr_cont:
 46898 000010C1 2EFF2E[7610]            	jmp	far [cs:DOSINTTABLE+20]	; jmp to DOS
 46899                                  
 46900                                  ;-----------------------------------------------------------------------------
 46901                                  ;
 46902                                  ; INT 2f
 46903                                  ;
 46904                                  ;-------------------------------------------------------------------------
 46905                                  
 46906                                  lint2f:
 46907                                  	; The following jump, skipping the XMS calls will be patched to
 46908                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 46909                                  	; needed because the stub is installed even before the XMS driver
 46910                                  	; is loaded if the user specifies dos=high in the config.sys
 46911                                  i2fpatch:
 46912 000010C6 EB03                    	jmp	short int2f_cont
 46913                                  
 46914 000010C8 E8A400                  	call	EnsureA20ON		; we must turn on A20 if OFF
 46915                                  int2f_cont:
 46916 000010CB 2EFF2E[7A10]            	jmp	far [cs:DOSINTTABLE+24]	; jmp to DOS
 46917                                  
 46918                                  ;-----------------------------------------------------------------------------
 46919                                  ;
 46920                                  ; CPM entry
 46921                                  ;
 46922                                  ;------------------------------------------------------------------------
 46923                                  
 46924                                  lcall_entry:
 46925                                  	; The following jump, skipping the XMS calls will be patched to
 46926                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 46927                                  	; needed because the stub is installed even before the XMS driver
 46928                                  	; is loaded if the user specifies dos=high in the config.sys
 46929                                  cpmpatch:
 46930 000010D0 EB03                    	jmp	short callentry_cont
 46931                                  
 46932 000010D2 E89A00                  	call	EnsureA20ON		; we must turn on A20 if OFF
 46933                                  callentry_cont:
 46934 000010D5 2EFF2E[7E10]            	jmp	far [cs:DOSINTTABLE+28]	; jmp to DOS
 46935                                  
 46936                                  ;--------------------------------------------------------------------------
 46937                                  
 46938                                  lirett:
 46939 000010DA CF                      	iret
 46940                                  
 46941                                  ;---------------------------------------------------------------------------
 46942                                  ;
 46943                                  ; LowIntXX:
 46944                                  ;
 46945                                  ; Interrupts from DOS that pass control to a user program must be done from
 46946                                  ; low memory, as the user program may change the state of the A20 line or
 46947                                  ; they may require that the A20 line be OFF. The following piece of code is
 46948                                  ; far call'd from the following places in DOS:
 46949                                  ;
 46950                                  ;	1. msctrlc.asm where dos issues an int 23h (ctrlc)
 46951                                  ;	2. msctrlc.asm where dos issues an int 24h (critical error)
 46952                                  ;	3. msctrlc.asm where dos issues an int 28h (idle int)
 46953                                  ;
 46954                                  ; The int 23 and int 24 handlers may decide to do a far return instead of an
 46955                                  ; IRET ane leave the flags on the stack. Therefore we save the return address
 46956                                  ; before doing the ints and then do a far junp back into DOS.
 46957                                  ;
 46958                                  ;---------------------------------------------------------------------------
 46959                                  
 46960 000010DB 00000000                DosRetAddr23:	dd	0
 46961 000010DF 00000000                DosRetAddr24:	dd	0
 46962 000010E3 00000000                DosRetAddr28:	dd	0
 46963                                  
 46964                                  	; Execute int 23h from low memory
 46965                                  LowInt23:
 46966                                  					; save the return address that is on
 46967                                  					; the stack
 46968 000010E7 2E8F06[DB10]            	pop	word [cs:DosRetAddr23]
 46969 000010EC 2E8F06[DD10]            	pop	word [cs:DosRetAddr23+2]
 46970                                  
 46971 000010F1 CD23                    	int	23h			; ctrl C
 46972                                  					; turn on A20 it has been turned OFF
 46973                                  					; by int 28/23/24 handler.
 46974                                  
 46975 000010F3 E87900                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF
 46976                                  
 46977 000010F6 2EFF2E[DB10]            	jmp	far [cs:DosRetAddr23]	; jump back to DOS
 46978                                  
 46979                                  
 46980                                  	; Execute int 24h from low memory
 46981                                  LowInt24:
 46982                                  					; save the return address that is on
 46983                                  					; the stack
 46984 000010FB 2E8F06[DF10]            	pop	word [cs:DosRetAddr24]
 46985 00001100 2E8F06[E110]            	pop	word [cs:DosRetAddr24+2]
 46986                                  
 46987 00001105 CD24                    	int	24h			; crit error
 46988                                  					; turn on A20 it has been turned OFF
 46989                                  					; by int 28/23/24 handler.
 46990                                  
 46991 00001107 E86500                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF
 46992                                  
 46993 0000110A 2EFF2E[DF10]            	jmp	far [cs:DosRetAddr24]	; jump back to DOS
 46994                                  
 46995                                  
 46996                                   
 46997                                  	; Execute int 28h from low memory
 46998                                  LowInt28:
 46999 0000110F CD28                    	int	28h			; idle int
 47000                                  					; turn on A20 it has been turned OFF
 47001                                  					; by int 28/23/24 handler.
 47002                                  
 47003 00001111 E85B00                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF
 47004                                  
 47005 00001114 CB                      	retf
 47006                                  
 47007                                  ; DOSDATA:1115h (MSDOS 6.21, MSDOS.SYS)
 47008                                  
 47009                                  ;-------------------------------------------------------------------------
 47010                                  ;
 47011                                  ; int 21 ah=4b (exec) call will jump to the following label before xferring
 47012                                  ; control to the exec'd program. We turn off A20 inorder to allow programs
 47013                                  ; that have been packed by the faulty exepack utility to unpack correctly.
 47014                                  ; This is so because exepac'd programs rely on address wrap.
 47015                                  ;
 47016                                  ;-------------------------------------------------------------------------
 47017                                  
 47018                                  disa20_xfer:
 47019 00001115 E83F00                  	call	XMMDisableA20		; disable A20
 47020                                  
 47021                                  	; Look at msproc.asm at label exec_go for understanding the following:
 47022                                  
 47023                                  	; DS:SI points to entry point
 47024                                  	; AX:DI points to initial stack
 47025                                  	; DX has PDB pointer
 47026                                  	; BX has initial AX value
 47027                                  
 47028 00001118 FA                      	cli
 47029 00001119 2EC606[2103]00          	mov	byte [cs:INDOS],0	; SS Override
 47030                                  
 47031 0000111F 8ED0                    	mov	SS,AX			; set up user's stack
 47032 00001121 89FC                    	mov	SP,DI			; and SP
 47033 00001123 FB                      	sti
 47034                                  
 47035 00001124 1E                      	push	DS			; fake long call to entry
 47036 00001125 56                      	push	SI
 47037 00001126 8EC2                    	mov	ES,DX			; set up proper seg registers
 47038 00001128 8EDA                    	mov	DS,DX
 47039 0000112A 89D8                    	mov	AX,BX			; set up proper AX
 47040 0000112C CB                      	retf
 47041                                  
 47042                                  ;-------------------------------------------------------------------------
 47043                                  ;
 47044                                  ; M003:
 47045                                  ;
 47046                                  ; If an int 21 ah=25 call is made immediately after an exec call, DOS will
 47047                                  ; come here, turn A20 OFF restore user stack and registers before returning
 47048                                  ; to user. This is done in dos\msdisp.asm. This has been done to support
 47049                                  ; programs compiled with MS PASCAL 3.2. See under TAG M003 in DOSSYM.INC for
 47050                                  ; more info.
 47051                                  ;
 47052                                  ; Also at this point DS is DOSDATA. So we can assume DS DOSDATA. Note that
 47053                                  ; SS is also DOS stack. It is important that we do the XMS call on DOS's
 47054                                  ; stack to avoid additional stack overhead for the user.
 47055                                  ;
 47056                                  ; -------------------------------------------------------------------------
 47057                                  
 47058                                  disa20_iret:
 47059 0000112D E82700                  	call	XMMDisableA20
 47060 00001130 FE0E[2103]              	dec	byte [INDOS]
 47061 00001134 8E16[8605]              	mov	SS,[USER_SS]		; restore user stack
 47062 00001138 8B26[8405]              	mov	SP,[USER_SP]
 47063 0000113C 89E5                    	mov	BP,SP
 47064                                  	;mov	[BP+user_env.user_AX],AL
 47065 0000113E 884600                  	mov	[bp],al
 47066 00001141 A1[F205]                	mov	AX,[NSP]
 47067 00001144 A3[8405]                	mov	[USER_SP],AX
 47068 00001147 A1[F005]                	mov	AX,[NSS]
 47069 0000114A A3[8605]                	mov	[USER_SS],AX
 47070                                  
 47071 0000114D 58                      	pop	AX			; restore user regs
 47072 0000114E 5B                      	pop	BX
 47073 0000114F 59                      	pop	CX
 47074 00001150 5A                      	pop	DX
 47075 00001151 5E                      	pop	SI
 47076 00001152 5F                      	pop	DI
 47077 00001153 5D                      	pop	BP
 47078 00001154 1F                      	pop	DS
 47079 00001155 07                      	pop	ES
 47080 00001156 CF                      	iret
 47081                                  
 47082                                  ;**************************************************************************
 47083                                  ;***	XMMDisableA20 - switch 20th address line
 47084                                  ;
 47085                                  ;	This routine is used to disable the 20th address line in
 47086                                  ;	the system using XMM calls.
 47087                                  ;
 47088                                  ;	ENTRY	none		;ds = _DATA
 47089                                  ;	EXIT	A20 line disabled
 47090                                  ;	USES	NOTHING
 47091                                  ;
 47092                                  ;**************************************************************************
 47093                                  
 47094                                  XMMDisableA20:
 47095 00001157 53                      	push	bx
 47096 00001158 50                      	push	ax
 47097                                  	;mov	ah,XMM_LOCAL_DISABLE_A20
 47098 00001159 B406                    	mov	ah,6
 47099 0000115B 2EFF1E[6311]            	call	far [cs:XMMcontrol]
 47100 00001160 58                      	pop	ax
 47101 00001161 5B                      	pop	bx
 47102 00001162 C3                      	retn
 47103                                  
 47104                                  ; The entry point in the BIOS XMS driver is defined here.
 47105                                  
 47106                                  XMMcontrol:
 47107 00001163 00000000                	dd	0
 47108                                  
 47109                                  ;--------------------------------------------------------------------------
 47110                                  ;
 47111                                  ;***	EnsureA20ON - Ensures that A20 is ON
 47112                                  ;
 47113                                  ;	This routine is used to query the A20 state in
 47114                                  ;	the system using XMM calls.
 47115                                  ;
 47116                                  ;	ENTRY: none
 47117                                  ;
 47118                                  ;	EXIT : A20 will be ON
 47119                                  ;
 47120                                  ; 	USES : NONE
 47121                                  ;
 47122                                  ;--------------------------------------------------------------------------
 47123                                  
 47124                                  ; 25/03/2024
 47125                                  ;;19/09/2023
 47126                                  LowMemory:	; label dword		; Set equal to 0000:0080
 47127 00001167 8000                    	dw	00080h
 47128 00001169 0000                    	dw	00000h
 47129                                  
 47130                                  HighMemory:	; label dword
 47131 0000116B 9000                    	dw	00090h			; Set equal to FFFF:0090
 47132 0000116D FFFF                    	dw	0FFFFh
 47133                                  
 47134                                  	; 25/03/2024 - Retro DOS v5.0
 47135                                  	; MSDOS 5.0-6.22 MSDOS.SYS - DOSDATA:116Fh
 47136                                  	; (PCDOS 7.1 IBMDOS.COM - DOSDATA:1085h)
 47137                                  
 47138                                  EnsureA20ON:
 47139 0000116F 9C                      	pushf
 47140 00001170 1E                      	push    ds
 47141 00001171 06                      	push	es
 47142 00001172 51                      	push	cx
 47143 00001173 56                      	push	si
 47144 00001174 57                      	push	di
 47145                                  
 47146                                  	; 25/03/2024
 47147                                  	;;19/09/2023
 47148 00001175 2EC536[6711]            	lds	si,[cs:LowMemory]	; Compare the 4 words at 0000:0080
 47149 0000117A 2EC43E[6B11]            	les	di,[cs:HighMemory]	; with the 4 at FFFF:0090
 47150                                  
 47151                                  	; 25/03/2024
 47152                                  	;xor	di,di
 47153                                  	;mov	es,di
 47154                                  	;dec	di
 47155                                  	;mov	si,90h	; 0FFFFh:0090h	; HighMemory
 47156                                  	;mov	ds,di
 47157                                  	;mov	di,80h	; 0000h:0080h	; LowMemory
 47158                                  	
 47159 0000117F B90400                  	mov	cx,4
 47160 00001182 FC                      	cld
 47161 00001183 F3A7                    	repe    cmpsw
 47162                                  
 47163 00001185 7407                    	jz	short EA20_OFF
 47164                                  EA20_RET:
 47165 00001187 5F                      	pop	di
 47166 00001188 5E                      	pop	si
 47167 00001189 59                      	pop	cx
 47168 0000118A 07                      	pop	es
 47169 0000118B 1F                      	pop	ds
 47170 0000118C 9D                      	popf
 47171 0000118D C3                      	retn
 47172                                  
 47173                                  EA20_OFF:
 47174                                  	; We are going to do the XMS call on the DOS's AuxStack.
 47175                                  	; NOTE: ints are disabled at this point.
 47176                                  
 47177 0000118E 53                      	push	bx
 47178 0000118F 50                      	push	ax
 47179                                  
 47180 00001190 8CD0                    	mov	ax,ss			; save user's stack pointer
 47181 00001192 2EA3[8610]              	mov	[cs:SS_Save],ax
 47182 00001196 2E8926[8810]            	mov	[cs:SP_Save],sp
 47183 0000119B 8CC8                    	mov	ax,cs
 47184 0000119D 8ED0                    	mov	ss,ax
 47185 0000119F BC[A007]                	mov	sp,AUXSTACK
 47186                                  					; ss:sp -> DOSDATA:AuxStack
 47187                                  	;mov	ah,XMM_LOCAL_ENABLE_A20
 47188 000011A2 B405                    	mov	ah,5
 47189 000011A4 2EFF1E[6311]            	call	far [cs:XMMcontrol]
 47190 000011A9 09C0                    	or	ax,ax
 47191 000011AB 740F                    	jz	short XMMerror		; AX = 0 fatal error
 47192                                  
 47193 000011AD 2EA1[8610]              	mov	ax,[cs:SS_Save]		; restore user stack
 47194 000011B1 8ED0                    	mov	ss,ax
 47195 000011B3 2E8B26[8810]            	mov	sp,[cs:SP_Save]
 47196                                  
 47197 000011B8 58                      	pop	ax
 47198 000011B9 5B                      	pop	bx
 47199                                  
 47200 000011BA EBCB                    	jmp	short EA20_RET
 47201                                  
 47202                                  XMMerror:				; M006 - Start
 47203 000011BC B40F                    	mov	ah,0Fh			; get video mode
 47204 000011BE CD10                    	int	10h
 47205 000011C0 3C07                    	cmp	al,7			; Q: are we an MDA
 47206 000011C2 7406                    	je	short XMMcont		; Y: do not change mode
 47207 000011C4 30E4                    	xor	ah,ah ; 0		; set video mode
 47208 000011C6 B002                    	mov	al,02h			; 80 X 25 text
 47209 000011C8 CD10                    	int	10h
 47210                                  XMMcont:
 47211 000011CA B405                    	mov	ah,05h			; set display page
 47212 000011CC 30C0                    	xor	al,al			; page 0
 47213 000011CE CD10                    	int	10h
 47214                                  	
 47215 000011D0 BE[B812]                	mov	si,XMMERRMSG
 47216 000011D3 0E                      	push	cs
 47217 000011D4 1F                      	pop	ds
 47218 000011D5 FC                      	cld				; clear direction flag
 47219                                  XMMprnt:
 47220 000011D6 AC                      	lodsb
 47221 000011D7 3C24                    	cmp	al,'$'			; indicates end of XMMERRMSG
 47222 000011D9 7409                    	jz	short XMMStall		; function 0Eh
 47223 000011DB B40E                    	mov	ah,0Eh
 47224 000011DD BB0700                  	mov	bx,7
 47225 000011E0 CD10                    	int	10h
 47226 000011E2 EBF2                    	jmp	short XMMprnt
 47227                                  
 47228                                  XMMStall:
 47229 000011E4 FB                      	sti				; allow the user to warm boot
 47230 000011E5 EBFD                    	jmp	short XMMStall		; M006 - End
 47231                                  
 47232                                  ;---------------------------------------------------------------------------
 47233                                  
 47234                                  ; 27/04/2019 - Retro DOS v4.0
 47235                                  
 47236                                  ; retrodos4.s ; offset 0Ch in BIOS segment (0070h)
 47237                                  ALTAH	equ 0Ch
 47238                                  
 47239                                  ;This has been put in for WIN386 2.XX support. The format of the instance
 47240                                  ;table was different for this. Segments will be patched in at init time.
 47241                                  
 47242                                  ; 25/03/2024
 47243                                  ; MSDOS 5.0-6.22 MSDOS.SYS - DOSDATA:11E7h
 47244                                  ; (PCDOS 7.1 IBMDOS.COM - DOSDATA:10FCh)
 47245                                  
 47246                                  OldInstanceJunk:
 47247 000011E7 7000                    	dw	70h	;segment of BIOS
 47248 000011E9 0000                    	dw	0	;indicate stacks in SYSINIT area
 47249 000011EB 0600                    	dw	6	;5 instance items
 47250                                  
 47251                                  	;dw	0,offset dosdata:contpos, 2
 47252                                  	;dw	0,offset dosdata:bcon, 4
 47253                                  	;dw	0,offset dosdata:carpos,106h
 47254                                  	;dw	0,offset dosdata:charco, 1
 47255                                  	;dw	0,offset dosdata:exec_init_sp, 34               ;M032
 47256                                  	;dw	070h,offset BData:altah, 1	 ; altah byte in bios
 47257                                  
 47258 000011ED 0000[2200]0200          	dw	0,CONTPOS,2
 47259 000011F3 0000[3200]0400          	dw	0,BCON,4
 47260 000011F9 0000[F901]0601          	dw	0,CARPOS,106h
 47261 000011FF 0000[0003]0100          	dw	0,CHARCO,1
 47262 00001205 0000[C00F]2200          	dw	0,exec_init_SP,34
 47263 0000120B 70000C000100            	dw	70h,ALTAH,1	; altah byte in bios
 47264                                  
 47265                                  ;---------------------------------------------------------------------------
 47266                                  
 47267                                  ; M021-
 47268                                  ;
 47269                                  ; DosHasHMA - This flag is set by seg_reinit when the DOS actually
 47270                                  ; 	takes control of the HMA. When running, this word is a reliable
 47271                                  ;	indicator that the DOS is actually using HMA. You can't just use
 47272                                  ;	CS, because ROMDOS uses HMA with CS < F000.
 47273                                  
 47274                                  DosHasHMA:
 47275 00001211 00                      	db	0
 47276                                  FixExePatch:
 47277 00001212 0000                    	dw	0		; M012
 47278                                  
 47279                                  ; 25/03/2024
 47280                                  ;; 28/12/2022 - Retro DOS v4.1
 47281                                  RationalPatchPtr:
 47282 00001214 0000                    	dw	0		; M012
 47283                                  
 47284                                  ; End M021
 47285                                  
 47286                                  ;---------------------------------------------------------------------------
 47287                                  
 47288                                  ; 25/03/2024
 47289                                  %if 1
 47290                                  ;; 28/12/2022 - Retro DOS v4.1
 47291                                  ;%if 0
 47292                                  
 47293                                  ; M020 Begin
 47294                                  
 47295                                  RatBugCode:	; proc	far
 47296 00001216 51                      	push	cx
 47297 00001217 8B0E1000                	mov	cx,[10h]
 47298                                  rbc_loop:
 47299                                  	;loop	$
 47300 0000121B E2FE                    	loop	rbc_loop
 47301 0000121D 59                      	pop	cx
 47302 0000121E CB                      	retf
 47303                                  
 47304                                  ; M020 End
 47305                                  
 47306                                  %endif
 47307                                  
 47308                                  ;---------------------------------------------------------------------------
 47309                                  	
 47310                                  UmbSave1:
 47311                                  	;db	11 dup (?)	; M023
 47312 0000121F 00<rep Bh>              	times	11 db 0	
 47313                                  
 47314                                  ; DOSDATA:122Ah
 47315                                  
 47316                                  Mark3:	; label byte
 47317                                  
 47318                                  ;IF2
 47319                                  ;	IF ((OFFSET MARK3) GT (OFFSET COUNTRY_CDPG) )
 47320                                  ;		%OUT !DATA CORRUPTION!MARK3 OFFSET TOO BIG. RE-ORGANIZE DATA.
 47321                                  ;	ENDIF
 47322                                  ;ENDIF
 47323                                  
 47324                                  ;############################################################################
 47325                                  ;
 47326                                  ; ** HACK FOR DOS 4.0 REDIR **
 47327                                  ;
 47328                                  ; The dos 4.X redir requires that country_cdpg is at offset 0122ah. Any new
 47329                                  ; data variable that is to be added to DOSDATA must go in between Mark3
 47330                                  ; COUNTRY_CDPG if it can. 
 47331                                  ;
 47332                                  ; MARK3 SHOULD NOT BE > 122AH
 47333                                  ;
 47334                                  ; As of 9/6/90, this area is FULL!
 47335                                  ;
 47336                                  ;############################################################################
 47337                                   
 47338                                  	;ORG	0122Ah
 47339                                  
 47340                                  ; DOSDATA:122Ah (MSDOS 6.21, MSDOS.SYS)
 47341                                  
 47342                                  ; The following table is used for DOS 3.3
 47343                                  ;DOS country and code page information is defined here for DOS 3.3.
 47344                                  ;The initial value for ccDosCountry is 1 (USA).
 47345                                  ;The initial value for ccDosCodepage is 850.
 47346                                  
 47347                                  ; country and code page information
 47348                                  ; ---------------------------------------------------------------------------
 47349                                  COUNTRY_CDPG:	; label  byte
 47350 0000122A 0000000000000000        	db   0,0,0,0,0,0,0,0		; reserved words
 47351 00001232 5C434F554E5452592E-     	db   '\COUNTRY.SYS',0		; path name of country.sys
 47351 0000123B 53595300           
 47352                                  	;db   51 dup (?)
 47353 0000123F 00<rep 33h>             	times 51 db 0
 47354                                  ; ------------------------------------------------<MSKK01>-------------------
 47355                                  ;ifdef	DBCS
 47356                                  ;  ifdef JAPAN
 47357                                  ;	dw   932			; system code page id (JAPAN)
 47358                                  ;  endif
 47359                                  ;  ifdef TAIWAN
 47360                                  ;	dw   938			; system code page id (TAIWAN)
 47361                                  ;  endif
 47362                                  ;  ifdef KOREA
 47363                                  ;	dw   934			; system code page id (KOREA IBM)
 47364                                  ;  endif
 47365                                  ;else
 47366 00001272 B501                    	dw   437			; system code page id
 47367                                  ;endif
 47368                                  ; ------------------------------------------------<MSKK01>-------------------
 47369 00001274 0600                    	dw   6				; number of entries
 47370 00001276 02                      	db   SetUcase  ; 2		; Ucase type
 47371 00001277 [AD0A]                  	dw   UCASE_TAB			;pointer to upper case table
 47372 00001279 0000                    	dw   0				; segment of poiter
 47373 0000127B 04                      	db   SetUcaseFile  ; 4		; Ucase file char type
 47374 0000127C [2F0B]                  	dw   FILE_UCASE_TAB 		;pointer to file upper case table
 47375 0000127E 0000                    	dw   0				; segment of poiter
 47376 00001280 05                      	db   SetFileList ; 5		; valid file chars type
 47377 00001281 [B10B]                  	dw   FILE_CHAR_TAB 		;pointer to valid file char tab
 47378 00001283 0000                    	dw   0				; segment of poiter
 47379 00001285 06                      	db   SetCollate	; 6		; collate type
 47380 00001286 [E10B]                  	dw   COLLATE_TAB		;pointer to collate table
 47381 00001288 0000                    	dw   0				; segment of poiter
 47382 0000128A 07                      	db   SetDBCS	; 7		;AN000; DBCS Ev			2/12/KK
 47383 0000128B [E30C]                  	dw   DBCS_TAB			;AN000;pointer to DBCS Ev table	2/12/KK
 47384 0000128D 0000                    	dw   0				;AN000; segment of pointer	2/12/KK
 47385 0000128F 01                      	db   SetCountryInfo  ; 1	; country info type
 47386 00001290 2600                    	dw   NEW_COUNTRY_SIZE		; extended country info size
 47387                                  ; ------------------------------------------------<MSKK01>-------------------
 47388                                  ;ifdef	DBCS
 47389                                  ;	...... 
 47390                                  ;else
 47391 00001292 0100                    	dw   1				; USA country id
 47392 00001294 B501                    	dw   437			; USA system code page id
 47393 00001296 0000                    	dw   0 				; date format
 47394 00001298 2400000000              	db   '$',0,0,0,0		; currency symbol
 47395 0000129D 2C00                    	db   ',',0			; thousand separator
 47396 0000129F 2E00                    	db   '.',0			; decimal separator
 47397 000012A1 2D00                    	db   '-',0			; date separator
 47398 000012A3 3A00                    	db   ':',0			; time separator
 47399 000012A5 00                      	db   0				; currency format flag
 47400 000012A6 02                      	db   2				; # of digits in currency
 47401 000012A7 00                      	db   0 				; time format
 47402 000012A8 [F50C]                  	dw   MAP_CASE			; mono case routine entry point
 47403 000012AA 0000                    	dw   0				; segment of entry point
 47404 000012AC 2C00                    	db   ',',0			; data list separator
 47405 000012AE 000000000000000000-     	dw   0,0,0,0,0			; reserved
 47405 000012B7 00                 
 47406                                  ;endif
 47407                                  ; ------------------------------------------------<MSKK01>-------------------
 47408                                  
 47409                                  ; 27/04/2019 - Retro DOS v4.0
 47410                                  
 47411                                  ;include msdos.cl2			; XMMERRMSG
 47412                                  
 47413                                  ; DOSDATA:12B8h (MSDOS 6.22, MSDOS.SYS) ; 17/01/2024
 47414                                  
 47415                                  XMMERRMSG:
 47416 000012B8 0D0A                    	db	0Dh,0Ah
 47417 000012BA 413230204861726477-     	db	'A20 Hardware Error',0Dh,0Ah,'$'
 47417 000012C3 617265204572726F72-
 47417 000012CC 0D0A24             
 47418                                  
 47419                                  ; DOSDATA ends
 47420                                  
 47421                                  ; 05/11/2022
 47422                                  ;----------------------------------------------------------------------------
 47423                                  ; End of MSDOS 5.0 MSDOS.SYS /// Retro DOS v4.0 (2022) - 05/11/2022
 47424                                  ;----------------------------------------------------------------------------
 47425                                  
 47426                                  ; 28/12/2022 - Retro DOS v4.1
 47427                                  ; (windows 3.1 and Rational Extender patches are removed/disabled)
 47428                                  ; (Windows 3.1 does not use the patches below if DOS version is MSDOS 5.0)
 47429                                  ;----------------------------------------------------------------------------
 47430                                  %if 0
 47431                                  
 47432                                  ;----------------------------------------------------------------------------
 47433                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 47434                                  
 47435                                  ;============================================================================
 47436                                  ; WPATCH.INC (MSDOS 6.0, 1991)  ;;; Windows 3.1 patches ;;;
 47437                                  ;============================================================================
 47438                                  ; 27/04/2019 - Retro DOS 4.0
 47439                                  
 47440                                  ;DOSDATA Segment
 47441                                  
 47442                                  ; DOSDATA:12CFh (MSDOS 6.21, MSDOS.SYS)
 47443                                  
 47444                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 47445                                  ; DOSDATA:12CFh (MSDOS 5.0, MSDOS.SYS)
 47446                                  
 47447                                  ; first and second DOS patches
 47448                                  ;	Non-console device read/write (system calls 3Fh and 40h)
 47449                                  ;
 47450                                  ; Code in disk.asm, 2 locations, one for read, one for write
 47451                                  ;	DVRDLP:
 47452                                  ;	DVWRTLP:
 47453                                  ;
 47454                                  ;
 47455                                  ; 036h	lds	si,SS:[????]				  ; ThisSFT
 47456                                  ;	lds	si,si+7 				  ; sf_devptr
 47457                                  ; 0E8h	call	????		<- "simulate" int28 event ; DSKSTATCHK
 47458                                  
 47459                                  DOSP1_ID:	db	036h,0C5h,036h
 47460                                  DOSP1_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 47461                                  DOSP1_ID_LEN	equ	$-DOSP1_ID
 47462                                  
 47463                                  		db	90h, 90h
 47464                                  
 47465                                  DOSP12_ID:	db	036h,0C5h,036h
 47466                                  DOSP12_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 47467                                  DOSP12_ID_LEN	equ	$-DOSP1_ID
 47468                                  
 47469                                  ; DOSDATA:12E3h
 47470                                  
 47471                                  ; Third/Fourth DOS patch - System call 3Fh (Read) from console
 47472                                  ;
 47473                                  ; Code in disk.asm, 1 location
 47474                                  ;	GETBUF:
 47475                                  ;
 47476                                  ; 051h	push	cx	<- begin special int28 mode
 47477                                  ;	push	es
 47478                                  ;	push	di
 47479                                  ;	mov	dx,???? ; offset dosgroup:CONBUF
 47480                                  ;	call	????	; $STD_CON_STRING_INPUT
 47481                                  ;	pop	di
 47482                                  ;	pop	es
 47483                                  ; 059h	pop	cx	<- end special int28 mode
 47484                                  
 47485                                  DOSP3_ID:	db	051h,006h,057h,0BAh
 47486                                  DOSP3_CONBUF:	db	029h,002h,0E8h
 47487                                  DOSP3_ID_LEN	equ	$-DOSP3_ID
 47488                                  		db	09Ah,0E3h,05Fh,007h	; ???? , pop di, pop es
 47489                                  DOSP4_ID:	db	059h			; pop cx
 47490                                  DOSP4_ID_OFF	equ	(DOSP4_ID - DOSP3_ID)
 47491                                  	
 47492                                  ; DOSDATA:12EFh
 47493                                  
 47494                                  ; Fifth DOS patch - System call 40h (Write) to console
 47495                                  ;
 47496                                  ; Code in disk.asm, 1 location
 47497                                  ;
 47498                                  ;		push	cx
 47499                                  ;      WRCONLP: lodsb
 47500                                  ;		cmp	al,1Ah
 47501                                  ;		jz	????
 47502                                  ;		call	????	<- "simulate" int28 event
 47503                                  ;		loop	WRCONLP
 47504                                  ;      CONEOF:	pop	ax
 47505                                  
 47506                                  DOSP5_ID:	db	051h			; push cx
 47507                                  		db	0ACh,03Ch,01Ah,074h,005h
 47508                                  		db	0E8h			; call
 47509                                  DOSP5_ID_LEN	equ	$-DOSP5_ID
 47510                                  
 47511                                  ; DOSDATA:12F6h
 47512                                  
 47513                                  ; Seventh DOS patch - System call entry, patch USER_ID with VMid for share
 47514                                  ;
 47515                                  ; Code in disp.asm, 1 location
 47516                                  ;
 47517                                  ;
 47518                                  ;	mov [SaveDS],ds
 47519                                  ;	mov [SaveBX],bx
 47520                                  ;	mov bx,cs
 47521                                  ;	mov ds,bx
 47522                                  ;	inc [indos]
 47523                                  ;	xor ax,ax
 47524                                  ;	mov [USER_ID],AX	<- Patch to set USER_ID to VMID
 47525                                  
 47526                                  DOSP7_ID:	db	02Eh,08Ch,01Eh
 47527                                  DOSP7_SAVEDS:	db	07Eh,05h		; mov [SaveDS],ds
 47528                                  		db	02Eh,089h,01Eh
 47529                                  DOSP7_SAVEBX:	db	07Ch,05h		; mov [SaveBX],bx
 47530                                  		db	08Ch,0CBh		; mov bx,cs
 47531                                  		db	08Eh,0DBh		; mov ds,bx
 47532                                  		db	0FEh,006h
 47533                                  DOSP7_INDOS:	db	0CFh,002h		; inc [indos]
 47534                                  		db	033h,0C0h		; xor ax,ax
 47535                                  DOSP7_ID_LEN	equ	$-DOSP7_ID
 47536                                  
 47537                                  ; DOSDATA:130Ah
 47538                                  
 47539                                  ; Eighth DOS patch - OWNER check in handle calls. For share, need to NOP test
 47540                                  ;
 47541                                  ; Code in handle.asm, 1 location in routine CheckOwner
 47542                                  ;
 47543                                  ;
 47544                                  ;
 47545                                  ;	push	ax
 47546                                  ;	mov	ax,ss:[USER_ID]     <- patch to XOR AX,AX to set zero
 47547                                  ;	cmp	ax,es:[di.sf_UID]   <- NOP
 47548                                  ;	pop	ax
 47549                                  ;	jz	????
 47550                                  
 47551                                  DOSP8_ID:	db	050h			; push ax
 47552                                  		db	036h,0A1h
 47553                                  DOSP8_USER_ID:	db	0EAh,002h		; mov  ax,ss:[USER_ID]
 47554                                  		db	026h,03Bh,045h		; cmp  ax,es:[di+2F]
 47555                                  DOSP8_ID_LEN	equ	$-DOSP8_ID
 47556                                  		db	02Fh,058h		; pop  ax
 47557                                  
 47558                                  ; DOSDATA:1314h
 47559                                  
 47560                                  ; 10th, 11th, 12th DOS patch - System call 3Fh (Read) in raw mode
 47561                                  ;
 47562                                  ;   Take RAW read to STDIN SFT and turn it into a polling loop doing
 47563                                  ;   a yeild when a character is not ready to be read.
 47564                                  ;
 47565                                  ; Code in disk.asm, 3 locations
 47566                                  ;
 47567                                  ;   DVRDRAW:
 47568                                  ;	    PUSH    ES
 47569                                  ;	    POP     DS
 47570                                  ;   ReadRawRetry:				<- Patch 10
 47571                                  ;	    MOV     BX,DI
 47572                                  ;	    XOR     AX,AX			<- Reenter #2
 47573                                  ;	    MOV     DX,AX
 47574                                  ;	    call    SETREAD
 47575                                  ;	    PUSH    DS				<- Reenter #1
 47576                                  ;	    LDS     SI,[THISSFT]
 47577                                  ;	    call    DEVIOCALL
 47578                                  ;	    MOV     DX,DI
 47579                                  ;	    MOV     AH,86H
 47580                                  ;	    MOV     DI,[DEVCALL.REQSTAT]
 47581                                  ;	    TEST    DI,STERR
 47582                                  ;	    JZ	    CRDROK
 47583                                  ;	    call    CHARHARD
 47584                                  ;	    MOV     DI,DX
 47585                                  ;	    OR	    AL,AL
 47586                                  ;	    JZ	    CRDROK
 47587                                  ;	    CMP     AL,3
 47588                                  ;	    JZ	    CRDFERR
 47589                                  ;	    POP     DS
 47590                                  ;	    JMP     ReadRawRetry
 47591                                  ;
 47592                                  ;   CRDFERR:
 47593                                  ;	    POP     DI				<- Patch 11
 47594                                  ;   DEVIOFERR:
 47595                                  ;	    LES     DI,[THISSFT]
 47596                                  ;	    jmp     SET_ACC_ERR_DS
 47597                                  ;
 47598                                  ;   CRDROK:
 47599                                  ;	    POP     DI				<- Patch 12
 47600                                  ;	    MOV     DI,DX
 47601                                  ;	    ADD     DI,[CALLSCNT]
 47602                                  ;	    JMP     SHORT ENDRDDEVJ3
 47603                                  
 47604                                  DOSP10_ID:		db	006H,01FH
 47605                                  DOSP10_LOC_OFFSET	equ	$-DOSP10_ID
 47606                                  DOSP10_LOC:		db	08BH,0DFH
 47607                                  DOSP10_REENT2_OFFSET	equ	$-DOSP10_LOC
 47608                                  			db	033H,0C0H,08BH,0D0H,0E8H
 47609                                  DOSP10_ID_LEN		equ	$-DOSP10_ID
 47610                                  			db	0DFH,00EH
 47611                                  DOSP10_REENT1_OFFSET	equ	$-DOSP10_LOC
 47612                                  			db	01EH,036H,0C5H,036H,036H,005H,0E8H,0AFH,00EH
 47613                                  			db	08BH,0D7H,0B4H,086H,036H,08BH,03EH
 47614                                  DOSP10_PACKVAL_OFFSET	equ	$-DOSP10_ID
 47615                                  			db	009H,003H
 47616                                  			db	0F7H,0C7H,000H,080H,074H,019H,0E8H,047H,017H
 47617                                  			db	08BH,0FAH,00AH,0C0H,074H,010H,03CH,003H,074H,003H
 47618                                  			db	01FH,0EBH,0CFH
 47619                                  DOSP11_LOC_OFFSET	equ	$-DOSP10_ID
 47620                                  			db	05FH
 47621                                  DOSP11_REENT_OFFSET	equ	$-DOSP10_LOC
 47622                                  			db	036H,0C4H,03EH,036H,005H,0E9H,0A1H,004H
 47623                                  
 47624                                  DOSP12_LOC_OFFSET	equ	$-DOSP10_ID
 47625                                  			db	05FH,08BH,0FAH
 47626                                  ; DOSDATA:1353h
 47627                                  
 47628                                  ; 13th DOS patch - Actually a SYSINIT patch. Patches the stack fault code
 47629                                  ;		which prints the fatal stack fault error on DOS >= 3.20.
 47630                                  ;
 47631                                  ;	    Sets focus to current VM so user can see fatal message.
 47632                                  ;
 47633                                  ;
 47634                                  ;	l0: lodsb		<- Setfocus here
 47635                                  ;	    cmp al, '$'
 47636                                  ;	    je l1
 47637                                  ;	    mov bl, 7
 47638                                  ;	    mov ah, 0Eh
 47639                                  ;	    int 10h
 47640                                  ;	    jmp l0
 47641                                  ;	l1: jmp $
 47642                                  
 47643                                  DOSP13_ID:	db	0ACh			; l0: lodsb
 47644                                  		db	03Ch,024h		;     cmp al, '$'
 47645                                  		db	074h,008h		;     je l1
 47646                                  		db	0B3h,007h		;     mov bl, 7
 47647                                  		db	0B4h,00Eh		;     mov ah, 0Eh
 47648                                  		db	0CDh,010h		;     int 10h
 47649                                  		db	0EBh,0F3h		;     jmp l0
 47650                                  		db	0EBh,0FEh		; l1: jmp $
 47651                                  DOSP13_ID_LEN	equ	$-DOSP13_ID
 47652                                  
 47653                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 47654                                  ; DOSDATA:1362h (MSDOS 5.0 MSDOS.SYS)
 47655                                  
 47656                                  ; 06/12/2022
 47657                                  ;DOSDATASIZE	equ  $ - DOSDATASTART ; 4962 bytes (1362h)
 47658                                  
 47659                                  ; DOSDATA ends
 47660                                  
 47661                                  ;============================================================================
 47662                                  ; MPATCH.ASM (MSDOS 6.0, 1993)
 47663                                  ;============================================================================
 47664                                  ; 27/04/2019 - Retro DOS 4.0
 47665                                  
 47666                                  ;mpatch.asm -- holds data patch location for callouts 
 47667                                  ; -- allocate cluster in rom.asm
 47668                                  ;
 47669                                  ; This area is pointed to by OffsetMagicPatch[609h] in fixed DOS data.
 47670                                  ; Currently, this location is used only by magicdrv.sys's patch to
 47671                                  ; cluster allocation, however it can be expanded to be used by other
 47672                                  ; patches. This is important since we have an easy-access pointer to
 47673                                  ; this location in OffsetMagicPatch. Magicdrv.sys is guaranteed to
 47674                                  ; only patch out a far call/retf, so any space after that could be
 47675                                  ; used as a patch by using OffsetMagicPatch+6. See rom.asm on how
 47676                                  ; to call out here.
 47677                                  ;
 47678                                  ; Currently, we allocate only the minimum space required for the 6
 47679                                  ; byte magicdrv patch, so if you change the dos data, you may want
 47680                                  ; to reserve space here if your new data will be position dependent
 47681                                  ; and would prohibit growing of this table.
 47682                                  ;
 47683                                  ;history	-	created 8-7-92 by scottq
 47684                                  ;		-	added Rational386PatchPtr 2-1-93 by jimmat
 47685                                  ;
 47686                                  ;Exported Functions
 47687                                  ;==================
 47688                                  ;MagicPatch     -       callout patched by magidrv.sys for cluster allocations
 47689                                  
 47690                                  ; DosData Segment
 47691                                  
 47692                                  ; DOSDATA:1362h (MSDOS 6.21, MSDOS.SYS)
 47693                                  
 47694                                  ; ---------------------------------------------------------------------------
 47695                                  
 47696                                  ; Rational386PatchPtr points to either a RET instruction (80286 or less) or
 47697                                  ; a routine to fix buggy versions of the Rational DOS Extender (80386 or
 47698                                  ; greater). Added to this file because it needed to be somewhere and is
 47699                                  ; 'patch' related.
 47700                                  
 47701                                  Rational386PatchPtr:
 47702                                  	dw	0	; points to patch routine or RET instr.
 47703                                  ; ---------------------------------------------------------------------------
 47704                                  
 47705                                  MagicPatch:
 47706                                  ;MagicPatch proc far
 47707                                          retf            ;default is to just return to allocate
 47708                                          nop             ;however, this code will be patched
 47709                                          nop             ;by magicdrv.sys to
 47710                                          nop             ; call far ?:?     
 47711                                          nop             ; retf or perhaps just jmp far
 47712                                          nop             ;retf/nop take one byte, so we need six instructions
 47713                                                          ;for 6 byte patch
 47714                                  ;MagicPatch endp
 47715                                  
 47716                                  ; ---------------------------------------------------------------------------
 47717                                  
 47718                                  ;DosData Ends
 47719                                  
 47720                                  ; DOSDATA:136Ah
 47721                                  
 47722                                  ;----------------------------------------------------------------------------
 47723                                  
 47724                                  ;DOSDATALAST SEGMENT
 47725                                  
 47726                                  ; 29/04/2019 - Retro DOS v4.0
 47727                                  
 47728                                  ;----------------------------------------------------------------------------
 47729                                  ; 25/05/2019 - Retro DOS v4.0 Modification (paragraph alignment)
 47730                                  
 47731                                  ;db 0,1,12,64,19,0 ; ! Magic numbers !
 47732                                  
 47733                                  ;align 16
 47734                                  
 47735                                  ; !!! DOSDATA:1370h ; Retro DOS v4.0 only!
 47736                                  
 47737                                  ;----------------------------------------------------------------------------
 47738                                  
 47739                                  %endif	; 05/11/2022
 47740                                  
 47741                                  ; 05/12/2022
 47742                                  ;MSDAT001E:	; label byte
 47743                                  
 47744                                  ; 22/03/2024 - Retro DOS v4.2
 47745                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 47746                                  DOSDATAEND equ $
 47747                                  DOSDATASIZE equ DOSDATAEND - DOSDATASTART ; = 4962 for MSDOS 5.0 MSDOS.SYS
 47748                                  MSDAT001E equ DOSDATAEND - DOSDATASTART	; = 4970 for MSDOS 6.22 MSDOS.SYS
 47749                                  					; (= 4934 for PCDOS 7.1 IBMDOS.COM)
 47750                                  					; ((= 4944 for Windows ME IO.SYS))
 47751                                  ;DOSDATALAST ENDS
 47752                                  
 47753                                  ; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 5.0 KERNEL via NASM)
 47754                                  ; DECEMBER 2022, ISTANBUL - TURKIYE.
 47755                                  ;============================================================================
 47756                                  ;	END
 47757                                  ;============================================================================
 47758                                  ; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 6.21 KERNEL via NASM)
 47759                                  ; -----------------------------
 47760                                  ; MAY 2019, ISTANBUL - TURKIYE.
