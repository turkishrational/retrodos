     1                                  ;*****************************************************************************
     2                                  ; IBMDOS7.S (PCDOS 7.1 Kernel) - RETRO DOS v5.0 by ERDOGAN TAN - 01/01/2024
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 04/02/2024 - Retro DOS v5.0 (Modified PCDOS 7.1)
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 22/04/2019 (Retro DOS 4.0), 03/11/2022 (Retro DOS 4.2)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.15
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	   ((nasm ibmdos7.s -l ibmdos7.txt -o IBMDOS.COM -Z error.txt))
    11                                  ;					   -o IBMDOS7.BIN
    12                                  ;*****************************************************************************
    13                                  ; main file: 'retrodos5.s'
    14                                  ; incbin 'IBMDOS7.BIN'
    15                                  ;=============================================================================
    16                                  ; Modified from 'msdos6.s' (modified MSDOS 6.21 kernel src as Retro DOS v4.2)
    17                                  ; 29/09/2023 /// Retro DOS v4.2 (2023) -> Modified MSDOS 6.22 IO.SYS+MSDOS.SYS
    18                                  ;=============================================================================
    19                                  
    20                                  ; 30/12/2022 - Retro DOS v4.2 Kernel ('msdos6.s')
    21                                  ; Modified from 'msdos5.s' (29/12/2022, Retro DOS v4.1 Kernel) file
    22                                  ; as below:
    23                                  ;	1) MS-DOS version has been changed to 6.22 (It was 5.0) 
    24                                  ;	2) Retro DOS version has been changed to 4.2 (It was 4.1)
    25                                  ; (The content has not been changed except kernel version because the kernel
    26                                  ;  code is already compatible with MSDOS 6.x and it is optimized before.)
    27                                  ;	(But IO.SYS part of the kernel is not same with Retro DOS v4.1 code.)
    28                                  
    29                                  ; ----------------------------------------------------------------------------
    30                                  
    31                                  ; 03/11/2022 - Erdogan Tan (Istanbul)
    32                                  
    33                                  ; Note:	This code is a part of Retro DOS 4.0 kernel source code
    34                                  ;	(as included binary, 'MSDOS5.BIN') 
    35                                  ;	Equivalent of MSDOS 5.0 MSDOS.SYS kernel file 
    36                                  ;	
    37                                  ;	((MSDOS 6.0 kernel source code has been modified by using disassembled
    38                                  ;	MSDOS 5.0 MSDOS.SYS)) -- Disassembler: HEX-RAYS IDA Pro --
    39                                  ;	((Disassembly -Reverse engineering- reference: MSDOS 6.0 kernel src))
    40                                        
    41                                  ;------ Retro DOS v2 (v3) boot sector loads RETRODOS.SYS (MSDOS.SYS)
    42                                  ;	at 1000h:0000h and loader (initialization) part of RETRODOS kernel
    43                                  ;	moves IO.SYS (DOSBIOSCODE & DOSBIOSDATA, 'IOSYS5.BIN') to 70h:0000h.
    44                                  ;	Then SYSINIT code to the next segment (4D6h for current version)..
    45                                  ;	SYSINIT code relocates itself and DOSBIOSCODE and MSDOS.SYS
    46                                  ;	(MSDOS5.BIN) according to request/setting in 'config.sys' file.
    47                                  
    48                                  ; ----------------------------------------------------------------------------
    49                                  
    50                                  ; 01/01/2024 - Retro DOS v5.0 Kernel ('ibmdos7.s')
    51                                  ; Modified from 'msdos6.s' (29/09/2023, Retro DOS v4.2 kernel: MSDOS.SYS) file
    52                                  ; as below:
    53                                  ;
    54                                  ;    1) Retro DOS v5.0 IBMDOS.COM is based on disassembled source code
    55                                  ;	of PCDOS 7.1 IBMDOS.COM (2003) and it is derived using Retro DOS v4.2
    56                                  ;	MSDOS.SYS source code. Retro DOS v5.0 (IBMDOS.COM) kernel source code
    57                                  ;	is modified (and optimized) and so, it is not same with the original
    58                                  ;	PCDOS 7.1 IBMDOS.COM.
    59                                  ;
    60                                  ;    2) Retro DOS v4.2 MSDOS.SYS is based on disassembled source code
    61                                  ;	of MSDOS 6.21 MSDOS.SYS, derived using MSDOS 6.0 source code.
    62                                  ;	(And then it has been verified and updated by comparing it with
    63                                  ;	the disassembled source code of MSDOS 6.22 kernel file MSDOS.SYS.)
    64                                  ;
    65                                  ;    3) Labels, names, comments, explanations and structure definitions
    66                                  ;	about procedures and code details are almost entirely taken from
    67                                  ;	the original MSDOS 6.0 source code, except for the details that
    68                                  ;	Erdogan Tan personally experienced. Some of them are incompatible
    69                                  ;	with PCDOS 7.1 code. But they have not been deleted to preserve
    70                                  ;	the originality of the descriptions.)
    71                                  ;
    72                                  ; ('msdos6.s' has been converted to 'ibmdos7.s' and 'retrodos42.s' has been
    73                                  ; converted to 'retrodos5.s'. 'ibmdos7.s' is IBMDOS.COM source code file
    74                                  ; while 'retrodos5.s' is source code of Retro DOS v5 kernel file 'PCDOS.SYS'.
    75                                  ; 'retrodos5.s' includes 'ibmdos7.bin' or IBMDOS.COM as binary file.)
    76                                  		
    77                                  ; ----------------------------------------------------------------------------
    78                                  
    79                                  ;=============================================================================
    80                                  ; Most of comments in this file are from the original MSDOS 6.0 source code
    81                                  ;-----------------------------------------------------------------------------
    82                                  
    83                                  ; MSDOS 6.0 Kernel source files:
    84                                  ;	MSDATA.ASM, 
    85                                  ; 		(MSHEAD.ASM, MSCONST.ASM,CONST2.ASM, MS_DATA.ASM,
    86                                  ;		DOSTAB.ASM, LMSTUB.ASM, WPATCH.INC, MPATCH.ASM)
    87                                  ;	MSTABLE.ASM, MSCODE.ASM, MSDOSME.ASM (DOSMES.INC), TIME.ASM,
    88                                  ;	GETSET.ASM, PARSE.ASM, MISC.ASM, MISC2.ASM, CRIT.ASM, CPMIO.ASM,
    89                                  ;	CPMIO2.ASM, FCBIO.ASM, FCBIO2.ASM, SEARCH.ASM, PATH.ASM, IOCTL.ASM,
    90                                  ;	DELETE.ASM, RENAME.ASM, FINFO.ASM, DUP.ASM, CREATE.ASM, OPEN.ASM,
    91                                  ;	DINFO.ASM, ISEARCH.ASM, BUF.ASM, ABORT.ASM,CLOSE.ASM, DIRCALL.ASM,
    92                                  ;	DISK.ASM, DISK2.ASM, DISK3.ASM, DIR.ASM, DIR2.ASM, DEV.ASM,
    93                                  ;	MKNODE.ASM, ROM.ASM, FCB.ASM, MSCTRLC.ASM, FAT.ASM, MSPROC.ASM
    94                                  ;	ALLOC.ASM, SRVCALL.ASM, UTIL.ASM, MACRO.ASM, MACRO2.ASM, HANDLE.ASM
    95                                  ;	FILE.ASM, LOCK.ASM, ROMFIND.ASM, SHARE.ASM, MSINIT.ASM, ORIGIN.ASM
    96                                  ;
    97                                  ; MSDOS 2.0 Kernel source files:
    98                                  ; 	MSDOS.ASM (STDSW.ASM + MSHEAD.ASM + MSDATA.ASM)
    99                                  ;	MSCODE.ASM
   100                                  ;	DOSMES.ASM ... STDIO.ASM, TIME.ASM, XENIX.ASM, XENIX2.ASM
   101                                  
   102                                  ;============================================================================
   103                                  ; DOSLINK
   104                                  ;============================================================================
   105                                  ;msdos mscode dosmes misc getset dircall alloc dev dir +
   106                                  ;disk fat rom stdbuf stdcall stdctrlc stdfcb stdproc +
   107                                  ;stdio time xenix xenix2
   108                                  
   109                                  ;============================================================================
   110                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
   111                                  ; output in TASM syntax (July 2018 -> NASM syntax) [ IBMDOS.COM, 17/03/1987 ]
   112                                  ;============================================================================
   113                                  ;
   114                                  ; ###########################################################################
   115                                  ; #	This file is generated by The Interactive Disassembler (IDA)	    #
   116                                  ; #	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    #
   117                                  ; #			 Licensed to: Freeware version			    #
   118                                  ; ###########################################################################
   119                                  ;
   120                                  ; Input	MD5   :	75959BC417C19135B982F7959EE9C92A
   121                                  
   122                                  ; ---------------------------------------------------------------------------
   123                                  ; File Name   :	C:\Documents and Settings\Erdoðan Tan\Desktop\MSDOS621.BIN
   124                                  ; Format      :	Binary file
   125                                  ;============================================================================
   126                                  ; MSDOS621.BIN = MSDOS.SYS, 13/02/1994, 38138 bytes (MSDOS 6.21 kernel) 2019
   127                                  ;----------------------------------------------------------------------------
   128                                  ; MSDOS5.BIN = MSDOS.SYS, 11/11/1991, 37394 bytes (MSDOS 5.0 kernel) 2022
   129                                  
   130                                  ;============================================================================
   131                                  ; MSDOS.ASM
   132                                  ;============================================================================
   133                                  
   134                                  ;TITLE   Standard MSDOS
   135                                  ;NAME    MSDOS_2
   136                                  
   137                                  ; Number of disk I/O buffers
   138                                  
   139                                  ;	INCLUDE STDSW.ASM
   140                                  ;       INCLUDE MSHEAD.ASM
   141                                  ;       INCLUDE MSDATA.ASM
   142                                  
   143                                  ;	END
   144                                  
   145                                  ;============================================================================
   146                                  ; STDSW.ASM
   147                                  ;============================================================================
   148                                  
   149                                  TRUE    EQU     0FFFFH
   150                                  FALSE   EQU     ~TRUE ; NOT TRUE
   151                                  
   152                                  ; Use the switches below to produce the standard Microsoft version or the IBM
   153                                  ; version of the operating system
   154                                  ;MSVER   EQU	false
   155                                  ;IBM     EQU	true
   156                                  ;WANG    EQU	FALSE
   157                                  ;ALTVECT EQU	FALSE
   158                                  
   159                                  ; Set this switch to cause DOS to move itself to the end of memory
   160                                  ;HIGHMEM EQU     FALSE
   161                                  
   162                                  ;	IF      IBM
   163                                  ESCCH    EQU	 0			;character to begin escape seq.
   164                                  CANCEL   EQU	 27			;Cancel with escape
   165                                  TOGLINS  EQU	TRUE			;One key toggles insert mode
   166                                  TOGLPRN  EQU	TRUE			;One key toggles printer echo
   167                                  ZEROEXT  EQU	TRUE
   168                                  ;       ELSE
   169                                  ;       IF      WANG			;Are we assembling for WANG?
   170                                  ;ESCCH	 EQU	1FH			;Yes. Use 1FH for escape character
   171                                  ;       ELSE
   172                                  ;ESCCH	 EQU	1BH
   173                                  ;       ENDIF
   174                                  ;CANCEL  EQU	"X"-"@"			;Cancel with Ctrl-X
   175                                  ;TOGLINS EQU	WANG			;Separate keys for insert mode on
   176                                  					;and off if not WANG
   177                                  ;TOGLPRN EQU	FALSE			;Separate keys for printer echo on
   178                                  					;and off
   179                                  ;ZEROEXT EQU	TRUE
   180                                  ;        ENDIF
   181                                  
   182                                  ;============================================================================
   183                                  ; MSHEAD.ASM
   184                                  ;============================================================================
   185                                  
   186                                  ;--------------------------------------------------------------
   187                                  ; TITLE   MSHEAD.ASM -- MS-DOS DEFINITIONS
   188                                  ;--------------------------------------------------------------
   189                                  
   190                                  ; MS-DOS High-performance operating system for the 8086  version 1.28
   191                                  ;        by Microsoft MSDOS development group:
   192                                  ;           Tim Paterson (Ret.)
   193                                  ;           Aaron Reynolds
   194                                  ;           Nancy Panners (Parenting)
   195                                  ;           Mark Zbikowski
   196                                  ;           Chris Peters (BIOS) (ret.)
   197                                  
   198                                  ; ****************** Revision History *************************
   199                                  ;          >> EVERY change must noted below!! <<
   200                                  ;
   201                                  ; 0.34 12/29/80 General release, updating all past customers
   202                                  ; 0.42 02/25/81 32-byte directory entries added
   203                                  ; 0.56 03/23/81 Variable record and sector sizes
   204                                  ; 0.60 03/27/81 Ctrl-C exit changes, including register save on user stack
   205                                  ; 0.74 04/15/81 Recognize I/O devices with file names
   206                                  ; 0.75 04/17/81 Improve and correct buffer handling
   207                                  ; 0.76 04/23/81 Correct directory size when not 2^N entries
   208                                  ; 0.80 04/27/81 Add console input without echo, Functions 7 & 8
   209                                  ; 1.00 04/28/81 Renumber for general release
   210                                  ; 1.01 05/12/81 Fix bug in `STORE'
   211                                  ; 1.10 07/21/81 Fatal error trapping, NUL device, hidden files, date & time,
   212                                  ;               RENAME fix, general cleanup
   213                                  ; 1.11 09/03/81 Don't set CURRENT BLOCK to 0 on open; fix SET FILE SIZE
   214                                  ; 1.12 10/09/81 Zero high half of CURRENT BLOCK after all (CP/M programs don't)
   215                                  ; 1.13 10/29/81 Fix classic "no write-through" error in buffer handling
   216                                  ; 1.20 12/31/81 Add time to FCB; separate FAT from DPT; Kill SMALLDIR; Add
   217                                  ;               FLUSH and MAPDEV calls; allow disk mapping in DSKCHG; Lots
   218                                  ;               of smaller improvements
   219                                  ; 1.21 01/06/82 HIGHMEM switch to run DOS in high memory
   220                                  ; 1.22 01/12/82 Add VERIFY system call to enable/disable verify after write
   221                                  ; 1.23 02/11/82 Add defaulting to parser; use variable escape character Don't
   222                                  ;               zero extent field in IBM version (back to 1.01!)
   223                                  ; 1.24 03/01/82 Restore fcn. 27 to 1.0 level; add fcn. 28
   224                                  ; 1.25 03/03/82 Put marker (00) at end of directory to speed searches
   225                                  ; 1.26 03/03/82 Directory buffers searched as a circular queue, current buffer
   226                                  ;               is searched first when possible to minimize I/O
   227                                  ;      03/03/82 STORE routine optimized to tack on partial sector tail as
   228                                  ;               full sector write when file is growing
   229                                  ;      03/09/82 Multiple I/O buffers
   230                                  ;      03/29/82 Two bugs:  Delete all case resets search to start at beginning
   231                                  ;               of directory (infinite loop possible otherwise), DSKRESET
   232                                  ;               must invalidate all buffers (disk and directory).
   233                                  ; 1.27 03/31/82 Installable device drivers
   234                                  ;                 Function call 47 - Get pointer to device table list
   235                                  ;                 Function call 48 - Assign CON AUX LIST
   236                                  ;      04/01/82 Spooler interrupt (INT 28) added.
   237                                  ; 1.28 04/15/82 DOS retructured to use ASSUMEs and PROC labels around system
   238                                  ;               call entries.  Most CS relative references changed to SS
   239                                  ;               relative with an eye toward putting a portion of the DOS in
   240                                  ;               ROM.  DOS source also broken into header, data and code pieces
   241                                  ;      04/15/82 GETDMA and GETVECT calls added as 24 and 32.  These calls
   242                                  ;               return the current values.
   243                                  ;      04/15/82 INDOS flag implemented for interrupt processing along with
   244                                  ;               call to return flag location (call 29)
   245                                  ;      04/15/82 Volume ID attribute added
   246                                  ;      04/17/82 Changed ABORT return to user to a long ret from a long jump to
   247                                  ;               avoid a CS relative reference.
   248                                  ;      04/17/82 Put call to STATCHK in dispatcher to catch ^C more often
   249                                  ;      04/20/82 Added INT int_upooler into loop ^S wait
   250                                  ;      04/22/82 Dynamic disk I/O buffer allocation and call to manage them
   251                                  ;               call 49.
   252                                  ;      04/23/82 Added GETDSKPTDL as call 50, similar to GETFATPT(DL), returns
   253                                  ;               address of DPB
   254                                  ;      04/29/82 Mod to WRTDEV to look for ^C or ^S at console input when
   255                                  ;               writting to console device via file I/O.  Added a console
   256                                  ;               output attribute to devices.
   257                                  ;      04/30/82 Call to en/dis able ^C check in dispatcher Call 51
   258                                  ;      04/30/82 Code to allow assignment of func 1-12 to disk files as well
   259                                  ;               as devices....  pipes, redirection now possible
   260                                  ;      04/30/82 Expanded GETLIST call to 2.0 standard
   261                                  ;      05/04/82 Change to INT int_fatal_abort callout int HARDERR.  DOS SS
   262                                  ;               (data segment) stashed in ES, INT int_fatal_abort routines must
   263                                  ;               preserve ES.  This mod so HARDERR can be ROMed.
   264                                  ; 1.29 06/01/82 Installable block and character devices as per 2.0 spec
   265                                  ;      06/04/82 Fixed Bug in CLOSE regarding call to CHKFATWRT.  It got left
   266                                  ;               out back about 1.27 or so (oops).  ARR
   267                                  ; 1.30 06/07/82 Directory sector buffering added to main DOS buffer queue
   268                                  ; 1.40 06/15/82 Tree structured directories.  XENIX Path Parser MKDIR CHDIR
   269                                  ;               RMDIR Xenix calls
   270                                  ; 1.41 06/13/82 Made GETBUFFR call PLACEBUF
   271                                  ; 1.50 06/17/82 FATs cached in buffer pool, get FAT pointer calls disappear
   272                                  ;               Frees up lots of memory.
   273                                  ; 1.51 06/24/82 BREAKDOWN modified to do EXACT one sector read/write through
   274                                  ;               system buffers
   275                                  ; 1.52 06/30/82 OPEN, CLOSE, READ, WRITE, DUP, DUP2, LSEEK implemented
   276                                  ; 1.53 07/01/82 OPEN CLOSE mod for Xenix calls, saves and gets remote dir
   277                                  ; 1.54 07/11/82 Function calls 1-12 make use of new 2.0 PDB. Init code
   278                                  ;               changed to set file handle environment.
   279                                  ; 2.00 08/01/82 Number for IBM release
   280                                  ;      01/19/83 No environ bug in EXEC
   281                                  ;      01/19/83 MS-DOS OEM INT 21 extensions (SET_OEM_HANDLER)
   282                                  ;      01/19/83 Performance bug fix in cooked write to NUL
   283                                  ;      01/27/83 Growcnt fixed for 32-bits
   284                                  ;      01/27/83 Find-first problem after create
   285                                  ; 2.01 02/17/83 International DOS
   286                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   287                                  ;               an IBM PC
   288                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
   289                                  ; (MSHEAD.ASM, MSDOS 6.0, 1991) - mshead.asm 1.1 85/04/10 -
   290                                  ; 2.10 03/09/83 Start of NETWORK support
   291                                  ;		New Buffer structure
   292                                  ;		New Sytem file table structure
   293                                  ;		FCB moved to internal representation
   294                                  ;		DOS re-organized
   295                                  ; 2.11 04/21/83 Continuation of 2.10, preliminary Network
   296                                  ;		device interface.
   297                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   298                                  ;               an IBM PC
   299                                  ; 2.50 09/12/83 More network stuff
   300                                  ;
   301                                  ; *************************************************************
   302                                  
   303                                  ; ----------------------------------------------------------------------------
   304                                  ; EQUATES
   305                                  
   306                                  ; Interrupt Entry Points:
   307                                  
   308                                  ; INTBASE:      ABORT
   309                                  ; INTBASE+4:    COMMAND
   310                                  ; INTBASE+8:    BASE EXIT ADDRESS
   311                                  ; INTBASE+C:    CONTROL-C ABORT
   312                                  ; INTBASE+10H:  FATAL ERROR ABORT
   313                                  ; INTBASE+14H:  BIOS DISK READ
   314                                  ; INTBASE+18H:  BIOS DISK WRITE
   315                                  ; INTBASE+1CH:  END BUT STAY RESIDENT (NOT SET BY DOS)
   316                                  ; INTBASE+20H:  SPOOLER INTERRUPT
   317                                  ; INTBASE+40H:  Long jump to CALL entry point
   318                                  
   319                                  ENTRYPOINTSEG   EQU     0Ch
   320                                  MAXDIF          EQU     0FFFh
   321                                  SAVEXIT         EQU     10
   322                                  ; 06/05/2019
   323                                  WRAPOFFSET	EQU	0FEF0h  ; (MISC.ASM, MSDOS 6.0, 1991)
   324                                  
   325                                         ; INCLUDE DOSSYM.ASM
   326                                         ; INCLUDE DEVSYM.ASM
   327                                  
   328                                  ; SUBTTL ^C, terminate/abort/exit and Hard error actions
   329                                  ; PAGE
   330                                  ; There are three kinds of context resets that can occur during normal DOS
   331                                  ; functioning:  ^C trap, terminate/abort/exit, and Hard-disk error.  These must
   332                                  ; be handles in a clean fashion that allows nested executions along with the
   333                                  ; ability to trap one's own errors.
   334                                  ;
   335                                  ; ^C trap - A process may elect to catch his own ^Cs.  This is achieved by
   336                                  ;           using the $GET_INTERRUPT_VECTOR and $SET_INTERRUPT_VECTOR as
   337                                  ;           follows:
   338                                  ;
   339                                  ;           $GET_INTERRUPT_VECTOR for INT int_ctrl_c
   340                                  ;           Save it in static memory.
   341                                  ;           $SET_INTERRUPT_VECTOR for INT int_ctrl_c
   342                                  ;
   343                                  ;           The interrupt service routine must preserve all registers and
   344                                  ;           return carry set iff the operation is to be aborted (via abort
   345                                  ;           system call), otherwise, carry is reset and the operation is
   346                                  ;           restarted.  ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE
   347                                  ;           RESULTS.
   348                                  ;
   349                                  ;           To restore original ^C processing (done on terminate/abort/exit),
   350                                  ;           restore INT int_ctrl_c from the saved vector.
   351                                  ;
   352                                  ; Hard-disk error -- The interrupt service routine for INT int_fatal_abort must
   353                                  ;           also preserve registers and return one of three values in AL: 0 and
   354                                  ;           1 imply retry and ignore (???)  and 2 indicates an abort.  The user
   355                                  ;           himself is not to issue the abort, rather, the dos will do it for
   356                                  ;           him by simulating a normal abort/exit system call.  ANY DEVIATION
   357                                  ;           FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   358                                  ;
   359                                  ; terminate/abort/exit -- The user may not, under any circumstances trap an
   360                                  ;           abort call.  This is reserved for knowledgeable system programs.
   361                                  ;           ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   362                                  
   363                                  ;SUBTTL SEGMENT DECLARATIONS
   364                                  
   365                                  ; The following are all of the segments used.  They are declared in the order
   366                                  ; that they should be placed in the executable
   367                                  
   368                                  ;
   369                                  ; segment ordering for MSDOS
   370                                  ;
   371                                  
   372                                  ;START           SEGMENT BYTE PUBLIC 'START'
   373                                  ;START           ENDS
   374                                  
   375                                  ;CONSTANTS       SEGMENT BYTE PUBLIC 'CONST'
   376                                  ;CONSTANTS       ENDS
   377                                  
   378                                  ;DATA            SEGMENT WORD PUBLIC 'DATA'
   379                                  ;DATA            ENDS
   380                                  
   381                                  ;CODE            SEGMENT BYTE PUBLIC 'CODE'
   382                                  ;CODE            ENDS
   383                                  
   384                                  ;LAST            SEGMENT BYTE PUBLIC 'LAST'
   385                                  ;LAST            ENDS
   386                                  
   387                                  ;DOSGROUP    GROUP   CODE,CONSTANTS,DATA,LAST
   388                                  
   389                                  ; The following segment is defined such that the data/const classes appear
   390                                  ; before the code class for ROMification
   391                                  
   392                                  ;START		SEGMENT BYTE PUBLIC 'START'
   393                                  ;           	ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
   394                                  ;		JMP     DOSINIT
   395                                  ;START		ENDS
   396                                  
   397                                  ;============================================================================
   398                                  ; BPB.INC, MSDOS 6.0, 1991
   399                                  ;============================================================================
   400                                  ; 09/07/2018 - Retro DOS v3.0
   401                                  
   402                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   403                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   404                                  ;									   ;
   405                                  
   406                                  ;**	BIOS PARAMETER BLOCK DEFINITION
   407                                  ;
   408                                  ;	The BPB contains information about the disk structure. It dates
   409                                  ;	back to the earliest FAT systems and so FAT information is
   410                                  ;	intermingled with physical driver information.
   411                                  ;
   412                                  ;	A boot sector contains a BPB for its device; for other disks
   413                                  ;	the driver creates a BPB. DOS keeps copies of some of this
   414                                  ;	information in the DPB.
   415                                  ;
   416                                  ;	The BDS structure contains a BPB within it. 
   417                                  
   418                                  ; 01/01/2024
   419                                  %if 0
   420                                  
   421                                  struc A_BPB
   422                                  .BPB_BYTESPERSECTOR:	resw	1
   423                                  .BPB_SECTORSPERCLUSTER:	resb	1
   424                                  .BPB_RESERVEDSECTORS:	resw	1
   425                                  .BPB_NUMBEROFFATS:	resb	1
   426                                  .BPB_ROOTENTRIES: 	resw	1
   427                                  .BPB_TOTALSECTORS:	resw	1
   428                                  .BPB_MEDIADESCRIPTOR:	resb	1
   429                                  .BPB_SECTORSPERFAT:	resw	1
   430                                  .BPB_SECTORSPERTRACK:	resw	1
   431                                  .BPB_HEADS:		resw	1
   432                                  .BPB_HIDDENSECTORS:	resw	1
   433                                  			resw	1
   434                                  .BPB_BIGTOTALSECTORS:	resw	1
   435                                  			resw	1
   436                                  			resb	6	; NOTE:  many times these
   437                                  ;					; 	 6 bytes are omitted
   438                                  ;					;	 when BPB manipulations
   439                                  ;					;	 are performed!
   440                                  .size:
   441                                  endstruc
   442                                  
   443                                  %else
   444                                  
   445                                  ; 01/01/2024 - Retro DOS v5.0	
   446                                  
   447                                  struc A_BPB
   448 00000000 ????                    .BYTESPERSECTOR:    resw 1
   449 00000002 ??                      .SECTORSPERCLUSTER: resb 1
   450 00000003 ????                    .RESERVEDSECTORS:   resw 1
   451 00000005 ??                      .NUMBEROFFATS:	    resb 1
   452 00000006 ????                    .ROOTENTRIES:	    resw 1
   453 00000008 ????                    .TOTALSECTORS:	    resw 1
   454 0000000A ??                      .MEDIADESCRIPTOR:   resb 1
   455 0000000B ????                    .SECTORSPERFAT:	    resw 1
   456 0000000D ????                    .SECTORSPERTRACK:   resw 1
   457 0000000F ????                    .HEADS:		    resw 1
   458 00000011 ????????                .HIDDENSECTORS:	    resd 1
   459 00000015 ????????                .BIGTOTALSECTORS:   resd 1
   460                                  ;............ FAT32 ......  + 28
   461 00000019 ????????                .FATSIZE32:	    resd 1
   462 0000001D ????                    .EXTFLAGS:	    resw 1
   463 0000001F ????                    .FSVER:		    resw 1
   464 00000021 ????????                .ROOTDIRCLUSTER:    resd 1
   465 00000025 ????                    .FSINFOSECTOR:	    resw 1  ; (offset from FAT32 bs)
   466 00000027 ????                    .BACKUPBOOTSECTOR:  resw 1  ; (offset from FAT32 bs)
   467 00000029 <res Ch>                .RESERVEDBYTES:	    resb 12 ; (zero bytes)
   468                                  .size:
   469                                  endstruc
   470                                  
   471                                  %endif
   472                                  
   473                                  ;                                                                          ;
   474                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   475                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   476                                  
   477                                  ;============================================================================
   478                                  ; BUFFER.INC, MSDOS 6.0, 1991
   479                                  ;============================================================================
   480                                  ; 04/05/2019 - Retro DOS v4.0
   481                                  ; 03/01/2024 - Retro DOS v5.0
   482                                  
   483                                  ; <Disk I/O Buffer Header>
   484                                  
   485                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   486                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   487                                  ;									   ;
   488                                  
   489                                  ; Field definition for I/O buffer information
   490                                  
   491                                  	; 03/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
   492                                  
   493                                  struc BUFFINFO
   494 00000000 ????                    .buf_next:	resw 1		; Pointer to next buffer in list
   495 00000002 ????                    .buf_prev:	resw 1		; Pointer to prev buffer in list
   496 00000004 ??                      .buf_ID:	resb 1		; Drive of buffer (bit 7 = 0)
   497                                  				; SFT table index (bit 7 = 1)
   498                                  				; = FFH if buffer free
   499 00000005 ??                      .buf_flags:	resb 1		; Bit 7 = 1 if Remote file buffer
   500                                  				;	= 0 if Local device buffer
   501                                  				; Bit 6 = 1 if buffer dirty
   502                                  				; Bit 5 = Reserved
   503                                  				; Bit 4 = Search bit (bit 7 = 1)
   504                                  				; Bit 3 = 1 if buffer is DATA
   505                                  				; Bit 2 = 1 if buffer is DIR
   506                                  				; Bit 1 = 1 if buffer is FAT
   507                                  				; Bit 0 = Reserved
   508 00000006 ????????                .buf_sector:	resd 1		; Sector number of buffer (flags bit 7 = 0)
   509                                  ; The next two items are often refed as a word (flags bit 7 = 0)
   510 0000000A ??                      .buf_wrtcnt:	resb 1		; For FAT sectors, # times sector written out
   511 0000000B ????                    .buf_wrtcntinc:	resw 1		; "   "     "   , # sectors between each write
   512 0000000D ????                    		resw 1 ; * ; 03/01/2024 ; PCDOS 7.1
   513                                  			   ; hw of sectors per FAT
   514 0000000F ????????                .buf_DPB:	resd 1		; Pointer to drive parameters
   515 00000013 ????                    .buf_fill:	resw 1		; How full buffer is (flags bit 7 = 1)
   516 00000015 ??                      .buf_reserved:	resb 1		; make DWORD boundary for 386
   517 00000016 ????                    		resw 1 ; * ; 03/01/2024 ; PCDOS 7.1
   518                                  			   ; reserved word for dword boundary
   519                                  .size:	; 20 bytes ; MSDOS 5.0 to 6.22
   520                                  	; 24 bytes ; PCDOS 7.1 ; 03/01/2024
   521                                  endstruc
   522                                  
   523                                  %define buf_offset	BUFFINFO.buf_sector ; 22/07/2019
   524                                  				;For buf_flags bit 7 = 1, this is the byte
   525                                  				;offset of the start of the buffer in
   526                                  				;the file pointed to by buf_ID. Thus
   527                                  				;the buffer starts at location
   528                                  				;buf_offset in the file and contains
   529                                  				;buf_fill bytes.
   530                                  
   531                                  BUFINSIZ        EQU     BUFFINFO.size
   532                                  
   533                                  buf_Free	EQU	0FFh	; buf_id of free buffer
   534                                  
   535                                  ;Flag byte masks
   536                                  buf_isnet	EQU	10000000B
   537                                  buf_dirty	EQU	01000000B
   538                                  ;***
   539                                  buf_visit	EQU	00100000B
   540                                  ;***
   541                                  buf_snbuf	EQU	00010000B
   542                                  
   543                                  buf_isDATA	EQU	00001000B
   544                                  buf_isDIR	EQU	00000100B
   545                                  buf_isFAT	EQU	00000010B
   546                                  buf_type_0	EQU	11110001B	; AND sets type to "none"
   547                                  
   548                                  buf_NetID	EQU	BUFINSIZ
   549                                  
   550                                  ;                                                                          ;
   551                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   552                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   553                                  
   554                                  ;============================================================================
   555                                  ; DOSSSYM.INC, MSDOS 6.0, 1991
   556                                  ;============================================================================
   557                                  ; 04/05/2019 - Retro DOS v4.0
   558                                  
   559                                  ; <Control character definitions>
   560                                  
   561                                  c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
   562                                  c_BS	    EQU     08h 	; ^H ASCII backspace
   563                                  c_CR	    EQU     0Dh 	; ^M ASCII carriage return
   564                                  c_LF	    EQU     0Ah 	; ^J ASCII linefeed
   565                                  c_ETB	    EQU     17h 	; ^W ASCII end of transmission
   566                                  c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
   567                                  c_ETX	    EQU     03h 	; ^C ASCII end of text
   568                                  c_HT	    EQU     09h 	; ^I ASCII tab
   569                                  
   570                                  ; <User stack inside of system call>
   571                                  ; Location of user registers relative user stack pointer
   572                                  
   573                                  struc	user_env   ; user_environ
   574 00000000 ????                    .user_AX: resw 1
   575 00000002 ????                    .user_BX: resw 1
   576 00000004 ????                    .user_CX: resw 1
   577 00000006 ????                    .user_DX: resw 1
   578 00000008 ????                    .user_SI: resw 1
   579 0000000A ????                    .user_DI: resw 1
   580 0000000C ????                    .user_BP: resw 1
   581 0000000E ????                    .user_DS: resw 1
   582 00000010 ????                    .user_ES: resw 1
   583 00000012 ????                    .user_IP: resw 1
   584 00000014 ????                    .user_CS: resw 1
   585 00000016 ????                    .user_F:  resw 1
   586                                  .size:
   587                                  endstruc
   588                                  
   589                                  ; ---- <Disk map> ----
   590                                  
   591                                  ;	MSDOS partitions the disk into 4 sections:
   592                                  ;
   593                                  ;  phys sector 0:   +-------------------+
   594                                  ;	|	    | boot/reserved	|
   595                                  ;	|	    +-------------------+
   596                                  ;	|	    |  File allocation	|
   597                                  ;	v	    |	   table(s)	|
   598                                  ;		    |  (multiple copies |
   599                                  ;		    |	  are kept)	|
   600                                  ;		    +-------------------+
   601                                  ;		    |	  Directory	|
   602                                  ;		    +-------------------+
   603                                  ;		    |	  File space	|
   604                                  ;		    +-------------------+
   605                                  ;		    |	Unaddressable	|
   606                                  ;		    |  (to end of disk) |
   607                                  ;		    +-------------------+
   608                                  ;
   609                                  ; All partition boundaries are sector boundaries. The size of the FAT is
   610                                  ; adjusted to maximize the file space addressable.
   611                                  
   612                                  ; <File allocation Table information>
   613                                  
   614                                  ; The File Allocation Table uses a 12-bit entry for each allocation unit on
   615                                  ; the disk. These entries are packed, two for every three bytes. The contents
   616                                  ; of entry number N is found by 1) multiplying N by 1.5; 2) adding the result
   617                                  ; to the base address of the Allocation Table; 3) fetching the 16-bit word
   618                                  ; at this address; 4) If N was odd (so that N*1.5 was not an integer), shift
   619                                  ; the word right four bits; 5) mask to 12 bits (AND with 0FFF hex). Entry
   620                                  ; number zero is used as an end-of-file trap in the OS and is passed to the
   621                                  ; BIOS to help determine disk format. Entry 1 is reserved for future use.
   622                                  ; The first available allocation unit is assigned entry number two, and even
   623                                  ; though it is the first, is called cluster 2. Entries greater than 0FF8H
   624                                  ; (12-bit fats) or 0FFF8H (16-bit fats) are end of file marks; entries of zero
   625                                  ; are unallocated. Otherwise, the contents of a FAT entry is the number of
   626                                  ; the next cluster in the file.
   627                                  ;
   628                                  ; Clusters with bad sectors are tagged with FF7H. Any non-zero number would
   629                                  ; do because these clusters show as allocated, but are not part of any
   630                                  ; allocation chain and thus will never be allocated to a file. A particular
   631                                  ; number is selected so that disk checking programs know what to do (ie. a
   632                                  ; cluster with entry FF7H which is not in a chain is not an error).
   633                                  
   634                                  ;**	Character Type Flags
   635                                  ;
   636                                  ;	These flags are used in a lookup table indexed by the character code.
   637                                  ;	They're used to quickly classify characters when parsing paths.
   638                                  ;	I think that these are only used to parse FCBs - jgl
   639                                  
   640                                  FCHK	equ 1	; I think this means "normal name char, no chks needed" -jgl
   641                                  FDELIM	equ 2	; is a delimiter
   642                                  FSPCHK	equ 4	; set if character is not a space or equivalent
   643                                  FFCB	equ 8	; is valid in an FCB
   644                                  
   645                                  ;** Bit definitions for DOS_FLAG
   646                                  ;
   647                                  ; Bit 0 - this is set when a $open call is made from $exec. This is used in
   648                                  ;	  $open to indicate to the redirector that this open is being made
   649                                  ;	  by an exec call.
   650                                  ;
   651                                  ; Bit 2
   652                                  ;
   653                                  ; M003, M027:
   654                                  ;
   655                                  ; The start up code of MS PASCAL 3.2 programs depend on the 1M address wrap 
   656                                  ; if they load below 64K. This is a likely possiblity in DOS 5.x with DOS in
   657                                  ; the HMA. By default DOS will turn A20 OFF before Xferring control to the
   658                                  ; user program in the case of an Exec call. The next call to DOS will turn
   659                                  ; A20 line ON. It has been observed that MS PASCAL 3.2 start up does an int
   660                                  ; 21 ah=25h call before executing the faulty code. This will turn A20 On. 
   661                                  ; In order to support this we will set Bit 2 of this flag in the DOS exec
   662                                  ; call (msproc.asm) if DOS is running in the HMA. In $set_interrupt_vector in
   663                                  ; getset.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
   664                                  ; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
   665                                  ; is non zero then A20 will be turned OFF before returning to the user. 
   666                                  ; Bit 2 will be unconditionally cleared here.
   667                                  ;
   668                                  ; M009, M027:
   669                                  ;
   670                                  ; Mace utilities MKEYRATE.COM version 1.0 copyright 1987 is an execpacked 
   671                                  ; program converted to a com file. Therefore if DOS is loaded high and if 
   672                                  ; this program is loaded below 64K it will blurt out "packed file is corrupt".
   673                                  ; This program does an int 21 ah=49h before executing the buggy execpacked
   674                                  ; code. This int21 call turns a20 on and hence the problem. In $dealloc
   675                                  ; alloc.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
   676                                  ; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
   677                                  ; is non zero then A20 will be turned OFF before returning to the user. 
   678                                  ; Bit 2 will be unconditionally cleared here.
   679                                  
   680                                  EXECOPEN	EQU	00000001b	; bit 0 of DOS_FLAG
   681                                  SUPPRESS_WINA20	EQU	00000010b	; M025
   682                                  EXECA20OFF	EQU	00000100b	; bit 2 of DOS_FLAG
   683                                  
   684                                  ;============================================================================
   685                                  ; VECTOR.INC, MSDOS 6.0, 1991
   686                                  ;============================================================================
   687                                  ; 04/05/2019 - Retro DOS v4.0
   688                                  
   689                                  ; 09/07/2018 - Retro DOS v3.0 (VECTOR.INC, MSDOS 3.3, 1987)
   690                                  
   691                                  ; <interrupt definitions>
   692                                  
   693                                  INTTAB          EQU     20H
   694                                  INTBASE         EQU     4 * INTTAB
   695                                  ENTRYPOINT      EQU     INTBASE+40H
   696                                  
   697                                  ;	IF      ALTVECT
   698                                  ;ALTTAB  EQU     0F0H
   699                                  ;ALTBASE EQU     4 * ALTTAB
   700                                  ;	ENDIF
   701                                  
   702                                  ;
   703                                  ; interrupt assignments
   704                                  ;
   705                                  ;	IF	NOT ALTVECT
   706                                  int_abort	    EQU     INTTAB	; abort process
   707                                  int_command	    EQU     int_abort+1 ; call MSDOS
   708                                  int_terminate	    EQU     int_abort+2 ; int to terminate address
   709                                  int_ctrl_c	    EQU     int_abort+3 ; ^c trapper
   710                                  int_fatal_abort     EQU     int_abort+4 ; hard disk error
   711                                  int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   712                                  int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   713                                  int_keep_process    EQU     int_abort+7 ; terminate program and stay
   714                                  					; resident
   715                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   716                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   717                                  ;									   ;
   718                                  int_spooler	    EQU     int_abort+8 ; spooler call
   719                                  int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   720                                  int_IBM 	    EQU     int_abort+10; critical section maintenance
   721                                  ;									   ;
   722                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   723                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   724                                  ;	ELSE
   725                                  ;int_abort	    EQU     INTTAB	; abort process
   726                                  ;int_command	    EQU     int_abort+1 ; call MSDOS
   727                                  ;int_terminate	    EQU     ALTTAB	; int to terminate address
   728                                  ;int_ctrl_c	    EQU     int_terminate+1 ; ^c trapper
   729                                  ;int_fatal_abort    EQU     int_terminate+2 ; hard disk error
   730                                  ;int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   731                                  ;int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   732                                  ;int_keep_process   EQU     int_abort+7 ; terminate program and stay resident
   733                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   734                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   735                                  ;									   ;
   736                                  ;int_spooler	    EQU     int_terminate+3 ; spooler call
   737                                  ;int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   738                                  ;									   ;
   739                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   740                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   741                                  ;	ENDIF
   742                                  
   743                                  addr_int_abort		EQU    4 * int_abort
   744                                  addr_int_command	EQU    4 * int_command
   745                                  addr_int_terminate	EQU    4 * int_terminate
   746                                  addr_int_ctrl_c 	EQU    4 * int_ctrl_c
   747                                  addr_int_fatal_abort	EQU    4 * int_fatal_abort
   748                                  addr_int_disk_read	EQU    4 * int_disk_read
   749                                  addr_int_disk_write	EQU    4 * int_disk_write
   750                                  addr_int_keep_process	EQU    4 * int_keep_process
   751                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   752                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   753                                  ;									   ;
   754                                  addr_int_spooler	EQU    4 * int_spooler
   755                                  addr_int_fastcon	EQU    4 * int_fastcon
   756                                  addr_int_ibm		EQU    4 * int_IBM
   757                                  ;									   ;
   758                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   759                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   760                                  
   761                                  ;============================================================================
   762                                  ; DIRENT.INC, MSDOS 6.0, 1991
   763                                  ;============================================================================
   764                                  ; 04/05/2019 - Retro DOS v4.0
   765                                  
   766                                  ; BREAK <Directory entry>
   767                                  
   768                                  ;
   769                                  ;       +---------------------------+
   770                                  ;       |  (12 BYTE) filename/ext   |       0       0
   771                                  ;       +---------------------------+
   772                                  ;       |     (BYTE) attributes     |       11      B
   773                                  ;       +---------------------------+
   774                                  ;       |    (10 BYTE) reserved     |       12      C
   775                                  ;       +---------------------------+
   776                                  ;       | (WORD) time of last write |       22      16
   777                                  ;       +---------------------------+
   778                                  ;       | (WORD) date of last write |       24      18
   779                                  ;       +---------------------------+
   780                                  ;       |   (WORD) First cluster    |       26      1A
   781                                  ;       +---------------------------+
   782                                  ;       |     (DWORD) file size     |       28      1C
   783                                  ;       +---------------------------+
   784                                  ;
   785                                  ;   First byte of filename  = E5 -> free directory entry
   786                                  ;                           = 00 -> end of allocated directory
   787                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   788                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   789                                  
   790                                  ; 01/01/2024
   791                                  %if 0
   792                                  
   793                                  struc dir_entry
   794                                  .dir_name:	resb 11			; file name
   795                                  .dir_attr:	resb 1			; attribute bits
   796                                  .dir_codepg:	resw 1			; code page DOS 4.00
   797                                  .dir_extcluster: resw 1			; extended attribute starting cluster
   798                                  .dir_attr2:	resb 1			; reserved
   799                                  .dir_pad:	resb 5			; reserved for expansion
   800                                  .dir_time:	resw 1			; time of last write
   801                                  .dir_date:	resw 1			; date of last write
   802                                  .dir_first:	resw 1			; first allocation unit of file
   803                                  .dir_size_l:	resw 1			; low 16 bits of file size
   804                                  .dir_size_h:	resw 1			; high 16 bits of file size
   805                                  .size:
   806                                  endstruc
   807                                  
   808                                  %else
   809                                  
   810                                  ; 01/01/2024 - Retro DOS v5.0 (*)
   811                                  
   812                                  struc dir_entry
   813 00000000 <res Bh>                .dir_name:	resb 11			; file name (short file name)
   814 0000000B ??                      .dir_attr:	resb 1			; file attributes (*)
   815 0000000C ??                      .dir_nt_res:	resb 1			; reserved for use by Windows NT. 0
   816                                  .dir_pad:	;resb 7			; (creation time, last access date
   817                                  					;  for use by Windows) 
   818                                  .dir_crttime_tenth:
   819 0000000D ??                      		resb 1
   820 0000000E ????                    .dir_crttime:	resw 1
   821 00000010 ????                    .dir_crtdate:	resw 1
   822                                  .dir_lstaccdate:
   823 00000012 ????                    		resw 1
   824 00000014 ????                    .dir_fclus_hi:	resw 1	; FAT32	fs	; high word of first cluster number
   825 00000016 ????                    .dir_time:	resw 1			; time of last write
   826 00000018 ????                    .dir_date:	resw 1			; date of last write
   827                                  .dir_fclus:				
   828 0000001A ????                    .dir_first:	resw 1			; first cluster (alloc. unit) of file
   829                                  .dir_file_size:
   830 0000001C ????                    .dir_size_l:	resw 1			; low 16 bits of file size
   831 0000001E ????                    .dir_size_h:	resw 1			; high 16 bits of file size
   832                                  .size:
   833                                  endstruc
   834                                  
   835                                  %endif
   836                                  
   837                                  attr_read_only      EQU      1h
   838                                  attr_hidden         EQU      2h
   839                                  attr_system         EQU      4h
   840                                  attr_volume_id      EQU      8h
   841                                  attr_directory      EQU     10h
   842                                  attr_archive        EQU     20h
   843                                  attr_device	    EQU     40h	; This is a VERY special bit.
   844                                  				;   NO directory entry on a disk EVER
   845                                  				;   has this bit set. It is set non-zero
   846                                  				;   when a device is found by GETPATH
   847                                  
   848                                  attr_all            EQU     attr_hidden+attr_system+attr_directory
   849                                                                          ; OR of hard attributes for FINDENTRY
   850                                  
   851                                  attr_ignore         EQU     attr_read_only+attr_archive
   852                                                                          ; ignore this(ese) attribute(s)
   853                                                                          ; during search first/next
   854                                  
   855                                  attr_changeable     EQU     attr_read_only+attr_hidden+attr_system+attr_archive
   856                                                                          ; changeable via CHMOD
   857                                  
   858                                  DIRFREE		equ	0E5h	; stored in dir_name[0] to indicate free slot
   859                                  
   860                                  ; ----------------------------------------------------------------------------
   861                                  ; 01/01/2024 - Retro DOS v5.0
   862                                  ; ref: FAT32 File System Specification v1.03 (Microsoft, December 6, 2000) (*)
   863                                  
   864                                  attr_long_name	equ attr_read_only|attr_hidden|attr_system|attr_volume_id
   865                                  attr_longname_mask equ attr_long_name|attr_directory|attr_archive
   866                                  
   867                                  ;============================================================================
   868                                  ; DPB.INC, MSDOS 6.0, 1991
   869                                  ;============================================================================
   870                                  ; 24/04/2019 - Retro DOS v4.0
   871                                  
   872                                  ; 19/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 3.3, 1987)
   873                                  ; 07/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 6.0, 1991)
   874                                  
   875                                  ; ---------------------------------------------------------------------------
   876                                  ;**	DPB - Drive Parameter Block
   877                                  ;
   878                                  ;	BUGBUG - this isn't authorative - it's my probably incomplete and
   879                                  ;	possibly inaccurate deductions from code study... - jgl
   880                                  ;
   881                                  ;	The DPB is DOS's main structure for describing block devices.
   882                                  ;	It contains info about the "Drive" intermingled with info about
   883                                  ;	the FAT file system which is presumably on the drive. I don't know
   884                                  ;	how those fields are used if it's not the FAT file system - BUGBUG
   885                                  ;
   886                                  ;	The DPBs are statically allocated and chained off of DPBHead.
   887                                  ;	Users scan this chain looking for a match on DPB_DRIVE.
   888                                  ;	The DPBs are built at init time from info in the SYSDEV structure.
   889                                  ; ---------------------------------------------------------------------------
   890                                  
   891                                  ; 01/01/2024
   892                                  %if 0
   893                                  
   894                                  struc	DPB
   895                                  .DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
   896                                  .UNIT:		resb 1		; Driver unit number of DPB
   897                                  .SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
   898                                  .CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
   899                                  .CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
   900                                  .FIRST_FAT:	resw 1		; Starting record of FATs
   901                                  .FAT_COUNT:	resb 1		; Number of FATs for this drive
   902                                  .ROOT_ENTRIES:	resw 1		; Number of directory entries
   903                                  .FIRST_SECTOR:	resw 1		; First sector of first cluster
   904                                  .MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
   905                                  ; MSDOS 3.3
   906                                  ;.FAT_SIZE:	resb 1		; Number of records occupied by FAT
   907                                  ; MSDOS 6.0
   908                                  .FAT_SIZE:	resw 1		; Number of records occupied by FAT
   909                                  .DIR_SECTOR:	resw 1		; Starting record of directory
   910                                  .DRIVER_ADDR:	resd 1		; Pointer to driver
   911                                  .MEDIA:		resb 1		; Media byte
   912                                  .FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
   913                                  				; check the first time this DPB is used
   914                                  .NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
   915                                  .NEXT_FREE:	resw 1		; Cluster # of last allocated cluster
   916                                  .FREE_CNT:	resw 1		; Count of free clusters, -1 if unknown
   917                                  .size:
   918                                  endstruc
   919                                  
   920                                  %else
   921                                  
   922                                  ; 01/01/2024 - Retro DOS v5.0 (PCDOS 7.1)
   923                                  
   924                                  struc	DPB
   925 00000000 ??                      .DRIVE:		resb 1	; 0	; Logical drive # assoc with DPB (A=0,B=1,...)
   926 00000001 ??                      .UNIT:		resb 1	; 1	; Driver unit number of DPB
   927 00000002 ????                    .SECTOR_SIZE:	resw 1	; 2	; Size of physical sector in bytes
   928 00000004 ??                      .CLUSTER_MASK:	resb 1	; 4	; Sectors/cluster - 1
   929 00000005 ??                      .CLUSTER_SHIFT:	resb 1	; 5	; Log2 of sectors/cluster
   930 00000006 ????                    .FIRST_FAT:	resw 1	; 6	; Starting record of FATs
   931 00000008 ??                      .FAT_COUNT:	resb 1	; 8	; Number of FATs for this drive
   932 00000009 ????                    .ROOT_ENTRIES:	resw 1	; 9	; Number of directory entries
   933 0000000B ????                    .FIRST_SECTOR:	resw 1	; 11	; First sector of first cluster
   934 0000000D ????                    .MAX_CLUSTER:	resw 1	; 13	; Number of clusters on drive + 1
   935 0000000F ????                    .FAT_SIZE:	resw 1	; 15	; Number of records occupied by FAT
   936 00000011 ????                    .DIR_SECTOR:	resw 1	; 17	; Starting record of directory
   937 00000013 ????????                .DRIVER_ADDR:	resd 1  ; 19	; Pointer to driver
   938 00000017 ??                      .MEDIA:		resb 1	; 23	; Media byte
   939 00000018 ??                      .FIRST_ACCESS:	resb 1	; 24	; This is initialized to -1 to force a media
   940                                  				; check the first time this DPB is used
   941 00000019 ????????                .NEXT_DPB:	resd 1	; 25	; Pointer to next Drive parameter block
   942 0000001D ????                    .NEXT_FREE:	resw 1	; 29	; Cluster # of last allocated cluster
   943 0000001F ????                    .FREE_CNT:	resw 1	; 31	; Count of free clusters, -1 if unknown
   944                                  ; FAT32 fs ; 01/01/2024
   945                                  ; ref: https://en.wikibooks.org/wiki/
   946                                  ;      First_steps_towards_system_programming_under_MS-DOS_7/Appendix
   947                                  ;   -- A.03-1. Structure of Drive Parameters Blocks (DPB) ---
   948 00000021 ????                    .FREE_CNT_HW:	resw 1	; 33	; High word of free cluster count
   949 00000023 ????                    .EXT_FLAGS:	resw 1	; 35	; FAT32 extended flags (active FAT number)
   950 00000025 ????                    .FSINFO_SECTOR:	resw 1	; 37	; (FAT32 fs) FSINFO structure sector address
   951 00000027 ????                    .BKBOOT_SECTOR:	resw 1	; 39	; (FAT32 fs) Backup Boot Sector address
   952 00000029 ????????                .FCLUS_FSECTOR: resd 1	; 41	; The first cluster's first sector address
   953 0000002D ????????                .LAST_CLUSTER:	resd 1	; 45	; The last cluster number
   954 00000031 ????????                .FAT32_SIZE:	resd 1	; 49	; Number of FAT sectors (for FAT32 fs)	 
   955 00000035 ????????                .ROOT_CLUSTER:	resd 1	; 53	; Root directory's cluster number (FAT32 fs)
   956                                  ; 01/01/2024 - Retro DOS v5.0
   957 00000039 ????????                .FAT32_NXTFREE:	resd 1  ; 57	; The next free cluster (for FAT32 fs)
   958                                  .size:		; 61 bytes ; 01/01/2024 (PCDOS 7.1)
   959                                  endstruc
   960                                  
   961                                  
   962                                  %endif
   963                                  
   964                                  DPBSIZ  EQU     DPB.size	; Size of the structure in bytes
   965                                  
   966                                  DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)
   967                                  
   968                                  ;                                                                          ;
   969                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   970                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   971                                  
   972                                  ;============================================================================
   973                                  ; SF.INC, MSDOS 6.0, 1991
   974                                  ;============================================================================
   975                                  ; 25/04/2019 - Retro DOS v4.0
   976                                  ; 07/07/2018 - Retro DOS v3.0
   977                                  
   978                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   979                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   980                                  ;                                                                          ;
   981                                  
   982                                  ; ---------------------------------------------------------------------------
   983                                  ;**	SF.INC - System File Table
   984                                  ;
   985                                  ;   AN000   version 4.00   Jan. 1988
   986                                  ;   AN003   PTM 3680 --  make NAME offset the same as before (<=3.30)
   987                                  ;   AN009   PTM 3839	 reorder SFT for MS WINDOWS
   988                                  ; ---------------------------------------------------------------------------
   989                                  ;**	System File Table SuperStructure
   990                                  ;
   991                                  ;	The system file table entries are allocated in contiguous groups.
   992                                  ;	There may be more than one such groups; the SF "superstructure"
   993                                  ;	tracks the groups.
   994                                  ; ---------------------------------------------------------------------------
   995                                  
   996                                  struc	SFT
   997 00000000 ????????                .SFLink:	resd 1
   998 00000004 ????                    .SFCount:	resw 1		; number of entries
   999 00000006 ????                    .SFTable:	resw 1		; beginning of array of the following
  1000                                  .size:
  1001                                  endstruc
  1002                                  
  1003                                  ; ---------------------------------------------------------------------------
  1004                                  ;**	System file table entry
  1005                                  ;
  1006                                  ;	These are the structures which are at SFTABLE in the SF structure.
  1007                                  ; ---------------------------------------------------------------------------
  1008                                  
  1009                                  ; 01/01/2024 - Retro DOS v5.0
  1010                                  ; 25/04/2019 - Retro DOS v4.0
  1011                                  
  1012                                  struc SF_ENTRY
  1013 00000000 ????                    .sf_ref_count:	resw 1	; 0	; number of processes sharing entry
  1014                                  				;   if FCB then ref count
  1015 00000002 ????                    .sf_mode:	resw 1	; 2	; mode of access or high bit on if FCB
  1016 00000004 ??                      .sf_attr:	resb 1	; 4	; attribute of file
  1017 00000005 ????                    .sf_flags:	resw 1	; 5	;Bits 8-15
  1018                                  				; Bit 15 = 1 if remote file
  1019                                  				;	 = 0 if local file or device
  1020                                  				; Bit 14 = 1 if date/time is not to be
  1021                                  				;   set from clock at CLOSE. Set by
  1022                                  				;   FILETIMES and FCB_CLOSE. Reset by
  1023                                  				;   other reseters of the dirty bit
  1024                                  				;   (WRITE)
  1025                                  				; Bit 13 = Pipe bit (reserved)
  1026                                  				;
  1027                                  				; Bits 0-7 (old FCB_devid bits)
  1028                                  				; If remote file or local file, bit
  1029                                  				; 6=0 if dirty Device ID number, bits
  1030                                  				; 0-5 if local file.
  1031                                  				; bit 7=0 for local file, bit 7
  1032                                  				;      =1 for local I/O device
  1033                                  				; If local I/O device, bit 6=0 if EOF (input)
  1034                                  				;		Bit 5=1 if Raw mode
  1035                                  				;		Bit 0=1 if console input device
  1036                                  				;		Bit 1=1 if console output device
  1037                                  				;		Bit 2=1 if null device
  1038                                  				;		Bit 3=1 if clock device
  1039 00000007 ????????                .sf_devptr:	resd	1 ; 7	; Points to DPB if local file, points
  1040                                  				; to device header if local device,
  1041                                  				; points to net device header if
  1042                                  				; remote
  1043 0000000B ????                    .sf_firclus:	resw	1 ; 11	; First cluster of file (bit 15 = 0)
  1044 0000000D ????                    .sf_time:	resw	1 ; 13	; Time associated with file
  1045 0000000F ????                    .sf_date:	resw	1 ; 15	; Date associated with file
  1046 00000011 ????????                .sf_size:	resd 	1 ; 17	; Size associated with file
  1047 00000015 ????????                .sf_position:	resd	1 ; 21	; Read/Write pointer or LRU count for FCBs
  1048                                  
  1049                                  ; Starting here, the next 7 bytes may be used by the file system to store
  1050                                  ; an ID
  1051                                  
  1052                                  ; 09/07/2018 - Retro DOS v3.0
  1053                                  
  1054                                  ; MSDOS 3.3 SF.INC, 1987
  1055                                  ;.sf_cluspos:	resw	1	; Position of last cluster accessed
  1056                                  ;.sf_lstclus	resw	1	; Last cluster accessed
  1057                                  ;.sf_dirsec:	resw	1	; Sector number of directory sector
  1058                                  ;				; for this file
  1059                                  ;.sf_dirpos:	resb	1	; Offset of this entry in the above
  1060                                  
  1061                                  ; MSDOS 6.0, SF.INC, 1991
  1062 00000019 ????                    .sf_cluspos:	resw	1 ; 25	; Position of last cluster accessed
  1063 0000001B ????????                .sf_dirsec:	resd	1 ; 27	; Sector number of directory sector
  1064                                  				; for this file
  1065 0000001F ??                      .sf_dirpos:	resb	1 ; 31	; Offset of this entry in the above
  1066                                  
  1067                                  ; End of 7 bytes of file-system specific info.
  1068                                  
  1069 00000020 <res Bh>                .sf_name:	resb	11 ; 32	; 11 character name that is in the
  1070                                  				; directory entry. This is used by
  1071                                  				; close to detect file deleted and
  1072                                  				; disk changed errors.
  1073                                  ; SHARING INFO
  1074 0000002B ????????                .sf_chain:	resd	1 ; 43	; link to next SF
  1075 0000002F ????                    .sf_UID:	resw	1 ; 47
  1076 00000031 ????                    .sf_PID:	resw	1 ; 49	; owner process identifier (PSP segment) 
  1077 00000033 ????                    .sf_MFT:	resw	1 ; 51
  1078                                  
  1079                                  ; MSDOS 6.0, SF.INC, 1991
  1080 00000035 ????                    .sf_lstclus:	resw	1 ; 53	;AN009; Last cluster accessed
  1081 00000037 ????????                .sf_IFS_HDR:	resd	1 ; 55	; pointer to IFS drive or 0:0 for files
  1082                                  
  1083                                  .size:
  1084                                  endstruc
  1085                                  
  1086                                  ; 20/07/2018
  1087                                  ; MSDOS 3.3, SF.INC, 1987
  1088                                  %define sf_netid   SF_ENTRY.sf_cluspos    ; byte
  1089                                  %define sf_OpenAge SF_ENTRY.sf_position+2 ; word
  1090                                  %define sf_LRU	   SF_ENTRY.sf_position	  ; word
  1091                                  ; MSDOS 6.0, SF.INC, 1991
  1092                                  %define sf_fsda	     SF_ENTRY.sf_cluspos  ; byte ;DOS 4.00
  1093                                  %define sf_serial_ID SF_ENTRY.sf_firclus  ; word ;DOS 4.00
  1094                                  
  1095                                  ; 19/07/2018
  1096                                  ; MSDOS 3.3, SF.INC, 1987
  1097                                  
  1098                                  sf_default_number  EQU	5
  1099                                  
  1100                                  ; Note that we need to mark an SFT as being busy for OPEN/CREATE. This is
  1101                                  ; because an INT 24 may prevent us from 'freeing' it. We mark this as such
  1102                                  ; by placing a -1 in the ref_count field.
  1103                                  
  1104                                  sf_busy EQU -1
  1105                                  
  1106                                  ; mode mask for FCB detection
  1107                                  sf_isFCB		EQU	1000000000000000B
  1108                                  
  1109                                  ; Flag word masks
  1110                                  sf_isnet		EQU	1000000000000000B
  1111                                  sf_close_nodate 	EQU	0100000000000000B
  1112                                  sf_pipe 		EQU	0010000000000000B
  1113                                  sf_no_inherit		EQU	0001000000000000B
  1114                                  sf_net_spool		EQU	0000100000000000B
  1115                                  
  1116                                  ; 25/04/2019
  1117                                  sf_entry_size equ SF_ENTRY.size ; 59 (MSDOS 6.0)
  1118                                  
  1119                                  ; ---------------------------------------------------------------------------
  1120                                  ; Local file/device flag masks
  1121                                  ; ---------------------------------------------------------------------------
  1122                                  
  1123                                  devid_file_clean        EQU     40h     ; true if file and not written
  1124                                  devid_file_mask_drive   EQU     3Fh     ; mask for drive number
  1125                                  
  1126                                  devid_device            EQU     80h     ; true if a device
  1127                                  devid_device_EOF        EQU     40h     ; true if end of file reached
  1128                                  devid_device_raw        EQU     20h     ; true if in raw mode
  1129                                  devid_device_special    EQU     10h     ; true if special device
  1130                                  devid_device_clock      EQU     08h     ; true if clock device
  1131                                  devid_device_null       EQU     04h     ; true if null device
  1132                                  devid_device_con_out    EQU     02h     ; true if console output
  1133                                  devid_device_con_in     EQU     01h     ; true if console input
  1134                                  
  1135                                  ; ---------------------------------------------------------------------------
  1136                                  ; structure of devid field as returned by IOCTL is:
  1137                                  ;
  1138                                  ;       BIT     7   6   5   4   3   2   1   0
  1139                                  ;             |---|---|---|---|---|---|---|---|
  1140                                  ;             | I | E | R | S | I | I | I | I |
  1141                                  ;             | S | O | A | P | S | S | S | S |
  1142                                  ;             | D | F | W | E | C | N | C | C |
  1143                                  ;             | E |   |   | C | L | U | O | I |
  1144                                  ;             | V |   |   | L | K | L | T | N |
  1145                                  ;             |---|---|---|---|---|---|---|---|
  1146                                  ;       ISDEV = 1 if this channel is a device
  1147                                  ;             = 0 if this channel is a disk file
  1148                                  ;
  1149                                  ;       If ISDEV = 1
  1150                                  ;
  1151                                  ;             EOF = 0 if End Of File on input
  1152                                  ;             RAW = 1 if this device is in Raw mode
  1153                                  ;                 = 0 if this device is cooked
  1154                                  ;             ISCLK = 1 if this device is the clock device
  1155                                  ;             ISNUL = 1 if this device is the null device
  1156                                  ;             ISCOT = 1 if this device is the console output
  1157                                  ;             ISCIN = 1 if this device is the console input
  1158                                  ;
  1159                                  ;       If ISDEV = 0
  1160                                  ;             EOF = 0 if channel has been written
  1161                                  ;             Bits 0-5 are the block device number for
  1162                                  ;                 the channel (0 = A, 1 = B, ...)
  1163                                  ; ---------------------------------------------------------------------------
  1164                                  
  1165                                  devid_ISDEV     EQU     80h
  1166                                  devid_EOF       EQU     40h
  1167                                  devid_RAW       EQU     20h
  1168                                  devid_SPECIAL   EQU     10H
  1169                                  devid_ISCLK     EQU     08h
  1170                                  devid_ISNUL     EQU     04h
  1171                                  devid_ISCOT     EQU     02h
  1172                                  devid_ISCIN     EQU     01h
  1173                                  
  1174                                  devid_block_dev EQU     1Fh             ; mask for block device number
  1175                                  
  1176                                  ;============================================================================
  1177                                  ; PDB.INC, MSDOS 6.0, 1991
  1178                                  ;============================================================================
  1179                                  ; 04/05/2019 - Retro DOS v4.0
  1180                                  ; 08/07/2018 - Retro DOS v3.0
  1181                                  
  1182                                  ; ---------------------------------------------------------------------------
  1183                                  ; BREAK <Process data block>
  1184                                  ; ---------------------------------------------------------------------------
  1185                                  ;**	Process data block (otherwise known as program header)
  1186                                  ;
  1187                                  
  1188                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
  1189                                  ;	can be rearranged here, ever. Reserved areas are probably safe
  1190                                  ;	for use.
  1191                                  ; ---------------------------------------------------------------------------
  1192                                  
  1193                                  FILPERPROC	EQU     20
  1194                                  
  1195                                  struc PDB	; Process_data_block
  1196 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
  1197 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
  1198 00000004 ??                                      resb 1
  1199 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
  1200 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
  1201 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
  1202 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
  1203 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
  1204 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
  1205 0000002C ????                    .ENVIRON:	resw 1		; segment address of environment
  1206 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
  1207 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
  1208 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
  1209 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
  1210 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
  1211 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
  1212 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
  1213 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
  1214 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
  1215 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
  1216 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
  1217                                  				;  an extended FCB
  1218                                  ;endstruc 	; MSDOS 3.3
  1219                                  	  	; MSDOS 6.0
  1220 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
  1221 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
  1222 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
  1223 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
  1224                                  endstruc
  1225                                  
  1226                                  ;============================================================================
  1227                                  ; EXE.INC, MSDOS 6.0, 1991
  1228                                  ;============================================================================
  1229                                  ; 04/05/2019 - Retro DOS v4.0
  1230                                  
  1231                                  ;**	EXE.INC - Definitions for the EXEC command and EXE files
  1232                                  ; ---------------------------------------------------------------------------
  1233                                  ; The following get used as arguments to the EXEC system call.  They indicate
  1234                                  ; whether or not the program is executed or whether or not a program header
  1235                                  ; gets created.
  1236                                  
  1237                                  exec_func_no_execute EQU 1	; no execute bit
  1238                                  exec_func_overlay    EQU 2	; overlay bit
  1239                                  
  1240                                  struc EXEC0
  1241 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
  1242 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
  1243 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
  1244 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
  1245                                  .size:
  1246                                  endstruc
  1247                                  
  1248                                  struc EXEC1
  1249 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
  1250 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
  1251 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
  1252 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
  1253 0000000E ????                    .SP:		resw 1		; stack pointer of program
  1254 00000010 ????                    .SS:		resw 1		; stack seg register of program
  1255 00000012 ????                    .IP:		resw 1		; entry point IP
  1256 00000014 ????                    .CS:		resw 1		; entry point CS
  1257                                  .size:
  1258                                  endstruc
  1259                                  
  1260                                  struc EXEC3
  1261 00000000 ????                    .load_addr:	resw 1		; seg address of load point
  1262 00000002 ????                    .reloc_fac:	resw 1		; relocation factor
  1263                                  endstruc
  1264                                  
  1265                                  ;**	Exit codes (in upper byte) for terminating programs
  1266                                  
  1267                                  EXIT_TERMINATE		EQU	0
  1268                                  EXIT_ABORT		EQU	0
  1269                                  EXIT_CTRL_C		EQU	1
  1270                                  EXIT_HARD_ERROR 	EQU	2
  1271                                  EXIT_KEEP_PROCESS	EQU	3
  1272                                  
  1273                                  ;**	EXE File Header Description
  1274                                  
  1275                                  struc EXE
  1276 00000000 ????                    .signature:   resw 1		; must contain 4D5A (yay zibo!)
  1277 00000002 ????                    .len_mod_512: resw 1		; low 9 bits of length
  1278 00000004 ????                    .pages:       resw 1		; number of 512b pages in file
  1279 00000006 ????                    .rle_count:   resw 1		; count of reloc entries
  1280 00000008 ????                    .par_dir:     resw 1		; number of paragraphs before image
  1281 0000000A ????                    .min_BSS:     resw 1		; minimum number of para of BSS
  1282 0000000C ????                    .max_BSS:     resw 1		; max number of para of BSS
  1283 0000000E ????                    .SS:          resw 1		; stack of image
  1284 00000010 ????                    .SP:          resw 1		; SP of image
  1285 00000012 ????                    .chksum:      resw 1		; checksum of file (ignored)
  1286 00000014 ????                    .IP:          resw 1		; IP of entry
  1287 00000016 ????                    .CS:          resw 1		; CS of entry
  1288 00000018 ????                    .rle_table:   resw 1		; byte offset of reloc table
  1289 0000001A ????                    .iov:         resw 1		; overlay number (0 for root)
  1290 0000001C ????????                .sym_tab:     resd 1		; offset of symbol table in file
  1291                                  .size:
  1292                                  endstruc
  1293                                  
  1294                                  exe_valid_signature     EQU 5A4Dh
  1295                                  exe_valid_old_signature EQU 4D5Ah
  1296                                  
  1297                                  ;**	EXE file symbol info definitions
  1298                                  
  1299                                  struc symbol_entry
  1300 00000000 ????????                .value:	resd 1
  1301 00000004 ????                    .type:	resw 1
  1302 00000006 ??                      .len:	resb 1
  1303 00000007 <res FFh>               .name:	resb 255
  1304                                  endstruc
  1305                                  
  1306                                  ;**	Data structure passed for ExecReady call
  1307                                  
  1308                                  struc ERStruc
  1309 00000000 ????                     .ER_Reserved:	resw	1	; reserved, should be zero
  1310 00000002 ????                     .ER_Flags:	resw	1
  1311 00000004 ????????                 .ER_ProgName:	resd	1	; ptr to ASCIIZ str of prog name
  1312 00000008 ????                     .ER_PSP:	resw	1	; PSP of the program
  1313 0000000A ????????                 .ER_StartAddr:	resd	1	; Start CS:IP of the program
  1314 0000000E ????????                 .ER_ProgSize:	resd	1	; Program size including PSP
  1315                                   .size:
  1316                                  endstruc
  1317                                  
  1318                                  ;** bit fields in ER_Flags
  1319                                  
  1320                                  ER_EXE		equ	0001h
  1321                                  ER_OVERLAY	equ	0002h
  1322                                  
  1323                                  
  1324                                  ;============================================================================
  1325                                  ; ARENA.INC, MSDOS 6.0, 1991
  1326                                  ;============================================================================
  1327                                  ; 24/04/2019 - Retro DOS v4.0
  1328                                  ; 04/08/2018 - Retro DOS v3.0
  1329                                  
  1330                                  ;BREAK <Memory arena structure>
  1331                                  
  1332                                  ;**	Arena Header
  1333                                  
  1334                                  struc ARENA
  1335 00000000 ??                      .SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
  1336 00000001 ????                    .OWNER:		resw 1		; owner of arena item
  1337 00000003 ????                    .SIZE:		resw 1		; size in paragraphs of item
  1338 00000005 ??????                  .RESERVED:	resb 3		; reserved
  1339 00000008 ????????????????        .NAME:		resb 8		; owner file name
  1340                                  .headersize:			
  1341                                  endstruc
  1342                                  
  1343                                  ; 20/05/2019 - Retro DOS v4.0
  1344                                  ARENAHEADERSIZE equ ARENA.headersize 
  1345                                  
  1346                                  ; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
  1347                                  ; and arena_owner_system are all equal to zero and are contained in DI.
  1348                                  ; Change them and change ALLOC.ASM.
  1349                                  
  1350                                  arena_owner_system  EQU 0               ; free block indication
  1351                                  
  1352                                  arena_signature_normal	EQU 4Dh		; valid signature, not end of arena
  1353                                  arena_signature_end     EQU 5Ah         ; valid signature, last block in arena
  1354                                  
  1355                                  FIRST_FIT	EQU	00000000B
  1356                                  BEST_FIT	EQU	00000001B
  1357                                  LAST_FIT	EQU	00000010B
  1358                                  
  1359                                  ; MSDOS 6.0
  1360                                  LOW_FIRST	EQU	00000000B	; M001
  1361                                  HIGH_FIRST	EQU	10000000B	; M001
  1362                                  HIGH_ONLY	EQU	01000000B	; M001
  1363                                  
  1364                                  LINKSTATE	EQU	00000001B	; M002
  1365                                  
  1366                                  HF_MASK		EQU	~HIGH_FIRST	; M001
  1367                                  HO_MASK		EQU	~HIGH_ONLY	; M001
  1368                                  
  1369                                  STRAT_MASK	EQU	HF_MASK & HO_MASK	; M001;
  1370                                  						; M026: used to mask of bits
  1371                                  						; M026: 6 & 7 of AllocMethod
  1372                                  
  1373                                  ;============================================================================
  1374                                  ; MI.INC, MSDOS 6.0, 1991
  1375                                  ;============================================================================
  1376                                  ; 07/07/2018 - Retro DOS v3.0
  1377                                  
  1378                                  ;BREAK <Machine instruction, flag definitions and character types>
  1379                                  
  1380                                  mi_INT		EQU	0CDh
  1381                                  mi_long_jmp	EQU	0EAh
  1382                                  mi_Long_CALL	EQU	09Ah
  1383                                  mi_Long_RET	EQU	0CBh
  1384                                  mi_Near_RET	EQU	0C3h
  1385                                  
  1386                                  ;			xxxxoditszxaxpxc
  1387                                  f_Overflow	EQU	0000100000000000B
  1388                                  f_Direction	EQU	0000010000000000B
  1389                                  f_Interrupt	EQU	0000001000000000B
  1390                                  f_Trace 	EQU	0000000100000000B
  1391                                  f_Sign		EQU	0000000010000000B
  1392                                  f_Zero		EQU	0000000001000000B
  1393                                  f_Aux		EQU	0000000000010000B
  1394                                  f_Parity	EQU	0000000000000100B
  1395                                  f_Carry 	EQU	0000000000000001B
  1396                                  
  1397                                  ;============================================================================
  1398                                  ; FILEMODE.INC, MSDOS 6.0, 1991
  1399                                  ;============================================================================
  1400                                  ; 13/07/2018 - Retro DOS v3.0
  1401                                  ; 29/04/2019 - Retro DOS v4.0
  1402                                  
  1403                                  ;**	Standard I/O file handles
  1404                                  
  1405                                  stdin       EQU     0
  1406                                  stdout      EQU     1
  1407                                  stderr      EQU     2
  1408                                  stdaux      EQU     3
  1409                                  stdprn      EQU     4
  1410                                  
  1411                                  ;**	File Modes
  1412                                  ; <Xenix subfunction assignments>  ; MSDOS 3.3 FILEMODE.INC
  1413                                  
  1414                                  open_for_read   EQU 0
  1415                                  open_for_write  EQU 1
  1416                                  open_for_both   EQU 2
  1417                                  
  1418                                  ; MSDOS 6.0
  1419                                  OPEN_FOR_BOTH	equ 2
  1420                                  EXEC_OPEN	equ 3	; access code of 3 indicates that open was 
  1421                                  				; made from exec
  1422                                  
  1423                                  access_mask	EQU 0Fh ; 09/08/2018
  1424                                  
  1425                                  SHARING_MASK	    equ 0F0h
  1426                                  SHARING_COMPAT	    equ 000h
  1427                                  SHARING_DENY_BOTH   equ 010h
  1428                                  SHARING_DENY_WRITE  equ 020h
  1429                                  SHARING_DENY_READ   equ 030h
  1430                                  SHARING_DENY_NONE   equ 040h
  1431                                  SHARING_NET_FCB     equ 070h
  1432                                  SHARING_NO_INHERIT  equ 080h
  1433                                  
  1434                                  ; 29/04/2019
  1435                                  
  1436                                  ;**	Extended Open Definitions
  1437                                  
  1438                                  RESERVED_BITS_MASK equ 0FE00h	; reserved bits for extended open flags
  1439                                  EXISTS_MASK	   equ 0Fh 	; "file exists" action field
  1440                                  NOT_EXISTS_MASK    equ 0F0h
  1441                                  
  1442                                  ;*	SF_MODE values
  1443                                  
  1444                                  AUTO_COMMIT_WRITE	equ 4000h
  1445                                  INT_24_ERROR		equ 2000h
  1446                                  
  1447                                  ;*	Flags in EXTOPEN_ON
  1448                                  
  1449                                  EXT_OPEN_ON		equ 01h
  1450                                  EXT_FILE_NOT_EXISTS	equ 04h
  1451                                  EXT_OPEN_I24_OFF	equ 02h
  1452                                  
  1453                                  ;*	Flags in EXTOPEN_FLAG
  1454                                  
  1455                                  ACTION_OPENED		equ 01h
  1456                                  ACTION_CREATED_OPENED	equ 02h
  1457                                  ACTION_REPLACED_OPENED	equ 03h
  1458                                  EXT_EXISTS_OPEN 	equ 01h
  1459                                  EXT_EXISTS_FAIL 	equ 00h
  1460                                  EXT_NEXISTS_CREATE	equ 10h
  1461                                  
  1462                                  ;**	Extended Open Structure
  1463                                  
  1464                                  struc EXT_OPEN_PARM
  1465 00000000 ????????                .SET_LIST:	resd 1
  1466 00000004 ????                    .NUM_OF_PARM:	resw 1
  1467                                  endstruc
  1468                                  
  1469                                  ;============================================================================
  1470                                  ; SYSCALL.INC, MSDOS 6.0, 1991
  1471                                  ;============================================================================
  1472                                  ; 29/04/2019 - Retro DOS v4.0
  1473                                  ; 09/07/2018 - Retro DOS v3.0 (SYSCALL.INC, MSDOS 3.3, 1987)
  1474                                  
  1475                                  ; <system call definitions>
  1476                                  
  1477                                  ABORT                           EQU 0   ;  0      0
  1478                                  STD_CON_INPUT                   EQU 1   ;  1      1
  1479                                  STD_CON_OUTPUT                  EQU 2   ;  2      2
  1480                                  STD_AUX_INPUT                   EQU 3   ;  3      3
  1481                                  STD_AUX_OUTPUT                  EQU 4   ;  4      4
  1482                                  STD_PRINTER_OUTPUT              EQU 5   ;  5      5
  1483                                  RAW_CON_IO                      EQU 6   ;  6      6
  1484                                  RAW_CON_INPUT                   EQU 7   ;  7      7
  1485                                  STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
  1486                                  STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
  1487                                  STD_CON_STRING_INPUT            EQU 10  ; 10      A
  1488                                  STD_CON_INPUT_STATUS            EQU 11  ; 11      B
  1489                                  STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
  1490                                  DISK_RESET                      EQU 13  ; 13      D
  1491                                  SET_DEFAULT_DRIVE               EQU 14  ; 14      E
  1492                                  FCB_OPEN                        EQU 15  ; 15      F
  1493                                  FCB_CLOSE                       EQU 16  ; 16     10
  1494                                  DIR_SEARCH_FIRST                EQU 17  ; 17     11
  1495                                  DIR_SEARCH_NEXT                 EQU 18  ; 18     12
  1496                                  FCB_DELETE                      EQU 19  ; 19     13
  1497                                  FCB_SEQ_READ                    EQU 20  ; 20     14
  1498                                  FCB_SEQ_WRITE                   EQU 21  ; 21     15
  1499                                  FCB_CREATE                      EQU 22  ; 22     16
  1500                                  FCB_RENAME                      EQU 23  ; 23     17
  1501                                  GET_DEFAULT_DRIVE               EQU 25  ; 25     19
  1502                                  SET_DMA                         EQU 26  ; 26     1A
  1503                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1504                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1505                                  ;                                                                          ;
  1506                                  GET_DEFAULT_DPB                 EQU 31  ; 31     1F
  1507                                  ;                                                                          ;
  1508                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1509                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1510                                  FCB_RANDOM_READ                 EQU 33  ; 33     21
  1511                                  FCB_RANDOM_WRITE                EQU 34  ; 34     22
  1512                                  GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
  1513                                  GET_FCB_POSITION                EQU 36  ; 36     24
  1514                                  SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
  1515                                  CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
  1516                                  FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
  1517                                  FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
  1518                                  PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
  1519                                  GET_DATE                        EQU 42  ; 42     2A
  1520                                  SET_DATE                        EQU 43  ; 43     2B
  1521                                  GET_TIME                        EQU 44  ; 44     2C
  1522                                  SET_TIME                        EQU 45  ; 45     2D
  1523                                  SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
  1524                                  ; Extended functionality group
  1525                                  GET_DMA                         EQU 47  ; 47     2F
  1526                                  GET_VERSION                     EQU 48  ; 48     30
  1527                                  KEEP_PROCESS                    EQU 49  ; 49     31
  1528                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1529                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1530                                  ;                                                                          ;
  1531                                  GET_DPB                         EQU 50  ; 50     32
  1532                                  ;                                                                          ;
  1533                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1534                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1535                                  SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
  1536                                  GET_INDOS_FLAG                  EQU 52  ; 52     34
  1537                                  GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
  1538                                  GET_DRIVE_FREESPACE             EQU 54  ; 54     36
  1539                                  CHAR_OPER                       EQU 55  ; 55     37
  1540                                  INTERNATIONAL                   EQU 56  ; 56     38
  1541                                  ; XENIX CALLS
  1542                                  ;   Directory Group
  1543                                  MKDIR                           EQU 57  ; 57     39
  1544                                  RMDIR                           EQU 58  ; 58     3A
  1545                                  CHDIR                           EQU 59  ; 59     3B
  1546                                  ;   File Group
  1547                                  CREAT                           EQU 60  ; 60     3C
  1548                                  OPEN                            EQU 61  ; 61     3D
  1549                                  CLOSE                           EQU 62  ; 62     3E
  1550                                  READ                            EQU 63  ; 63     3F
  1551                                  WRITE                           EQU 64  ; 64     40
  1552                                  UNLINK                          EQU 65  ; 65     41
  1553                                  LSEEK                           EQU 66  ; 66     42
  1554                                  CHMOD                           EQU 67  ; 67     43
  1555                                  IOCTL                           EQU 68  ; 68     44
  1556                                  XDUP                            EQU 69  ; 69     45
  1557                                  XDUP2                           EQU 70  ; 70     46
  1558                                  CURRENT_DIR                     EQU 71  ; 71     47
  1559                                  ;    Memory Group
  1560                                  ALLOC                           EQU 72  ; 72     48
  1561                                  DEALLOC                         EQU 73  ; 73     49
  1562                                  SETBLOCK                        EQU 74  ; 74     4A
  1563                                  ;    Process Group
  1564                                  EXEC                            EQU 75  ; 75     4B
  1565                                  EXIT                            EQU 76  ; 76     4C
  1566                                  _WAIT				EQU 77  ; 77     4D
  1567                                  FIND_FIRST                      EQU 78  ; 78     4E
  1568                                  ;   Special Group
  1569                                  FIND_NEXT                       EQU 79  ; 79     4F
  1570                                  ; SPECIAL SYSTEM GROUP
  1571                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1572                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1573                                  ;                                                                          ;
  1574                                  SET_CURRENT_PDB                 EQU 80  ; 80     50
  1575                                  GET_CURRENT_PDB                 EQU 81  ; 81     51
  1576                                  GET_IN_VARS                     EQU 82  ; 82     52
  1577                                  SETDPB                          EQU 83  ; 83     53
  1578                                  ;                                                                          ;
  1579                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1580                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1581                                  GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
  1582                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1583                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1584                                  ;                                                                          ;
  1585                                  DUP_PDB                         EQU 85  ; 85     55
  1586                                  ;                                                                          ;
  1587                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1588                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1589                                  RENAME                          EQU 86  ; 86     56
  1590                                  FILE_TIMES                      EQU 87  ; 87     57
  1591                                  ALLOCOPER			EQU 88	; 88	 58
  1592                                  ; Network extention system calls
  1593                                  GETEXTENDEDERROR		EQU 89	; 89	 59
  1594                                  CREATETEMPFILE			EQU 90	; 90	 5A
  1595                                  CREATENEWFILE			EQU 91	; 91	 5B
  1596                                  LOCKOPER			EQU 92	; 92	 5C Lock and Unlock
  1597                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1598                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1599                                  ;									   ;
  1600                                  SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
  1601                                  					;	    CloseByName, CloseUser,
  1602                                  					;	    CloseUserProcess,
  1603                                  					;	    GetOpenFileList
  1604                                  ;									   ;
  1605                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1606                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1607                                  USEROPER			EQU 94	; 94	 5E Get and Set
  1608                                  ASSINGOPER			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
  1609                                  XNAMETRANS			EQU 96	; 96	 60
  1610                                  PATHPARSE			EQU 97	; 97	 61
  1611                                  GETCURRENTPSP			EQU 98	; 98	 62
  1612                                  HONGEUL 			EQU 99	; 99	 63
  1613                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1614                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1615                                  ;									   ;
  1616                                  SET_PRINTER_FLAG		EQU 100 ; 100	 64
  1617                                  ;									   ;
  1618                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1619                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1620                                  GETEXTCNTRY			EQU 101 ; 101	 65 
  1621                                  GETSETCDPG			EQU 102 ; 102	 66
  1622                                  EXTHANDLE			EQU 103 ; 103	 67
  1623                                  COMMIT				EQU 104 ; 104	 68
  1624                                  
  1625                                  ; 29/04/2019 - Retro DOS v4.0
  1626                                  ; (MSDOS 6.0, SYSCALL.INC, 1987)
  1627                                  
  1628                                  GetSetMediaID			EQU 105 ; 105	 69
  1629                                  IFS_IOCTL			EQU 107 ; 107	 6B
  1630                                  ExtOpen 			EQU 108 ; 108	 6C
  1631                                  
  1632                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1633                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1634                                  ;                                                                          ;
  1635                                  ;ifdef ROMEXEC
  1636                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
  1637                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
  1638                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
  1639                                  ;endif
  1640                                  ;                                                                          ;
  1641                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1642                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1643                                  
  1644                                  SET_OEM_HANDLER			EQU 248 ; 248    F8
  1645                                  ;OEM_C1				EQU 249 ; 249    F9
  1646                                  ;OEM_C2				EQU 250 ; 250    FA
  1647                                  ;OEM_C3				EQU 251 ; 251    FB
  1648                                  ;OEM_C4				EQU 252 ; 252    FC
  1649                                  ;OEM_C5				EQU 253 ; 253    FD
  1650                                  ;OEM_C6				EQU 254 ; 254    FE
  1651                                  ;OEM_C7				EQU 255 ; 255    FF
  1652                                  
  1653                                  ; 01/01/2024 - Retro DOS v5.0 - PCDOS 7.1 IBMDOS.COM
  1654                                  ; (PCDOS 7.1 extension to MSDOS 6.22 system calls)
  1655                                   
  1656                                  ExtCountryInfo 			equ 112	; 70h
  1657                                  LONGNAME			equ 113	; 71h
  1658                                  LFNFINDCLOSE			equ 114 ; 72h
  1659                                  FAT32EXT			equ 115	; 73h
  1660                                  
  1661                                  ;============================================================================
  1662                                  ; VERSIONA.INC (MSDOS 6.0, 1991)
  1663                                  ;============================================================================
  1664                                  ; 24/04/2019 - Retro DOS 4.0
  1665                                  
  1666                                  ;MAJOR_VERSION	EQU     6
  1667                                  ;;MINOR_VERSION	EQU	00
  1668                                  ;MINOR_VERSION	EQU     21  ; MSDOS 6.21
  1669                                  
  1670                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  1671                                  ;MAJOR_VERSION	EQU     5
  1672                                  ;MINOR_VERSION	EQU     0
  1673                                  
  1674                                  ; 30/12/2022 - Retro DOS v4.2
  1675                                  ;MAJOR_VERSION	EQU     6
  1676                                  ;MINOR_VERSION	EQU     22
  1677                                  
  1678                                  ; 01/01/2024 - Retro DOS v5.0
  1679                                  MAJOR_VERSION	EQU     7
  1680                                  MINOR_VERSION	EQU     10  ; PCDOS 7.1	(7.10)
  1681                                  
  1682                                  ;============================================================================
  1683                                  ; INTNAT.INC, MSDOS 3.3, 1987
  1684                                  ;============================================================================
  1685                                  ; 09/07/2018 - Retro DOS 3.0
  1686                                  
  1687                                  ; Current structure of the data returned by the international call
  1688                                  
  1689                                  struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  1690                                  .Date_tim_format:
  1691 00000000 ????                    		RESW 1		; 0-USA, 1-EUR, 2-JAP
  1692                                  .Currency_sym:
  1693 00000002 ??????????              		RESB 5		; Currency Symbol 5 bytes
  1694                                  .Thous_sep:
  1695 00000007 ????                    		RESB 2		; Thousands separator 2 bytes
  1696                                  .Decimal_sep:
  1697 00000009 ????                    		RESB 2		; Decimal separator 2 bytes
  1698                                  .Date_sep:
  1699 0000000B ????                    		RESB 2		; Date separator 2 bytes
  1700                                  .Time_sep:
  1701 0000000D ????                    		RESB 2		; Time separator 2 bytes
  1702                                  .Bit_field:	
  1703 0000000F ??                      		RESB 1		; Bit values
  1704                                                                     ;   Bit 0 = 0 if currency symbol first
  1705                                                                     ;         = 1 if currency symbol last
  1706                                                                     ;   Bit 1 = 0 if No space after currency symbol
  1707                                                                     ;         = 1 if space after currency symbol
  1708                                  .Currency_cents:
  1709 00000010 ??                      		RESB 	1	; Number of places after currency dec point
  1710                                  .Time_24:
  1711 00000011 ??                      		RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
  1712                                  .Map_call:
  1713 00000012 ????                    		RESW	1	; Address of case mapping call (DWORD)
  1714 00000014 ????                                    RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
  1715                                  				;  in pieces.
  1716                                  .Data_sep:
  1717 00000016 ????                    		RESB	2	; Data list separator character
  1718                                  .size:		
  1719                                  endstruc
  1720                                  
  1721                                  ; Max size of the block returned by the INTERNATIONAL call
  1722                                  
  1723                                  internat_block_max	EQU	32
  1724                                  
  1725                                  ;============================================================================
  1726                                  ; SYSVAR.INC (MSDOS 6.0, 1991)
  1727                                  ;============================================================================
  1728                                  ; 08/07/2018 - Retro DOS v3.0
  1729                                  
  1730                                  ; 01/01/2024 - Retro DOS v5.0
  1731                                  
  1732                                  ;SysInitVars STRUC
  1733                                  struc SYSI
  1734 00000000 ????????                .DPB:	    resd 1	; 0	; DPB chain
  1735 00000004 ????????                .SFT:	    resd 1	; 4	; SFT chain
  1736 00000008 ????????                .CLOCK:	    resd 1	; 8	; CLOCK device
  1737 0000000C ????????                .CON:	    resd 1	; 12	; CON device
  1738 00000010 ????                    .MAXSEC:    resw 1	; 16	; maximum sector size
  1739 00000012 ????????                .BUF:	    resd 1	; 18	; points to Hashinitvar
  1740 00000016 ????????                .CDS:	    resd 1	; 22	; CDS list
  1741 0000001A ????????                .FCB:	    resd 1	; 26	; FCB chain
  1742 0000001E ????                    .Keep:	    resw 1	; 30	; keep count
  1743 00000020 ??                      .NUMIO:	    resb 1	; 32	; Number of block devices
  1744 00000021 ??                      .NCDS:	    resb 1	; 33	; number of CDS's
  1745 00000022 ????????                .DEV:	    resd 1	; 34	; device list
  1746                                  ; 09/07/2018
  1747                                  ; Above parameters are described in MSDOS 3.3 SYSVAR.INC (85/04/10)
  1748                                  ; Following parameters are used with MSDOS 6.0 (Retro DOS v4.0)
  1749 00000026 ????                    .ATTR:	    resw 1	; 38	; null device attribute word
  1750 00000028 ????                    .STRAT:	    resw 1	; 40	; null device strategy entry point
  1751 0000002A ????                    .INTER:	    resw 1	; 42	; null device interrupt entry point
  1752 0000002C ????????????????        .NAME:	    resb 8	; 44	; null device name
  1753 00000034 ??                      .SPLICE:    resb 1	; 52	; TRUE -> splicees being done
  1754 00000035 ????                    .IBMDOS_SIZE: resw 1	; 53 	; DOS size in paragraphs
  1755 00000037 ????????                .IFS_DOSCALL@: resd 1	; 55	; IFS DOS service routine entry
  1756 0000003B ????????                .IFS:	    resd 1	; 59	; IFS header chain
  1757 0000003F ????????                .BUFFERS:   resw 2	; 63	; BUFFERS= values (m,n)
  1758 00000043 ??                      .BOOT_DRIVE: resb 1	; 67	; boot drive A=1 B=2,..
  1759 00000044 ??                      .DWMOVE:    resb 1	; 68	; 1 if 386 machine
  1760 00000045 ????                    .EXT_MEM:   resw 1	; 69	; Extended memory size in KB.
  1761                                  endstruc
  1762                                  ;SysInitVars ENDS
  1763                                  
  1764                                  ;This is added for more information exchange between DOS, BIOS.
  1765                                  ;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86
  1766                                  
  1767                                  ;SysInitVars_Ext struc
  1768                                  struc SYSI_EXT
  1769 00000000 ????????                .SysInitVars:	resd 1		; Points to the above structure.
  1770 00000004 ????????                .Country_Tab:	resd 1		; DOS_Country_cdpg_info
  1771                                  endstruc
  1772                                  ;SysInitVars_Ext ends
  1773                                  
  1774                                  ;============================================================================
  1775                                  ; IOCTL.INC - MSDOS 6.0 - 1991
  1776                                  ;============================================================================
  1777                                  ; 09/07/2018 - Retro DOS v3.0
  1778                                  
  1779                                  ;*** J.K.
  1780                                  ;General Guide -
  1781                                  ;Category Code:
  1782                                  ; 0... .... DOS Defined
  1783                                  ; 1... .... User defined
  1784                                  ; .xxx xxxx Code
  1785                                  
  1786                                  ;Function Code:
  1787                                  ; 0... .... Return error if unsupported
  1788                                  ; 1... .... Ignore if unsupported
  1789                                  ; .0.. .... Intercepted by DOS
  1790                                  ; .1.. .... Passed to driver
  1791                                  ; ..0. .... Sends data/commands to device
  1792                                  ; ..1. .... Quries data/info from device
  1793                                  ; ...x .... Subfunction
  1794                                  ;
  1795                                  ; Note that "Sends/queries" data bit is intended only to regularize the
  1796                                  ; function set.  It plays no critical role; some functions may contain both
  1797                                  ; command and query elements. The convention is that such commands are
  1798                                  ; defined as "sends data".
  1799                                  
  1800                                  ;*****************************;*
  1801                                  ; BLOCK DRIVERS 	      ;*
  1802                                  ;*****************************;*
  1803                                  
  1804                                  ; IOCTL SUB-FUNCTIONS
  1805                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1806                                  IOCTL_GET_DEVICE_INFO	EQU	0
  1807                                  IOCTL_SET_DEVICE_INFO	EQU	1
  1808                                  IOCTL_READ_HANDLE	EQU	2
  1809                                  IOCTL_WRITE_HANDLE	EQU	3
  1810                                  IOCTL_READ_DRIVE	EQU	4
  1811                                  IOCTL_WRITE_DRIVE	EQU	5
  1812                                  IOCTL_GET_INPUT_STATUS	EQU	6
  1813                                  IOCTL_GET_OUTPUT_STATUS EQU	7
  1814                                  IOCTL_CHANGEABLE?	EQU	8
  1815                                  IOCTL_DeviceLocOrRem?	EQU	9
  1816                                  IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
  1817                                  IOCTL_SHARING_RETRY	EQU	0Bh   ;11
  1818                                  GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
  1819                                  GENERIC_IOCTL		EQU	0Dh   ;13
  1820                                  ; (MSDOS 6.0 + MSDOS 3.3)
  1821                                  IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
  1822                                  IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
  1823                                  ; (MSDOS 6.0)
  1824                                  IOCTL_QUERY_HANDLE	EQU	10h   ;16
  1825                                  IOCTL_QUERY_BLOCK	EQU	11h   ;17
  1826                                  
  1827                                  ; GENERIC IOCTL CATEGORY CODES
  1828                                  IOC_OTHER		EQU	0	; Other device control J.K. 4/29/86
  1829                                  IOC_SE			EQU	1	; SERIAL DEVICE CONTROL
  1830                                  IOC_TC			EQU	2	; TERMINAL CONTROL
  1831                                  IOC_SC			EQU	3	; SCREEN CONTROL
  1832                                  IOC_KC			EQU	4	; KEYBOARD CONTROL
  1833                                  IOC_PC			EQU	5	; PRINTER CONTROL
  1834                                  IOC_DC			EQU	8	; DISK CONTROL (SAME AS RAWIO)
  1835                                  
  1836                                  ; GENERIC IOCTL SUB-FUNCTIONS
  1837                                  RAWIO			EQU	8
  1838                                  
  1839                                  ; RAWIO SUB-FUNCTIONS
  1840                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1841                                  GET_DEVICE_PARAMETERS	EQU	60H
  1842                                  SET_DEVICE_PARAMETERS	EQU	40H
  1843                                  READ_TRACK		EQU	61H
  1844                                  WRITE_TRACK		EQU	41H
  1845                                  VERIFY_TRACK		EQU	62H
  1846                                  FORMAT_TRACK		EQU	42H
  1847                                  ; (MSDOS 6.0)
  1848                                  GET_MEDIA_ID		EQU	66h	;AN000;AN003;changed from 63h
  1849                                  SET_MEDIA_ID		EQU	46h	;AN000;AN003;changed from 43h
  1850                                  GET_ACCESS_FLAG 	EQU	67h	;AN002;AN003;Unpublished function.Changed from 64h
  1851                                  SET_ACCESS_FLAG 	EQU	47h	;AN002;AN003;Unpublished function.Changed from 44h
  1852                                  SENSE_MEDIA_TYPE	EQU	68H	;Added for 5.00
  1853                                  
  1854                                  ; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
  1855                                  BUILD_DEVICE_BPB	EQU	000000001B
  1856                                  
  1857                                  ; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
  1858                                  INSTALL_FAKE_BPB	EQU	000000001B
  1859                                  ONLY_SET_TRACKLAYOUT	EQU	000000010B
  1860                                  TRACKLAYOUT_IS_GOOD	EQU	000000100B
  1861                                  
  1862                                  ; SPECIAL FUNCTION FOR FORMAT TRACK
  1863                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1864                                  STATUS_FOR_FORMAT	EQU	000000001B
  1865                                  ; (MSDOS 6.0)
  1866                                  DO_FAST_FORMAT		EQU	000000010B ;AN001;
  1867                                  
  1868                                  ; CODES RETURNED FROM FORMAT STATUS CALL
  1869                                  FORMAT_NO_ROM_SUPPORT	EQU	000000001B
  1870                                  FORMAT_COMB_NOT_SUPPORTED EQU	000000010B
  1871                                  
  1872                                  ; DEVICETYPE VALUES
  1873                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1874                                  MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
  1875                                  DEV_5INCH		EQU	0
  1876                                  DEV_5INCH96TPI		EQU	1
  1877                                  DEV_3INCH720KB		EQU	2
  1878                                  DEV_8INCHSS		EQU	3
  1879                                  DEV_8INCHDS		EQU	4
  1880                                  DEV_HARDDISK		EQU	5
  1881                                  DEV_OTHER		EQU	7
  1882                                  ; (MSDOS 6.0)
  1883                                  ;DEV_3INCH1440KB	EQU	7
  1884                                  DEV_3INCH2880KB		EQU	9
  1885                                  ; Retro DOS v2.0 - 26/03/2018
  1886                                  ;;DEV_TAPE		EQU	6
  1887                                  ;;DEV_ERIMO		EQU	8
  1888                                  ;DEV_3INCH2880KB	EQU	9
  1889                                  DEV_3INCH1440KB		EQU	10
  1890                                  
  1891                                  ; (MSDOS 3.3)
  1892                                  ;MAX_DEV_TYPE		EQU	7
  1893                                  
  1894                                  ; (MSDOS 6.0)
  1895                                  MAX_DEV_TYPE		EQU	10	; MAXIMUM DEVICE TYPE THAT WE
  1896                                  					; CURRENTLY SUPPORT.
  1897                                  struc A_SECTORTABLE
  1898 00000000 ????                    .ST_SECTORNUMBER:	resw	1
  1899 00000002 ????                    .ST_SECTORSIZE:		resw	1
  1900                                  .size:
  1901                                  endstruc
  1902                                  
  1903                                  ;============================================================================
  1904                                  ; DEVSYM.INC
  1905                                  ;============================================================================
  1906                                  ; 07/07/2018 - Retro DOS v3.0
  1907                                  ; 30/04/2019 - Retro DOS v4.0 (DEVSYM.INC, MSDOS 6.0, 1991)
  1908                                  
  1909                                  ;**	DevSym.inc - Device Symbols
  1910                                  
  1911                                  ; The device table list has the form:
  1912                                  struc	SYSDEV
  1913 00000000 ????????                .NEXT:		resd 1		;Pointer to next device header
  1914 00000004 ????                    .ATT:		resw 1		;Attributes of the device
  1915 00000006 ????                    .STRAT:		resw 1		;Strategy entry point
  1916 00000008 ????                    .INT:		resw 1		;Interrupt entry point
  1917 0000000A ????????????????        .NAME:		resb 8		;Name of device (only first byte used for block)
  1918                                  .size:
  1919                                  endstruc
  1920                                  
  1921                                  ;
  1922                                  ; ATTRIBUTE BIT MASKS
  1923                                  ;
  1924                                  ; CHARACTER DEVICES:
  1925                                  ;
  1926                                  ; BIT 15 -> MUST BE 1
  1927                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1928                                  ;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
  1929                                  ;     12 -> UNUSED
  1930                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
  1931                                  ;     10 -> MUST BE 0
  1932                                  ;      9 -> MUST BE 0
  1933                                  ;      8 -> UNUSED
  1934                                  ;      7 -> UNUSED
  1935                                  ;      6 -> UNUSED
  1936                                  ;      5 -> UNUSED
  1937                                  ;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
  1938                                  ;      3 -> 1 IF DEVICE IS CLOCK DEVICE
  1939                                  ;      2 -> 1 IF DEVICE IS NULL DEVICE
  1940                                  ;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
  1941                                  ;      0 -> 1 IF DEVICE IS CONSOLE INPUT
  1942                                  ;
  1943                                  ; BLOCK DEVICES:
  1944                                  ;
  1945                                  ; BIT 15 -> MUST BE 0
  1946                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1947                                  ;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
  1948                                  ;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
  1949                                  ;	    THE SAME PLACE.
  1950                                  ;     12 -> UNUSED
  1951                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
  1952                                  ;     10 -> MUST BE 0
  1953                                  ;      9 -> MUST BE 0
  1954                                  ;      8 -> UNUSED
  1955                                  ;      7 -> UNUSED
  1956                                  ;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
  1957                                  ;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
  1958                                  ;      5 -> UNUSED
  1959                                  ;      4 -> UNUSED
  1960                                  ;      3 -> UNUSED
  1961                                  ;      2 -> UNUSED
  1962                                  ;      1 -> UNUSED
  1963                                  ;      0 -> UNUSED
  1964                                  ;
  1965                                  
  1966                                  ;Attribute bit masks
  1967                                  DEVTYP	EQU     8000H           ;Bit 15 - 1 if Char, 0 if block
  1968                                  DEVIOCTL EQU    4000H           ;Bit 14 - CONTROL mode bit
  1969                                  ISFATBYDEV EQU  2000H           ;Bit 13 - Device uses FAT ID bytes, comp media.
  1970                                  
  1971                                  ; 09/07/2018 - Retro DOS (DEVSYM.INC, MSDOS 3.3, 1987) 
  1972                                  
  1973                                  OUTTILBUSY EQU	2000H		; OUTPUT UNTIL BUSY IS ENABLED
  1974                                  ISNET	   EQU	1000H		; BIT 12 - 1 IF A NET DEVICE, 0 IF
  1975                                  				;  NOT.  CURRENTLY BLOCK ONLY.
  1976                                  DEVOPCL    EQU	0800H		; BIT 11 - 1 IF THIS DEVICE HAS
  1977                                  				;  OPEN,CLOSE AND REMOVABLE MEDIA
  1978                                  				;  ENTRY POINTS, 0 IF NOT
  1979                                  
  1980                                  EXTENTBIT  EQU	0400H		; BIT 10 - CURRENTLY 0 ON ALL DEVS
  1981                                  				;  THIS BIT IS RESERVED FOR FUTURE USE
  1982                                  				;  TO EXTEND THE DEVICE HEADER BEYOND
  1983                                  				;  ITS CURRENT FORM.
  1984                                  
  1985                                  ; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
  1986                                  ;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
  1987                                  ;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
  1988                                  ;    MACHINES (FORMAT,CHKDSK,RECOVER,..).
  1989                                  
  1990                                  IOQUERY	EQU	0080H		;Bit 7 - Supports generic IOCtl query
  1991                                  
  1992                                  DEV320	EQU	0040H		;BIT 6 - FOR BLOCK DEVICES, THIS
  1993                                  				;DEVICE SUPPORTS SET/GET MAP OF
  1994                                  				;LOGICAL DRIVES, AND SUPPORTS
  1995                                  				;GENERIC IOCTL CALLS.
  1996                                  				;FOR CHARACTER DEVICES, THIS
  1997                                  				;DEVICE SUPPORTS GENERIC IOCTL.
  1998                                  				;THIS IS A DOS 3.2 DEVICE DRIVER.
  1999                                  
  2000                                  ISSPEC	EQU     0010H		;Bit 4 - This device is special ; 15/03/2018
  2001                                  ;ISIBM	EQU     0010H		;Bit 4 - This device is special
  2002                                  ISCLOCK EQU     0008H           ;Bit 3 - This device is the clock device.
  2003                                  ISNULL  EQU     0004H           ;Bit 2 - This device is the null device.
  2004                                  ISCOUT  EQU     0002H           ;Bit 1 - This device is the console output.
  2005                                  ISCIN   EQU     0001H           ;Bit 0 - This device is the console input.
  2006                                  
  2007                                  EXTDRVR	EQU	0002h		;BIT 1 - BLOCK DEVICE EXTENDED DRIVER
  2008                                  				; (MSDOS 6.0, DEVSYM.INC, 1991) ; 30/04/2019
  2009                                  
  2010                                  ;Static Reguest Header
  2011                                  struc	SRHEAD
  2012 00000000 ??                      .REQLEN:	resb 1		;Length in bytes of request block
  2013 00000001 ??                      .REQUNIT:	resb 1		;Device unit number
  2014 00000002 ??                      .REQFUNC:	resb 1		;Type of request
  2015 00000003 ????                    .REQSTAT:	resw 1		;Status Word
  2016 00000005 ????????????????                	resb 8		;Reserved for queue links
  2017                                  .size:
  2018                                  endstruc
  2019                                  
  2020                                  ;Status word masks
  2021                                  STERR   EQU     8000H           ;Bit 15 - Error
  2022                                  STBUI   EQU     0200H           ;Bit 9 - Buisy
  2023                                  STDON   EQU     0100H           ;Bit 8 - Done
  2024                                  STECODE EQU     00FFH           ;Error code
  2025                                  WRECODE EQU     0
  2026                                  
  2027                                  ;Function codes
  2028                                  DINITHL EQU     26              ;Size of init header
  2029                                  DMEDHL  EQU     15              ;Size of media check header
  2030                                  DBPBHL  EQU     22              ;Size of Get BPB header
  2031                                  DRDWRHL EQU     22              ;Size of RD/WR header
  2032                                  DRDNDHL EQU     14              ;Size of non destructive read header
  2033                                  DSTATHL EQU     13              ;Size of status header
  2034                                  DFLSHL  EQU     15              ;Size of flush header
  2035                                  
  2036                                  DEVINIT EQU     0               ;Initialization
  2037                                  DEVMDCH EQU     1               ;Media check
  2038                                  DEVBPB  EQU     2               ;Get BPB
  2039                                  DEVRDIOCTL EQU  3               ;IOCTL read
  2040                                  DEVRD   EQU     4               ;Read
  2041                                  DEVRDND EQU     5               ;Non destructive read no wait (character devs)
  2042                                  DEVIST  EQU     6               ;Input status
  2043                                  DEVIFL  EQU     7               ;Input flush
  2044                                  DEVWRT  EQU     8               ;Write
  2045                                  DEVWRTV EQU     9               ;Write with verify
  2046                                  DEVOST  EQU     10              ;Output status
  2047                                  DEVOFL  EQU     11              ;Output flush
  2048                                  DEVWRIOCTL EQU  12              ;IOCTL write
  2049                                  
  2050                                  ; 09/07/2018 - Retro DOS v3.0 (DEVSYM.INC, MSDOS 3.3, 1987) 
  2051                                  DEVOPN	EQU	13		;DEVICE OPEN
  2052                                  DEVCLS	EQU	14		;DEVICE CLOSE
  2053                                  DOPCLHL EQU	13		;SIZE OF OPEN/CLOSE HEADER
  2054                                  DEVRMD	EQU	15		;REMOVABLE MEDIA
  2055                                  ; 07/08/2018 - Retro DOS v3.0
  2056                                  REMHL	EQU	13		;SIZE OF REMOVABLE MEDIA HEADER
  2057                                  GENIOCTL EQU	19
  2058                                  
  2059                                  ; THE NEXT THREE ARE USED IN DOS 4.0
  2060                                  ;		     20
  2061                                  ;		     21
  2062                                  ;		     22
  2063                                  
  2064                                  DEVGETOWN      EQU   23		;GET DEVICE OWNER
  2065                                  DEVSETOWN      EQU   24		;SET DEVICE OWNER
  2066                                  ; 18/05/2019 - Retro DOS v4.0
  2067                                  IOCTL_QUERY    EQU   25		;Query generic ioctl support
  2068                                  
  2069                                  OWNHL	       EQU   13		;SIZE OF DEVICE OWNER HEADER
  2070                                  
  2071                                  DEVOUT	       EQU   16		; OUTPUT UNTIL BUSY.
  2072                                  DEVOUTL        EQU   DEVWRT	; LENGTH OF OUTPUT UNTIL BUSY
  2073                                  
  2074                                  ; ADDED FOR DOS 5.00
  2075                                  
  2076                                  ; GENERIC IOCTL REQUEST STRUCTURE
  2077                                  ;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
  2078                                  
  2079                                  struc IOCTL_REQ
  2080 00000000 <res Dh>                .SRHEAD:	resb SRHEAD.size
  2081                                  				; GENERIC IOCTL ADDITION.
  2082 0000000D ??                      .MAJORFUNCTION: resb 1		;FUNCTION CODE
  2083 0000000E ??                      .MINORFUNCTION: resb 1		;FUNCTION CATEGORY
  2084 0000000F ????                    .REG_SI:	resw 1
  2085 00000011 ????                    .REG_DI:	resw 1
  2086 00000013 ????????                .GENERICIOCTL_PACKET: resd 1	; POINTER TO DATA BUFFER
  2087                                  .size: ; 07/08/2018
  2088                                  endstruc
  2089                                  
  2090                                  ; DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
  2091                                  GEN_IOCTL_WRT_TRK EQU	40H
  2092                                  GEN_IOCTL_RD_TRK  EQU	60H
  2093                                  GEN_IOCTL_FN_TST  EQU	20H	; USED TO DIFF. BET READS AND WRTS
  2094                                  
  2095                                  ;; 32-bit absolute read/write input list structure
  2096                                  
  2097                                  struc ABS_32RW
  2098 00000000 ????????                .SECTOR_RBA:	resd 1		; relative block address
  2099 00000004 ????                    .ABS_RW_COUNT:	resw 1		; number of sectors to be transferred
  2100 00000006 ????????                .BUFFER_ADDR:	resd 1		; data addrress
  2101                                  .size:
  2102                                  endstruc
  2103                                  
  2104                                  ;; media ID info
  2105                                  
  2106                                  struc MEDIA_ID_INFO
  2107 00000000 ????                    .MEDIA_level:	resw	1	; info level
  2108 00000002 ????????                .MEDIA_Serial:	resd	1	; serial #
  2109 00000006 <res Bh>                .MEDIA_Label:	resb	11	; volume label
  2110 00000011 ????????????????        .MEDIA_System:	resb	8	; system type
  2111                                  .size:
  2112                                  endstruc
  2113                                  
  2114                                  ; equates for DOS34_FLAG
  2115                                  ; (BUGBUG: why are bits 0,1,3 and 4 not defined.)
  2116                                  
  2117                                  FROM_DISK_RESET       EQU   000000000100b   ;from disk reset
  2118                                  Force_I24_Fail	      EQU   000000100000b   ;form IFS CALL BACK
  2119                                  Disable_EOF_I24       EQU   000001000000b   ;disable EOF int24 for input status
  2120                                  DBCS_VOLID	      EQU   000010000000b   ;indicate from volume id
  2121                                  DBCS_VOLID2	      EQU   000100000000b   ;indicate 8th char is DBCS
  2122                                  CTRL_BREAK_FLAG       EQU   001000000000b   ;indicate control break is input
  2123                                  SEARCH_FASTOPEN       EQU   010000000000b   ;set fastopen flag for search
  2124                                  EXEC_AWARE_REDIR      EQU   100000000000b   ;M018: this bit is set by a redir 
  2125                                  					    ;M018: that knows how to handle 
  2126                                  					    ;M018: open for exec
  2127                                  
  2128                                  NO_FROM_DISK_RESET    EQU   ~FROM_DISK_RESET	;not from disk reset
  2129                                  NO_Force_I24_Fail     EQU   ~Force_I24_Fail	;not form IFS CALL BACK
  2130                                  NO_Disable_EOF_I24    EQU   ~Disable_EOF_I24
  2131                                  
  2132                                  ;============================================================================
  2133                                  ; ERROR.INC (MSDOS 6.0, 1991)
  2134                                  ;============================================================================
  2135                                  ; 16/07/2018 - Retro DOS v3.0 
  2136                                  
  2137                                  ;**	ERROR.INC - DOS Error Codes
  2138                                  ;
  2139                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
  2140                                  ;    return error codes through AX. If an error occurred then
  2141                                  ;    the carry bit will be set and the error code is in AX. If no error
  2142                                  ;    occurred then the carry bit is reset and AX contains returned info.
  2143                                  ;
  2144                                  ;    Since the set of error codes is being extended as we extend the operating
  2145                                  ;    system, we have provided a means for applications to ask the system for a
  2146                                  ;    recommended course of action when they receive an error.
  2147                                  ;
  2148                                  ;    The GetExtendedError system call returns a universal error, an error
  2149                                  ;    location and a recommended course of action. The universal error code is
  2150                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
  2151                                  ;    is issued.
  2152                                  
  2153                                  ;	2.0 error codes
  2154                                  
  2155                                  error_invalid_function		EQU	1
  2156                                  error_file_not_found		EQU	2
  2157                                  error_path_not_found		EQU	3
  2158                                  error_too_many_open_files	EQU	4
  2159                                  error_access_denied		EQU	5
  2160                                  error_invalid_handle		EQU	6
  2161                                  error_arena_trashed		EQU	7
  2162                                  error_not_enough_memory 	EQU	8
  2163                                  error_invalid_block		EQU	9
  2164                                  error_bad_environment		EQU	10
  2165                                  error_bad_format		EQU	11
  2166                                  error_invalid_access		EQU	12
  2167                                  error_invalid_data		EQU	13
  2168                                  ;**** reserved			EQU	14	; *****
  2169                                  error_invalid_drive		EQU	15
  2170                                  error_current_directory 	EQU	16
  2171                                  error_not_same_device		EQU	17
  2172                                  error_no_more_files		EQU	18
  2173                                  
  2174                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
  2175                                  
  2176                                  error_write_protect		EQU	19
  2177                                  error_bad_unit			EQU	20
  2178                                  error_not_ready 		EQU	21
  2179                                  error_bad_command		EQU	22
  2180                                  error_CRC			EQU	23
  2181                                  error_bad_length		EQU	24
  2182                                  error_seek			EQU	25
  2183                                  error_not_DOS_disk		EQU	26
  2184                                  error_sector_not_found		EQU	27
  2185                                  error_out_of_paper		EQU	28
  2186                                  error_write_fault		EQU	29
  2187                                  error_read_fault		EQU	30
  2188                                  error_gen_failure		EQU	31
  2189                                  
  2190                                  ;	the new 3.0 error codes reported through INT 24
  2191                                  
  2192                                  error_sharing_violation 	EQU	32
  2193                                  error_lock_violation		EQU	33
  2194                                  error_wrong_disk		EQU	34
  2195                                  error_FCB_unavailable		EQU	35
  2196                                  error_sharing_buffer_exceeded	EQU	36
  2197                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00  ;AN000;
  2198                                  error_handle_EOF		EQU	38    ; DOS 4.00  ;AN000;
  2199                                  error_handle_Disk_Full		EQU	39    ; DOS 4.00  ;AN000;
  2200                                  
  2201                                  ;	New OEM network-related errors are 50-79
  2202                                  
  2203                                  error_not_supported		EQU	50
  2204                                  
  2205                                  error_net_access_denied		EQU	65	;M028
  2206                                  
  2207                                  ;	End of INT 24 reportable errors
  2208                                  
  2209                                  error_file_exists		EQU	80
  2210                                  error_DUP_FCB			EQU	81	; *****
  2211                                  error_cannot_make		EQU	82
  2212                                  error_FAIL_I24			EQU	83
  2213                                  
  2214                                  ;	New 3.0 network related error codes
  2215                                  
  2216                                  error_out_of_structures 	EQU	84
  2217                                  error_already_assigned		EQU	85
  2218                                  error_invalid_password		EQU	86
  2219                                  error_invalid_parameter 	EQU	87
  2220                                  error_NET_write_fault		EQU	88
  2221                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00  ;AN000;
  2222                                  
  2223                                  ;	BREAK <Interrupt 24 error codes>
  2224                                  
  2225                                  ;**	Int24 Error Codes
  2226                                  
  2227                                  error_I24_write_protect 	EQU	0
  2228                                  error_I24_bad_unit		EQU	1
  2229                                  error_I24_not_ready		EQU	2
  2230                                  error_I24_bad_command		EQU	3
  2231                                  error_I24_CRC			EQU	4
  2232                                  error_I24_bad_length		EQU	5
  2233                                  error_I24_Seek			EQU	6
  2234                                  error_I24_not_DOS_disk		EQU	7
  2235                                  error_I24_sector_not_found	EQU	8
  2236                                  error_I24_out_of_paper		EQU	9
  2237                                  error_I24_write_fault		EQU	0Ah
  2238                                  error_I24_read_fault		EQU	0Bh
  2239                                  error_I24_gen_failure		EQU	0Ch
  2240                                  ; NOTE: Code 0DH is used by MT-DOS.
  2241                                  error_I24_wrong_disk		EQU	0Fh
  2242                                  
  2243                                  ;	THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24
  2244                                  ;
  2245                                  ;	NOTE: ABORT is ALWAYS allowed
  2246                                  
  2247                                  Allowed_FAIL			EQU	00001000B
  2248                                  Allowed_RETRY			EQU	00010000B
  2249                                  Allowed_IGNORE			EQU	00100000B
  2250                                  
  2251                                  I24_operation			EQU	00000001B  ;Z if READ,NZ if Write
  2252                                  I24_area			EQU	00000110B  ; 00 if DOS
  2253                                  						   ; 01 if FAT
  2254                                  						   ; 10 if root DIR
  2255                                  						   ; 11 if DATA
  2256                                  I24_class			EQU	10000000B  ;Z if DISK, NZ if FAT or char
  2257                                  
  2258                                  ;	BREAK <GetExtendedError CLASSes ACTIONs LOCUSs>
  2259                                  
  2260                                  ;**	The GetExtendedError call takes an error code and returns CLASS,
  2261                                  ;	ACTION and LOCUS codes to help programs determine the proper action
  2262                                  ;	to take for error codes that they don't explicitly understand.
  2263                                  
  2264                                  ;	Values for error CLASS
  2265                                  
  2266                                  errCLASS_OutRes 	EQU	1	; Out of Resource
  2267                                  errCLASS_TempSit	EQU	2	; Temporary Situation
  2268                                  errCLASS_Auth		EQU	3	; Permission problem
  2269                                  errCLASS_Intrn		EQU	4	; Internal System Error
  2270                                  errCLASS_HrdFail	EQU	5	; Hardware Failure
  2271                                  errCLASS_SysFail	EQU	6	; System Failure
  2272                                  errCLASS_Apperr 	EQU	7	; Application Error
  2273                                  errCLASS_NotFnd 	EQU	8	; Not Found
  2274                                  errCLASS_BadFmt 	EQU	9	; Bad Format
  2275                                  errCLASS_Locked 	EQU	10	; Locked
  2276                                  errCLASS_Media		EQU	11	; Media Failure
  2277                                  errCLASS_Already	EQU	12	; Collision with Existing Item
  2278                                  errCLASS_Unk		EQU	13	; Unknown/other
  2279                                  
  2280                                  ;	Values for error ACTION
  2281                                  
  2282                                  errACT_Retry		EQU	1	; Retry
  2283                                  errACT_DlyRet		EQU	2	; Delay Retry, retry after pause
  2284                                  errACT_User		EQU	3	; Ask user to regive info
  2285                                  errACT_Abort		EQU	4	; abort with clean up
  2286                                  errACT_Panic		EQU	5	; abort immediately
  2287                                  errACT_Ignore		EQU	6	; ignore
  2288                                  errACT_IntRet		EQU	7	; Retry after User Intervention
  2289                                  
  2290                                  ;	Values for error LOCUS
  2291                                  
  2292                                  errLOC_Unk		EQU	1	; No appropriate value
  2293                                  errLOC_Disk		EQU	2	; Random Access Mass Storage
  2294                                  errLOC_Net		EQU	3	; Network
  2295                                  errLOC_SerDev		EQU	4	; Serial Device
  2296                                  errLOC_Mem		EQU	5	; Memory
  2297                                  
  2298                                  ;============================================================================
  2299                                  ; INT2A.INC (MSDOS 6.0, 1991)
  2300                                  ;============================================================================
  2301                                  ; 04/05/2019 - Retro DOS v4.0
  2302                                  
  2303                                  ;**	Int 2A functions
  2304                                  ; ---------------------------------------------------------------------------
  2305                                  ;	Int 2A is an interface to the network code; it's also overloaded
  2306                                  ;		as a critical section handler since critical sections
  2307                                  ;		were originally created to support the net.
  2308                                  ; ---------------------------------------------------------------------------
  2309                                  
  2310                                  ; ---------------------------------------------------------------------------
  2311                                  ;**	This table was created by examining the source and may not be
  2312                                  ;	complete or completely accurate - JGL
  2313                                  ;
  2314                                  ;	M010	MD	8/31/90 - Added definition for AH = 5
  2315                                  
  2316                                  ;	(ah) = 0	installation check
  2317                                  ;			   (returns ah !=0 if installed)
  2318                                  ;	(ah) = 1	cooked net bios call
  2319                                  ;	(ah) = 3	query drive shared
  2320                                  ;			   (ds:si) = "n:" asciz string
  2321                                  ;	(ah) = 4	net bios
  2322                                  ;	       (al) = 0	   cooked net bios call
  2323                                  ;	       (al) = 1	   raw net bios call
  2324                                  ;	       (al) = 2	   ???
  2325                                  ;
  2326                                  ;	(ah) = 5	Get Net Adaptor Resources. CX returns the number of
  2327                                  ;			NCBs available/outstanding. DX returns the number of
  2328                                  ;			sessions. Supposedly, this is documented in an old
  2329                                  ;			IBM PC-LAN reference. Lotus Notes uses it. DOS LAN
  2330                                  ;			Manager 2.0 Enhanced responds to it. But it should
  2331                                  ;			not be used, as it is a hack, only to get Lotus
  2332                                  ;			Notes running.
  2333                                  ;
  2334                                  ;	(ah) = 80h	enter critical section
  2335                                  ;	(ah) = 81h	leave critical section
  2336                                  ;	(ah) = 82h	free all critical sections (Leave-all)
  2337                                  ;	(ah) = 84h	entering idle loop (don't understand how this works)
  2338                                  ; ---------------------------------------------------------------------------
  2339                                  
  2340                                  ;**	Critical section definitions
  2341                                  ; ---------------------------------------------------------------------------
  2342                                  ;	Although DOS is not designed to be reentrant there are some hacks
  2343                                  ;	which various programs use to make it so, in a limited fashion.
  2344                                  ;	Both WIN386 and some servers block copy a section of the DOS data
  2345                                  ;	area so that DOS can be reentered on behalf of another thread/program.
  2346                                  ;	DOS's global data structures, such as the memory arena, are not
  2347                                  ;	in this area, so critical section indicators are used to protect
  2348                                  ;	those areas.  DOS flags a critical section by issuing an INT_IBM
  2349                                  ;	(int 2Ah) at each critical section entry and exit.  Some clients
  2350                                  ;	(such as WIN386) just don't "context switch" the DOS when one
  2351                                  ;	of these is in effect, others, such as the IBM server, go ahead
  2352                                  ;	and reenter the DOS and if they get an int 2A to reenter the same
  2353                                  ;	critical section they then switch away from that second thread and
  2354                                  ;	let the first one finish and exit the section.
  2355                                  ; ---------------------------------------------------------------------------
  2356                                  
  2357                                  ; These below are subject to leave-all sections
  2358                                  critDisk    EQU     1			; Disk I/O critical section
  2359                                  critShare   EQU     1			; Sharer I/O critical section
  2360                                  critMem     EQU     1			; memory maintenance critical section
  2361                                  critSFT     EQU     1			; sft table allocation
  2362                                  critDevice  EQU     2			; Device I/O critical section
  2363                                  critNet     EQU     5			; network critical section
  2364                                  critIFS     EQU     6			; ifsfunc critical section
  2365                                  ; These below are not subject to leave-all sections
  2366                                  critASSIGN  EQU     8			; Assign has munged a system call
  2367                                  
  2368                                  ;============================================================================
  2369                                  ; MULT.INC (MSDOS 6.0, 1991)
  2370                                  ;============================================================================
  2371                                  ; 04/05/2019 - Retro DOS v4.0
  2372                                  
  2373                                  ;Break <Multiplex channels>
  2374                                  
  2375                                  ; ---------------------------------------------------------------------------
  2376                                  ; The current set of defined multiplex channels is (* means documented):
  2377                                  ;
  2378                                  ;   Channel(h)  Issuer          Receiver    Function
  2379                                  ;      00       server          PSPRINT     print job control
  2380                                  ;     *01       print/apps      PRINT       Queueing of files
  2381                                  ;      02       BIOS            REDIR       signal open/close of printers
  2382                                  ;
  2383                                  ;      05       command         REDIR       obtain text of net int 24 message
  2384                                  ;     *06       server/assign   ASSIGN      Install check
  2385                                  ;
  2386                                  ;      08       external driver IBMBIO      interface to internal routines
  2387                                  ;
  2388                                  ;      10       sharer/server   Sharer      install check
  2389                                  ;      11       DOS/server      Redir       install check/redirection funcs
  2390                                  ;      12       sharer/redir    DOS         dos functions and structure maint
  2391                                  ;      13       MSNET           MSNET       movement of NCBs
  2392                                  ;      13       external driver IBMBIO      Reset_Int_13, allows installation
  2393                                  ;                                           of alternative INT_13 drivers after
  2394                                  ;                                           boot_up
  2395                                  ;      14 (IBM) DOS             NLSFUNC     down load NLS country info,DOS 3.3
  2396                                  ;      14 (MS)  APPS            POPUP       MSDOS 4 popup screen functions
  2397                                  ;      15       APPS            MSCDEX      CD-ROM extensions interface
  2398                                  ;      16       WIN386          WIN386      Windows communications
  2399                                  ;      17       Clipboard       WINDOWS     Clipboard interface
  2400                                  ;     *18       Applications    MS-Manger   Toggle interface to manager
  2401                                  ;      19       Shell
  2402                                  ;      1A       Ansi.sys
  2403                                  ;      1B       Fastopen,Vdisk   IBMBIO     EMS INT 67H stub handler
  2404                                  ;
  2405                                  ;      40h      OS/2
  2406                                  ;      41h      Lanman
  2407                                  ;      42h      Lanman
  2408                                  ;      43h      Himem
  2409                                  ;                               AL = 20h    reserved for Mach 20 Himem support
  2410                                  ;                               AL = 30h    reserved for Himem external A20 code
  2411                                  ;      44h      Dosextender
  2412                                  ;      45H      Windows profiler
  2413                                  ;      46h      Windows/286 DOS extender
  2414                                  ;      47h      Basic Compiler Vn. 7.0
  2415                                  ;      48h      Doskey
  2416                                  ;      49h      DOS 5.x install 
  2417                                  ;      4Ah      Multi Purpose
  2418                                  ;                multMULTSWPDSK         0 - Swap Disk in drive A (BIOS)
  2419                                  ;                multMULTGETHMAPTR      1 - Get available HMA & ptr
  2420                                  ;                multMULTALLOCHMA       2 - Allocate HMA (bx == no of bytes)
  2421                                  ;                multMULTTASKSHELL      5 - Shell/switcher API
  2422                                  ;                multMULTRPLTOM         6 - Top Of Memory for RPL support
  2423                                  ;
  2424                                  ;                multSmartdrv           10h
  2425                                  ;                multMagicdrv           11h
  2426                                  ;      4Bh      Task Switcher API
  2427                                  ;
  2428                                  ;      4Ch      APPS            APM         Advanced power management
  2429                                  ;      4Dh      Kana Kanji Converter, MSKK
  2430                                  ;
  2431                                  ;      51h      ODI real mode support driver (for Chicago)
  2432                                  ;
  2433                                  ;      53h      POWER.EXE - used for broadcasting APM events    ; M036
  2434                                  ;      54h      POWER.EXE - used for POWER API                  ; M036
  2435                                  ;
  2436                                  ;      55h      COMMAND.COM
  2437                                  ;                multCOMFIRST           0 - API to determine whether 1st
  2438                                  ;                                           instance of command.com
  2439                                  ;                multCOMFIRSTROM        1 - API to determine whether 1st
  2440                                  ;                                           instance of ROM COMMAND
  2441                                  ;      56h      Sewell Development
  2442                                  ;               INTERLNK
  2443                                  ;
  2444                                  ;      57h      Iomega Corp.
  2445                                  ;
  2446                                  ;      ABh      Unspecified IBM use
  2447                                  ;      ACh      Graphics
  2448                                  ;      ADh      NLS (toronto)
  2449                                  ;      AEh
  2450                                  ;      AFh      Mode
  2451                                  ;      B0h      GRAFTABL        GRAFTABL
  2452                                  ;
  2453                                  ;      D7h      Banyan VINES
  2454                                  ; ---------------------------------------------------------------------------
  2455                                  
  2456                                  ;MUX 00-3F reserverd for IBM
  2457                                  ;MUX 80-BF reserverd for IBM
  2458                                  
  2459                                  ;MUX 40-7F reserved for Microsoft
  2460                                  
  2461                                  ;MUX C0-FF users
  2462                                  
  2463                                  MultSHARE   EQU     10h 		; sharer
  2464                                      ;	1   MFT_enter
  2465                                      ;	2   MFTClose
  2466                                      ;	3   MFTclU
  2467                                      ;	4   MFTCloseP
  2468                                      ;	5   MFTCloN
  2469                                      ;	6   set_block
  2470                                      ;	7   clr_block
  2471                                      ;	8   chk_block
  2472                                      ;	9   MFT_get
  2473                                      ;	10  ShSave
  2474                                      ;	11  ShChk
  2475                                      ;	12  ShCol
  2476                                      ;	13  ShCloseFile
  2477                                  
  2478                                  MultNET     EQU     11h 		; Network support
  2479                                  MultIFS     EQU     11h                 ; Network support
  2480                                      ;   1   IFS_RMDIR
  2481                                      ;   2   IFS_SEQ_RMDIR
  2482                                      ;   3   IFS_MKDIR
  2483                                      ;   4   IFS_SEQ_MKDIR
  2484                                      ;   5   IFS_CHDIR
  2485                                      ;   6   IFS_CLOSE
  2486                                      ;   7   IFS_COMMIT
  2487                                      ;   8   IFS_READ
  2488                                      ;   9   IFS_WRITE
  2489                                      ;   10  IFS_LOCK
  2490                                      ;   11  IFS_UNLOCK
  2491                                      ;   12  IFS_DISK_INFO
  2492                                      ;   13  IFS_SET_FILE_ATTRIBUTE
  2493                                      ;   14  IFS_SEQ_SET_FILE_ATTRIBUTE
  2494                                      ;   15  IFS_GET_FILE_INFO
  2495                                      ;   16  IFS_SEQ_GET_FILE_INFO
  2496                                      ;   17  IFS_RENAME
  2497                                      ;   18  IFS_SEQ_RENAME
  2498                                      ;   19  IFS_DELETE
  2499                                      ;   20  IFS_SEQ_DELETE
  2500                                      ;   21  IFS_OPEN
  2501                                      ;   22  IFS_SEQ_OPEN
  2502                                      ;   23  IFS_CREATE
  2503                                      ;   24  IFS_SEQ_CREATE
  2504                                      ;   25  IFS_SEQ_SEARCH_FIRST
  2505                                      ;   26  IFS_SEQ_SEARCH_NEXT
  2506                                      ;   27  IFS_SEARCH_FIRST
  2507                                      ;   28  IFS_SEARCH_NEXT
  2508                                      ;   29  IFS_ABORT
  2509                                      ;   30  IFS_ASSOPER
  2510                                      ;   31  Printer_SET_STRING
  2511                                      ;   32  IFSFlushBuf
  2512                                      ;   33  IFSBufWrite
  2513                                      ;   34  IFSResetEnvironment
  2514                                      ;   35  IFSSpoolCheck
  2515                                      ;   36  IFSSpoolClose
  2516                                      ;   37  IFSDeviceOper
  2517                                      ;   38  IFSSpoolEchoCheck
  2518                                      ;   39      - - -   Unused   - - -
  2519                                      ;   40      - - -   Unused   - - -
  2520                                      ;   41      - - -   Unused   - - -
  2521                                      ;   42  SERVER_DOSCALL_CLOSEFILES_FOR_UID
  2522                                      ;   43  DEVICE_IOCTL
  2523                                      ;   44  IFS_UPDATE_CB
  2524                                      ;   45  IFS_FILE_XATTRIBUTES
  2525                                      ;   46  IFS_XOPEN
  2526                                      ;   47  IFS_DEPENDENT_IOCTL
  2527                                  
  2528                                  MultDOS     EQU     12h 		; DOS call back
  2529                                      ;	1   DOS_CLOSE
  2530                                      ;	2   RECSET
  2531                                      ;	3   Get DOSGROUP
  2532                                      ;	4   PATHCHRCMP
  2533                                      ;	5   OUT
  2534                                      ;	6   NET_I24_ENTRY
  2535                                      ;	7   PLACEBUF
  2536                                      ;	8   FREE_SFT
  2537                                      ;	9   BUFWRITE
  2538                                      ;	10  SHARE_VIOLATION
  2539                                      ;	11  SHARE_ERROR
  2540                                      ;	12  SET_SFT_MODE
  2541                                      ;	13  DATE16
  2542                                      ;	14  SETVISIT
  2543                                      ;	15  SCANPLACE
  2544                                      ;	16  SKIPVISIT
  2545                                      ;	17  StrCpy
  2546                                      ;	18  StrLen
  2547                                      ;	19  UCase
  2548                                      ;	20  POINTCOMP
  2549                                      ;	21  CHECKFLUSH
  2550                                      ;	22  SFFromSFN
  2551                                      ;	23  GetCDSFromDrv
  2552                                      ;	24  Get_User_Stack
  2553                                      ;	25  GetThisDrv
  2554                                      ;	26  DriveFromText
  2555                                      ;	27  SETYEAR
  2556                                      ;	28  DSUM
  2557                                      ;	29  DSLIDE
  2558                                      ;	30  StrCmp
  2559                                      ;	31  initcds
  2560                                      ;	32  pjfnfromhandle
  2561                                      ;	33  $NameTrans
  2562                                      ;	34  CAL_LK
  2563                                      ;	35  DEVNAME
  2564                                      ;	36  Idle
  2565                                      ;   37  DStrLen
  2566                                      ;   38  NLS_OPEN      DOS 3.3
  2567                                      ;   39  $CLOSE        DOS 3.3
  2568                                      ;   40  NLS_LSEEK     DOS 3.3
  2569                                      ;   41  $READ         DOS 3.3
  2570                                      ;   42  FastInit      DOS 4.0
  2571                                      ;   43  NLS_IOCTL     DOS 3.3
  2572                                      ;   44  GetDevList    DOS 3.3
  2573                                      ;   45  NLS_GETEXT    DOS 3.3
  2574                                      ;   46  MSG_RETRIEVAL DOS 4.0
  2575                                      ;   47  FAKE_VERSION  DOS 4.0
  2576                                  
  2577                                  NLSFUNC     EQU     14h 		; NLSFUNC CALL , DOS 3.3
  2578                                      ;	0   NLSInstall
  2579                                      ;	1   ChgCodePage
  2580                                      ;	2   GetExtInfo
  2581                                      ;	3   SetCodePage
  2582                                      ;	4   GetCntry
  2583                                  
  2584                                  multANSI    EQU     1Ah                 ; ANSI multiplex number
  2585                                      ;   0   INSTALL_CHECK               ; install check for ANSI
  2586                                      ;   1   IOCTL_2F                    ; 2F interface to IOCTL
  2587                                      ;   2   DA_INFO_2F                  ; J.K. Information passing to ANSI.
  2588                                  
  2589                                  multMULT        EQU     4Ah
  2590                                  multMAGIC       EQU     256*multMULT + 11h
  2591                                  multMULTRPLTOM  EQU     06h
  2592                                  
  2593                                      ;   0   swap disk function for single floppy drive m/cs
  2594                                      ;       BIOS broadcasts with cx==0, and apps who handle
  2595                                      ;       swap disk messaging set cx == -1. BIOS sets dl == requested
  2596                                      ;       drive
  2597                                      ;
  2598                                      ;   1   Get available HMA & pointer to it. Returns in BX & ES:DI
  2599                                      ;   2   Allocate HMA. BX == number of bytes in HMA to be allocated
  2600                                      ;       returns pointer in ES:DI
  2601                                      ;
  2602                                      ;   3-4 currently used by nobody
  2603                                      ;   5   Switcher API
  2604                                      ;   6   Top of Memory for RPL.
  2605                                      ;           BIOS issues INT 2f AX=4a06 & DX = Top of Mem and any RPL
  2606                                      ;           code present in TOM should respond with a new TOM in DX
  2607                                      ;           to protect itself from MSLOAD & SYSINIT tromping over it.
  2608                                      ;           SYSINIT builds an arena with owner type 8 & name 'RPL' to
  2609                                      ;           protect the RPL code from COMMAND.COM transient protion.
  2610                                      ;           It is the responsibility of RPL program to release the mem.
  2611                                      ;   7   Reserved for PROTMAN support.
  2612                                      ;  10   smartdrv 4.0
  2613                                      ;  11   dblspace api
  2614                                      ;  12   MRCI     api
  2615                                      ;  13   dblspace/mrci stealth packet api
  2616                                  
  2617                                  MultAPM     EQU     4ch             ; Obselete ???
  2618                                      ;       00h     APM_VER_CHK
  2619                                      ;       01h     APM_SUS_SYS_REQ
  2620                                      ;       FFh     APM_SUS_RES_BATT_NOTIFY
  2621                                  
  2622                                  MultPWR_BRDCST  EQU     53h     ; Used by POWER.EXE to broadcast      ; M036
  2623                                  				;  APM events                         ; M036
  2624                                  MultPWR_API     EQU     54h     ; Used for accessing POWER.EXE's API  ; M036
  2625                                  
  2626                                  ;FASTOPEN is not chained through INT 2F   ; DOS 3.3 F.C.
  2627                                  ;	  it calls Multdos 42 to set up an entry routine address
  2628                                      ;	0   Install status  (reserved)
  2629                                      ;	1   Lookup
  2630                                      ;	2   Insert
  2631                                      ;	3   Delete
  2632                                      ;	4   Purge	    (reserved)
  2633                                  
  2634                                  ;============================================================================
  2635                                  ; FIND.INC (MSDOS 6.0, 1991)
  2636                                  ;============================================================================
  2637                                  ; 17/05/2019 - Retro DOS v4.0
  2638                                  ; 09/07/2018 - Retro DOS v3.0 (MSDOS 3.3, 1987)
  2639                                  
  2640                                  ;Break	<find first/next buffer>
  2641                                  
  2642                                  struc find_buf
  2643 00000000 ??                      .drive:	    resb 1		; drive of search
  2644 00000001 <res Bh>                .name:	    resb 11		; formatted name
  2645 0000000C ??                      .sattr:	    resb 1		; attribute of search
  2646 0000000D ????                    .LastEnt:   resw 1		; LastEnt
  2647 0000000F ????                    .DirStart:  resw 1		; DirStart
  2648 00000011 ????????                .NETID:	    resb 4 ; MSDOS 6.0 	; Reserved for NET
  2649 00000015 ??                      .attr:	    resb 1		; attribute found
  2650 00000016 ????                    .time:	    resw 1		; time
  2651 00000018 ????                    .date:	    resw 1		; date
  2652 0000001A ????                    .size_l:    resw 1		; low(size)
  2653 0000001C ????                    .size_h:    resw 1		; high(size)
  2654 0000001E <res Dh>                .pname:	    resb 13		; packed name
  2655                                  .size:
  2656                                  endstruc
  2657                                  
  2658                                  ;============================================================================
  2659                                  ; DOSCNTRY.INC (MSDOS 6.0, 1991)
  2660                                  ;============================================================================
  2661                                  ; 29/04/2019 - Retro DOS v4.0
  2662                                  ; 09/07/2018 - Retro DOS v3.0 (MSDOS 3.3, 1987)
  2663                                  
  2664                                  ;Equates for COUNTRY INFORMATION.
  2665                                  SetCountryInfo	EQU	1	;country info
  2666                                  SetUcase	EQU	2	;uppercase table
  2667                                  SetLcase	EQU	3	;lowercase table (Reserved)
  2668                                  SetUcaseFile	EQU	4	;uppercase file spec table
  2669                                  SetFileList	EQU	5	;valid file character list
  2670                                  SetCollate	EQU	6	;collating sequence
  2671                                  SetDBCS 	EQU	7	;double byte character set
  2672                                  SetALL		EQU	-1	;all the entries
  2673                                  
  2674                                  ;DOS country and code page information table structure.
  2675                                  ;Internally, IBMDOS gives a pointer to this table.
  2676                                  ;IBMBIO, MODE and NLSFUNC modules communicate with IBMDOS through
  2677                                  ;this structure.
  2678                                  
  2679                                  struc  DOS_CCDPG	; DOS_country_cdpg_info
  2680 00000000 ????????????????        .ccInfo_reserved: 	resb 8	;reserved for internal use
  2681 00000008 <res 40h>               .ccPath_CountrySys:	resb 64 ;path and filename for country info
  2682 00000048 ????                    .ccSysCodePage:		resw 1	;system code page id
  2683 0000004A ????                    .ccNumber_of_entries:	resw 1  ; (default value = 6)
  2684 0000004C ??                      .ccSetUcase:		resb 1  ; (default value = SetUcase)
  2685 0000004D ????????                .ccUcase_ptr:		resd 1	;pointer to Ucase table
  2686                                  
  2687 00000051 ??                      .ccSetUcaseFile:	resb 1	; (default value = SetUcaseFile)
  2688 00000052 ????????                .ccFileUcase_ptr: 	resd 1	;pointer to File Ucase table
  2689                                  
  2690 00000056 ??                      .ccSetFileList:		resb 1 	; (default value = SetFileList)
  2691 00000057 ????????                .ccFileChar_ptr:	resd 1	;pointer to File char list table
  2692                                  
  2693 0000005B ??                      .ccSetCollate:		resb 1	; (default value = SetCollate)
  2694 0000005C ????????                .ccCollate_ptr:		resd 1	;pointer to collate table
  2695                                  
  2696                                  ; MSDOS 6.0
  2697 00000060 ??                      .ccSetDBCS:		resb 1	; (default value = SetDBCS)
  2698 00000061 ????????                .ccDBCS_ptr:		resd 1	; pointer to DBCS table
  2699                                  
  2700 00000065 ??                      .ccSetCountryInfo:	resb 1  ; (default value = SetCountryInfo)
  2701 00000066 ????                    .ccCountryInfoLen:	resw 1	;length of country info
  2702 00000068 ????                    .ccDosCountry:		resw 1	;system country code id
  2703 0000006A ????                    .ccDosCodePage:		resw 1	;system code page id
  2704 0000006C ????                    .ccDFormat:		resw 1	;date format
  2705 0000006E ??????????              .ccCurSymbol:		resb 5	;5 byte of (currency symbol+0)
  2706 00000073 ????                    .cc1000Sep:		resb 2	;2 byte of (1000 sep. + 0)
  2707 00000075 ????                    .ccDecSep:		resb 2	;2 byte of (Decimal sep. + 0)
  2708 00000077 ????                    .ccDateSep:		resb 2	;2 byte of (date sep. + 0)
  2709 00000079 ????                    .ccTimeSep:		resb 2	;2 byte of (time sep. + 0)
  2710 0000007B ??                      .ccCFormat:		resb 1	;currency format flags
  2711 0000007C ??                      .ccCSigDigits:		resb 1	;# of digits in currency
  2712 0000007D ??                      .ccTFormat:		resb 1	;time format
  2713 0000007E ????????                .ccMono_ptr:		resd 1	;monocase routine entry point
  2714 00000082 ????                    .ccListSep:		resb 2	;data list separator
  2715 00000084 <res Ah>                .ccReserved_area: 	resw 5	;reserved
  2716                                  .size:
  2717                                  endstruc
  2718                                  
  2719                                  ;Ucase table
  2720                                  struc CC_UCASE_TAB
  2721 00000000 ????                    .ccUcase_leng:		resw 1	; (default value = 128)
  2722 00000002 <res 80h>               .ccUcase_data:		resb 128
  2723                                  endstruc
  2724                                  
  2725                                  ;File Ucase table
  2726                                  struc CC_FILE_UCASE_TAB
  2727 00000000 ????                    .ccFileucase_leng:	resw 1	; (default value = 128)
  2728 00000002 <res 80h>               .ccFileucase_data:	resb 128
  2729                                  endstruc
  2730                                  
  2731                                  ;File char list
  2732                                  struc CC_FILE_CHAR_TAB
  2733 00000000 ????                    .ccFilechar_leng:	resw 1
  2734 00000002 <res 2Eh>               .ccFilechar_data:	resb 46
  2735                                  endstruc
  2736                                  
  2737                                  ;collate table
  2738                                  struc CC_COLLATE_TAB
  2739 00000000 ????                    .ccCollate_leng:	resw 1	; (default value = 128)
  2740 00000002 <res 100h>              .ccCollate_data:	resb 256
  2741                                  endstruc
  2742                                  
  2743                                  OLD_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDFormat - 10)
  2744                                  NEW_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDosCountry) ; 38
  2745                                  
  2746                                  ; 06/08/2018
  2747                                  ; DOSCNTRY.INC (MSDOS 6.0, 1991)
  2748                                  
  2749                                  ;CAPITALIZATION equates
  2750                                  CAP_ONE_CHAR	equ	20H
  2751                                  CAP_STRING	equ	21H
  2752                                  CAP_ASCIIZ	equ	22H
  2753                                  CHECK_YES_NO	equ	23H
  2754                                  UPPER_TABLE	equ	80H
  2755                                  
  2756                                  ;NLS_YES	equ	59H  ; 'Y'
  2757                                  ;NLS_yes2	equ	79H  ; 'y' 	
  2758                                  ;NLS_NO		equ	4EH  ; 'N'	
  2759                                  ;NLS_no2	equ	6EH  ; 'n'	
  2760                                  
  2761                                  ;============================================================================
  2762                                  ; CURDIR.INC (MSDOS 6.0, 1991)
  2763                                  ;============================================================================
  2764                                  ; 25/04/2019 - Retro DOS v4.0
  2765                                  ; 09/07/2018 - Retro DOS v3.0 (CURDIR.INC, MSDOS 3.3, 1987)
  2766                                  
  2767                                  ;BREAK <Current directory list structure>
  2768                                  
  2769                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2770                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2771                                  ;									   ;
  2772                                  ; CDS items are used bu the internal routines to store cluster numbers and ;
  2773                                  ; network identifiers for each logical name.  The ID field is used dually, ;
  2774                                  ; both as net ID and for a cluster number for local devices.  In the case  ;
  2775                                  ; of local devices, the cluster number will be -1 if there is a potential  ;
  2776                                  ; of the disk being changed or if the path must be recracked.		   ;
  2777                                  ;
  2778                                  ;	Some pathnames have special preambles, such as
  2779                                  ;
  2780                                  ;		\\machine\sharename\...
  2781                                  ;	For these pathnames we can't allow ".." processing to back us
  2782                                  ;	up into the special front part of the name.  The CURDIR_END field
  2783                                  ;	holds the address of the seperator character which marks
  2784                                  ;	the split between the special preamble and the regular
  2785                                  ;	path list; ".." processing isn't allowed to back us up past
  2786                                  ;	(i.e., before) CURDIR_END
  2787                                  ;	For the root, it points at the leading /.  For net
  2788                                  ;	assignments it points at the end (nul) of the initial assignment:
  2789                                  ;	A:/	\\foo\bar	    \\foo\bar\blech\bozo
  2790                                  ;	  ^		 ^		     ^
  2791                                  
  2792                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
  2793                                  
  2794                                  TEMPLEN 	EQU	DIRSTRLEN*2
  2795                                  
  2796                                  struc curdir	; curdir_list
  2797 00000000 <res 43h>               .text:		resb DIRSTRLEN		; text of assignment and curdir
  2798 00000043 ????                    .flags:		resw 1			; various flags
  2799 00000045 ????????                .devptr:	resd 1			; local pointer to DPB or net device
  2800 00000049 ????????                .ID:		resw 2			; cluster of current dir (net ID)
  2801 0000004D ????                    .user_word:	resw 1
  2802 0000004F ????                    .end:		resw 1			; index to ".." backup limit - see above
  2803                                  ; MSDOS 6.0
  2804 00000051 ??                      .type:		resb 1			; IFS drive (2=ifs, 4=netuse)
  2805 00000052 ????????                .ifs_hdr:	resd 1			; Ptr to File System Header
  2806 00000056 ????                    .fsda:		resb 2			; File System Dependent Data Area
  2807                                  .size:
  2808                                  endstruc
  2809                                  
  2810                                  curdirLen	EQU curdir.size	; 88	; Needed for screwed up
  2811                                  
  2812                                  %define curdir_netID curdir_ID  ; dword
  2813                                  
  2814                                  ;**	Flag values for CURDIR_FLAGS
  2815                                  
  2816                                  curdir_isnet	EQU	1000000000000000B
  2817                                  CURDIR_isifs	EQU	1000000000000000B ; MSDOS 6.0	
  2818                                  curdir_inuse	EQU	0100000000000000B
  2819                                  curdir_splice	EQU	0010000000000000B
  2820                                  curdir_local	EQU	0001000000000000B
  2821                                  
  2822                                  ;									   ;
  2823                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2824                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2825                                  
  2826                                  ;============================================================================
  2827                                  ; CPMFCB.INC (MSDOS 3.3, 1987)
  2828                                  ;============================================================================
  2829                                  ; 09/07/2018 - Retro DOS v3.0
  2830                                  
  2831                                  ;BREAK <File Control Block definition>
  2832                                  
  2833                                  ;
  2834                                  ; Field definition for FCBs
  2835                                  ; The FCB has the following structure:
  2836                                  ;
  2837                                  ;	+---------------------------+
  2838                                  ;	|   Drive indicator(byte)   |
  2839                                  ;	+---------------------------+
  2840                                  ;	|    Filename (8 chars)     |
  2841                                  ;	+---------------------------+
  2842                                  ;	|    Extension (3 chars)    |
  2843                                  ;	+---------------------------+
  2844                                  ;	|   Current Extent(word)    |
  2845                                  ;	+---------------------------+
  2846                                  ;	|    Record size (word)     |
  2847                                  ;	+---------------------------+
  2848                                  ;	|    File Size (2 words)    |
  2849                                  ;	+---------------------------+
  2850                                  ;	|	Date of write	    |
  2851                                  ;	+---------------------------+
  2852                                  ;	|	Time of write	    |
  2853                                  ;	+---------------------------+
  2854                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2855                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2856                                  ;									   ;
  2857                                  ;	+---------------------------+
  2858                                  ;	|   8 bytes reserved	    |
  2859                                  ;	+---------------------------+
  2860                                  ;									   ;
  2861                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2862                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2863                                  ;	|    next record number     |
  2864                                  ;	+---------------------------+
  2865                                  ;	|   random record number    |
  2866                                  ;	+---------------------------+
  2867                                  ;
  2868                                  
  2869                                  struc	SYS_FCB
  2870 00000000 ??                      .drive:	resb 1
  2871 00000001 ????????????????        .name:	resb 8
  2872 00000009 ??????                  .ext:	resb 3
  2873 0000000C ????                    .EXTENT: resw 1
  2874 0000000E ????                    .RECSIZ: resw 1			; Size of record (user settable)
  2875 00000010 ????                    .FILSIZ: resw 1			; Size of file in bytes; used with the
  2876                                  				; following word
  2877 00000012 ????                    .DRVBP:	resw 1			; BP for SEARCH FIRST and SEARCH NEXT
  2878 00000014 ????                    .FDATE:	resw 1			; Date of last writing
  2879 00000016 ????                    .FTIME:	resw 1			; Time of last writing
  2880                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2881                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2882                                  ;									   ;
  2883 00000018 ????????????????        .reserved: resb 8		; RESERVED
  2884                                  ;									   ;
  2885                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2886                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2887 00000020 ??                      .NR:	resb 1			; Next record
  2888 00000021 ????????                .RR:	resb 4			; Random record
  2889                                  .size:
  2890                                  endstruc
  2891                                  
  2892                                  FILDIRENT EQU SYS_FCB.FILSIZ	; Used only by SEARCH FIRST and SEARCH
  2893                                  				; NEXT
  2894                                  ; 20/07/2018
  2895                                  %define fcb_sfn	SYS_FCB.reserved ; byte
  2896                                  
  2897                                  ; Note that fcb_net_handle, fcb_nsl_drive, fcb_nsld_drive and fcb_l_drive
  2898                                  ; all must point to the same byte.  Otherwise, the FCBRegen will fail.
  2899                                  ; NOTE about this byte (fcb_nsl_drive)
  2900                                  ;   The high two bits of this byte are used as follows to indicate the FCB type
  2901                                  ;	00 means a local file or device with sharing loaded
  2902                                  ;	10 means a remote (network) file
  2903                                  ;	01 means a local file with no sharing loaded
  2904                                  ;	11 means a local device with no sharing loaded
  2905                                  
  2906                                  ; 20/07/2018
  2907                                  
  2908                                  ;
  2909                                  ; Network FCB
  2910                                  ;
  2911                                  
  2912                                  %define fcb_net_drive	SYS_FCB.reserved+1  ; byte
  2913                                  %define fcb_net_handle	SYS_FCB.reserved+2  ; word
  2914                                  %define fcb_netID	SYS_FCB.reserved+4  ; dword		
  2915                                  
  2916                                  ;
  2917                                  ; No sharing local file FCB
  2918                                  ;
  2919                                  
  2920                                  %define fcb_nsl_drive	SYS_FCB.reserved+1  ; byte
  2921                                  %define fcb_nsl_bits	SYS_FCB.reserved+2  ; byte	
  2922                                  %define fcb_nsl_firclus SYS_FCB.reserved+3  ; word	
  2923                                  %define fcb_nsl_dirsec	SYS_FCB.reserved+5  ; word
  2924                                  %define fcb_nsl_dirpos  SYS_FCB.reserved+7  ; byte
  2925                                  
  2926                                  ;
  2927                                  ; No sharing local device FCB
  2928                                  ;
  2929                                  
  2930                                  %define fcb_nsld_drive	SYS_FCB.reserved+1  ; byte	
  2931                                  %define fcb_nsld_drvptr SYS_FCB.reserved+2  ; dword
  2932                                  
  2933                                  ;
  2934                                  ; Sharing local FCB
  2935                                  ;
  2936                                  
  2937                                  %define fcb_l_drive	SYS_FCB.reserved+1  ; byte
  2938                                  %define fcb_l_firclus	SYS_FCB.reserved+2  ; word
  2939                                  %define fcb_l_mfs	SYS_FCB.reserved+4  ; word
  2940                                  %define fcb_l_attr	SYS_FCB.reserved+6  ; byte
  2941                                  
  2942                                  ;
  2943                                  ; Bogusness:  the four cases are:
  2944                                  ;
  2945                                  ;   local file	    00
  2946                                  ;   local device    40
  2947                                  ;   local sharing   C0
  2948                                  ;   network	    80
  2949                                  ;
  2950                                  ; Since sharing and network collide, we cannot use a test instruction for
  2951                                  ; deciding whether a network or a share check in involved
  2952                                  ;
  2953                                  FCBDEVICE   EQU 040h
  2954                                  FCBNETWORK  EQU 080h
  2955                                  FCBSHARE    EQU 0C0h
  2956                                  
  2957                                  ; FCBSPECIAL must be able to mask off both net and share
  2958                                  FCBSPECIAL  EQU 080h
  2959                                  FCBMASK     EQU 0C0h
  2960                                  
  2961                                  ;============================================================================
  2962                                  ; FASTOPEN.INC, MSDOS 6.0, 1991
  2963                                  ;============================================================================
  2964                                  ; 11/07/2018 - Retro DOS v3.0
  2965                                  ; 25/04/2019 - Retro DOS v4.0
  2966                                  
  2967                                  struc FEI	; FASTOPEN_EXTENDED_INFO
  2968 00000000 ??                      .dirpos:	resb 1
  2969 00000001 ????????                .dirsec:	resd 1 ; MSDOS 6.0
  2970                                  ;.dirsec:	resw 1 ; MSDOS 3.3
  2971 00000005 ????                    .clusnum:	resw 1
  2972 00000007 ????                    .lastent:	resw 1	; for search first ; MSDOS 6.0
  2973 00000009 ????                    .dirstart:	resw 1	; for search first ; MSDOS 6.0
  2974                                  .size:
  2975                                  endstruc
  2976                                  
  2977                                  ; 23/07/2018
  2978                                  ;FASTOPEN NAME CACHING Subfunctions
  2979                                  FONC_Look_up	equ	1
  2980                                  FONC_insert	equ	2
  2981                                  FONC_delete	equ	3
  2982                                  FONC_update	equ	4
  2983                                  FONC_purge	equ	5	;reserved for the future use.
  2984                                  FONC_Rename	equ	6	;AN001
  2985                                  
  2986                                  ; 27/07/2018
  2987                                  ;FastOpen Data Structure
  2988                                  struc fastopen_entry	;Fastopen Entry pointer in DOS
  2989 00000000 ????                    .entry_size:	resw 1	; = 4	; size of the following
  2990 00000002 ????????                .name_caching:	resd 1
  2991                                  ; MSDOS 6.0
  2992                                  ;.fatchain_caching: resd 1	;reserved for future use
  2993                                  .size:
  2994                                  endstruc
  2995                                  
  2996                                  ; 27/07/2018
  2997                                  ;Equates used in DOS.
  2998                                  FastOpen_Set	       equ     00000001b
  2999                                  FastOpen_Reset	       equ     11111110b
  3000                                  Lookup_Success	       equ     00000010b
  3001                                  Lookup_Reset	       equ     11111101b
  3002                                  Special_Fill_Set       equ     00000100b
  3003                                  Special_Fill_Reset     equ     11111011b
  3004                                  No_Lookup	       equ     00001000b
  3005                                  Set_For_Search	       equ     00010000b	;DCR 167
  3006                                  
  3007                                  ; 09/08/2018 
  3008                                  ; (FASTXXXX.INC, MSDOS 6.0, 1991)
  3009                                  ; Fastxxx equates
  3010                                  FastOpen_ID	   equ	   1
  3011                                  FastSeek_ID	   equ	   2
  3012                                  Fast_yes	   equ	   10000000B ; 80h ; fastxxx flag
  3013                                  
  3014                                  ;Structure definitions
  3015                                  ;
  3016                                  struc Fasttable_Entry	 ; Fastxxx  Entry pointer in DOS
  3017 00000000 ????                    .Fast_Entry_Num: resw 1	 ; number of entries
  3018 00000002 ????????                .FastOpen_Seek:	 resd 1	 ; fastopen & fastseek entry address
  3019                                  endstruc
  3020                                  
  3021                                  ;============================================================================
  3022                                  ; LOCK.INC, MSDOS 6.0, 1991
  3023                                  ;============================================================================
  3024                                  ; 14/07/2018 - Retro DOS v3.0
  3025                                  
  3026                                  ;**	LOCK.INC - Definitions for Record Locking
  3027                                  
  3028                                  ;**	LOCK functions
  3029                                  
  3030                                  LOCK_ALL	    equ    0
  3031                                  UNLOCK_ALL	    equ    1
  3032                                  LOCK_MUL_RANGE	    equ    2
  3033                                  UNLOCK_MUL_RANGE    equ    3
  3034                                  LOCK_READ	    equ    4
  3035                                  WRITE_UNLOCK	    equ    5
  3036                                  LOCK_ADD	    equ    6
  3037                                  
  3038                                  ;**	Structure for Lock buffer
  3039                                  
  3040                                  struc LockBuf
  3041 00000000 ????????                .Lock_position:	resd 1		; file position for LOCK
  3042 00000004 ????????                .Lock_length:	resd 1		; number of bytes to LOCK
  3043                                  endstruc
  3044                                  
  3045                                  ;============================================================================
  3046                                  ; DPL.ASM, MSDOS 6.0, 1991
  3047                                  ;============================================================================
  3048                                  ; 04/08/2018 - Retro DOS v3.0
  3049                                  
  3050                                  ; (SRVCALL.ASM)
  3051                                  
  3052                                  struc DPL
  3053 00000000 ????                    .AX:	resw	1	; AX register
  3054 00000002 ????                    .BX:	resw	1	; BX register
  3055 00000004 ????                    .CX:	resw	1	; CX register
  3056 00000006 ????                    .DX:	resw	1	; DX register
  3057 00000008 ????                    .SI:	resw	1	; SI register
  3058 0000000A ????                    .DI:	resw	1	; DI register
  3059 0000000C ????                    .DS:	resw	1	; DS register
  3060 0000000E ????                    .ES:	resw	1	; ES register
  3061 00000010 ????                    .rsrvd: resw	1	; Reserved
  3062 00000012 ????                    .UID:	resw	1	; User (Machine) ID (0 = local macine)
  3063 00000014 ????                    .PID:	resw	1	; Process ID (0 = local user PID)
  3064                                  .size:
  3065                                  endstruc
  3066                                   
  3067                                  ;----------------------------------------------------------------------------
  3068                                  ; DOSDATA
  3069                                  ;----------------------------------------------------------------------------
  3070                                  ;============================================================================
  3071                                  ; 24/04/2019 - Retro DOS v4.0
  3072                                  
  3073                                  DosDataSg equ 3 ; DOS Data Segment address (dw in 'retrodos4.s')
  3074                                  		; ((just after resident IO.SYS code&data))
  3075                                  
  3076                                  ;============================================================================
  3077                                  ; WIN386.INC, MSDOS 6.0, 1991
  3078                                  ;============================================================================
  3079                                  ; 24/04/2019 - Retro DOS 4.0
  3080                                  
  3081                                  ;
  3082                                  ;  Symbols and structures relating to WIN386 support.
  3083                                  ;
  3084                                  ;  Used by files in both the DOS and the BIOS.
  3085                                  ;
  3086                                  ;  Created: 7-13-89 by MRW
  3087                                  ;
  3088                                  
  3089                                  ; WIN386 broadcast int 2fh multiplex number and subfunction numbers
  3090                                  
  3091                                  MultWin386		equ     16h	; Int 2f multiplex number
  3092                                  
  3093                                  Win386_Init		equ	05h	; Win386 initialization
  3094                                  Win386_Exit		equ	06h	; Win386 exit
  3095                                  Win386_Devcall		equ	07h	; Win386 device call out
  3096                                  Win386_InitDone		equ	08h	; Win386 initialization is complete
  3097                                  
  3098                                  ; When Win386_Devcall is broadcast, BX is the Device ID. DOS must 
  3099                                  ; answer call outs from the DOSMGR
  3100                                  
  3101                                  Win386_DOSMGR		equ	15H
  3102                                  
  3103                                  ; The following structures are used to communicate instance data to 
  3104                                  ; Win386 from the DOS and the BIOS. See Win386 API documentation
  3105                                  ; (chapter 3, "Call Out Interfaces") for further description.
  3106                                  
  3107                                  struc Win386_SIS	; Startup Info Structure
  3108 00000000 ????                     .Version:		resb	2	; db 3, 0
  3109 00000002 ????????                 .Next_Dev_Ptr:		resd	1	; pointer to next SIS in list
  3110 00000006 ????????                 .Virt_Dev_File_Ptr:	resd	1
  3111 0000000A ????????                 .Reference_Data:	resd	1
  3112 0000000E ????????                 .Instance_Data_Ptr:	resd	1	; pointer to instance data array
  3113                                  endstruc
  3114                                  
  3115                                  size_of_Win386_SIS equ 18 ; 24/04/2019 - Retro DOS v4.0
  3116                                  
  3117                                  struc Win386_IIS	; Instance Item Structure
  3118 00000000 ????????                .Ptr:			resd	1	; pointer to an instance item
  3119 00000004 ????                    .Size:			resw	1	; size of an instance item
  3120                                  endstruc
  3121                                  
  3122                                  size_of_Win386_IIS equ 6 ; 24/04/2019 - Retro DOS v4.0
  3123                                  
  3124                                  ;Win386 DOSMGR function return values to indicate operation done
  3125                                  
  3126                                  WIN_OP_DONE		equ	0B97Ch	; 
  3127                                  DOSMGR_OP_DONE		equ	0A2ABh	;
  3128                                  
  3129                                  ;M021
  3130                                  ; WInoldap callout multiplex number
  3131                                  
  3132                                  WINOLDAP		equ	46h	;
  3133                                  
  3134                                  ;============================================================================
  3135                                  ;----------------------------------------------------------------------------
  3136                                  ; DOSCODE
  3137                                  ;----------------------------------------------------------------------------
  3138                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3139                                  
  3140                                  ;============================================================================
  3141                                  ; MSHEAD.ASM (MSDOS 6.0, 1991)
  3142                                  ;============================================================================
  3143                                  ; 16/07/2018 - Retro DOS 3.0
  3144                                  ;----------------------------------------------------------------------------
  3145                                  ; 24/04/2019 - Retro DOS 4.0
  3146                                  
  3147                                  ; MSDOS 6.0
  3148                                  ;----------------------------------------------------------------------------
  3149                                  ; FILE : ORIGIN.INC
  3150                                  ;----------------------------------------------------------------------------
  3151                                  ; This is included in origin.asm and mshead.asm. Contains the equate that
  3152                                  ; is used for ORGing the DOS code.
  3153                                  ;
  3154                                  ; Brief Description of the necessacity of this ORG:
  3155                                  ; -------------------------------------------------
  3156                                  ;
  3157                                  ; A special problem exits when running out of the HMA. The HMA starts at 
  3158                                  ; address FFFF:10. There is no place in the HMA with an offset of zero.
  3159                                  ; This means programs running out off the HMA must use non-zero offset base
  3160                                  ; addresses. It also means that if we're running multiple programs from the
  3161                                  ; HMA, the base offset of each segment must atleast be as big as all of the
  3162                                  ; HMA segments that precede it.
  3163                                  ; 
  3164                                  ; One solution to this problem to ORG each module at 64K minus its size.
  3165                                  ; For instance a code segment 1234h bytes in length would org'd at edcbh.
  3166                                  ; This gives max. flexibility regarding it's location in the HMA. By 
  3167                                  ; selecting segment values between f124h and ffffh it could be located 
  3168                                  ; anywhere in the HMA. The problem with this is that programs with such 
  3169                                  ; high ORGs would not be able to run in low RAM.
  3170                                  ;
  3171                                  ; A compromise solution is to set the ORG address somewhere between 0010h
  3172                                  ; and ffffh - their size. In the particular case of the BIOS and the DOS 
  3173                                  ; the following solution has been implemented:
  3174                                  ;
  3175                                  ; The Bios Code segment will have a very small offset and run at the very
  3176                                  ; front of the HMA, after the VDISK header. THE Dos Code segment will have 
  3177                                  ; a base offset of (700+<min. size off RAM based BIOS>+<min. size of the DOS
  3178                                  ; DATA segment when DOS is running low>). This will reflect the lowest 
  3179                                  ; possible physical address at which DOS code will run, while still providing
  3180                                  ; max. possible flexibility in HMA positioning. This offset MUST NOT be 
  3181                                  ; smaller then that 20+size of Bios Code segment when running high. This is 
  3182                                  ; mostly true.
  3183                                  ;
  3184                                  ; Also this ORG'd value must be communicated to the BIOS. This is done by
  3185                                  ; putting this value after the first jmp instruction in the DOS code in
  3186                                  ; mshead.asm. 
  3187                                  ;
  3188                                  ; In order for the stripz utility to know how many zeroes to be stripped 
  3189                                  ; out, this value is placed at the beginning of the binary in origin.asm.
  3190                                  ;
  3191                                  ; Revision History:
  3192                                  ;
  3193                                  ; Currently this is being done manually. Therefore any change in the DOS DATA
  3194                                  ; Size or the BIOS size should be reflected here. --- Feb 90
  3195                                  ;
  3196                                  ; BDSIZE.INC contains the equates for BIODATASIZE, BIOCODESIZ and DOSDATASIZ.
  3197                                  ; A utility called getsize will obtain the corresponding values from msdos
  3198                                  ; and msbio.map and update the values in BDSIZ.INC if they are different. 
  3199                                  ; DOS should now be built using the batch file makedos.bat which invokes this
  3200                                  ; utility. The FORMAT of BDSIZE.INC should not be changed as getsize is 
  3201                                  ; dependant on that.				  --- Apr 3 '90
  3202                                  ;
  3203                                  ; For ROMDOS, however, there is no need to org the doscode to any location
  3204                                  ; other than zero.  Therefore the stripz utility will not need to be used,
  3205                                  ; so the offset will not need to be included at the beginning of the code
  3206                                  ; segment.  Also, the BIOS can just assume that the resident code begins
  3207                                  ; at offset zero within the segment.
  3208                                  ; 
  3209                                  ;
  3210                                  ;--------------------------------------------------------------------------
  3211                                  
  3212                                  BIODATASTART	EQU	00700h
  3213                                  ;include	bdsize.inc	; this sets the values:
  3214                                  				;	BIODATASIZ
  3215                                  				;	BIOCODESIZ
  3216                                  				;	DOSDATASIZ
  3217                                  
  3218                                  ; 05/12/2022
  3219                                  ;BIODATASIZ EQU 00910H	; 0900h for MSDOS 6.21 IO.SYS
  3220                                  			; 0900h for MSDOS 5.0 IO.SYS
  3221                                  ;BIOCODESIZ EQU 01A70H	; 1A70h for MSDOS 6.21 IO.SYS
  3222                                  			; 1A60h for MSDOS 5.0 IO.SYS
  3223                                  ;DOSDATASIZ EQU 01370H	; 1370h for MSDOS 6.21 IO.SYS
  3224                                  			; 1370h for MSDOS 5.0 IO.SYS
  3225                                  ;ifndef ROMDOS
  3226                                  ;
  3227                                  ;BYTSTART	EQU    	BIODATASTART+BIODATASIZ+BIOCODESIZ+DOSDATASIZ
  3228                                  ;PARASTART	EQU	(BYTSTART + 0FH) AND (NOT 0FH)	
  3229                                  ;
  3230                                  ;else
  3231                                  ;
  3232                                  ;BYTSTART	EQU	0
  3233                                  ;PARASTART	EQU	0
  3234                                  ;
  3235                                  ;endif ; ROMDOS
  3236                                  
  3237                                  ; 24/04/2019 - Retro DOS v4.0 - Modification
  3238                                  ; -----------------------------------------------------------------
  3239                                  ;MSDAT001E equ 136Ah ; 4970 ; for MSDOS 6.21	
  3240                                  ;MSDAT001E equ 1370h ; 4976 ; for Retro DOS v4.0 modif. 25/05/2019	
  3241                                  ;DOSDATASIZE equ MSDAT001E
  3242                                  ; 05/12/2022
  3243                                  ;DOSDATASIZE equ $ ; 29/04/2019 ; -only- for RETRO DOS v4.0 :
  3244                                  ;_PARASTART_ equ DOSDATASIZE ; segment value will point to start of
  3245                                  			    ; of DOSDATA (in low memory) while
  3246                                  			    ; dos/kernel code starts just after 
  3247                                  			    ; this data block ((org = DOSDATASIZE))
  3248                                  			    ; (in low memory or in HMA)	
  3249                                  ; -----------------------------------------------------------------
  3250                                  
  3251                                  ; 04/11/2022	
  3252                                  ; -----------------------------------------------------------------	
  3253                                  ; NOTE:
  3254                                  ; Microsoft dos programmers were calling 'IO.SYS' as dos 'BIOS'
  3255                                  ; (Also, they were calling 'ROMBIOS' as 'ROM' only!)
  3256                                  ; -----------------------------------------------------------------
  3257                                  
  3258                                  ; ----------------------------------------------------------------------------
  3259                                  ; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3260                                  ; ----------------------------------------------------------------------------
  3261                                  ; ----------------------------------------------------------------------------
  3262                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  3263                                  ; ----------------------------------------------------------------------------
  3264                                  
  3265                                  ;-----------------------------------------------------------------------------
  3266                                  ; Start of (PCDOS 7.1) IBMDOS.COM
  3267                                  ;-----------------------------------------------------------------------------
  3268                                  
  3269                                  ;segment .code vstart=3DD0h ; 06/12/2022
  3270                                  ; 29/09/2023
  3271                                  ;segment .code vstart=3DE0h ; 19/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.22)
  3272                                  ; ----------------------------------------------------------------------------
  3273                                  ; 01/01/2024
  3274                                  segment .code vstart=3F10h ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1)
  3275                                  								
  3276                                  ; ============================================================================
  3277                                  
  3278                                  ;[ORG 3DE0h]
  3279                                  
  3280                                  ;[ORG _PARASTART_]     ; [org 136Ah]
  3281                                  
  3282                                  ;[ORG 1370h] ; 25/05/2019 - Retro DOS v4.0
  3283                                  
  3284                                  ; 01/01/2024 - Retro DOS v5.0 
  3285                                  ;[ORG 3F10h] 
  3286                                  
  3287                                  	; 05/12/2022 - RetroDOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3288                                  	;PARASTART equ 3DD0h ; BIOSDATASTART+BIOSDATASIZE
  3289                                  			     ; +BIOSCODESIZE+DOSDATASIZE (rounded up)
  3290                                  	
  3291                                  	; 29/09/2023 
  3292                                  	; 19/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
  3293                                  	;PARASTART equ 3DE0h	; (MSDOS 6.22 MSDOS.SYS)
  3294                                  
  3295                                  	; 01/01/2024 - Retro DOS v4.2 (Modified PCDOS 7.1 IBMDOS.COM)
  3296                                  	PARASTART equ 3F10h	; (PCDOS 7.1 IBMDOS.COM)
  3297                                  
  3298                                  	[ORG PARASTART]	
  3299                                  
  3300                                  _$STARTCODE:
  3301                                  
  3302                                  ;PARASTART:
  3303 00000000 E9AC80                          JMP     DOSINIT
  3304                                  
  3305                                  	;dw	PARASTART	; PARASTART = 3DE0h for MSDOS 6.0, 6.22
  3306                                  	; 04/11/2022		; PARASTART = 3DD0h for MSDOS 5.0
  3307 00000003 [0000]                  	dw	_$STARTCODE	; PARASTART = 3F10h for PCDOS 7.1 ; 01/01/2024
  3308                                  
  3309                                  BioDataSeg:
  3310 00000005 7000                    	dw	0070h		; Bios data segment fixed at 70h
  3311                                  
  3312                                  ; DosDSeg is a data word in the DOSCODE segment that is loaded with
  3313                                  ; the segment address of DOSDATA. This is purely an optimization, that
  3314                                  ; allows getting the DOS data segment without going through the 
  3315                                  ; BIOS data segment. It is used by the "getdseg" macro.
  3316                                  
  3317                                  DosDSeg:
  3318 00000007 0000                    	dw	0
  3319                                  	
  3320                                  ;============================================================================
  3321                                  ; MSTABLE.ASM (MSDOS 6.0, 1991)
  3322                                  ;============================================================================
  3323                                  ; 16/07/2018 - Retro DOS 3.0
  3324                                  ; 29/04/2019 - Retro DOS 4.0
  3325                                  
  3326                                  	; (MSDOS version)
  3327                                  	; DOSCODE:3DE9h (MSDOS 6.21, MSDOS.SYS)
  3328                                  	;db	6
  3329                                  	;db	20
  3330                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS) 
  3331                                  	; DOSCODE:3DD9h (MSDOS 5.0, MSDOS.SYS)
  3332                                  	;db	5
  3333                                  	;db	0	
  3334                                  
  3335                                  	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
  3336                                  MSVERS:				; MS-DOS version in hex for $GET_VERSION
  3337 00000009 07                      MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  3338 0000000A 0A                      MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  3339                                  
  3340                                  ;;hkn YRTAB & MONTAB moved to DOSDATA in ms_data.asm
  3341                                  ;	I_am	YRTAB,8,<200,166,200,165,200,165,200,165>   ; [SYSTEM]
  3342                                  ;	I_am	MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> ; [SYSTEM]
  3343                                  
  3344                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
  3345                                  ; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
  3346                                  ;
  3347                                  ;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
  3348                                  ;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 
  3349                                  
  3350                                  ; This is the error code mapping table for INT 21 errors. This table defines
  3351                                  ; those error codes which are "allowed" for each system call. If the error
  3352                                  ; code ABOUT to be returned is not "allowed" for the call, the correct action
  3353                                  ; is to return the "real" error via Extended error, and one of the allowed
  3354                                  ; errors on the actual call.
  3355                                  ;
  3356                                  ; The table is organized as follows:
  3357                                  ;
  3358                                  ;    Each entry in the table is of variable size, but the first
  3359                                  ;       two bytes are always:
  3360                                  ;
  3361                                  ;       Call#,Cnt of bytes following this byte
  3362                                  ;
  3363                                  ; EXAMPLE:
  3364                                  ;       Call 61 (OPEN)
  3365                                  ;
  3366                                  ;       DB      61,5,12,3,2,4,5
  3367                                  ;
  3368                                  ;       61 is the AH INT 21 call value for OPEN.
  3369                                  ;        5 indicates that there are 5 bytes after this byte (12,3,2,4,5).
  3370                                  ;       Next five bytes are those error codes which are "allowed" on OPEN.
  3371                                  ;       The order of these values is not important EXCEPT FOR THE LAST ONE (in
  3372                                  ;       this case 5).  The last value will be the one returned on the call if
  3373                                  ;       the "real" error is not one of the allowed ones.
  3374                                  ;
  3375                                  ; There are a number of calls (for instance all of the FCB calls) for which
  3376                                  ;   there is NO entry.  This means that NO error codes are returned on this
  3377                                  ;   call, so set up an Extended error and leave the current error code alone.
  3378                                  ;
  3379                                  ; The table is terminated by a call value of 0FFh
  3380                                  
  3381                                  ;PUBLIC I21_MAP_E_TAB
  3382                                  	; 10/08/2018
  3383                                  
  3384                                  ; 29/04/2019
  3385                                  ; DOSCODE:3DE9h (MSDOS 6.21, MSDOS.SYS)
  3386                                  ; 04/11/2022
  3387                                  ; DOSCODE:3DDBh	(MSDOS 5.0 MSDOS.SYS)
  3388                                  ; 01/01/2024
  3389                                  ; DOSCODE:3F1Bh	(PCDOS 7.1 IBMDOS.COM)
  3390                                  
  3391                                  I21_MAP_E_TAB:	; LABEL	BYTE
  3392 0000000B 38020102                    DB  INTERNATIONAL,2,error_invalid_function,error_file_not_found
  3393 0000000F 3903030205                  DB  MKDIR,3,error_path_not_found,error_file_not_found,error_access_denied
  3394 00000014 3A041003                    DB  RMDIR,4,error_current_directory,error_path_not_found
  3395 00000018 0205                        DB          error_file_not_found,error_access_denied
  3396 0000001A 3B020203                    DB  CHDIR,2,error_file_not_found,error_path_not_found
  3397 0000001E 3C040302                    DB  CREAT,4,error_path_not_found,error_file_not_found
  3398 00000022 04                          DB          error_too_many_open_files
  3399 00000023 05                          DB          error_access_denied
  3400                                      ; MSDOS 6.0
  3401 00000024 3D0603020C                  DB	OPEN,6,error_path_not_found,error_file_not_found,error_invalid_access
  3402 00000029 04                          DB          error_too_many_open_files
  3403 0000002A 1A05                        DB          error_not_DOS_disk,error_access_denied
  3404                                      ; MSDOS 3.3
  3405                                      ;DB	OPEN,5,error_path_not_found,error_file_not_found,error_invalid_access
  3406                                      ;DB		error_too_many_open_files,error_access_denied
  3407 0000002C 3E0106                      DB  CLOSE,1,error_invalid_handle
  3408 0000002F 3F020605                    DB  READ,2,error_invalid_handle,error_access_denied
  3409 00000033 40020605                    DB  WRITE,2,error_invalid_handle,error_access_denied
  3410 00000037 4103030205                  DB  UNLINK,3,error_path_not_found,error_file_not_found,error_access_denied
  3411 0000003C 42020601                    DB  LSEEK,2,error_invalid_handle,error_invalid_function
  3412 00000040 4304030201                  DB  CHMOD,4,error_path_not_found,error_file_not_found,error_invalid_function
  3413 00000045 05                          DB          error_access_denied
  3414 00000046 44050F0D01                  DB  IOCTL,5,error_invalid_drive,error_invalid_data,error_invalid_function
  3415 0000004B 0605                        DB          error_invalid_handle,error_access_denied
  3416 0000004D 45020604                    DB  XDUP,2,error_invalid_handle,error_too_many_open_files
  3417 00000051 46020604                    DB  XDUP2,2,error_invalid_handle,error_too_many_open_files
  3418                                      ; MSDOS 6.0	
  3419 00000055 47021A0F                    DB  CURRENT_DIR,2,error_not_DOS_disk,error_invalid_drive
  3420                                      ; MSDOS 3.3	
  3421                                      ;DB  CURRENT_DIR,1,error_invalid_drive
  3422 00000059 48020708                    DB  ALLOC,2,error_arena_trashed,error_not_enough_memory
  3423 0000005D 49020709                    DB  DEALLOC,2,error_arena_trashed,error_invalid_block
  3424 00000061 4A03070908                  DB  SETBLOCK,3,error_arena_trashed,error_invalid_block,error_not_enough_memory
  3425 00000066 4B08030102                  DB  EXEC,8,error_path_not_found,error_invalid_function,error_file_not_found
  3426 0000006B 040B0A                      DB          error_too_many_open_files,error_bad_format,error_bad_environment
  3427 0000006E 0805                        DB          error_not_enough_memory,error_access_denied
  3428 00000070 4E03030212                  DB  FIND_FIRST,3,error_path_not_found,error_file_not_found,error_no_more_files
  3429 00000075 4F0112                      DB  FIND_NEXT,1,error_no_more_files
  3430                                      ; MSDOS 6.0
  3431 00000078 5605110302                  DB  RENAME,5,error_not_same_device,error_path_not_found,error_file_not_found
  3432 0000007D 1005                        DB		error_current_directory,error_access_denied
  3433                                      ; MSDOS 3.3
  3434                                      ;DB  RENAME,4,error_not_same_device,error_path_not_found,error_file_not_found
  3435                                      ;DB		error_access_denied
  3436                                      ; MSDOS 6.0	
  3437 0000007F 57040608                    DB  FILE_TIMES,4,error_invalid_handle,error_not_enough_memory
  3438 00000083 0D01                        DB		error_invalid_data,error_invalid_function
  3439                                      ; MSDOS 3.3	
  3440                                      ;DB  FILE_TIMES,2,error_invalid_handle,error_invalid_function
  3441 00000085 580101                      DB  ALLOCOPER,1,error_invalid_function
  3442 00000088 5A040302                    DB  CREATETEMPFILE,4,error_path_not_found,error_file_not_found
  3443 0000008C 0405                        DB          error_too_many_open_files,error_access_denied
  3444 0000008E 5B055003                    DB  CREATENEWFILE,5,error_file_exists,error_path_not_found
  3445 00000092 020405                      DB          error_file_not_found,error_too_many_open_files,error_access_denied
  3446 00000095 5C040601                    DB  LOCKOPER,4,error_invalid_handle,error_invalid_function
  3447 00000099 2421                        DB          error_sharing_buffer_exceeded,error_lock_violation
  3448 0000009B 65020102                    DB  GETEXTCNTRY,2,error_invalid_function,error_file_not_found	;DOS 3.3
  3449 0000009F 66020102                    DB  GETSETCDPG,2,error_invalid_function,error_file_not_found        ;DOS 3.3
  3450 000000A3 680106                      DB  COMMIT,1,error_invalid_handle                                   ;DOS 3.3
  3451 000000A6 67030408                    DB  EXTHANDLE,3,error_too_many_open_files,error_not_enough_memory
  3452 000000AA 01                          DB              error_invalid_function
  3453                                      ; MSDOS 6.0		
  3454 000000AB 6C0A                        DB	ExtOpen,10
  3455 000000AD 03020C                      DB	  error_path_not_found,error_file_not_found,error_invalid_access
  3456 000000B0 045008                      DB		error_too_many_open_files,error_file_exists,error_not_enough_memory
  3457 000000B3 1A0D                        DB		error_not_DOS_disk,error_invalid_data
  3458 000000B5 0105                        DB		error_invalid_function,error_access_denied
  3459 000000B7 69040F0D                    DB	GetSetMediaID,4,error_invalid_drive,error_invalid_data
  3460 000000BB 0105                        DB		error_invalid_function,error_access_denied
  3461                                      ; 01/01/2024
  3462                                      ; PCDOS 7.1				
  3463 000000BD 700101                      db	ExtCountryInfo,1,error_invalid_function 
  3464 000000C0 FF                          DB  0FFh
  3465                                  
  3466                                  ;19/09/2023
  3467                                  ;22/12/2022
  3468                                  ;04/11/2022	
  3469                                  ;29/04/2019 - Retro DOS v4.0
  3470                                  ;============================================================================
  3471                                  ; 	Retro DOS v4.0
  3472                                  ;============================================================================
  3473 000000C1 00                      	db 	0
  3474                                  RETRODOSMSG:
  3475 000000C2 0D0A                    	db	13,10
  3476                                  	;;;;;db	"Retro DOS v4.0 by Erdogan Tan [2019]"
  3477                                  	;;;;db	"Retro DOS v4.0 by Erdogan Tan [2022]"
  3478                                  	;;;db	"Retro DOS v4.1 by Erdogan Tan [2022]" ; 28/12/2022
  3479                                  	;;db	"Retro DOS v4.2 by Erdogan Tan [2022]" ; 30/12/2022
  3480                                  	;db	"Retro DOS v4.2 by Erdogan Tan [2023]"
  3481 000000C4 526574726F20444F53-     	db	"Retro DOS v5.0 by Erdogan Tan [2024]" ; 01/01/2024	 
  3481 000000CD 2076352E3020627920-
  3481 000000D6 4572646F67616E2054-
  3481 000000DF 616E205B323032345D 
  3482 000000E8 0D0A2400                	db	13,10,"$", 0 
  3483                                  
  3484                                  ;============================================================================
  3485                                  ; MSTABLE.ASM, MSDOS 6.0, 1991
  3486                                  ;============================================================================
  3487                                  ; 11/07/2018 - Retro DOS v3.0
  3488                                  
  3489                                  	%define short_addr dw  ; 03/03/2018 - Retro DOS v2.0
  3490                                  align 2
  3491                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0E00h
  3492                                  
  3493                                  ; Standard Functions
  3494                                  ;DISPATCH  LABEL WORD
  3495                                  DISPATCH:
  3496                                  	; 16/07/2018 - Retro DOS v3.0
  3497                                  	; (MSDOS 3.3)
  3498                                  
  3499                                  ; 29/04/2019
  3500                                  ; DOSCODE:3E9Eh (MSDOS 6.21, MSDOS.SYS)
  3501                                  
  3502                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3503                                  ; DOSCODE:3E8Eh (MSDOS 5.0, MSDOS.SYS)
  3504                                  
  3505                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  3506                                  ; DOSCODE:3FD2h (PCDOS 7.1, IBMDOS.COM)
  3507                                  
  3508 000000EC [E06B]                          short_addr  _$ABORT			    ;  0      0
  3509 000000EE [421C]                          short_addr  _$STD_CON_INPUT		    ;  1      1
  3510 000000F0 [4B1C]                          short_addr  _$STD_CON_OUTPUT		    ;  2      2
  3511 000000F2 [FD1C]                          short_addr  _$STD_AUX_INPUT		    ;  3      3
  3512 000000F4 [181D]                          short_addr  _$STD_AUX_OUTPUT		    ;  4      4
  3513 000000F6 [1E1D]                          short_addr  _$STD_PRINTER_OUTPUT	    ;  5      5
  3514 000000F8 [891B]                          short_addr  _$RAW_CON_IO		    ;  6      6
  3515 000000FA [B51B]                          short_addr  _$RAW_CON_INPUT		    ;  7      7
  3516 000000FC [6319]                          short_addr  _$STD_CON_INPUT_NO_ECHO	    ;  8      8
  3517 000000FE [BC19]                          short_addr  _$STD_CON_STRING_OUTPUT	    ;  9      9
  3518 00000100 [C819]                          short_addr  _$STD_CON_STRING_INPUT	    ; 10      A
  3519 00000102 [321D]                          short_addr  _$STD_CON_INPUT_STATUS	    ; 11      B
  3520 00000104 [3B1D]                          short_addr  _$STD_CON_INPUT_FLUSH	    ; 12      C
  3521 00000106 [3414]                          short_addr  _$DISK_RESET		    ; 13      D
  3522 00000108 [6F0F]                          short_addr  _$SET_DEFAULT_DRIVE		    ; 14      E
  3523 0000010A [3C24]                          short_addr  _$FCB_OPEN			    ; 15      F
  3524 0000010C [DA1D]                          short_addr  _$FCB_CLOSE			    ; 16     10
  3525 0000010E [5325]                          short_addr  _$DIR_SEARCH_FIRST		    ; 17     11
  3526 00000110 [9925]                          short_addr  _$DIR_SEARCH_NEXT		    ; 18     12
  3527 00000112 [801D]                          short_addr  _$FCB_DELETE		    ; 19     13
  3528 00000114 [9722]                          short_addr  _$FCB_SEQ_READ		    ; 20     14
  3529 00000116 [9B22]                          short_addr  _$FCB_SEQ_WRITE	            ; 21     15
  3530 00000118 [4325]                          short_addr  _$FCB_CREATE		    ; 22     16
  3531 0000011A [461E]                          short_addr  _$FCB_RENAME		    ; 23     17
  3532                                  	; 16/07/2018
  3533                                          ;short_addr _CPMFUNC			    ; 24     18	
  3534 0000011C [8C06]                          short_addr  NO_OP			    ; 24     18
  3535 0000011E [6A0F]                          short_addr  _$GET_DEFAULT_DRIVE		    ; 25     19
  3536 00000120 [5F0F]                          short_addr  _$SET_DMA			    ; 26     1A
  3537                                  
  3538                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3539                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3540                                  ;                                                                          ;
  3541 00000122 [0D13]                          short_addr  _$SLEAZEFUNC		    ; 27     1B
  3542 00000124 [0F13]                          short_addr  _$SLEAZEFUNCDL		    ; 28     1C
  3543                                  ;                                                                          ;
  3544                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3545                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3546                                  
  3547                                          ;short_addr  _CPMFUNC			    ; 29     1D
  3548                                          ;short_addr  _CPMFUNC			    ; 30     1E
  3549                                  
  3550                                  ; 08/07/2018 - Retro DOS v3.0
  3551                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3552                                  
  3553 00000126 [8C06]                  	short_addr  NO_OP			    ; 29     1D
  3554 00000128 [8C06]                  	short_addr  NO_OP			    ; 30     1E
  3555                                  
  3556                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3557                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3558                                  ;                                                                          ;
  3559 0000012A [5A13]                          short_addr  _$GET_DEFAULT_DPB               ; 31     1F
  3560                                  ;                                                                          ;
  3561                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3562                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3563                                          ;short_addr _CPMFUNC			    ; 32     20
  3564                                  
  3565                                  ; 08/07/2018 - Retro DOS v3.0
  3566                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3567                                  
  3568 0000012C [8C06]                  	short_addr  NO_OP			    ; 32     20
  3569                                  
  3570 0000012E [9F22]                          short_addr  _$FCB_RANDOM_READ               ; 33     21
  3571 00000130 [A322]                          short_addr  _$FCB_RANDOM_WRITE              ; 34     22
  3572 00000132 [921D]                          short_addr  _$GET_FCB_FILE_LENGTH	    ; 35     23
  3573 00000134 [681D]                          short_addr  _$GET_FCB_POSITION		    ; 36     24
  3574                                  
  3575                                  ;MAXCALL = ($-DISPATCH)/2 - 1
  3576                                  MAXCALL EQU ($-DISPATCH)/2 - 1
  3577                                  
  3578                                  ; Extended Functions
  3579 00000136 [900F]                          short_addr  _$SET_INTERRUPT_VECTOR	    ; 37     25
  3580                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3581                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3582                                  ;                                                                          ;
  3583 00000138 [6716]                          short_addr  _$CREATE_PROCESS_DATA_BLOCK	    ; 38     26
  3584                                  ;                                                                          ;
  3585                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3586                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3587 0000013A [9322]                          short_addr  _$FCB_RANDOM_READ_BLOCK	    ; 39     27
  3588 0000013C [8F22]                          short_addr  _$FCB_RANDOM_WRITE_BLOCK        ; 40     28
  3589 0000013E [EA12]                          short_addr  _$PARSE_FILE_DESCRIPTOR	    ; 41     29
  3590 00000140 [DA0A]                          short_addr  _$GET_DATE                      ; 42     2A
  3591 00000142 [F70A]                          short_addr  _$SET_DATE                      ; 43     2B
  3592 00000144 [160B]                          short_addr  _$GET_TIME                      ; 44     2C
  3593 00000146 [270B]                          short_addr  _$SET_TIME                      ; 45     2D
  3594 00000148 [DF0C]                          short_addr  _$SET_VERIFY_ON_WRITE           ; 46     2E
  3595                                  
  3596                                  ; Extended functionality group
  3597 0000014A [4C0F]                          short_addr  _$GET_DMA                       ; 47     2F
  3598 0000014C [B60C]                          short_addr  _$GET_VERSION                   ; 48     30
  3599 0000014E [846B]                          short_addr  _$KEEP_PROCESS		    ; 49     31
  3600                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3601                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3602                                  ;                                                                          ;
  3603 00000150 [5C13]                          short_addr  _$GET_DPB			    ; 50     32
  3604                                  ;                                                                          ;
  3605                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3606                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3607 00000152 [3D02]                          short_addr  _$SET_CTRL_C_TRAPPING           ; 51     33
  3608 00000154 [4413]                          short_addr  _$GET_INDOS_FLAG                ; 52     34
  3609 00000156 [810F]                          short_addr  _$GET_INTERRUPT_VECTOR          ; 53     35
  3610 00000158 [1F0F]                          short_addr  _$GET_DRIVE_FREESPACE           ; 54     36
  3611 0000015A [BD0F]                          short_addr  _$CHAR_OPER                     ; 55     37
  3612 0000015C [E60C]                          short_addr  _$INTERNATIONAL                 ; 56     38
  3613                                  ; XENIX CALLS
  3614                                  ;   Directory Group
  3615 0000015E [4628]                          short_addr  _$MKDIR			    ; 57     39
  3616 00000160 [6927]                          short_addr  _$RMDIR			    ; 58     3A
  3617 00000162 [B627]                          short_addr  _$CHDIR			    ; 59     3B
  3618                                  ;   File Group
  3619 00000164 [A279]                          short_addr  _$CREAT			    ; 60     3C
  3620 00000166 [CB78]                          short_addr  _$OPEN			    ; 61     3D
  3621 00000168 [FC70]                          short_addr  _$CLOSE		 	    ; 62     3E
  3622 0000016A [0D72]                          short_addr  _$READ			    ; 63     3F
  3623 0000016C [7372]                          short_addr  _$WRITE			    ; 64     40
  3624 0000016E [F279]                          short_addr  _$UNLINK			    ; 65     41
  3625 00000170 [7872]                          short_addr  _$LSEEK			    ; 66     42
  3626 00000172 [AF79]                          short_addr  _$CHMOD			    ; 67     43
  3627 00000174 [AE28]                          short_addr  _$IOCTL			    ; 68     44
  3628 00000176 [2D73]                          short_addr  _$DUP			    ; 69     45
  3629 00000178 [4B73]                          short_addr  _$DUP2			    ; 70     46
  3630 0000017A [0527]                          short_addr  _$CURRENT_DIR		    ; 71     47
  3631                                  ;   Memory Group
  3632 0000017C [776C]                          short_addr  _$ALLOC			    ; 72     48
  3633 0000017E [F16D]                          short_addr  _$DEALLOC                       ; 73     49
  3634 00000180 [CD6D]                          short_addr  _$SETBLOCK                      ; 74     4A
  3635                                  ;   Process Group
  3636 00000182 [5E65]                          short_addr  _$EXEC			    ; 75     4B
  3637 00000184 [BC6B]                          short_addr  _$EXIT			    ; 76     4C
  3638 00000186 [5465]                          short_addr  _$WAIT			    ; 77     4D
  3639 00000188 [4F26]                          short_addr  _$FIND_FIRST		    ; 78     4E
  3640                                  ;   Special Group
  3641 0000018A [A326]                          short_addr  _$FIND_NEXT			    ; 79     4F
  3642                                  ; SPECIAL SYSTEM GROUP
  3643                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3644                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3645                                  ;                                                                          ;
  3646 0000018C [A202]                          short_addr  _$SET_CURRENT_PDB		    ; 80     50
  3647 0000018E [AE02]                          short_addr  _$GET_CURRENT_PDB               ; 81     51
  3648 00000190 [5013]                          short_addr  _$GET_IN_VARS                   ; 82     52
  3649 00000192 [7B14]                          short_addr  _$SETDPB			    ; 83     53
  3650                                  ;                                                                          ;
  3651                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3652                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3653 00000194 [DA0C]                          short_addr  _$GET_VERIFY_ON_WRITE	    ; 84     54
  3654                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3655                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3656                                  ;                                                                          ;
  3657 00000196 [5616]                          short_addr  _$DUP_PDB                       ; 85     55
  3658                                  ;                                                                          ;
  3659                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3660                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3661 00000198 [187A]                          short_addr  _$RENAME			    ; 86     56
  3662 0000019A [DF72]                          short_addr  _$FILE_TIMES                    ; 87     57
  3663 0000019C [266E]                          short_addr  _$ALLOCOPER                     ; 88     58
  3664                                  
  3665                                  ; 08/07/2018 - Retro DOS v3.0
  3666                                  ; -------------------------------------------------------------------------;
  3667                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3668                                  
  3669                                  ; Network extention system calls
  3670 0000019E [D10F]                          short_addr  _$GetExtendedError              ; 89     59
  3671 000001A0 [A37A]                          short_addr  _$CreateTempFile                ; 90     5A
  3672 000001A2 [8B7A]                          short_addr  _$CreateNewFile                 ; 91     5B
  3673 000001A4 [847C]                          short_addr  _$LockOper                      ; 92     5C
  3674 000001A6 [0C6F]                          short_addr  _$ServerCall                    ; 93     5D
  3675 000001A8 [1574]                          short_addr  _$UserOper                      ; 94     5E
  3676 000001AA [7A73]                          short_addr  _$AssignOper                    ; 95     5F
  3677 000001AC [6678]                          short_addr  _$NameTrans                     ; 96     60
  3678 000001AE [8C06]                  	short_addr  NO_OP			    ; 97     61
  3679 000001B0 [AE02]                          short_addr  _$GET_CURRENT_PDB		    ; 98     62
  3680                                  ; the next call is reserved for hangool sys call
  3681                                  	; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0)
  3682 000001B2 [F10F]                  	short_addr  _$ECS_Call			    ; 99     63
  3683                                  	;short_addr  NO_OP  ;  MSDOS 3.3	    ; 99     63
  3684                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3685                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3686                                  ;                                                                          ;
  3687 000001B4 [BA02]                          short_addr  _$SET_PRINTER_FLAG              ; 100    64
  3688                                  ;                                                                          ;
  3689                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3690                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3691 000001B6 [A30D]                          short_addr  _$GetExtCntry                   ; 101    65
  3692 000001B8 [CD0E]                          short_addr  _$GetSetCdPg                    ; 102    66
  3693 000001BA [4971]                          short_addr  _$ExtHandle                     ; 103    67
  3694 000001BC [2F71]                          short_addr  _$COMMIT                        ; 104    68
  3695                                  
  3696                                  ; 08/07/2018
  3697                                  ; Above system calls are valid for Retro DOS v3.0 (MSDOS 3.3) 
  3698                                  ; Following system calls are valid for Retro DOS v4.0 (MSDOS 6.0)
  3699                                  
  3700                                  ; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0)
  3701 000001BE [5917]                  	short_addr  _$GSetMediaID                   ; 105    69   ;AN000;
  3702 000001C0 [2F71]                  	short_addr  _$COMMIT                        ; 106    6A   ;AN000;
  3703 000001C2 [8C06]                  	short_addr  NO_OP                           ; 107    6B   
  3704                                  						    ; IFS_IOCTL no longer 
  3705                                  						    ; supported
  3706 000001C4 [397B]                  	short_addr  _$Extended_Open                 ; 108    6C   ;AN000;
  3707                                  
  3708                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3709                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3710                                  ;                                                                          ;
  3711                                  ;ifdef ROMEXEC
  3712                                  ;       short_addr  $ROM_FIND_FIRST	   	    ; 109    6D
  3713                                  ;       short_addr  $ROM_FIND_NEXT	   	    ; 110    6E
  3714                                  ;	short_addr  $ROM_EXCLUDE		    ; 111    6F	  ; M078
  3715                                  ;endif
  3716                                  ;                                                                          ;
  3717                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3718                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3719                                  
  3720                                  ; --------------------------------------------------------------------------
  3721                                  
  3722                                  ; 01/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  3723                                  
  3724 000001C6 [8C06]                  	short_addr NO_OP	; 6Dh, OS/2 "DosMkDir2" - ROM DOS: Find first ROM program
  3725 000001C8 [8C06]                  	short_addr NO_OP	; 6Eh, OS/2 "DosEnumAttrib" - ROM DOS: Find next ROM program
  3726 000001CA [8C06]                  	short_addr NO_OP	; 6Fh, OS/2 "DosQMaxEASize" - ROM DOS: Get/set searched ROM area
  3727 000001CC [690D]                  	short_addr _$ExtCountryInfo ; 70h, MSDOS 7 (WIN 95) - Get/set extended country information
  3728                                  				; GET/SET INTERNATIONALIZATION INFORMATION
  3729 000001CE [0C10]                  	short_addr _$LONGNAME	; 71h, MSDOS 7 (WIN 95) LONG FILENAME FUNCTIONS
  3730 000001D0 [0C10]                  	short_addr _$LONGNAME	; 72h, MSDOS 7 (WIN 95) LFN-FindClose
  3731 000001D2 [1910]                  	short_addr _$FAT32EXT	; 73h, MSDOS 7 - FAT32 extended drive functions
  3732                                  
  3733                                  ;MAXCOM  = ($-DISPATCH)/2 - 1
  3734                                  
  3735                                  MAXCOM  EQU ($-DISPATCH)/2 - 1
  3736                                  
  3737                                  ; 08/07/2018 - Retro DOS v3.0
  3738                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3739                                  
  3740                                  ;	If Installed
  3741                                  
  3742                                  align 2
  3743                                  
  3744                                  ;PUBLIC FOO
  3745                                  
  3746                                  FOO:	; LABEL WORD
  3747 000001D4 [4907]                          short_addr Leave2F
  3748                                  
  3749 000001D6 [D801]                  DTab:	DW DOSTable
  3750                                  
  3751                                  	;PUBLIC FOO,DTAB
  3752                                  
  3753                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0ED6h
  3754                                  
  3755                                  ; 29/04/2019
  3756                                  ; DOSCODE:3F7Ch (MSDOS 6.21, MSDOS.SYS)
  3757                                  
  3758                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3759                                  ; DOSCODE:3F6Ch (MSDOS 5.0, MSDOS.SYS)
  3760                                  
  3761                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  3762                                  ; DOSCODE:40BEh (PCDOS 7.1, IBMDOS.COM)
  3763                                         
  3764                                  DOSTable:  ; LABEL  WORD
  3765 000001D8 32                              DB	(DOSTableEnd-DOSTable-1)/2 ; db 50 ; 01/01/2024 
  3766 000001D9 [BB09]                          short_addr  DOSInstall          ;   0 install check
  3767 000001DB [4537]                          short_addr  DOS_CLOSE           ;   1   DOS_CLOSE
  3768 000001DD [B20F]                          short_addr  RECSET              ;   2   RECSET
  3769 000001DF [B509]                          short_addr  DosGetGroup         ;   3   Get DOSGROUP
  3770 000001E1 [4F5A]                          short_addr  PATHCHRCMP          ;   4   PATHCHRCMP
  3771 000001E3 [4D1C]                          short_addr  OUTT                ;   5   OUT
  3772 000001E5 [255D]                          short_addr  NET_I24_ENTRY       ;   6   NET_I24_ENTRY
  3773 000001E7 [D262]                          short_addr  PLACEBUF            ;   7   PLACEBUF
  3774 000001E9 [AD38]                          short_addr  FREE_SFT            ;   8   FREE_SFT
  3775 000001EB [9764]                          short_addr  BUFWRITE            ;   9   BUFWRITE
  3776 000001ED [387D]                          short_addr  SHARE_VIOLATION     ;   10  SHARE_VIOLATION
  3777 000001EF [2233]                          short_addr  SHARE_ERROR         ;   11  SHARE_ERROR
  3778 000001F1 [0C33]                          short_addr  SET_SFT_MODE        ;   12  SET_SFT_MODE
  3779 000001F3 [6C0B]                          short_addr  DATE16              ;   13  DATE16
  3780 000001F5 [FC17]                          short_addr  Idle		;   14      empty slot
  3781 000001F7 [CB62]                          short_addr  SCANPLACE           ;   15  SCANPLACE
  3782 000001F9 [FC17]                          short_addr  Idle		;   16      empty slot
  3783 000001FB [C917]                          short_addr  StrCpy              ;   17  StrCpy
  3784 000001FD [E117]                          short_addr  StrLen              ;   18  StrLen
  3785 000001FF [FA59]                          short_addr  UCase		;   19  UCase
  3786 00000201 [0F63]                          short_addr  POINTCOMP           ;   20  POINTCOMP
  3787 00000203 [6E64]                          short_addr  CHECKFLUSH          ;   21  CHECKFLUSH
  3788 00000205 [7770]                          short_addr  SFFromSFN           ;   22  SFFromSFN
  3789 00000207 [DA74]                          short_addr  GetCDSFromDrv       ;   23  GetCDSFromDrv
  3790 00000209 [7704]                          short_addr  Get_User_Stack      ;   24  Get_User_Stack
  3791 0000020B [8574]                          short_addr  GETTHISDRV          ;   25  GetThisDrv
  3792 0000020D [8B78]                          short_addr  DriveFromText       ;   26  DriveFromText
  3793 0000020F [130C]                          short_addr  SETYEAR             ;   27  SETYEAR
  3794 00000211 [AC0C]                          short_addr  DSUM                ;   28  DSUM
  3795 00000213 [090C]                          short_addr  DSLIDE              ;   29  DSLIDE
  3796 00000215 [A717]                          short_addr  StrCmp              ;   30  StrCmp
  3797 00000217 [C873]                          short_addr  InitCDS             ;   31  initcds
  3798 00000219 [4470]                          short_addr  pJFNFromHandle      ;   32  pJfnFromHandle
  3799 0000021B [6678]                          short_addr  _$NameTrans		;   33  $NameTrans
  3800 0000021D [B306]                          short_addr  CAL_LK              ;   34  CAL_LK
  3801 0000021F [884B]                          short_addr  DEVNAME             ;   35  DEVNAME
  3802 00000221 [FC17]                          short_addr  Idle                ;   36  Idle
  3803 00000223 [EF17]                          short_addr  DStrLen             ;   37  DStrLen
  3804 00000225 [9E18]                          short_addr  NLS_OPEN            ;   38  NLS_OPEN      DOS 3.3
  3805 00000227 [FC70]                          short_addr  _$CLOSE		;   39  $CLOSE        DOS 3.3
  3806 00000229 [A418]                          short_addr  NLS_LSEEK           ;   40  NLS_LSEEK     DOS 3.3
  3807 0000022B [0D72]                          short_addr  _$READ		;   41  $READ         DOS 3.3
  3808 0000022D [6018]                          short_addr  FastInit            ;   42  FastInit      DOS 3.4  ;AN000;
  3809 0000022F [E118]                          short_addr  NLS_IOCTL           ;   43  NLS_IOCTL     DOS 3.3
  3810 00000231 [D018]                          short_addr  GetDevList          ;   44  GetDevList    DOS 3.3
  3811 00000233 [FE18]                          short_addr  NLS_GETEXT          ;   45  NLS_GETEXT    DOS 3.3
  3812                                          
  3813                                  	; 29/04/2019 - Retro DOS v4.0
  3814 00000235 [0219]                  	short_addr  MSG_RETRIEVAL	;   46  MSG_RETRIEVAL DOS 4.0  ;AN000;
  3815                                  
  3816 00000237 [8C06]                  	short_addr  NO_OP		;   M006: 47  no longer supported
  3817                                  ;*** 	short_addr  Fake_Version	;   47  Fake_Version  DOS 4.0  ;AN006;
  3818                                  
  3819                                  	; -------------------------------
  3820                                  
  3821                                  	; 01/01/2024 - Retro DOS v5.0 (PCDOS 7.1)
  3822 00000239 [D248]                  	short_addr  int_2Fh_1230h	;   48
  3823                                  				; FIND SFT ENTRY IN INTERNAL FILE TABLES
  3824 0000023B [6E09]                  	short_addr  int_2Fh_1231h	;   49
  3825                                  				; SET/CLEAR REPORT WINDOWS TO DOS PROGRAMS FLAG	
  3826                                  
  3827                                  DOSTableEnd:  ; LABEL BYTE
  3828                                  
  3829                                  	;ENDIF
  3830                                  
  3831                                  ; ----------------------------------------------------------------------------
  3832                                  ; BREAK   <Copyright notice and version>
  3833                                  ; ----------------------------------------------------------------------------
  3834                                  
  3835                                  ;CODSTRT EQU	$
  3836                                  
  3837                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
  3838                                  ; (MSTABLE.ASM, MSDOS 6.0, 1991)
  3839                                  
  3840                                  ; NOTE WARNING: This declaration of HEADER must be THE LAST thing in this
  3841                                  ;       module. The reason is so that the data alignments are the same in
  3842                                  ;       IBM-DOS and MS-DOS up through header.
  3843                                  
  3844                                  	;PUBLIC	HEADER
  3845                                  
  3846                                  HEADER:	; LABEL	BYTE
  3847                                          ;IF	DEBUG
  3848                                          ;DB	13,10,"Debugging DOS version "
  3849                                          ;DB	MAJOR_VERSION + "0"
  3850                                          ;DB	"."
  3851                                          ;DB	(MINOR_VERSION / 10) + "0"
  3852                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  3853                                          ;ENDIF
  3854                                  
  3855                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3856                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
  3857                                  %if 0
  3858                                          ;IF	NOT IBM
  3859                                          DB	13,10,"MS-DOS version "
  3860                                          DB	MAJOR_VERSION + "0"
  3861                                          DB	"."
  3862                                          DB	(MINOR_VERSION / 10) + "0"
  3863                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  3864                                          DB	(MINOR_VERSION % 10) + "0"
  3865                                  
  3866                                          ;IF	HIGHMEM
  3867                                          ;DB	"H"
  3868                                          ;ENDIF
  3869                                  
  3870                                  	;DB	13,10,"Copyright 1981,82,83,84,88 Microsoft Corp.",13,10,"$"
  3871                                  	; 30/04/2019 - Retro DOS v4.0
  3872                                  	DB	13,10,"Copyright 1981-1993 Microsoft Corp.",13,10,"$"	
  3873                                  
  3874                                  	;ENDIF
  3875                                  
  3876                                  %endif
  3877                                  
  3878                                  ;IF DEBUG
  3879                                  ;	DB	13,10,"$"
  3880                                  ;ENDIF
  3881                                  
  3882                                  ;include copyrigh.inc
  3883                                  
  3884                                  ; DOSCODE:3FDDh (MSDOS 6.21, MSDOS.SYS)
  3885                                  
  3886                                  	;DB	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
  3887                                  	;DB	"Licensed Material - Property of Microsoft "
  3888                                  	;DB	"All rights reserved "
  3889                                  
  3890                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3891                                  ; DOSCODE:3FCDh (MSDOS 5.0, MSDOS.SYS)
  3892                                  
  3893                                  ; 28/12/2022 - Retro DOS v4.1
  3894                                  %if 0
  3895                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  3896                                  ms_copyright:
  3897                                  	db	'MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp '
  3898                                  	db	'Licensed Material - Property of Microsoft '
  3899                                  	db	'All rights reserved '
  3900                                  
  3901                                  %endif
  3902                                  	;; 28/12/2022 - Retro DOS v4.1
  3903                                  ;ms_copyright:	
  3904                                    	;db	13,10,"MS DOS Version 5.0"
  3905                                  	;db	13,10,"Copyright 1981-1991 Microsoft Corp.",13,10,"$",0	
  3906                                  
  3907                                  ;	; 21/09/2023 - Retro DOS v4.2 MSDOS.SYS
  3908                                  ;	; (MSDOS 6.22 MSDOS.SYS - DOSCODE:3FDDh (File offset: 509))
  3909                                  ;ms_copyright:
  3910                                  ;	db 'MS DOS Version 6 (C)Copyright 1981-1994 Microsoft Corp '
  3911                                  ;	db 'Licensed Material - Property of Microsoft All rights reserved '
  3912                                  
  3913                                  	; 01/01/2024 - Retro DOS v5.0
  3914                                  	
  3915                                  	; 20/09/2023 - Retro DOS v4.2
  3916                                  ;ms_copyright:	
  3917                                  	;db	13,10,"MS DOS Version 6.22"
  3918                                  	;db	13,10,"Copyright 1981-1994 Microsoft Corp.",13,10,"$",0	
  3919                                  
  3920                                  ;============================================================================
  3921                                  ; MSCODE.ASM
  3922                                  ;============================================================================
  3923                                  
  3924                                  ; Retro DOS v2.0 (NASM 2.11) source code modifications by Erdogan Tan
  3925                                  ; 03/03/2018
  3926                                  
  3927                                  ;
  3928                                  ; MSCODE.ASM -- MSDOS code
  3929                                  ;
  3930                                  
  3931                                  ;INCLUDE DOSSEG.ASM
  3932                                  ;INCLUDE STDSW.ASM
  3933                                  
  3934                                  ;CODE    SEGMENT BYTE PUBLIC  'CODE'
  3935                                  ;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  3936                                  
  3937                                  ;.xcref
  3938                                  ;INCLUDE DOSSYM.ASM
  3939                                  ;INCLUDE DEVSYM.ASM
  3940                                  ;.cref
  3941                                  ;.list
  3942                                  
  3943                                  ;IFNDEF  KANJI
  3944                                  ;KANJI   EQU     0       ; FALSE
  3945                                  ;ENDIF
  3946                                  
  3947                                  ;IFNDEF  IBM
  3948                                  ;IBM     EQU     0
  3949                                  ;ENDIF
  3950                                  
  3951                                  ;IFNDEF  HIGHMEM
  3952                                  ;HIGHMEM  EQU     0
  3953                                  ;ENDIF
  3954                                  
  3955                                          ;i_need  USER_SP,WORD
  3956                                          ;i_need  USER_SS,WORD
  3957                                          ;i_need  SAVEDS,WORD
  3958                                          ;i_need  SAVEBX,WORD
  3959                                          ;i_need  INDOS,BYTE
  3960                                          ;i_need  NSP,WORD
  3961                                          ;i_need  NSS,WORD
  3962                                          ;i_need  CURRENTPDB,WORD
  3963                                          ;i_need  AUXSTACK,BYTE
  3964                                          ;i_need  CONSWAP,BYTE
  3965                                          ;i_need  IDLEINT,BYTE
  3966                                          ;i_need  NOSETDIR,BYTE
  3967                                          ;i_need  ERRORMODE,BYTE
  3968                                          ;i_need  IOSTACK,BYTE
  3969                                          ;i_need  WPERR,BYTE
  3970                                          ;i_need  DSKSTACK,BYTE
  3971                                          ;i_need  CNTCFLAG,BYTE
  3972                                          ;i_need  LEAVEADDR,WORD
  3973                                          ;i_need  NULLDEVPT,DWORD
  3974                                  
  3975                                          ;IF NOT IBM
  3976                                          ;i_need  OEM_HANDLER,DWORD
  3977                                          ;ENDIF
  3978                                  
  3979                                          ;EXTRN   DSKSTATCHK:NEAR,GETBP:NEAR,DSKREAD:NEAR,DSKWRITE:NEAR
  3980                                  
  3981                                  ;============================================================================
  3982                                  ; MSDISP.ASM, MSDOS 6.0, 1991
  3983                                  ;============================================================================
  3984                                  ; 11/07/2018 - Retro DOS v3.0
  3985                                  ; 01/05/2019 - Retro DOS v4.0
  3986                                  
  3987                                  ; DosCode SEGMENT
  3988                                  
  3989                                  ; ==========================================================================
  3990                                  ;
  3991                                  ; $Set_CTRL_C_Trapping
  3992                                  ;
  3993                                  ; Function:
  3994                                  ;	Enable disable ^C checking in dispatcher
  3995                                  ;
  3996                                  ; Inputs:
  3997                                  ;		AL = 0 read ^C status
  3998                                  ;		AL = 1 Set ^C status, DL = 0/1 for ^C off/on
  3999                                  ;		AL = 2 Set ^C status to contents of DL.	Output is old state.
  4000                                  ;		AL = 5 get DOS boot drive
  4001                                  ;		AL = 6 Get version number
  4002                                  ;			RETURNS:
  4003                                  ;				BH = Minor version number
  4004                                  ;				BL = Major version number
  4005                                  ;				DL = DOS internal revision
  4006                                  ;				DH = DOS type flags
  4007                                  ;					Bit 3 	- DOS in ROM
  4008                                  ;					Bit 4 	- DOS in HMA
  4009                                  ;					Bit 0-2, 5-7 - Reserved
  4010                                  ; Outputs:
  4011                                  ;		If AL = 0 then DL = 0/1 for ^C off/on
  4012                                  ;
  4013                                  ; History:
  4014                                  ;      removed	AL = 3 Get CPSW state to DL	    DOS 3.4
  4015                                  ;      removed	AL = 4 Set CPSW state from DL	    DOS 3.4
  4016                                  ; ==========================================================================
  4017                                  
  4018                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4019                                  ; DOSCODE:4045h (MSDOS 5.0, MSDOS.SYS)
  4020                                  
  4021                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  4022                                  ; DOSCODE:4123h (PCDOS 7.1, IBMDOS.COM)
  4023                                  
  4024                                  _$SET_CTRL_C_TRAPPING:
  4025                                  	; 01/05/2019 - Retro DOS v4.0
  4026                                  
  4027 0000023D 3C07                    	cmp	al,7	; 01/01/2024 - Retro DOS v5.0
  4028                                  	;cmp	AL,6			; Is this a valid subfunction?
  4029 0000023F 7603                    	jbe	short scct_1		; If yes continue processing
  4030                                  
  4031 00000241 B0FF                    	mov	AL,0FFh			; Else set AL to -1 and
  4032 00000243 CF                      	iret
  4033                                  scct_1:
  4034 00000244 1E                      	push	DS
  4035                                  
  4036                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4037 00000245 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4038                                  	
  4039 0000024A 50                      	push	AX			; DL only register that can change
  4040 0000024B 56                      	push	SI
  4041                                  
  4042 0000024C BE[3703]                	mov	SI,CNTCFLAG		; DS:SI --> Ctrl C Status byte
  4043 0000024F 30E4                    	xor	AH,AH			; Clear high byte of AX
  4044 00000251 09C0                    	or	AX,AX			; Check for subfunction 0
  4045 00000253 7504                    	jnz	short scct_2		; If not 0 jmp to next check
  4046                                  
  4047 00000255 8A14                    	mov	DL,[SI]			; Else move current ctrl C status
  4048 00000257 EB32                    	jmp	SHORT scct_9s		; into DL and jmp to exit
  4049                                  scct_2:
  4050 00000259 48                      	dec	AX			; Now dec AX and see if it was 1
  4051 0000025A 7507                    	jnz	short scct_3		; If not 0 it wasn't 1 so do next chk
  4052                                  
  4053 0000025C 80E201                  	and	DL,1			; Else mask off bit 0 of DL and
  4054 0000025F 8814                    	mov	[SI],DL			; save it as new Ctrl C status
  4055 00000261 EB28                    	jmp	SHORT scct_9s		; Jmp to exit
  4056                                  scct_3:
  4057 00000263 48                      	dec	AX			; Dec AX again to see if it was 2
  4058 00000264 7507                    	jnz	short scct_4		; If not 0 wasn't 2 so go to next chk
  4059                                  
  4060 00000266 80E201                  	and	DL,1			; Else mask off bit 0 of DL and
  4061 00000269 8614                    	xchg	[SI],DL			; Exchange DL with old status byte
  4062 0000026B EB1E                    	jmp	SHORT scct_9s		; Jump to exit (returning old status)
  4063                                  scct_4:
  4064 0000026D 3C03                    	cmp	al,3 ; 01/01/2024
  4065                                  	;cmp	AX,3 			; Test for 5 after it was dec twice
  4066 0000026F 7506                    	jne	short scct_5		; If not equal then not get boot drv
  4067 00000271 8A16[6900]              	mov	DL,[BOOTDRIVE]		; Else return boot drive in DL
  4068 00000275 EB14                    	jmp	SHORT scct_9s		; Jump to exit (returning boot drive)
  4069                                  scct_5:
  4070                                  	; 01/01/2024 - Retro DOS v5.0
  4071 00000277 7212                    	jb	short scct_9s ; PCDOS 7.1
  4072                                  	;
  4073 00000279 3C04                    	cmp	al,4 ; 01/01/2024
  4074                                  	;cmp	AX,4 			; Test for 6 after it was dec twice
  4075                                  	;jne	short scct_9s		; If not equal then not get version
  4076 0000027B 7512                    	jne	short scct_6 ; 01/01/2024 ; PCDOS 7.1	
  4077                                  
  4078                                  	;mov	BX,(Minor_Version SHL 8) + Major_Version
  4079                                  
  4080                                  	;;mov	bx,1406h ; 6.20	; DOSCODE:4092h (MSDOS 6.21, MSDOS.SYS)
  4081                                  	;;mov	bx,1606h ; 6.22	; DOSCODE:4092h (MSDOS 6.22, MSDOS.SYS)
  4082                                  
  4083                                  	;mov	bx,0A07h ; 7.10	; DOSCODE:4163h (PCDOS 7.1, IMBDOS.COM)
  4084 0000027D BB070A                  	mov	bx,(MINOR_VERSION<<8)+MAJOR_VERSION  ; true dos version
  4085                                  	
  4086                                  	;mov	dl,0			; revision 0
  4087                                  	;mov	DL,DOSREVNM ; 0
  4088                                  
  4089                                  	;xor	dh,dh			; assume vanilla DOS
  4090                                  	; 01/01/2024
  4091 00000280 BA0000                  	mov	dx,0	
  4092 00000283 3836[870D]              	cmp	byte [DosHasHMA],dh ; 0
  4093                                  	;cmp	byte [DosHasHMA],0	; is DOS in HMA?  (M021)
  4094                                  	;;je	short @F
  4095                                  	;je	short scct_6
  4096 00000287 7402                    	je	short scct_9s ; 01/01/2024	
  4097                                  	; 01/01/2024
  4098 00000289 B610                    	mov	dh,10h			; version flags bit 4
  4099                                  	;or	DH,DOSINHMA ; 10h	; 'DOS in HMA' status
  4100                                  ;@@:
  4101                                  ;scct_6:
  4102                                  ;ifdef ROMDOS
  4103                                  ;	or	DH,DOSINROM ; 08h
  4104                                  ;endif ; ROMDOS
  4105                                  
  4106                                  	; 01/01/2024 (PCDOS 7.1)
  4107                                  	;jmp	short short scct_9s
  4108                                  
  4109                                  	; 01/01/2024
  4110                                  ;scct_6:
  4111                                  	; ....
  4112                                  
  4113                                  scct_9s:
  4114 0000028B 5E                      	pop	SI
  4115 0000028C 58                      	pop	AX
  4116 0000028D 1F                      	pop	DS
  4117                                  scct_9f:
  4118 0000028E CF                      	iret
  4119                                  
  4120                                  	; 01/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  4121                                  scct_6:
  4122 0000028F 8026[8600]DF            	and	byte [DOS_FLAG],0DFh	; clear bit 5 of DOS flag
  4123 00000294 80FA01                  	cmp	dl, 1
  4124 00000297 75F2                    	jne	short scct_9s
  4125 00000299 800E[8600]20            	or	byte [DOS_FLAG],20h	; set bit 5 of DOS flag
  4126 0000029E EBEB                    	jmp	short scct_9s
  4127                                  
  4128                                  SetCtrlShortEntry:			; This allows a conditional entry
  4129                                  					; from main dispatch code
  4130 000002A0 EB9B                    	jmp	SHORT _$SET_CTRL_C_TRAPPING
  4131                                  
  4132                                  ; ==========================================================================
  4133                                  ;
  4134                                  ; The following two routines are dispatched to directly with ints disabled
  4135                                  ; immediately after the int 21h entry.	no DIS state is set.
  4136                                  ;
  4137                                  ; $Set_current_PDB takes BX and sets it to be the current process
  4138                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  4139                                  ;
  4140                                  ; ==========================================================================
  4141                                  
  4142                                  _$SET_CURRENT_PDB:
  4143 000002A2 1E                      	push	DS
  4144                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4145 000002A3 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4146 000002A8 891E[3003]              	mov	[CurrentPDB],BX		; Set new PSP segment from caller's BX
  4147 000002AC 1F                      	pop	DS
  4148 000002AD CF                      	iret
  4149                                  
  4150                                  ; ==========================================================================
  4151                                  ;
  4152                                  ; $get_current_PDB returns in BX the current process
  4153                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  4154                                  ;
  4155                                  ; ==========================================================================
  4156                                  
  4157                                  _$GET_CURRENT_PDB:
  4158 000002AE 1E                      	push	DS
  4159                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4160 000002AF 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4161 000002B4 8B1E[3003]              	mov	BX,[CurrentPDB]		; Return current PSP segment in BX
  4162 000002B8 1F                      	pop	DS
  4163 000002B9 CF                      	iret
  4164                                  
  4165                                  ; ==========================================================================
  4166                                  ;
  4167                                  ; Sets the Printer Flag to whatever is in AL.
  4168                                  ; NOTE: THIS PROCEDURE IS SUBJECT TO CHANGE!!!
  4169                                  ;
  4170                                  ; ==========================================================================
  4171                                  
  4172                                  _$SET_PRINTER_FLAG:
  4173 000002BA 1E                      	push	ds
  4174                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4175 000002BB 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4176 000002C0 A2[A00A]                	mov	[PRINTER_FLAG],AL 	; Set printer flag from caller's AL
  4177 000002C3 1F                      	pop	ds
  4178 000002C4 CF                      	iret
  4179                                  
  4180                                  ; 01/05/2019 - Retro DOS v4.0
  4181                                  ; 08/07/2018 - Retro DOS v3.0
  4182                                  ; (MSDISP.ASM, MSDOS 6.0, 1991)
  4183                                  
  4184                                  ; ----------------------------------------------------------------------------
  4185                                  ; BREAK   <System call entry points and dispatcher>
  4186                                  ; ----------------------------------------------------------------------------
  4187                                  
  4188                                  ; DOSCODE:40CCh (MSDOS 6.21, MSDOS.SYS)
  4189                                  
  4190                                  ; ==========================================================================
  4191                                  ;
  4192                                  ; The Quit entry point is where all INT 20h's come from. These are old- style
  4193                                  ; exit system calls. The CS of the caller indicates which Process is dying.
  4194                                  ; The error code is presumed to be 0. We simulate an ABORT system call.
  4195                                  ;
  4196                                  ; ==========================================================================
  4197                                  
  4198                                  SYSTEM_CALL:    ; PROC NEAR
  4199                                  
  4200                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4201                                  ; DOSCODE:40BFh (MSDOS 5.0, MSDOS.SYS)
  4202                                  
  4203                                  ;entry	QUIT				
  4204                                  QUIT:				; INT 20H entry point	
  4205                                  	;MOV	AH,0
  4206 000002C5 30E4                    	xor	ah,ah ; 08/07/2018
  4207 000002C7 EB36                    	JMP     SHORT SAVREGS
  4208                                  
  4209                                  ; ---------------------------------------------------------------------------
  4210                                  
  4211                                  	; The system call in AH is out of the range that we know how
  4212                                  	; to handle. We arbitrarily set the contents of AL to 0 and
  4213                                  	; IRET. Note that we CANNOT set the carry flag to indicate an
  4214                                  	; error as this may break some programs compatability.
  4215                                  
  4216                                  BADCALL:
  4217                                          ;MOV	AL,0
  4218 000002C9 30C0                    	xor	al,al ; 08/07/2018
  4219                                  IRETT:	; 06/05/2019
  4220                                  _IRET:
  4221 000002CB CF                              IRET
  4222                                  
  4223                                  ; ---------------------------------------------------------------------------
  4224                                  
  4225                                  ; 01/05/2019 - Retro DOS v4.0
  4226                                  ; DOSCODE:40D3h (MSDOS 6.21 MSDOS.SYS)
  4227                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4228                                  ; DOSCODE:40C6h (MSDOS 5.0 MSDOS.SYS)
  4229                                  
  4230                                  	; An alternative method of entering the system is to perform a
  4231                                  	; CALL 5 in the program segment prefix with the contents of CL
  4232                                  	; indicating what system call the user would like. A subset of
  4233                                  	; the possible system calls is allowed here only the
  4234                                  	; CPM-compatible calls may get dispatched.
  4235                                  
  4236                                  		; System call entry point and dispatcher
  4237                                  CALL_ENTRY:
  4238 000002CC 1E                      	push	DS
  4239                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4240 000002CD 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4241 000002D2 8F06[EC05]              	pop	word [SAVEDS]		; Save original DS
  4242                                  
  4243 000002D6 58                              POP     AX                      ; IP from the long call at 5
  4244 000002D7 58                              POP     AX                      ; Segment from the long call at 5
  4245 000002D8 8F06[8405]              	POP	WORD [USER_SP]		; IP from the CALL 5
  4246                                  
  4247                                  		; Re-order the stack to simulate an interrupt 21.
  4248                                  
  4249 000002DC 9C                      	PUSHF				; Start re-ordering the stack
  4250 000002DD FA                      	CLI
  4251 000002DE 50                              PUSH    AX                      ; Save segment
  4252 000002DF FF36[8405]                      PUSH	WORD [USER_SP]		; Stack now ordered as if INT had been used
  4253                                  	; 04/11/2022
  4254                                  	; DOSCODE:40EAh (MSDOS 6.21 MSDOS.SYS)
  4255                                  	; DOSCODE:40DDh (MSDOS 5.0 MSDOS.SYS)
  4256 000002E3 FF36[EC05]              	push	word [SAVEDS]
  4257 000002E7 1F                      	pop	ds
  4258                                  	;
  4259                                  	;cmp	cl,36
  4260 000002E8 80F924                          CMP     CL,MAXCALL              ; This entry point doesn't get as many calls
  4261 000002EB 77DC                            JA      SHORT BADCALL
  4262 000002ED 88CC                            MOV     AH,CL
  4263                                  	; 08/07/2018
  4264 000002EF EB0E                    	jmp	short SAVREGS
  4265                                  
  4266                                  ; ---------------------------------------------------------------------------
  4267                                  
  4268                                  ; 01/05/2019 - Retro DOS v4.0
  4269                                  ; 01/01/2024 - Retro DOS v5.0
  4270                                  
  4271                                  	; This is the normal INT 21 entry point. We first perform a
  4272                                  	; quick test to see if we need to perform expensive DOS-entry
  4273                                  	; functions. Certain system calls are done without interrupts
  4274                                  	; being enabled.
  4275                                  
  4276                                  	;entry	COMMAND 		; Interrupt call entry point (int 21h)
  4277                                  
  4278                                  ; DOSCODE:40F8h (MSDOS 6.21, MSDOS.SYS)
  4279                                  ; 04/11/2022
  4280                                  ; DOSCODE:40EBh (MSDOS 5.0, MSDOS.SYS)
  4281                                  ; 01/01/2024
  4282                                  ; DOSCODE:41D7h (PCDOS 7.1, IBMDOS.COM)
  4283                                  
  4284                                  COMMAND:
  4285                                  	; 22/12/2022
  4286 000002F1 FA                      	cli
  4287                                  
  4288                                  	; 01/05/2019 - Retro DOS v4.0
  4289                                  	; 08/07/2018 - Retro DOS v3.0
  4290                                  
  4291                                  ; 22/12/2022
  4292                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4293                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  4294                                  
  4295                                  	;IF	NOT IBM
  4296 000002F2 80FCF8                  	CMP	AH,SET_OEM_HANDLER
  4297 000002F5 7203                    	JB	SHORT NOTOEM
  4298 000002F7 E98701                  	JMP	_$SET_OEM_HANDLER
  4299                                  
  4300                                  NOTOEM:
  4301                                  	;ENDIF
  4302                                  
  4303                                  ; DOSCODE:40F8h (MSDOS 6.21, MSDOS.SYS)
  4304                                  ; DOSCODE:40EBh (MSDOS 5.0, MSDOS.SYS)
  4305                                  ; 01/01/2024 - Retro DOS v5.0
  4306                                  ; DOSCODE:41D7h (PCDOS 7.1, IBMDOS.COM)
  4307                                  
  4308                                  	; 22/12/2022
  4309                                  	;cli	; 08/07/2018
  4310                                  	
  4311                                  	; 01/01/2024
  4312                                  _COMMAND: ; MSDOS 3.3 (IBMDOS)
  4313                                  	;;cmp	ah,6Ch  ; MSDOS 6.21
  4314                                  	;cmp	ah,73h	; PCDOS 7.1 ; Max int 21h function call number 
  4315                                  	; 04/11/2022
  4316 000002FA 80FC73                  	CMP     AH,MAXCOM ; 6Ch for MSDOS 6.0 (6.21,6.22) & MSDOS 5.0
  4317                                  			; 73h for PCDOS 7.1	
  4318                                  	;JBE	SHORT SAVREGS
  4319 000002FD 77CA                            JA	SHORT BADCALL ; 08/07/2018
  4320                                  
  4321                                  	; 31/05/2019
  4322                                  
  4323                                  	; The following set of calls are issued by the server at
  4324                                  	; *arbitrary* times and, therefore, must be executed on
  4325                                  	; the user's entry stack and executed with interrupts off.
  4326                                  
  4327                                  SAVREGS:
  4328                                  	; 01/05/2019 - Retro DOS v4.0
  4329                                  	; 10/08/2018
  4330                                  	; 08/07/2018 - Retro DOS v3.0
  4331 000002FF 80FC33                  	cmp	ah,33h			; Check Minimum special case #
  4332                                  	;;je	_$SET_CTRL_C_TRAPPING
  4333                                  	;je	short SetCtrlShortEntry ; If equal jmp directly to function
  4334 00000302 7218                    	jb	short SaveAllRegs	; Not special case so continue	
  4335                                  	; 04/11/2022
  4336 00000304 749A                    	je	short SetCtrlShortEntry ; If equal jmp directly to function
  4337 00000306 80FC64                  	cmp	ah,64h			; Check Max case number
  4338 00000309 7711                    	ja	short SaveAllRegs	; Not special case so continue
  4339 0000030B 74AD                    	je	short _$SET_PRINTER_FLAG ; If equal jmp directly to function
  4340 0000030D 80FC51                  	cmp	ah,51h			; Is this a Get PSP call (51h)?
  4341 00000310 749C                    	je	short _$GET_CURRENT_PDB	; Yes, jmp directly to function
  4342 00000312 80FC62                  	cmp	ah,62h			; Is this a Get PSP call (62h)?
  4343 00000315 7497                    	je	short _$GET_CURRENT_PDB	; Yes, jmp directly to function
  4344 00000317 80FC50                  	cmp     ah,50h			; Is this a Set PSP call (50h) ?
  4345 0000031A 7486                    	je	short _$SET_CURRENT_PDB	; Yes, jmp directly to function
  4346                                  
  4347                                  SaveAllRegs:
  4348                                  	; 01/05/2019 - Retro DOS v4.0
  4349                                  	; 01/01/2024 - Retro DOS v5.0
  4350                                  
  4351 0000031C 06                              push	ES
  4352 0000031D 1E                      	push	DS
  4353 0000031E 55                      	push	BP
  4354 0000031F 57                      	push	DI
  4355 00000320 56                      	push	SI
  4356 00000321 52                      	push	DX
  4357 00000322 51                      	push	CX
  4358 00000323 53                      	push	BX
  4359 00000324 50                      	push	AX
  4360                                  
  4361 00000325 8CD8                    	mov	AX,DS
  4362                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4363 00000327 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4364 0000032C A3[EC05]                	mov	[SAVEDS],AX		; save caller's DS
  4365 0000032F 891E[EA05]              	mov	[SAVEBX],BX
  4366                                  
  4367                                          ;INC     BYTE [INDOS]		; Flag that we're in the DOS
  4368                                  	
  4369                                  	; 08/07/2018 - Retro DOS v3.0
  4370                                  	;xor     ax,ax
  4371                                  	;mov     [USER_ID],ax
  4372                                  	;mov     ax,[CurrentPDB]
  4373                                  	;mov     [PROC_ID],ax
  4374                                  
  4375                                  	; 01/05/2019
  4376                                  
  4377                                  	; Note: Nsp and Nss have to be unconditionally initialized here 
  4378                                  	; even if InDOS is zero. Programs like CROSSTALK 3.7 depend on
  4379                                  	; this!!!
  4380                                  
  4381 00000333 A1[8405]                	MOV     AX,[USER_SP]
  4382 00000336 A3[F205]                        MOV     [NSP],AX
  4383 00000339 A1[8605]                        MOV     AX,[USER_SS]
  4384 0000033C A3[F005]                        MOV     [NSS],AX
  4385                                  
  4386 0000033F 31C0                    	xor	AX,AX ; 0
  4387 00000341 A2[7205]                	mov	[FSHARING],AL		; allow redirection
  4388                                  
  4389 00000344 F606[A110]01            	test	byte [IsWin386],1	; WIN386 patch. Do not update USER_ID
  4390 00000349 7503                    	jnz	short set_indos_flag	; if win386 present
  4391 0000034B A3[3E03]                	mov	[USER_ID],AX
  4392                                  set_indos_flag:
  4393 0000034E FE06[2103]              	INC     BYTE [INDOS]		; Flag that we're in the DOS
  4394                                  
  4395                                  	; 01/01/2024 (PCDOS 7.1 IBMDOS.COM)
  4396 00000352 FE06[DF13]              	inc	byte [INDOS_FLAG]	; duplicated INDOS flag (what for ?)
  4397                                  
  4398 00000356 8926[8405]                      MOV     [USER_SP],SP
  4399 0000035A 8C16[8605]                      MOV     [USER_SS],SS
  4400                                  
  4401 0000035E A1[3003]                	mov	AX,[CurrentPDB]
  4402 00000361 A3[3C03]                	mov	[PROC_ID],AX
  4403 00000364 8ED8                    	mov	DS,AX
  4404 00000366 58                      	pop	AX
  4405 00000367 50                      	push	AX
  4406                                  
  4407                                  	; save user stack in his area for later returns (possibly from EXEC)
  4408                                  
  4409 00000368 89262E00                        MOV     [PDB.USER_STACK],SP	; mov [2Eh], sp
  4410 0000036C 8C163000                        MOV     [PDB.USER_STACK+2],SS	; mov [30h], ss
  4411                                  
  4412                                  	; 18/07/2018
  4413                                  	;mov	byte [CS:FSHARING], 0
  4414                                  
  4415                                  	;MOV     BX,CS			; no holes here.
  4416                                  	;MOV     SS,BX
  4417                                  
  4418                                  	;getdseg <ss>			; ss -> dosdat, already flag is CLI
  4419 00000370 2E8E16[0700]            	mov	ss,[cs:DosDSeg]
  4420                                  					;entry	REDISP
  4421                                  REDISP:
  4422 00000375 BC[A007]                        MOV     SP,AUXSTACK		; Enough stack for interrupts
  4423 00000378 FB                              STI                             ; stack is in our space now...
  4424                                  
  4425 00000379 8CD3                    	mov	bx,ss
  4426 0000037B 8EDB                    	mov	ds,bx
  4427                                  
  4428 0000037D 93                      	xchg	ax,bx
  4429                                  
  4430 0000037E 31C0                    	xor	ax,ax ; 0
  4431                                  
  4432                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4433                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:416Eh  (from org 3DD0h)
  4434                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:417Bh (from org 3DE0h)
  4435                                  
  4436                                  	; (Note: ss: segment prefix was not needed here! ds=ss ! -04/11/2022-)
  4437                                  
  4438                                  	;mov	[ss:EXTOPEN_ON],al ; 0	; Clear extended open flag
  4439                                  	;;and	word [ss:DOS34_FLAG],EXEC_AWARE_REDIR
  4440                                  	;and	word [ss:DOS34_FLAG],800h ; clear all bits except bit 11
  4441                                  	;mov	[ss:CONSWAP],al  ; 0	; random clean up of possibly mis-set flags
  4442                                  	;mov	[ss:NoSetDir],al ; 0	; set directories on search
  4443                                  	;mov	[ss:FAILERR],al ; 0	; FAIL not in progress
  4444                                  	;inc	ax
  4445                                  	;;inc	AL			; AL = 1
  4446                                  	;mov	[ss:IDLEINT],al		; presume that we can issue INT 28h
  4447                                  
  4448                                  	; 15/12/2022
  4449 00000380 A2[F605]                	mov	[EXTOPEN_ON],al ; 0	; Clear extended open flag
  4450                                  	;and	word [DOS34_FLAG],EXEC_AWARE_REDIR
  4451 00000383 8126[1106]0008          	and	word [DOS34_FLAG],800h	; clear all bits except bit 11
  4452 00000389 A2[5703]                	mov	[CONSWAP],al  ; 0	; random clean up of possibly mis-set flags
  4453                                  	;mov	byte [IDLEINT],1
  4454 0000038C A2[4C03]                	mov	[NoSetDir],al ; 0	; set directories on search
  4455 0000038F A2[4A03]                	mov	[FAILERR],al ; 0	; FAIL not in progress
  4456 00000392 40                      	inc	ax
  4457                                  	;inc	al			; AL = 1
  4458 00000393 A2[5803]                	mov	[IDLEINT],al		; presume that we can issue INT 28h
  4459                                  
  4460 00000396 93                      	XCHG	AX,BX			; Restore AX and BX = 1
  4461                                  
  4462 00000397 88E3                    	MOV     BL,AH			
  4463 00000399 D1E3                            SHL     BX,1			; 2 bytes per call in table
  4464                                         
  4465 0000039B FC                      	CLD
  4466                                  		; Since the DOS maintains mucho state information across system
  4467                                  		; calls, we must be very careful about which stack we use.
  4468                                  		; First, all abort operations must be on the disk stack. This
  4469                                  		; is due to the fact that we may be hitting the disk (close
  4470                                  		; operations, flushing) and may need to report an INT 24.
  4471                                          
  4472 0000039C 08E4                    	OR      AH,AH
  4473 0000039E 7416                            JZ      SHORT DSKROUT		; ABORT
  4474                                  
  4475                                          ;CMP	AH,12
  4476                                          ;JBE	SHORT IOROUT		; Character I/O
  4477                                          ;CMP	AH,GET_CURRENT_PDB      ; INT 24h needs GET,SET PDB
  4478                                          ;JZ	SHORT IOROUT
  4479                                          ;CMP	AH,SET_CURRENT_PDB
  4480                                          ;JNZ	SHORT DSKROUT
  4481                                  
  4482                                  		; Second, PRINT and PSPRINT and the server issue
  4483                                  		; GetExtendedError calls at INT 28 and INT 24 time.
  4484                                  		; This call MUST, therefore, use the AUXSTACK.
  4485                                  
  4486                                  	; 10/08/2018
  4487 000003A0 80FC59                  	cmp     ah,GETEXTENDEDERROR ; 59h
  4488 000003A3 7439                    	je      short DISPCALL
  4489                                  	
  4490                                  	; 01/05/2019
  4491                                  	
  4492                                  		; Old 1-12 system calls may be either on the IOSTACK (normal
  4493                                  		; operation) or on the AUXSTACK (at INT 24 time).
  4494                                  
  4495 000003A5 80FC0C                  	cmp     ah,12 ; STD_CON_INPUT_FLUSH ; 0Ch
  4496 000003A8 770C                    	ja      short DSKROUT
  4497                                  
  4498                                  IOROUT:
  4499                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4500                                  	; (ss: prefix was not needed here! ds=ss)
  4501                                  	;cmp	byte [ss:ERRORMODE],0	; Are we in an INT 24h? 
  4502                                  	; 15/12/2022
  4503 000003AA 803E[2003]00            	cmp     BYTE [ERRORMODE],0	; Are we in an INT 24h?
  4504 000003AF 752D                            JNZ     SHORT DISPCALL		; Stay on AUXSTACK if INT 24h
  4505 000003B1 BC[A00A]                        MOV     SP,IOSTACK
  4506 000003B4 EB28                            JMP     SHORT DISPCALL
  4507                                  
  4508                                  		; We are on a system call that is classified as "the rest".
  4509                                  		; We place ourselves onto the DSKSTACK and away we go.
  4510                                  		; We know at this point:
  4511                                  		; *  An INT 24 cannot be in progress. Therefore we reset
  4512                                  		;    ErrorMode and WpErr
  4513                                  		; *  That there can be no critical sections in effect.
  4514                                  		;    We signal the server to remove all the resources.
  4515                                  
  4516                                  DSKROUT:
  4517                                  	; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  4518                                  	; 15/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4519                                  	; 08/07/2018 - Retro DOS v3.0
  4520 000003B6 A3[3A03]                	mov     [USER_IN_AX],ax		; Remember what user is doing
  4521                                  	; 01/01/2024
  4522                                  	;mov	byte [EXTERR_LOCUS],1	; errLOC_Unk (Default)
  4523                                  	;MOV	BYTE [WPERR],-1		; error mode, so good place to
  4524                                  	                   		; make sure flags are reset
  4525 000003B9 C706[2203]FF01          	mov	word [WPERR],1FFh
  4526                                  
  4527 000003BF C606[2003]00            	MOV     BYTE [ERRORMODE],0	; Cannot make non 1-12 calls in
  4528                                  
  4529                                  
  4530                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4531                                  	; (ss: prefix was not needed here! ds=ss)
  4532                                  
  4533                                  	;mov	[ss:USER_IN_AX],ax	; Remember what user is doing
  4534                                  	;mov	byte [ss:EXTERR_LOCUS],1 ; errLOC_Unk (Default)
  4535                                  	;mov	byte [ss:ERRORMODE],0	; Cannot make non 1-12 calls in
  4536                                  	;mov	byte [ss:WPERR],-1	; error mode, so good place to
  4537                                                                          ; make sure flags are reset
  4538 000003C4 50                      	push    ax
  4539 000003C5 B482                    	mov     ah,82h			; Release all resource information
  4540 000003C7 CD2A                    	int     2Ah 		; Microsoft Networks 
  4541                                  				; END DOS CRITICAL SECTIONS 0 THROUGH 7
  4542 000003C9 58                      	pop     ax
  4543                                  
  4544                                  		; Since we are going to be running on the DSKStack and since
  4545                                  		; INT 28 people will use the DSKStack, we must turn OFF the
  4546                                  		; generation of INT 28's.
  4547                                  
  4548                                  	; 15/12/2022
  4549                                  	;mov     byte [ss:IDLEINT],0
  4550                                  	;
  4551                                          ;mov	sp,DSKSTACK
  4552                                  	;test	byte [ss:CNTCFLAG],-1  ; 0FFh
  4553                                          ;jz	short DISPCALL
  4554                                  
  4555 000003CA C606[5803]00            	mov     byte [IDLEINT],0
  4556                                  
  4557 000003CF BC[2009]                	MOV     SP,DSKSTACK
  4558 000003D2 F606[3703]FF            	TEST    BYTE [CNTCFLAG],-1
  4559 000003D7 7405                    	JZ      SHORT DISPCALL
  4560                                  
  4561 000003D9 50                              PUSH    AX
  4562                                          ;invoke	DSKSTATCHK
  4563 000003DA E88B56                          CALL	DSKSTATCHK
  4564 000003DD 58                      	POP     AX
  4565                                  DISPCALL:
  4566                                  	; 01/05/2019 - Retro DOS v4.0
  4567 000003DE 2E8B9F[EC00]            	mov	bx,[CS:BX+DISPATCH]
  4568                                  
  4569                                  	; 15/12/2022
  4570 000003E3 871E[EA05]              	xchg	bx,[SAVEBX]
  4571 000003E7 8E1E[EC05]              	MOV	DS,[SAVEDS]
  4572                                  
  4573                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4574                                  	; (ss: prefix was not needed here! ds=ss)        
  4575                                  	;xchg	bx,[ss:SAVEBX]
  4576                                  	;mov	ds,[ss:SAVEDS]
  4577                                  
  4578 000003EB 36FF16[EA05]            	call	word [SS:SAVEBX] ; near call
  4579                                  
  4580                                  	; The EXEXA20OFF bit of DOS_FLAG will now be unconditionally cleared
  4581                                  	; here. Please see under M003, M009 and M068 tags in dossym.inc
  4582                                  	; for explanation. Also NOTE that a call to ExecReady (ax=4b05) will
  4583                                  	; return to LeaveDos and hence will not clear this bit. This is 
  4584                                  	; because this bit is used to indicate to the next int 21 call that
  4585                                  	; the previous int 21 was an exec.
  4586                                  	;
  4587                                  	; So do not add any code between the call above and the label 
  4588                                  	; LeaveDOS if it needs to be executed even for ax=4b05
  4589                                  
  4590                                  	;;and	byte [ss:DOS_FLAG],~EXECA20OFF
  4591                                  	;and	byte [ss:DOS_FLAG],0FBh ; clear bit 2
  4592                                  
  4593                                  	; 01/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  4594 000003F0 368026[8600]DB          	and	byte [ss:DOS_FLAG],0DBh ; clear bit 2 and bit 5
  4595                                  
  4596                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4597                                  ; DOSCODE:41F7h
  4598                                  
  4599                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  4600                                  ; DOSCODE:42D4h
  4601                                  
  4602                                  ;entry LEAVE
  4603                                  ;;;_LEAVE:				; Exit from a system call
  4604                                  LeaveDOS: ; 18/07/2018 
  4605                                  ;ASSUME	SS:NOTHING			; User routines may misbehave
  4606 000003F6 FA                      	CLI
  4607                                  
  4608                                  	; 01/05/2019
  4609                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4610 000003F7 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4611 000003FC 803E[8500]00            	cmp	byte [A20OFF_COUNT],0	; M068: Q: is count 0
  4612 00000401 752A                    	jne	short disa20		; M068: N: dec count and turn a20 off
  4613                                  
  4614                                  LeaveA20On:
  4615 00000403 FE0E[2103]                      DEC     BYTE [INDOS]
  4616                                  	
  4617                                  	; 01/01/2024 (PCDOS 7.1 IBMDOS.COM)
  4618 00000407 FE0E[DF13]              	dec	byte [INDOS_FLAG]	; duplicated INDOS flag (what for ?)
  4619                                  
  4620                                          ; 04/11/2022
  4621 0000040B 8E16[8605]              	mov	ss,[USER_SS]
  4622 0000040F 8B26[8405]              	MOV     SP,[USER_SP]
  4623                                  	;MOV	SS,[USER_SS]
  4624 00000413 89E5                    	MOV     BP,SP
  4625                                  	;MOV	[BP.user_AX],AL	
  4626                                          ; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4627                                  	;;mov	[bp+0],al ; MSDOS 5.0 MSDOS.SYS - DOSCODE:4212h	
  4628                                  	;MOV	[BP+user_env.user_AX],AL  ; user_env.user_AX = 0
  4629                                  	
  4630                                  	; 15/12/2022
  4631 00000415 884600                  	MOV	[BP],AL	; mov [bp+0],al
  4632                                  	
  4633                                  	;MOV	AX,[NSP]
  4634                                          ;MOV	[USER_SP],AX
  4635                                          ;MOV	AX,[NSS]
  4636                                          ;MOV	[USER_SS],AX
  4637                                  	; 01/01/2024
  4638 00000418 C406[F005]              	les	ax,[NSS]
  4639 0000041C A3[8605]                	mov	[USER_SS],ax
  4640 0000041F 8C06[8405]              	mov	[USER_SP],es
  4641                                  
  4642 00000423 58                      	pop	AX
  4643 00000424 5B                      	pop	BX
  4644 00000425 59                      	pop	CX
  4645 00000426 5A                      	pop	DX
  4646 00000427 5E                      	pop	SI
  4647 00000428 5F                      	pop	DI
  4648 00000429 5D                      	pop	BP
  4649 0000042A 1F                      	pop	DS
  4650 0000042B 07                      	pop	ES
  4651                                  
  4652 0000042C CF                              IRET
  4653                                  
  4654                                  disa20:	   				; M068 - Start
  4655 0000042D 8B1E[6300]              	mov	bx,[A20OFF_PSP]		; bx = PSP for which a20 to be off'd
  4656 00000431 3B1E[3003]              	cmp	bx,[CurrentPDB]		; Q: do the PSP's match
  4657 00000435 75CC                    	jne	short LeaveA20On	; N: don't clear bit and don't turn 
  4658                                  					;    a20 off
  4659                                  					; Y: turn a20 off and dec a20off_count
  4660 00000437 FE0E[8500]              	dec	byte [A20OFF_COUNT]	; M068 - End
  4661                                   					; Start - M004
  4662 0000043B 1E                      	push	ds			; segment of stub
  4663 0000043C BB[7711]                	mov	bx,disa20_iret		; offset in stub
  4664 0000043F 53                      	push	bx
  4665 00000440 CB                      	retf	  			; go to stub
  4666                                  					; End - M004
  4667                                  ;SYSTEM_CALL ENDP
  4668                                  
  4669                                  ; DOSCODE:424Ch (MSDOS 6.21, MSDOS.SYS)
  4670                                  ; 04/11/2022
  4671                                  ; DOSCODE:423Fh (MSDOS 5.0, MSDOS.SYS)
  4672                                  
  4673                                  ; ==========================================================================
  4674                                  ;
  4675                                  ; Restore_World restores all registers ('cept SS:SP, CS:IP, flags) from
  4676                                  ; the stack prior to giving the user control
  4677                                  ;
  4678                                  ; ==========================================================================
  4679                                  
  4680                                  ; 01/05/2019 - Retro DOS v4.0
  4681                                  
  4682                                          ;procedure restore_world,NEAR
  4683                                  restore_world:
  4684                                  	;getdseg <es>		; es -> dosdata
  4685 00000441 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4686                                  
  4687 00000446 268F06[EE05]                    POP	WORD [ES:RESTORE_TMP]
  4688                                  
  4689 0000044B 58                              POP     AX
  4690 0000044C 5B                              POP     BX
  4691 0000044D 59                              POP     CX
  4692 0000044E 5A                              POP     DX
  4693 0000044F 5E                              POP     SI
  4694 00000450 5F                              POP     DI
  4695 00000451 5D                              POP     BP
  4696 00000452 1F                              POP     DS
  4697                                  
  4698 00000453 26FF26[EE05]                   	jmp	word [ES:RESTORE_TMP]
  4699                                  
  4700                                  ;restore_world	ENDP
  4701                                  
  4702                                  ; 01/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDISP.ASM, 1991)
  4703                                  
  4704                                  ; DOSCODE:4263h (MSDOS 6.21, MSDOS.SYS)
  4705                                  ; 04/11/2022
  4706                                  ; DOSCODE:4256h (MSDOS 5.0, MSDOS.SYS)
  4707                                  
  4708                                  ; ==========================================================================
  4709                                  ;
  4710                                  ; Save_World saves complete registers on the stack
  4711                                  ;
  4712                                  ; ==========================================================================
  4713                                  
  4714                                          ;procedure save_world,NEAR
  4715                                  save_world:
  4716                                  	;getdseg <es>		; es -> dosdata
  4717 00000458 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4718                                  
  4719 0000045D 268F06[EE05]                    POP	WORD [ES:RESTORE_TMP]
  4720                                  
  4721                                  	; 12/05/2019
  4722                                          
  4723 00000462 1E                      	PUSH    DS
  4724 00000463 55                              PUSH    BP
  4725 00000464 57                              PUSH    DI
  4726 00000465 56                              PUSH    SI
  4727 00000466 52                              PUSH    DX
  4728 00000467 51                              PUSH    CX
  4729 00000468 53                              PUSH    BX
  4730 00000469 50                              PUSH    AX
  4731                                  
  4732 0000046A 26FF36[EE05]            	push	word [ES:RESTORE_TMP]
  4733                                  
  4734 0000046F 55                      	push	BP
  4735 00000470 89E5                    	mov	BP,SP
  4736 00000472 8E4614                  	mov	ES,[BP+20]	; es was pushed before call
  4737 00000475 5D                      	pop	BP
  4738                                  	
  4739 00000476 C3                      	retn
  4740                                  
  4741                                  ;save_world	ENDP
  4742                                  
  4743                                  ; 01/05/2019
  4744                                  
  4745                                  ; DOSCODE:4282h (MSDOS 6.21, MSDOS.SYS)
  4746                                  ; 04/11/2022
  4747                                  ; DOSCODE:4275h (MSDOS 5.0, MSDOS.SYS)
  4748                                  
  4749                                  ; ==========================================================================
  4750                                  ;
  4751                                  ; Get_User_Stack returns the user's stack (and hence registers) in DS:SI
  4752                                  ;
  4753                                  ; ==========================================================================
  4754                                  
  4755                                          ;procedure get_user_stack,NEAR
  4756                                  Get_User_Stack:
  4757                                          ;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4758 00000477 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4759 0000047C C536[8405]                      lds	si,[USER_SP]
  4760 00000480 C3                      	retn
  4761                                  
  4762                                  ;get_user_stack  ENDP
  4763                                  
  4764                                  ; 22/12/2022
  4765                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
  4766                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1, IBMDOS.COM)
  4767                                  ;%if 0
  4768                                  
  4769                                  ; ---------------------------------------------------------------------------
  4770                                  ;
  4771                                  ; Set_OEM_Handler -- Set OEM sys call address and handle OEM Calls
  4772                                  ; Inputs:
  4773                                  ;	User registers, User Stack, INTS disabled
  4774                                  ;	If CALL F8, DS:DX is new handler address
  4775                                  ; Function:
  4776                                  ;	Process OEM INT 21 extensions
  4777                                  ; Outputs:
  4778                                  ;	Jumps to OEM_HANDLER if appropriate
  4779                                  ;
  4780                                  ; ---------------------------------------------------------------------------
  4781                                  
  4782                                  ;IF	NOT IBM
  4783                                  
  4784                                  _$SET_OEM_HANDLER:
  4785                                  	; 01/05/2019 - Retro DOS v4.0
  4786                                  	
  4787                                  	;(cmp	ah,SET OEM HANDLER  ; 0F8h)
  4788                                  	;(jb	short NOTOOEM)
  4789                                  
  4790 00000481 06                      	push	es ; *
  4791                                  	;getdseg <es>			; es -> dosdata
  4792 00000482 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4793                                  
  4794 00000487 750C                    	jne	short check_trueversion_request ; check Retro DOS true version
  4795                                  						; (message) request
  4796                                  	; AH = 0F8h = SET OEM HANDLER
  4797                                  
  4798 00000489 268916[1400]            	MOV     [es:OEM_HANDLER],DX	; Set Handler
  4799 0000048E 268C1E[1600]            	MOV     [es:OEM_HANDLER+2],DS
  4800                                  
  4801 00000493 07                      	pop	es ; *
  4802                                  
  4803 00000494 CF                      	IRET                            ; Quick return, Have altered no registers
  4804                                  
  4805                                  check_trueversion_request:
  4806                                  	; 18/07/2019 - Retro DOS v3.0
  4807                                  
  4808                                  	; Retro DOS v2.0 - 20/04/2018
  4809 00000495 83F8FF                  	CMP	AX,0FFFFh
  4810                                  	; 18/07/2018
  4811 00000498 7520                    	jne	short DO_OEM_FUNC ; 01/05/2019
  4812                                  
  4813                                  	; 01/05/2019
  4814 0000049A 07                      	pop	es ; *
  4815                                  
  4816 0000049B B40E                    	mov	ah,0Eh
  4817                                  
  4818                                  	; Retro DOS v4.0 feature only!
  4819 0000049D 81FBA101                	cmp	bx,417  ; Signature to bypass
  4820                                  			; Retro DOS true version message
  4821 000004A1 7414                    	je	short true_version_iret
  4822                                  
  4823 000004A3 56                      	push	si
  4824 000004A4 53                      	push	bx
  4825                                  
  4826 000004A5 BE[C200]                	mov	si,RETRODOSMSG
  4827                                  wrdosmsg:
  4828                                  	;movb	ah,0Eh
  4829 000004A8 BB0700                  	mov	bx,7
  4830                                  wrdosmsg_nxt:
  4831 000004AB 2EAC                    	cs	lodsb
  4832 000004AD 3C24                    	cmp	al,'$'
  4833 000004AF 7404                    	je	short wrdosmsg_ok		
  4834 000004B1 CD10                    	int	10h
  4835 000004B3 EBF6                    	jmp	short wrdosmsg_nxt
  4836                                  
  4837                                  wrdosmsg_ok:
  4838 000004B5 5B                      	pop	bx
  4839 000004B6 5E                      	pop	si
  4840                                  
  4841                                  true_version_iret:
  4842                                  	; ah = 0Eh
  4843                                  	;mov	al,40h ; Retro DOS v4.0
  4844                                  	; 
  4845                                  	;mov	al,41h ; Retro DOS v4.1 
  4846                                  	; 30/12/2022
  4847                                  	;mov	al,42h ; Retro DOS v4.2
  4848                                  	; 01/01/2024
  4849 000004B7 B050                    	mov	al,50h ; Retro DOS v5.0	
  4850 000004B9 CF                      	iret
  4851                                  
  4852                                  	; If above F8 try to jump to handler
  4853                                  
  4854                                  DO_OEM_FUNC:
  4855                                  	; 01/05/2019
  4856 000004BA 26833E[1400]FF          	cmp     word [es:OEM_HANDLER],-1
  4857 000004C0 7504                    	JNE     short OEM_JMP
  4858 000004C2 07                      	pop	es ; *
  4859 000004C3 E903FE                  	JMP     BADCALL                 ; Handler not initialized
  4860                                  OEM_JMP:
  4861 000004C6 06                      	push	es
  4862 000004C7 1F                      	pop	ds ; DOSDATA segment !
  4863 000004C8 07                      	pop	es ; *
  4864                                  
  4865                                  	; 22/12/2022
  4866 000004C9 FB                      	sti	; (enable interrupts before jumping to private handler)  
  4867                                  
  4868 000004CA FF2E[1400]              	JMP     FAR [OEM_HANDLER]
  4869                                  
  4870                                  ;       ENDIF
  4871                                  
  4872                                  ; ---------------------------------------------------------------------------
  4873                                  
  4874                                  ;%endif
  4875                                  
  4876                                  ;============================================================================
  4877                                  ; MCODE.ASM, MSDOS 6.0, 1991
  4878                                  ;============================================================================
  4879                                  ; 17/07/2018 - Retro DOS v3.0
  4880                                  
  4881                                  ;	TITLE	MISC DOS ROUTINES - Int 25 and 26 handlers and other
  4882                                  ;	NAME	IBMCODE
  4883                                  
  4884                                  ;BREAK <NullDev -- Driver for null device>
  4885                                  
  4886                                  ; ROMDOS note:
  4887                                  ;	NUL device driver used to be here, but it was removed and placed in
  4888                                  ;	DOSDATA, because the entry points have to be in the segment as the
  4889                                  ;	header, which is also in DOSDATA.
  4890                                  
  4891                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>
  4892                                  
  4893                                  ;----------------------------------------------------------------------------
  4894                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
  4895                                  ;----------------------------------------------------------------------------
  4896                                  ; DOSCODE:428Ch (MSDOS 6.21 MSDOS.SYS)
  4897                                  ; DOSCODE:427Fh (MSDOS 5.0 MSDOS.SYS)
  4898                                  
  4899                                  ; 01/01/2024 - Retro DOS v5.0
  4900                                  ; DOSCODE:435Fh (PCDOS 7.1 IBMDOS.COM)
  4901                                  
  4902                                  ;Public MSC001S,MSC001E
  4903                                  ;MSC001S label byte
  4904                                  	;IF	IBM
  4905                                  ; Codes returned by BIOS
  4906                                  ERRIN:
  4907 000004CE 02                      	DB	2			; NO RESPONSE
  4908 000004CF 06                      	DB	6			; SEEK FAILURE
  4909 000004D0 0C                      	DB	12			; GENERAL ERROR
  4910 000004D1 04                      	DB	4			; BAD CRC
  4911 000004D2 08                      	DB	8			; SECTOR NOT FOUND
  4912 000004D3 00                      	DB	0			; WRITE ATTEMPT ON WRITE-PROTECT DISK
  4913                                  ERROUT:
  4914                                  ; DISK ERRORS RETURNED FROM INT 25 and 26
  4915 000004D4 80                      	DB	80H			; NO RESPONSE
  4916 000004D5 40                      	DB	40H			; Seek failure
  4917 000004D6 02                      	DB	2			; Address Mark not found
  4918 000004D7 10                      	DB	10H			; BAD CRC
  4919 000004D8 04                      	DB	4			; SECTOR NOT FOUND
  4920 000004D9 03                      	DB	3			; WRITE ATTEMPT TO WRITE-PROTECT DISK
  4921                                  
  4922                                  NUMERR	EQU	$-ERROUT
  4923                                  	;ENDIF
  4924                                  ;MSC001E label byte
  4925                                  ;----------------------------------------------------------------------------
  4926                                  
  4927                                  ;============================================================================
  4928                                  ; MSCODE.ASM - MSDOS 6.0 - 1991
  4929                                  ;============================================================================
  4930                                  ; 18/07/2018 - Retro DOS v3.0
  4931                                  ; 15/05/2019 - Retro DOS v4.0
  4932                                  
  4933                                  ; 02/01/2024 - Retro DOS v5.0
  4934                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:436Bh
  4935                                  
  4936                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>>
  4937                                  
  4938                                  ;   AbsSetup - setup for abs disk functions
  4939                                  ;----------------------------------------------------------------------------
  4940                                  
  4941                                  AbsSetup:
  4942                                  	; 02/01/2024 (PCDOS 7.1, Retro DOS 5.0)
  4943                                  	;;;
  4944                                  	;
  4945 000004DA 1E                      	push	ds ; *
  4946 000004DB 16                      	push	ss
  4947 000004DC 1F                      	pop	ds
  4948                                  	;
  4949 000004DD 8826[E20A]              	mov	[absdrw_extd],ah
  4950                                  	;mov	[ss:absdrw_extd],ah	; Extended ABS Disk Read/Write flag
  4951                                  					; (AH=1 for INT 21h ax=7305h function)
  4952 000004E1 08E4                    	or	ah,ah
  4953 000004E3 7508                    	jnz	short AbsSetup1		; INT 21h AX=7305h
  4954                                  
  4955                                  	; INT 25h
  4956 000004E5 FE06[DF13]              	inc	byte [INDOS_FLAG]
  4957                                  	;inc	byte [ss:INDOS_FLAG]	; Windows DOSBOX's INDOS flag ?
  4958                                  	;;;
  4959 000004E9 FE06[2103]              	inc	byte [INDOS]
  4960                                  	;INC	byte [SS:INDOS]		; SS override
  4961                                  AbsSetup1:
  4962 000004ED FB                      	STI
  4963 000004EE FC                      	CLD
  4964                                  	; 02/01/2024
  4965                                  	;PUSH	DS
  4966                                  	;push	ss
  4967                                  	;pop	ds
  4968 000004EF E83A01                  	CALL	GETBP
  4969                                  	; 02/01/2024
  4970 000004F2 1F                      	pop	ds ; *
  4971 000004F3 7229                    	JC	short errdriv 		; PM. error drive ;AN000;
  4972                                  	
  4973                                  	; 02/01/2024
  4974                                  	;;mov	word [es:bp+1Fh]
  4975                                  	;MOV	WORD [ES:BP+DPB.FREE_CNT],-1 ; do not trust user at all.
  4976                                  ;errdriv:
  4977                                  	;POP	DS
  4978                                  	;jnc	short AbsSetup2
  4979                                  ;AbsSetup_retn:
  4980                                  	;retn
  4981                                  
  4982                                  AbsSetup2:
  4983                                  	; 15/05/2019 - Retro DOS v4.0
  4984                                  	; MSDOS 6.0
  4985                                  					; SS override
  4986 000004F5 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0 ;>32mb	from API		;AN000;
  4987 000004FC E8BF04                  	CALL	RW32_CONVERT		;>32mb convert 32bit format to 16bit ;AN000;
  4988                                  	;jc	short AbsSetup_retn
  4989                                  	;call	SET_RQ_SC_PARMS 	;LB. set up SC parms		;AN000;
  4990                                  	; 02/01/2024 - Retro DOS v5.0
  4991 000004FF 721D                    	jc	short errdriv
  4992                                  	;call	null_sub ; retn	; PCDOS 7.1 IBMDOS.COM
  4993                                  
  4994                                  	; MSDOS 3.3 (& MSDOS 6.0)
  4995 00000501 1E                      	PUSH	DS
  4996 00000502 56                      	PUSH	SI
  4997 00000503 50                      	PUSH	AX
  4998                                  
  4999 00000504 16                      	push	ss
  5000 00000505 1F                      	pop	ds
  5001                                  	
  5002 00000506 BE[BE03]                	MOV	SI,OPENBUF
  5003 00000509 8804                    	MOV	[SI],AL
  5004 0000050B 800441                  	ADD	BYTE [SI],"A"
  5005 0000050E C744013A00              	MOV	WORD [SI+1],003AH ; ":",0
  5006 00000513 B80003                  	MOV	AX,0300H
  5007 00000516 F8                      	CLC
  5008 00000517 CD2A                    	INT	int_IBM ; int 2Ah	; Will set carry if shared
  5009                                  		
  5010                                  		; 04/11/2022
  5011                                  		; (INT 2Ah - AX = 0300h)
  5012                                  		; Microsoft Networks - CHECK DIRECT I/O
  5013                                  		; DS:SI -> ASCIIZ disk device name (may be full path or
  5014                                  		;    only drive specifier--must include the colon)
  5015                                  		; Return: CF clear if absolute disk access allowed
  5016                                  
  5017 00000519 58                      	POP	AX
  5018 0000051A 5E                      	POP	SI
  5019 0000051B 1F                      	POP	DS
  5020 0000051C 730E                    	jnc	short AbsSetup_retn
  5021                                  
  5022                                  	; 02/01/2024
  5023                                  errdriv:
  5024                                  	;mov	word [ss:EXTERR],32h
  5025 0000051E 36C706[2403]3200        	MOV	word [ss:EXTERR],error_not_supported
  5026                                  	; 02/01/2024 - Retro DOS v5.0
  5027 00000525 36C706[080E]0702        	mov	word [ss:AbsDskErr],207h ; PCDOS 7.1 IBMDOS.COM
  5028                                  
  5029                                  	; 02/01/2024
  5030                                  AbsSetup_retn:
  5031 0000052C C3                      	retn
  5032                                  
  5033                                  ;---------------------------------------------------------------------------
  5034                                  ;
  5035                                  ; Procedure Name : ABSDRD
  5036                                  ;
  5037                                  ; Interrupt 25 handler. Performs absolute disk read.
  5038                                  ; Inputs:	AL - 0-based drive number
  5039                                  ;		DS:BX point to destination buffer
  5040                                  ;		CX number of logical sectors to read
  5041                                  ;		DX starting logical sector number (0-based)
  5042                                  ; Outputs:	Original flags still on stack
  5043                                  ;		Carry set
  5044                                  ;		    AH error from BIOS
  5045                                  ;		    AL same as low byte of DI from INT 24
  5046                                  ;
  5047                                  ;---------------------------------------------------------------------------
  5048                                          ;procedure   ABSDRD,FAR
  5049                                  ABSDRD:
  5050                                  	; 15/05/2019 - Retro DOS v4.0
  5051                                  	; MSDOS 6.21 (DOSCODE:42E5h)
  5052                                  	; 04/11/2022
  5053                                  	; MSDOS 5.0 (DOSCODE:42D8h)
  5054                                  
  5055                                  	; 02/01/2024 - Retro DOS v5.0
  5056                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:43C4h
  5057                                  	
  5058                                  	;;;
  5059 0000052D 30E4                    	xor     ah,ah	; ah=0		; Interrupt 25h handler (ah=0)
  5060 0000052F 31F6                    	xor     si,si	; si=0		; clear read/write mode flags
  5061                                  					; (used with INT 21h ax=7305h)
  5062                                  FAT32_ABSDRD:	; ah=1 si=0 cf=0 (jump from '_$FAT32EXT')
  5063 00000531 FA                      	cli
  5064                                  	;clc ; not necessary
  5065                                  				; INT 21h
  5066                                  				;	AX = 7305h
  5067                                  				; FAT32 - EXTENDED ABSOLUTE DISK READ/WRITE
  5068                                  				;	CX = FFFFh
  5069                                  				;	DL = drive number (01h=A:, etc.)
  5070                                  				;	SI = read/write mode flags
  5071                                  				;	DS:BX -> disk I/O packet
  5072                                  				;
  5073                                  				; Extended Absolute Disk Read/Write mode flags:
  5074                                  				;
  5075                                  				;	Bit(s)  Description
  5076                                  				;	0	direction (0=read, 1=write)
  5077                                  				;	12-1	reserved (0)
  5078                                  				;	14-13	write type (should be 00 on reads).
  5079                                  				;		00 unknown data.
  5080                                  				;		01 FAT data.
  5081                                  				;		10 directory data.
  5082                                  				;		11 file data
  5083                                  				;	15     reserved (0)
  5084                                  				;
  5085                                  				; Format of disk read/write packet:
  5086                                  				;
  5087                                  				;	Offset Size    Description
  5088                                  				;	00h    DWORD   sector number
  5089                                  				;	04h    WORD    number of sectors to r/w
  5090                                  				;	06h    DWORD   transfer address
  5091                                  				;
  5092                                  				; ref: Ralf Brown's Interrupt List
  5093                                  	;;;
  5094                                  absdrd_1:
  5095                                  	; MSDOS 6.0
  5096                                  	;CLI
  5097                                  	
  5098                                  ;	set up ds to point to DOSDATA
  5099                                  
  5100 00000532 50                      	push	ax			; preserve AX value
  5101 00000533 8CD8                    	mov	ax,ds			; store DS value in AX
  5102                                  	;getdseg <ds>
  5103 00000535 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5104 0000053A A3[840D]                	mov	[TEMPSEG],ax		; store DS value in TEMPSEG
  5105 0000053D 58                      	pop	ax			; restore AX value
  5106                                  
  5107                                  	; M072:
  5108                                  	; We shall save es on the user stack here. We need to use ES in
  5109                                  	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
  5110                                  	; time in order to restore the user stack.
  5111                                  
  5112 0000053E 06                      	push	es  ; ****		; M072
  5113                                  
  5114                                  	; 02/01/2024 - Retrodos v5.0 (PCDOS 7.1 IBMDOS.COM)
  5115                                  	;;;
  5116                                  	; 02/01/2024
  5117 0000053F 9C                      	pushf	; !*!
  5118 00000540 7300                    	jnc	short absdrd_2		; (not jumped from ABSDWRT) absolute disk read
  5119                                  	
  5120                                  	;(jumped from ABSDRWT)
  5121                                  	; 02/01/2023 ; (!*!)
  5122                                  	;or	ah,ah
  5123                                  	;stc				; absolute disk write
  5124                                  	;jmp	short absdrd_3
  5125                                  absdrd_2:
  5126 00000542 08E4                    	or	ah,ah
  5127                                  absdrd_3:
  5128 00000544 7510                    	jnz	short absdrd_4		; EXTENDED ABSOLUTE DISK READ/WRITE
  5129                                  	;;;
  5130                                  
  5131 00000546 8C16[1B06]              	MOV	[AbsRdWr_SS],SS		; M013
  5132 0000054A 8926[1D06]              	MOV	[AbsRdWr_SP],SP		; M013
  5133                                  
  5134                                  ; 	set up ss to point to DOSDATA
  5135                                  ;
  5136                                  ; NOTE! Due to an obscure bug in the 80286, you cannot use the ROMDOS
  5137                                  ; version of the getdseg macro with the SS register! An interrupt will
  5138                                  ; sneak through.
  5139                                  
  5140                                  ;ifndef ROMDOS
  5141                                  	;getdseg <ss>			; cli in entry of routine
  5142                                  
  5143 0000054E 2E8E16[0700]            	mov     ss,[cs:DosDSeg]
  5144                                  
  5145                                  ;else
  5146                                  ;	mov	ds, cs:[BioDataSeg]
  5147                                  ;	assume	ds:bdata
  5148                                  ;
  5149                                  ;	mov	ss, ds:[DosDataSg]
  5150                                  ;	assume	ss:DOSDATA
  5151                                  ;
  5152                                  ;endif ; ROMDOS
  5153                                  					; 02/01/2024
  5154 00000553 BC[2009]                	MOV	SP,DSKSTACK	 	;"@#IBM:12.01.2003.build_1.32#@ IBMDOS.COM(USA)"
  5155                                  					; (PCDOS 7.1 IBMDOS.COM)
  5156                                  absdrd_4:
  5157                                  	; 02/01/2024
  5158 00000556 9D                      	popf	; !*!
  5159                                  	;
  5160 00000557 8E1E[840D]              	mov	ds,[TEMPSEG]		; restore DS value
  5161                                  
  5162 0000055B 06                      	push	es ; *** (MSDOS 6.21)
  5163 0000055C E8F9FE                  	call	save_world		; save all regs
  5164                                  
  5165 0000055F 06                      	PUSH	ES ; **
  5166                                  
  5167                                  	; 02/01/2024 - Retrodos v5.0
  5168                                  	;;;
  5169 00000560 7303                    	jnc	short absdrd_5  ; (!*!)	; absolute disk read
  5170 00000562 E9A500                  	jmp     absdrwt_3       ; (!*!)	; (jumping back to) absolute disk write
  5171                                  absdrd_5:
  5172                                  	;;;
  5173                                  
  5174 00000565 E872FF                  	CALL	AbsSetup
  5175 00000568 723D                    	JC	short ILEAVE
  5176                                  
  5177                                  	; Here is a gross temporary fix to get around a serious design flaw in
  5178                                  	;  the secondary cache. The secondary cache does not check for media
  5179                                  	;  changed (it should). Hence, you can change disks, do an absolute
  5180                                  	;  read, and get data from the previous disk. To get around this,
  5181                                  	;  we just won't use the secondary cache for absolute disk reads.
  5182                                  	;                                                      -mw 8/5/88
  5183                                  
  5184                                  	;EnterCrit critDisk
  5185 0000056A E89613                  	call	ECritDisk
  5186 0000056D 36C606[9C12]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ; invalidate SC  ;AN000;
  5187                                  	;LeaveCrit critDisk
  5188 00000573 E8BA13                  	call	LCritDisk
  5189                                  
  5190                                          ;invoke	DSKREAD
  5191 00000576 E8583A                  	CALL	DSKREAD
  5192 00000579 7513                            jnz	short ERR_LEAVE		;Jump if read unsuccessful.
  5193                                  
  5194 0000057B 89F9                            mov     cx,di
  5195 0000057D 368C1E[0E06]                    mov     [ss:TEMP_VAR2],ds
  5196 00000582 36891E[0C06]                    mov     [ss:TEMP_VAR],bx
  5197                                  
  5198                                  ;       CX = # of contiguous sectors read. (These constitute a block of
  5199                                  ;            sectors, also termed an "Extent".)
  5200                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
  5201                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
  5202                                  ;       ES:BP -> Drive Parameter Block (DPB).
  5203                                  ;
  5204                                  ;	The Buffer Queue must now be scanned: the contents of any dirty
  5205                                  ;	buffers must be "read" into the transfer memory block, so that the
  5206                                  ;       transfer memory reflects the most recent data.
  5207                                  
  5208                                  	;invoke	DskRdBufScan		;This trashes DS, but don't care.
  5209 00000587 E8973C                          call	DskRdBufScan
  5210 0000058A EB1B                    	jmp     short ILEAVE
  5211                                  
  5212                                  TLEAVE:
  5213 0000058C 7419                    	JZ	short ILEAVE
  5214                                  
  5215                                  ERR_LEAVE:				; M039
  5216                                  	; 15/07/2018 - Retro DOS v3.0
  5217                                          ;IF	IBM
  5218                                  ; Translate the error code to ancient 1.1 codes
  5219 0000058E 06                              PUSH    ES ; *
  5220 0000058F 0E                              PUSH    CS
  5221 00000590 07                              POP     ES
  5222 00000591 30E4                            XOR     AH,AH			; Nul error code
  5223                                  	;mov	cx,6
  5224 00000593 B90600                          MOV     CX,NUMERR		; Number of possible error conditions
  5225 00000596 BF[CE04]                        MOV     DI,ERRIN		; Point to error conditions
  5226 00000599 F2AE                            REPNE   SCASB
  5227 0000059B 7504                            JNZ     SHORT LEAVECODE		; Not found
  5228                                  	;mov	ah,[ES:DI+5]
  5229 0000059D 268A6505                        MOV     AH,[ES:DI+NUMERR-1]	; Get translation
  5230                                  LEAVECODE:
  5231 000005A1 07                              POP     ES ; *
  5232                                  	; 15/05/2019 - Retro DOS v4.0
  5233 000005A2 36A3[080E]              	mov	[ss:AbsDskErr],ax
  5234                                          ;ENDIF
  5235                                  
  5236 000005A6 F9                              STC
  5237                                  ILEAVE:
  5238                                  	; 15/05/2019
  5239 000005A7 07                              POP     ES ; **
  5240 000005A8 E896FE                  	call	restore_world
  5241 000005AB 07                              pop	es ; *** (MSDOS 6.21)
  5242                                  
  5243                                  	; 02/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  5244                                  	;;;
  5245 000005AC 9C                      	pushf
  5246 000005AD 36803E[E20A]00          	cmp	byte [ss:absdrw_extd],0
  5247                                  			; FAT32- EXTENDED ABSOLUTE DISK READ/WRITE flag
  5248 000005B3 751F                    	jnz     short ILEAVE_EXTD	; INT 21h AX=7305h
  5249                                  	; INT 25h
  5250 000005B5 9D                      	popf
  5251                                  	;;;
  5252                                  
  5253 000005B6 FA                      	CLI
  5254 000005B7 36A1[080E]              	mov     ax,[ss:AbsDskErr]	; restore error
  5255 000005BB 36FE0E[2103]            	DEC	BYTE [SS:INDOS]
  5256                                  	;
  5257                                  	; 02/01/2024 (PCDOS 7.1 IBMDOS.COM)
  5258 000005C0 36FE0E[DF13]            	dec	byte [ss:INDOS_FLAG]	; Windows DOSBOX's INDOS flag ?
  5259                                  	;
  5260 000005C5 16                              push	ss			; M072 - Start
  5261 000005C6 07                      	pop	es			; es - dosdata
  5262 000005C7 268E16[1B06]                    mov	ss,[es:AbsRdWr_SS]	; M013
  5263 000005CC 268B26[1D06]            	mov	sp,[es:AbsRdWr_SP]	; M013
  5264 000005D1 07                      	pop	es  ; ****		; Note es was saved on user
  5265                                  					; stack at entry 
  5266                                  					; M072 - End
  5267 000005D2 FB                              STI
  5268 000005D3 CB                      	RETF   ; ! FAR return !
  5269                                  
  5270                                  	; 02/01/2024 - Retro DOS v5.0
  5271                                  	; (PCDOS 7.1 IBMDOS.COM)
  5272                                  	;;;
  5273                                  ILEAVE_EXTD:	; return from INT 21h AX=7305h
  5274 000005D4 9D                      	popf
  5275 000005D5 36A1[080E]              	mov	ax,[ss:AbsDskErr]	; restore error
  5276 000005D9 07                      	pop	es ; ****
  5277 000005DA FB                      	sti
  5278 000005DB C3                      	retn
  5279                                  	;;;
  5280                                  
  5281                                  ;ABSDRD	ENDP
  5282                                  
  5283                                  ;---------------------------------------------------------------------------
  5284                                  ;
  5285                                  ; Procedure Name : ABSDWRT
  5286                                  ;
  5287                                  ; Interrupt 26 handler. Performs absolute disk write.
  5288                                  ; Inputs:	AL - 0-based drive number
  5289                                  ;		DS:BX point to source buffer
  5290                                  ;		CX number of logical sectors to write
  5291                                  ;		DX starting logical sector number (0-based)
  5292                                  ; Outputs:	Original flags still on stack
  5293                                  ;		Carry set
  5294                                  ;		    AH error from BIOS
  5295                                  ;		    AL same as low byte of DI from INT 24
  5296                                  ;
  5297                                  ;---------------------------------------------------------------------------
  5298                                          ;procedure   ABSDWRT,FAR
  5299                                  ABSDWRT:
  5300                                  	; 15/05/2019 - Retro DOS v4.0
  5301                                  	; MSDOS 6.21 (DOSCODE:436Ch)
  5302                                  	; 04/11/2022
  5303                                  	; MSDOS 5.0 (DOSCODE:435Fh)
  5304                                  
  5305                                  	; 03/01/2024 - Retro DOS v5.0
  5306                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:4477h
  5307                                  
  5308                                  	;;;
  5309 000005DC 30E4                    	xor     ah,ah	; ah=0		; Interrupt 26h handler (ah=0)
  5310 000005DE BE0100                  	mov	si,1			; set direction flag/bit to write
  5311                                  					; (used with INT 21h ax=7305h)
  5312                                  FAT32_ABSDWRT:	; ah=1 si=1 cf=0 (jump from '_$FAT32EXT')
  5313                                  
  5314                                  				; INT 21h
  5315                                  				;	AX = 7305h
  5316                                  				; FAT32 - EXTENDED ABSOLUTE DISK READ/WRITE
  5317                                  				;	CX = FFFFh
  5318                                  				;	DL = drive number (01h=A:, etc.)
  5319                                  				;	SI = read/write mode flags
  5320                                  				;	DS:BX -> disk I/O packet
  5321                                  				;
  5322                                  				; Extended Absolute Disk Read/Write mode flags:
  5323                                  				;
  5324                                  				;	Bit(s)  Description
  5325                                  				;	0	direction (0=read, 1=write)
  5326                                  				;	12-1	reserved (0)
  5327                                  				;	14-13	write type (should be 00 on reads).
  5328                                  				;		00 unknown data.
  5329                                  				;		01 FAT data.
  5330                                  				;		10 directory data.
  5331                                  				;		11 file data
  5332                                  				;	15     reserved (0)
  5333                                  				;
  5334                                  				; Format of disk read/write packet:
  5335                                  				;
  5336                                  				;	Offset Size    Description
  5337                                  				;	00h    DWORD   sector number
  5338                                  				;	04h    WORD    number of sectors to r/w
  5339                                  				;	06h    DWORD   transfer address
  5340                                  				;
  5341                                  				; ref: Ralf Brown's Interrupt List
  5342 000005E1 3C02                    	cmp	al,2
  5343 000005E3 7220                    	jb	short absdrwt_2	; floppy disk
  5344                                  	; hard disk
  5345 000005E5 53                      	push	bx
  5346 000005E6 1E                      	push	ds
  5347 000005E7 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5348 000005EC 30FF                    	xor	bh,bh
  5349 000005EE 88C3                    	mov	bl,al			;
  5350                                  					; NOTE: PCDOS 7.1 kernel does not set
  5351                                  					; DOS_FLAG bit 6 or drive_flags bit 7
  5352                                  					; (It appears that these bits are set
  5353                                  					; by Windows or a system utility or
  5354                                  					; driver that knows the addresses of
  5355                                  					; these FLAGs in the DOSDATA segment.)
  5356                                  					; Erdogan Tan - 03/01/2024
  5357                                  					;
  5358 000005F0 F687[2F14]80            	test	byte [drive_flags+bx],80h 
  5359                                  					; test bit 7 (locked bit) ; 29/01/2024
  5360 000005F5 7505                    	jnz	short absdwrt_1		; locked (logical drive) -allowed to abs write-
  5361                                  					; NOTE: lock/unlock are MSDOS/PCDOS 7 extd functions
  5362 000005F7 F606[8600]40            	test	byte [DOS_FLAG],40h	; test bit 6 (large disk support -windows- bit?)
  5363                                  					; NOTE: Retro DOS v5 kernel must set this bit.
  5364                                  absdwrt_1:
  5365 000005FC 1F                      	pop     ds
  5366 000005FD 5B                      	pop     bx
  5367 000005FE 7505                    	jnz     short absdrwt_2	; allowed
  5368 00000600 F9                      	stc
  5369 00000601 E81AFF                  	call    errdriv		; error
  5370 00000604 CB                      	retf
  5371                                  
  5372                                  ;absdrwt_2:
  5373                                  	;;;
  5374                                  
  5375                                  ; 03/01/2024
  5376                                  %if 0
  5377                                  	CLI
  5378                                  
  5379                                  ;	set up ds to point to DOSDATA
  5380                                  
  5381                                  	push	ax
  5382                                  	mov	ax,ds
  5383                                  	;getdseg <ds>
  5384                                  	mov	ds,[cs:DosDSeg]
  5385                                  	mov	[TEMPSEG],ax
  5386                                  	pop	ax
  5387                                  
  5388                                  	; M072:
  5389                                  	; We shall save es on the user stack here. We need to use ES in
  5390                                  	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
  5391                                  	; time in order to restore the user stack.
  5392                                  
  5393                                  	push	es ; ****		; M072
  5394                                  
  5395                                  	MOV	[AbsRdWr_SS],SS		; M013
  5396                                  	MOV	[AbsRdWr_SP],SP		; M013
  5397                                  
  5398                                  	; set up ss to point to DOSDATA
  5399                                  	;
  5400                                  	; NOTE! Due to an obscure bug in the 80286, you cannot use the 
  5401                                  	; ROMDOS version of the getdseg macro with the SS register!
  5402                                  	; An interrupt will sneak through.
  5403                                  
  5404                                  ;ifndef ROMDOS
  5405                                  	;getdseg <ss>			; cli in entry of routine
  5406                                  	mov     ss,[cs:DosDSeg]
  5407                                  ;else
  5408                                  ;	mov	ds, cs:[BioDataSeg]
  5409                                  ;	assume	ds:bdata
  5410                                  ;
  5411                                  ;	mov	ss, ds:[DosDataSg]
  5412                                  ;	assume	ss:DOSDATA
  5413                                  ;
  5414                                  ;endif ; ROMDOS
  5415                                  
  5416                                  	MOV	SP,DSKSTACK
  5417                                  		; we are now switched to DOS's disk stack
  5418                                  
  5419                                  	mov	ds,[TEMPSEG]		; restore user's ds
  5420                                  
  5421                                  	push	es ; *** (MSDOS 6.21)
  5422                                  
  5423                                  	call	save_world	      	; save all regs
  5424                                  
  5425                                  	PUSH	ES ; **
  5426                                  %endif
  5427                                  	; 03/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  5428                                  	;;;
  5429                                  absdrwt_2:
  5430 00000605 FA                      	cli
  5431 00000606 F9                      	stc			; writable disk
  5432                                  				; ('jumped from ABSDWRT' sign for common r/w code)
  5433 00000607 E928FF                  	jmp	absdrd_1        ; jump to ABSDRD (common r/w) code
  5434                                  	;;;
  5435                                  
  5436                                  absdrwt_3:
  5437 0000060A E8CDFE                  	CALL	AbsSetup
  5438 0000060D 7298                    	JC	short ILEAVE
  5439                                  
  5440                                  	; 03/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  5441 0000060F E8CE5A                  	call	chk_set_first_access
  5442                                  
  5443                                  	;EnterCrit critDisk
  5444 00000612 E8EE12                  	call	ECritDisk
  5445 00000615 36C606[9C12]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ; invalidate SC ;AN000;
  5446 0000061B E8DF03                  	CALL	Fastxxx_Purge		 ; purge fatopen ;AN000;
  5447                                  	;LeaveCrit critDisk
  5448 0000061E E80F13                  	call	LCritDisk
  5449                                  
  5450                                  ;M039
  5451                                  ;       DS:BX = transfer address (source data address).
  5452                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
  5453                                  ;	     sectors, also termed an "Extent".)
  5454                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
  5455                                  ;       ES:BP -> Drive Parameter Block (DPB).
  5456                                  ;       [CURSC_DRIVE] = -1 (invalid drive).
  5457                                  ;
  5458                                  ;       Free any buffered sectors which are in Extent; they are being over-
  5459                                  ;       written. Note that all the above registers are preserved for
  5460                                  ;       DSKWRITE.
  5461                                  
  5462 00000621 1E                              push    ds
  5463                                  	;invoke	DskWrtBufPurge          ; This trashes DS.
  5464 00000622 E8133F                  	call	DskWrtBufPurge
  5465 00000625 1F                              pop     ds
  5466                                  ;M039
  5467                                  	;invoke	DSKWRITE
  5468 00000626 E8D139                  	call	DSKWRITE
  5469 00000629 E960FF                  	JMP	TLEAVE
  5470                                  
  5471                                  ;ABSDWRT ENDP
  5472                                  
  5473                                  ;----------------------------------------------------------------------------
  5474                                  ;
  5475                                  ; Procedure Name : GETBP
  5476                                  ;
  5477                                  ; Inputs:
  5478                                  ;	AL = Logical unit number (A = 0)
  5479                                  ; Function:
  5480                                  ;	Find Drive Parameter Block
  5481                                  ; Outputs:
  5482                                  ;	ES:BP points to DPB
  5483                                  ;	[THISDPB] = ES:BP
  5484                                  ;	Carry set if unit number bad or unit is a NET device.
  5485                                  ;		Later case sets extended error error_I24_not_supported
  5486                                  ; No other registers alteredjjj
  5487                                  ;
  5488                                  ;----------------------------------------------------------------------------
  5489                                  
  5490                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5491                                  	; 04/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  5492                                  	; PCDOS 76.1 IBMDOS.COM - DOSCODE:44C7h
  5493                                  GETBP:
  5494                                  	; 15/05/2019 - Retro DOS v4.0
  5495                                  	; 11/07/2018 - Retro DOS v3.0
  5496 0000062C 50                      	PUSH	AX
  5497 0000062D 0401                    	ADD	AL, 1		; No increment; need carry flag
  5498 0000062F 7216                    	JC	SHORT SKIPGET
  5499 00000631 E8516E                  	CALL	GETTHISDRV
  5500                                  	; MSDOS 6.0
  5501 00000634 7311                    	JNC	SHORT SKIPGET		;PM. good drive		;AN000;
  5502 00000636 30E4                    	XOR	AH,AH			;DCR. ax= error code 	;AN000;
  5503 00000638 83F81A                  	CMP	AX,error_not_DOS_disk	;DCR. is unknown media ? ;AN000;
  5504 0000063B 740A                    	JZ	SHORT SKIPGET 		;DCR. yes, let it go 	;AN000;
  5505 0000063D F9                      	STC				;DCR.			;AN000;
  5506 0000063E A3[2403]                	MOV	[EXTERR],AX	;PM. invalid drive or Non DOS drive ;AN000;
  5507 00000641 C706[080E]0102          	MOV	WORD [AbsDskErr],201h
  5508                                  SKIPGET:
  5509 00000647 58                      	POP	AX
  5510 00000648 7212                    	JC	SHORT GETBP_RETN ; 15/12/2022
  5511                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  5512                                  	;jnc	short getbp_t
  5513                                  	;retn
  5514                                  getbp_t:
  5515 0000064A C42E[A205]              	LES	BP,[THISCDS]
  5516                                  	; 15/12/2022
  5517 0000064E 26F6464480              	test	byte [es:bp+curdir.flags+1],curdir_isnet>>8
  5518                                  	; 07/12/2022
  5519                                  	;TEST	WORD [ES:BP+43H],8000H
  5520                                  	;TEST	WORD [ES:BP+curdir.flags],curdir_isnet ; Clears carry
  5521 00000653 7408                    	JZ	SHORT GETBP_CDS
  5522                                  GETBP_err:	; 04/01/2024
  5523 00000655 C706[2403]3200          	MOV	WORD [EXTERR],error_not_supported  ; 32h
  5524 0000065B F9                      	STC
  5525                                  GETBP_RETN:
  5526 0000065C C3                      	RETN
  5527                                  
  5528                                  GETBP_CDS:
  5529                                  	;LES	BP,[ES:BP+45H]
  5530 0000065D 26C46E45                	LES	BP,[ES:BP+curdir.devptr]
  5531                                  	; 04/01/2024 (PCDOS 7.1 IBMDOS.COM)
  5532                                  	;;;
  5533 00000661 50                      	push	ax
  5534 00000662 09E8                    	or	ax,bp
  5535 00000664 58                      	pop	ax
  5536 00000665 74EE                    	jz	short GETBP_err ; zero address, error
  5537                                  	;;;
  5538                                  ;----------------------------------------------------------------------------
  5539                                  GOTDPB:
  5540                                  	; Load THISDPB from ES:BP
  5541 00000667 892E[8A05]              	MOV	[THISDPB],BP
  5542 0000066B 8C06[8C05]              	MOV	[THISDPB+2],ES
  5543 0000066F C3                      	RETN
  5544                                  
  5545                                  ;BREAK <SYS_RET_OK SYS_RET_ERR CAL_LK ETAB_LK set system call returns>
  5546                                  
  5547                                  ;----------------------------------------------------------------------------
  5548                                  ;
  5549                                  ; Procedure Name : SYS_RETURN
  5550                                  ;
  5551                                  ; These are the general system call exit mechanisms. All internal system
  5552                                  ; calls will transfer (jump) to one of these at the end. Their sole purpose
  5553                                  ; is to set the user's flags and set his AX register for return.
  5554                                  ;
  5555                                  ;----------------------------------------------------------------------------
  5556                                  
  5557                                          ;procedure   SYS_RETURN,NEAR
  5558                                  SYS_RETURN:        
  5559                                          ;entry	SYS_RET_OK
  5560                                  SYS_RET_OK:   
  5561 00000670 E804FE                  	call    Get_User_Stack
  5562                                  		; turn off user's carry flag
  5563                                  SYS_RET_OK_clc: ; 25/06/2019 
  5564                                          ;;and	word [SI+16h],0FFFEh 
  5565                                  	;and	word [SI+user_env.user_F],~f_Carry 
  5566                                          ; 25/06/2019
  5567 00000673 806416FE                	and	byte [SI+user_env.user_F],~f_Carry ; 0FEh
  5568                                  	; 04/01/2024
  5569                                  	;JMP	SHORT DO_RET
  5570                                  DO_RET:
  5571                                          ;MOV	[SI+user_env.user_AX],AX ; Really only sets AH
  5572 00000677 8904                    	MOV	[SI],AX
  5573 00000679 C3                      	RETN
  5574                                  
  5575                                          ;entry   SYS_RET_ERR
  5576                                  SYS_RET_ERR:        
  5577 0000067A 30E4                    	XOR     AH,AH 		; hack to allow for smaller error rets
  5578 0000067C E86B00                  	call	ETAB_LK 	; Make sure code is OK, EXTERR gets set
  5579 0000067F E81900                  	CALL	ErrorMap
  5580                                  
  5581                                  	;entry	From_GetSet
  5582                                  From_GetSet:
  5583 00000682 E8F2FD                          call    Get_User_Stack
  5584                                  		 ; signal carry to user
  5585                                  	;;or	word [SI+16h],1
  5586                                  	;OR	word [SI+user_env.user_F],f_Carry
  5587                                  	; 25/06/2019
  5588 00000685 804C1601                	or	byte [SI+user_env.user_F],f_Carry
  5589 00000689 F9                      	STC			; also, signal internal error
  5590                                  	; 04/01/2024
  5591 0000068A EBEB                    	jmp	short DO_RET
  5592                                  ;DO_RET:
  5593                                  	;;MOV	[SI+user_env.user_AX],AX ; Really only sets AH
  5594                                  	;MOV	[SI],AX
  5595                                  	;RETN
  5596                                  
  5597                                  	;entry	FCB_RET_OK
  5598                                  FCB_RET_OK:
  5599                                  	;entry	NO_OP		; obsolete system calls dispatch to here
  5600                                  NO_OP:
  5601 0000068C 30C0                    	XOR	AL,AL
  5602 0000068E C3                      	retn
  5603                                  
  5604                                  	;entry	FCB_RET_ERR
  5605                                  FCB_RET_ERR:
  5606 0000068F 30E4                    	XOR	AH,AH
  5607 00000691 36A3[2403]              	mov	[ss:EXTERR],AX
  5608 00000695 E80300                  	CALL	ErrorMap
  5609 00000698 B0FF                    	MOV	AL,-1
  5610 0000069A C3                      	retn
  5611                                  
  5612                                  	;entry	ErrorMap
  5613                                  ErrorMap:
  5614 0000069B 56                      	PUSH	SI
  5615                                  				; ERR_TABLE_21 is now in DOSDATA
  5616 0000069C BE[220E]                	MOV	SI,ERR_TABLE_21
  5617                                  				; SS override for FAILERR and EXTERR
  5618 0000069F 36803E[4A03]00          	CMP	byte [SS:FAILERR],0 ; Check for SPECIAL case.
  5619 000006A5 7407                    	JZ	short EXTENDED_NORMAL ; All is OK.
  5620                                  		 ; Ooops, this is the REAL reason
  5621                                  	;mov	word [SS:EXTERR],53h
  5622 000006A7 36C706[2403]5300        	MOV	word [SS:EXTERR],error_FAIL_I24
  5623                                  EXTENDED_NORMAL:
  5624 000006AE E80200                  	call	CAL_LK		; Set CLASS,ACTION,LOCUS for EXTERR
  5625 000006B1 5E                      	POP	SI
  5626 000006B2 C3                      	retn
  5627                                  
  5628                                  	;EndProc SYS_RETURN
  5629                                  
  5630                                  ;---------------------------------------------------------------------------
  5631                                  ;
  5632                                  ; Procedure Name : CAL_LK
  5633                                  ;
  5634                                  ; Inputs:
  5635                                  ;	SI is OFFSET in DOSDATA of CLASS,ACTION,LOCUS Table to use
  5636                                  ;		(DS NEED not be DOSDATA)
  5637                                  ;	[EXTERR] is set with error
  5638                                  ; Function:
  5639                                  ;	Look up and set CLASS ACTION and LOCUS values for GetExtendedError
  5640                                  ; Outputs:
  5641                                  ;	[EXTERR_CLASS] set
  5642                                  ;	[EXTERR_ACTION] set
  5643                                  ;	[EXTERR_LOCUS] set  (EXCEPT on certain errors as determined by table)
  5644                                  ; Destroys SI, FLAGS
  5645                                  ;
  5646                                  ;---------------------------------------------------------------------------
  5647                                  
  5648                                  	;procedure CAL_LK,NEAR
  5649                                  CAL_LK:
  5650 000006B3 1E                      	PUSH	DS
  5651 000006B4 50                      	PUSH	AX
  5652 000006B5 53                      	PUSH	BX
  5653                                  
  5654                                  ;M048	Context DS		; DS:SI -> Table
  5655                                  ;
  5656                                  ; Since this function can be called thru int 2f we shall not assume that SS
  5657                                  ; is DOSDATA
  5658                                  
  5659                                  	;getdseg  <ds>	; M048: DS:SI -> Table
  5660                                  	; 15/05/2019 - Retro DOS v4.0
  5661 000006B6 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5662                                  
  5663                                  	; 18/07/2018
  5664                                  	;push	ss
  5665                                  	;pop	ds
  5666                                  
  5667 000006BB 8B1E[2403]              	MOV	BX,[EXTERR]	; Get error in BL
  5668                                  TABLK1:
  5669 000006BF AC                      	LODSB
  5670                                  
  5671 000006C0 3CFF                    	CMP	AL,0FFH
  5672 000006C2 7409                    	JZ	short GOT_VALS	; End of table
  5673 000006C4 38D8                    	CMP	AL,BL
  5674 000006C6 7405                    	JZ	short GOT_VALS	; Got entry
  5675 000006C8 83C603                  	ADD	SI,3		; Next table entry
  5676                                  	; 15/08/2018
  5677 000006CB EBF2                    	JMP	short TABLK1
  5678                                  
  5679                                  GOT_VALS:
  5680 000006CD AD                      	LODSW			; AL is CLASS, AH is ACTION
  5681                                  
  5682 000006CE 80FCFF                  	CMP	AH,0FFH
  5683 000006D1 7404                    	JZ	short NO_SET_ACT
  5684 000006D3 8826[2603]              	MOV	[EXTERR_ACTION],AH ; Set ACTION
  5685                                  NO_SET_ACT:
  5686 000006D7 3CFF                    	CMP	AL,0FFH
  5687 000006D9 7403                    	JZ	short NO_SET_CLS
  5688 000006DB A2[2703]                	MOV	[EXTERR_CLASS],AL ; Set CLASS
  5689                                  NO_SET_CLS:
  5690 000006DE AC                      	LODSB			; Get LOCUS
  5691                                  
  5692 000006DF 3CFF                    	CMP	AL,0FFH
  5693 000006E1 7403                    	JZ	short NO_SET_LOC
  5694 000006E3 A2[2303]                	MOV	[EXTERR_LOCUS],AL
  5695                                  NO_SET_LOC:
  5696 000006E6 5B                      	POP	BX
  5697 000006E7 58                      	POP	AX
  5698 000006E8 1F                      	POP	DS
  5699 000006E9 C3                      	retn
  5700                                  
  5701                                  	;EndProc CAL_LK
  5702                                  
  5703                                  ;---------------------------------------------------------------------------
  5704                                  ;
  5705                                  ; Procedure Name : ETAB_LK
  5706                                  ;
  5707                                  ; Inputs:
  5708                                  ;	AX is error code
  5709                                  ;	[USER_IN_AX] has AH value of system call involved
  5710                                  ; Function:
  5711                                  ;	Make sure error code is appropriate to this call.
  5712                                  ; Outputs:
  5713                                  ;	AX MAY be mapped error code
  5714                                  ;	[EXTERR] = Input AX
  5715                                  ; Destroys ONLY AX and FLAGS
  5716                                  ;
  5717                                  ;---------------------------------------------------------------------------
  5718                                  
  5719                                  	;procedure ETAB_LK,NEAR
  5720                                  
  5721                                  ETAB_LK: ; 10/08/2018 - Retro DOS v3.0
  5722 000006EA 1E                      	PUSH	DS
  5723 000006EB 56                      	PUSH	SI
  5724 000006EC 51                      	PUSH	CX
  5725 000006ED 53                      	PUSH	BX
  5726                                  
  5727                                  	;Context DS			; SS is DOSDATA
  5728                                  
  5729 000006EE 16                      	push	ss
  5730 000006EF 1F                      	pop	ds
  5731                                  
  5732 000006F0 A3[2403]                	MOV	[EXTERR],AX		; Set EXTERR with "real" error
  5733                                  
  5734                                  					; I21_MAP_E_TAB is now in DOSCODE
  5735 000006F3 BE[0B00]                	MOV	SI,I21_MAP_E_TAB
  5736 000006F6 88C7                    	MOV	BH,AL			; Real code to BH
  5737 000006F8 8A1E[3B03]              	MOV	BL,[USER_IN_AX+1]	; Sys call to BL
  5738                                  TABLK2:
  5739                                  	; 15/05/2019 - Retro DOS v4.0
  5740 000006FC 2E                      	cs
  5741 000006FD AD                      	lodsw	; MSDOS 6.0 (MSDOS 6.21 - MSDOS.SYS, DOSCODE:447Dh)
  5742                                  	
  5743                                  	; 18/07/2018 - Retro DOS v3.0
  5744                                  	;lodsw		; IBMDOS.COM (MSDOS 3.3) - Offset 16F7h
  5745                                  
  5746 000006FE 3CFF                    	CMP	AL,0FFH 		; End of table?
  5747 00000700 740C                    	JZ	short NOT_IN_TABLE	; Yes
  5748 00000702 38D8                    	CMP	AL,BL			; Found call?
  5749 00000704 740C                    	JZ	short GOT_CALL		; Yes
  5750 00000706 86E0                    	XCHG	AH,AL			; Count to AL
  5751 00000708 30E4                    	XOR	AH,AH			; Make word for add
  5752 0000070A 01C6                    	ADD	SI,AX			; Next table entry
  5753 0000070C EBEE                    	JMP	short TABLK2
  5754                                  
  5755                                  NOT_IN_TABLE:
  5756 0000070E 88F8                    	MOV	AL,BH			; Restore original code
  5757 00000710 EB0C                    	JMP	SHORT NO_MAP
  5758                                  
  5759                                  GOT_CALL:
  5760 00000712 88E1                    	MOV	CL,AH
  5761 00000714 30ED                    	XOR	CH,CH			; Count of valid err codes to CX
  5762                                  CHECK_CODE:
  5763                                  	; 15/05/2019 - Retro DOS v4.0
  5764 00000716 2E                      	cs
  5765 00000717 AC                      	lodsb	; MSDOS 6.0 (MSDOS 6.21 - MSDOS.SYS, DOSCODE:4497h)
  5766                                  
  5767                                  	; 18/07/2018
  5768                                  	;lodsb		; IBMDOS.COM (MSDOS 3.3) - Offset 1710h
  5769                                  
  5770 00000718 38F8                    	CMP	AL,BH			; Code OK?
  5771 0000071A 7402                    	JZ	short NO_MAP		; Yes
  5772 0000071C E2F8                    	LOOP	CHECK_CODE
  5773                                  NO_MAP:
  5774 0000071E 30E4                    	XOR	AH,AH			; AX is now valid code
  5775 00000720 5B                      	POP	BX
  5776 00000721 59                      	POP	CX
  5777 00000722 5E                      	POP	SI
  5778 00000723 1F                      	POP	DS
  5779 00000724 C3                      	retn
  5780                                  
  5781                                  	;EndProc ETAB_LK
  5782                                  
  5783                                  ; 18/07/2018 - Retro DOS v3.0
  5784                                  ;---------------------------------------------------------------------------
  5785                                  ; BREAK <DOS 2F Handler and default NET 2F handler>
  5786                                  
  5787                                  ;IF installed ; (*)
  5788                                  
  5789                                  ;---------------------------------------------------------------------------
  5790                                  ;
  5791                                  ; Procedure Name : SetBad
  5792                                  ;
  5793                                  ; SetBad sets up info for bad functions
  5794                                  ;
  5795                                  ;---------------------------------------------------------------------------
  5796                                  
  5797                                  SetBad:
  5798                                  	;mov	ax,1
  5799 00000725 B80100                  	MOV	AX,error_invalid_function ; ALL NET REQUESTS get inv func
  5800                                  
  5801                                  	; MSDOS 3.3
  5802                                  	;;mov	byte [cs:EXTERR_LOCUS],1
  5803                                  	;MOV	byte [CS:EXTERR_LOCUS],errLOC_Unk
  5804                                  
  5805                                  ;	set up ds to point to DOSDATA
  5806                                  
  5807                                  	; 15/05/2019 - Retro DOS v4.0
  5808                                  	; MSDOS 6.0
  5809 00000728 1E                      	push	ds
  5810                                  
  5811                                  	;getdseg <ds>
  5812 00000729 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5813                                  
  5814 0000072E C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1	
  5815                                  
  5816 00000733 1F                      	pop	ds	  	;hkn; restore ds
  5817                                  
  5818 00000734 F9                      	STC
  5819 00000735 C3                      	retn
  5820                                  
  5821                                  ;--------------------------------------------------------------------------
  5822                                  ;
  5823                                  ; Procedure Name : BadCall
  5824                                  ;
  5825                                  ; BadCall is the initial routine for bad function calls
  5826                                  ;
  5827                                  ;--------------------------------------------------------------------------
  5828                                  
  5829                                  BadCall:
  5830 00000736 E8ECFF                  	call	SetBad
  5831 00000739 CB                      	retf
  5832                                  
  5833                                  ;--------------------------------------------------------------------------
  5834                                  ;
  5835                                  ; OKCall always sets carry to off.
  5836                                  ;
  5837                                  ;-----------------------------------------------------------------------
  5838                                  
  5839                                  OKCall:
  5840 0000073A F8                      	CLC
  5841 0000073B CB                      	retf
  5842                                  
  5843                                  ;---------------------------------------------------------------------------
  5844                                  ;
  5845                                  ; Procedure Name : INT2F
  5846                                  ;
  5847                                  ; INT 2F handler works as follows:
  5848                                  ;   PUSH    AX
  5849                                  ;   MOV     AX,multiplex:function
  5850                                  ;   INT     2F
  5851                                  ;   POP     ...
  5852                                  ; The handler itself needs to make the AX available for the various routines.
  5853                                  ;
  5854                                  ;----------------------------------------------------------------------------
  5855                                  
  5856                                  ; 15/05/2019 - Retro DOS v4.0
  5857                                  
  5858                                  ;KERNEL_SEGMENT equ 70h
  5859                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5860                                  DOSBIODATASEG equ 70h
  5861                                  
  5862                                  ; retrodos4.s - offset in BIOSDATA
  5863                                  bios_i2f equ 5
  5864                                  
  5865                                  ;PUBLIC	Int2F
  5866                                  ;INT2F	PROC	FAR
  5867                                  
  5868                                  ; 15/05/2019
  5869                                  ; DOSCODE:44BDh (MSDOS 6.21, MSDOS.SYS)
  5870                                  
  5871                                  ; 04/11/2022
  5872                                  ; DOSCODE:44B0h (MSDOS 5.0, MSDOS.SYS)
  5873                                  
  5874                                  	; 15/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5875                                  	; 18/07/2018 - Retro DOS v3.0
  5876                                  	; 05/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  5877                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:45DAh
  5878                                  INT2F:
  5879                                  	; Offset 172Fh in IBMDOS.COM (MSDOS 3.3), 1987
  5880                                  INT2FNT:
  5881                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5882 0000073C FB                      	STI
  5883                                  	;cmp	ah,11h
  5884 0000073D 80FC11                  	CMP	AH,MultNET
  5885 00000740 750A                    	JNZ	short INT2FSHR
  5886                                  TestInstall:
  5887 00000742 08C0                    	OR	AL,AL
  5888 00000744 7403                    	JZ	short Leave2F
  5889                                  BadFunc:
  5890 00000746 E8DCFF                  	CALL	SetBad
  5891                                  
  5892                                  	;entry	Leave2F
  5893                                  Leave2F:
  5894 00000749 CA0200                  	RETF	2			; long return + clear flags off stack
  5895                                  
  5896                                  INT2FSHR:
  5897                                  	;cmp	ah,10h
  5898 0000074C 80FC10                  	CMP	AH,MultSHARE		; is this a share request
  5899 0000074F 74F1                    	JZ	short TestInstall	; yes, check for installation
  5900                                  INT2FNLS:
  5901                                  	;cmp	ah,14h
  5902 00000751 80FC14                  	CMP	AH,NLSFUNC		; is this a DOS 3.3 NLSFUNC request
  5903 00000754 74EC                    	JZ	short TestInstall	; yes check for installation
  5904                                  INT2FDOS:
  5905                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5906                                  
  5907                                  	; 18/07/2018
  5908                                  	; MSDOS 3.3
  5909                                  	;;cmp	ah,12h	
  5910                                  	;CMP	AH,MultDOS
  5911                                  	;jz	short DispatchDOS
  5912                                  	;iret
  5913                                  
  5914                                  	; 15/05/2019
  5915                                  	; MSDOS 6.0
  5916                                  	;cmp	ah,12h	; 07/12/2022
  5917 00000756 80FC12                  	CMP	AH,MultDOS
  5918 00000759 7503                    	JNZ	short check_win		;check if win386 broadcast
  5919 0000075B E93F02                  	jmp	DispatchDOS
  5920                                  
  5921                                  	; .... win386 .... 
  5922                                  
  5923                                  check_win:
  5924                                  	;cmp	ah,16h
  5925 0000075E 80FC16                  	cmp	ah,MultWin386		; Is this a broadcast from Win386?
  5926 00000761 7408                    	je	short Win386_Msg
  5927                                  
  5928                                  	; M044
  5929                                  	; Check if the callout is from Winoldap indicating swapping out or in 
  5930                                  	; of Windows. If so, do special action of going and saving last para
  5931                                  	; of the Windows memory arena which Winoldap does not save due to a 
  5932                                  	; bug
  5933                                  
  5934 00000763 80FC46                  	cmp	ah,WINOLDAP ; 46h	; from Winoldap?
  5935                                  	;jne	short next_i2f		; no, chain on
  5936                                  	; 15/12/2022
  5937                                  	;jmp	winold_swap		; yes, do desired action
  5938 00000766 7460                    	je	short winold_swap
  5939 00000768 E92301                  	jmp	next_i2f
  5940                                  
  5941                                  	; 15/12/2022
  5942                                  ;next_i2f:
  5943                                  ;	;;;jmp	bios_i2f
  5944                                  ;	;;jmp	far ptr 70h:5 ; MSDOS 6.21 (MSDOS.SYS, DOSCODE:44F1h)
  5945                                  ;	;jmp	KERNEL_SEGMENT:bios_i2f
  5946                                  ;	; 04/11/2022
  5947                                  ;	jmp	DOSBIODATASEG:bios_i2f
  5948                                  
  5949                                  ;	IRET				; This assume that we are at the head
  5950                                  					; of the list
  5951                                  ;INT2F	ENDP
  5952                                  
  5953                                  ; 15/05/2019 - Retro DOS v4.0
  5954                                  
  5955                                  ; We have received a message from Win386. There are three possible
  5956                                  ; messages we could get from Win386:
  5957                                  ;
  5958                                  ; Init 		- for this, we set the IsWin386 flag and return a pointer
  5959                                  ;		  to the Win386 startup info structure.
  5960                                  ; Exit		- for this, we clear the IsWin386 flag.
  5961                                  ; DOSMGR query 	- for this, we need to indicate that instance data
  5962                                  ;		  has already been handled. this is indicated by setting
  5963                                  ;		  CX to a non-zero value.
  5964                                  
  5965                                  Win386_Msg:
  5966 0000076B 1E                      	push	ds
  5967                                  
  5968                                  	;getdseg <DS>			; ds is DOSDATA
  5969 0000076C 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5970                                  
  5971                                  	; For WIN386 2.xx instance data
  5972                                  
  5973 00000771 3C03                    	cmp	al,3			; win386 2.xx instance data call?
  5974 00000773 7503                    	jne	short Win386_Msg_exit
  5975 00000775 E94801                  	jmp	OldWin386Init		; yes, return instance data
  5976                                  Win386_Msg_exit:
  5977 00000778 3C06                    	cmp	al,Win386_Exit	 ; 6	; is it an exit call?
  5978 0000077A 7503                    	jne	short Win386_Msg_devcall
  5979 0000077C E94A01                  	jmp	Win386_Leaving
  5980                                  Win386_Msg_devcall:
  5981 0000077F 3C07                    	cmp	al,Win386_Devcall ; 7	; is it call from DOSMGR?
  5982 00000781 7503                    	jne	short Win386_Msg_init
  5983 00000783 E97E01                  	jmp	Win386_Query
  5984                                  Win386_Msg_init:
  5985 00000786 3C05                    	cmp	al,Win386_Init	; 5	; is it an init call?
  5986 00000788 7403                    	je	short Win386_Starting
  5987 0000078A E90001                  	jmp	win_nexti2f		; no, return
  5988                                  
  5989                                  Win386_Starting:
  5990                                  	; 05/01/2024 - Retro DOS v5.0
  5991                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:4630h
  5992                                  	;;;
  5993 0000078D 50                      	push	ax
  5994 0000078E 51                      	push	cx
  5995 0000078F 57                      	push	di
  5996 00000790 06                      	push	es
  5997 00000791 1E                      	push	ds
  5998 00000792 07                      	pop	es
  5999 00000793 BF[FB01]                	mov	di,INBUF
  6000 00000796 B90500                  	mov	cx,5
  6001 00000799 FC                      	cld
  6002                                  Win386_s_floop:
  6003 0000079A B8434F                  	mov	ax,'CO'	; 4F43h
  6004 0000079D AB                      	stosw
  6005 0000079E B84E20                  	mov	ax,'N '	; 204Eh
  6006 000007A1 AB                      	stosw
  6007 000007A2 83C737                  	add	di,55	; (write 5 times 'CON ' and skip 55 bytes between them)
  6008                                  			; what for ?
  6009 000007A5 E2F3                    	loop	Win386_s_floop
  6010 000007A7 07                      	pop	es
  6011 000007A8 5F                      	pop	di
  6012 000007A9 59                      	pop	cx
  6013 000007AA 58                      	pop	ax
  6014                                  	;;;
  6015                                  
  6016                                  	; 17/12/2022
  6017 000007AB F6C201                  	test	dl,1
  6018                                  	;test	dx,1			; is this really win386?
  6019 000007AE 7403                    	jz	short Win386_vchk	; YES! go and handle it
  6020 000007B0 E9DA00                  	jmp	win_nexti2f		; NO! It's win 286 dos extender! M002
  6021                                  Win386_vchk:
  6022                                  	; M018 -- start of block changes
  6023                                  	; The VxD needs to be loaded only for Win 3.0. If version is greater 
  6024                                  	; than 030Ah, we skip the VxD presence check
  6025                                  
  6026                                  ;M067 -- Begin changes
  6027                                  ; If Win 3.0 is run, the VxD ptr has been initialized. If Win 3.1 is now
  6028                                  ;run, it tries to unnecesarily load the VxD even though it is not needed.
  6029                                  ;So, we null out the VxD ptr before the check.
  6030                                  
  6031                                  	;mov	word [Win386_Info+6],0
  6032 000007B3 C706[2D10]0000          	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],0
  6033                                  	;mov	word [Win386_Info+8],0
  6034 000007B9 C706[2F10]0000          	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2],0
  6035                                  
  6036                                  ;M067 -- End changes
  6037                                  
  6038                                  ;ifdef JAPAN
  6039                                  ;	cmp	di,0300h		; version >= 300 i.e 3.10 ;M037
  6040                                  ;else
  6041                                  	;cmp	di,030Ah		; version >= 30a i.e 3.10 ;M037
  6042                                  	; 05/01/2024 - PCDOS 7.1 - Retro DOS v5.0
  6043 000007BF 81FF0004                	cmp	di,0400h		; version >= 400 ; 05/01/2024
  6044                                  ;endif
  6045                                  	;ljae	noVxD31			; yes, VxD not needed 	 ;M037
  6046 000007C3 724E                    	jb	short Win386_vxd
  6047 000007C5 E9DD00                  	jmp	noVxD31
  6048                                  
  6049                                  	; 15/12/2022
  6050                                  winold_swap:
  6051 000007C8 1E                      	push	ds
  6052 000007C9 06                      	push	es
  6053 000007CA 56                      	push	si
  6054 000007CB 57                      	push	di
  6055 000007CC 51                      	push	cx
  6056                                  
  6057                                  	;getdseg <ds>			;ds = DOSDATA
  6058 000007CD 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6059                                  
  6060 000007D2 3C01                    	cmp	al,1			;swap Windows out call
  6061 000007D4 751B                    	jne	short swapin		;no, check if Swap in call
  6062 000007D6 E88801                  	call	getwinlast
  6063 000007D9 1E                      	push	ds
  6064 000007DA 07                      	pop	es
  6065 000007DB 8EDE                    	mov	ds,si			;ds = memory arena of Windows
  6066 000007DD 31F6                    	xor	si,si
  6067                                  	;mov	di,6 ; 05/01/2024
  6068 000007DF BF[0600]                	mov	di,WinoldPatch1 ; 6
  6069 000007E2 B90800                  	mov	cx,8
  6070 000007E5 FC                      	cld
  6071 000007E6 51                      	push	cx
  6072 000007E7 F3A4                    	rep	movsb			;save first 8 bytes
  6073 000007E9 59                      	pop	cx
  6074                                  	;mov	di,1176h ; 05/01/2024
  6075 000007EA BF[9D12]                	mov	di,WinoldPatch2 ; 1176h
  6076 000007ED F3A4                    	rep	movsb			;save next 8 bytes
  6077 000007EF EB1B                    	jmp	short winold_done
  6078                                  swapin:
  6079 000007F1 3C02                    	cmp	al,2			;swap Windows in call?
  6080 000007F3 7517                    	jne	short winold_done	;no, something else, pass it on
  6081 000007F5 E86901                  	call	getwinlast
  6082 000007F8 8EC6                    	mov	es,si
  6083 000007FA 31FF                    	xor	di,di
  6084 000007FC BE[0600]                	mov	si,WinoldPatch1
  6085 000007FF B90800                  	mov	cx,8
  6086 00000802 FC                      	cld
  6087 00000803 51                      	push	cx
  6088 00000804 F3A4                    	rep	movsb			;restore first 8 bytes
  6089 00000806 59                      	pop	cx
  6090 00000807 BE[9D12]                	mov	si,WinoldPatch2
  6091 0000080A F3A4                    	rep	movsb			;restore next 8 bytes
  6092                                  winold_done:
  6093 0000080C 59                      	pop	cx
  6094 0000080D 5F                      	pop	di
  6095 0000080E 5E                      	pop	si
  6096 0000080F 07                      	pop	es
  6097 00000810 1F                      	pop	ds
  6098 00000811 EB7B                    	jmp	short next_i2f		;chain on
  6099                                  	; 15/12/2022
  6100                                  	;jmp	next_i2f	
  6101                                  
  6102                                  Win386_vxd:
  6103 00000813 50                      	push	ax
  6104 00000814 53                      	push	bx
  6105 00000815 51                      	push	cx
  6106 00000816 52                      	push	dx
  6107 00000817 56                      	push	si
  6108 00000818 57                      	push	di			; save regs !!dont change order!!
  6109                                  
  6110 00000819 8B1E[8C00]              	mov	bx,[UMB_HEAD]		; M062 - Start
  6111 0000081D 83FBFF                  	cmp	bx,0FFFFh    		; Q: have umbs been initialized
  6112 00000820 741F                    	je	short Vxd31		; N: continue
  6113                                  					; Y: save arena associated with 
  6114                                  					;    umb_head
  6115                                  
  6116 00000822 C606[210E]01            	mov	byte [UmbSaveFlag],1	; indicate that we're saving 
  6117                                  					; umb_arena
  6118 00000827 1E                      	push	ds
  6119 00000828 06                      	push	es
  6120                                  
  6121                                  	;mov	ax,ds
  6122                                  	;mov	es,ax			; es - > dosdata
  6123                                  	; 05/01/2024
  6124 00000829 1E                      	push	ds
  6125 0000082A 07                      	pop	es
  6126                                  
  6127 0000082B 8EDB                    	mov	ds,bx
  6128 0000082D 31F6                    	xor	si,si			; ds:si -> umb_head
  6129                                  
  6130                                  	; 05/01/2024 PCDOS 7.1
  6131                                  	;;;			
  6132                                  	;clc	; not necessary (XOR already clears CF)
  6133                                  
  6134                                  restore_ubmhead:		; !! PCDOS 7.1 bug !!
  6135                                  				; jump from 'Win386_Leaving' here was/is wrong
  6136                                  				; (DI and SI would be reversed for 'Win386_Leaving')
  6137                                  				; Erdogan Tan - 05/01/2024
  6138                                  	;;;
  6139                                  
  6140 0000082F FC                      	cld
  6141                                  
  6142 00000830 BF[5612]                	mov	di,UmbSave1
  6143 00000833 B90B00                  	mov	cx,11
  6144 00000836 F3A4                    	rep	movsb
  6145                                  
  6146 00000838 BF[1C0E]                	mov	di,UmbSave2
  6147                                  	;mov	cx,5
  6148                                  	; 18/12/2022
  6149 0000083B B105                    	mov	cl,5
  6150 0000083D F3A4                    	rep	movsb
  6151                                  	
  6152                                  	; 05/01/2024 PCDOS 7.1
  6153                                  	;;;	
  6154                                  	;jnb	short restore_ubmhead_c ; (not jumped from 'Win386_Leaving')
  6155                                  	;jmp	restore_ubmhead_ok ; (jumped from 'Win386_Leaving' just after 'stc')
  6156                                  ;restore_ubmhead_c:
  6157                                  	;;;
  6158                                  
  6159 0000083F 07                      	pop	es
  6160 00000840 1F                      	pop	ds			; M062 - End
  6161                                  
  6162                                  Vxd31:
  6163                                  	;test	byte [DOS_FLAG],2
  6164 00000841 F606[8600]02            	test	byte [DOS_FLAG],SUPPRESS_WINA20	; M066
  6165 00000846 7408                    	jz	short Dont_Supress		; M066
  6166 00000848 5F                      	pop	di				; M066
  6167 00000849 5E                      	pop	si				; M066
  6168 0000084A 5A                      	pop	dx				; M066
  6169 0000084B 59                      	pop	cx				; M066
  6170 0000084C 5B                      	pop	bx				; M066
  6171 0000084D 58                      	pop	ax				; M066
  6172 0000084E EB55                    	jmp	short noVxD31			; M066
  6173                                  
  6174                                  	; We check here if the VxD is available in the root of the boot drive. 
  6175                                  	; We do an extended open to suppress any error messages
  6176                                  	
  6177                                  Dont_Supress:
  6178 00000850 A0[6900]                	mov	al,[BOOTDRIVE]
  6179 00000853 0440                    	add	al,'A' - 1		; get drive letter
  6180 00000855 A2[1F14]                	mov	[VxDpath],al		; path is root of bootdrive
  6181                                  	;mov	ah,ExtOpen  ;6Ch	; extended open
  6182                                  	;mov	al,0			; no extended attributes
  6183                                  	; 18/12/2022
  6184 00000858 B8006C                  	mov	ax,ExtOpen<<8 ; 6C00h
  6185 0000085B BB8020                  	mov	bx,2080h		; read access, compatibility mode
  6186                                  					; no inherit, suppress crit err
  6187 0000085E B90700                  	mov	cx,7			; hidden,system,read-only attr
  6188                                  	;05/01/2024
  6189                                  	;inc	dx			; dx bit 0 = 1 ; fail if file does not exist
  6190 00000861 BA0100                  	mov	dx,1			; fail if file does not exist
  6191                                  	
  6192 00000864 BE[1F14]                	mov	si,VxDpath ; "c:\\wina20.386"	
  6193                                  					; path of VxD file
  6194 00000867 BFFFFF                  	mov	di,0FFFFh		; no extended attributes
  6195                                  
  6196 0000086A CD21                    	int	21h			; do extended open
  6197                                  
  6198 0000086C 5F                      	pop	di
  6199 0000086D 5E                      	pop	si
  6200 0000086E 5A                      	pop	dx
  6201 0000086F 59                      	pop	cx
  6202                                  
  6203 00000870 7321                    	jnc	short VxDthere		; we found the VxD, go ahead
  6204                                  
  6205                                  	; We could not find the VxD. Cannot let windows load. Return cx != 0 
  6206                                  	; to indicate error to Windows after displaying message to user that 
  6207                                  	; VxD needs to be present to run Windows in enhanced mode.
  6208                                  
  6209 00000872 52                      	push	dx
  6210 00000873 1E                      	push	ds
  6211 00000874 56                      	push	si
  6212 00000875 BE[320A]                	mov	si,NoVxDErrMsg
  6213 00000878 0E                      	push	cs
  6214 00000879 1F                      	pop	ds
  6215 0000087A B96300                  	mov	cx,VxDMesLen ; 99	;
  6216 0000087D B402                    	mov	ah,2			; write char to console
  6217 0000087F FC                      	cld
  6218                                  vxdlp:
  6219 00000880 AC                      	lodsb
  6220 00000881 86D0                    	xchg	dl,al			; get char in dl
  6221 00000883 CD21                    	int	21h
  6222 00000885 E2F9                    	loop	vxdlp
  6223                                  
  6224 00000887 5E                      	pop	si
  6225 00000888 1F                      	pop	ds
  6226 00000889 5A                      	pop	dx
  6227 0000088A 5B                      	pop	bx
  6228 0000088B 58                      	pop	ax			;all registers restored
  6229 0000088C 41                      	inc	cx			;cx != 0 to indicate error
  6230                                  	; 15/12/22022
  6231                                  	;jmp	win_nexti2f		;chain on
  6232                                  	;jmp	short win_nexti2f
  6233                                  
  6234                                  	; 15/12/2022
  6235                                  win_nexti2f:
  6236 0000088D 1F                      	pop	ds
  6237                                  	;jmp	short next_i2f		; go to BIOS i2f handler
  6238                                  	; 15/12/2022
  6239                                  next_i2f:
  6240                                  	;;;jmp	bios_i2f
  6241                                  	;;jmp	far ptr 70h:5 ; MSDOS 6.21 (MSDOS.SYS, DOSCODE:44F1h)
  6242                                  	;jmp	KERNEL_SEGMENT:bios_i2f
  6243                                  	; 04/11/2022
  6244 0000088E EA05007000              	jmp	DOSBIODATASEG:bios_i2f
  6245                                  
  6246                                  VxDthere:
  6247 00000893 89C3                    	mov	bx,ax
  6248 00000895 B43E                    	mov	ah,CLOSE ; 3Eh
  6249 00000897 CD21                    	int	21h			;close the file
  6250                                  
  6251                                  	; Update the VxD ptr in the instance data structure with path to VxD
  6252                                  
  6253                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  6254                                  	;mov	bx,Win386_Info
  6255                                  	;mov	word [bx+Win386_SIS.Virt_Dev_File_Ptr],VxDpath
  6256                                  	;mov	word [bx+Win386_SIS.Virt_Dev_File_Ptr+2],ds
  6257                                  	; 15/12/2022
  6258 00000899 C706[2D10][1F14]        	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],VxDpath
  6259 0000089F 8C1E[2F10]              	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2],ds
  6260                                  
  6261 000008A3 5B                      	pop	bx
  6262 000008A4 58                      	pop	ax
  6263                                  noVxD31:
  6264                                  	; M018; End of block changes
  6265                                  
  6266 000008A5 800E[A110]01            	or	byte [IsWin386],1 	; Indicate WIN386 present
  6267 000008AA 800E[860D]01            	or	byte [redir_patch],1	; Enable critical sections; M002
  6268                                  
  6269                                  	; M002;
  6270                                  	; Save the previous es:bx (instance data ptr) into our instance table
  6271                                  
  6272 000008AF 52                      	push	dx			; M002
  6273 000008B0 89DA                    	mov	dx,bx			; M002
  6274                                  					; point ES:BX to Win386_Info ; M002
  6275 000008B2 BB[2710]                	mov	bx,Win386_Info 
  6276 000008B5 895702                  	mov	[bx+2],dx		; M002
  6277 000008B8 8C4704                  	mov	[bx+4],es		; M002
  6278 000008BB 5A                      	pop	dx			; M002
  6279 000008BC 1E                      	push	ds			; M002
  6280 000008BD 07                      	pop	es			; M002
  6281                                  	;jmp	win_nexti2f		; M002
  6282                                  	; 15/12/2022
  6283 000008BE EBCD                    	jmp	short win_nexti2f
  6284                                  
  6285                                  	; 15/12/2022
  6286                                  	; Code to return Win386 2.xx instance table
  6287                                  OldWin386Init:
  6288 000008C0 58                      	pop	ax			; discard ds pushed on stack
  6289 000008C1 BE[2C12]                	mov	si,OldInstanceJunk 
  6290                                  					; ds:si = instance table
  6291 000008C4 B84852                  	mov	ax,5248h ; 'HR'		; indicate instance data present
  6292                                  	;jmp	next_i2f
  6293                                  	; 15/12/2022
  6294 000008C7 EBC5                    	jmp	short next_i2f
  6295                                  
  6296                                  Win386_Leaving:
  6297                                  	; 15/12/2022
  6298 000008C9 F6C201                  	test 	dl,1
  6299                                  	;test	dx,1			; is this really win386?
  6300                                  	;jz	short Win386_Leaving_c
  6301                                  	;jmp	win_nexti2f		; NO! It's win 286 dos extender! M002
  6302                                  	; 15/12/2022
  6303 000008CC 75BF                    	jnz	short win_nexti2f	
  6304                                  
  6305                                  Win386_Leaving_c:
  6306                                  					; M062 - Start
  6307 000008CE 803E[210E]01            	cmp	byte [UmbSaveFlag],1	; Q: was umb_arena saved at win start
  6308                                  					;    up.
  6309 000008D3 7523                    	jne	short noumb		; N: not saved 
  6310 000008D5 C606[210E]00            	mov	byte [UmbSaveFlag],0	; Y: clear UmbSaveFlag and restore 
  6311                                  					;    previously saved umb_head
  6312                                  
  6313                                  	; 05/01/2024 - PCDOS 7.1 (has BUG here!)
  6314                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:472Bh
  6315                                  	;;;
  6316                                  	;push	ax ; (not necessary)
  6317                                  	;push	es
  6318                                  	;push	cx
  6319                                  	;push	si
  6320                                  	;push	di
  6321                                  	;mov	es,[UMB_HEAD]
  6322                                  	;xor	di,di
  6323                                  	;stc
  6324                                  	;jmp	restore_ubmhead	; !! PCDOS 7.1 bug !! IBMDOS.COM - DOSCODE:4737h
  6325                                  	;			; (jumped code does not restore umbhead,
  6326                                  	;			; MSDOS 6.22 "Win386_Leaving" code was/is correct,
  6327                                  	;			; modified code -in PCDOS 7.1 IBMDOS.COM- is wrong)
  6328                                  	;			; Erdogan Tan - 05/01/2024
  6329                                  	;
  6330                                  	;;;
  6331                                  
  6332                                  	; 05/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1)
  6333                                  	;push	ax ; (not necessary)
  6334 000008DA 06                      	push	es
  6335 000008DB 51                      	push	cx
  6336 000008DC 56                      	push	si
  6337 000008DD 57                      	push	di
  6338                                  
  6339                                  	;mov	ax,[UMB_HEAD]
  6340                                  	;mov	es,ax
  6341                                  	; 05/01/2024
  6342 000008DE 8E06[8C00]              	mov	es,[UMB_HEAD]
  6343 000008E2 31FF                    	xor	di,di			; es:di -> umb_head
  6344                                  
  6345 000008E4 FC                      	cld
  6346                                  
  6347 000008E5 BE[5612]                	mov	si,UmbSave1
  6348 000008E8 B90B00                  	mov	cx,11
  6349 000008EB F3A4                    	rep	movsb
  6350 000008ED BE[1C0E]                	mov	si,UmbSave2
  6351                                  	;mov	cx,5
  6352                                  	; 18/12/2022
  6353 000008F0 B105                    	mov	cl,5
  6354 000008F2 F3A4                    	rep	movsb
  6355                                  
  6356                                  restore_ubmhead_ok:	; 05/01/2024 - PCDOS 7.1 IBMDOS.COM - DOSCODE:473Ah
  6357 000008F4 5F                      	pop	di
  6358 000008F5 5E                      	pop	si
  6359 000008F6 59                      	pop	cx
  6360 000008F7 07                      	pop	es
  6361                                  	; 05/01/2024
  6362                                  	;pop	ax
  6363                                  noumb:					; M062 - End
  6364 000008F8 8026[A110]00            	and	byte [IsWin386],0	; Win386 is gone
  6365 000008FD 8026[860D]00            	and	byte [redir_patch],0	; Disable critical sections ; M002
  6366 00000902 EB89                    	jmp	short win_nexti2f
  6367                                  
  6368                                  ;	; 15/12/2022
  6369                                  ;	; Code to return Win386 2.xx instance table
  6370                                  ;OldWin386Init:
  6371                                  ;	pop	ax			; discard ds pushed on stack
  6372                                  ;	mov	si,OldInstanceJunk 
  6373                                  ;					; ds:si = instance table
  6374                                  ;	mov	ax,5248h ; 'RH'		; indicate instance data present
  6375                                  ;	;jmp	next_i2f
  6376                                  ;	; 15/12/2022
  6377                                  ;	jmp	short _next_i2f
  6378                                  
  6379                                  Win386_Query:
  6380 00000904 83FB15                  	cmp	bx,Win386_DOSMGR ; 15h	; is this from DOSMGR?
  6381 00000907 7584                    	jne	short win_nexti2f     	; no, ignore it & chain to next
  6382 00000909 09C9                    	or	cx,cx			; is it an instance query?
  6383 0000090B 7508                    	jnz	short dosmgr_func	; no, some DOSMGR query
  6384 0000090D 41                      	inc	cx			; indicate that data is instanced
  6385                                  ;
  6386                                  ; M001; We were previously returning a null ptr in es:bx. This will not work.
  6387                                  ; M001; WIN386 needs a ptr to a table in es:bx with the following offsets:
  6388                                  ; M001;  
  6389                                  ; M001; OFFSETS STRUC
  6390                                  ; M001; 	Major_version	db	?
  6391                                  ; M001; 	Minor_version	db	?
  6392                                  ; M001; 	SaveDS		dw	?
  6393                                  ; M001; 	SaveBX		dw	?
  6394                                  ; M001; 	Indos		dw	?
  6395                                  ; M001; 	User_id		dw	?
  6396                                  ; M001; 	CritPatch	dw	?
  6397                                  ; M001; OFFSETS	ENDS
  6398                                  ; M001; 
  6399                                  ; M001; User_Id is the only variable really important for proper functioning  
  6400                                  ; M001; of Win386. The other variables are used at init time to patch stuff
  6401                                  ; M001; out. In DOS 5.0, we do the patching ourselves. But we still need to 
  6402                                  ; M001; pass this table because Win386 depends on this table to get the 
  6403                                  ; M001; User_Id offset.
  6404                                  ; M001; 
  6405 0000090E BB[9310]                	mov	bx,Win386_DOSVars	; M001 
  6406 00000911 1E                      	push	ds			; M001
  6407 00000912 07                      	pop	es			; es:bx points at offset table ; M001
  6408 00000913 EB40                    	jmp	short PopIret		; M001
  6409                                  
  6410                                  ; 15/12/2022
  6411                                  ;	; Code to return Win386 2.xx instance table
  6412                                  ;OldWin386Init:
  6413                                  ;	pop	ax			; discard ds pushed on stack
  6414                                  ;	mov	si,OldInstanceJunk 
  6415                                  ;					; ds:si = instance table
  6416                                  ;	mov	ax,5248h ; 'RH'		; indicate instance data present
  6417                                  ;	;jmp	next_i2f
  6418                                  ;	; 15/12/2022
  6419                                  ;	jmp	short _next_i2f
  6420                                  
  6421                                  dosmgr_func:
  6422 00000915 49                      	dec	cx
  6423 00000916 7435                    	jz	short win386_patch	; call to patch DOS
  6424 00000918 49                      	dec	cx
  6425 00000919 743A                    	jz	short PopIret		; remove DOS patches, ignore
  6426 0000091B 49                      	dec	cx
  6427 0000091C 7439                    	jz	short win386_size	; get size of DOS data structures
  6428 0000091E 49                      	dec	cx
  6429 0000091F 7428                    	jz	short win386_inst	; instance more data
  6430                                  	;dec	cx
  6431                                  	;jnz	short PopIret		; no functions above this
  6432                                  	; 05/01/2024 (PCDOS 7.1 IBMDOS.COM DOSCODE:4771h)
  6433 00000921 E232                    	loop	PopIret
  6434                                  
  6435                                  	; Get DOS device driver size -- es:di points at device driver header
  6436                                  	; In DOS 4.x, the para before the device header contains an arena 
  6437                                  	; header for the driver.
  6438                                  
  6439 00000923 8CC0                    	mov	ax,es			; ax = device header segment
  6440                                  
  6441                                  	; We check to see if we have a memory arena for this device driver. 
  6442                                  	; The way to do this would be to look at the previous para to see if
  6443                                  	; it has a 'D' marking it as an arena and also see if the owner-field 
  6444                                  	; in the arena is the same as the device header segment. These two 
  6445                                  	; checks together should take care of all cases
  6446                                  
  6447 00000925 48                      	dec	ax			; get arena header
  6448 00000926 06                      	push	es
  6449 00000927 8EC0                    	mov	es,ax			; arena header for device driver
  6450                                  
  6451 00000929 26803D44                	cmp	byte [es:di],'D'	; is it a device arena?
  6452 0000092D 7517                    	jnz	short cantsize		; no, cant size this driver
  6453 0000092F 40                      	inc	ax			; get back device header segment
  6454 00000930 26394501                	cmp	[es:di+1],ax		; owner field pointing at driver?
  6455 00000934 7510                    	jnz	short cantsize		; no, not a proper arena
  6456                                  
  6457 00000936 268B4503                	mov	ax,[es:di+3]		; get arena size in paras
  6458 0000093A 07                      	pop	es
  6459                                  
  6460                                  	; We have to multiply by 16 to get the number of bytes in (bx:cx)
  6461                                  	; Speed is not critical and so we choose the shortest method 
  6462                                  	; -- use "mul"
  6463                                  
  6464 0000093B BB1000                  	mov	bx,16
  6465 0000093E F7E3                    	mul	bx
  6466 00000940 89C1                    	mov	cx,ax
  6467 00000942 89D3                    	mov	bx,dx
  6468 00000944 EB09                    	jmp	short win386_done	; return with device driver size
  6469                                  cantsize:
  6470 00000946 07                      	pop	es
  6471 00000947 31C0                    	xor	ax,ax
  6472                                  win386_inst:	; 05/01/2024
  6473 00000949 31D2                    	xor	dx,dx			; ask DOSMGR to use its methods
  6474 0000094B EB08                    	jmp	short PopIret		; return
  6475                                  
  6476                                  win386_patch:
  6477                                  	; dx contains bits marking the patches to be applied. We return 
  6478                                  	; the field with all bits set to indicate that all patches have been
  6479                                  	; done
  6480                                  
  6481 0000094D 89D3                    	mov	bx,dx			; move patch bitfield to bx
  6482                                   	;jmp	short win386_done	; done, return
  6483                                  	; 15/12/2022
  6484                                  	; 15/12/2022
  6485                                  win386_done:
  6486 0000094F B87CB9                  	mov	ax,WIN_OP_DONE		; 0B97Ch
  6487 00000952 BAABA2                  	mov	dx,DOSMGR_OP_DONE	; 0A2ABh
  6488                                  PopIret:
  6489 00000955 1F                      	pop	ds
  6490 00000956 CF                      	iret	
  6491                                  
  6492                                  win386_size:
  6493                                  	; Return the size of DOS data structures -- currently only CDS size
  6494                                  
  6495                                  	; 17/12/2022
  6496 00000957 F6C201                  	test	dl,1
  6497                                  	;test	dx,1			; check for CDS size bit
  6498 0000095A 74F9                    	jz	short PopIret		; no, unknown structure -- return
  6499                                  
  6500 0000095C B95800                  	mov	cx,curdirLen	; 88 	; cx = CDS size
  6501 0000095F EBEE                    	jmp	short win386_done	; return with the size
  6502                                  
  6503                                  ; 05/01/2024
  6504                                  %if 0
  6505                                  win386_inst:
  6506                                  	; WIN386 check to see if DOS has identified the CDS,SFT and device
  6507                                  	; chain as instance data. Currently, we let the WIN386 DOSMGR handle
  6508                                  	; this by returning a status of not previously instanced. The basic
  6509                                  	; structure of these things have not changed and so the current 
  6510                                  	; DOSMGR code should be able to work it out
  6511                                  
  6512                                  	xor	dx,dx			; make sure dx has a not done value
  6513                                  	jmp	short PopIret		; skip done indication
  6514                                  %endif
  6515                                  
  6516                                  	; 15/12/2022
  6517                                  ;win386_done:
  6518                                  ;	mov	ax,WIN_OP_DONE		; 0B97Ch
  6519                                  ;	mov	dx,DOSMGR_OP_DONE	; 0A2ABh
  6520                                  ;PopIret:
  6521                                  ;	pop	ds
  6522                                  ;	iret				; return back up the chain
  6523                                  
  6524                                  	; 15/12/2022
  6525                                  ;win_nexti2f:
  6526                                  	;pop	ds
  6527                                  	;jmp	next_i2f		; go to BIOS i2f handler
  6528                                  
  6529                                  ;End WIN386 support
  6530                                  
  6531                                  ; 15/05/2019
  6532                                  
  6533                                  ;M044; Start of changes
  6534                                  ; Winoldap has a bug in that its calculations for the Windows memory image
  6535                                  ; to save is off by 1 para. This para can happen to be a Windows arena if the
  6536                                  ; DOS top of memory happens to be at an odd boundary (as is the case when
  6537                                  ; UMBs are present). This is because Windows builds its arenas only at even
  6538                                  ; para boundaries. This arena now gets trashed when Windows is swapped back
  6539                                  ; in leading to a crash. Winoldap issues callouts when it swaps Windows out
  6540                                  ; and back in. We sit on these callouts. On the Windows swapout, we save the
  6541                                  ; last para of the Windows memory block and then restore this para on the
  6542                                  ; Windows swapin callout. 
  6543                                  
  6544                                  getwinlast:
  6545                                  	; 07/12/2022
  6546 00000961 8B36[3003]              	mov	si,[CurrentPDB]
  6547 00000965 4E                      	dec	si
  6548 00000966 8EC6                    	mov	es,si
  6549 00000968 2603360300              	add	si,[es:3]
  6550 0000096D C3                      	retn
  6551                                  
  6552                                  ; 15/12/2022
  6553                                  %if 0
  6554                                  winold_swap:
  6555                                  	push	ds
  6556                                  	push	es
  6557                                  	push	si
  6558                                  	push	di
  6559                                  	push	cx
  6560                                  
  6561                                  	;getdseg <ds>			;ds = DOSDATA
  6562                                  	mov	ds,[cs:DosDSeg]
  6563                                  
  6564                                  	cmp	al,1			;swap Windows out call
  6565                                  	jne	short swapin		;no, check if Swap in call
  6566                                  	call	getwinlast
  6567                                  	push	ds
  6568                                  	pop	es
  6569                                  	mov	ds,si			;ds = memory arena of Windows
  6570                                  	xor	si,si
  6571                                  	mov	di,WinoldPatch1
  6572                                  	mov	cx,8
  6573                                  	cld
  6574                                  	push	cx
  6575                                  	rep	movsb			;save first 8 bytes
  6576                                  	pop	cx
  6577                                  	mov	di,WinoldPatch2
  6578                                  	rep	movsb			;save next 8 bytes
  6579                                  	jmp	short winold_done
  6580                                  swapin:
  6581                                  	cmp	al,2			;swap Windows in call?
  6582                                  	jne	short winold_done	;no, something else, pass it on
  6583                                  	call	getwinlast
  6584                                  	mov	es,si
  6585                                  	xor	di,di
  6586                                  	mov	si,WinoldPatch1
  6587                                  	mov	cx,8
  6588                                  	cld
  6589                                  	push	cx
  6590                                  	rep	movsb			;restore first 8 bytes
  6591                                  	pop	cx
  6592                                  	mov	si,WinoldPatch2
  6593                                  	rep	movsb			;restore next 8 bytes
  6594                                  winold_done:
  6595                                  	pop	cx
  6596                                  	pop	di
  6597                                  	pop	si
  6598                                  	pop	es
  6599                                  	pop	ds
  6600                                  	jmp	next_i2f		;chain on
  6601                                  
  6602                                  %endif
  6603                                  
  6604                                  ;M044; End of changes
  6605                                  
  6606                                  ; ---------------------------------------------------------------------
  6607                                  ; 06/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM/MSDOS.SYS)
  6608                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:4811h
  6609                                  
  6610                                  	; INT 2Fh AX=1231h
  6611                                  	; Windows95 - SET/CLEAR "REPORT WINDOWS TO DOS PROGRAMS" FLAG
  6612                                  	; 			(Ref: Ralf Brown's Interrupt List)
  6613                                  int_2Fh_1231h:
  6614 0000096E 1E                      	push	ds
  6615 0000096F 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6616 00000974 31C0                    	xor	ax,ax ; 0
  6617 00000976 08D2                    	or	dl,dl
  6618 00000978 7507                    	jnz	short not_1231_dl_0
  6619 0000097A C606[A210]01            	mov	byte [IsWin386+1],1	; set byte after "IsWIN386" to 01h
  6620 0000097F EB1A                    	jmp	short int_2f_1231h_retn
  6621                                  
  6622                                  	;nop
  6623                                  
  6624                                  not_1231_dl_0:
  6625 00000981 80FA01                  	cmp	dl,1
  6626 00000984 7507                    	jne	short not_1231_dl_1	; clear "IsWIN386" bit 1
  6627 00000986 800E[A110]02            	or	byte [IsWin386],2	; set "IsWIN386" bit 1
  6628 0000098B EB0E                    	jmp	short int_2f_1231h_retn
  6629                                  
  6630                                  	;nop
  6631                                  
  6632                                  not_1231_dl_1:
  6633 0000098D 80FA02                  	cmp	dl,2
  6634 00000990 7507                    	jne	short not_1231_dl_2
  6635 00000992 8026[A110]FD            	and	byte [IsWin386],0FDh	; clear bit 1
  6636 00000997 EB02                    	jmp	short int_2f_1231h_retn
  6637                                  not_1231_dl_2:
  6638 00000999 40                      	inc	ax              	; return error, ax = 1
  6639 0000099A F9                      	stc
  6640                                  int_2f_1231h_retn:
  6641 0000099B 1F                      	pop	ds
  6642 0000099C C3                      	retn
  6643                                  
  6644                                  ; ---------------------------------------------------------------------
  6645                                  
  6646                                  ; 15/05/2019
  6647                                  
  6648                                  ; 06/01/2024 - Retro DOS v5.0
  6649                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:4842h
  6650                                  
  6651                                  DispatchDOS:
  6652 0000099D 2EFF36[D401]            	PUSH	word [CS:FOO]		; push return address
  6653 000009A2 2EFF36[D601]            	PUSH	word [CS:DTab]		; push table address
  6654 000009A7 50                      	PUSH	AX			; push index
  6655 000009A8 55                      	PUSH	BP
  6656 000009A9 89E5                    	MOV	BP,SP
  6657                                  		; stack looks like:
  6658                                  		;   0	BP
  6659                                  		;   2	DISPATCH
  6660                                  		;   4	TABLE
  6661                                  		;   6	RETURN
  6662                                  		;   8	LONG-RETURN
  6663                                  		;   C	FLAGS
  6664                                  		;   E	AX
  6665                                  	
  6666 000009AB 8B460E                  	MOV	AX,[BP+0Eh]		; get AX value
  6667 000009AE 5D                      	POP	BP
  6668 000009AF E8640E                  	call	TableDispatch
  6669 000009B2 E991FD                  	JMP	BadFunc 		; return indicates invalid function
  6670                                  
  6671                                  INT2F_etcetera:
  6672                                  	;entry	DosGetGroup
  6673                                  DosGetGroup:
  6674                                  	; MSDOS 3.3
  6675                                  	;push	cs
  6676                                  	;pop	ds
  6677                                  	;retn
  6678                                  
  6679                                  	; MSDOS 6.0
  6680                                  ;SR; Cannot use CS now
  6681                                  ;
  6682                                  ;	PUSH	CS
  6683                                  ;	POP	DS
  6684                                  
  6685                                  	; 04/11/2022
  6686                                  	; (MSDOS 5.0 MSDOS.SYS - DOSCODE:46FBh)
  6687                                  
  6688                                  	;getdseg <ds>
  6689 000009B5 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6690 000009BA C3                      	retn
  6691                                  
  6692                                  	;entry	DOSInstall
  6693                                  DOSInstall:
  6694 000009BB B0FF                    	MOV	AL,0FFh
  6695 000009BD C3                      	retn
  6696                                  
  6697                                  ;ENDIF ; (*)
  6698                                  
  6699                                  
  6700                                  ; 15/05/2019 - Retro DOS v4.0
  6701                                  ; 06/01/2024 - Retro DOS v5.0
  6702                                  
  6703                                  ;------------------------------------------------------------------------
  6704                                  ;
  6705                                  ; Procedure Name : RW32_CONVERT
  6706                                  ;
  6707                                  ;Input: same as ABSDRD and ABSDWRT
  6708                                  ;	 ES:BP -> DPB
  6709                                  ;Functions: convert 32bit absolute RW input parms to 16bit input parms
  6710                                  ;Output: carry set when CX=-1 and drive is less then 32mb
  6711                                  ;	 carry clear, parms ok
  6712                                  ;
  6713                                  ;------------------------------------------------------------------------
  6714                                  
  6715                                  	; 06/01/2024
  6716                                  RW32_CONVERT:
  6717 000009BE 83F9FF                  	CMP	CX,-1			   ;>32mb  new format ?	;AN000;
  6718                                  	;inc	cx ; *	; 01 -> 0
  6719 000009C1 7423                    	JZ	short new32format	   ;>32mb  yes		;AN000;
  6720                                  	;dec	dx
  6721                                  	
  6722                                  	;cmp	word [es:bp+0Fh],0
  6723 000009C3 26837E0F00              	cmp	word [es:bp+DPB.FAT_SIZE],0 ; PCDOS 7.1
  6724 000009C8 741A                    	jz	short rw32_conv_err ; FAT32 fs
  6725                                  
  6726 000009CA 50                      	PUSH	AX			   ;>32mb  save ax	;AN000;
  6727 000009CB 52                      	PUSH	DX			   ;>32mb  save dx	;AN000;
  6728                                  	;mov	ax,[es:bp+0Dh]
  6729 000009CC 268B460D                	MOV	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  get max cluster # ;AN000;
  6730                                  	;mov	dl,[es:bp+4]
  6731 000009D0 268A5604                	MOV	DL,[ES:BP+DPB.CLUSTER_MASK] ;>32mb		;AN000;
  6732 000009D4 80FAFE                  	CMP	DL,0FEh ; 254		;>32mb  removable ?	;AN000;
  6733 000009D7 7407                    	JZ	short letold		;>32mb  yes		;AN000;
  6734                                  	;INC	DL			;>32mb			;AN000;
  6735                                  	; 17/12/2022
  6736 000009D9 42                      	inc	dx
  6737 000009DA 30F6                    	XOR	DH,DH			;>32mb  dx = sector/cluster ;AN000;
  6738 000009DC F7E2                    	MUL	DX			;>32mb  dx:ax= max sector # ;AN000;
  6739 000009DE 09D2                    	OR	DX,DX	; (clears CF)	;>32mb  > 32mb ?	;AN000;
  6740                                  letold:
  6741 000009E0 5A                      	POP	DX			;>32mb  restore dx	;AN000;
  6742 000009E1 58                      	POP	AX			;>32mb  restore ax 	;AN000;
  6743 000009E2 7418                    	JZ	short old_style	; cf=0	;>32mb  no 		;AN000;
  6744                                  
  6745                                  	; 06/01/2024
  6746                                  	;push	ds
  6747                                  	;;getdseg <ds>
  6748                                  	;mov	ds,[cs:DosDSeg]
  6749                                  	;mov	word [AbsDskErr],207h	;>32mb  bad address mark
  6750                                  	;pop	ds
  6751                                  rw32_conv_err:
  6752 000009E4 F9                      	STC				;>32mb			;AN000;
  6753 000009E5 C3                      	retn				;>32mb			;AN000;
  6754                                  
  6755                                  new32format:
  6756                                  	;mov	dx,[bx+2]
  6757 000009E6 8B5702                  	MOV	DX,[BX+ABS_32RW.SECTOR_RBA+2] ;>32mb		;AN000;
  6758                                  
  6759 000009E9 1E                      	push	ds			; set up ds to DOSDATA
  6760                                  	;getdseg <ds>
  6761 000009EA 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6762 000009EF 8916[0706]              	MOV	[HIGH_SECTOR],DX	;>32mb			;AN000;
  6763 000009F3 1F                      	pop	ds
  6764                                  
  6765 000009F4 8B17                    	mov	dx,[bx]
  6766                                  	;MOV	DX,[BX+ABS_32RW.SECTOR_RBA]  ;>32mb		;AN000;
  6767                                  	;mov	cx,[bx+4]
  6768 000009F6 8B4F04                  	MOV	CX,[BX+ABS_32RW.ABS_RW_COUNT] ;>32mb		;AN000;
  6769                                  	;lds	bx,[bx+6]
  6770 000009F9 C55F06                  	LDS	BX,[BX+ABS_32RW.BUFFER_ADDR] ;>32mb		;AN000;
  6771                                  old_style:				;>32mb			;AN000;
  6772                                  	; 06/01/2024
  6773                                  	; cf=0
  6774                                  	;CLC				;>32mb			;AN000;
  6775 000009FC C3                      	retn				;>32mb			;AN000;
  6776                                  
  6777                                  ;------------------------------------------------------------------------
  6778                                  ;
  6779                                  ; Procedure Name : Fastxxx_Purge
  6780                                  ;
  6781                                  ; Input: None
  6782                                  ; Functions: Purge Fastopen/ Cache Buffers
  6783                                  ; Output: None
  6784                                  ;
  6785                                  ;------------------------------------------------------------------------
  6786                                  
  6787                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6788                                  
  6789                                  Fastxxx_Purge:
  6790 000009FD 50                      	PUSH	AX			; save regs.	;AN000;
  6791 000009FE 56                      	PUSH	SI						;AN000;
  6792 000009FF 52                      	PUSH	DX						;AN000;
  6793                                  topen:
  6794 00000A00 1E                      	push	ds			; set up ds to DOSDATA
  6795                                  	;getdseg <ds>
  6796 00000A01 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6797                                  
  6798 00000A06 F606[6D12]80            	TEST	byte [FastOpenFlg],Fast_yes ; 80h 
  6799                                  					; fastopen installed ?	;AN000;
  6800 00000A0B 1F                      	pop	ds
  6801 00000A0C 740B                    	JZ	short nofast		; no			;AN000;
  6802 00000A0E B401                    	MOV	AH,FastOpen_ID	; 1				;AN000;
  6803                                  dofast:
  6804 00000A10 B005                    	MOV	AL,FONC_purge  ;5	; purge			;AN000;
  6805                                  	;;mov	dl,[es:bp+0]
  6806                                  	; 05/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  6807                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; set up drive number	;AN000;
  6808                                  	; 15/12/2022
  6809 00000A12 268A5600                	mov	dl,[es:bp]
  6810                                  	;invoke	Fast_Dispatch		; call fastopen/seek	;AN000;
  6811 00000A16 E87C23                  	call	Fast_Dispatch
  6812                                  nofast:
  6813 00000A19 5A                      	POP	DX						;AN000;
  6814 00000A1A 5E                      	POP	SI			; restore regs		;AN000;
  6815 00000A1B 58                      	POP	AX			 			;AN000;
  6816 00000A1C C3                      	retn				; exit
  6817                                  
  6818                                  ;============================================================================
  6819                                  ; DOSMES.INC (MSDOS 6.0, 1991)
  6820                                  ;============================================================================
  6821                                  ; 29/04/2019 - Retro DOS v4.0
  6822                                  
  6823                                  ;include dossym.inc
  6824                                  ;include dosmac.inc
  6825                                  ;include doscntry.inc
  6826                                  
  6827                                  ; DOSCODE Segment
  6828                                  
  6829                                  ; 17/07/2018 - Retro DOS v3.0  [ DOSMES.INC (MSDOS 3.3, 1987) ]
  6830                                  ; ---------------------------------------------------------------------------
  6831                                  ;include divmes.inc
  6832                                  
  6833                                  ; DOSCODE:48C3h (PCDOS 7.1, IBMDOS.COM) - 06/04/2024 -
  6834                                  ; -------------------------------------
  6835                                  ; DOSCODE:4778h (MSDOS 6.21, MSDOS.SYS)
  6836                                  ; -------------------------------------
  6837                                  ; DOSCODE:476Bh (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6838                                  
  6839                                  ; THIS IS THE ONLY DOS "MESSAGE". IT DOES NOT NEED A TERMINATOR.
  6840                                  	;PUBLIC	DIVMES
  6841                                  
  6842 00000A1D 0D0A44697669646520-     DIVMES:	DB	13,10,"Divide overflow",13,10
  6842 00000A26 6F766572666C6F770D-
  6842 00000A2F 0A                 
  6843                                  
  6844                                  	;PUBLIC	DivMesLen
  6845                                  DivMesLen:
  6846 00000A30 1300                    	DW	$-DIVMES  ; 19	; Length of the above message in bytes
  6847                                  
  6848                                  ; DOSCODE:478Dh (MSDOS 6.21, MSDOS.SYS)
  6849                                  ; -------------------------------------
  6850                                  ; DOSCODE:4780h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6851                                  
  6852                                  ; (MSDOS 6.0)
  6853                                  ; VxD not found error message
  6854                                  
  6855                                  NoVxDErrMsg:
  6856 00000A32 596F75206D75737420-     	db  'You must have the file WINA20.386 in the root of your boot drive'
  6856 00000A3B 686176652074686520-
  6856 00000A44 66696C652057494E41-
  6856 00000A4D 32302E33383620696E-
  6856 00000A56 2074686520726F6F74-
  6856 00000A5F 206F6620796F757220-
  6856 00000A68 626F6F742064726976-
  6856 00000A71 65                 
  6857 00000A72 0D0A746F2072756E20-     	db  0Dh,0Ah,'to run Windows in Enhanced Mode',0Dh,0Ah
  6857 00000A7B 57696E646F77732069-
  6857 00000A84 6E20456E68616E6365-
  6857 00000A8D 64204D6F64650D0A   
  6858                                  
  6859                                  VxDMesLen equ $ - NoVxDErrMsg  ; 99
  6860                                  
  6861                                  ; 13/05/2019 - Retro DOS v4.0
  6862                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6863                                  
  6864                                  ;include yesno.asm  (MNSDOS 6.0)
  6865                                  ; -------------------------------------
  6866                                  ; DOSCODE:47F0h (MSDOS 6.21, MSDOS.SYS)
  6867                                  ; DOSCODE:47E3h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6868                                  
  6869                                  ; This is for country Yes and No
  6870                                  
  6871                                  ; 06/01/2024 (Retro DOS 5.0 - PCDOS 7.1 IBMDOS.COM)
  6872                                  ;NLS_YES:	db 'Y'
  6873                                  ;NLS_NO:	db 'N'
  6874                                  ;NLS_yes2:	db 'y'
  6875                                  ;NLS_no2:	db 'n'
  6876                                  
  6877                                  ; ---------------------------------------------------------------------------
  6878                                  
  6879                                  ; DOSCODE:493Bh (PCDOS 7.1, IBMDOS.COM) - 06/04/2024 -
  6880                                  ; -------------------------------------
  6881                                  ; DOSCODE:47F4h (MSDOS 6.21, MSDOS.SYS)
  6882                                  ; DOSCODE:47E7h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6883                                  
  6884                                  ;SUBTTL EDIT FUNCTION ASSIGNMENTS AND HEADERS
  6885                                  
  6886                                  ; The following two tables implement the current buffered input editing
  6887                                  ; routines. The tables are pairwise associated in reverse order for ease
  6888                                  ; in indexing. That is; The first entry in ESCTAB corresponds to the last
  6889                                  ; entry in ESCFUNC, and the last entry in ESCTAB to the first entry in ESCFUNC.
  6890                                  
  6891                                  	;PUBLIC	CANCHAR
  6892                                  CANCHAR:
  6893 00000A95 1B                      	DB	CANCEL	; 1Bh	;Cancel line character
  6894                                  	
  6895                                  	;PUBLIC	ESCCHAR
  6896                                  ESCCHAR:
  6897 00000A96 00                      	DB	ESCCH	; 0	;Lead-in character for escape sequences
  6898                                  	
  6899                                  	;IF	NOT Rainbow
  6900                                  
  6901                                  ESCTAB:	; LABEL BYTE
  6902                                  
  6903                                  	;IF	IBM
  6904 00000A97 40                      	DB	64		; Ctrl-Z - F6
  6905 00000A98 4D                      	DB	77		; Copy one char - -->
  6906 00000A99 3B                      	DB	59		; Copy one char - F1
  6907 00000A9A 53                      	DB	83		; Skip one char - DEL
  6908 00000A9B 3C                      	DB	60		; Copy to char - F2
  6909 00000A9C 3E                      	DB	62		; Skip to char - F4
  6910 00000A9D 3D                      	DB	61		; Copy line - F3
  6911 00000A9E 3D                      	DB	61		; Kill line (no change to template ) - Not used
  6912 00000A9F 3F                      	DB	63		; Reedit line (new template) - F5
  6913 00000AA0 4B                      	DB	75		; Backspace - <--
  6914 00000AA1 52                      	DB	82		; Enter insert mode - INS (toggle)
  6915 00000AA2 52                      	DB	82		; Exit insert mode - INS (toggle)
  6916 00000AA3 41                      	DB	65		; Escape character - F7
  6917 00000AA4 41                      	DB	65		; End of table
  6918                                  	;ENDIF
  6919                                  
  6920                                  ESCEND: ; LABEL BYTE
  6921                                  
  6922                                  ESCTABLEN EQU ESCEND-ESCTAB
  6923                                  
  6924                                  ESCFUNC: ; LABEL WORD
  6925                                  	
  6926 00000AA5 [011A]                  	short_addr  GETCH	; Ignore the escape sequence
  6927 00000AA7 [7E1A]                  	short_addr  TWOESC
  6928 00000AA9 [731B]                  	short_addr  EXITINS
  6929 00000AAB [731B]                  	short_addr  ENTERINS
  6930 00000AAD [791A]                  	short_addr  BACKSP
  6931 00000AAF [5F1B]                  	short_addr  REEDIT
  6932 00000AB1 [661A]                  	short_addr  KILNEW
  6933 00000AB3 [F51A]                  	short_addr  COPYLIN
  6934 00000AB5 [271B]                  	short_addr  SKIPSTR
  6935 00000AB7 [FB1A]                  	short_addr  COPYSTR
  6936 00000AB9 [1E1B]                  	short_addr  SKIPONE
  6937 00000ABB [001B]                  	short_addr  COPYONE
  6938 00000ABD [001B]                  	short_addr  COPYONE
  6939 00000ABF [7A1B]                  	short_addr  CTRLZ
  6940                                  
  6941                                  	;ENDIF
  6942                                  
  6943                                  ; DOSMES.INC (MSDOS 6.0, 1991)
  6944                                  ; ---------------------------------------------------------------------------
  6945                                  ; DOSMES.ASM (MSDOS 2.11, 1983)
  6946                                  
  6947                                  ; OEMFunction key is expected to process a single function
  6948                                  ;   key input from a device and dispatch to the proper
  6949                                  ;   routines leaving all registers UNTOUCHED.
  6950                                  ;
  6951                                  ; Inputs:   CS, SS are DOSGROUP
  6952                                  ; Outputs:  None. This function is expected to JMP to onw of
  6953                                  ;           the following labels:
  6954                                  ;
  6955                                  ;           GetCh       - ignore the sequence
  6956                                  ;           TwoEsc      - insert an ESCChar in the buffer
  6957                                  ;           ExitIns     - toggle insert mode
  6958                                  ;           EnterIns    - toggle insert mode
  6959                                  ;           BackSp      - move backwards one space
  6960                                  ;           ReEdit      - reedit the line with a new template
  6961                                  ;           KilNew      - discard the current line and start from scratch
  6962                                  ;           CopyLin     - copy the rest of the template into the line
  6963                                  ;           SkipStr     - read the next character and skip to it in the template
  6964                                  ;           CopyStr     - read next char and copy from template to line until char
  6965                                  ;           SkipOne     - advance position in template one character
  6966                                  ;           CopyOne     - copy next character in template into line
  6967                                  ;           CtrlZ       - place a ^Z into the template
  6968                                  ; Registers that are allowed to be modified by this function are:
  6969                                  ;           AX, CX, BP
  6970                                  
  6971                                  ; 13/05/2019 - Retro DOS v4.0
  6972                                  ; -------------------------------------
  6973                                  ; DOSCODE:4820h (MSDOS 6.21, MSDOS.SYS)
  6974                                  
  6975                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6976                                  ; -------------------------------------
  6977                                  ; DOSCODE:4813h (MSDOS 5.0, MSDOS.SYS)
  6978                                  
  6979                                  ; 06/01/2024 - Retro DOS v5.0
  6980                                  ; -------------------------------------
  6981                                  ; DOSCODE:4967h (PCDOS 7.1, IBMDOS.COM)
  6982                                  
  6983                                  OEMFunctionKey:
  6984 00000AC1 E89F0E                  	CALL	_$STD_CON_INPUT_NO_ECHO	; Get the second byte of the sequence
  6985 00000AC4 B10E                    	MOV     CL,ESCTABLEN ; 14	; length of table for scan
  6986 00000AC6 57                      	PUSH    DI                      ; save DI (cannot change it!)
  6987 00000AC7 BF[970A]                	MOV     DI,ESCTAB		; offset of second byte table
  6988 00000ACA 06                      	push	es
  6989 00000ACB 0E                      	push	cs
  6990 00000ACC 07                      	pop	es
  6991 00000ACD F2AE                    	REPNE   SCASB                   ; Look it up in the table
  6992 00000ACF 07                      	pop	es
  6993 00000AD0 5F                      	POP     DI                      ; restore DI
  6994 00000AD1 D1E1                    	SHL     CX,1                    ; convert byte offset to word
  6995 00000AD3 89CD                    	MOV     BP,CX                   ; move to indexable register
  6996                                  	;JMP	word [BP+ESCFUNC]	; Go to the right routine
  6997 00000AD5 2EFFA6[A50A]            	JMP	word [CS:BP+ESCFUNC]
  6998                                  
  6999                                  ;DOSCODE ENDS
  7000                                  	
  7001                                  ;============================================================================
  7002                                  ; TIME.ASM (MSDOS 6.0, 1991)
  7003                                  ;============================================================================
  7004                                  ; Retro DOS v3.0 - 18/07/2018
  7005                                  
  7006                                  ; SYSCALL.ASM (MSDOS 2.11, 1983)
  7007                                  ;----------------------------------------------------------------------------
  7008                                  ; Retro DOS v2.0 - 13/03/2018
  7009                                  
  7010                                  ;**	TIME.ASM - System Calls and low level routines for DATE and TIME
  7011                                  
  7012                                  	;BREAK <DATE AND TIME - SYSTEM CALLS 42,43,44,45>
  7013                                  
  7014                                  ;**	$GET_DATE - Get Current Date
  7015                                  ;----------------------------------------
  7016                                  ;	ENTRY	none
  7017                                  ;	EXIT	(cx:dx) = current date
  7018                                  ;	USES	all
  7019                                  
  7020                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7021                                  ; 06/01/2024 - Retro DOS v5.0 (Modified MSDOS 7.1 IBMDOS.COM)	
  7022                                  
  7023                                  _$GET_DATE:	;System call 42
  7024                                  
  7025 00000ADA 16                      	PUSH	SS
  7026 00000ADB 1F                      	POP	DS
  7027 00000ADC E8B700                  	CALL	READTIME	;Check for rollover to next day
  7028 00000ADF A1[5203]                	MOV	AX,[YEAR]
  7029                                  
  7030                                  ;	WARNING!!!! DAY and MONTH must be adjacently allocated!
  7031                                  
  7032 00000AE2 8B1E[5003]              	MOV	BX,[DAY]	; fetch both day and month
  7033 00000AE6 E88EF9                  	CALL	Get_User_Stack	;Get pointer to user registers
  7034                                  	;MOV	[SI+6],BX	;DH=month, DL=day
  7035 00000AE9 895C06                  	MOV	[SI+user_env.user_DX],BX
  7036 00000AEC 05BC07                  	ADD	AX,1980		;Put bias back
  7037                                  	;MOV	[SI+4],AX	;CX=year
  7038 00000AEF 894404                  	MOV	[SI+user_env.user_CX],AX
  7039 00000AF2 36A0[5603]              	MOV	AL,[SS:WEEKDAY]	;hkn; SS override
  7040                                  RET20:	; 05/11/2022
  7041                                  RET24:	; 18/12/2022
  7042 00000AF6 C3                      	RETN
  7043                                  
  7044                                  ;**	$SET_DATE - Set Current Date
  7045                                  ;----------------------------------------
  7046                                  ;	ENTRY	(cx:dx) = current date
  7047                                  ;	EXIT	(al) = -1 iff bad date
  7048                                  ;		(al) = 0 if ok
  7049                                  ;	USES	all
  7050                                  
  7051                                  _$SET_DATE:	;System call 43
  7052                                  
  7053 00000AF7 B0FF                    	MOV	AL,-1		;Be ready to flag error
  7054 00000AF9 81E9BC07                	SUB	CX,1980		;Fix bias in year
  7055                                  	;JC	SHORT RET24	;Error if not big enough
  7056                                  	; 05/11/2022
  7057 00000AFD 72F7                    	jc	short RET20
  7058 00000AFF 83F977                  	CMP	CX,119		;Year must be less than 2100
  7059 00000B02 77F2                    	JA	SHORT RET24
  7060 00000B04 08F6                    	OR	DH,DH
  7061                                  	;JZ	SHORT RET24
  7062                                   	; 05/11/2022
  7063 00000B06 74EE                    	jz	short RET20
  7064 00000B08 08D2                    	OR	DL,DL
  7065                                  	;JZ	SHORT RET24	;Error if either month or day is 0
  7066                                  	; 05/11/2022
  7067 00000B0A 74EA                    	jz	short RET20
  7068 00000B0C 80FE0C                  	CMP	DH,12		;Check against max. month
  7069 00000B0F 77E5                    	JA	SHORT RET24
  7070 00000B11 16                      	PUSH	SS
  7071 00000B12 1F                      	POP	DS
  7072                                  	;CALL	DODATE
  7073                                  	; 18/12/2022
  7074 00000B13 E91301                  	jmp	DODATE
  7075                                  ;RET24:  
  7076                                  	;RETN
  7077                                  
  7078                                  ;**	$GET_TIME - Get Current Time
  7079                                  ;----------------------------------------
  7080                                  ;	ENTRY	none
  7081                                  ;	EXIT	(cx:dx) = current time
  7082                                  ;	USES	all
  7083                                  
  7084                                  _$GET_TIME:			;System call 44
  7085                                  
  7086 00000B16 16                      	PUSH	SS
  7087 00000B17 1F                      	POP	DS
  7088 00000B18 E87B00                  	CALL	READTIME
  7089 00000B1B E859F9                  	CALL	Get_User_Stack	;Get pointer to user registers
  7090                                  	;MOV	[SI+6],DX
  7091 00000B1E 895406                  	MOV	[SI+user_env.user_DX],DX
  7092                                  	;MOV	[SI+4],CX
  7093 00000B21 894C04                  	MOV	[SI+user_env.user_CX],CX
  7094                                  set_time_ok:	; 06/01/2024
  7095 00000B24 30C0                    	XOR	AL,AL
  7096                                  RET26:  
  7097 00000B26 C3                      	RETN
  7098                                  
  7099                                  ;**	$SET_TIME - Set Current Time
  7100                                  ;----------------------------------------
  7101                                  ;	ENTRY	(cx:dx) = time
  7102                                  ;	EXIT	(al) = 0 if 0k
  7103                                  ;		(al) = -1 if invalid
  7104                                  ;	USES	ALL
  7105                                  
  7106                                  _$SET_TIME:			;System call 45
  7107                                  
  7108 00000B27 B0FF                    	MOV	AL,-1		;Flag in case of error
  7109 00000B29 80FD18                  	CMP	CH,24		;Check hours
  7110 00000B2C 73F8                    	JAE	SHORT RET26
  7111 00000B2E 80F93C                  	CMP	CL,60		;Check minutes
  7112 00000B31 73F3                    	JAE	SHORT RET26
  7113 00000B33 80FE3C                  	CMP	DH,60		;Check seconds
  7114 00000B36 73EE                    	JAE	SHORT RET26
  7115 00000B38 80FA64                  	CMP	DL,100		;Check 1/100's
  7116 00000B3B 73E9                    	JAE	SHORT RET26
  7117 00000B3D 51                      	PUSH	CX
  7118 00000B3E 52                      	PUSH	DX
  7119 00000B3F 16                      	PUSH	SS
  7120 00000B40 1F                      	POP	DS
  7121 00000B41 BB[B603]                	MOV	BX,TIMEBUF
  7122 00000B44 B90600                  	MOV	CX,6
  7123                                  	;XOR	DX,DX
  7124                                  	;MOV	AX,DX
  7125 00000B47 31C0                    	xor	ax,ax
  7126 00000B49 99                      	cwd	; 06/01/2024
  7127 00000B4A 53                      	PUSH	BX
  7128 00000B4B E84D45                  	CALL	SETREAD
  7129 00000B4E 1E                      	PUSH	DS
  7130 00000B4F C536[2E00]              	LDS	SI,[BCLOCK]
  7131 00000B53 E8CF44                  	CALL	DEVIOCALL2	;Get correct day count
  7132 00000B56 1F                      	POP	DS
  7133 00000B57 5B                      	POP	BX
  7134 00000B58 E87345                  	CALL	SETWRITE
  7135 00000B5B 8F06[BA03]              	POP	WORD [TIMEBUF+4]
  7136 00000B5F 8F06[B803]              	POP	WORD [TIMEBUF+2]
  7137 00000B63 C536[2E00]              	LDS	SI,[BCLOCK]
  7138 00000B67 E8BB44                  	CALL	DEVIOCALL2	;Set the time
  7139                                  	; 06/01/2024
  7140                                  	;XOR	AL,AL
  7141                                  	;RETN
  7142 00000B6A EBB8                    	jmp	short set_time_ok
  7143                                  
  7144                                  ; 11/07/2018 - Retro DOS v3.0
  7145                                  ; Retro DOS v2.0 - 14/03/2018
  7146                                  
  7147                                  FOURYEARS EQU 3*365 + 366  ; = 1461 
  7148                                  
  7149                                  ;SUBTTL DATE16, READTIME, DODATE -- GUTS OF TIME AND DATE
  7150                                  ;----------------------------------------------------------
  7151                                  ; Date16 returns the current date in AX, current time in DX
  7152                                  ;   AX - YYYYYYYMMMMDDDDD  years months days
  7153                                  ;   DX - HHHHHMMMMMMSSSSS  hours minutes seconds/2
  7154                                  
  7155                                  DATE16:
  7156                                  	
  7157                                  ;M048	Context DS
  7158                                  ;
  7159                                  ; Since this function can be called thru int 2f we shall not assume that SS
  7160                                  ; is DOSDATA
  7161                                  
  7162                                  	;push	ss
  7163                                  	;pop	ds
  7164                                  
  7165                                  	;getdseg <ds>		; M048
  7166                                  
  7167                                  	; 13/05/2019 - Retro DOS v4.0
  7168 00000B6C 2E8E1E[0700]            	mov	ds, [cs:DosDSeg]	
  7169                                  
  7170 00000B71 51                      	PUSH	CX
  7171 00000B72 06                      	PUSH	ES
  7172 00000B73 E82000                  	CALL	READTIME
  7173 00000B76 07                      	POP	ES
  7174 00000B77 D0E1                    	SHL	CL,1		;Minutes to left part of byte
  7175 00000B79 D0E1                    	SHL	CL,1
  7176 00000B7B D1E1                    	SHL	CX,1		;Push hours and minutes to left end
  7177 00000B7D D1E1                    	SHL	CX,1
  7178 00000B7F D1E1                    	SHL	CX,1
  7179 00000B81 D0EE                    	SHR	DH,1		;Count every two seconds
  7180 00000B83 08F1                    	OR	CL,DH		;Combine seconds with hours and minutes
  7181 00000B85 89CA                    	MOV	DX,CX
  7182                                  
  7183                                  ;	WARNING! MONTH and YEAR must be adjacently allocated
  7184                                  
  7185 00000B87 A1[5103]                	MOV	AX,[MONTH]	;Fetch month and year
  7186 00000B8A B104                    	MOV	CL,4
  7187 00000B8C D2E0                    	SHL	AL,CL		;Push month to left to make room for day
  7188 00000B8E D1E0                    	SHL	AX,1
  7189 00000B90 59                      	POP	CX
  7190 00000B91 0A06[5003]              	OR	AL,[DAY]
  7191                                  RET21:
  7192 00000B95 C3                      	RETN
  7193                                  
  7194                                  ;----------------------------------------------------------
  7195                                  
  7196                                  READTIME:
  7197                                  
  7198                                  ;Gets time in CX:DX. Figures new date if it has changed.
  7199                                  ;Uses AX, CX, DX.
  7200                                  
  7201 00000B96 C706[E20D]0000          	MOV	word [DATE_FLAG],0 ; reset date flag for CPMIO
  7202 00000B9C 56                      	PUSH	SI
  7203 00000B9D 53                      	PUSH	BX
  7204                                  
  7205 00000B9E BB[B603]                	MOV	BX,TIMEBUF
  7206                                  
  7207 00000BA1 B90600                  	MOV	CX,6
  7208                                  	;XOR	DX,DX
  7209                                  	;MOV	AX,DX
  7210                                  	; 06/01/2024
  7211 00000BA4 31C0                    	xor	ax,ax
  7212 00000BA6 99                      	cwd
  7213 00000BA7 E8F144                  	CALL	SETREAD
  7214 00000BAA 1E                      	PUSH	DS
  7215 00000BAB C536[2E00]              	LDS	SI,[BCLOCK]
  7216 00000BAF E87344                  	CALL	DEVIOCALL2	;Get correct date and time
  7217 00000BB2 1F                      	POP	DS
  7218 00000BB3 5B                      	POP	BX
  7219 00000BB4 5E                      	POP	SI
  7220 00000BB5 A1[B603]                	MOV	AX,[TIMEBUF]
  7221 00000BB8 8B0E[B803]              	MOV	CX,[TIMEBUF+2]
  7222 00000BBC 8B16[BA03]              	MOV	DX,[TIMEBUF+4]
  7223 00000BC0 3B06[5403]              	CMP	AX,[DAYCNT]	;See if day count is the same
  7224                                  	;JZ	SHORT RET22
  7225 00000BC4 74CF                    	JZ	SHORT RET21 ; 18/07/2018
  7226                                  	;cmp	ax,43830
  7227 00000BC6 3D36AB                  	CMP	AX,FOURYEARS*30 ;Number of days in 120 years
  7228 00000BC9 733D                    	JAE	SHORT RET22	;Ignore if too large
  7229 00000BCB A3[5403]                	MOV	[DAYCNT],AX
  7230 00000BCE 56                      	PUSH	SI
  7231 00000BCF 51                      	PUSH	CX
  7232 00000BD0 52                      	PUSH	DX		;Save time
  7233 00000BD1 31D2                    	XOR	DX,DX
  7234                                  	;mov	cx,1461
  7235 00000BD3 B9B505                  	MOV	CX,FOURYEARS	;Number of days in 4 years
  7236 00000BD6 F7F1                    	DIV	CX		;Compute number of 4-year units
  7237 00000BD8 D1E0                    	SHL	AX,1
  7238 00000BDA D1E0                    	SHL	AX,1
  7239 00000BDC D1E0                    	SHL	AX,1		;Multiply by 8 (no. of half-years)
  7240 00000BDE 89C1                    	MOV	CX,AX		;<240 implies AH=0
  7241                                  
  7242 00000BE0 BE[650D]                	MOV	SI,YRTAB	;Table of days in each year
  7243                                  
  7244 00000BE3 E82300                  	CALL	DSLIDE		;Find out which of four years we're in
  7245 00000BE6 D1E9                    	SHR	CX,1		;Convert half-years to whole years
  7246 00000BE8 7304                    	JNC	SHORT SK	;Extra half-year?
  7247 00000BEA 81C2C800                	ADD	DX,200
  7248                                  SK:
  7249 00000BEE E82200                  	CALL	SETYEAR
  7250 00000BF1 B101                    	MOV	CL,1		;At least at first month in year
  7251                                  
  7252 00000BF3 BE[6D0D]                	MOV	SI,MONTAB	;Table of days in each month
  7253                                  	
  7254 00000BF6 E81000                  	CALL	DSLIDE		;Find out which month we're in
  7255 00000BF9 880E[5103]              	MOV	[MONTH],CL
  7256 00000BFD 42                      	INC	DX		;Remainder is day of month (start with one)
  7257 00000BFE 8816[5003]              	MOV	[DAY],DL
  7258 00000C02 E89400                  	CALL	WKDAY		;Set day of week
  7259 00000C05 5A                      	POP	DX
  7260 00000C06 59                      	POP	CX
  7261 00000C07 5E                      	POP	SI
  7262                                  RET22:  
  7263 00000C08 C3                      	RETN
  7264                                  
  7265                                  ;----------------------------------------------------------
  7266                                  
  7267                                  DSLIDE:
  7268                                  	;MOV	AH,0
  7269                                  	; 06/01/2024
  7270                                  	; (AH=0)
  7271                                  DSLIDE1:
  7272 00000C09 AC                      	LODSB			;Get count of days
  7273 00000C0A 39C2                    	CMP	DX,AX		;See if it will fit
  7274                                  	;JB	SHORT RET23	;If not, done
  7275 00000C0C 72FA                    	jb	short RET22 ; 13/05/2019 - Retro DOS v4.0
  7276 00000C0E 29C2                    	SUB	DX,AX
  7277 00000C10 41                      	INC	CX		;Count one more month/year
  7278 00000C11 EBF6                    	JMP	SHORT DSLIDE1
  7279                                  
  7280                                  ;----------------------------------------------------------
  7281                                  
  7282                                  SETYEAR:
  7283                                  
  7284                                  ;Set year with value in CX. Adjust length of February for this year.
  7285                                  
  7286                                  ; NOTE: This can also be called thru int 2f. If this is called then it will
  7287                                  ;	  set DS to DOSDATA. Since the only guy calling this should be the DOS
  7288                                  ;	redir, DS will be DOSDATA anyway. It is going to be in-efficient to
  7289                                  ;	preserve DS as CHKYR is also called as a routine.
  7290                                  
  7291                                  	; MSDOS 6.0 (18/07/2018) ; *
  7292                                  
  7293                                  	;GETDSEG DS
  7294                                  
  7295                                  	;PUSH	CS  ; *
  7296                                  	;POP	DS  ; *
  7297                                  
  7298                                  	; 13/05/2019 - Retro DOS v4.0
  7299 00000C13 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  7300                                  
  7301                                  	; Offset 18CEh in IBMDOS.COM (MSDOS 3.3), 1987
  7302                                  	; 05/11/2022 
  7303                                  	; DOSCODE:4970h in MSDOS.SYS (MSDOS 5.0), 1991 
  7304                                  
  7305 00000C18 880E[5203]              	MOV	[YEAR],CL
  7306                                  CHKYR:
  7307 00000C1C F6C103                  	TEST	CL,3		;Check for leap year
  7308 00000C1F B01C                    	MOV	AL,28
  7309 00000C21 7502                    	JNZ	SHORT SAVFEB	;28 days if no leap year
  7310 00000C23 FEC0                    	INC	AL		;Add leap day
  7311                                  SAVFEB:
  7312 00000C25 A2[6E0D]                	mov	[february],al
  7313                                  	;MOV	[MONTAB+1],AL	;Store for February
  7314                                  RET23:  
  7315 00000C28 C3                      	RETN
  7316                                  
  7317                                  ;----------------------------------------------------------
  7318                                  
  7319                                  DODATE:
  7320 00000C29 E8F0FF                  	CALL	CHKYR		;Set Feb. up for new year
  7321 00000C2C 88F0                    	MOV	AL,DH
  7322                                  
  7323 00000C2E BB[6C0D]                	MOV	BX,MONTAB-1	;DOSDATA:0D1Bh for MSDOS 6.21
  7324                                  				; 06/01/2024
  7325                                  				;DOSDATA:0D1Bh for PCDOS 7.1 
  7326                                  
  7327 00000C31 D7                      	XLAT			;Look up days in month
  7328 00000C32 38D0                    	CMP	AL,DL
  7329 00000C34 B0FF                    	MOV	AL,-1		;Restore error flag, just in case
  7330                                  	;JB	SHORT RET25	;Error if too many days
  7331 00000C36 72F0                    	jb	short RET23 ; 18/07/2018
  7332 00000C38 E8D8FF                  	CALL	SETYEAR
  7333                                  ;
  7334                                  ; WARNING! DAY and MONTH must be adjacently allocated
  7335                                  ;
  7336 00000C3B 8916[5003]              	MOV	[DAY],DX	;Set both day and month
  7337 00000C3F D1E9                    	SHR	CX,1
  7338 00000C41 D1E9                    	SHR	CX,1
  7339                                  	;mov	ax,1461
  7340 00000C43 B8B505                  	MOV	AX,FOURYEARS
  7341 00000C46 89D3                    	MOV	BX,DX
  7342 00000C48 F7E1                    	MUL	CX
  7343 00000C4A 8A0E[5203]              	MOV	CL,[YEAR]
  7344 00000C4E 80E103                  	AND	CL,3
  7345                                  
  7346 00000C51 BE[650D]                	MOV	SI,YRTAB
  7347                                  
  7348 00000C54 89C2                    	MOV	DX,AX
  7349 00000C56 D1E1                    	SHL	CX,1		;Two entries per year, so double count
  7350 00000C58 E85100                  	CALL	DSUM		;Add up the days in each year
  7351 00000C5B 88F9                    	MOV	CL,BH		;Month of year
  7352                                  
  7353 00000C5D BE[6D0D]                	MOV	SI,MONTAB
  7354                                  
  7355 00000C60 49                      	DEC	CX		;Account for months starting with one
  7356 00000C61 E84800                  	CALL	DSUM		;Add up days in each month
  7357 00000C64 88D9                    	MOV	CL,BL		;Day of month
  7358 00000C66 49                      	DEC	CX		;Account for days starting with one
  7359 00000C67 01CA                    	ADD	DX,CX		;Add in to day total
  7360 00000C69 92                      	XCHG	AX,DX		;Get day count in AX
  7361 00000C6A A3[5403]                	MOV	[DAYCNT],AX
  7362 00000C6D 56                      	PUSH	SI
  7363 00000C6E 53                      	PUSH	BX
  7364 00000C6F 50                      	PUSH	AX
  7365                                  
  7366 00000C70 BB[B603]                	MOV	BX,TIMEBUF
  7367                                  
  7368 00000C73 B90600                  	MOV	CX,6
  7369                                  	;XOR	DX,DX
  7370                                  	;MOV	AX,DX
  7371                                  	; 06/01/2024
  7372 00000C76 31C0                    	xor	ax,ax
  7373 00000C78 99                      	cwd
  7374 00000C79 53                      	PUSH	BX
  7375 00000C7A E81E44                  	CALL	SETREAD
  7376                                  
  7377 00000C7D 1E                      	PUSH	DS
  7378 00000C7E C536[2E00]              	LDS	SI,[BCLOCK]
  7379 00000C82 E8A043                  	CALL	DEVIOCALL2	;Get correct date and time
  7380 00000C85 1F                      	POP	DS
  7381 00000C86 5B                      	POP	BX
  7382 00000C87 E84444                  	CALL	SETWRITE
  7383 00000C8A 8F06[B603]              	POP	WORD [TIMEBUF]
  7384 00000C8E 1E                      	PUSH	DS
  7385 00000C8F C536[2E00]              	LDS	SI,[BCLOCK]
  7386 00000C93 E88F43                  	CALL	DEVIOCALL2	;Set the date
  7387 00000C96 1F                      	POP	DS
  7388 00000C97 5B                      	POP	BX
  7389 00000C98 5E                      	POP	SI
  7390                                  WKDAY:
  7391 00000C99 A1[5403]                	MOV	AX,[DAYCNT]
  7392 00000C9C 31D2                    	XOR	DX,DX
  7393 00000C9E B90700                  	MOV	CX,7
  7394 00000CA1 40                      	INC	AX
  7395 00000CA2 40                      	INC	AX		;First day was Tuesday
  7396 00000CA3 F7F1                    	DIV	CX		;Compute day of week
  7397 00000CA5 8816[5603]              	MOV	[WEEKDAY],DL
  7398 00000CA9 30C0                    	XOR	AL,AL		;Flag OK
  7399                                  RET25:
  7400 00000CAB C3                      	RETN
  7401                                  
  7402                                  ;----------------------------------------------------------
  7403                                  
  7404                                  ;**	DSUM - Compute the sum of a string of bytes
  7405                                  ;
  7406                                  ;	ENTRY	(cx) = byte count
  7407                                  ;		(ds:si) = byte address
  7408                                  ;		(dx) = sum register, initialized by caller
  7409                                  ;	EXIT	(dx) updated
  7410                                  ;	USES	ax, cx, dx, si, flags
  7411                                  
  7412                                  DSUM:
  7413 00000CAC B400                    	MOV	AH,0
  7414 00000CAE E305                    	JCXZ	DSUM9 ; 13/05/2019 - Retro DOS v4.0
  7415                                  	;JCXZ	RET25 ; 18/07/2018
  7416                                  DSUM1:
  7417 00000CB0 AC                      	LODSB
  7418 00000CB1 01C2                    	ADD	DX,AX
  7419 00000CB3 E2FB                    	LOOP	DSUM1
  7420                                  DSUM9:
  7421 00000CB5 C3                      	RETN
  7422                                  
  7423                                  ;============================================================================
  7424                                  ; GETSET.ASM (MSDOS 6.0, 1991)
  7425                                  ;============================================================================
  7426                                  ; 29/04/2019 - Retro DOS v4.0
  7427                                  ; 18/07/2018 - Retro DOS v3.0 (GETSET.ASM, MSDOS 6.0, 1991)
  7428                                  
  7429                                  ; 12/03/2018 - Retro DOS v2.0 
  7430                                  
  7431                                  ;TITLE	GETSET - GETting and SETting MS-DOS system calls
  7432                                  ;NAME	GETSET
  7433                                  
  7434                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
  7435                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
  7436                                  
  7437                                  ;USERNUM:
  7438                                  ;	DW	0			; 24 bit user number
  7439                                  ;       DB      0
  7440                                  ;;	IF      IBM
  7441                                  ;;OEMNUM: DB    0			; 8 bit OEM number
  7442                                  ;;	ELSE
  7443                                  ;OEMNUM: DB     0FFH			; 8 bit OEM number
  7444                                  ;;	ENDIF
  7445                                  
  7446                                  ;MSVERS:		; MS-DOS version in hex for $GET_VERSION
  7447                                  ;; 08/07/2018 - Retro DOS v3.0
  7448                                  ;MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  7449                                  ;MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  7450                                  
  7451                                  ;BREAK <$Get_Version -- Return MSDOS version number>
  7452                                  ;----------------------------------------------------------------------------
  7453                                  
  7454                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7455                                  ; DOSCODE:4A0Fh (MSDOS 5.0 MSDOS.SYS)
  7456                                  
  7457                                  ; 06/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  7458                                  ; DOSCODE:4B5Fh (PCDOS 7.1 IBMDOS.COM)
  7459                                  
  7460                                  _$GET_VERSION:
  7461                                  
  7462                                  ; Inputs:
  7463                                  ;       None
  7464                                  ; Function:
  7465                                  ;       Return MS-DOS version number
  7466                                  ; Outputs:
  7467                                  ;       OEM number in BH
  7468                                  ;       User number in BL:CX (24 bits)
  7469                                  ;       Version number as AL.AH in binary
  7470                                  ;       NOTE: On pre 1.28 DOSs AL will be zero
  7471                                  
  7472                                  ; MSDOS 6.0
  7473                                  ;
  7474                                  ;	Fake_Count is used to lie about the version numbers to support
  7475                                  ;	old binarys. See ms_table.asm for more info.
  7476                                  ;
  7477                                  ;		if input al = 00
  7478                                  ;		  (bh) = OEM number			
  7479                                  ;		else if input al = 01
  7480                                  ;		  (bh) = version flags
  7481                                  ;		 
  7482                                  ;		       	 bits 0-2 = DOS internal revision
  7483                                  ;		       	 bits 3-7 = DOS type flags
  7484                                  ;		              bit 3    = DOS is in ROM
  7485                                  ;		              bit 4    = DOS in in HMA
  7486                                  ;		              bits 5-7 = reserved
  7487                                  ;               M007 change - only bit 3 is now valid. Other bits
  7488                                  ;               are 0 when AL = 1
  7489                                  
  7490                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7491 00000CB6 36C50E[B203]            	lds	cx, [ss:USERNUM]
  7492 00000CBB 8CDB                    	mov	bx, ds
  7493                                  
  7494                                  	; MSDOS 3.3 (IBMDOS.COM, offset 196Dh)
  7495                                  	;--------------------------------------
  7496                                  	; MSDOS 6.21 (MSDOS.SYS, DOSCODE:4A1Ch)
  7497                                  
  7498 00000CBD 16                              PUSH    SS
  7499 00000CBE 1F                              POP     DS
  7500                                          
  7501                                  	; 06/01/2024
  7502                                  	;MOV	BX,[USERNUM+2]
  7503                                          ;MOV	CX,[USERNUM]
  7504                                  
  7505                                  	; 13/05/2019 - Retro DOS v4.0
  7506                                  
  7507                                  	;If AL == 1, ROMDOS will return BH = dos internal version # &
  7508                                  	;DOS flags
  7509                                  
  7510 00000CBF 3C01                    	cmp	AL,1
  7511 00000CC1 7502                    	jne	short Norm_Vers
  7512                                  
  7513                                  ;ifdef ROMDOS
  7514                                  ;	mov	BH,DOSINROM 	; Just set the bit for ROM version
  7515                                  ;				(DOSINROM = 8)
  7516                                  ;else
  7517 00000CC3 30FF                            xor     bh,bh		; Otherwise return 0
  7518                                  ;endif				;M007 end
  7519                                  
  7520                                  Norm_Vers:
  7521                                  	;MOV	AX,[MSVERS]  ; MSDOS 3.3
  7522                                  
  7523                                          	; MSDOS 6.0	; MSVERS is a label in TABLE segment	
  7524                                  	; 13/05/2019 - Retro DOS v4.0
  7525 00000CC5 1E                      	push	ds		; Get the version number from the
  7526 00000CC6 8E1E[3003]              	mov	ds,[CurrentPDB]	; current app's PSP segment
  7527                                  	;mov	ax,[40h]
  7528 00000CCA A14000                  	mov	ax,[PDB.Version] ; AX = DOS version number	
  7529                                  	; 07/12/2022
  7530 00000CCD 1F                      	pop	ds
  7531 00000CCE E8A6F7                  	call	Get_User_Stack
  7532                                  				; Put values for return registers
  7533                                  				; in the proper place on the user's	 
  7534                                  				; stack addressed by DS:SI
  7535                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7536                                  gdrvfspc_ret:
  7537                                          ;MOV	[SI+user_env.user_AX],AX
  7538 00000CD1 8904                            MOV	[SI],AX
  7539                                          ;MOV	[SI+4],CX
  7540 00000CD3 894C04                  	mov	[SI+user_env.user_CX],CX
  7541                                  set_user_bx:
  7542                                  	;MOV	[SI+2],BX
  7543 00000CD6 895C02                  	mov	[SI+user_env.user_BX],BX
  7544                                  
  7545 00000CD9 C3                      	RETN
  7546                                  
  7547                                  ; 18/07/2018 - Retro DOS v3.0
  7548                                  
  7549                                  ;BREAK <$Get/Set_Verify_on_Write - return/set verify-after-write flag>
  7550                                  ;----------------------------------------------------------------------------
  7551                                  
  7552                                  ;**	$Get_Verify_On_Write - Get Status of Verify on write flag
  7553                                  ;
  7554                                  ;	ENTRY	none
  7555                                  ;	EXIT	(al) = value of VERIFY flag
  7556                                  ;	USES	all
  7557                                  
  7558                                  
  7559                                  _$GET_VERIFY_ON_WRITE:
  7560                                  
  7561                                  ;hkn; SS override
  7562 00000CDA 36A0[FF02]              	MOV	AL,[SS:VERFLG]	; Retro DOS v2.0 - 12/03/2018
  7563 00000CDE C3                      	retn
  7564                                  
  7565                                  ;**	$Set_Verify_On_Write - Set Status of Verify on write flag
  7566                                  ;
  7567                                  ;	ENTRY	(al) = value of VERIFY flag
  7568                                  ;	EXIT	none
  7569                                  ;	USES	all
  7570                                  
  7571                                  _$SET_VERIFY_ON_WRITE:
  7572                                  
  7573 00000CDF 2401                    	AND	AL,1
  7574                                  ;hkn; SS override
  7575 00000CE1 36A2[FF02]              	MOV	[SS:VERFLG],AL	; Retro DOS v2.0 - 12/03/2018
  7576                                  RET27:	; 18/07/2018
  7577 00000CE5 C3                      	retn
  7578                                  
  7579                                  ; 19/07/2018 - Retro DOS v3.0
  7580                                  
  7581                                  ;BREAK <$International - return country-dependent information>
  7582                                  ;----------------------------------------------------------------------------
  7583                                  ;
  7584                                  ; Procedure Name : $INTERNATIONAL
  7585                                  ;
  7586                                  ; Inputs:
  7587                                  ;	MOV	AH,International
  7588                                  ;	MOV	AL,country	(al = 0 => current country)
  7589                                  ;      [MOV	BX,country]
  7590                                  ;	LDS	DX,block
  7591                                  ;	INT	21
  7592                                  ; Function:
  7593                                  ;	give users an idea of what country the application is running
  7594                                  ; Outputs:
  7595                                  ;	IF DX != -1 on input (get country)
  7596                                  ;	  AL = 0 means return current country table.
  7597                                  ;	  0<AL<0FFH means return country table for country AL
  7598                                  ;	  AL = 0FF means return country table for country BX
  7599                                  ;	  No Carry:
  7600                                  ;	     Register BX will contain the 16-bit country code.
  7601                                  ;	     Register AL will contain the low 8 bits of the country code.
  7602                                  ;	     The block pointed to by DS:DX is filled in with the information
  7603                                  ;	     for the particular country.
  7604                                  ;		BYTE  Size of this table excluding this byte and the next
  7605                                  ;		BYTE  Country code represented by this table
  7606                                  ;			A sequence of n bytes, where n is the number specified
  7607                                  ;			by the first byte above and is not > internat_block_max,
  7608                                  ;			in the correct order for being returned by the
  7609                                  ;			INTERNATIONAL call as follows:
  7610                                  ;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
  7611                                  ;		5 BYTE	Currency symbol null terminated
  7612                                  ;		2 BYTE	thousands separator null terminated
  7613                                  ;		2 BYTE	Decimal point null terminated
  7614                                  ;		2 BYTE	Date separator null terminated
  7615                                  ;		2 BYTE	Time separator null terminated
  7616                                  ;		1 BYTE	Bit field.  Currency format.
  7617                                  ;			Bit 0.	=0 $ before #  =1 $ after #
  7618                                  ;			Bit 1.	no. of spaces between # and $ (0 or 1)
  7619                                  ;		1 BYTE	No. of significant decimal digits in currency
  7620                                  ;		1 BYTE	Bit field.  Time format.
  7621                                  ;			Bit 0.	=0 12 hour clock  =1 24 hour
  7622                                  ;		DWORD	Call address of case conversion routine
  7623                                  ;		2 BYTE	Data list separator null terminated.
  7624                                  ;	  Carry:
  7625                                  ;	     Register AX has the error code.
  7626                                  ;	IF DX = -1 on input (set current country)
  7627                                  ;	  AL = 0 is an error
  7628                                  ;	  0<AL<0FFH means set current country to country AL
  7629                                  ;	  AL = 0FF means set current country to country BX
  7630                                  ;	  No Carry:
  7631                                  ;	    Current country SET
  7632                                  ;	    Register AL will contain the low 8 bits of the country code.
  7633                                  ;	  Carry:
  7634                                  ;	     Register AX has the error code.
  7635                                  ;-----------------------------------------------------------------------------
  7636                                  
  7637                                  ;procedure   $INTERNATIONAL,NEAR   ; DOS 3.3
  7638                                  
  7639                                  ; 13/05/2019 - Retro DOS v4.0
  7640                                  ; DOSCODE:4A4Dh (MSDOS 6.21, MSDOS.SYS)
  7641                                  
  7642                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7643                                  ; DOSCODE:4A40h (MSDOS 5.0, MSDOS.SYS)
  7644                                  
  7645                                  ; 06/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 PCDOS.COM)
  7646                                  ; DOSCODE:4B8Dh (PCDOS 7.1, IBMDOS.COM)
  7647                                  
  7648                                  _$INTERNATIONAL:  ; IBMDOS.COM (MSDOS 3.3), offset 1992h
  7649                                  	 
  7650 00000CE6 3CFF                    	CMP	AL,0FFH
  7651 00000CE8 7404                    	JZ	short BX_HAS_CODE	; -1 means country code is in BX
  7652 00000CEA 88C3                    	MOV	BL,AL			; Put AL country code in BX
  7653 00000CEC 30FF                    	XOR	BH,BH
  7654                                  BX_HAS_CODE:
  7655 00000CEE 1E                      	PUSH	DS
  7656 00000CEF 07                      	POP	ES
  7657 00000CF0 52                      	PUSH	DX
  7658 00000CF1 5F                      	POP	DI			; User buffer to ES:DI
  7659                                  
  7660                                  ;hkn; SS is DOSDATA
  7661                                  ;	context DS
  7662                                  
  7663 00000CF2 16                      	push	ss
  7664 00000CF3 1F                      	pop	ds
  7665                                  
  7666 00000CF4 83FFFF                  	CMP	DI,-1
  7667 00000CF7 745D                    	JZ	short international_set
  7668 00000CF9 09DB                    	OR	BX,BX
  7669 00000CFB 7505                    	JNZ	short international_find
  7670                                  
  7671                                  ;hkn; country_cdpg is in DOSDATA segment.
  7672 00000CFD BE[5113]                	MOV	SI,COUNTRY_CDPG
  7673                                  
  7674 00000D00 EB39                    	JMP	SHORT international_copy
  7675                                  
  7676                                  international_find:
  7677                                  	;MOV	BP,0			 ; flag it for GetCntry only
  7678                                  	; 06/01/2024
  7679 00000D02 31ED                    	xor	bp,bp ; 0
  7680 00000D04 E80A00                  	CALL	international_get
  7681 00000D07 7255                    	JC	short errtn
  7682                                  	;CMP	BX,0			 ; nlsfunc finished it ?
  7683                                  	; 06/01/2024
  7684 00000D09 09DB                    	or	bx,bx
  7685 00000D0B 752E                    	JNZ	SHORT international_copy ; no, copy by myself
  7686 00000D0D 89D3                    	MOV	BX,DX			 ; put country back
  7687 00000D0F EB3A                    	JMP	SHORT international_ok3
  7688                                  
  7689                                  international_get:
  7690 00000D11 BE[5113]                	MOV	SI,COUNTRY_CDPG
  7691                                  
  7692                                  ;hkn; country_cdpg is in DOSDATA segment.
  7693                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  7694                                  
  7695                                  	; MSDOS 3.3
  7696                                  	;;cmp	bx,[SI+63h]
  7697                                  	;CMP	BX,[SI+DOS_CCDPG.ccDosCountry]
  7698                                  	;jz	short RET27
  7699                                  
  7700                                  	; 13/05/2019 - Retro DOS v4.0
  7701                                  
  7702                                  	; MSDOS 6.0
  7703                                  	;cmp	bx,[ss:si+68h]
  7704 00000D14 363B5C68                	CMP	BX,[ss:SI+DOS_CCDPG.ccDosCountry] ; = current country id
  7705 00000D18 74CB                    	jz	short RET27			; return if equal
  7706                                  
  7707 00000D1A 89DA                    	MOV	DX,BX
  7708 00000D1C 31DB                    	XOR	BX,BX			; bx = 0, default code page
  7709                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7710 00000D1E B80014                  	mov	ax,1400h
  7711 00000D21 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7712                                  			; Return: AL = 00h not installed, OK to install
  7713                                  			; 01h not installed, not OK
  7714                                  			; FFh installed
  7715 00000D23 3CFF                    	CMP	AL,0FFH
  7716 00000D25 7510                    	JNZ	short interr		; not in memory
  7717                                  	
  7718                                  	; 06/01/2024
  7719 00000D27 B80314                  	mov	ax,1403h		; set country info
  7720                                  
  7721                                  	;cmp	bp,0
  7722 00000D2A 09ED                    	or	bp,bp			; GetCntry ?
  7723 00000D2C 7501                    	JNZ	short stcdpg
  7724                                  	
  7725                                  	;CallInstall GetCntry,NLSFUNC,4	; get country info
  7726                                  	;mov	ax,1404h
  7727 00000D2E 40                      	inc	ax	; AX = 1404h ; get country info
  7728                                  
  7729                                  	; 06/01/2024
  7730                                  	;int	2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  7731                                  	;		; BX = code page, DX = country code,
  7732                                  	;		; DS:SI -> internal code page structure
  7733                                  	;		; ES:DI -> user buffer
  7734                                  	;		; Return: AL = status
  7735                                  	;
  7736                                  	;JMP	short chkok
  7737                                  	
  7738                                  	;nop
  7739                                  
  7740                                  stcdpg:
  7741                                  	;CallInstall SetCodePage,NLSFUNC,3  ; set country info
  7742                                  	; 06/01/2024
  7743                                  	;mov     ax,1403h
  7744                                  gscdpg:
  7745 00000D2F CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - SET COUNTRY INFO
  7746                                  			; DS:SI -> internal code page structure
  7747                                  			; BX = code page, DX = country code
  7748                                  			; Return: AL = status
  7749                                  chkok:
  7750 00000D31 08C0                    	or	al,al			; success ?
  7751                                  	;retz				; yes
  7752 00000D33 74B0                    	jz	short RET27
  7753                                  
  7754                                  setcarry:
  7755 00000D35 F9                      	STC				; set carry
  7756 00000D36 C3                      	retn
  7757                                  interr:
  7758 00000D37 B0FF                    	MOV	AL,0FFH			; flag nlsfunc error
  7759 00000D39 EBFA                    	JMP	short setcarry
  7760                                  
  7761                                  international_copy:
  7762                                  
  7763                                  ;hkn; country_cdpg is in DOSDATA segment.
  7764                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  7765                                  
  7766                                  	; MSDOS 3.3
  7767                                  	;;mov	bx,[SI+63h]
  7768                                  	;mov	BX,[SI+DOS_CCDPG.ccDosCountry]
  7769                                  	;mov	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; 08/09/2018
  7770                                  
  7771                                  	; 13/05/2019 - Retro DOS v4.0
  7772                                  
  7773                                  	; MSDOS 6.0
  7774                                  	;mov	bx,[ss:si+68h]
  7775 00000D3B 368B5C68                	MOV	BX,[ss:SI+DOS_CCDPG.ccDosCountry] ; = current country id
  7776 00000D3F BE[BD13]                	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; COUNTRY_CDPG + 108
  7777                                  
  7778                                  	;mov	cx,24
  7779 00000D42 B91800                  	MOV	CX,OLD_COUNTRY_SIZE
  7780                                  
  7781                                  	; MSDOS 6.0
  7782                                  
  7783                                  ;hkn;	must set up DS to SS so that international info can be copied
  7784                                  	
  7785 00000D45 1E                      	push	ds
  7786                                  
  7787 00000D46 16                      	push	ss			; cs -> ss
  7788 00000D47 1F                      	pop	ds
  7789                                  
  7790 00000D48 F3A4                    	REP	MOVSB			; copy country info
  7791                                  
  7792                                  	; MSDOS 6.0
  7793                                  
  7794 00000D4A 1F                      	pop	ds	;hkn;	restore ds
  7795                                  
  7796                                  international_ok3:
  7797 00000D4B E829F7                  	call	Get_User_Stack
  7798                                  ;ASSUME	DS:NOTHING
  7799                                  	;MOV	[SI+2],BX
  7800 00000D4E 895C02                  	MOV	[SI+user_env.user_BX],BX
  7801                                  international_ok:
  7802 00000D51 89D8                    	MOV	AX,BX			; Return country code in AX too.
  7803                                  ;SYS_RET_OK_jmp:
  7804                                  	; 05/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7805                                  	; 09/01/2024
  7806                                  ;nono:	; 15/12/2022
  7807                                  SYS_RET_OK_jmp:
  7808 00000D53 E91AF9                  	jmp	SYS_RET_OK
  7809                                  
  7810                                  international_set:
  7811                                  
  7812                                  ;hkn; ASSUME	DS:DOSGROUP
  7813                                  ;ASSUME	DS:DOSDATA
  7814                                  
  7815 00000D56 BD0100                  	MOV	BP,1			; flag it for SetCodePage only
  7816 00000D59 E8B5FF                  	CALL	international_get
  7817 00000D5C 73F3                    	JNC	short international_ok
  7818                                  errtn:
  7819 00000D5E 3CFF                    	CMP	AL,0FFH
  7820 00000D60 7403                    	JZ	short errtn2
  7821                                  errtn1:
  7822 00000D62 E915F9                  	jmp	SYS_RET_ERR		; return what we got from NLSFUNC
  7823                                  errtn2:
  7824                                  	;error	error_invalid_function	; NLSFUNC not existent
  7825                                  
  7826                                  	;mov	al,1
  7827 00000D65 B001                    	mov	al,error_invalid_function
  7828 00000D67 EBF9                    	jmp	short errtn1 ; 13/05/2019 - Retro DOS v4.0
  7829                                  ;errtn3:
  7830                                  ;	jmp	SYS_RET_ERR
  7831                                  
  7832                                  ;EndProc $INTERNATIONAL
  7833                                  
  7834                                  
  7835                                  ; ---------------------------------------------------------------------------
  7836                                  
  7837                                  	; 06/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 PCDOS.COM)
  7838                                  	; DOSCODE:4C10h (PCDOS 7.1, IBMDOS.COM)
  7839                                  
  7840                                  _$ExtCountryInfo:
  7841                                  			; INT 21h, AH = 70h
  7842                                  			; GET/SET INTERNATIONALIZATION INFORMATION
  7843                                  			; ****
  7844                                  			; AL = subfunction
  7845                                  			; 00h SET general internationalization info
  7846                                  			;    CX = buffer size (up to 38 bytes)
  7847                                  			;    DS:SI -> buffer containing internationalization info
  7848                                  			;  first three bytes are skipped, the rest is copied to
  7849                                  			;  somewhere in the DOS data segment
  7850                                  			; 01h SET extended internationalization info
  7851                                  			;    CX = number of bytes to set (up to 58 bytes)
  7852                                  			;    DS:SI -> buffer containing internationalization info
  7853                                  			; 02h GET extended internationalization info
  7854                                  			;    CX = buffer size in bytes (up to 58 bytes used)
  7855                                  			;    ES:DI -> buffer
  7856                                  			; ****
  7857                                  			; (Ref: Ralf Brown's Interrupt List) - had some mistakes -
  7858 00000D69 3C02                    	cmp	al,2 
  7859 00000D6B 77F8                    	ja	short errtn2
  7860 00000D6D 06                      	push    es
  7861 00000D6E 16                      	push    ss
  7862 00000D6F 750F                    	jnz	short ext_cntry_inf_1
  7863 00000D71 07                      	pop	es		; AX = GET 35 bytes info (from offset 3 to 37)
  7864                                  				; (38 bytes buffer is used)
  7865 00000D72 BF[B913]                	mov	di,_COUNTRY_ID
  7866 00000D75 268B45FE                	mov	ax,[es:di-2]	; NEW_COUNTRY_SIZE = 38
  7867 00000D79 BB0300                  	mov	bx,3		; skip the 1st 3 bytes of the buffer
  7868 00000D7C 01DE                    	add	si,bx
  7869 00000D7E EB13                    	jmp	short ext_cntry_inf_4
  7870                                  
  7871                                  ext_cntry_inf_1:
  7872 00000D80 FEC8                    	dec	al
  7873 00000D82 7506                    	jnz	short ext_cntry_inf_2 ; AX = 2
  7874                                  				; AX = 1 (set)
  7875 00000D84 07                      	pop	es
  7876 00000D85 BF[E113]                	mov	di,_ENU		; "ENU"
  7877 00000D88 EB04                    	jmp	short ext_cntry_inf_3
  7878                                  
  7879                                  ext_cntry_inf_2:
  7880 00000D8A 1F                      	pop	ds		; AX = 2 (get)
  7881 00000D8B BE[E113]                	mov	si,_ENU		; "ENU"
  7882                                  
  7883                                  ext_cntry_inf_3:		; CODE XREF: DOSCODE:4C2F^j
  7884 00000D8E 31DB                    	xor	bx,bx		; 0
  7885 00000D90 B83A00                  	mov	ax,58		; 3Ah
  7886                                  
  7887                                  ext_cntry_inf_4:
  7888 00000D93 39C1                    	cmp	cx,ax		; > 38 ? (58)
  7889                                  	;jb	short ext_cntry_inf_5 ; no
  7890 00000D95 7602                    	jna	short ext_cntry_inf_5 ; 06/01/2024
  7891 00000D97 89C1                    	mov	cx,ax		; yes, decrease size to 38 (58)
  7892                                  
  7893                                  ext_cntry_inf_5:
  7894 00000D99 89C8                    	mov	ax,cx		; buffer (filled) size
  7895 00000D9B 29D9                    	sub	cx,bx		; copy byte count
  7896 00000D9D F3A4                    	rep movsb
  7897 00000D9F 07                      	pop	es
  7898 00000DA0 E91903                  	jmp	ret_ax_to_user_cx ; ax -> user's cx
  7899                                  
  7900                                  ; ---------------------------------------------------------------------------
  7901                                  
  7902                                  ; 19/07/2018
  7903                                  
  7904                                  ;BREAK <$GetExtCntry - return extended country-dependent information>
  7905                                  
  7906                                  ;----------------------------------------------------------------------------
  7907                                  ;
  7908                                  ; Procedure Name : $GetExtCntry
  7909                                  ;
  7910                                  ; Inputs:
  7911                                  ;	if AL >= 20H
  7912                                  ;	  AL= 20H    capitalize single char, DL= char
  7913                                  ;	      21H    capitalize string, CX= string length
  7914                                  ;	      22H    capitalize ASCIIZ string
  7915                                  ;	      23H    YES/NO check, DL=1st char DH= 2nd char (DBCS)
  7916                                  ;	      80H bit 0 = use normal upper case table
  7917                                  ;		      1 = use file upper case table
  7918                                  ;	   DS:DX points to string
  7919                                  ;
  7920                                  ;	else
  7921                                  ;
  7922                                  ;	MOV	AH,GetExtCntry	 ; DOS 3.3
  7923                                  ;	MOV	AL,INFO_ID	( info type,-1 selects all )
  7924                                  ;	MOV	BX,CODE_PAGE	( -1 = active code page )
  7925                                  ;	MOV	DX,COUNTRY_ID	( -1 = active country )
  7926                                  ;	MOV	CX,SIZE 	( amount of data to return )
  7927                                  ;	LES	DI,COUNTRY_INFO ( buffer for returned data )
  7928                                  ;	INT	21
  7929                                  ; Function:
  7930                                  ;	give users extended country dependent information
  7931                                  ;	or capitalize chars
  7932                                  ; Outputs:
  7933                                  ;	  No Carry:
  7934                                  ;	     extended country info is succesfully returned
  7935                                  ;	  Carry:
  7936                                  ;	     Register AX has the error code.
  7937                                  ;	     AX=0, NO	 for YES/NO CHECK
  7938                                  ;		1, YES
  7939                                  ;----------------------------------------------------------------------------
  7940                                  
  7941                                  ;procedure   $GetExtCntry,NEAR	; DOS 3.3
  7942                                  
  7943                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7944                                  	; 06/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  7945                                  
  7946                                  	; MSDOS 6.0
  7947                                  _$GetExtCntry:
  7948 00000DA3 3C20                    	CMP	AL,CAP_ONE_CHAR 	; < 20H ?
  7949 00000DA5 726A                    	JB	short notcap
  7950                                  capcap: 				;
  7951 00000DA7 A880                    	TEST	AL,UPPER_TABLE	; 80h	; which upper case table
  7952 00000DA9 7505                    	JNZ	short fileupper		; file upper case
  7953                                  
  7954                                  ;hkn; UCASE_TAB in DOSDATA
  7955 00000DAB BB[030B]                	MOV	BX,UCASE_TAB+2		; get normal upper case
  7956 00000DAE EB05                    	JMP	SHORT capit
  7957                                  
  7958                                  fileupper:
  7959                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM - DOSCODE:4C57h)
  7960                                  	; ((Note: This must be a bugfix, because bit 7 of AX is 1 here!))
  7961                                  	; AL >= 80h
  7962 00000DB0 247F                    	and	al,7Fh 
  7963                                  
  7964                                  ;hkn; FILE_UCASE_TAB in DOSDATA
  7965 00000DB2 BB[850B]                	MOV	BX,FILE_UCASE_TAB+2 ; get file upper case
  7966                                  capit:					;
  7967 00000DB5 3C20                    	CMP	AL,CAP_ONE_CHAR ; 20h	; cap one char ?
  7968 00000DB7 750D                    	JNZ	short chkyes		; no
  7969 00000DB9 88D0                    	MOV	AL,DL			; set up AL
  7970 00000DBB E8614C                  	call	GETLET3 		; upper case it
  7971 00000DBE E8B6F6                  	call	Get_User_Stack		; get user stack
  7972                                  	;mov	[si+6],al
  7973 00000DC1 884406                  	MOV	[SI+user_env.user_DX],AL ; user's DL=AL
  7974 00000DC4 EB24                    	JMP	SHORT nono		; done
  7975                                  chkyes: 				;
  7976 00000DC6 3C23                    	CMP	AL,CHECK_YES_NO	; 23h	; check YES or NO ?
  7977 00000DC8 7523                    	JNZ	short capstring		; no
  7978                                  
  7979 00000DCA 31C0                    	XOR	AX,AX			; presume NO
  7980                                  		      
  7981                                  ;hkn; NLS_YES, NLS_NO, NLS_yes2, NLS_no2 is defined in msdos.cl3 which is
  7982                                  ;hkn; included in yesno.asm in the DOSCODE segment.
  7983                                  
  7984                                  	; 06/08/2018 - Retro DOS v3.0
  7985                                  	; 13/05/2019 - Retro DOS v4.0
  7986                                  	;cmp	dl,'Y'
  7987 00000DCC 2E3A16[5D14]            	CMP	DL,[cs:NLS_YES]		; is 'Y' ?
  7988 00000DD1 7416                    	JZ	short yesyes		; yes
  7989                                  	;cmp	dl,'y'
  7990 00000DD3 2E3A16[5F14]            	CMP	DL,[cs:NLS_yes2]	; is 'y' ?
  7991 00000DD8 740F                    	JZ	short yesyes		; yes
  7992                                  	;cmp	dl,'N'
  7993 00000DDA 2E3A16[5E14]            	CMP	DL,[cs:NLS_NO]		; is  'N'?
  7994 00000DDF 7409                    	JZ	short nono		; no
  7995                                  	;cmp	dl,'n'
  7996 00000DE1 2E3A16[6014]            	CMP	DL,[cs:NLS_no2]		; is 'n' ?
  7997 00000DE6 7402                    	JZ	short nono		; no
  7998                                  ;dbcs_char:				;
  7999 00000DE8 40                      	INC	AX			; not YES or NO
  8000                                  yesyes: 				;
  8001 00000DE9 40                      	INC	AX			; return 1
  8002                                  	; 15/12/2022
  8003                                  	; 09/01/2024 - Retro DOS v5.0
  8004                                  nono:	
  8005                                  	;jmp	short SYS_RET_OK_jmp	;
  8006                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8007                                  	; 09/01/2024
  8008 00000DEA E983F8                  	jmp	SYS_RET_OK		; done
  8009                                  
  8010                                  capstring:				;
  8011 00000DED 89D6                    	MOV	SI,DX			; si=dx
  8012 00000DEF 3C21                    	CMP	AL,CAP_STRING	; 21h	; cap string ?
  8013 00000DF1 750D                    	JNZ	short capascii		; no
  8014                                  	;OR	CX,CX			; check count 0
  8015                                  	;JZ	short nono		; yes finished
  8016                                  	; 06/01/2024
  8017 00000DF3 E3F5                    	jcxz	nono
  8018                                  concap: 				;
  8019 00000DF5 AC                      	LODSB				; get char
  8020 00000DF6 E8264C                  	call	GETLET3 		; upper case it
  8021 00000DF9 8844FF                  	MOV	byte [SI-1],AL		; store back
  8022                                  ;next99: 				;
  8023 00000DFC E2F7                    	LOOP	concap			; continue
  8024 00000DFE EBEA                    	JMP	short nono		; done
  8025                                  capascii:				;
  8026 00000E00 3C22                    	CMP	AL,CAP_ASCIIZ	; 22h	; cap ASCIIZ string ?
  8027 00000E02 7573                    	JNZ	short capinval		; no
  8028                                  concap2:				;
  8029 00000E04 AC                      	LODSB				; get char
  8030 00000E05 08C0                    	or	al,al			; end of string ?
  8031 00000E07 74E1                    	JZ	short nono		; yes
  8032 00000E09 E8134C                  	call	GETLET3 		; upper case it
  8033 00000E0C 8844FF                  	MOV	[SI-1],AL		; store back
  8034 00000E0F EBF3                    	JMP	short concap2 		; continue
  8035                                  
  8036                                  	; MSDOS 3.3 (& MSDOS 6.0)
  8037                                  
  8038                                  ; Offset 1A19h in IBMDOS.COM (MSDOS 3.3), 1987 	
  8039                                  ; _$GetExtCntry:
  8040                                  
  8041                                  notcap:
  8042 00000E11 83F905                  	CMP	CX,5			; minimum size is 5
  8043                                  	;jb	short sizeerror
  8044                                  	; 09/01/2024
  8045 00000E14 7261                    	jb	short capinval		; (size error)
  8046                                  
  8047                                  GEC_CONT:
  8048                                  ;hkn; SS is DOSDATA
  8049                                  	;context DS
  8050                                  
  8051 00000E16 16                      	push	ss
  8052                                  	;pop	es  ; ! (Retro DOS v3.0 BUG) !
  8053 00000E17 1F                      	pop	ds  ; 13/05/2019 - Retro DOS v4.0	
  8054                                  	
  8055                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  8056 00000E18 BE[5113]                	MOV	SI,COUNTRY_CDPG
  8057                                  
  8058                                  ; ------------------------------------------------------------
  8059                                  	; 06/01/2024 - Retro DOS v5.0
  8060                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:4CC6h
  8061                                  	;;;
  8062 00000E1B 08C0                    	or	al,al
  8063 00000E1D 752A                    	jnz	short GETCNTRY
  8064                                  			; AL = 0 (INT 21h, AX=6500h)
  8065                                  			; Set extended country-dependent information
  8066                                  			; (SET GENERAL INTERNATIONALIZATION INFO)
  8067                                  
  8068 00000E1F 83E907                  	sub	cx,7		; minimum 8 bytes
  8069 00000E22 7653                    	jbe	short capinval	; error_invalid_function
  8070 00000E24 8B5C48                  	mov	bx,[si+48h]	; [SI+DOS_CCDPG.ccSysCodePage]
  8071 00000E27 8D7466                  	lea	si,[si+66h]	; SI+DOS_CCDPG.ccCountryInfoLen
  8072 00000E2A 8B04                    	mov	ax,[si]
  8073 00000E2C 83E804                  	sub	ax,4
  8074 00000E2F 39C1                    	cmp	cx,ax
  8075 00000E31 7602                    	jbe	short set_intern_inf
  8076 00000E33 89C1                    	mov	cx,ax
  8077                                  set_intern_inf:
  8078 00000E35 89C8                    	mov	ax,cx
  8079 00000E37 83C004                  	add	ax,4
  8080 00000E3A 26894501                	mov	[es:di+1], ax	; info length/size (will be written)
  8081 00000E3E 83C606                  	add	si,6		; DOS_CCDPG.ccDFormat
  8082 00000E41 83C707                  	add	di,7		; points to date format
  8083 00000E44 E8AE09                  	call	XCHGP		; ds:si = user's buffer + 6
  8084                                  				; es:di = country info buffer + 7
  8085 00000E47 EB3F                    	jmp	short OK_RETN
  8086                                  	;;;
  8087                                  ; ------------------------------------------------------------
  8088                                  	
  8089                                  	; 06/01/2024
  8090                                  GETCNTRY:
  8091 00000E49 83FAFF                  	CMP	DX,-1 ; COUNTRY_ID	; active country ?
  8092 00000E4C 7503                    	JNZ	short GETCDPG 		; no
  8093                                  
  8094                                  ;hkn; use DS override to accesss country_cdpg fields
  8095                                  	;;mov	dx,[si+63h] ; MSDOS 3.3
  8096                                  	;mov	dx,[si+68h] ; MSDOS 6.0
  8097 00000E4E 8B5468                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]
  8098                                  					; get active country id;smr;use DS
  8099                                  GETCDPG:
  8100 00000E51 83FBFF                  	CMP	BX,-1 ; CODE_PAGE	; active code page?
  8101 00000E54 7503                    	JNZ	short CHKAGAIN		; no, check again
  8102                                  
  8103                                  ;hkn; use DS override to accesss country_cdpg fields
  8104                                  	;;mov	bx,[si+65h] ; MSDOS 3.3	
  8105                                  	;mov	bx,[si+6Ah] ; MSDOS 6.0
  8106 00000E56 8B5C6A                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  8107                                  					; get active code page id;smr;Use DS
  8108                                  CHKAGAIN:
  8109                                  	;cmp	dx,[si+68h] ; MSDOS 6.0
  8110 00000E59 3B5468                  	CMP	DX,[SI+DOS_CCDPG.ccDosCountry]
  8111                                  					; same as active country id?;smr;use DS
  8112 00000E5C 7550                    	JNZ	short CHKNLS		; no
  8113                                  	;cmp	bx,[si+6Ah] ; MSDOS 6.0	
  8114 00000E5E 3B5C6A                  	CMP	BX,[SI+DOS_CCDPG.ccDosCodePage]	
  8115                                  					; same as active code pg id?;smr;use DS
  8116 00000E61 754B                    	JNZ	short CHKNLS		; no
  8117                                  CHKTYPE:
  8118                                  	;mov	bx,[si+48h]
  8119 00000E63 8B5C48                  	MOV	BX,[SI+DOS_CCDPG.ccSysCodePage]	
  8120                                  					; bx = sys code page id;smr;use DS
  8121 00000E66 51                      	PUSH	CX			; save cx
  8122                                  	;mov	cx,[si+4Ah]
  8123 00000E67 8B4C4A                  	MOV	CX,[SI+DOS_CCDPG.ccNumber_of_entries]  ;smr;use DS
  8124                                  	;mov	si,COUNTRY_CDPG+76
  8125 00000E6A BE[9D13]                	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccSetUcase   ;smr;CDPG in DOSDATA
  8126                                  NXTENTRY:
  8127 00000E6D 3A04                    	CMP	AL,[SI] 		; compare info type;smr;use DS
  8128 00000E6F 740B                    	JZ	short FOUNDIT
  8129 00000E71 83C605                  	ADD	SI,5			; next entry
  8130 00000E74 E2F7                    	LOOP	NXTENTRY
  8131 00000E76 59                      	POP	CX
  8132                                  capinval:
  8133                                  	;error	error_invalid_function	; info type not found
  8134                                  	;mov	al,1
  8135 00000E77 B001                    	mov	al,error_invalid_function
  8136                                  ;SYS_RET_ERR_jmp:
  8137                                  	;jmp	SYS_RET_ERR
  8138                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8139                                  SYS_RET_ERR_jmp:
  8140 00000E79 E9FEF7                  	jmp	SYS_RET_ERR	
  8141                                  
  8142                                  FOUNDIT:
  8143 00000E7C A4                      	MOVSB				; move info id byte
  8144 00000E7D 59                      	POP	CX			; restore char count
  8145                                  	;cmp	al,1
  8146 00000E7E 3C01                    	CMP	AL,SetCountryInfo	; select country info type ?
  8147 00000E80 7415                    	JZ	short setsize
  8148 00000E82 B90400                  	MOV	CX,4			; 4 bytes will be moved
  8149 00000E85 B80500                  	MOV	AX,5			; 5 bytes will be returned in CX
  8150                                  OK_RETN:
  8151 00000E88 F3A4                    	REP	MOVSB			; copy info
  8152 00000E8A 89C1                    	MOV	CX,AX			; CX = actual length returned
  8153 00000E8C 89D8                    	MOV	AX,BX			; return sys code page in ax
  8154                                  GETDONE:
  8155 00000E8E E8E6F5                  	call	Get_User_Stack		; return actual length to user's CX
  8156                                  	;mov	[si+4],cx 
  8157 00000E91 894C04                  	MOV	[SI+user_env.user_CX],CX
  8158                                  	;jmp	SYS_RET_OK
  8159                                  	; 15/12/2022
  8160                                  	; 25/06/2019
  8161 00000E94 E9DCF7                  	jmp	SYS_RET_OK_clc
  8162                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8163                                  	; 15/12/2022
  8164                                  ;nono_jmp:
  8165                                  	;jmp	short nono
  8166                                  setsize:
  8167 00000E97 83E903                  	SUB	CX,3			; size after length field
  8168 00000E9A 390C                    	CMP	[SI],CX			; less than table size ;smr;use ds
  8169 00000E9C 7302                    	JAE	short setsize2		; no
  8170 00000E9E 8B0C                    	MOV	CX,[SI]			; truncate to table size ;smr;use ds
  8171                                  setsize2:
  8172 00000EA0 26890D                  	MOV	[ES:DI],CX		; copy actual length to user's buffer
  8173                                  	;ADD	DI,2			; update index
  8174                                  	;ADD	SI,2
  8175                                  	; 06/01/2024
  8176 00000EA3 47                      	inc	di
  8177 00000EA4 47                      	inc	di
  8178 00000EA5 46                      	inc	si
  8179 00000EA6 46                      	inc	si
  8180 00000EA7 89C8                    	MOV	AX,CX
  8181 00000EA9 83C003                  	ADD	AX,3			; AX has the actual length
  8182 00000EAC EBDA                    	JMP	short OK_RETN 		; go move it
  8183                                  CHKNLS:
  8184 00000EAE 30E4                    	XOR	AH,AH
  8185                                  	;PUSH	AX			; save info type
  8186                                  	;POP	BP			; bp = info type
  8187                                  	; 06/01/2024
  8188 00000EB0 89C5                    	mov	bp,ax
  8189                                  
  8190                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  8191 00000EB2 B80014                  	mov     ax,1400h
  8192 00000EB5 CD2F                    	int     2Fh     ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  8193                                  			; Return: AL = 00h not installed, OK to install
  8194                                  			; 01h not installed, not OK
  8195                                  			; FFh installed
  8196 00000EB7 3CFF                    	CMP	AL,0FFH
  8197 00000EB9 7402                    	JZ	short NLSNXT		; in memory
  8198                                  
  8199                                  sizeerror:
  8200                                  	; 09/01/2024 - Retro DOS v5.0
  8201                                  	;
  8202                                  ;	;error	error_invalid_function
  8203                                  ;	;mov	al,1
  8204                                  ;	mov	al,error_invalid_function
  8205                                  ;	;jmp	SYS_RET_ERR
  8206                                  ;	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8207                                  ;sys_ret_err_jmp2:
  8208                                  ;	jmp	short SYS_RET_ERR_jmp
  8209                                  	; 09/01/2024
  8210 00000EBB EBBA                    	jmp	short capinval
  8211                                  
  8212                                  NLSNXT: 
  8213                                  	;CallInstall GetExtInfo,NLSFUNC,2 ;get extended info
  8214 00000EBD B80214                  	mov     ax,1402h
  8215 00000EC0 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  8216                                  			; BP = subfunction, BX = code page
  8217                                  			; DX = country code, DS:SI -> internal code page structure
  8218                                  			; ES:DI -> user buffer, CX = size of user buffer
  8219                                  			; Return: AL = status
  8220                                  			; 00h successful
  8221                                  			; else DOS error code
  8222                                  
  8223 00000EC2 3C00                    	CMP	AL,0			; success ?
  8224 00000EC4 7505                    	JNZ	short NLSERROR
  8225                                  	;mov	ax,[si+48h] ; 13/05/2019 
  8226 00000EC6 8B4448                  	MOV	AX,[SI+DOS_CCDPG.ccSysCodePage]
  8227                                  			; ax = sys code page id;smr;use ds;
  8228                                  			;BUGBUG;check whether DS is OK after the above calls
  8229 00000EC9 EBC3                    	JMP	short GETDONE
  8230                                  seterr:
  8231                                  	; 15/12/2022
  8232                                  NLSERROR:
  8233                                  	;jmp	SYS_RET_ERR		; return what is got from NLSFUNC
  8234                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8235                                  	;jmp	short sys_ret_err_jmp2
  8236                                  	; 15/12/2022
  8237 00000ECB EBAC                    	jmp	short SYS_RET_ERR_jmp
  8238                                  
  8239                                  ;EndProc $GetExtCntry
  8240                                  
  8241                                  ; 13/05/2019 - Retro DOS v4.0
  8242                                  ; DOSCODE:4BD6h (MSDOS 6.21, MSDOS.SYS)
  8243                                  
  8244                                  ;BREAK <$GetSetCdPg - get or set global code page>
  8245                                  ;----------------------------------------------------------------------------
  8246                                  ;**	$GetSetCdPg - Get or Set Global Code Page
  8247                                  ;
  8248                                  ;   System call format:
  8249                                  ;
  8250                                  ;	MOV	AH,GetSetCdPg	; DOS 3.3
  8251                                  ;	MOV	AL,n		; n = 1 : get code page, n = 2 : set code page
  8252                                  ;	MOV	BX,CODE_PAGE	(set code page only)
  8253                                  ;	INT	21
  8254                                  ;
  8255                                  ;	ENTRY	(al) = n
  8256                                  ;		(bx) = code page
  8257                                  ;	EXIT	'C' clear
  8258                                  ;		  global code page is set	(set global code page)
  8259                                  ;		  (BX) = active code page id	(get global code page)
  8260                                  ;		  (DX) = system code page id	(get global code page)
  8261                                  ;		'C' set
  8262                                  ;		  (AX) = error code
  8263                                  
  8264                                  ;procedure  $GetSetCdPg,NEAR   ; DOS 3.3
  8265                                  
  8266                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8267                                  	; DOSCODE:4BC9h
  8268                                  
  8269                                  	; 06/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  8270                                  	; DOSCODE:4D73h
  8271                                  
  8272                                  _$GetSetCdPg:
  8273                                  
  8274                                  ;hkn; SS is DOSDATA
  8275                                  	;context DS
  8276                                  
  8277 00000ECD 16                      	push	ss
  8278 00000ECE 1F                      	pop	ds
  8279                                  
  8280                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  8281 00000ECF BE[5113]                	MOV	SI,COUNTRY_CDPG	  ; (DOSDATA:122Ah for MSDOS 6.21)
  8282                                  
  8283 00000ED2 3C01                    	CMP	AL,1		       ; get global code page
  8284 00000ED4 7512                    	JNZ	short setglpg 	       ; set global code page
  8285                                  	
  8286                                  	;;mov	bx,[si+65h] ; MSDOS 3.3
  8287                                  	;mov	bx,[si+6Ah] ; MSDOS 6.0
  8288 00000ED6 8B5C6A                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  8289                                  					; get active code page id;smr;use ds
  8290                                  	;mov	dx,[si+48h]
  8291 00000ED9 8B5448                  	MOV	DX,[SI+DOS_CCDPG.ccSysCodePage]
  8292                                  				  	; get sys code page id;smr;use ds
  8293 00000EDC E898F5                  	call	Get_User_Stack
  8294                                  ;ASSUME DS:NOTHING
  8295                                  	;;mov	[si+2],bx
  8296                                  	;MOV	[SI+user_env.user_BX],BX ; update returned bx
  8297                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
  8298 00000EDF E8F4FD                  	call    set_user_bx	; MOV [SI+user_env.user_BX],BX 
  8299                                  	;mov	[si+6],dx
  8300 00000EE2 895406                  	MOV	[SI+user_env.user_DX],DX ; update returned dx
  8301                                  OK_RETURN:
  8302                                  	; 15/12/2022
  8303                                  	;transfer SYS_RET_OK
  8304 00000EE5 E988F7                  	jmp	SYS_RET_OK
  8305                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8306                                  	;jmp	short nono_jmp
  8307                                  
  8308                                  ;hkn; ASSUME DS:DOSGROUP
  8309                                  ;ASSUME	DS:DOSDATA
  8310                                  
  8311                                  setglpg:
  8312 00000EE8 3C02                    	CMP	AL,2
  8313 00000EEA 752F                    	JNZ	short nomem
  8314                                  	
  8315                                  	;;mov	dx,[si+63h] ; MSDOS 3.3
  8316                                  	;mov	dx,[si+68h] ; MSDOS 6.0
  8317 00000EEC 8B5468                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]	;smr;use ds
  8318                                  	
  8319                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  8320 00000EEF B80014                  	mov     ax,1400h
  8321 00000EF2 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  8322                                  			; Return: AL = 00h not installed, OK to install
  8323                                  			; 01h not installed, not OK
  8324                                  			; FFh installed
  8325 00000EF4 3CFF                    	CMP	AL,0FFH
  8326 00000EF6 7523                    	JNZ	short nomem		; not in memory
  8327                                  
  8328                                  	;CallInstall SetCodePage,NLSFUNC,1 ;set the code page
  8329 00000EF8 B80114                  	mov     ax,1401h
  8330 00000EFB CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - CHANGE CODE PAGE
  8331                                  			; DS:SI -> internal code page structure
  8332                                  			; BX = new code page, DX = country code???
  8333                                  			; Return: AL = status
  8334                                  			; 00h successful
  8335                                  			; else DOS error code
  8336                                  	;cmp	al,0
  8337 00000EFD 08C0                    	or	al,al			; success ?
  8338 00000EFF 74E4                    	JZ	short OK_RETURN		; yes
  8339                                  
  8340 00000F01 3C41                    	CMP	AL,65			; set device code page failed
  8341 00000F03 75C6                    	JNZ	short seterr
  8342                                  	;MOV	AX,65
  8343                                  	; 06/01/2024
  8344 00000F05 98                      	cbw
  8345 00000F06 A3[2403]                	MOV	[EXTERR],AX
  8346                                  	;mov	byte [EXTERR_ACTION],6
  8347                                  	;mov	byte [EXTERR_CLASS],5
  8348                                  	;mov	byte [EXTERR_LOCUS],4
  8349 00000F09 C606[2603]06            	MOV	byte [EXTERR_ACTION],errACT_Ignore
  8350 00000F0E C606[2703]05            	MOV	byte [EXTERR_CLASS],errCLASS_HrdFail
  8351 00000F13 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
  8352                                  	;transfer From_GetSet
  8353 00000F18 E967F7                  	jmp	From_GetSet
  8354                                  
  8355                                  	; 15/12/2022
  8356                                  ;seterr:
  8357                                  	;;;transfer SYS_RET_ERR
  8358                                  	;;jmp	SYS_RET_ERR
  8359                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8360                                  	;jmp	short NLSERROR
  8361                                  
  8362                                  nomem:
  8363                                  	;error	error_invalid_function	; function not defined
  8364                                  	;mov	al,1
  8365 00000F1B B001                    	mov	al,error_invalid_function
  8366 00000F1D EBAC                    	jmp	short seterr
  8367                                  
  8368                                  ;EndProc $GetSetCdPg
  8369                                  
  8370                                  ; 13/05/2019 - Retro DOS v4.0
  8371                                  ; DOSCODE:4C2Bh (MSDOS 6.21, MSDOS.SYS)
  8372                                  
  8373                                  ;BREAK <$Get_Drive_Freespace -- Return bytes of free disk space on a drive>
  8374                                  ;----------------------------------------------------------------------------
  8375                                  ;**	$Get_Drive_Freespace - Return amount of drive free space
  8376                                  ;
  8377                                  ;	$Get_Drive_Freespace returns the # of free allocation units on a
  8378                                  ;		drive.
  8379                                  ;
  8380                                  ;	This call returns the same info in the same registers (except for the
  8381                                  ;	FAT pointer) as the old FAT pointer calls
  8382                                  ;
  8383                                  ;	ENTRY	DL = Drive number
  8384                                  ;	EXIT	AX = Sectors per allocation unit
  8385                                  ;		   = -1 if bad drive specified
  8386                                  ;		On User Stack
  8387                                  ;		    BX = Number of free allocation units
  8388                                  ;		    DX = Total Number of allocation units on disk
  8389                                  ;		    CX = Sector size
  8390                                  
  8391                                  ;procedure   $GET_DRIVE_FREESPACE,NEAR
  8392                                  
  8393                                  	; 09/01/2024
  8394                                  	; 06/01/2024 - Retro DOS v5.0
  8395                                  	; (PCDOS 7.1 IBMDOS.COM - DOSCODE:4DC4h)
  8396                                  
  8397                                  _$GET_DRIVE_FREESPACE:
  8398                                  
  8399                                  ;hkn; SS is DOSDATA
  8400                                  	;context DS
  8401 00000F1F 16                      	push	ss
  8402 00000F20 1F                      	pop	ds
  8403                                  
  8404 00000F21 88D0                    	MOV	AL,DL
  8405                                  	;invoke	GetThisDrv		; Get drive
  8406 00000F23 E85F65                  	call	GETTHISDRV
  8407                                  SET_AX_RET:
  8408 00000F26 721C                    	JC	short BADFDRV
  8409                                  	;invoke	DISK_INFO
  8410 00000F28 E85D24                  	call	DISK_INFO
  8411                                  	; 09/01/2024
  8412                                  	;XCHG	DX,BX
  8413                                  	;;JC	short SET_AX_RET	; User FAILed to I 24
  8414                                  	; 06/01/2024
  8415 00000F2B 7217                    	jc	short BADFDRV
  8416                                  	; 09/01/2024 - Retro DOS v5.0 (PCDOS 7.1)
  8417                                  gdrvfspc_1:
  8418 00000F2D 30E4                    	XOR	AH,AH			; Chuck Fat ID byte
  8419                                  	;;;
  8420 00000F2F 57                      	push	di
  8421 00000F30 E80E09                  	call	TestNet
  8422 00000F33 5F                      	pop	di
  8423 00000F34 7203                    	jc	short gdrvfspc_2
  8424 00000F36 E85325                  	call    modify_cluster_count
  8425                                  			; if hw of total clusters (di) > 0
  8426                                  			; sectors per cluster and cluster counts
  8427                                  			; will be modified (shifted)
  8428                                  			; (but sectors per clust * clust count will be same)
  8429                                  			; /// disk size -calculation- limit = 2 GB ///
  8430                                  gdrvfspc_2:
  8431 00000F39 87D3                    	xchg	dx,bx		; bx = free clusters (after xchg)
  8432                                  	;;;
  8433                                  DoSt:
  8434 00000F3B E839F5                  	call	Get_User_Stack
  8435                                  ;ASSUME	DS:NOTHING
  8436                                  	;mov	[si+6],dx
  8437                                  	;;mov	[si+4],cx
  8438                                  	;;mov	[si+2],bx
  8439                                  	; 09/01/2024
  8440 00000F3E 895406                  	MOV	[SI+user_env.user_DX],DX ; total clusters
  8441                                  	;MOV	[SI+user_env.user_CX],CX
  8442                                  	;MOV	[SI+user_env.user_BX],BX
  8443                                  	;;MOV	[SI+user_env.user_AX],AX
  8444                                  	;mov	[si],ax
  8445                                  	;;return
  8446                                  	;retn
  8447                                  	; 09/01/2024
  8448 00000F41 E98DFD                  	jmp     gdrvfspc_ret	; ax = sectors per cluster (modified)
  8449                                  
  8450                                  BADFDRV:
  8451                                  	; MSDOS 3.3
  8452                                  	;;mov	al,0Fh
  8453                                  	;mov	al,error_invalid_drive	; Assume error
  8454                                  
  8455                                  	; 13/05/2019 - Retro DOS v4.0
  8456                                  
  8457                                  	; MSDOS 6.0 & MSDOS 3.3
  8458                                  	;invoke	FCB_RET_ERR
  8459 00000F44 E848F7                  	call	FCB_RET_ERR
  8460                                  	
  8461 00000F47 B8FFFF                  	MOV	AX,-1
  8462 00000F4A EBEF                    	JMP	short DoSt
  8463                                  
  8464                                  ;EndProc $GET_DRIVE_FREESPACE
  8465                                  
  8466                                  ;	BREAK <$Get_DMA, $Set_DMA -- Get/Set current DMA address>
  8467                                  ;----------------------------------------------------------------------------
  8468                                  ;**	$Get_DMA - Get Disk Transfer Address
  8469                                  ;
  8470                                  ;	ENTRY	none
  8471                                  ;	EXIT	ES:BX is current transfer address
  8472                                  ;	USES	all
  8473                                  
  8474                                  	; 09/01/2024
  8475                                  _$GET_DMA:
  8476 00000F4C 368B1E[2C03]            	MOV	BX,[SS:DMAADD]
  8477 00000F51 368B0E[2E03]            	MOV	CX,[SS:DMAADD+2]
  8478 00000F56 E81EF5                  	call	Get_User_Stack
  8479                                  	;mov	[si+2],bx
  8480                                  	;mov	[si+10h],cx
  8481                                  	; 09/01/2024
  8482                                  	;MOV	[SI+user_env.user_BX],BX
  8483 00000F59 894C10                  	MOV	[SI+user_env.user_ES],CX
  8484                                  	;retn
  8485                                  	; 09/01/2024
  8486 00000F5C E977FD                  	jmp	set_user_bx
  8487                                  
  8488                                  ;**	$Set_DMA - Set Disk Transfer Address
  8489                                  ;----------------------------------------------------------------------------
  8490                                  ;	ENTRY	DS:DX is current transfer address
  8491                                  ;	EXIT	none
  8492                                  ;	USES	all
  8493                                  
  8494                                  _$SET_DMA:
  8495 00000F5F 368916[2C03]            	MOV	[SS:DMAADD],DX
  8496 00000F64 368C1E[2E03]            	MOV	[SS:DMAADD+2],DS
  8497 00000F69 C3                      	retn
  8498                                  
  8499                                  ;	BREAK <$Get_Default_Drive, $Set_Default_Drive -- Set/Get default drive>
  8500                                  ;------------------------------------------------------------------------------
  8501                                  
  8502                                  ;**	$Get_Default_Drive - Get Current Default Drive
  8503                                  ;-----------------------------------------------------
  8504                                  ;	ENTRY	none
  8505                                  ;	EXIT	(AL) = drive number
  8506                                  ;	USES	all
  8507                                  
  8508                                  _$GET_DEFAULT_DRIVE:
  8509 00000F6A 36A0[3603]              	MOV	AL,[SS:CURDRV]
  8510 00000F6E C3                      	retn
  8511                                  
  8512                                  ;**	$Set_Default_Drive - Specify new Default Drive
  8513                                  ;-----------------------------------------------------
  8514                                  ;	ENTRY	(DL) = Drive number for new default drive
  8515                                  ;	EXIT	(AL) = Number of drives, NO ERROR RETURN IF DRIVE NUMBER BAD
  8516                                  
  8517                                  _$SET_DEFAULT_DRIVE:
  8518 00000F6F 88D0                    	MOV	AL,DL
  8519 00000F71 FEC0                    	INC	AL			; A=1, B=2...
  8520 00000F73 E8F364                  	call	GetVisDrv		; see if visible drive
  8521 00000F76 7204                    	JC	short SETRET		; errors do not set
  8522 00000F78 36A2[3603]              	MOV	[SS:CURDRV],AL		; no, set
  8523                                  
  8524                                  SETRET:
  8525 00000F7C 36A0[4700]              	MOV	AL,[SS:CDSCOUNT]	; let user see what the count really is
  8526 00000F80 C3                      	retn
  8527                                  
  8528                                  ;BREAK <$Get/Set_Interrupt_Vector - Get/Set interrupt vectors>
  8529                                  ;----------------------------------------------------------------------------
  8530                                  
  8531                                  ;**	$Get_Interrupt_Vector - Get Interrupt Vector
  8532                                  ;---------------------------------------------------
  8533                                  ;	$Get_Interrupt_Vector is the official way for user pgms to get the
  8534                                  ;	contents of an interrupt vector.
  8535                                  ;
  8536                                  ;	ENTRY	(AL) = interrupt number
  8537                                  ;	EXIT	(ES:BX) = current interrupt vector
  8538                                  
  8539                                  _$GET_INTERRUPT_VECTOR:
  8540 00000F81 E82E00                  	CALL	RECSET
  8541 00000F84 26C41F                  	LES	BX,[ES:BX]
  8542 00000F87 E8EDF4                  	call	Get_User_Stack
  8543                                  set_user_es_bx:
  8544                                  	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
  8545                                  	;;mov	[si+2],bx
  8546                                  	;mov	[si+10h],es
  8547                                  	;MOV	[SI+user_env.user_BX],BX
  8548 00000F8A 8C4410                  	MOV	[SI+user_env.user_ES],ES
  8549                                  	;retn
  8550 00000F8D E946FD                  	jmp	set_user_bx
  8551                                  
  8552                                  ;**	$Set_Interrupt_Vector - Set Interrupt Vector
  8553                                  ;---------------------------------------------------
  8554                                  ;	$Set_Interrupt_Vector is the official way for user pgms to set the
  8555                                  ;	contents of an interrupt vector.
  8556                                  ;
  8557                                  ;	M004, M068: Also set A20OFF_COUNT to 1 if EXECA20OFF bit has been set 
  8558                                  ;	and if A20OFF_COUNT is non-zero. See under tag M003 in inc\dossym.inc 
  8559                                  ;	for explanation.
  8560                                  ;
  8561                                  ;	ENTRY	(AL) = interrupt number
  8562                                  ;		(ds:dx) = desired new vector value
  8563                                  ;	EXIT	none
  8564                                  ;	USES	all
  8565                                  
  8566                                  ; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8567                                  ; 13/05/2019 - Retro DOS v4.0
  8568                                  
  8569                                  _$SET_INTERRUPT_VECTOR:
  8570 00000F90 E81F00                  	CALL	RECSET
  8571 00000F93 FA                      	CLI				; Watch out!!!!! Folks sometimes use
  8572 00000F94 268917                  	MOV	[ES:BX],DX		;   this for hardware ints (like timer).
  8573 00000F97 268C5F02                	MOV	[ES:BX+2],DS
  8574 00000F9B FB                      	STI
  8575                                  					; M004, M068 - Start
  8576                                  	; MSDOS 6.0
  8577 00000F9C 36F606[8600]04          	test	byte [ss:DOS_FLAG],EXECA20OFF ; 4
  8578                                  					; Q: was the previous call an int 21h
  8579                                  					;    exec call
  8580                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8581                                  	;jnz	short siv_1		; Y: go set count
  8582                                  	;retn				; N: return
  8583                                  	; 15/12/2022
  8584 00000FA2 740D                    	jz	short siv_2
  8585                                  siv_1:	
  8586 00000FA4 36803E[8500]00          	cmp	byte [ss:A20OFF_COUNT],0 ; Q: is count 0
  8587 00000FAA 7505                    	jnz	short siv_2		 ; N: done 
  8588                                  	; 20/09/2023
  8589 00000FAC 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]
  8590                                  	;mov	byte [ss:A20OFF_COUNT],1 ; Y: set it to 1 to indicate to dos
  8591                                  					 ; dispatcher to turn A20 Off before
  8592                                  					 ; returning to user.
  8593                                  siv_2:
  8594                                  	; 07/12/2022
  8595 00000FB1 C3                      	retn				; M004, M068 - End
  8596                                  	
  8597                                  RECSET:
  8598 00000FB2 31DB                    	XOR	BX,BX
  8599 00000FB4 8EC3                    	MOV	ES,BX
  8600 00000FB6 88C3                    	MOV	BL,AL
  8601 00000FB8 D1E3                    	SHL	BX,1
  8602 00000FBA D1E3                    	SHL	BX,1
  8603 00000FBC C3                      	retn
  8604                                  
  8605                                  ;	BREAK <$Char_Oper - hack on paths, switches so that xenix can look like PCDOS>
  8606                                  ;-------------------------------------------------------------------------------------
  8607                                  
  8608                                  ;**	$Char_Oper - Manipulate Switch Character
  8609                                  ;
  8610                                  ;	This function was put in to facilitate XENIX path/switch compatibility
  8611                                  ;
  8612                                  ;	ENTRY	AL = function:
  8613                                  ;		    0 - read switch char
  8614                                  ;		    1 - set switch char (char in DL)
  8615                                  ;		    2 - read device availability
  8616                                  ;			Always returns available
  8617                                  ;		    3 - set device availability
  8618                                  ;			No longer supported (NOP)
  8619                                  ;	EXIT	(al) = 0xff iff error
  8620                                  ;		(al) != 0xff if ok
  8621                                  ;		  (dl) = character/flag, if "read switch char" subfunction
  8622                                  ;	USES	AL, DL
  8623                                  ;
  8624                                  ;	NOTE	This already obsolete function has been deactivated in DOS 5.0
  8625                                  ;		The character / is always returned for subfunction 0,
  8626                                  ;		subfunction 2 always returns -1, all other subfunctions are ignored.
  8627                                  
  8628                                  ; 13/05/2019 - Retro DOS v4.0
  8629                                  ; DOSCODE:4CC9h (MSDOS 6.21, MSDOS.SYS)
  8630                                  
  8631                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8632                                  ; DOSCODE:4CBCh (MSDOS 5.0, MSDOS.SYS)
  8633                                  
  8634                                  _$CHAR_OPER:
  8635                                  	; MSDOS 6.0
  8636 00000FBD 08C0                    	or	al,al				; get switch?
  8637 00000FBF B22F                    	mov	dl,'/'				; assume yes
  8638 00000FC1 7407                    	jz	short chop_1			; jump if yes
  8639 00000FC3 3C02                    	cmp	al,2				; check device availability?
  8640 00000FC5 B2FF                    	mov	dl,-1				; assume yes
  8641 00000FC7 7401                    	jz	short chop_1			; jump if yes
  8642 00000FC9 C3                      	retn					; otherwise just quit
  8643                                  
  8644                                  ; subfunctions requiring return of value to user come here. DL holds
  8645                                  ; value to return
  8646                                  
  8647                                  chop_1:
  8648 00000FCA E8AAF4                  	call	Get_User_Stack
  8649 00000FCD 895406                  	mov	[SI+user_env.user_DX],dx	; store value for user
  8650 00000FD0 C3                      	retn
  8651                                  
  8652                                  	; MSDOS 3.3
  8653                                  	; Offset 1B87h in IBMDOS.COM (MSDOS 3.3), 1987
  8654                                  	;push	ss
  8655                                  	;pop	ds
  8656                                  	;cmp	al,1
  8657                                  	;jb	short chop_1
  8658                                  	;jz	short chop_2
  8659                                  	;cmp	al,3
  8660                                  	;jb	short chop_3
  8661                                  	;jz	short chop_5
  8662                                  	;mov	al,0FFh
  8663                                  	;retn
  8664                                  ;chop_1:
  8665                                  	;mov	dl,[chSwitch]
  8666                                  	;jmp	short chop_4
  8667                                  ;chop_2:
  8668                                  	;mov	[chSwitch],dl
  8669                                  	;retn
  8670                                  ;chop_3:
  8671                                  	;mov	dl, FFh
  8672                                  ;chop_4:
  8673                                  	;call	Get_User_Stack
  8674                                  	;mov	[si+6],dx
  8675                                  ;chop_5:
  8676                                  	;retn
  8677                                  
  8678                                  ;**	$GetExtendedError - Return Extended error code
  8679                                  ;----------------------------------------------------------------------------
  8680                                  ;	This function reads up the extended error info from the static
  8681                                  ;	variables where it was stored.
  8682                                  ;
  8683                                  ;	ENTRY	none
  8684                                  ;	EXIT	AX = Extended error code (0 means no extended error)
  8685                                  ;		BL = recommended action
  8686                                  ;		BH = class of error
  8687                                  ;		CH = locus of error
  8688                                  ;		ES:DI = may be pointer
  8689                                  ;	USES	ALL
  8690                                  
  8691                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8692                                  
  8693                                  _$GetExtendedError:
  8694 00000FD1 16                      	push	ss
  8695 00000FD2 1F                      	pop	ds
  8696 00000FD3 A1[2403]                	MOV	AX,[EXTERR]
  8697 00000FD6 C43E[2803]              	LES	DI,[EXTERRPT]
  8698 00000FDA 8B1E[2603]              	MOV	BX,[EXTERR_ACTION]	; BL = Action, BH = Class
  8699 00000FDE 8A2E[2303]              	MOV	CH,[EXTERR_LOCUS]
  8700 00000FE2 E892F4                  	call	Get_User_Stack
  8701                                  	;mov	[si+0Ah],di
  8702 00000FE5 897C0A                  	MOV	[SI+user_env.user_DI],DI
  8703                                  
  8704                                  	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
  8705                                  	;;mov	[si+10h],es
  8706                                  	;MOV	[SI+user_env.user_ES],ES
  8707                                  	;;mov	[si+2],bx
  8708                                  	;MOV	[SI+user_env.user_BX],BX
  8709 00000FE8 E89FFF                  	call	set_user_es_bx
  8710                                  
  8711                                  	;mov	[si+4],cx
  8712 00000FEB 894C04                  	MOV	[SI+user_env.user_CX],CX
  8713                                  jmp_SYS_RET_OK:
  8714                                  	; 15/12/2022
  8715                                  	;jmp	SYS_RET_OK
  8716                                  	; 25/06/2019
  8717 00000FEE E982F6                  	jmp	SYS_RET_OK_clc ; 15/12/2022
  8718                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8719                                  ;jmp_SYS_RET_OK:
  8720                                  	;jmp	SYS_RET_OK
  8721                                  
  8722                                  ; --------------------------------------------------------------------------
  8723                                  ; 09/01/2024
  8724                                  %if 0
  8725                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8726                                  	; DOSCODE:4CF3h
  8727                                  ;patch_or_unknown:
  8728                                  ;get_code_page:
  8729                                  	push    si
  8730                                  	mov     si, COUNTRY_CDPG
  8731                                  	;mov	ax, [si+DOS_CCDPG.ccDosCodePage]
  8732                                  	mov     ax, [ss:si+6Ah]
  8733                                  	pop     si
  8734                                  	retn
  8735                                  %endif
  8736                                  ; --------------------------------------------------------------------------
  8737                                  
  8738                                  ; 29/04/2019 - Retro DOS v4.0
  8739                                  
  8740                                  ;BREAK	<ECS_call - Extended Code System support function>
  8741                                  ;---------------------------------------------------------------------------
  8742                                  ; Inputs:
  8743                                  ;	AL = 0	get lead byte table
  8744                                  ;		on return DS:SI has the table location
  8745                                  ;
  8746                                  ;	AL = 1	set / reset interim console flag
  8747                                  ;		DL = flag (00H or 01H)
  8748                                  ;		no return
  8749                                  ;
  8750                                  ;	AL = 2	get interim console flag
  8751                                  ;		on return DL = current flag value
  8752                                  ;
  8753                                  ;	AL = OTHER then error, and returns with:
  8754                                  ;		AX = error_invalid_function
  8755                                  ;
  8756                                  ;  NOTE: THIS CALL DOES GUARANTEE THAT REGISTER OTHER THAN
  8757                                  ;	 SS:SP WILL BE PRESERVED!
  8758                                  ;---------------------------------------------------------------------------
  8759                                  
  8760                                  _$ECS_Call:
  8761 00000FF1 08C0                    	or	al,al			; AL = 0 (get table)?
  8762                                  	;jnz	short _okok
  8763                                  	; 15/12/2022
  8764 00000FF3 7403                    	jz	short get_lbt
  8765                                  ;_okok:
  8766 00000FF5 E978F6                  	jmp	SYS_RET_OK
  8767                                  get_lbt:
  8768 00000FF8 E87CF4                  	call	Get_User_Stack		; *
  8769                                  
  8770                                  ;hkn; dbcs_table moved low to dosdata
  8771                                  	;mov	word [si+8],DBCS_TAB+2
  8772 00000FFB C74408[390D]            	mov	word [SI+user_env.user_SI],DBCS_TAB+2
  8773                                  
  8774 00001000 06                      	push	es
  8775                                  	;getdseg <es>			; es = DOSDATA
  8776 00001001 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  8777                                  	;mov	[si+14],es
  8778 00001006 8C440E                  	mov	[SI+user_env.user_DS],es
  8779 00001009 07                      	pop	es
  8780                                  
  8781                                  	; 15/12/2022
  8782 0000100A EBE2                    	jmp	short jmp_SYS_RET_OK ; jmp SYS_RET_OK_clc ; *
  8783                                  ;_okok:
  8784                                  	; 15/12/2022	
  8785                                  	;;transfer SYS_RET_OK
  8786                                  	;jmp	short jmp_SYS_RET_OK
  8787                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8788                                  	;;jmp	SYS_RET_OK
  8789                                  	;jmp	short jmp_SYS_RET_OK
  8790                                  
  8791                                  ; --------------------------------------------------------------------------
  8792                                  ; 10/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM - DOSCODE:4EB4h)
  8793                                  ; --------------------------------------------------------------------------
  8794                                  
  8795                                  	; INT 21h, AH=71h - LONG FILENAME FUNCTIONS
  8796                                  	; INT 21h, AH=72h - LFN FindClose
  8797                                  _$LONGNAME:
  8798 0000100C 30C0                    	xor	al,al			; longname functions are not supported
  8799                                  lfn_error:
  8800 0000100E E866F4                  	call	Get_User_Stack
  8801 00001011 834C1601                	or	word [si+16h],1		; [SI+user_env.user_F],f_Carry
  8802 00001015 F9                      	stc
  8803 00001016 8904                    	mov	[si],ax			; [SI+user_env.user_ax]
  8804 00001018 C3                      	retn
  8805                                  ; ---------------------------------------------------------------------------
  8806                                  
  8807                                  	; FAT32 - EXTENDED FUNCTIONS 
  8808                                  	; INT 21h, AH=73h
  8809                                  _$FAT32EXT:
  8810 00001019 3C05                    	cmp	al,5			; INT 21h AX = 7305h
  8811 0000101B 7609                    	jbe	short valid_fat32_ext_function
  8812 0000101D B001                    	mov	al,1			; error_invalid_function
  8813                                  fat32_ext_func_err:
  8814 0000101F E958F6                  	jmp	SYS_RET_ERR
  8815                                  
  8816                                  function_5_invalid_cx:
  8817 00001022 B057                    	mov	al,57h			; error_invalid_parameter
  8818                                  fat32_ext_func_err_j:
  8819 00001024 EBF9                    	jmp	short fat32_ext_func_err
  8820                                  
  8821                                  valid_fat32_ext_function:
  8822 00001026 7524                    	jnz	short not_function_5
  8823 00001028 83F9FF                  	cmp	cx,0FFFFh 	; Function 5 - FAT32 - EXTENDED ABSOLUTE DISK READ/WRITE
  8824 0000102B 75F5                    	jne	short function_5_invalid_cx
  8825 0000102D F7C6FE9F                	test	si,9FFEh		; read/write mode flags
  8826 00001031 75EF                    	jnz	short function_5_invalid_cx
  8827 00001033 88D0                    	mov	al,dl			; drive number, 1 = A
  8828 00001035 FEC8                    	dec	al
  8829 00001037 B401                    	mov	ah,1
  8830 00001039 F7C60100                	test	si,1
  8831 0000103D 7405                    	jz	short function_5_read
  8832 0000103F E89FF5                  	call	FAT32_ABSDWRT		; INT 21h AX = 7305h (SI bit 0 = 1)
  8833 00001042 EB03                    	jmp	short fat32_absdrw_ret
  8834                                  
  8835                                  function_5_read:
  8836 00001044 E8EAF4                  	call	FAT32_ABSDRD		; INT 21h AX = 7305h (SI bit 0 = 0)
  8837                                  fat32_absdrw_ret:
  8838 00001047 72C5                    	jc	short lfn_error
  8839 00001049 E924F6                  	jmp	SYS_RET_OK
  8840                                  
  8841                                  not_function_5:
  8842 0000104C 3C03                    	cmp	al,3		; Function 3 - FAT32 - GET EXTENDED FREE SPACE ON DRIVE
  8843 0000104E 7475                    	je	short function_73_3
  8844 00001050 3C02                    	cmp	al,2
  8845 00001052 7203                    	jb	short chk_drive_lock_flush
  8846 00001054 E90503                  	jmp	_$GET_DPB	; Function 2 - FAT32 - "Get_ExtDPB" - GET EXTENDED DPB
  8847                                  			  	; Function 4 - FAT32 - Set DPB TO USE FOR FORMATTING
  8848                                  
  8849                                  chk_drive_lock_flush:
  8850 00001057 80FA1A                  	cmp	dl,26			; MSDOS 7 - DRIVE LOCKING AND FLUSHING
  8851 0000105A 7604                    	jbe	short drv_lock_flush_1
  8852 0000105C B00F                    	mov	al,0Fh			; invalid drive number
  8853                                  drv_lock_flush_err:
  8854                                  	;jmp	short fat32_ext_func_err_j ; ax = error code
  8855                                  	; 10/01/2024
  8856 0000105E EBBF                    	jmp	short fat32_ext_func_err
  8857                                  
  8858                                  drv_lock_flush_1:
  8859 00001060 FECA                    	dec	dl
  8860 00001062 7905                    	jns	short drv_lock_flush_2
  8861 00001064 368A16[3603]            	mov	dl,[ss:CURDRV]		; 0 = default/current drive)
  8862                                  drv_lock_flush_2:
  8863 00001069 B600                    	mov	dh,0
  8864 0000106B 89D3                    	mov	bx,dx
  8865 0000106D 80F901                  	cmp	cl,1			; which flag to get or set
  8866 00001070 7604                    	jbe	short drv_lock_flush_3
  8867 00001072 B001                    	mov	al,1			; error_invalid_function
  8868                                  	;jmp	short drv_lock_flush_err
  8869                                  	; 10/01/2024
  8870 00001074 EBA9                    	jmp	short fat32_ext_func_err
  8871                                  
  8872                                  drv_lock_flush_3:
  8873 00001076 368AA7[2F14]            	mov	ah,[ss:drive_flags+bx]
  8874 0000107B 08C9                    	or	cl,cl
  8875 0000107D 7422                    	jz	short get_set_indctd_flag ; use bit 1 and bit 2
  8876 0000107F 08C0                    	or	al,al			; get drive's dirty-buffers flag
  8877 00001081 7419                    	jz	short get_dirty_buf_flag ; use bit 3
  8878 00001083 80E4F7                  	and	ah,0F7h			; clear bit 3
  8879 00001086 80E508                  	and	ch,8			; izolate bit 3 of the new flag value
  8880 00001089 08EC                    	or	ah,ch			; set AH bit 3 according to CH bit 3
  8881 0000108B 3688A7[2F14]            	mov	[ss:drive_flags+bx],ah	; set or reset dirty buffer flag
  8882 00001090 F6C408                  	test	ah,8
  8883 00001093 7505                    	jnz	short set_dirty_flag_ok	; bit 3 is set/1
  8884 00001095 B0FF                    	mov	al,0FFh
  8885 00001097 E89553                  	call	FLUSHBUF
  8886                                  set_dirty_flag_ok:
  8887 0000109A EB26                    	jmp	short jmp_to_SYS_RET_OK
  8888                                  
  8889                                  get_dirty_buf_flag:
  8890 0000109C 80E408                  	and	ah,8			; izolate dirty buffers flag
  8891 0000109F EB19                    	jmp	short mov_flag_cl_to_al	; AH = new flag and 08h (bit 3 used)
  8892                                  
  8893                                  get_set_indctd_flag:
  8894 000010A1 08C0                    	or	al,al
  8895 000010A3 7412                    	jz	short get_indicated_flag
  8896 000010A5 80E4F9                  	and	ah,0F9h			; clear bit 1 and bit 2
  8897 000010A8 F6C502                  	test	ch,2			; new value for indicated flag
  8898 000010AB 7403                    	jz	short reset_indctd_flags ; bit 1 is zero
  8899 000010AD 80CC06                  	or	ah,6			; set bit 1 and bit 2
  8900                                  reset_indctd_flags:
  8901 000010B0 3688A7[2F14]            	mov	[ss:drive_flags+bx],ah
  8902 000010B5 EB0B                    	jmp	short jmp_to_SYS_RET_OK
  8903                                  
  8904                                  get_indicated_flag:
  8905 000010B7 80E406                  	and	ah,6			; AH = new flag and 06h (bits 1 and 2 used)
  8906                                  mov_flag_cl_to_al:			; CODE XREF: DOSCODE:4F47^j
  8907 000010BA 88C8                    	mov	al,cl			; value of CL on entry
  8908                                  ret_ax_to_user_cx:  ; ax -> user's cx
  8909 000010BC E8B8F3                  	call	Get_User_Stack
  8910 000010BF 894404                  	mov	[si+4],ax		; [SI+user_env.user_cx] ; requested flag
  8911                                  jmp_to_SYS_RET_OK:
  8912 000010C2 E9ABF5                  	jmp	SYS_RET_OK
  8913                                  
  8914                                  function_73_3:
  8915 000010C5 89D6                    	mov	si,dx		; FAT32 - GET EXTENDED FREE SPACE ON DRIVE
  8916                                  				; AX = 7303h
  8917                                  				; DS:DX -> ASCIZ string for drive ("C:\" or "\\SERVER\Share")
  8918                                  				; ES:DI -> buffer for extended free space structure
  8919                                  				; CX = length of buffer for extended free space
  8920 000010C7 E8C167                  	call	DriveFromText
  8921 000010CA 92                      	xchg	ax,dx
  8922 000010CB AD                      	lodsw
  8923 000010CC FECA                    	dec	dl
  8924 000010CE 80FA1A                  	cmp	dl,26
  8925 000010D1 7323                    	jnb	short func_73_3_err2
  8926 000010D3 08E4                    	or	ah,ah
  8927 000010D5 751F                    	jnz	short func_73_3_err2
  8928 000010D7 E87549                  	call	PATHCHRCMP
  8929 000010DA 751A                    	jnz	short func_73_3_err2
  8930 000010DC FEC2                    	inc	dl
  8931 000010DE 83F92C                  	cmp	cx,44			; buffer (Structure) size must be 44
  8932 000010E1 721C                    	jb	short func_73_3_err4
  8933 000010E3 26837D0200              	cmp	word [es:di+2],0	; buffer structure version (must be 0)
  8934 000010E8 7511                    	jnz	short func_73_3_err3
  8935 000010EA 16                      	push	ss
  8936 000010EB 1F                      	pop	ds
  8937 000010EC 88D0                    	mov	al,dl
  8938 000010EE E89463                  	call	GETTHISDRV
  8939 000010F1 7310                    	jnc	short fill_efs_struc_b
  8940                                  func_73_3_err1:
  8941 000010F3 E899F5                  	call	FCB_RET_ERR
  8942                                  func_73_3_err2:
  8943 000010F6 B00F                    	mov	al,0Fh			; error_invalid_drive
  8944                                  jmp_to_SYS_RET_ERR:
  8945 000010F8 E97FF5                  	jmp	SYS_RET_ERR
  8946                                  
  8947                                  func_73_3_err3:
  8948 000010FB B057                    	mov	al,57h			; error_invalid_parameter
  8949                                  jmp_to_jmp_SYS_RET_ERR:
  8950 000010FD EBF9                    	jmp	short jmp_to_SYS_RET_ERR
  8951                                  
  8952                                  func_73_3_err4:
  8953 000010FF B018                    	mov	al,18h	   		; error_bad_length
  8954 00001101 EBFA                    	jmp	short jmp_to_jmp_SYS_RET_ERR
  8955                                  
  8956                                  fill_efs_struc_b:
  8957 00001103 E88222                  	call	DISK_INFO
  8958 00001106 72EB                    	jc	short func_73_3_err1
  8959 00001108 30E4                    	xor	ah,ah
  8960 0000110A 56                      	push	si			; si:dx = free cluster count
  8961 0000110B 57                      	push	di			; di:bx = number of clusters
  8962 0000110C E868F3                  	call	Get_User_Stack
  8963 0000110F 8E4410                  	mov	es,[si+10h]		; user's buffer segment (in ES)
  8964 00001112 8B7C0A                  	mov	di,[si+0Ah]		; user's buffer offset/address (in DI)
  8965                                  	; 10/01/2024
  8966 00001115 06                      	push	es
  8967 00001116 1F                      	pop	ds ; (*)
  8968                                  	;
  8969                                  	;mov	[es:di+10h],bx		; total number of clusters on the drive
  8970                                  	;mov	[es:di+20h],bx		; total allocation units, without adjustment for compression
  8971 00001117 895D10                  	mov	[di+10h],bx
  8972 0000111A 895D20                  	mov	[di+20h],bx
  8973 0000111D 5B                      	pop	bx
  8974                                  	;mov	[es:di+12h],bx		; total number of clusters on the drive, hw
  8975                                  	;mov	[es:di+22h],bx		; total allocation units, hw
  8976                                  	;mov	[es:di+0Ch],dx		; number of available clusters
  8977                                  	;mov	[es:di+1Ch],dx		; number of available allocation units, without adjustment
  8978 0000111E 895D12                  	mov	[di+12h],bx
  8979 00001121 895D22                  	mov	[di+22h],bx
  8980 00001124 89550C                  	mov	[di+0Ch],dx
  8981 00001127 89551C                  	mov	[di+1Ch],dx
  8982 0000112A 5A                      	pop	dx
  8983                                  	;mov	[es:di+0Eh],dx		; number of available clusters, hw
  8984                                  	;mov	[es:di+1Eh],dx		; number of available allocation units, hw
  8985                                  	;mov	[es:di+8],cx		; bytes per sector
  8986                                  	;mov	[es:di+4],ax		; sectors per cluster (with adjustment for compression)
  8987 0000112B 89550E                  	mov	[di+0Eh],dx
  8988 0000112E 89551E                  	mov	[di+1Eh],dx
  8989 00001131 894D08                  	mov	[di+8],cx
  8990 00001134 894504                  	mov	[di+4],ax	
  8991 00001137 89C1                    	mov	cx,ax
  8992 00001139 F7E3                    	mul	bx			; 32 bit multiplication
  8993 0000113B 720B                    	jc	short dsk_cap_calc_overf ; disk capacity calculation overflow error
  8994 0000113D 89C3                    	mov	bx,ax
  8995                                  	;mov	ax,[es:di+20h]		; total allocation units, lw
  8996 0000113F 8B4520                  	mov	ax,[di+20h]
  8997 00001142 F7E1                    	mul	cx
  8998 00001144 01DA                    	add	dx,bx
  8999 00001146 7305                    	jnb	short dsk_cap_calc_ok
  9000                                  dsk_cap_calc_overf:
  9001 00001148 B8FFFF                  	mov	ax,0FFFFh		; set to 0FFFFFFFFh
  9002 0000114B 89C2                    	mov	dx,ax
  9003                                  dsk_cap_calc_ok:
  9004                                  	; 10/01/2024
  9005                                  	; ds = es (*)
  9006                                  	;mov	[es:di+1Ah],dx
  9007                                  	;mov	[es:di+18h],ax		; total number of physical sectors on the drive,
  9008                                  					; without adjustment for compression
  9009 0000114D 89551A                  	mov	[di+1Ah],dx
  9010 00001150 894518                  	mov	[di+18h],ax
  9011 00001153 89C8                    	mov	ax,cx			; 32 bit multiplication
  9012                                  	;mul	word [es:di+0Eh]	; number of available clusters, hw
  9013 00001155 F7650E                  	mul	word [di+0Eh]
  9014 00001158 720B                    	jc	short dsk_free_calc_overf
  9015 0000115A 89C3                    	mov	bx,ax
  9016                                  	;mov	ax,[es:di+0Ch]		; number of available clusters, lw
  9017 0000115C 8B450C                  	mov	ax,[di+0Ch]
  9018 0000115F F7E1                    	mul	cx
  9019 00001161 01DA                    	add	dx,bx
  9020 00001163 7305                    	jnc	short dsk_free_calc_ok
  9021                                  dsk_free_calc_overf:
  9022 00001165 B8FFFF                  	mov	ax,0FFFFh
  9023 00001168 89C2                    	mov	dx,ax
  9024                                  dsk_free_calc_ok:
  9025                                  	; 10/01/2024
  9026                                  	;mov	[es:di+16h],dx		; hw
  9027                                  	;mov	[es:di+14h],ax		; number of physical sectors available on the drive,
  9028                                  					; without adjustment for compression
  9029 0000116A 895516                  	mov	[di+16h],dx
  9030 0000116D 894514                  	mov	[di+14h],ax
  9031 00001170 31C0                    	xor	ax,ax	; 0
  9032                                  	;mov	[es:di+0Ah],ax		; number of bytes per sector, high word = 0
  9033                                  	;mov	[es:di+6],ax		; number of sectors per cluster, high word = 0
  9034 00001172 89450A                  	mov	[di+0Ah],ax
  9035 00001175 894506                  	mov	[di+6],ax
  9036                                  	
  9037                                  	;mov	[es:di+24h],ax		; reserved, 8 bytes zero
  9038                                  	;mov	[es:di+26h],ax
  9039                                  	;mov	[es:di+28h],ax
  9040                                  	;mov	[es:di+2Ah],ax
  9041 00001178 83C724                  	add	di,24h ; 36 ; 10/01/2024
  9042 0000117B AB                      	stosw
  9043 0000117C AB                      	stosw
  9044 0000117D AB                      	stosw
  9045 0000117E AB                      	stosw
  9046 0000117F B82C00                  	mov	ax,44
  9047 00001182 29C7                    	sub	di,ax ; 10/01/2024 
  9048                                  	;mov	[es:di],ax		; size of returned structure = 44
  9049                                  	; 10/01/2024
  9050                                  	;mov	[di],ax
  9051 00001184 AB                      	stosw
  9052 00001185 E9E8F4                  	jmp	SYS_RET_OK
  9053                                  
  9054                                  ; ---------------------------------------------------------------------------
  9055                                  
  9056                                  ; 12/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM/MSDOS.SYS)
  9057                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:504Ah
  9058                                  
  9059                                  Set_DPBforFormat:	; INT 21h, AX = 7304h (continues from _$GET_DPB)
  9060                                  	; 12/01/2024			; (Ref: Ralf Brown's Interrupt List)
  9061 00001188 B81800                  	mov	ax,18h
  9062 0000118B 394404                  	cmp	[si+4],ax	
  9063                                  	;cmp	word ptr [si+4],24	; [SI+user_env.user_CX]
  9064                                  					; size of buffer (must be at least 18h)
  9065                                  	;jnb	short setdpbf_2
  9066                                  	;mov	al,18h			; error_bad_length
  9067                                  ;setdpbf_1:
  9068                                  	;jmp	SYS_RET_ERR
  9069 0000118E 7223                    	jb	short setdpbf_1 ; al = 18h
  9070                                  setdpbf_2:
  9071 00001190 06                      	push	es			; ES:BP = Drive parameter block
  9072 00001191 55                      	push	bp
  9073 00001192 8E4410                  	mov	es,[si+10h]		; [SI+user_env.user_ES]
  9074 00001195 8B7C0A                  	mov	di,[si+0Ah]		; [SI+user_env.user_DI]
  9075 00001198 5E                      	pop	si
  9076 00001199 1F                      	pop	ds
  9077                                  
  9078 0000119A 268B4504                	mov	ax,[es:di+4]		; (call) function number
  9079 0000119E 26837D0200              	cmp	word [es:di+2],0	; structure version (must be 0)
  9080 000011A3 750C                    	jnz	short setdpbf_3
  9081 000011A5 26837D0600              	cmp	word [es:di+6],0	; (must be 0)
  9082 000011AA 7505                    	jnz	short setdpbf_3
  9083 000011AC 83F804                  	cmp	ax,4			; (max) 5 functions (0 to 4)
  9084 000011AF 7605                    	jbe	short setdpbf_4
  9085                                  setdpbf_3:
  9086 000011B1 B057                    	mov	al,57h			; error_invalid_parameter
  9087                                  	;jmp	short setdpbf_1
  9088                                  setdpbf_1:
  9089 000011B3 E9C4F4                  	jmp	SYS_RET_ERR
  9090                                  
  9091                                  setdpbf_4:
  9092 000011B6 26C7051800              	mov	word [es:di],18h	; (call) size
  9093 000011BB 08C0                    	or	al,al
  9094 000011BD 7403                    	jz	short setdpbf_5		; invalidate DPB counts
  9095 000011BF E98200                  	jmp	setdpbf_18
  9096                                  
  9097                                  setdpbf_5:
  9098 000011C2 31D2                    	xor	dx,dx	; 0
  9099 000011C4 8B5C0D                  	mov	bx,[si+0Dh]		; DPB.MAX_CLUSTER
  9100 000011C7 39540F                  	cmp	[si+0Fh],dx ; 0
  9101                                  	;cmp	word [si+0Fh],0		; DPB.FAT_SIZE
  9102 000011CA 7506                    	jnz	short setdpbf_6		; not FAT32
  9103 000011CC 8B542F                  	mov	dx,[si+2Fh]
  9104 000011CF 8B5C2D                  	mov	bx,[si+2Dh]		; DPB.LAST_CLUSTER
  9105                                  setdpbf_6:
  9106 000011D2 268B450A                	mov	ax,[es:di+0Ah]
  9107 000011D6 268B4D08                	mov	cx,[es:di+8]		; new DPB free count
  9108                                  		  		; (00000000h=no change, FFFFFFFFh=unknown)
  9109 000011DA 09C0                    	or	ax,ax
  9110 000011DC 7502                    	jnz	short setdpbf_7
  9111 000011DE E322                    	jcxz	setdpbf_11
  9112                                  setdpbf_7:
  9113 000011E0 83F8FF                  	cmp	ax,0FFFFh
  9114 000011E3 7505                    	jne	short setdpbf_8
  9115 000011E5 83F9FF                  	cmp	cx,0FFFFh
  9116 000011E8 7408                    	je	short setdpbf_10	; (set as UNKNOWN/INITIAL)
  9117                                  setdpbf_8:
  9118 000011EA 39D0                    	cmp	ax,dx			; must be < DPB.LAST_CLUSTER
  9119 000011EC 7502                    	jne	short setdpbf_9
  9120 000011EE 39D9                    	cmp	cx,bx
  9121                                  setdpbf_9:
  9122 000011F0 73BF                    	jnb	short setdpbf_3
  9123                                  setdpbf_10:
  9124 000011F2 804C1801                	or	byte [si+18h],1		; DPB.FIRST_ACCESS (bit 0 = 1)
  9125 000011F6 894C1F                  	mov	[si+1Fh],cx		; DPB.FREE_CNT
  9126 000011F9 837C0F00                	cmp	word [si+0Fh],0		; DP.FAT_SIZE
  9127 000011FD 7503                    	jnz	short setdpbf_11	; FAT12 or FAT16
  9128 000011FF 894421                  	mov	[si+21h],ax		; DPB.FREE_CNT_HW
  9129                                  setdpbf_11:
  9130 00001202 268B450E                	mov	ax,[es:di+0Eh]
  9131 00001206 268B4D0C                	mov	cx,[es:di+0Ch]		; new DPB next-free
  9132                                  		  		; (00000000h=no change, FFFFFFFFh=unknown)
  9133 0000120A 09C0                    	or	ax,ax
  9134 0000120C 7502                    	jnz	short setdpbf_12
  9135 0000120E E32E                    	jcxz	setdpbf_17
  9136                                  setdpbf_12:
  9137 00001210 83F8FF                  	cmp	ax,0FFFFh
  9138 00001213 7505                    	jne	short setdpbf_13
  9139 00001215 83F9FF                  	cmp	cx,0FFFFh
  9140 00001218 7411                    	je	short setdpbf_16	; (set as UNKNOWN/INITIAL)
  9141                                  setdpbf_13:
  9142 0000121A 21C0                    	and	ax,ax
  9143                                  	;cmp	ax,0			; must be >= 2
  9144 0000121C 7505                    	jnz	short setdpbf_14
  9145 0000121E 83F902                  	cmp	cx,2
  9146                                  ;setdpbf_14:
  9147 00001221 728E                    	jb	short setdpbf_3
  9148                                  setdpbf_14:
  9149 00001223 39D0                    	cmp	ax,dx			; must be < DPB.LAST_CLUSTER
  9150 00001225 7502                    	jne	short setdpbf_15
  9151 00001227 39D9                    	cmp	cx,bx
  9152                                  setdpbf_15:
  9153 00001229 7786                    	ja	short setdpbf_3
  9154                                  setdpbf_16:
  9155 0000122B 804C1801                	or	byte [si+18h],1		; DPB.FIRST_ACCESS (bit 0 = 1)
  9156 0000122F 894C1D                  	mov	[si+1Dh],cx		; DPB.NEXT_FREE
  9157 00001232 837C0F00                	cmp	word [si+0Fh],0		; DPB.FAT_SIZE
  9158 00001236 7506                    	jnz	short setdpbf_17	; FAT16 or FAT12
  9159 00001238 89443B                  	mov	[si+3Bh],ax
  9160 0000123B 894C39                  	mov	[si+39h],cx		; DPB.FAT32_NXTFREE
  9161                                  setdpbf_17:
  9162 0000123E B80473                  	mov	ax,7304h		; done (successful)
  9163 00001241 E92CF4                  	jmp	SYS_RET_OK
  9164                                  
  9165                                  setdpbf_18:
  9166                                  	;dec	al
  9167 00001244 48                      	dec	ax
  9168 00001245 7514                    	jnz	short setdpbf_19
  9169 00001247 1E                      	push	ds			; rebuild DPB from BPB
  9170 00001248 56                      	push	si
  9171 00001249 26C57508                	lds	si,[es:di+8]		; BIOS Parameter Block
  9172 0000124D 5D                      	pop	bp
  9173 0000124E 07                      	pop	es
  9174 0000124F B95845                  	mov	cx,4558h		; 'XE' (NASM syntax)
  9175 00001252 BA5241                  	mov	dx,4152h		; 'RA' (NASM syntax)
  9176 00001255 E82302                  	call	_$SETDPB
  9177 00001258 E915F4                  	jmp	SYS_RET_OK
  9178                                  
  9179                                  setdpbf_19:
  9180                                  	;dec	al
  9181 0000125B 48                      	dec	ax
  9182 0000125C 7507                    	jnz	short setdpbf_20
  9183                                  		  ; force media change
  9184                                  		  ; (next access to drive rebuild DPB)
  9185 0000125E 804C1880                	or	byte [si+18h],80h	; DPB.FIRST_ACCESS (bit 7 = 1)
  9186                                  setdpbf_29:	; 12/01/2024
  9187 00001262 E90BF4                  	jmp	SYS_RET_OK
  9188                                  
  9189                                  setdpbf_20:
  9190 00001265 837C0F00                	cmp	word [si+0Fh],0		; DPB.FAT_SIZE
  9191 00001269 7405                    	jz	short setdpbf_22 ; FAT32
  9192 0000126B B00F                    	mov	al,0Fh			; error_invalid_drive
  9193                                  		 ; (function 3 or 4 are only for drives with FAT32 fs)
  9194                                  setdpbf_21:
  9195 0000126D E90AF4                  	jmp	SYS_RET_ERR
  9196                                  
  9197                                  setdpbf_22:
  9198                                  	;dec	al
  9199 00001270 48                      	dec	ax
  9200 00001271 7454                    	jz	short setdpbf_30	; get/set active FAT number and mirroring
  9201 00001273 8B4435                  	mov	ax,[si+35h]		; DPB.ROOT_CLUSTER		
  9202                                  			; get/set root directory cluster number
  9203 00001276 2689450C                	mov	[es:di+0Ch],ax		; (ret) previous root directory cluster number
  9204 0000127A 8B4437                  	mov	ax,[si+37h]
  9205 0000127D 2689450E                	mov	[es:di+0Eh],ax
  9206 00001281 268B4D0A                	mov	cx,[es:di+0Ah]
  9207 00001285 268B4508                	mov	ax,[es:di+8]		; (call) new root directory cluster number
  9208 00001289 83F8FF                  	cmp	ax,0FFFFh		; -1 --> return only previous root dir cluster number
  9209 0000128C 7505                    	jne	short setdpbf_23
  9210 0000128E 83F9FF                  	cmp	cx,0FFFFh
  9211 00001291 74CF                    	je	short setdpbf_29
  9212                                  setdpbf_23:
  9213 00001293 21C9                    	and	cx,cx
  9214                                  	;cmp	cx,0			; cluster number must be >= 2
  9215                                  	;jnz	short setdpbf_24
  9216 00001295 7509                    	jnz	short setdpbf_26
  9217 00001297 83F802                  	cmp	ax,2
  9218                                  setdpbf_24:
  9219 0000129A 7304                    	jnb	short setdpbf_26
  9220                                  setdpbf_25:
  9221                                  	;jmp	setdpbf_3		; error (invalid parameter)
  9222                                  	; 12/01/2024
  9223 0000129C B057                    	mov	al,57h			; error_invalid_parameter
  9224 0000129E EBCD                    	jmp	short setdpbf_21
  9225                                  
  9226                                  setdpbf_26:
  9227 000012A0 3B4C2F                  	cmp	cx,[si+2Fh]		; must be <= DPB.LAST_CLUSTER
  9228 000012A3 7503                    	jne	short setdpbf_27
  9229 000012A5 3B442D                  	cmp	ax,[si+2Dh]
  9230                                  setdpbf_27:
  9231 000012A8 77F2                    	ja	short setdpbf_25	; error
  9232 000012AA 894C37                  	mov	[si+37h],cx		; DPB.ROOT_CLUSTER
  9233 000012AD 894435                  	mov	[si+35h],ax
  9234 000012B0 804C1802                	or	byte [si+18h],2		; DPB.FIRST_ACCESS (bit 1 = 1)
  9235 000012B4 1E                      	push    ds
  9236 000012B5 56                      	push    si
  9237 000012B6 5D                      	pop	bp
  9238 000012B7 07                      	pop	es
  9239 000012B8 E84806                  	call    ECritDisk
  9240 000012BB E8D321                  	call    update_fat32_fsinfo
  9241 000012BE E86F06                  	call    LCritDisk
  9242 000012C1 739F                    	jnc	short setdpbf_29
  9243 000012C3 B01F                    	mov	al,1Fh			; error_gen_failure
  9244                                  setdpbf_28:
  9245 000012C5 EBA6                    	jmp	short setdpbf_21
  9246                                  
  9247                                  	; 12/01/2024
  9248                                  ;setdpbf_29:
  9249                                  	;jmp	SYS_RET_OK
  9250                                  
  9251                                  setdpbf_30:
  9252                                  	; 12/01/2024
  9253                                  	; ax = 0
  9254 000012C7 8164238F00              	and	word [si+23h],8Fh	; DPB.EXT_FLAGS (clear bit 4-6)
  9255 000012CC 8B4C23                  	mov	cx,[si+23h]
  9256 000012CF 26894D0C                	mov	[es:di+0Ch],cx		; (ret) previous active FAT/mirroring state
  9257 000012D3 2689450E                	mov	[es:di+0Eh],ax ; 0
  9258                                  	;mov	word [es:di+0Eh],0	; put zero to Set_DPBforFormat struc offset 14
  9259 000012D7 268B5508                	mov	dx,[es:di+8]		; (call) new active FAT/mirroring state,
  9260                                  		  			;  or FFFFFFFFh to get
  9261 000012DB 83FAFF                  	cmp	dx,0FFFFh
  9262                                  	;jnz	short setdpbf_31
  9263                                  	;jmp	SYS_RET_OK
  9264                                  	; 12/01/2024
  9265 000012DE 7482                    	je	short setdpbf_29
  9266                                  
  9267                                  setdpbf_31:
  9268 000012E0 F7C270FF                	test    dx,0FF70h
  9269                                  	;jz	short setdpbf_33	; bit 4-6 of DBP.EXT_FLAGS must be 0
  9270                                  	;mov	al,57h			; error_invalid_parameter
  9271                                  	; 12/01/2024
  9272 000012E4 75B6                    	jnz	short setdpbf_25
  9273                                  setdpbf_32:
  9274                                  	;;jmp	short setdpbf_28
  9275                                  	; 12/01/2024
  9276                                  	;jmp	short setdpbf_21
  9277                                  	
  9278                                  setdpbf_33:
  9279 000012E6 B001                    	mov	al,1			; error_invalid_function
  9280                                  					; (modification is not allowed)
  9281                                  	;jmp	short setdpbf_32
  9282                                  	; 12/01/2024
  9283 000012E8 EB83                    	jmp	short setdpbf_21
  9284                                  
  9285                                  ; ---------------------------------------------------------------------------
  9286                                  
  9287                                  ;============================================================================
  9288                                  ; PARSE.ASM, MSDOS 6.0, 1991
  9289                                  ;============================================================================
  9290                                  ; 19/07/2018 - Retro DOS v3.0
  9291                                  ; 15/05/2019 - Retro DOS v4.0
  9292                                  
  9293                                  ; System calls for parsing command lines
  9294                                  ;
  9295                                  ;   $PARSE_FILE_DESCRIPTOR
  9296                                  ;
  9297                                  ;   Modification history:
  9298                                  ;
  9299                                  ;       Created: ARR 30 March 1983
  9300                                  ;               EE PathParse 10 Sept 1983
  9301                                  ;
  9302                                  
  9303                                  ;BREAK <$Parse_File_Descriptor -- Parse an arbitrary string into an FCB>
  9304                                  ;---------------------------------------------------------------------------
  9305                                  ; Inputs:
  9306                                  ;       DS:SI Points to a command line
  9307                                  ;       ES:DI Points to an empty FCB
  9308                                  ;       Bit 0 of AL = 1 At most one leading separator scanned off
  9309                                  ;                   = 0 Parse stops if separator encountered
  9310                                  ;       Bit 1 of AL = 1 If drive field blank in command line - leave FCB
  9311                                  ;                   = 0  "    "    "     "         "      "  - put 0 in FCB
  9312                                  ;       Bit 2 of AL = 1 If filename field blank - leave FCB
  9313                                  ;                   = 0  "       "      "       - put blanks in FCB
  9314                                  ;       Bit 3 of AL = 1 If extension field blank - leave FCB
  9315                                  ;                   = 0  "       "      "        - put blanks in FCB
  9316                                  ; Function:
  9317                                  ;       Parse command line into FCB
  9318                                  ; Returns:
  9319                                  ;       AL = 1 if '*' or '?' in filename or extension, 0 otherwise
  9320                                  ;       DS:SI points to first character after filename
  9321                                  ;---------------------------------------------------------------------------
  9322                                  
  9323                                  	; 13/01/2024
  9324                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:51BFh
  9325                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:4D22h
  9326                                  
  9327                                  _$PARSE_FILE_DESCRIPTOR:
  9328 000012EA E8D445                  	call	MAKEFCB
  9329 000012ED 56                      	PUSH    SI
  9330 000012EE E886F1                  	call	Get_User_Stack
  9331                                  	;pop	word [si+8]
  9332 000012F1 8F4408                  	POP     word [SI+user_env.user_SI]
  9333 000012F4 C3                      	retn
  9334                                  
  9335                                  ; --------------------------------------------------------------------------
  9336                                  ; 13/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM - DOSCODE:51CAh)
  9337                                  ; --------------------------------------------------------------------------
  9338                                  
  9339                                  set_exerr_locus_unk:
  9340 000012F5 50                      	push    ax
  9341 000012F6 B001                    	mov     al,1		; errLOC_Unk
  9342                                  set_exerr_locus:
  9343 000012F8 36A2[2303]                      mov	[ss:EXTERR_LOCUS],al
  9344 000012FC 58                              pop	ax
  9345 000012FD C3                              retn
  9346                                  
  9347                                  set_exerr_locus_disk:
  9348 000012FE 50                      	push	ax
  9349 000012FF B002                    	mov	al,2		; errLOC_Disk
  9350 00001301 EBF5                    	jmp	short set_exerr_locus
  9351                                  
  9352                                  set_exerr_locus_ser:
  9353 00001303 50                      	push	ax
  9354 00001304 B004                    	mov	al,4		; errLOC_SerDev
  9355 00001306 EBF0                    	jmp	short set_exerr_locus
  9356                                  
  9357                                  set_exerr_locus_mem:
  9358 00001308 50                      	push	ax
  9359 00001309 B005                    	mov	al,5		; errLOC_Mem
  9360 0000130B EBEB                    	jmp	short set_exerr_locus
  9361                                  
  9362                                  ; ---------------------------------------------------------------------------
  9363                                  
  9364                                  ;============================================================================
  9365                                  ; MISC.ASM, MSDOS 6.0, 1991
  9366                                  ;============================================================================
  9367                                  ; 19/07/2018 - Retro DOS v3.0
  9368                                  
  9369                                  ; 29/04/2019 - Retro DOS v4.0
  9370                                  
  9371                                  ;ENTRYPOINTSEG	EQU	0CH
  9372                                  ;MAXDIF		EQU	0FFFH
  9373                                  ;SAVEXIT 	EQU	10
  9374                                  ;WRAPOFFSET	EQU	0FEF0h
  9375                                  
  9376                                  ;
  9377                                  ;----------------------------------------------------------------------------
  9378                                  ;
  9379                                  ;**	$SLEAZEFUNC - Get a Pointer to the Media Byte
  9380                                  ;
  9381                                  ;	Return Stuff sort of like old get fat call
  9382                                  ;
  9383                                  ;	ENTRY	none
  9384                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  9385                                  ;			GOD help anyone who tries to do ANYTHING except
  9386                                  ;			READ this ONE byte.
  9387                                  ;		DX = Total Number of allocation units on disk
  9388                                  ;		CX = Sector size
  9389                                  ;		AL = Sectors per allocation unit
  9390                                  ;		   = -1 if bad drive specified
  9391                                  ;	USES	all
  9392                                  ;
  9393                                  ;**	$SLEAZEFUNCDL - Get a Pointer to the Media Byte
  9394                                  ;
  9395                                  ;	Identical to $SLEAZEFUNC except (dl) = drive
  9396                                  ;
  9397                                  ;	ENTRY	(dl) = drive (0=default, 1=A, 2=B, etc.)
  9398                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  9399                                  ;			GOD help anyone who tries to do ANYTHING except
  9400                                  ;			READ this ONE byte.
  9401                                  ;		DX = Total Number of allocation units on disk
  9402                                  ;		CX = Sector size
  9403                                  ;		AL = Sectors per allocation unit
  9404                                  ;		   = -1 if bad drive specified
  9405                                  ;	USES	all
  9406                                  ;
  9407                                  ;----------------------------------------------------------------------------
  9408                                  ;
  9409                                  	; 10/01/2024 - Retro DOS v5.0
  9410                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:51E2h
  9411                                  
  9412                                  _$SLEAZEFUNC:
  9413                                  	; 15/05/2019 - Retro DOS v4.0
  9414 0000130D B200                    	MOV	DL,0
  9415                                  _$SLEAZEFUNCDL:
  9416 0000130F 16                      	push	ss
  9417 00001310 1F                      	pop	ds
  9418                                  	
  9419 00001311 88D0                    	MOV	AL,DL
  9420 00001313 E86F61                  	call	GETTHISDRV		; Get CDS structure
  9421                                  SET_AL_RET:
  9422                                  	; MSDOS 3.3
  9423                                  	;;mov	al, 0Fh
  9424                                  	;MOV	AL,error_invalid_drive	; Assume error	;AC000;
  9425                                  	
  9426                                  	; MSDOS 6.0 & MSDOS 3.3
  9427 00001316 7229                    	JC	short BADSLDRIVE
  9428                                  
  9429 00001318 E86D20                  	call	DISK_INFO
  9430                                  	;JC	short SET_AL_RET	; User FAILed to I 24
  9431 0000131B 7224                    	jc	short BADSLDRIVE
  9432 0000131D 8826[9805]              	MOV	[FATBYTE],AH	; FAT (MEDIA) ID byte
  9433                                  
  9434                                  	; 10/01/2024 - Retro DOS v5.0 (PCDOS 7.1)
  9435                                  	;;;
  9436 00001321 30E4                    	xor     ah, ah		; AH = 0
  9437                                  				; AL = sectors per cluster
  9438 00001323 57                      	push    di		; di:bx = number of clusters
  9439 00001324 E81A05                  	call    TestNet
  9440 00001327 5F                      	pop     di
  9441 00001328 7205                    	jc      short sleazefunc1
  9442 0000132A 51                      	push    cx		; bytes per sector
  9443 0000132B E85E21                  	call    modify_cluster_count
  9444 0000132E 59                      	pop     cx		; ax = sectors per cluster (modified)
  9445                                  				; dx = number of clusters (modified)
  9446                                  				; if bytes per cluster > 16384
  9447                                  				;    and hw of cluster count > 0
  9448                                  				;    bx = 0FFFEh (invalidated parm sign)
  9449                                  sleazefunc1:
  9450                                  	;;;
  9451                                  
  9452                                  ; NOTE THAT A FIXED MEMORY CELL IS USED --> THIS CALL IS NOT
  9453                                  ; RE-ENTRANT. USERS BETTER GET THE ID BYTE BEFORE THEY MAKE THE
  9454                                  ; CALL AGAIN
  9455                                  
  9456                                  	;MOV	DI,FATBYTE
  9457                                  	; 10/01/2024 
  9458                                  	;XOR	AH,AH			; AL has sectors/cluster
  9459 0000132F E845F1                  	call	Get_User_Stack
  9460                                  	;mov	[si+4],cx
  9461                                  	;mov	[si+6],bx
  9462                                  	;mov	[si+2],di
  9463 00001332 894C04                  	MOV	[SI+user_env.user_CX],CX
  9464 00001335 895C06                  	MOV	[SI+user_env.user_DX],BX
  9465                                  	;MOV	[SI+user_env.user_BX],DI
  9466                                  	; 10/01/2024
  9467 00001338 C74402[9805]            	MOV	word [SI+user_env.user_BX],FATBYTE
  9468                                  	
  9469                                  	;mov	[si+0Eh],ss
  9470 0000133D 8C540E                  	MOV     [SI+user_env.user_DS],SS ; stash correct pointer
  9471                                  
  9472 00001340 C3                      	retn
  9473                                  
  9474                                  BADSLDRIVE:
  9475 00001341 E94BF3                  	jmp	FCB_RET_ERR
  9476                                  
  9477                                  ;
  9478                                  ;----------------------------------------------------------------------------
  9479                                  ;
  9480                                  ;**	$Get_INDOS_Flag - Return location of DOS Critical Section Flag
  9481                                  ;
  9482                                  ;	Returns location of DOS status for interrupt routines
  9483                                  ;
  9484                                  ;	ENTRY	none
  9485                                  ;	EXIT	(es:bx) = flag location
  9486                                  ;	USES	all
  9487                                  ;
  9488                                  ;----------------------------------------------------------------------------
  9489                                  ;
  9490                                  
  9491                                  _$GET_INDOS_FLAG:
  9492 00001344 E830F1                  	CALL	Get_User_Stack
  9493                                  	;MOV	WORD [SI+2],INDOS
  9494 00001347 C74402[2103]            	MOV	word [SI+user_env.user_BX],INDOS
  9495                                  getin_segm:	; 13/01/2024
  9496                                  	;MOV	[SI+10H],SS
  9497 0000134C 8C5410                  	MOV	[SI+user_env.user_ES],SS
  9498 0000134F C3                      	RETN 
  9499                                  
  9500                                  ;
  9501                                  ;----------------------------------------------------------------------------
  9502                                  ;
  9503                                  ;**	$Get_IN_Vars - Return Pointer to DOS Variables
  9504                                  ;
  9505                                  ;	Return a pointer to interesting DOS variables This call is version
  9506                                  ;	dependent and is subject to change without notice in future versions.
  9507                                  ;	Use at risk.
  9508                                  ;
  9509                                  ;	ENTRY	none
  9510                                  ;	EXIT	(es:bx) = address of SYSINITVAR
  9511                                  ;	uses	ALL
  9512                                  ;
  9513                                  ;----------------------------------------------------------------------------
  9514                                  ;
  9515                                  
  9516                                  	; 13/01/2024 - Retro DOS v5.0
  9517                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:5226h
  9518                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:4D65h
  9519                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:4D58h
  9520                                  
  9521                                  _$GET_IN_VARS:
  9522 00001350 E824F1                  	CALL	Get_User_Stack
  9523                                  	;MOV	WORD [SI+2],SYSINITVAR
  9524                                  	;MOV	word [SI+user_env.user_BX],SYSINITVAR
  9525 00001353 C74402[2600]            	MOV	word [SI+user_env.user_BX],SYSINITVARS
  9526                                  	; 13/01/2024
  9527                                  	;;MOV	[SI+10H],SS
  9528                                  	;MOV	[SI+user_env.user_ES],SS
  9529                                  	;RETN
  9530 00001358 EBF2                    	jmp	short getin_segm
  9531                                  ;
  9532                                  ;----------------------------------------------------------------------------
  9533                                  ;
  9534                                  ;**	$Get_Default_DPB - Return a pointer to the Default DPB
  9535                                  ;
  9536                                  ;	Return pointer to drive parameter table for default drive
  9537                                  ;
  9538                                  ;	ENTRY	none
  9539                                  ;	EXIT	(ds:bx) = DPB address
  9540                                  ;	USES	all
  9541                                  ;
  9542                                  ;**	$Get_DPB - Return a pointer to a specified DPB
  9543                                  ;
  9544                                  ;	Return pointer to a specified drive parameter table
  9545                                  ;
  9546                                  ;	ENTRY	(dl) = drive # (0 = default, 1=A, 2=B, etc.)
  9547                                  ;	EXIT	(al) = 0 iff ok
  9548                                  ;		  (ds:bx) = DPB address
  9549                                  ;		(al) = -1 if bad drive
  9550                                  ;	USES	all
  9551                                  ;
  9552                                  ;----------------------------------------------------------------------------
  9553                                  ;
  9554                                  
  9555                                  ; 10/01/2024
  9556                                  %if 0
  9557                                  
  9558                                  ; 15/05/2019 - Retro DOS v4.0
  9559                                  
  9560                                  _$GET_DEFAULT_DPB:
  9561                                  	MOV	DL,0
  9562                                  _$GET_DPB:
  9563                                  	push	ss
  9564                                  	pop	ds
  9565                                  
  9566                                  	MOV	AL,DL
  9567                                  	call	GETTHISDRV		; Get CDS structure
  9568                                  	JC	short ISNODRV 		; no valid drive
  9569                                  	LES	DI,[THISCDS]		; check for net CDS
  9570                                  	;;test	word [es:di+43h],8000h
  9571                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
  9572                                  	;test	byte [es:di+44h],80h
  9573                                  	test	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
  9574                                  	JNZ	short ISNODRV 		; No DPB to point at on NET stuff
  9575                                  	call	ECritDisk
  9576                                  	call	FATREAD_CDS		; Force Media Check and return DPB
  9577                                  	call	LCritDisk
  9578                                  	JC	short ISNODRV 		; User FAILed to I 24, only error we
  9579                                  					;   have.
  9580                                  	call	Get_User_Stack
  9581                                  	;mov	[si+2],bp
  9582                                  	MOV	[SI+user_env.user_BX],BP
  9583                                  	;mov	[si+0Eh],es
  9584                                  	MOV	[SI+user_env.user_DS],ES
  9585                                  	XOR	AL,AL
  9586                                  	retn
  9587                                  ISNODRV:
  9588                                  	MOV	AL,-1
  9589                                  	retn
  9590                                  
  9591                                  %else
  9592                                  
  9593                                  ; 13/01/2024
  9594                                  ; 10/01/2024 - Retro DOS v5.0
  9595                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:5230h
  9596                                  
  9597                                  _$GET_DEFAULT_DPB:
  9598 0000135A B200                    	MOV	DL,0
  9599                                  _$GET_DPB:
  9600 0000135C 16                      	push	ss
  9601 0000135D 1F                      	pop	ds
  9602                                  
  9603 0000135E 88D0                    	MOV	AL,DL
  9604 00001360 E82261                  	call	GETTHISDRV		; Get CDS structure
  9605 00001363 B00F                    	mov	al,0Fh			; error_invalid_drive
  9606 00001365 7315                    	jnc	short getdpb_3		
  9607                                  
  9608                                  	; no valid drive
  9609                                  getdpb_1:
  9610                                  	; 13/01/2024
  9611 00001367 E80DF1                  	call	Get_User_Stack
  9612 0000136A 813C0273                	cmp	word [si],7302h		; INT 21h, AX = 7302h ? Get_ExtDPB
  9613                                  					; GET EXTENDED DPB
  9614 0000136E 7406                    	je      short getdpb_2
  9615 00001370 813C0473                	cmp	word [si],7304h		; INT 21h, AX = 7304h ? Set_DPBforFormat
  9616                                  					; Set DPB TO USE FOR FORMATTING
  9617 00001374 7503                    	jne	short ISNODRV
  9618                                  getdpb_2:
  9619 00001376 E901F3                  	jmp     SYS_RET_ERR
  9620                                  
  9621                                  ISNODRV:
  9622 00001379 B0FF                    	mov	al,0FFh	; -1		; invalid (or network) drive
  9623 0000137B C3                      	retn
  9624                                  
  9625                                  getdpb_3:
  9626 0000137C C43E[A205]              	LES	DI,[THISCDS]		; check for net CDS
  9627                                  	;;test	word [es:di+43h],8000h
  9628                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
  9629                                  	;test	byte [es:di+44h],80h
  9630 00001380 26F6454480              	test	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
  9631                                  	;JNZ	short ISNODRV 		; No DPB to point at on NET stuff
  9632                                  	; 10/01/2024
  9633 00001385 75E0                    	jnz	short getdpb_1
  9634 00001387 E87905                  	call	ECritDisk
  9635 0000138A E8FC4C                  	call	FATREAD_CDS		; Force Media Check and return DPB
  9636 0000138D E8A005                  	call	LCritDisk
  9637                                  	;JC	short ISNODRV 		; User FAILed to I 24,
  9638 00001390 B053                    	mov	al,53h ; error_FAIL_I24 ;  only error we have.
  9639 00001392 72D3                    	jc	short getdpb_1
  9640 00001394 E8E0F0                  	call	Get_User_Stack
  9641                                  	; 13/01/2024
  9642 00001397 813C0473                	cmp	word [si],7304h		; INT 21h, AX = 7304h ?
  9643 0000139B 7503                    	jnz	short getdpb_4
  9644 0000139D E9E8FD                  	jmp	Set_DPBforFormat
  9645                                  
  9646                                  	; 13/01/2024
  9647                                  getdpb_4:
  9648 000013A0 813C0273                	cmp	word [si],7302h		; INT 21h, AX = 7302h ?
  9649 000013A4 7410                    	je	short getdpb_5
  9650 000013A6 26837E0F00              	cmp	word [es:bp+0Fh],0
  9651 000013AB 74BA                    	jz	short getdpb_1
  9652 000013AD 896C02                  	mov	[si+2],bp
  9653 000013B0 8C440E                  	mov	[si+0Eh],es
  9654 000013B3 30C0                    	xor	al,al			; status = 0 = successful
  9655 000013B5 C3                      	retn
  9656                                  
  9657                                  getdpb_5:
  9658 000013B6 B018                    	mov	al,18h			; error_bad_length
  9659 000013B8 837C043F                	cmp	word [si+4],63		; [SI+user_env.user_CX]
  9660                                  					; length of buffer (must be 63 bytes)
  9661 000013BC 72B8                    	jb	short getdpb_2		; error
  9662                                  
  9663 000013BE 06                      	push	es			; ES:BP = Drive parameter block
  9664 000013BF 55                      	push	bp
  9665 000013C0 8E4410                  	mov	es,[si+16]		; [SI+user_env.user_ES]
  9666 000013C3 8B7C0A                  	mov	di,[si+10]		; [SI+user_env.user_DI]
  9667 000013C6 8B5C08                  	mov	bx,[si+8]		; [SI+user_env.user_SI] (!)
  9668 000013C9 5E                      	pop	si
  9669 000013CA 1F                      	pop	ds
  9670                                  
  9671 000013CB B83D00                  	mov	ax,61			; length of following data (003Dh)
  9672 000013CE AB                      	stosw
  9673 000013CF 89C1                    	mov	cx,ax
  9674 000013D1 57                      	push	di
  9675 000013D2 F3A4                    	rep movsb
  9676 000013D4 5F                      	pop	di
  9677                                  	
  9678                                  	; 13/01/2024
  9679 000013D5 06                      	push	es
  9680 000013D6 1F                      	pop	ds
  9681 000013D7 31C0                    	xor	ax,ax ; 0
  9682                                  
  9683 000013D9 81FBA6F1                	cmp	bx,0F1A6h		; (!) signature (undocumented),
  9684                                  					;  must be 0F1A6h to get device driver
  9685                                  					;  address and next-DBP pointer
  9686                                  					; (Ref: Ralf Brown's Interrupt List)
  9687 000013DD 740E                    	je	short getdpb_6
  9688                                  	
  9689                                  	;xor	ax,ax	; 0
  9690 000013DF 48                      	dec	ax 	; -1
  9691                                  	;mov	[es:di+19h],ax		; pointer to next DPB (invalidated)
  9692                                  	;mov	[es:di+1Bh],ax
  9693                                  	;mov	[es:di+13h],ax		; pointer to driver address (invalidated)
  9694                                  	;mov	[es:di+15h],ax
  9695                                  	; 13/01/2024
  9696 000013E0 894519                  	mov	[di+19h],ax ; -1	; pointer to next DPB (invalidated)
  9697 000013E3 89451B                  	mov	[di+1Bh],ax
  9698 000013E6 894513                  	mov	[di+13h],ax		; pointer to driver address (invalidated)
  9699 000013E9 894515                  	mov	[di+15h],ax	
  9700                                  
  9701                                  	; 13/01/2024
  9702 000013EC 40                      	inc	ax ; 0
  9703                                  getdpb_6:
  9704                                  	; 13/01/2024
  9705                                  	; ax = 0
  9706 000013ED 39450F                  	cmp	[di+0Fh],ax ; 0
  9707                                  	;cmp	[es:di+0Fh],ax ; 0	; FAT (16 bit) size ?
  9708                                  	;;cmp	word [es:di+0Fh],0
  9709 000013F0 743F                    	jz	short getdpb_8		; FAT32
  9710                                  			  ; FAT16 or FAT12
  9711                                  	;mov	ax,[es:di+0Dh]		; DPB.MAX_CLUSTER
  9712                                  	;mov	[es:di+2Dh],ax		; DPB.LAST_CLUSTER
  9713                                  	;mov	ax,[es:di+0Fh]		; DPB.FAT_SIZE
  9714                                  	;mov	[es:di+31h],ax		; DPB.FAT32_SIZE
  9715                                  	;mov	ax,[es:di+1Dh]		; DPB.NEXT_FREE
  9716                                  	;mov	[es:di+39h],ax		; DPB.FAT32_NXTFREE
  9717                                  	;mov	ax,[es:di+0Bh]		; DPB.FIRST_SECTOR
  9718                                  	;mov	[es:di+29h],ax		; DPB.FCLUS_FSECTOR
  9719                                  	; 13/01/2024
  9720 000013F2 8B450D                  	mov	ax,[di+0Dh]		; DPB.MAX_CLUSTER
  9721 000013F5 89452D                  	mov	[di+2Dh],ax		; DPB.LAST_CLUSTER
  9722 000013F8 8B450F                  	mov	ax,[di+0Fh]		; DPB.FAT_SIZE
  9723 000013FB 894531                  	mov	[di+31h],ax		; DPB.FAT32_SIZE
  9724 000013FE 8B451D                  	mov	ax,[di+1Dh]		; DPB.NEXT_FREE
  9725 00001401 894539                  	mov	[di+39h],ax		; DPB.FAT32_NXTFREE
  9726 00001404 8B450B                  	mov	ax,[di+0Bh]		; DPB.FIRST_SECTOR
  9727 00001407 894529                  	mov	[di+29h],ax		; DPB.FCLUS_FSECTOR	
  9728                                  
  9729 0000140A 31C0                    	xor	ax,ax	; 0
  9730                                  	;mov	[es:di+2Fh],ax		; DPB.LAST_CLUSTER high word
  9731                                  	;mov	[es:di+33h],ax		; DPB.FAT32_SIZE high word
  9732                                  	;mov	[es:di+3Bh],ax		; DPB.FAT32_NXTFREE high word
  9733                                  	;mov	[es:di+2Bh],ax		; DPB.FCLUS_FSECTOR high word
  9734                                  	;mov	[es:di+35h],ax		; DPB.ROOT_CLUSTER
  9735                                  	;mov	[es:di+37h],ax		; DPB.ROOT_CLUSTER high word
  9736                                  	;mov	[es:di+23h],ax		; DPB.EXT_FLAGS
  9737                                  	; 13/01/2024
  9738 0000140C 89452F                  	mov	[di+2Fh],ax ; 0		; DPB.LAST_CLUSTER high word
  9739 0000140F 894533                  	mov	[di+33h],ax		; DPB.FAT32_SIZE high word
  9740 00001412 89453B                  	mov	[di+3Bh],ax		; DPB.FAT32_NXTFREE high word
  9741 00001415 89452B                  	mov	[di+2Bh],ax		; DPB.FCLUS_FSECTOR high word
  9742 00001418 894535                  	mov	[di+35h],ax		; DPB.ROOT_CLUSTER
  9743 0000141B 894537                  	mov	[di+37h],ax		; DPB.ROOT_CLUSTER high word
  9744 0000141E 894523                  	mov	[di+23h],ax		; DPB.EXT_FLAGS
  9745 00001421 48                      	dec	ax	; -1
  9746                                  	;mov	[es:di+25h],ax		; DPB.FSINFO_SECTOR (invalidated)
  9747                                  	;mov	[es:di+27h],ax		; DPB.BKBOOT_SECTOR (invalidated)
  9748                                  	; 13/01/2024
  9749 00001422 894525                  	mov	[di+25h],ax		; DPB.FSINFO_SECTOR (invalidated)
  9750 00001425 894527                  	mov	[di+27h],ax		; DPB.BKBOOT_SECTOR (invalidated)
  9751 00001428 3B451F                  	cmp	ax,[di+1Fh]
  9752                                  	;cmp	ax,[es:di+1Fh]		; DPB.FREE_COUNT (= -1 ?)
  9753 0000142B 7401                    	je	short getdpb_7
  9754 0000142D 40                      	inc	ax	; -1 -> 0
  9755                                  getdpb_7:
  9756 0000142E 894521                  	mov	[di+21h],ax
  9757                                  	;mov	[es:di+21h],ax		; DPB.PB.FREE_COUNT high word
  9758                                  getdpb_8:
  9759                                  	;xor	ax,ax			; status = 0 = successful
  9760 00001431 E93CF2                  	jmp	SYS_RET_OK
  9761                                  
  9762                                  %endif
  9763                                  
  9764                                  ;
  9765                                  ;----------------------------------------------------------------------------
  9766                                  ;
  9767                                  ;**	$Disk_Reset - Flush out Dirty Buffers
  9768                                  ;
  9769                                  ;	$DiskReset flushes and invalidates all buffers. BUGBUG - do
  9770                                  ;		we really invalidate? SHould we? THis screws non-removable
  9771                                  ;		caching. Maybe CHKDSK relies upon it, though....
  9772                                  ;
  9773                                  ;	ENTRY	none
  9774                                  ;	EXIT	none
  9775                                  ;	USES	all
  9776                                  ;
  9777                                  ;----------------------------------------------------------------------------
  9778                                  ;
  9779                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  9780                                  	; DOSCODE:4D94h
  9781                                  	; 13/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  9782                                  	; DOSCODE:5322h
  9783                                  _$DISK_RESET:
  9784                                  	; 15/05/2019 - Retro DOS v4.0
  9785 00001434 B0FF                    	mov	al,0FFh	; -1
  9786 00001436 16                      	push	ss
  9787 00001437 1F                      	pop	ds
  9788                                  	; 06/11/2022
  9789                                  	;MOV	AL,-1
  9790 00001438 E8C804                  	call	ECritDisk
  9791                                  	; MSDOS 6.0
  9792                                  	;;or	word [DOS34_FLAG],4
  9793                                  	;or	word [DOS34_FLAG],FROM_DISK_RESET    ;AN000;
  9794 0000143B 800E[1106]04            	or	byte [DOS34_FLAG],FROM_DISK_RESET ; 4 ; 15/05/2019
  9795 00001440 E8EC4F                  	call	FLUSHBUF
  9796                                  	; MSDOS 6.0
  9797                                  	;and	word [DOS34_FLAG],0FFFBh
  9798                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9799                                  	;and	word [DOS34_FLAG],NO_FROM_DISK_RESET ;AN000;
  9800                                  	; 15/12/2022
  9801 00001443 8026[1106]FB            	and	byte [DOS34_FLAG],NO_FROM_DISK_RESET ; 0FBh ; 15/05/2019
  9802                                  
  9803                                  	; 13/01/2024 - Retro DOS v5.0
  9804                                  	; (PCDOS 7.1 IBMDOS.COM)
  9805                                  	;;;
  9806 00001448 C42E[2600]              	les     bp,[DPBHEAD]
  9807                                  drst_1:
  9808 0000144C 83FDFF                  	cmp	bp,0FFFFh	; -1 ?
  9809 0000144F 7409                    	je	short drst_2	; yes, it is the last DPB
  9810 00001451 E83D20                  	call	update_fat32_fsinfo ; update FSINFO (sector) parameters 
  9811 00001454 26C46E19                	les	bp,[es:bp+19h]	; DPB.NEXT_DPB
  9812 00001458 EBF2                    	jmp	short drst_1
  9813                                  drst_2:
  9814                                  	;;;
  9815                                  
  9816 0000145A C706[050E]0000          	mov	word [SC_STATUS],0	; Throw out secondary cache ; M041
  9817                                  ;
  9818                                  ; We will "ignore" any errors on the flush, and go ahead and invalidate. This
  9819                                  ; call doesn't return any errors and it is supposed to FORCE a known state, so
  9820                                  ; let's do it.
  9821                                  ;
  9822                                  ; Invalidate 'last-buffer' used
  9823                                  ;
  9824 00001460 BBFFFF                  	MOV	BX,-1 ; 0FFFFh	
  9825 00001463 891E[2000]              	MOV	[LastBuffer+2],BX
  9826 00001467 891E[1E00]              	MOV	[LastBuffer],BX
  9827                                  
  9828                                  	; MSDOS 3.3 
  9829                                  	; IBMDOS.COM, Offset 1C66h
  9830                                  	;;;;
  9831                                  	;lds	si,[BUFFHEAD]
  9832                                  	;mov	ax,20FFh	; .buf_ID,    AL = FFh (Free buffer)
  9833                                  				; .buf_flags, AH = 0, reset/clear
  9834                                  ;DRST_1:
  9835                                  	;;mov	[si+4],ax
  9836                                  	;mov	[si+BUFFINFO.buf_ID],ax
  9837                                  	;lds	si,[SI]
  9838                                  	;cmp	si,bx ; -1
  9839                                  	;je	short DRST_2
  9840                                  	;;mov	[si+4],ax
  9841                                  	;mov	[si+BUFFINFO.buf_ID],ax
  9842                                  	;lds	si,[SI]
  9843                                  	;cmp	si,bx
  9844                                  	;jne	short DRST_1
  9845                                  	;;;;
  9846                                  ;DRST_2:
  9847 0000146B E8C204                  	call	LCritDisk
  9848 0000146E B8FFFF                  	MOV	AX,-1
  9849                                  	; 07/12/2022
  9850                                  	;mov	ax,0FFFFh
  9851                                  	;CallInstall NetFlushBuf,MultNET,32,AX,AX
  9852 00001471 50                      	push	ax ; * MSDOS 6.0 ; 15/05/2019
  9853 00001472 B82011                  	mov     ax,1120h
  9854 00001475 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
  9855                                  			; DS = DOS CS
  9856                                  			; Return: CF clear (successful)
  9857 00001477 58                      	pop	ax ; * MSDOS 6.0 ; 15/05/2019
  9858                                  	
  9859 00001478 C3                      	retn
  9860                                  
  9861                                  	; 19/07/2018 - Retro DOS v3.0
  9862                                  
  9863                                  ;
  9864                                  ;	BREAK <$SetDPB - Create a valid DPB from a user-specified BPB>
  9865                                  ;
  9866                                  ;----------------------------------------------------------------------------
  9867                                  ;
  9868                                  ;**	$SetDPB - Create a DPB
  9869                                  ;
  9870                                  ;	SetDPB Creates a valid DPB from a user-specified BPB
  9871                                  ;
  9872                                  ;	ENTRY	ES:BP Points to DPB
  9873                                  ;		DS:SI Points to BPB
  9874                                  ;	EXIT	DPB setup
  9875                                  ;	USES	ALL but BP, DS, ES
  9876                                  ;
  9877                                  ;----------------------------------------------------------------------------
  9878                                  ;
  9879                                  
  9880                                  ; 10/05/2019 - Retro DOS v4.0
  9881                                  
  9882                                  ; DOSCODE:4DD6h (MSDOS 6.21, MSDOS.SYS)
  9883                                  
  9884                                  ; MSDOS 6.0
  9885 00001479 0300                    word3:	dw	3			; M008 -- word value for divides
  9886                                  
  9887                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0)
  9888                                  ; DOSCODE:4DC9h (MSDOS 5.0, MSDOS.SYS)
  9889                                  
  9890                                  ; 13/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1)
  9891                                  ; DOSCODE:5369h (PCDOS 7.1, IBMDOS.COM)
  9892                                  
  9893                                  ; 13/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1)
  9894                                  ; Windows ME IO.SYS (Extracted) - BIOSCODE:4EF8h 
  9895                                  
  9896                                  ;procedure   $SETDPB,NEAR
  9897                                  
  9898                                  _$SETDPB:
  9899 0000147B 89EF                    	MOV	DI,BP
  9900                                  	;ADD	DI,2			; Skip over dpb_drive and dpb_UNIT
  9901                                  	; 13/01/2024
  9902 0000147D 47                      	inc	di
  9903 0000147E 47                      	inc	di
  9904 0000147F AD                      	LODSW
  9905 00001480 AB                      	STOSW				; dpb_sector_size
  9906                                  
  9907                                  	; 13/01/2024
  9908                                  	; Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  9909                                  	;;;
  9910 00001481 81F95845                	cmp	cx,4558h	; 'XE' (NASM syntax)
  9911                                  				; CX = signature 4558h ('EX') for FAT32 extended BPB/DPB
  9912 00001485 7506                    	jne	short not_fat32_extension
  9913 00001487 81FA5241                	cmp	dx,4152h	; 'RA' (NASM syntax)
  9914                                  				; DX = signature 4152h ('AR') for FAT32 extended BPB/DPB
  9915 0000148B 7402                    	je	short chk_fat32_conditions
  9916                                  not_fat32_extension:                    ; ...
  9917 0000148D 31C9                    	xor	cx,cx	; 0	; (Do not use FAT32 extensions -32 bit parameters-)
  9918                                  chk_fat32_conditions:  
  9919 0000148F 51                      	push	cx	; (*)
  9920                                  	;;;
  9921                                  	
  9922                                  	; 13/01/2024
  9923                                  	; MSDOS 6.0
  9924                                  	;cmp	byte [si+3],0
  9925                                  	;CMP	BYTE [SI+A_BPB.BPB_NUMBEROFFATS-2],0
  9926 00001490 807C0300                	cmp	byte [SI+A_BPB.NUMBEROFFATS-2],0 ; FAT file system drive ;AN000;
  9927                                  	;JNZ	short yesfat			 ; yes			 ;AN000;
  9928 00001494 740C                    	jz	short nofat ; 13/01/2024 (PCDOS 7.1)
  9929                                  
  9930                                  	; 13/01/2024 - Retro DOS v5.0
  9931                                  	;;;
  9932                                  	;cmp	word [si+9],0	; .BPB_SECTORSPERFAT ; BPB_FATSz16
  9933 00001496 837C0900                	cmp	word [si+A_BPB.SECTORSPERFAT-2],0
  9934 0000149A 7516                    	jnz	short yesfat
  9935                                  	;cmp	word [si+29],0	; .BPB_FAT32VERSION ; BPB_FSVer
  9936 0000149C 837C1D00                	cmp	word [si+A_BPB.FSVER-2],0
  9937 000014A0 7410                    	jz	short yesfat
  9938                                  nofat:             
  9939                                  	;;;
  9940                                  
  9941                                  	; 13/01/2024
  9942                                  	;;mov	byte [es:di+4],0
  9943                                  	;MOV	BYTE [ES:DI+DPB.FAT_COUNT-4],0
  9944                                  	;JMP	short setend			; NO		;AN000;
  9945                                  
  9946                                  	; 13/01/2024 (WINME IO.SYS)
  9947                                  	;mov	byte [es:di+4],0 ; DPB.FAT_COUNT
  9948                                  	;xor	eax,eax
  9949                                  	;jmp	setend
  9950                                  
  9951                                  	; 13/01/2024 (PCDOS7.1 IBMDOS.COM)
  9952 000014A2 31C0                    	xor	ax,ax ; 0
  9953 000014A4 26884504                	mov	[es:di+DPB.FAT_COUNT-4],al ; DPB.FAT_COUNT = 0
  9954                                  
  9955                                  	; 13/01/2024 (not necessary) 
  9956                                  	;add	di,15	; DPB.DRIVER_ADDR
  9957                                  
  9958 000014A8 83C60B                  	add	si,11	; .BPB_SECTORSPERTRACK
  9959                                  
  9960                                  	;mov	[es:bp+15],ax	; DPB.FAT_SIZE = 0
  9961 000014AB 2689460F                	mov	[es:bp+DPB.FAT_SIZE],ax
  9962                                  
  9963 000014AF E9B500                  	jmp	setend
  9964                                  
  9965                                  yesfat: ; 10/08/2018
  9966 000014B2 89C2                    	MOV	DX,AX
  9967 000014B4 AC                      	LODSB
  9968                                  	;;;
  9969                                  	; 13/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  9970 000014B5 08C0                    	or	al,al
  9971 000014B7 74E9                    	jz	short nofat
  9972                                  	;;;
  9973                                  	;DEC	AL
  9974                                  	; 17/12/2022
  9975 000014B9 48                      	dec	ax
  9976 000014BA AA                      	STOSB				; dpb_cluster_mask
  9977                                  	;INC	AL
  9978 000014BB 40                      	inc	ax
  9979 000014BC 30E4                    	XOR	AH,AH
  9980                                  LOG2LOOP:
  9981 000014BE A801                    	test	AL,1
  9982 000014C0 7506                    	JNZ	short SAVLOG
  9983 000014C2 FEC4                    	INC	AH
  9984 000014C4 D0E8                    	SHR	AL,1
  9985 000014C6 EBF6                    	JMP	SHORT LOG2LOOP
  9986                                  SAVLOG:
  9987 000014C8 88E0                    	MOV	AL,AH
  9988 000014CA AA                      	STOSB				; dpb_cluster_shift
  9989 000014CB 88C3                    	MOV	BL,AL
  9990 000014CD A5                      	MOVSW				; dpb_first_FAT Start of FAT (# of reserved sectors)
  9991 000014CE AC                      	LODSB
  9992 000014CF AA                      	STOSB				; dpb_FAT_count Number of FATs
  9993                                  ;	OR	AL,AL			; NONFAT ?				;AN000;
  9994                                  ;	JZ	short setend		; yes, don't do anything                ;AN000;
  9995 000014D0 88C7                    	MOV	BH,AL
  9996 000014D2 AD                      	LODSW
  9997 000014D3 AB                      	STOSW				; dpb_root_entries Number of directory entries
  9998 000014D4 B105                    	MOV	CL,5
  9999 000014D6 D3EA                    	SHR	DX,CL			; Directory entries per sector
 10000 000014D8 48                      	DEC	AX
 10001 000014D9 01D0                    	ADD	AX,DX			; Cause Round Up
 10002 000014DB 89D1                    	MOV	CX,DX
 10003 000014DD 31D2                    	XOR	DX,DX
 10004 000014DF F7F1                    	DIV	CX
 10005 000014E1 89C1                    	MOV	CX,AX			; Number of (root) directory sectors
 10006 000014E3 47                      	INC	DI
 10007 000014E4 47                      	INC	DI			; Skip dpb_first_sector
 10008 000014E5 A5                      	MOVSW			; Total number of sectors in DSKSIZ (temp as dpb_max_cluster)
 10009 000014E6 AC                      	LODSB
 10010                                  	;mov	[es:bp+17h],al
 10011 000014E7 26884617                	MOV	[ES:BP+DPB.MEDIA],AL	; Media byte
 10012 000014EB AD                      	LODSW				; Number of sectors in a FAT
 10013                                  	
 10014                                  	;;;
 10015                                  	;MSDOS 3.3
 10016                                  	;
 10017                                  	;STOSB		; DPB.FAT_SIZE
 10018                                  	;MUL	BH
 10019                                  	
 10020                                  	;MSDOS 6.0
 10021                                  	;
 10022 000014EC AB                      	STOSW		; DPB.FAT_SIZE	;AC000;;>32mb dpb_FAT_size
 10023                                  
 10024                                  ; 13/01/2024
 10025                                  %if 0
 10026                                  	MOV	DL,BH			;AN000;;>32mb
 10027                                  	XOR	DH,DH			;AN000;;>32mb
 10028                                  	MUL	DX			;AC000;;>32mb Space occupied by all FATs
 10029                                  	;;;
 10030                                  	
 10031                                  	;add	ax,[es:bp+6]
 10032                                  	ADD	AX,[ES:BP+DPB.FIRST_FAT]
 10033                                  	STOSW				; dpb_dir_sector
 10034                                  	ADD	AX,CX			; Add number of (root) directory sectors
 10035                                  	;mov	[es:bp+0Bh],ax
 10036                                  	MOV	[ES:BP+DPB.FIRST_SECTOR],AX
 10037                                  	
 10038                                  	; MSDOS 6.0
 10039                                  	MOV	CL,BL			;F.C. >32mb				;AN000;
 10040                                  	;;cmp	word [es:bp+0Dh],0
 10041                                  	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
 10042                                  	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
 10043                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10044                                  	; 15/12/2022
 10045                                  	; 28/07/2019
 10046                                  	mov	bx,[ES:BP+DSKSIZ]
 10047                                  	or	bx,bx
 10048                                  	JNZ	short normal_dpb	;F.C. >32mb				;AN000;
 10049                                  	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
 10050                                  	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
 10051                                  	
 10052                                  
 10053                                  	XOR	CH,CH			;F.C. >32mb				;AN000;
 10054                                  	;mov	bx,[si+8]
 10055                                  	mov	bx,[si+A_BPB.BIGTOTALSECTORS-A_BPB.SECTORSPERTRACK] ; 01/01/2024 (temporary)
 10056                                  	;MOV	BX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK]	;AN000;
 10057                                  	;mov	dx,[si+10]
 10058                                  	mov	dx,[si+A_BPB.BIGTOTALSECTORS-A_BPB.SECTORSPERTRACK+2] ; 01/01/2024 (temporary)
 10059                                  	;MOV	DX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK+2]	;AN000;
 10060                                  	SUB	BX,AX			;AN000;;F.C. >32mb
 10061                                  	SBB	DX,0			;AN000;;F.C. >32mb
 10062                                  	OR	CX,CX			;AN000;;F.C. >32mb
 10063                                  	JZ	short norot		;AN000;;F.C. >32mb
 10064                                  rott:					;AN000;;F.C. >32mb
 10065                                  	CLC				;AN000;;F.C. >32mb
 10066                                  	RCR	DX,1			;AN000;;F.C. >32mb
 10067                                  	RCR	BX,1			;AN000;;F.C. >32mb
 10068                                  	LOOP	rott			;AN000;;F.C. >32mb
 10069                                  norot:					;AN000;
 10070                                  	; 15/12/2022
 10071                                  	;MOV	AX,BX			;AN000;;F.C. >32mb
 10072                                  	JMP	short setend		;AN000;;F.C. >32mb
 10073                                  normal_dpb:
 10074                                  	;;sub	ax,[es:bp+0Dh]
 10075                                  	;SUB	AX,[ES:BP+DSKSIZ]
 10076                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10077                                  	; 15/12/2022
 10078                                  	; bx = [es:bp+DSKSIZ]
 10079                                  	;sub	ax,bx ; 28/07/2019
 10080                                  	;;SUB	AX,[ES:BP+DSKSIZ]
 10081                                  	; 15/12/2022
 10082                                  	sub	bx,ax
 10083                                  	;NEG	AX			; Sectors in data area
 10084                                  ;;	MOV	CL,BL			; dpb_cluster_shift
 10085                                  	; 15/12/2022
 10086                                  	; CL = cluster shift
 10087                                  	; BX = number of data sectors 
 10088                                  	;SHR	AX,CL			; Div by sectors/cluster
 10089                                  	shr	bx,cl 
 10090                                  setend:
 10091                                  ;	M008 - CAS
 10092                                  ;
 10093                                  	; 15/12/2022
 10094                                  	inc	bx
 10095                                  	;INC	AX			; +2 (reserved), -1 (count -> max)
 10096                                  ;
 10097                                  ;	There has been a bug in our fatsize calculation for so long
 10098                                  ;	  that we can't correct it now without causing some user to
 10099                                  ;	  experience data loss. There are even cases where allowing
 10100                                  ;	  the number of clusters to exceed the fats is the optimal
 10101                                  ;	  case -- where adding 2 more fat sectors would make the
 10102                                  ;	  data field smaller so that there's nothing to use the extra
 10103                                  ;	  fat sectors for.
 10104                                  ;
 10105                                  ;	Note that this bug had very minor known symptoms. CHKDSK would
 10106                                  ;	  still report that there was a cluster left when the disk was
 10107                                  ;	  actually full. Very graceful failure for a corrupt system
 10108                                  ;	  configuration. There may be worse cases that were never
 10109                                  ;	  properly traced back to this bug. The problem cases only
 10110                                  ;	  occurred when partition sizes were very near FAT sector
 10111                                  ;	  rounding boundaries, which were rare cases.
 10112                                  ;
 10113                                  ;	Also, it's possible that some third-party partition program might
 10114                                  ;	  create a partition that had a less-than-perfect FAT calculation
 10115                                  ;	  scheme. In this hypothetical case, the number of allocation
 10116                                  ;	  clusters which don't actually have FAT entries to represent
 10117                                  ;	  them might be larger and might create a more catastrophic
 10118                                  ;	  failure. So we'll provide the safeguard of limiting the
 10119                                  ;	  max_cluster to the amount that will fit in the FATs.
 10120                                  ;
 10121                                  ;	ax = maximum legal cluster, ES:BP -> dpb
 10122                                  
 10123                                  ;	make sure the number of fat sectors is actually enough to
 10124                                  ;	  hold that many clusters. otherwise, back the number of
 10125                                  ;	  clusters down
 10126                                  
 10127                                  	; 15/12/2022
 10128                                  	; bx = number of clusters
 10129                                  
 10130                                  	; 19/07/2018 - Retro DOS v3.0
 10131                                  	; MSDOS 6.0
 10132                                  	; 15/12/2022
 10133                                  	;mov	bx,ax			; remember calculated # clusters
 10134                                  
 10135                                  	; 01/08/2018 (MSDOS 3.3)
 10136                                  	;mov	al,[ES:BP+DPB.FAT_SIZE]
 10137                                  	;xor	ah,ah 
 10138                                  
 10139                                  	; 10/05/2019 - Retro DOS v4.0
 10140                                  	;mov	ax,[ES:BP+0Fh]
 10141                                  	mov	ax,[ES:BP+DPB.FAT_SIZE]
 10142                                  
 10143                                  	;mul	word [es:bp+2]	
 10144                                  	mul	word [ES:BP+DPB.SECTOR_SIZE] ; how big is the FAT?
 10145                                  	cmp	bx,4096-10  ; 0FF6h	; test for 12 vs. 16 bit fat
 10146                                  	jb	short setend_fat12
 10147                                  	shr	dx,1
 10148                                  
 10149                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10150                                  	; 15/12/2022
 10151                                  ;cs3 7/2/92
 10152                                  	jnz	short setend_faterr	; some bonehead gave us more fatspace
 10153                                  					; than enough for the maximum FAT,
 10154                                  					; so go ahead and use the calculated
 10155                                  					; number of clusters.
 10156                                  ;cs3 7/2/92
 10157                                  
 10158                                  	rcr	ax,1			; find number of entries
 10159                                  	cmp	ax,4096-10+1		; would this truncation move us
 10160                                  ;					;  into 12-bit fatland?
 10161                                  	jb	short setend_faterr	; then go ahead and let the
 10162                                  ;					;  inconsistency pass through
 10163                                  ;					;  rather than lose data by
 10164                                  ;					;  correcting the fat type
 10165                                  	jmp	short setend_fat16
 10166                                  
 10167                                  setend_fat12:
 10168                                  	add	ax,ax			; (fatsiz*2)/3 = # of fat entries
 10169                                  	adc	dx,dx
 10170                                  
 10171                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10172                                  ;cs3 7/2/92
 10173                                  	; 15/12/2022
 10174                                  	cmp	dx,3			; if our fatspace is WAY more than
 10175                                  	jnb	short setend_faterr	; we need, we may get an overflow
 10176                                  					; here. Check for it and use
 10177                                  					; the calculated size in this case.
 10178                                  ;cs3 7/2/92
 10179                                  
 10180                                  	div	word [cs:word3]
 10181                                  
 10182                                  setend_fat16:
 10183                                  	dec	ax			; limit at 1
 10184                                  	cmp	ax,bx			; is fat big enough?
 10185                                  	jbe	short setend_fat	; use max value that'll fit
 10186                                  
 10187                                  setend_faterr:
 10188                                  	mov	ax,bx			; use calculated value
 10189                                  
 10190                                  setend_fat:
 10191                                  
 10192                                  ;	now ax = maximum legal cluster
 10193                                  
 10194                                  ;	end M008
 10195                                  
 10196                                  
 10197                                  	;mov	[es:bp+0Dh], ax
 10198                                  	MOV	[ES:BP+DPB.MAX_CLUSTER],AX
 10199                                  
 10200                                  	;;mov	word [es:bp+1Ch],0  ; MSDOS 3.3
 10201                                  	;mov	word [es:bp+1Dh],0  ; MSDOS 6.0
 10202                                  	MOV	word [ES:BP+DPB.NEXT_FREE],0 
 10203                                  					; Init so first ALLOC starts at
 10204                                  					; begining of FAT
 10205                                  	;;mov	word [es:bp+1Eh],-1 ; MSDOS 3.3
 10206                                  	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
 10207                                  	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; current count is invalid.
 10208                                  
 10209                                  	retn
 10210                                  
 10211                                  %else
 10212                                  	; 13/01/2024 - Retro DOS v5.0
 10213                                  	;;;
 10214 000014ED 31D2                    	xor	dx,dx ; 0
 10215 000014EF 09C0                    	or	ax,ax
 10216 000014F1 750C                    	jnz	short savlog1	; 16 bit FAT size
 10217 000014F3 5A                      	pop	dx		; (*) FAT32 extensions
 10218                                  				; (use 32 bit FAT and Root Dir size if >0)
 10219 000014F4 52                      	push    dx		; (*)
 10220 000014F5 09D2                    	or	dx,dx
 10221 000014F7 7406                    	jz	short savlog1	; Do not use FAT32 extensions
 10222                                  				; (do not use 32 bit FAT size field)
 10223 000014F9 8B440C                  	mov	ax,[si+12]	; .BPB_SECTORSPERFAT32 ; BPB_FATSz32
 10224 000014FC 8B540E                  	mov	dx,[si+14]	; .BPB_SECTORSPERFAT32+2
 10225                                  savlog1:
 10226 000014FF 51                      	push    cx		; (**) Root directory sectors
 10227 00001500 89C1                    	mov	cx,ax		; 32 bit multiply
 10228 00001502 88F8                    	mov	al,bh		; FAT count
 10229 00001504 30E4                    	xor	ah,ah
 10230 00001506 F7E2                    	mul	dx
 10231 00001508 91                      	xchg    ax,cx
 10232 00001509 88FA                    	mov	dl,bh		; FAT count
 10233 0000150B 30F6                    	xor	dh,dh
 10234 0000150D F7E2                    	mul	dx
 10235 0000150F 01CA                    	add	dx,cx
 10236 00001511 59                      	pop	cx		; (**)
 10237 00001512 39D0                    	cmp	ax,dx
 10238 00001514 7504                    	jne	short savlog2
 10239                                  
 10240                                  	; 13/01/2024
 10241                                  	;or	ax,ax
 10242                                  	;jnz	short savlog2
 10243                                  
 10244                                  	; 13/01/2024 (not necessary)
 10245                                  	;inc	di
 10246                                  	;inc	di
 10247                                  	; di = 	DPB.DRIVER_ADDR	
 10248                                  
 10249                                  	;jmp	short setend
 10250                                  
 10251                                  	; 13/01/2024
 10252 00001516 09C0                    	or	ax,ax
 10253 00001518 744D                    	jz	short setend
 10254                                  
 10255                                  savlog2:
 10256 0000151A 26034606                	add	ax,[es:bp+DPB.FIRST_FAT]
 10257                                  	;add	ax,[es:bp+6]	; dx:ax = (total) FAT sectors
 10258 0000151E 83D200                  	adc	dx,0
 10259 00001521 AB                      	stosw			; DPB.DIR_SECTOR
 10260 00001522 01C8                    	add	ax,cx		; + root directory size
 10261 00001524 2689460B                	mov	[es:bp+DPB.FIRST_SECTOR],ax
 10262                                  	;mov	[es:bp+11],ax	; DPB.FIRST_SECTOR ; First data sector
 10263 00001528 83D200                  	adc	dx,0
 10264 0000152B 59                      	pop	cx		; (*)
 10265 0000152C 51                      	push    cx
 10266 0000152D E308                    	jcxz    savlog3
 10267 0000152F 26894629                	mov	[es:bp+DPB.FCLUS_FSECTOR],ax
 10268                                  	;mov	[es:bp+41],ax	; DPB.BIG_FIRST_SECTOR ; FAT32 first sector field
 10269 00001533 2689562B                	mov	[es:bp+DPB.FCLUS_FSECTOR+2],dx
 10270                                  	;mov	[es:bp+43],dx
 10271                                  savlog3: 
 10272 00001537 88D9                    	mov	cl,bl		; cluster shift
 10273 00001539 26837E0D00              	cmp	word [es:bp+DPB.MAX_CLUSTER],0
 10274                                  	;cmp	word [es:bp+13],0 ; DPB.MAX_CLUSTER
 10275                                  				; (contains 16 bit .BPB_TOTALSECTORS as temporary)
 10276 0000153E 751D                    	jnz	short normal_dpb
 10277 00001540 30ED                    	xor	ch,ch
 10278 00001542 52                      	push    dx	; (**)
 10279 00001543 8B5C08                  	mov	bx,[si+8]	; SI points to .BPB_SECTORSPERTRACK and SI+8 is
 10280                                  				; .BPB_BIGTOTALSECTORS (32 bit total sectors)
 10281 00001546 8B540A                  	mov	dx,[si+10]
 10282 00001549 29C3                    	sub	bx,ax
 10283 0000154B 58                      	pop	ax	; (**)
 10284 0000154C 19C2                    	sbb	dx,ax		; dx:bx = data sectors (for cluster count calc)
 10285 0000154E 09C9                    	or	cx,cx
 10286 00001550 7407                    	jz	short norot
 10287                                  rott:
 10288 00001552 F8                      	clc
 10289 00001553 D1DA                    	rcr	dx,1
 10290 00001555 D1DB                    	rcr	bx,1
 10291 00001557 E2F9                    	loop    rott
 10292                                  norot:
 10293 00001559 89D8                    	mov	ax,bx		; dx:ax = cluster count
 10294 0000155B EB0A                    	jmp	short setend
 10295                                  
 10296                                  normal_dpb:
 10297 0000155D 262B460D                	sub	ax,[es:bp+DPB.MAX_CLUSTER]
 10298                                  	;sub	ax,[es:bp+13]	; first sector - total sectors
 10299 00001561 31D2                    	xor	dx,dx
 10300 00001563 F7D8                    	neg	ax		; data sectors = total sectors - first sector
 10301 00001565 D3E8                    	shr	ax,cl		; cluster count
 10302                                  
 10303                                  setend:
 10304                                  	; 13/01/2024 (PCDOS 7.1 IBMDOS.COM)
 10305 00001567 59                      	pop	cx		; (*) 0 = not 32 bit fat sectors
 10306 00001568 51                      	push	cx		; (*)
 10307                                  	
 10308                                  	; 13/01/2024
 10309                                  	; (PCDOS 7.1 IBMDOS.COM BUGfix)
 10310 00001569 31D2                    	xor	dx,dx ; 0
 10311                                  	; si = BIOS Parameter Block + 13
 10312                                  	
 10313                                  	; 13/01/2024 (PCDOS 7.1 IBMDOS.COM)
 10314 0000156B 83C001                  	add	ax,1
 10315 0000156E 83D200                  	adc	dx,0			; calculated # clusters HW
 10316 00001571 89C3                    	mov	bx,ax			; calculated # clusters LW
 10317 00001573 268B460F                	mov	ax,[es:bp+DPB.FAT_SIZE]
 10318                                  	;mov	ax,[es:bp+15]		; FAT size (16 bit)
 10319 00001577 E30C                    	jcxz	setend1			; Do not use 32 bit FAT sectors field
 10320 00001579 31C9                    	xor	cx,cx
 10321 0000157B 09C0                    	or	ax,ax
 10322 0000157D 7506                    	jnz	short setend1
 10323 0000157F 8B440C                  	mov	ax,[si+12]		; .BPB_SECTORSPERFAT32  ; 32 bit FAT size field.
 10324 00001582 8B4C0E                  	mov	cx,[si+14]		; .BPB_SECTORSPERFAT32+2
 10325                                  setend1:
 10326 00001585 52                      	push    dx	; (**)		; cx:ax = FAT size (in sectors)
 10327                                  					; dx:bx = calculated number of clusters
 10328 00001586 91                      	xchg    ax,cx
 10329 00001587 26F76602                	mul	word [es:bp+DPB.SECTOR_SIZE]
 10330                                  	;mul	word [es:bp+2]		; DPB.SECTOR_SIZE
 10331 0000158B 91                      	xchg    ax,cx
 10332 0000158C 26F76602                	mul	word [es:bp+DPB.SECTOR_SIZE]
 10333                                  	;mul	word [es:bp+2]
 10334 00001590 01CA                    	add	dx,cx			; dx:ax = FAT size in bytes
 10335 00001592 59                      	pop	cx	; (**)		; calculated # clusters HW
 10336 00001593 09C9                    	or	cx,cx
 10337 00001595 7506                    	jnz	short setend2		; FAT32
 10338 00001597 81FBF60F                	cmp	bx,0FF6h
 10339 0000159B 721E                    	jb	short setend_fat12	; FAT12
 10340                                  setend2:
 10341                                  	; (PCDOS 7.1 IBMDOS.COM BUGfix)
 10342                                  	;or	cx,cx			; HW of calculated cluster count
 10343                                  	;jnz	short setend3
 10344 0000159D 83FBF6                  	cmp	bx,0FFF6h
 10345 000015A0 720C                    	jb	short setend4		; FAT16
 10346                                  setend3:
 10347 000015A2 D1EA                    	shr	dx,1			; FAT32 ; 4 byte (32 bit) cluster number
 10348                                  					; fatsiz/4 = # of fat entries
 10349 000015A4 D1D8                    	rcr	ax,1
 10350 000015A6 D1EA                    	shr	dx,1
 10351 000015A8 7408                    	jz	short setend5		; dx = 0
 10352 000015AA D1D8                    	rcr	ax,1
 10353 000015AC EB1B                    	jmp	short setend_fat16
 10354                                  
 10355                                  setend4:
 10356 000015AE D1EA                    	shr	dx,1			; FAT16 ; 2 byte (16 bit) cluster number
 10357                                  					; fatsiz/2 = # of fat entries
 10358 000015B0 7525                    	jnz	short setend_faterr ; dx > 0
 10359                                  setend5:
 10360 000015B2 D1D8                    	rcr	ax,1			; FAT16 ; 2 byte (16 bit) cluster number
 10361                                  					; fatsiz/2 = # of fat entries
 10362 000015B4 3DF70F                  	cmp	ax,0FF7h		; 4096-10+1
 10363 000015B7 721E                    	jb	short setend_faterr
 10364 000015B9 EB0E                    	jmp	short setend_fat16
 10365                                  
 10366                                  setend_fat12:
 10367 000015BB 01C0                    	add	ax,ax			; FAT12 ; 1.5 byte (12 bit) cluster number
 10368                                  					; (fatsiz*2)/3 = # of fat entries
 10369 000015BD 11D2                    	adc	dx,dx
 10370 000015BF 83FA03                  	cmp	dx,3			; if our fatspace is more than we need
 10371                                  					; use calculated size
 10372 000015C2 7313                    	jnb	short setend_faterr
 10373 000015C4 2EF736[7914]            	div	word [cs:word3]
 10374                                  setend_fat16:
 10375 000015C9 83E801                  	sub	ax,1
 10376 000015CC 83DA00                  	sbb	dx,0
 10377 000015CF 39CA                    	cmp	dx,cx			; is fat big enough?
 10378 000015D1 7704                    	ja	short setend_faterr
 10379 000015D3 39D8                    	cmp	ax,bx
 10380 000015D5 7604                    	jbe	short setend_fat32	; use max value that'll fit
 10381                                  setend_faterr:
 10382 000015D7 89D8                    	mov	ax,bx			; use calculated value
 10383 000015D9 89CA                    	mov	dx,cx
 10384                                  setend_fat32:
 10385 000015DB 26837E0F00              	cmp	word [es:bp+DPB.FAT_SIZE],0
 10386                                  	;cmp	word [es:bp+15],0	; DPB.FAT_SIZE ; 16 bit FAT size
 10387 000015E0 750E                    	jnz	short setend6
 10388 000015E2 26C74611FFFF            	mov	word [es:bp+DPB.DIR_SECTOR],-1 
 10389                                  	;mov	word [es:bp+17],0FFFFh	; DPB.DIR_SECTOR
 10390                                  					; (16 bit directory sector field)
 10391 000015E8 26C7460D0000            	mov	word [es:bp+DPB.MAX_CLUSTER],0 
 10392                                  	;mov	word [es:bp+13],0	; DPB.MAX_CLUSTER (16 bit)
 10393 000015EE EB04                    	jmp	short setend7
 10394                                  
 10395                                  setend6:
 10396 000015F0 2689460D                	mov	[es:bp+DPB.MAX_CLUSTER],ax
 10397                                  	;mov	[es:bp+13],ax	; DPB.MAX_CLUSTER = calculated last cluster number
 10398                                  setend7:
 10399 000015F4 59                      	pop	cx	; (*)		; 1 = use FAT32 extensions
 10400                                  					; 0 = don't use FAT32 extensions (32 bit fields)
 10401 000015F5 E353                    	jcxz	setend_fat		; do not use FAT32 extensions
 10402                                  	;mov	[es:bp+45],ax		; DPB.MAX_CLUSTER32 ; dx:ax = last cluster number
 10403                                  	;mov	[es:bp+47],dx
 10404 000015F7 2689462D                	mov	[es:bp+DPB.LAST_CLUSTER],ax
 10405 000015FB 2689562F                	mov	[es:bp+DPB.LAST_CLUSTER+2],dx
 10406 000015FF B8FFFF                  	mov	ax,0FFFFh ; -1
 10407 00001602 8D7E21                  	lea	di,[bp+DPB.FREE_CNT_HW]
 10408                                  	;lea	di,[bp+33]		; DPB.FAT32_EXT ; FAT32 extensions
 10409                                  					; -1 = ready
 10410 00001605 AB                      	stosw
 10411 00001606 8D7410                  	lea	si,[si+16]		; FAT32 flags
 10412 00001609 A5                      	movsw	   			; DPB FAT32 flags ; [bp+23h]
 10413 0000160A 83C606                  	add	si,6
 10414 0000160D AD                      	lodsw				; FSINFO structure sector number
 10415 0000160E 8B54DC                  	mov	dx,[si-24h]		; .BPB_RESERVEDSECTORS ; Number of reserved sectors.
 10416 00001611 09C0                    	or	ax,ax
 10417 00001613 7404                    	jz	short setend8
 10418 00001615 39D0                    	cmp	ax,dx
 10419 00001617 7203                    	jb	short setend9
 10420                                  setend8:
 10421 00001619 B8FFFF                  	mov	ax,0FFFFh ; -1		; invalid
 10422                                  setend9:
 10423 0000161C AB                      	stosw				; DPB FSINFO structure sector number
 10424                                  					; [bp+25h]
 10425 0000161D AD                      	lodsw				; Sector number of the backup boot sector
 10426 0000161E 09C0                    	or	ax,ax
 10427 00001620 7404                    	jz	short setend10
 10428 00001622 39D0                    	cmp	ax,dx
 10429 00001624 7203                    	jb	short setend11
 10430                                  setend10:
 10431 00001626 B8FFFF                  	mov	ax,0FFFFh ; -1		; invalid
 10432                                  setend11:
 10433 00001629 AB                      	stosw	   			; DPB backup boot sector address
 10434                                  					; [bp+27h]
 10435 0000162A 83C708                  	add	di,8			; [bp+31h]
 10436 0000162D 31D2                    	xor	dx,dx
 10437 0000162F 268B45DE                	mov	ax,[es:di-34]		; [bp+0Fh] ; DPB.MAX_CLUSTER
 10438 00001633 39D0                    	cmp	ax,dx
 10439 00001635 7506                    	jnz	short setend12		; > 0 (not FAT32)
 10440 00001637 8B44F0                  	mov	ax,[si-16]		; FAT32 Sectors per FAT ; .BPB_SECTORSPERFAT32
 10441 0000163A 8B54F2                  	mov	dx,[si-14]
 10442                                  setend12:
 10443 0000163D AB                      	stosw				; DPB FAT32 FAT size in sectors ; [bp+31h]
 10444 0000163E 89D0                    	mov	ax,dx
 10445 00001640 AB                      	stosw
 10446 00001641 83EE08                  	sub	si,8			; Root directory cluster number
 10447 00001644 A5                      	movsw				; DPB Root Dir Cluster ; [bp+35h]
 10448 00001645 A5                      	movsw
 10449 00001646 31C0                    	xor	ax,ax			; DPB reserved ; [bp+39h]
 10450 00001648 AB                      	stosw
 10451 00001649 AB                      	stosw	
 10452                                  %endif
 10453                                  	;;;
 10454                                  
 10455                                  setend_fat:
 10456                                  
 10457                                  	; 13/01/2024 - Retro DOS v5.0
 10458 0000164A 31C0                    	xor	ax,ax ; 0
 10459                                  
 10460                                  	;mov	word [es:bp+1Dh],ax ; 0
 10461 0000164C 2689461D                	mov	word [es:bp+DPB.NEXT_FREE],ax ; 0 
 10462                                  					; Init so first ALLOC starts at
 10463                                  					; begining of FAT
 10464 00001650 48                      	dec	ax  ; -1
 10465                                  	;mov	word [es:bp+1Fh],ax ; -1
 10466 00001651 2689461F                	mov	word [es:bp+DPB.FREE_CNT],ax ; -1 ; current count is invalid.
 10467                                  
 10468 00001655 C3                      	retn
 10469                                  
 10470                                  ;EndProc $SETDPB
 10471                                  
 10472                                  ;BREAK <$Create_Process_Data_Block,SetMem -- Set up process data block>
 10473                                  
 10474                                  ;
 10475                                  ;----------------------------------------------------------------------------
 10476                                  ;
 10477                                  ;**	$Dup_PDB
 10478                                  ;
 10479                                  ; Inputs:   DX is new segment address of process
 10480                                  ;	    SI is end of new allocation block
 10481                                  ;
 10482                                  ;----------------------------------------------------------------------------
 10483                                  ;
 10484                                  	; 14/01/2024 - Retro DOS 5.0
 10485                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:554Fh
 10486                                  
 10487                                  _$DUP_PDB:
 10488                                  
 10489                                  ;hkn;	CreatePDB would have a CS override. This is not valid.
 10490                                  ;hkn;	Must set up ds in order to acess CreatePDB. Also SS is 
 10491                                  ;hkn;	has been assumed to be NOTHING. It may not have DOSDATA.
 10492                                  
 10493                                  	; MSDOS 3.3
 10494                                  	;MOV	byte [CS:CreatePDB],0FFh  ; indicate a new process
 10495                                  	;MOV	DS,[CS:CurrentPDB]
 10496                                  
 10497                                  	; 15/05/2019 - Retro DOS v4.0
 10498                                  	; MSDOS 6.0
 10499 00001656 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 10500 0000165B C606[A803]FF            	MOV	byte [CreatePDB],0FFh
 10501 00001660 8E1E[3003]              	MOV	DS,[CurrentPDB]
 10502                                  
 10503 00001664 56                      	PUSH	SI
 10504 00001665 EB0A                    	JMP	SHORT CreateCopy
 10505                                  
 10506                                  ;
 10507                                  ;----------------------------------------------------------------------------
 10508                                  ;
 10509                                  ; Inputs:
 10510                                  ;	DX = Segment number of new base
 10511                                  ; Function:
 10512                                  ;	Set up program base and copy term and ^C from int area
 10513                                  ; Returns:
 10514                                  ;	None
 10515                                  ; Called at DOS init
 10516                                  ;
 10517                                  ;----------------------------------------------------------------------------
 10518                                  ;
 10519                                  
 10520                                  ; 15/05/2019 - Retro DOS v4.0
 10521                                  ; DOSCODE:4EB6h (MSDOS 6.21, MSDOS.SYS)
 10522                                  
 10523                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10524                                  ; DOSCODE:4EA2h (MSDOS 5.0, MSDOS.SYS)
 10525                                  
 10526                                  _$CREATE_PROCESS_DATA_BLOCK:
 10527                                  			; Offset 1D02h in IBMDOS.COM (MSDOS 3.3), 1987
 10528 00001667 E80DEE                  	CALL	Get_User_Stack
 10529                                  	;mov	ds,[si+14h]
 10530 0000166A 8E5C14                  	MOV	DS,[SI+user_env.user_CS]
 10531                                  	;push	word [2]
 10532 0000166D FF360200                	PUSH	word [PDB.BLOCK_LEN] ;*
 10533                                  CreateCopy:
 10534 00001671 8EC2                    	MOV	ES,DX
 10535                                  
 10536 00001673 31F6                    	XOR	SI,SI			; copy entire PDB
 10537 00001675 89F7                    	MOV	DI,SI
 10538 00001677 B98000                  	MOV	CX,128
 10539 0000167A F3A5                    	REP	MOVSW
 10540                                  
 10541                                  ; DOS 3.3 7/9/86
 10542                                  	;mov	cx,20
 10543                                  	;MOV	CX,FILPERPROC		; copy handles in case of
 10544                                  	; 15/12/2022
 10545 0000167C B114                    	mov	cl,FILPERPROC ; 06/07/2019
 10546                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10547                                  	;mov	cx,FILPERPROC
 10548                                  
 10549                                  	;mov	di,18h
 10550 0000167E BF1800                  	MOV	DI,PDB.JFN_TABLE	; Set Handle Count has been issued
 10551                                  	;;PUSH	DS ; * 15/05/2019
 10552                                  	;;lds	si,[34h]
 10553                                  	;LDS	SI,[PDB.JFN_Pointer]
 10554                                  	;REP	MOVSB
 10555                                  	;;POP	DS ; * 15/05/2019
 10556                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10557                                  	; 05/12/2022
 10558                                  	; (push ds then pop ds is not needed here!)
 10559                                  	;push	ds
 10560                                  	;lds	si,[34h]
 10561 00001681 C5363400                	lds	si,[PDB.JFN_Pointer]
 10562 00001685 F3A4                    	rep	movsb
 10563                                  	;pop	ds
 10564                                  
 10565                                  ; DOS 3.3 7/9/86
 10566                                  	;hkn ;CreatePDB would have a CS override. This is not valid.
 10567                                  	;hkn ;Must set up ds in order to access CreatePDB. Also SS is 
 10568                                  	;hkn ;has been assumed to be NOTHING. It may not have DOSDATA.
 10569                                  
 10570 00001687 2E8E1E[0700]            	mov	ds,[cs:DosDSeg] ; 15/05/2019
 10571                                  
 10572                                  	;;test	byte [cs:CreatePDB],0FFh
 10573                                  	;cmp	byte [CS:CreatePDB],0	; Shall we create a process?
 10574                                  	; 17/12/2022
 10575 0000168C 380E[A803]              	cmp	[CreatePDB],cl ; 0
 10576                                  	;cmp	byte [CreatePDB],0 ; 15/05/2019
 10577 00001690 744A                    	JZ	short Create_PDB_cont 	; nope, old style call
 10578                                  
 10579                                  ; Here we set up for a new process...
 10580                                  
 10581                                  	;PUSH	CS			; Called at DOSINIT time, NO SS
 10582                                  	;POP	DS
 10583                                  
 10584                                  	; MSDOS 6.0
 10585                                  	;;getdseg <ds>			; ds -> dosdata
 10586                                  	;mov	ds,[cs:DosDSeg] ; 15/05/2019
 10587                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10588                                  	; (nonsense! but i put this for addr compatibility as temporary)
 10589                                  	; 15/12/2022
 10590                                  	;mov	ds,[cs:DosDSeg] ; 15/05/2019
 10591                                  
 10592 00001692 31DB                    	XOR	BX,BX			; dup all jfns
 10593                                  	;mov	cx,20
 10594                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10595                                  	;MOV	CX,FILPERPROC		; only 20 of them
 10596                                  	; 15/12/2022
 10597 00001694 B114                    	mov	cl,FILPERPROC ; 06/07/2019
 10598                                  
 10599                                  Create_dup_jfn:
 10600 00001696 06                      	PUSH	ES ;**			; save new PDB
 10601 00001697 E8C759                  	call	SFFromHandle		; get sf pointer
 10602 0000169A B0FF                    	MOV	AL,-1			; unassigned JFN
 10603 0000169C 7224                    	JC	short CreateStash	; file was not really open
 10604                                  	;;test	word [es:di+5],1000h
 10605                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_no_inherit
 10606                                  	; 15/05/2019
 10607                                  	;test	byte [es:di+6],10h
 10608 0000169E 26F6450610              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_no_inherit>>8)
 10609 000016A3 751D                    	JNZ	short CreateStash	; if no-inherit bit is set, skip dup.
 10610                                  
 10611                                  ; We do not inherit network file handles.
 10612                                  
 10613                                  	;mov	ah,[es:di+2]
 10614 000016A5 268A6502                	MOV	AH,[ES:DI+SF_ENTRY.sf_mode]
 10615                                  	;and	ah,0F0h
 10616 000016A9 80E4F0                  	AND	AH,SHARING_MASK
 10617                                  	;cmp	ah,70h
 10618 000016AC 80FC70                  	CMP	AH,SHARING_NET_FCB
 10619 000016AF 7411                    	jz	short CreateStash
 10620                                  
 10621                                  ; The handle we have found is duplicatable (and inheritable). Perform
 10622                                  ; duplication operation.
 10623                                  
 10624 000016B1 893E[9E05]              	MOV	[THISSFT],DI
 10625 000016B5 8C06[A005]              	MOV	[THISSFT+2],ES
 10626 000016B9 E81D1A                  	call	DOS_DUP 		; signal duplication
 10627                                  
 10628                                  ; get the old sfn for copy
 10629                                  
 10630 000016BC E88559                  	call	pJFNFromHandle		; ES:DI is jfn
 10631 000016BF 268A05                  	MOV	AL,[ES:DI]		; get sfn
 10632                                  
 10633                                  ; Take AL (old sfn or -1) and stash it into the new position
 10634                                  
 10635                                  CreateStash:
 10636 000016C2 07                      	POP	ES ;**
 10637                                  	;mov	[es:bx+18h],al
 10638 000016C3 26884718                	MOV	[ES:BX+PDB.JFN_TABLE],AL ; copy into new place!
 10639 000016C7 43                      	INC	BX			; next jfn...
 10640 000016C8 E2CC                    	LOOP	Create_dup_jfn
 10641                                  
 10642 000016CA 8B1E[3003]              	MOV	BX,[CurrentPDB]		; get current process
 10643                                  	; 06/11/2022
 10644                                  	;mov	[es:16h],bx
 10645 000016CE 26891E1600              	MOV	[ES:PDB.PARENT_PID],BX	; stash in child
 10646 000016D3 8C06[3003]              	MOV	[CurrentPDB],ES
 10647                                  	;MOV	DS,BX ; 28/07/2019
 10648                                  	; 07/12/2022
 10649                                  	;mov	ds,[cs:DosDSeg]
 10650                                  	; 15/12/2022
 10651                                  	; ds = [cs:DosDSeg]
 10652 000016D7 C606[A803]00            	mov	byte [CreatePDB],0	; reset flag
 10653                                  	;mov	ds,bx
 10654                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10655                                  	; 15/12/2022
 10656                                  	;mov	ds,bx
 10657                                  
 10658                                  ; end of new process create
 10659                                  
 10660                                  Create_PDB_cont:
 10661                                  	;MOV	BYTE [CS:CreatePDB],0	; reset flag
 10662                                  
 10663                                  ;hkn; It comes to this point from 2 places. So, change to DOSDATA temporarily	
 10664                                  
 10665                                  	;; 28/07/2019
 10666                                  	;;push	ds
 10667                                  	;;mov	ds,[cs:DosDSeg]
 10668                                  	;mov	byte [CreatePDB],0
 10669                                  	;;pop	ds
 10670                                  
 10671                                  ; 05/12/2022
 10672                                  ;	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10673                                  ;	; (push-pop ds is nonsense here! 
 10674                                  ;	;  but i am using same code with original MSDOS.SYS
 10675                                  ;	;  for address compatibility.)
 10676                                  ;	push	ds
 10677                                  ;	; ds = [cs:DosDSeg] !
 10678                                  ;	mov	ds,[cs:DosDSeg]  ; again !
 10679                                  ;	mov	byte [CreatePDB],0
 10680                                  ;	pop	ds
 10681                                  
 10682 000016DC 58                      	POP	AX ;*
 10683                                  
 10684                                  	;entry	SETMEM
 10685                                  
 10686                                  	; 17/12/2022
 10687                                  	; cx = 0
 10688                                  
 10689                                  ;---------------------------------------------------------------------------
 10690                                  ; Inputs:
 10691                                  ;	AX = Size of memory in paragraphs
 10692                                  ;	DX = Segment
 10693                                  ; Function:
 10694                                  ;	Completely prepares a program base at the
 10695                                  ;	specified segment.
 10696                                  ; Called at DOS init
 10697                                  ; Outputs:
 10698                                  ;	DS = DX
 10699                                  ;	ES = DX
 10700                                  ;	[0] has INT int_abort
 10701                                  ;	[2] = First unavailable segment
 10702                                  ;	[5] to [9] form a long call to the entry point
 10703                                  ;	[10] to [13] have exit address (from int_terminate)
 10704                                  ;	[14] to [17] have ctrl-C exit address (from int_ctrl_c)
 10705                                  ;	[18] to [21] have fatal error address (from int_fatal_abort)
 10706                                  ; DX,BP unchanged. All other registers destroyed.
 10707                                  ;---------------------------------------------------------------------------
 10708                                  
 10709                                  SETMEM:
 10710                                  	;XOR	CX,CX
 10711                                  	; 17/12/2022
 10712                                  	; cx = 0
 10713 000016DD 8ED9                    	MOV	DS,CX
 10714 000016DF 8EC2                    	MOV	ES,DX
 10715                                  	;mov	si,88h
 10716 000016E1 BE8800                  	MOV	SI,addr_int_terminate
 10717                                  	;mov	di,10 ; 0Ah
 10718 000016E4 BF0A00                  	MOV	DI,SAVEXIT
 10719                                  	;MOV	CX,6
 10720                                  	; 15/12/2022
 10721 000016E7 B106                    	mov	cl,6
 10722 000016E9 F3A5                    	REP	MOVSW
 10723 000016EB 26A30200                	MOV	[ES:2],AX
 10724 000016EF 29D0                    	SUB	AX,DX
 10725 000016F1 3DFF0F                  	CMP	AX,MAXDIF ; 0FFFh
 10726 000016F4 7603                    	JBE	short HAVDIF
 10727 000016F6 B8FF0F                  	MOV	AX,MAXDIF
 10728                                  HAVDIF:
 10729 000016F9 83E810                  	SUB	AX,10h			; Allow for 100h byte "stack"
 10730 000016FC BB0C00                  	MOV	BX,ENTRYPOINTSEG ; 0Ch	;	in .COM files
 10731 000016FF 29C3                    	SUB	BX,AX
 10732 00001701 B104                    	MOV	CL,4
 10733 00001703 D3E0                    	SHL	AX,CL
 10734 00001705 8EDA                    	MOV	DS,DX
 10735                                  
 10736                                  	; (MSDOS 6.0 note)
 10737                                  	;
 10738                                  	; The address in BX:AX will be F01D:FEF0 if there is 64K or more 
 10739                                  	; memory in the system. This is equivalent to 0:c0 if A20 is OFF.
 10740                                  	; If DOS is in HMA this equivalence is no longer valid as A20 is ON.
 10741                                  	; But the BIOS which now resides in FFFF:30 has 5 bytes in FFFF:D0
 10742                                  	; (F01D:FEF0) which is the same as the ones in 0:C0, thereby 
 10743                                  	; making this equvalence valid for this particular case. If however
 10744                                  	; there is less than 64K remaining the address in BX:AX will not 
 10745                                  	; be the same as above. We will then stuff 0:c0, the call 5 address
 10746                                  	; into the PSP.
 10747                                  	;
 10748                                  	; Therefore for the case where there is less than 64K remaining in 
 10749                                  	; the system old CPM Apps that look at PSP:6 to determine memory
 10750                                  	; requirements will not work. Call 5, however will continue to work
 10751                                  	; for all cases.
 10752                                  	;
 10753                                  
 10754                                  	;mov	[6],ax
 10755                                  	;mov	[8],bx
 10756                                  
 10757 00001707 A30600                  	MOV	[PDB.CPM_CALL+1],AX
 10758 0000170A 891E0800                	MOV	[PDB.CPM_CALL+3],BX
 10759                                  
 10760                                  	; 06/05/2019 - Retro DOS v4.0
 10761 0000170E 3DF0FE                  	cmp	ax,WRAPOFFSET ; 0FEF0h	; Q: does the system have >= 64k of
 10762                                  					;    memory left
 10763 00001711 740C                    	je	short addr_ok		; Y: the above calculated address is
 10764                                  					;    OK
 10765                                  					; N: 
 10766                                  
 10767 00001713 C7060600C000            	MOV	WORD [PDB.CPM_CALL+1],0C0h
 10768 00001719 C70608000000            	MOV	WORD [PDB.CPM_CALL+3],0
 10769                                  addr_ok:
 10770                                  	;mov	word [0],20CDh
 10771 0000171F C7060000CD20            	MOV	word [PDB.EXIT_CALL],(int_abort*256) + mi_INT
 10772                                  	;mov	byte [5],9Ah
 10773 00001725 C60605009A              	MOV	BYTE [PDB.CPM_CALL],mi_Long_CALL
 10774                                  	;mov	word [50h],21CDh
 10775 0000172A C7065000CD21            	MOV	WORD [PDB.CALL_SYSTEM],(int_command*256) + mi_INT
 10776                                  	;mov	byte [52h],0CBh
 10777 00001730 C6065200CB              	MOV	BYTE [PDB.CALL_SYSTEM+2],mi_Long_RET
 10778                                  	;mov	word [34h],18h
 10779 00001735 C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE
 10780                                  	;mov	word [36h],ds
 10781 0000173B 8C1E3600                	MOV	WORD [PDB.JFN_Pointer+2],DS
 10782                                  	;mov	word [32h],20
 10783 0000173F C70632001400            	MOV	WORD [PDB.JFN_Length],FILPERPROC
 10784                                  ;
 10785                                  ; The server runs several PDB's without creating them VIA EXEC.  We need to
 10786                                  ; enumerate all PDB's at CPS time in order to find all references to a
 10787                                  ; particular SFT.  We perform this by requiring that the server link together
 10788                                  ; for us all sub-PDB's that he creates. The requirement for us, now, is to
 10789                                  ; initialize this pointer.
 10790                                  ;
 10791                                   	;mov	word [38h],-1
 10792 00001745 C7063800FFFF            	MOV	word [PDB.Next_PDB],-1
 10793                                  	;mov	word [3Ah],-1
 10794 0000174B C7063A00FFFF            	MOV	word [PDB.Next_PDB+2],-1
 10795                                  
 10796                                  	; 06/05/2019
 10797                                  	; Set the real version number in the PSP - 5.00
 10798                                  
 10799                                  	;mov	word [es:PDB.Version],1406h ; MSDOS 6.21 (DOSCODE:4FB6h)
 10800                                  	; 07/12/2022
 10801 00001751 26C7064000070A          	mov	word [ES:PDB.Version],(MINOR_VERSION*256)+MAJOR_VERSION
 10802                                  
 10803 00001758 C3                      	retn
 10804                                  
 10805                                  ; 29/04/2019 - Retro DOS v4.0
 10806                                  
 10807                                  ;BREAK <$GSetMediaID -- get set media ID>
 10808                                  
 10809                                  ;---------------------------------------------------------------------------
 10810                                  ; Inputs:
 10811                                  ;	BL= drive number as defined in IOCTL
 10812                                  ;	AL= 0 get media ID
 10813                                  ;	    1 set media ID
 10814                                  ;	DS:DX= buffer containing information
 10815                                  ;		DW  0  info level (set on input)
 10816                                  ;		DD  ?  serial #
 10817                                  ;		DB  11 dup(?)  volume id
 10818                                  ;		DB   8 dup(?)  file system type
 10819                                  ; Function:
 10820                                  ;	Get or set media ID
 10821                                  ; Returns:
 10822                                  ;	carry clear, DS:DX is filled
 10823                                  ;	carry set, error
 10824                                  ;---------------------------------------------------------------------------
 10825                                  
 10826                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10827                                  
 10828                                  ; 14/01/2024
 10829                                  %if 0
 10830                                  
 10831                                  _$GSetMediaID:
 10832                                  	; RAWIO - GET_MEDIA_ID
 10833                                  	mov	cx,0866h	      ;AN000;MS.; assume get for IOCTL
 10834                                  	cmp	al,0		      ;AN001;MS.; get ?
 10835                                  	je	short doioctl 	      ;AN000;MS.; yes
 10836                                  	;cmp	al,1		      ;AN000;MS.; set ?
 10837                                  	;jne	short errorfunc	      ;AN000;MS.; no
 10838                                  	; 15/12/2022
 10839                                  	dec	al
 10840                                  	jnz	short errorfunc ; al > 1
 10841                                  	; RAWIO - SET_MEDIA_ID
 10842                                  	;mov	cx,0846h	      ;AN001;MS.;
 10843                                  	; 15/12/2022
 10844                                  	mov	cl,46h	; cx = 0846h
 10845                                  doioctl:			      ;AN000;
 10846                                  	mov	al,0Dh		      ;AN000;MS.; generic IOCTL
 10847                                  	;invoke	$IOCTL		      ;AN000;MS.; let IOCTL take care of it
 10848                                  	;call	_$IOCTL
 10849                                  	;retn			      ;AN000;MS.;
 10850                                  	; 15/12/2022
 10851                                  	jmp	_$IOCTL
 10852                                  errorfunc:			      ;AN000;
 10853                                  	;error	error_invalid_function;AN000;MS. ; invalid function
 10854                                  	;mov	al,1
 10855                                  	mov	al,error_invalid_function
 10856                                  	jmp	SYS_RET_ERR
 10857                                  
 10858                                  %else
 10859                                  	; 14/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 10860                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:5667h
 10861                                  
 10862                                  _$GSetMediaID:
 10863 00001759 1E                      	push	ds
 10864 0000175A 56                      	push	si
 10865 0000175B 36C536[A205]            	lds	si,[ss:THISCDS]
 10866 00001760 C57445                  	lds	si,[si+45h]		; [si+curdir.devptr]
 10867                                  					; local pointer to DPB or net device
 10868 00001763 8B740F                  	mov	si,[si+0Fh]		; [si+DPB.FAT_SIZE]
 10869 00001766 B96608                  	mov	cx,0866h		; assume get for IOCTL
 10870 00001769 3C01                    	cmp	al,1			; set ?
 10871 0000176B 7208                    	jb	short doioctl1		; get
 10872 0000176D 7733                    	ja	short errorfunc		; invalid
 10873 0000176F B146                    	mov	cl,46h	; cx = 0846h
 10874                                  	;or	si,si
 10875 00001771 21F6                    	and	si,si ; 14/01/2024
 10876 00001773 7424                    	jz	short doioctl2
 10877                                  doioctl1:
 10878 00001775 09F6                    	or	si,si
 10879 00001777 7522                    	jnz	short doioctl
 10880 00001779 1F                      	pop	ds
 10881 0000177A 1E                      	push	ds
 10882 0000177B 89D6                    	mov	si,dx	; disk info
 10883                                  			; .................................
 10884                                  			;
 10885                                  			; 00h    WORD    0000h (info level)
 10886                                  			; 02h    DWORD   disk serial number (binary)
 10887                                  			; 06h 11 BYTEs   volume label or "NO NAME    " if none present
 10888                                  			; 11h  8 BYTEs   (AL=00h only) filesystem type
 10889                                  			;		"FAT12   "
 10890                                  			;		"FAT16   "
 10891                                  			;		"FAT32   " ; PCDOS 7.1
 10892                                  			;		"CDROM   "
 10893                                  			;		"CD001   " 
 10894                                  			;		"CDAUDIO "
 10895                                  			; .................................
 10896                                  			; (ref: Ralf Brown's Interrupt List) 		
 10897                                  
 10898 0000177D 817C114641              	cmp	word [si+11h],4146h ; 'FA'
 10899 00001782 7517                    	jne	short doioctl
 10900 00001784 817C135433              	cmp	word [si+13h],3354h ; 'T3'
 10901 00001789 7510                    	jne	short doioctl
 10902 0000178B 817C153220              	cmp     word [si+15h],2032h ; '2 '
 10903 00001790 7509                    	jne	short doioctl
 10904 00001792 817C172020              	cmp	word [si+17h],2020h ; '  '
 10905 00001797 7502                    	jne	short doioctl
 10906                                  doioctl2:
 10907 00001799 B548                    	mov	ch,48h	; cx = 4846h
 10908                                  doioctl:
 10909 0000179B 5E                      	pop	si
 10910 0000179C 1F                      	pop	ds
 10911 0000179D B00D                    	mov	al,0Dh			; generic IOCTL
 10912                                  	;call	_$IOCTL
 10913                                          ;retn
 10914 0000179F E90C11                  	jmp	_$IOCTL			; let IOCTL take care of it
 10915                                  
 10916                                  errorfunc:
 10917 000017A2 B001                    	mov	al,1			; error_invalid_function
 10918 000017A4 E9D3EE                  	jmp	SYS_RET_ERR
 10919                                  
 10920                                  %endif
 10921                                  
 10922                                  ; 16/05/2019 - Retro DOS v4.0
 10923                                  
 10924                                  ;============================================================================
 10925                                  ; MISC2.ASM, MSDOS 6.0, 1991
 10926                                  ;============================================================================
 10927                                  ; 20/07/2018 - Retro DOS v3.0
 10928                                  ; 29/04/2019 - Retro DOS v4.0
 10929                                  
 10930                                  ; Break <STRCMP - compare two ASCIZ strings DS:SI to ES:DI>
 10931                                  ;----------------------------------------------------------------------------
 10932                                  ;
 10933                                  ;   Strcmp - compare ASCIZ DS:SI to ES:DI. Case INSENSITIVE. '/' = '\'
 10934                                  ;	     Strings of different lengths don't match.
 10935                                  ;   Inputs:  DS:SI - pointer to source string  ES:DI - pointer to dest string
 10936                                  ;   Outputs: Z if strings same, NZ if different
 10937                                  ;   Registers modified: NONE
 10938                                  ;----------------------------------------------------------------------------
 10939                                  
 10940                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10941                                  
 10942                                  	; 14/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 10943                                  	; (PCDOS 7.1 IBMDOS.COM DOSCODE:56B6h)
 10944                                  	; (MSDOS 6.22 MSDOS.SYS DOSCODE:4FD7h)
 10945                                  StrCmp:
 10946 000017A7 56                      	push	si
 10947 000017A8 57                      	push	di
 10948 000017A9 50                      	push	ax
 10949                                  Cmplp:
 10950 000017AA AC                      	LODSB
 10951 000017AB E84C42                  	call	UCase			; convert to upper case
 10952 000017AE E89E42                  	call	PATHCHRCMP		; convert '/' to '\' ; 07/12/2022 ('\')
 10953 000017B1 88C4                    	MOV	AH,AL
 10954 000017B3 268A05                  	MOV	AL,[ES:DI]
 10955 000017B6 47                      	INC	DI
 10956 000017B7 E84042                  	call	UCase			; convert to upper case
 10957 000017BA E89242                  	call	PATHCHRCMP		; convert '/' to '\' ; 07/12/2022 ('\')
 10958 000017BD 38C4                    	CMP	AH,AL
 10959 000017BF 7504                    	JNZ	short PopRet		; Strings dif
 10960                                  
 10961 000017C1 08C0                    	OR	AL,AL
 10962 000017C3 75E5                    	JNZ	short Cmplp		; More string
 10963                                  PopRet:
 10964 000017C5 58                      	pop	ax
 10965 000017C6 5F                      	pop	di
 10966 000017C7 5E                      	pop	si
 10967 000017C8 C3                      	retn
 10968                                  
 10969                                  ;Break <STRCPY - copy ASCIZ string from DS:SI to ES:DI>
 10970                                  ;----------------------------------------------------------------------------
 10971                                  ;
 10972                                  ;   Strcpy - copy an ASCIZ string from DS:SI to ES:DI and make uppercase
 10973                                  ;   FStrcpy - copy an ASCIZ string from DS:SI to ES:DI. no modification of
 10974                                  ;	characters.
 10975                                  ;
 10976                                  ;   Inputs:	DS:SI - pointer to source string
 10977                                  ;		ES:DI - pointer to destination string
 10978                                  ;   Outputs:	ES:DI point byte after nul byte at end of dest string
 10979                                  ;		DS:SI point byte after nul byte at end of source string
 10980                                  ;   Registers modified: SI,DI
 10981                                  ;----------------------------------------------------------------------------
 10982                                  
 10983                                  StrCpy:
 10984 000017C9 50                      	push	ax
 10985                                  CPYLoop:
 10986 000017CA AC                      	LODSB
 10987 000017CB E82C42                  	call	UCase			; convert to upper case
 10988 000017CE E87E42                  	call	PATHCHRCMP		; convert / to \ ;
 10989 000017D1 AA                      	STOSB
 10990                                  
 10991 000017D2 08C0                    	OR	AL,AL
 10992 000017D4 75F4                    	JNZ	short CPYLoop
 10993 000017D6 58                      	pop	ax
 10994 000017D7 C3                      	retn
 10995                                  
 10996                                  ;----------------------------------------------------------------------------
 10997                                  ; Procedure Name : FStrCpy
 10998                                  ;----------------------------------------------------------------------------
 10999                                  
 11000                                  FStrCpy:
 11001 000017D8 50                      	push	ax
 11002                                  FCPYLoop:
 11003 000017D9 AC                      	LODSB
 11004 000017DA AA                      	STOSB
 11005 000017DB 08C0                    	OR	AL,AL
 11006 000017DD 75FA                    	JNZ	short FCPYLoop
 11007 000017DF 58                      	pop	ax
 11008 000017E0 C3                      	retn
 11009                                  
 11010                                  ; 20/07/2018 - Retro DOS v3.0
 11011                                  ;----------------------------------------------------------------------------
 11012                                  ; UCase, IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1E2Fh
 11013                                  ;----------------------------------------------------------------------------
 11014                                  ;
 11015                                  ;UCase:	
 11016                                  ;	call	_UCase	 ; Offset 5518h (GetLet, Offset 5517h)
 11017                                  ;	retn
 11018                                  
 11019                                  ;Break <StrLen - compute length of string ES:DI>
 11020                                  ;----------------------------------------------------------------------------
 11021                                  ;**	StrLen - Compute Length of String
 11022                                  ;
 11023                                  ;	StrLen computes the length of a string, including the trailing 00
 11024                                  ;
 11025                                  ;	ENTRY	(es:di) = address of string
 11026                                  ;	EXIT	(cx) = size of string
 11027                                  ;	USES	cx, flags
 11028                                  ;----------------------------------------------------------------------------
 11029                                  
 11030                                  StrLen:
 11031 000017E1 57                      	push	di
 11032 000017E2 50                      	push	ax
 11033                                  	;MOV	CX,-1
 11034 000017E3 B9FFFF                  	mov	cx,65535
 11035 000017E6 30C0                    	XOR	AL,AL
 11036 000017E8 F2AE                    	REPNE	SCASB
 11037 000017EA F7D1                    	NOT	CX
 11038 000017EC 58                      	pop	ax
 11039 000017ED 5F                      	pop	di
 11040 000017EE C3                      	retn
 11041                                  
 11042                                  ;----------------------------------------------------------------------------
 11043                                  ;**	DStrLen - Compute Length of String
 11044                                  ;
 11045                                  ;	ENTRY	(ds:si) = address of string
 11046                                  ;	EXIT	(cx) = size of string, including trailing NUL
 11047                                  ;	USES	cx, flags
 11048                                  ;----------------------------------------------------------------------------
 11049                                  
 11050                                  DStrLen:	; BUGBUG - this guy is a pig, who uses him?
 11051 000017EF E80300                  	CALL	XCHGP
 11052 000017F2 E8ECFF                  	CALL	StrLen
 11053                                  	;CALL	XCHGP
 11054                                  	;retn
 11055                                  	; 18/12/2022
 11056                                  	;jmp	short XCHGP
 11057                                  
 11058                                  ;----------------------------------------------------------------------------
 11059                                  ;**	XCHGP - Exchange Source and Destination Pointers
 11060                                  ;
 11061                                  ;	XCHGP exchanges (DS:SI) and (ES:DI)
 11062                                  ;
 11063                                  ;	ENTRY	none
 11064                                  ;	EXIT	pairs exchanged
 11065                                  ;	USES	SI, DI, DS, ES
 11066                                  ;----------------------------------------------------------------------------
 11067                                  
 11068                                  XCHGP:
 11069 000017F5 1E                      	push	ds
 11070 000017F6 06                      	push	es
 11071 000017F7 1F                      	pop	ds
 11072 000017F8 07                      	pop	es
 11073 000017F9 87F7                    	XCHG	SI,DI
 11074                                  xchgp_retn:
 11075 000017FB C3                      	retn
 11076                                  
 11077                                  ;Break	<Idle - wait for a specified amount of time>
 11078                                  ;----------------------------------------------------------------------------
 11079                                  ;
 11080                                  ;   Idle - when retrying an operation due to a lock/sharing violation,
 11081                                  ;   	   we spin until RetryLoop is exhausted.
 11082                                  ;
 11083                                  ;   Inputs:	RetryLoop is the number of times we spin
 11084                                  ;   Outputs:	Wait
 11085                                  ;   Registers modified: none
 11086                                  ;----------------------------------------------------------------------------
 11087                                  
 11088                                  Idle:
 11089                                  	;test	byte [SS:FSHARING],0FFh
 11090 000017FC 36803E[7205]00          	cmp	byte [SS:FSHARING],0	;hkn; SS override
 11091                                  	;retnz
 11092 00001802 75F7                    	jnz	short xchgp_retn
 11093                                  	;SAVE	<CX>
 11094 00001804 51                      	push	cx
 11095 00001805 368B0E[1C00]            	MOV	CX,[ss:RetryLoop]	;hkn; SS override
 11096 0000180A E308                    	JCXZ	Idle3
 11097                                  Idle1:	
 11098 0000180C 51                      	PUSH	CX
 11099 0000180D 31C9                    	XOR	CX,CX
 11100                                  Idle2:	
 11101 0000180F E2FE                    	LOOP	Idle2
 11102 00001811 59                      	POP	CX
 11103 00001812 E2F8                    	LOOP	Idle1
 11104                                  Idle3:	
 11105                                  	;RESTORE <CX>
 11106 00001814 59                      	pop	cx
 11107 00001815 C3                      	retn
 11108                                  
 11109                                  ;Break	<TableDispatch - dispatch to a table>
 11110                                  ;----------------------------------------------------------------------------
 11111                                  ;
 11112                                  ;   TableDispatch - given a table and an index, jmp to the approptiate
 11113                                  ;   routine. Preserve all input registers to the routine.
 11114                                  ;
 11115                                  ;   Inputs:	Push	return address
 11116                                  ;		Push	Table address
 11117                                  ;		Push	index (byte)
 11118                                  ;   Outputs:	appropriate routine gets jumped to.
 11119                                  ;		return indicates invalid index
 11120                                  ;   Registers modified: none.
 11121                                  ;----------------------------------------------------------------------------
 11122                                  
 11123                                  struc TFrame	 ; TableFrame
 11124 00000000 ????                    .OldBP:	 resw 1  ; 0
 11125 00000002 ????                    .OldRet: resw 1  ; 2
 11126 00000004 ??                      .Index:	 resb 1  ; 4
 11127 00000005 ??                      .Pad:	 resb 1  ; 5  
 11128 00000006 ????                    .Tab:	 resw 1  ; 6
 11129 00000008 ????                    .NewRet: resw 1  ; 8
 11130                                  endstruc
 11131                                  
 11132                                  TableDispatch:
 11133 00001816 55                      	PUSH	BP
 11134 00001817 89E5                    	MOV	BP,SP
 11135 00001819 53                      	PUSH	BX			; save BX
 11136                                  	;mov	bx,[bp+6]
 11137 0000181A 8B5E06                  	MOV	BX,[BP+TFrame.Tab]	; get pointer to table
 11138 0000181D 2E8A1F                  	MOV	BL,[CS:BX]		; maximum index
 11139                                  	;cmp	[bp+4],bl
 11140 00001820 385E04                  	CMP	[BP+TFrame.Index],BL	; table error?
 11141 00001823 7317                    	JAE	short TableError	; yes
 11142                                  	;mov	bl,[bp+4]
 11143 00001825 8A5E04                  	MOV	BL,[BP+TFrame.Index]	; get desired table index
 11144 00001828 30FF                    	XOR	BH,BH			; convert to word
 11145 0000182A D1E3                    	SHL	BX,1			; convert to word pointer
 11146 0000182C 43                      	INC	BX			; point past first length byte
 11147                                  	; 17/08/2018
 11148                                  	;add	bx,[bp+6]
 11149 0000182D 035E06                  	ADD	BX,[BP+TFrame.Tab]	; get real offset
 11150 00001830 2E8B1F                  	MOV	BX,[CS:BX]		; get contents of table entry
 11151                                  	;mov	[bp+6],bx
 11152 00001833 895E06                  	MOV	[BP+TFrame.Tab],BX	; put table entry into return address
 11153 00001836 5B                      	POP	BX			; restore BX
 11154 00001837 5D                      	POP	BP			; restore BP
 11155 00001838 83C404                  	ADD	SP,4			; clean off Index and our return addr
 11156 0000183B C3                      	retn				; do operation
 11157                                  TableError:
 11158 0000183C 5B                      	POP	BX			; restore BX
 11159 0000183D 5D                      	POP	BP			; restore BP
 11160 0000183E C20600                  	RETN	6			; clean off Index, Table and RetAddr
 11161                                  
 11162                                  ;Break	<TestNet - determine if a CDS is for the network>
 11163                                  ;----------------------------------------------------------------------------
 11164                                  ;
 11165                                  ;   TestNet - examine CDS pointed to by ThisCDS and see if it indicates a
 11166                                  ;	network CDS. This will handle NULL cds also.
 11167                                  ;
 11168                                  ;   Inputs:	ThisCDS points to CDS or NULL
 11169                                  ;   Outputs:	ES:DI = ThisCDS
 11170                                  ;		carry Set => network
 11171                                  ;		carry Clear => local
 11172                                  ;   Registers modified: none.
 11173                                  ;----------------------------------------------------------------------------
 11174                                  
 11175                                  TestNet:
 11176                                  	;LES	DI,[CS:THISCDS]
 11177                                  
 11178                                  	; 16/05/2019 - Retro DOS v4.0
 11179 00001841 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 11180 00001846 26C43E[A205]            	LES	DI,[ES:THISCDS]
 11181 0000184B 83FFFF                  	CMP	DI,-1
 11182 0000184E 7408                    	JZ	short CMCRet		; UNC? carry is clear
 11183                                  	;;test	word [es:di+43h],8000h
 11184                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 11185                                  	;test	byte [es:di+44h],80h
 11186 00001850 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 11187 00001855 7501                    	JNZ	short CMCRet		; jump has carry clear
 11188 00001857 C3                      	retn				; carry is clear
 11189                                  CMCRet: 
 11190 00001858 F5                      	CMC
 11191 00001859 C3                      	retn
 11192                                  
 11193                                  ;Break	<IsSFTNet - see if an sft is for the network>
 11194                                  ;----------------------------------------------------------------------------
 11195                                  ;
 11196                                  ;   IsSFTNet - examine SF pointed to by ES:DI and see if it indicates a
 11197                                  ;	network file.
 11198                                  ;
 11199                                  ;   Inputs:	ES:DI point to SFT
 11200                                  ;   Outputs:	Zero set if not network sft
 11201                                  ;		zero reset otherwise
 11202                                  ;		Carry CLEAR!!!
 11203                                  ;   Registers modified: none.
 11204                                  ;----------------------------------------------------------------------------
 11205                                  
 11206                                  IsSFTNet:
 11207                                  	;;test	word [es:di+5],8000h
 11208                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 11209                                  	; 16/05/2019 
 11210                                  	;test	byte [es:di+6],80h
 11211 0000185A 26F6450680              	TEST	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 11212 0000185F C3                      	retn
 11213                                  
 11214                                  ;Break	<FastInit - Initialize FastTable entries >
 11215                                  ;----------------------------------------------------------------------------
 11216                                  ;   DOS 4.00   2/9/87
 11217                                  ;   FastInit  - initialize the FASTXXX routine entry
 11218                                  ;		  in the FastTable
 11219                                  ;
 11220                                  ;   Inputs:	BX = FASTXXX ID ( 1=fastopen )
 11221                                  ;		DS:SI = address of FASTXXX routine entry
 11222                                  ;		   SI = -1 for query only
 11223                                  ;   Outputs:	Carry flag clear, if success
 11224                                  ;		Carry flag set,   if failure
 11225                                  ;
 11226                                  ;
 11227                                  ;----------------------------------------------------------------------------
 11228                                  
 11229                                  ;Procedure FastInit,NEAR
 11230                                  ;	ASSUME	CS:DOSCODE,SS:NOTHING
 11231                                  
 11232                                  ;	; MSDOS 3.3
 11233                                  ;	; IBMDOS.COM (1987) - Offset 1EB3h
 11234                                  ;FastInit:
 11235                                  ;	mov	di,FastTable ; FastOpenTable
 11236                                  ;	mov	ax,[cs:di+4]		; Entry segment
 11237                                  ;	mov	bx,cs			; get DOS segment
 11238                                  ;	cmp	ax,bx			; first time installed ?	
 11239                                  ;	je	short ok_install	; yes
 11240                                  ;	stc				; set carry
 11241                                  ;	retn				; (cf=1 means) already installed !
 11242                                  ;
 11243                                  ;ok_install:
 11244                                  ;	mov	bx,FastTable ; FastOpenTable
 11245                                  ;	mov	cx,ds
 11246                                  ;	; set address of FASTXXX (FASTOPEN) routine entry
 11247                                  ;	mov	[cs:bx+4],cx
 11248                                  ;	mov	[cs:bx+2],si
 11249                                  ;	retn
 11250                                  
 11251                                  ; 16/05/2019 - Retro DOS v4.0
 11252                                  
 11253                                  ; 14/01/2024 - Retro DOS v5.0
 11254                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:5773h
 11255                                  
 11256                                  FastInit:
 11257                                  	; MSDOS 6.0
 11258                                  	;hkn; set up es to dosdataseg.
 11259 00001860 06                      	push	es
 11260                                  	;getdseg <es>			; es -> dosdata
 11261 00001861 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 11262                                  
 11263                                  	;hkn; FastTable is in DOSDATA
 11264 00001866 BF[6512]                	MOV	DI,FastTable+2		;AN000;FO. points to fastxxx entry
 11265 00001869 4B                      	DEC	BX			;AN000;FO.;; decrement index
 11266 0000186A 89DA                    	MOV	DX,BX			;AN000;FO.;; save bx
 11267 0000186C D1E3                    	SHL	BX,1			;AN000;FO.;; times 4, each entry is DWORD
 11268 0000186E D1E3                    	SHL	BX,1			;AN000;FO.
 11269 00001870 01DF                    	ADD	DI,BX			;AN000;FO. index to the entry
 11270 00001872 268B4502                	MOV	AX,[ES:DI+2]		;AN000;FO. get entry segment
 11271                                  fcheck: 				;AN000;
 11272 00001876 8CC9                    	MOV	CX,CS			;AN000;FO.;; get DOS segment
 11273 00001878 39C8                    	CMP	AX,CX			;AN000;FO.;; first time installed ?
 11274 0000187A 7405                    	JZ	short ok_install	;AN000;FO.;; yes
 11275 0000187C 09C0                    	OR	AX,AX			;AN000;FO.;
 11276                                  	;JZ	short ok_install	;AN000;FO.;
 11277                                  	;STC				;AN000;FO.;; already installed !
 11278                                  	;JMP	SHORT FSret		;AN000;FO. set carry
 11279                                  	; 14/01/2024
 11280 0000187E F9                      	stc
 11281 0000187F 7517                    	jnz	short FSret
 11282                                  ok_install:				;AN000;
 11283 00001881 83FEFF                  	CMP	SI,-1			;AN000;FO.; Query only ?
 11284 00001884 7412                    	JZ	short FSret		;AN000;FO.; yes
 11285 00001886 8CD9                    	MOV	CX,DS			;AN000;FO.; get FASTXXX entry segment
 11286 00001888 26894D02                	MOV	[ES:DI+2],CX		;AN000;FO.; initialize routine entry
 11287 0000188C 268935                  	MOV	[ES:DI],SI		;AN000;FO.; initialize routine offset
 11288                                  
 11289                                  ;hkn; FastFlg moved to DOSDATA
 11290 0000188F BF[6D12]                	MOV	DI,FastFlg		;AN000;FO.; get addr of FASTXXX flags
 11291 00001892 01D7                    	ADD	DI,DX			;AN000;FO.; index to a FASTXXX flag
 11292                                  	;or	byte [es:di],80h
 11293 00001894 26800D80                	OR	byte [ES:DI],Fast_yes	;AN000;FO.; indicate installed
 11294                                  FSret:					;AN000;
 11295 00001898 07                      	pop	es
 11296 00001899 C3                      	retn				;AN000;FO.
 11297                                  
 11298                                  ;EndProc FastInit
 11299                                  
 11300                                  ;Break	<FastRet - initial routine in FastOpenTable >
 11301                                  ;----------------------------------------------------------------------------
 11302                                  ;   DOS 3.3   6/10/86
 11303                                  ;   FastRet	- indicate FASTXXXX  not in memory
 11304                                  ;
 11305                                  ;   Inputs:	None
 11306                                  ;   Outputs:	AX = -1 and carry flag set
 11307                                  ;
 11308                                  ;   Registers modified: none.
 11309                                  ;----------------------------------------------------------------------------
 11310                                  
 11311                                  FastRet:
 11312                                  	;mov	ax,-1
 11313                                  	;stc
 11314                                  	;retf
 11315 0000189A F9                      	STC
 11316 0000189B 19C0                    	sbb	ax,ax		; (ax) = -1, 'C' set
 11317 0000189D CB                      	RETF
 11318                                  
 11319                                  ;Break	<NLS_OPEN - do $open for NLSFUNC>
 11320                                  ;----------------------------------------------------------------------------
 11321                                  ;   DOS 3.3   6/10/86
 11322                                  ;   NLS_OPEN	- call $OPEN for NLSFUNC
 11323                                  ;
 11324                                  ;   Inputs:	Same input as $OPEN except CL = mode
 11325                                  ;   Outputs:	same output as $OPEN
 11326                                  ;
 11327                                  ;----------------------------------------------------------------------------
 11328                                  
 11329                                  ;hkn; NOTE! SS MUST HAVE BEEN SET UP TO DOSDATA BY THE TIME THESE
 11330                                  ;hkn; NLS FUNCTIONS ARE CALLED!!! THERE FORE WE WILL USE SS OVERRIDES
 11331                                  ;hkn; IN ORDER TO ACCESS DOS DATA VARIABLES!
 11332                                  
 11333                                  NLS_OPEN:
 11334                                  ;	MOV	BL,[CPSWFLAG]	 ; disable code page matching logic
 11335                                  ;	MOV	BYTE [CPSWFLAG],0
 11336                                  ;	PUSH	BX		 ; save current state
 11337                                  
 11338 0000189E 88C8                    	MOV	AL,CL		 ; set up correct interface for $OPEN
 11339 000018A0 E82860                  	call	_$OPEN
 11340                                  
 11341                                  ;	POP	BX		 ; restore current state
 11342                                  ;	MOV	[CPSWFLAG],BL
 11343                                  
 11344 000018A3 C3                      	RETN
 11345                                  
 11346                                  ;Break	<NLS_LSEEK - do $LSEEK for NLSFUNC>
 11347                                  ;----------------------------------------------------------------------------
 11348                                  ;   DOS 3.3   6/10/86
 11349                                  ;   NLS_LSEEK	- call $LSEEK for NLSFUNC
 11350                                  ;
 11351                                  ;   Inputs:	BP = open mode
 11352                                  ;   Outputs:	same output as $LSEEK
 11353                                  ;
 11354                                  ;----------------------------------------------------------------------------
 11355                                  
 11356                                  ; 16/05/2019 - Retro DOS v4.0
 11357                                  
 11358                                  NLS_LSEEK:
 11359 000018A4 36FF36[8405]            	PUSH	word [SS:USER_SP] ; save user stack
 11360 000018A9 36FF36[8605]            	PUSH	word [SS:USER_SS]
 11361 000018AE E81000                  	CALL	Fake_User_Stack
 11362 000018B1 89E8                    	MOV	AX,BP		; set up correct interface for $LSEEK
 11363 000018B3 E8C259                  	call	_$LSEEK
 11364 000018B6 368F06[8605]            	POP	word [SS:USER_SS] ; restore user stack
 11365 000018BB 368F06[8405]            	POP	word [SS:USER_SP]
 11366 000018C0 C3                      	RETN
 11367                                  
 11368                                  ;Break	<Fake_User_Stack - save user stack>
 11369                                  ;----------------------------------------------------------------------------
 11370                                  ;   DOS 3.3   6/10/86
 11371                                  ;   Fake_User_Stack - save user stack pointer
 11372                                  ;
 11373                                  ;----------------------------------------------------------------------------
 11374                                  
 11375                                  Fake_User_Stack:
 11376 000018C1 36A1[BB0D]              	MOV	AX,[SS:USER_SP_2F] ; replace with INT 2Fh stack
 11377 000018C5 36A3[8405]              	MOV	[SS:USER_SP],AX
 11378 000018C9 8CD0                    	MOV	AX,SS
 11379 000018CB 36A3[8605]              	MOV	[SS:USER_SS],AX
 11380 000018CF C3                      	RETN
 11381                                  
 11382                                  ;Break	<GetDevList - get device header list pointer>
 11383                                  ;----------------------------------------------------------------------------
 11384                                  ;   DOS 3.3   7/25/86
 11385                                  ;   GetDevList - get device header list pointer
 11386                                  ;
 11387                                  ;   Output: AX:BX points to the device header list
 11388                                  ;----------------------------------------------------------------------------
 11389                                  
 11390                                  GetDevList:
 11391                                  	; 16/05/2019 - Retro DOS v4.0
 11392 000018D0 BE[790D]                	MOV	SI,SysInitTable
 11393 000018D3 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 11394 000018D8 C534                    	LDS	SI,[SI]
 11395                                  	;mov	ax,[si+34]  ; SSYSINITVARS offset 34 = [SI+SYSI.DEV]
 11396 000018DA 8B4422                  	MOV	AX,[SI+SYSI.DEV]
 11397                                  	;mov	bx,[si+36]  ; SSYSINITVARS offset 36 = [SI+SYSI.DEV+2]
 11398 000018DD 8B5C24                  	MOV	BX,[SI+SYSI.DEV+2]
 11399 000018E0 C3                      	RETN
 11400                                  
 11401                                  ;Break	<NLS_IOCTL - do $IOCTL for NLSFUNC>
 11402                                  ;----------------------------------------------------------------------------
 11403                                  ;   DOS 3.3   7/25/86
 11404                                  ;   NLS_IOCTL	- call $IOCTL for NLSFUNC
 11405                                  ;
 11406                                  ;   Inputs:	BP = function code 0CH
 11407                                  ;   Outputs:	same output as generic $IOCTL
 11408                                  ;
 11409                                  ;----------------------------------------------------------------------------
 11410                                  
 11411                                  NLS_IOCTL:
 11412                                  	; 16/05/2019 - Retro DOS v4.0
 11413 000018E1 36FF36[8405]            	PUSH	word [SS:USER_SP] ; save user stack
 11414 000018E6 36FF36[8605]            	PUSH	word [SS:USER_SS]
 11415 000018EB E8D3FF                  	CALL	Fake_User_Stack
 11416 000018EE 89E8                    	MOV	AX,BP		; set up correct interface for $IOCTL
 11417 000018F0 E8BB0F                  	call	_$IOCTL
 11418 000018F3 368F06[8605]            	POP	word [SS:USER_SS] ; restore user stack
 11419 000018F8 368F06[8405]            	POP	word [SS:USER_SP]
 11420 000018FD C3                      	RETN
 11421                                  
 11422                                  ;Break	<NLS_GETEXT- get extended error for NLSFUNC>
 11423                                  ;----------------------------------------------------------------------------
 11424                                  ;   DOS 3.3   7/25/86
 11425                                  ;   NLS_GETEXT	-
 11426                                  ;
 11427                                  ;   Inputs:	none
 11428                                  ;   Outputs:	AX = extended error
 11429                                  ;
 11430                                  ;----------------------------------------------------------------------------
 11431                                  
 11432                                  NLS_GETEXT:
 11433                                  	; 16/05/2019 - Retro DOS v4.0
 11434 000018FE 36A1[2403]              	MOV	AX,[SS:EXTERR]	 ; return extended error
 11435                                  	; 23/09/2023
 11436                                  MSG_RETRIEVAL:
 11437 00001902 C3                      	RETN
 11438                                  
 11439                                  ; 29/04/2019 - Retro DOS v4.0
 11440                                  
 11441                                  ;Break	<MSG_RETRIEVAL- get beginning addr of system and parser messages>
 11442                                  
 11443                                  ;----------------------------------------------------------------------------
 11444                                  ;   DOS 4.00
 11445                                  ;
 11446                                  ;   Inputs:	DL=0 get extended error message addr
 11447                                  ;		  =1 set extended error message addr
 11448                                  ;		  =2 get parser error message addr
 11449                                  ;		  =3 set parser error message addr
 11450                                  ;		  =4 get critical error message addr
 11451                                  ;		  =5 set critical error message addr
 11452                                  ;		  =6 get file system error message addr
 11453                                  ;		  =7 set file system error message addr
 11454                                  ;		  =8 get address for code reduction
 11455                                  ;		  =9 set address for code reduction
 11456                                  ;   Function:	get/set message address
 11457                                  ;   Outputs:	ES:DI points to addr when get
 11458                                  ;----------------------------------------------------------------------------
 11459                                  
 11460                                  ;Procedure MSG_RETRIEVAL,NEAR
 11461                                  ;	ASSUME	CS:DOSCODE,SS:NOTHING
 11462                                  
 11463                                  ; 23/09/2023
 11464                                  ;MSG_RETRIEVAL:
 11465                                  
 11466                                  ;;	NOTE:  This function lives in command.com resident code now.
 11467                                  ;;	If the int 2F ever gets this far, we'll return registers
 11468                                  ;;	unchanged, which produces the same result as before, if
 11469                                  ;;	command.com wasn't present (and therefore no messages available).
 11470                                  ;;
 11471                                  ;;	I didn't point the entry in the 2F table to No_Op because
 11472                                  ;;	No_Op zeroes AL.
 11473                                  ;;
 11474                                  ;;;hkn; set up ds to point to DOSDATA
 11475                                  ;;	push	ds
 11476                                  ;;	getdseg	<ds>			; ds -> dosdata
 11477                                  ;;
 11478                                  ;;	PUSH	AX		    ;AN000;;MS. save regs
 11479                                  ;;	PUSH	SI		    ;AN000;;MS. save regs
 11480                                  ;;	MOV	AX,DX		    ;AN000;;MS.
 11481                                  ;;	MOV	SI,OFFSET DOSDATA:MSG_EXTERROR ;AN000;;MS.
 11482                                  ;;	test	AL,1		    ;AN000;;MS. get ?
 11483                                  ;;	JZ	toget		    ;AN000;;MS. yes
 11484                                  ;;	DEC	AL		    ;AN000;;MS.
 11485                                  ;;toget:				    ;AN000;
 11486                                  ;;	SHL	AL,1		    ;AN000;;MS. times 2
 11487                                  ;;	XOR	AH,AH		    ;AN000;;MS.
 11488                                  ;;	ADD	SI,AX		    ;AN000;;MS. position to the entry
 11489                                  ;;	test	DL,1		    ;AN000;;MS. get ?
 11490                                  ;;	JZ	getget			     ;AN000;;MS. yes
 11491                                  ;;	MOV	WORD PTR DS:[SI],DI    ;AN000;;MS. set MSG
 11492                                  ;;	MOV	WORD PTR DS:[SI+2],ES  ;AN000;;MS. address to ES:DI
 11493                                  ;;	JMP	SHORT MSGret		     ;AN000;;MS. exit
 11494                                  ;;getget: 				     ;AN000;
 11495                                  ;;	LES	DI,DWORD PTR DS:[SI]	     ;AN000;;MS. get msg addr
 11496                                  ;;MSGret: 				     ;AN000;
 11497                                  ;;	POP	SI			     ;AN000;;MS.
 11498                                  ;;	POP	AX			     ;AN000;;MS.
 11499                                  ;;
 11500                                  ;;	pop	ds
 11501                                  
 11502                                  ;	return				     ;AN000;;MS. exit
 11503                                  
 11504                                  ; 23/09/2023
 11505                                  ;	retn	; 29/04/2019
 11506                                  
 11507                                  ;============================================================================
 11508                                  ; ECritDisk, LCritDisk, ECritDevice, LCritDevice
 11509                                  ; IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1F36h
 11510                                  ;============================================================================
 11511                                  ; 20/07/2018 - Retro DOS v3.0
 11512                                  
 11513                                  ;	; MSDOS 3.3
 11514                                  ;	; 08/08/2018 - Retro DOS v3.0
 11515                                  ;ECritMEM:
 11516                                  ;ECritSFT:
 11517                                  ;	;
 11518                                  ;ECritDisk:
 11519                                  ;	retn
 11520                                  ;	;push	ax
 11521                                  ;	
 11522                                  ;	mov	ax,8001h
 11523                                  ;	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
 11524                                  ;			; AL = critical section number (00h-0Fh)
 11525                                  ;	pop	ax
 11526                                  ;	retn
 11527                                  ;
 11528                                  ;	; MSDOS 3.3
 11529                                  ;	; 08/08/2018 - Retro DOS v3.0
 11530                                  ;LCritMEM:
 11531                                  ;LCritSFT:
 11532                                  ;	;
 11533                                  ;LCritDisk:
 11534                                  ;	retn
 11535                                  ;	;push	ax
 11536                                  ;	
 11537                                  ;	mov	ax,8101h
 11538                                  ;	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
 11539                                  ;			; AL = critical section number (00h-0Fh)
 11540                                  ;	pop	ax
 11541                                  ;	retn
 11542                                  ;
 11543                                  ;ECritDevice:
 11544                                  ;	retn
 11545                                  ;	;push	ax
 11546                                  ;	
 11547                                  ;	mov	ax,8002h
 11548                                  ;	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
 11549                                  ;			; AL = critical section number (00h-0Fh)
 11550                                  ;	pop	ax
 11551                                  ;	retn
 11552                                  ;
 11553                                  ;LCritDevice:
 11554                                  ;	retn
 11555                                  ;	;push	ax
 11556                                  ;	
 11557                                  ;	mov	ax,8102h
 11558                                  ;	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
 11559                                  ;			; AL = critical section number (00h-0Fh)
 11560                                  ;	pop	ax
 11561                                  ;	retn
 11562                                  
 11563                                  ;============================================================================
 11564                                  ; CRIT.ASM, MSDOS 6.0, 1991
 11565                                  ;============================================================================
 11566                                  ; 12/05/2019 - Retro DOS v4.0
 11567                                  
 11568                                  ; Critical Section Routines
 11569                                  
 11570                                  ; MSDOS 6.21 - MSDOS.SYS - DOSCODE:513Ah
 11571                                  
 11572                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11573                                  ; DOSCODE:5126h (MSDOS 5.0 MSDOS.SYS)
 11574                                  
 11575                                  ; ---------------------------------------------------------------------------
 11576                                  ; Each handler must leave everything untouched; including flags!
 11577                                  ;
 11578                                  ; Sleaze for time savings: first instruction is a return. This is patched
 11579                                  ; by the sharer to be a PUSH AX to complete the correct routines.
 11580                                  ; ---------------------------------------------------------------------------
 11581                                  
 11582                                  ; (DOSMAC.INC, MSDOS 6.0, 1991)
 11583                                  ; ---------------------------------------------------------------------------
 11584                                  ; Some old versions of the 80286 have a bug in the chip. The popf instruction
 11585                                  ; will enable interrupts. Therefore in a section of code with interrupts
 11586                                  ; disabled and you need a popf instruction use the 'popff' macro instead.
 11587                                  ; ---------------------------------------------------------------------------
 11588                                  
 11589                                  ;%macro POPFF 0
 11590                                  ;	jmp	$+3
 11591                                  ;	iret
 11592                                  ;	push	cs
 11593                                  ;	call	$-2
 11594                                  ;%endmacro
 11595                                  
 11596                                  ; ---------------------------
 11597                                  
 11598                                  ; 14/01/2024 - Retro DOS v5.0
 11599                                  %if 0
 11600                                  
 11601                                  ;Procedure  ECritDisk,NEAR
 11602                                  	;public  ECritMEM
 11603                                  	;public  ECritSFT
 11604                                  ECritMEM:
 11605                                  ECritSFT:
 11606                                  ;
 11607                                  ECritDisk:
 11608                                  
 11609                                  ;SR; Check if critical section is to be entered
 11610                                  
 11611                                  	pushf
 11612                                  	cmp	byte [ss:redir_patch],0
 11613                                  	jz	short ECritDisk_2
 11614                                  
 11615                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11616                                  ;	;popff  ; * (macro)
 11617                                  ;	jmp	short ECritDisk_1 ; *
 11618                                  ;
 11619                                  ;ECritDisk_iret: ; *
 11620                                  ;	iret ; *
 11621                                  
 11622                                  	; 16/12/2022
 11623                                  	; 13/11/2022
 11624                                  	;jmp	short ECritDisk_1
 11625                                  	; 06/11/2022
 11626                                  ;ECritDisk_iret:
 11627                                  ;	iret	
 11628                                  
 11629                                  	; 06/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11630                                  ECritDisk_1:
 11631                                  	push	cs ; *
 11632                                  	call	ECritDisk_iret ; *		
 11633                                  	
 11634                                  ECritDisk_0:
 11635                                  	PUSH    AX
 11636                                  	;MOV	AX,8000h+critDisk
 11637                                  	;INT	int_IBM
 11638                                  	mov	ax,8001h
 11639                                  	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
 11640                                  			; AL = critical section number (00h-0Fh)
 11641                                  	POP     AX
 11642                                  	retn
 11643                                  
 11644                                  	; 16/12/2022
 11645                                  	; 13/11/2022
 11646                                  ECritDisk_iret:  ; 12/05/2019 - Retro DOS v4.0
 11647                                  LCritDisk_iret: 
 11648                                  	iret
 11649                                  
 11650                                  ECritDisk_2:
 11651                                  	;;popff ; *
 11652                                  	;;retn
 11653                                  ;	jmp	short ECritDisk_3 ; *
 11654                                  ;ECritDisk_iret2: ; *
 11655                                  ;	iret
 11656                                  	
 11657                                  	; 16/12/2022
 11658                                  	; 13/11/2022
 11659                                  	;jmp	short ECritDisk_3
 11660                                  ;ECritDisk_iret2:
 11661                                  	;iret
 11662                                  
 11663                                  ECritDisk_3:
 11664                                  	push    cs ; *
 11665                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11666                                  	;call	ECritDisk_iret2 ; *
 11667                                  	;retn
 11668                                  	; 16/12/2022
 11669                                  	call	ECritDisk_iret
 11670                                  	retn
 11671                                  
 11672                                  ;EndProc ECritDisk
 11673                                  
 11674                                  ; ---------------------------
 11675                                  
 11676                                  ;Procedure   LCritDisk,NEAR
 11677                                  	;public  LCritMEM
 11678                                  	;public  LCritSFT
 11679                                  LCritMEM:
 11680                                  LCritSFT:
 11681                                  ;
 11682                                  LCritDisk:
 11683                                  
 11684                                  ;SR; Check if critical section is to be entered
 11685                                  
 11686                                  	pushf
 11687                                  	cmp	byte [ss:redir_patch],0
 11688                                  	jz	short LCritDisk_2
 11689                                  	;popff  ; * (macro)
 11690                                  ;	jmp	short LCritDisk_1 ; *
 11691                                  ;
 11692                                  ;LCritDisk_iret: ; *
 11693                                  ;	iret ; *
 11694                                  
 11695                                  	; 16/12/2022
 11696                                  	; 13/11/2022
 11697                                  	;jmp	short LCritDisk_1
 11698                                  ;LCritDisk_iret:
 11699                                  	;iret
 11700                                  
 11701                                  LCritDisk_1:
 11702                                  	push	cs ; *
 11703                                  	call	LCritDisk_iret ; *		
 11704                                  	
 11705                                  LCritDisk_0:
 11706                                  	PUSH	AX
 11707                                  	;MOV	AX,8100h+critDisk
 11708                                  	;INT	int_IBM
 11709                                  	mov	ax,8101h
 11710                                  	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
 11711                                  			; AL = critical section number (00h-0Fh)
 11712                                  	POP	AX
 11713                                  	retn
 11714                                  
 11715                                  ;LCritDisk_iret:  ; 12/05/2019 - Retro DOS v4.0 
 11716                                  ;	iret
 11717                                  
 11718                                  LCritDisk_2:
 11719                                  	;;popff ; *
 11720                                  	;;retn
 11721                                  ;	jmp	short LCritDisk_3 ; *
 11722                                  ;LCritDisk_iret2: ; *
 11723                                  ;	iret
 11724                                  
 11725                                  	; 16/12/2022
 11726                                  	; 13/11/2022
 11727                                  	;jmp	short LCritDisk_3
 11728                                  ;LCritDisk_iret2:
 11729                                  	;iret
 11730                                  
 11731                                  LCritDisk_3:
 11732                                  	push    cs ; *
 11733                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11734                                  	;call	LCritDisk_iret2 ; *
 11735                                  	;retn
 11736                                  	; 16/12/2022
 11737                                  	call	LCritDisk_iret
 11738                                  	retn
 11739                                  
 11740                                  ;EndProc LCritDisk
 11741                                  
 11742                                  ; ---------------------------
 11743                                  
 11744                                  ;Procedure   ECritDevice,NEAR
 11745                                  
 11746                                  ECritDevice:
 11747                                  
 11748                                  ;SR; Check if critical section is to be entered
 11749                                  
 11750                                  	pushf
 11751                                  	cmp	byte [ss:redir_patch],0
 11752                                  	jz	short ECritDevice_2
 11753                                  	;popff  ; * (macro)
 11754                                  ;	jmp	short ECritDevice_1 ; *
 11755                                  ;
 11756                                  ;ECritDevice_iret: ; *
 11757                                  ;	iret ; *
 11758                                  
 11759                                  	; 16/12/2022	
 11760                                  	; 13/11/2022
 11761                                  	;jmp	short ECritDevice_1
 11762                                  ;ECritDevice_iret:
 11763                                  	;iret
 11764                                  
 11765                                  ECritDevice_1:
 11766                                  	push	cs ; *
 11767                                  	call	ECritDevice_iret ; *		
 11768                                  	
 11769                                  ECritDevice_0:
 11770                                  	PUSH	AX
 11771                                  	;MOV	AX,8000h+critDevice
 11772                                  	;INT	int_IBM
 11773                                  	mov	ax,8002h
 11774                                  	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
 11775                                  			; AL = critical section number (00h-0Fh)
 11776                                  	POP     AX
 11777                                  	retn
 11778                                  
 11779                                  	; 16/12/2022
 11780                                  	; 06/12/2022
 11781                                  ECritDevice_iret:  ; 12/05/2019 - Retro DOS v4.0
 11782                                  LCritDevice_iret: 
 11783                                  	iret
 11784                                  
 11785                                  ECritDevice_2:
 11786                                  	;;popff ; *
 11787                                  	;;retn
 11788                                  ;	jmp	short ECritDevice_3 ; *
 11789                                  ;ECritDevice_iret2: ; *
 11790                                  ;	iret
 11791                                  
 11792                                  	; 16/12/2022
 11793                                  	; 13/11/2022
 11794                                  	;jmp	short ECritDevice_3
 11795                                  ;ECritDevice_iret2:
 11796                                  	;iret
 11797                                  
 11798                                  ECritDevice_3:
 11799                                  	push    cs ; *
 11800                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11801                                  	;call	ECritDevice_iret2 ; *
 11802                                  	;retn
 11803                                  	; 16/12/2022
 11804                                  	call	ECritDevice_iret
 11805                                  	retn
 11806                                  
 11807                                  ;EndProc ECritDevice
 11808                                  
 11809                                  ; ---------------------------
 11810                                  
 11811                                  ;Procedure   LCritDevice,NEAR
 11812                                  
 11813                                  LCritDevice:
 11814                                  
 11815                                  ;SR; Check if critical section is to be entered
 11816                                  
 11817                                  	pushf
 11818                                  	cmp	byte [ss:redir_patch],0
 11819                                  	jz	short LCritDevice_2
 11820                                  	;popff  ; * (macro)
 11821                                  ;	jmp	short LCritDevice_1 ; *
 11822                                  ;
 11823                                  ;LCritDevice_iret: ; *
 11824                                  ;	iret ; *
 11825                                  
 11826                                  	; 16/12/2022
 11827                                  	; 13/11/2022
 11828                                  	;jmp	short LCritDevice_1
 11829                                  ;LCritDevice_iret:
 11830                                  	;iret
 11831                                  
 11832                                  LCritDevice_1:
 11833                                  	push	cs ; *
 11834                                  	call	LCritDevice_iret ; *		
 11835                                  	
 11836                                  LCritDevice_0:
 11837                                  	PUSH	AX
 11838                                  	;MOV	AX,8100h+critDevice
 11839                                  	;INT	int_IBM
 11840                                  	mov	ax,8102h
 11841                                  	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
 11842                                  			; AL = critical section number (00h-0Fh)
 11843                                  	POP     AX
 11844                                  	retn
 11845                                  
 11846                                  ;LCritDevice_iret:  ; 12/05/2019 - Retro DOS v4.0 
 11847                                  ;	iret
 11848                                  
 11849                                  LCritDevice_2:
 11850                                  	;;popff ; *
 11851                                  	;;retn
 11852                                  ;	jmp	short LCritDevice_3 ; *
 11853                                  ;LCritDevice_iret2: ; *
 11854                                  ;	iret
 11855                                  
 11856                                  	; 16/12/2022
 11857                                  	; 13/11/2022
 11858                                  	;jmp	short LCritDevice_3
 11859                                  ;LCritDevice_iret2:
 11860                                  	;iret
 11861                                  
 11862                                  LCritDevice_3:
 11863                                  	push    cs ; *
 11864                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11865                                  	;call	LCritDevice_iret2 ; *
 11866                                  	;retn
 11867                                  	; 16/12/2022
 11868                                  	call	LCritDevice_iret
 11869                                  	retn
 11870                                  
 11871                                  ;EndProc LCritDevice
 11872                                  
 11873                                  %endif
 11874                                  
 11875                                  	; 15/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1)
 11876                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:580Dh
 11877                                  
 11878                                  ; 15/01/2024 - Retro DOS v5.0
 11879                                  %if 1
 11880                                  	;;;
 11881                                  ; ---------------------------------------------------------------------------
 11882                                  ECritMEM:
 11883                                  ECritSFT:
 11884                                  ; ---------------------------------------------------------------------------
 11885                                  	; PCDOS 7.1 IBMDOS.COM
 11886                                  ECritDisk:
 11887 00001903 51                      	push	cx
 11888 00001904 B500                    	mov	ch,0
 11889 00001906 368A0E[860D]            	mov	cl,[ss:redir_patch]
 11890 0000190B E321                    	jcxz	ECritDisk_3
 11891 0000190D 59                      	pop	cx
 11892 0000190E 50                      	push	ax
 11893 0000190F B80180                  	mov	ax,8001h	; BEGIN DOS CRITICAL SECTION
 11894                                  				; AL = critical section number (01h)
 11895                                  ECritDisk_1:
 11896                                  ; ----------------------------------------
 11897                                  LCritDisk_1:
 11898                                  ECritDevice_1:
 11899                                  LCritDevice_1:
 11900 00001912 51                      	push	cx
 11901 00001913 B500                    	mov	ch,0
 11902 00001915 368A0E[A110]            	mov	cl,[ss:IsWin386]
 11903 0000191A E305                    	jcxz	ECritDisk2
 11904 0000191C 59                      	pop	cx
 11905 0000191D CD2A                    	int	2Ah		; Microsoft Networks - BEGIN DOS CRITICAL SECTION
 11906                                  				; AL = critical section number (00h-0Fh)
 11907 0000191F 58                      	pop	ax
 11908 00001920 C3                      	retn
 11909                                  
 11910                                  ECritDisk2:
 11911 00001921 06                      	push	es
 11912                                  	;mov	cx,0
 11913                                  	; 15/01/2024
 11914                                  	; cx = 0
 11915 00001922 8EC1                    	mov	es,cx
 11916 00001924 9C                      	pushf			; simulate INT 2Ah
 11917 00001925 26FF1EA800              	call	far [es:00A8h]	; call far (INT 2Ah vector)
 11918 0000192A 07                      	pop	es
 11919 0000192B 59                      	pop	cx
 11920 0000192C 58                      	pop	ax
 11921 0000192D C3                      	retn
 11922                                  
 11923                                  ECritDisk_3:
 11924                                  ; ----------------------------------------
 11925                                  LCritDisk_3:
 11926                                  ECritDevice_3:
 11927                                  LCritDevice_3:
 11928 0000192E 59                      	pop	cx
 11929 0000192F C3                      	retn
 11930                                  
 11931                                  ; ---------------------------------------------------------------------------
 11932                                  LCritMEM:
 11933                                  LCritSFT:
 11934                                  ; ---------------------------------------------------------------------------
 11935                                  	; PCDOS 7.1 IBMDOS.COM
 11936                                  LCritDisk:
 11937 00001930 51                      	push	cx
 11938 00001931 B500                    	mov	ch,0
 11939 00001933 368A0E[860D]            	mov	cl,[ss:redir_patch]
 11940 00001938 E3F4                    	jcxz	LCritDisk_3
 11941 0000193A 59                      	pop	cx
 11942 0000193B 50                      	push	ax
 11943 0000193C B80181                  	mov	ax,8101h	; END DOS CRITICAL SECTION
 11944                                  				; AL = critical section number (01h)
 11945 0000193F EBD1                    	jmp	short LCritDisk_1
 11946                                  
 11947                                  ; ---------------------------------------------------------------------------
 11948                                  
 11949                                  ECritDevice:
 11950 00001941 51                      	push	cx
 11951 00001942 B500                    	mov	ch,0
 11952 00001944 368A0E[860D]            	mov	cl,[ss:redir_patch]
 11953 00001949 E3E3                    	jcxz	ECritDevice_3
 11954 0000194B 59                      	pop	cx
 11955 0000194C 50                      	push	ax
 11956 0000194D B80280                  	mov	ax,8002h	; BEGIN DOS CRITICAL SECTION
 11957                                  				; AL = critical section number (02h)
 11958 00001950 EBC0                    	jmp	short ECritDevice_1
 11959                                  
 11960                                  ; ---------------------------------------------------------------------------
 11961                                  
 11962                                  LCritDevice:
 11963 00001952 51                      	push	cx
 11964 00001953 B500                    	mov	ch,0
 11965 00001955 368A0E[860D]            	mov	cl,[ss:redir_patch]
 11966 0000195A E3D2                    	jcxz	LCritDevice_3
 11967 0000195C 59                      	pop	cx
 11968 0000195D 50                      	push	ax
 11969 0000195E B80281                  	mov	ax,8102h	; END DOS CRITICAL SECTION
 11970                                  				; AL = critical section number (02h)
 11971 00001961 EBAF                    	jmp	short LCritDevice_1
 11972                                  
 11973                                  ; ---------------------------------------------------------------------------
 11974                                  	;;;
 11975                                  %endif
 11976                                  
 11977                                  ;============================================================================
 11978                                  ; CPMIO.ASM, MSDOS 6.0, 1991
 11979                                  ;============================================================================
 11980                                  ; 20/07/2018 - Retro DOS v3.0
 11981                                  
 11982                                  ;============================================================================
 11983                                  ; STDIO.ASM - (MSDOS 2.0)
 11984                                  ;============================================================================
 11985                                  
 11986                                  ;
 11987                                  ; Standard device IO for MSDOS (first 12 function calls)
 11988                                  ;
 11989                                  
 11990                                  ;.xlist
 11991                                  ;.xcref
 11992                                  ;INCLUDE STDSW.ASM
 11993                                  ;INCLUDE DOSSEG.ASM
 11994                                  ;.cref
 11995                                  ;.list
 11996                                  
 11997                                  ;TITLE   STDIO - device IO for MSDOS
 11998                                  ;NAME    STDIO
 11999                                  
 12000                                  ;INCLUDE IO.ASM
 12001                                  
 12002                                  ; ---------------------------------------------------------------------------
 12003                                  ;
 12004                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
 12005                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
 12006                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
 12007                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
 12008                                  ;			    to restore MSDOS 2.0 device IO source code 
 12009                                  ;
 12010                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)	
 12011                                  	
 12012                                  ;============================================================================
 12013                                  ; STDIO.ASM - (MSDOS 2.0)
 12014                                  ;============================================================================
 12015                                  
 12016                                  ;
 12017                                  ; Standard device IO for MSDOS (first 12 function calls)
 12018                                  ;
 12019                                  
 12020                                  ;.xlist
 12021                                  ;.xcref
 12022                                  ;INCLUDE STDSW.ASM
 12023                                  ;INCLUDE DOSSEG.ASM
 12024                                  ;.cref
 12025                                  ;.list
 12026                                  
 12027                                  ;TITLE   STDIO - device IO for MSDOS
 12028                                  ;NAME    STDIO
 12029                                  
 12030                                  ;INCLUDE IO.ASM
 12031                                  
 12032                                  ; ---------------------------------------------------------------------------
 12033                                  ;
 12034                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
 12035                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
 12036                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
 12037                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
 12038                                  ;			    to restore MSDOS 2.0 device IO source code 
 12039                                  ;
 12040                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)		
 12041                                  ;
 12042                                  ;============================================================================
 12043                                  ; IO.ASM (MSDOS 2.0) (IBMDOS.COM 2.0) - STRIN.ASM (MSDOS 2.0, 19/08/1983)
 12044                                  ;============================================================================
 12045                                  ; Retro DOS v2.0 by Erdogan Tan, 13/03/2018 - 14/03/2018
 12046                                  
 12047                                  ; (Disassembled code of IBMDOS.COM, 08/03/1983) - Dissassembler: IDA Pro Free
 12048                                  ; (Comments are from CPMIO.ASM - 1991, MSDOS 6.0) 
 12049                                  
 12050                                  ;============================================================================
 12051                                  ; CPMIO.ASM (MSDOS 6.0, 1991)
 12052                                  ;============================================================================
 12053                                  ; Retro DOS v4.0 by Erdogan Tan, 04/05/2019
 12054                                  
 12055                                  	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12056                                  
 12057                                  ;**	Standard device IO for MSDOS (first 12 function calls)
 12058                                  ;
 12059                                  ;	TITLE	IBMCPMIO - device IO for MSDOS
 12060                                  ;	NAME	IBMCPMIO
 12061                                  
 12062                                  ;	Old style CP/M 1-12 system calls to talk to reserved devices
 12063                                  ;
 12064                                  ;	$Std_Con_Input_No_Echo
 12065                                  ;	$Std_Con_String_Output
 12066                                  ;	$Std_Con_String_Input
 12067                                  ;	$RawConIO
 12068                                  ;	$RawConInput
 12069                                  ;	RAWOUT
 12070                                  ;	RAWOUT2
 12071                                  ;
 12072                                  
 12073                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
 12074                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
 12075                                  ; references to be SS or CS relative which is desired.
 12076                                  
 12077                                  ; ---------------------------------------------------------------------------
 12078                                  
 12079                                  ;	TITLE	CPMIO2 - device IO for MSDOS
 12080                                  ;	NAME	CPMIO2
 12081                                  
 12082                                  ;
 12083                                  ;	Microsoft Confidential
 12084                                  ;	Copyright (C) Microsoft Corporation 1991
 12085                                  ;	All Rights Reserved.
 12086                                  ;
 12087                                  
 12088                                  ;**	Old style CP/M 1-12 system calls to talk to reserved devices
 12089                                  ;
 12090                                  ;	$Std_Con_Input
 12091                                  ;	$Std_Con_Output
 12092                                  ;	OUTT
 12093                                  ;	TAB
 12094                                  ;	BUFOUT
 12095                                  ;	$Std_Aux_Input
 12096                                  ;	$Std_Aux_Output
 12097                                  ;	$Std_Printer_Output
 12098                                  ;	$Std_Con_Input_Status
 12099                                  ;	$Std_Con_Input_Flush
 12100                                  ;
 12101                                  ;	Revision History:
 12102                                  ;
 12103                                  ;	  AN000	 version 4.00 - Jan. 1988
 12104                                  
 12105                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
 12106                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
 12107                                  ; references to be SS or CS relative which is desired.
 12108                                  
 12109                                  ;DOSCODE SEGMENT
 12110                                  ;	ASSUME	SS:DOSDATA,CS:DOSCODE
 12111                                  
 12112                                  
 12113                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
 12114                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
 12115                                  ;hkn;	not valid. 
 12116                                  
 12117                                  ; DOSCODE:51BAh (MSDOS 6.21, MSDOS.SYS)
 12118                                  ; 08/11/2022
 12119                                  ; DOSCODE:51A6h (MSDOS 5.0, MSDOS.SYS)
 12120                                  
 12121                                  ;
 12122                                  ;----------------------------------------------------------------------------
 12123                                  ;
 12124                                  ; Procedure : $Std_Con_Input_No_Echo
 12125                                  ;
 12126                                  ;----------------------------------------------------------------------------
 12127                                  ;
 12128                                  
 12129                                  _$STD_CON_INPUT_NO_ECHO:   ;System call 8
 12130                                  
 12131                                  ; Inputs:
 12132                                  ;	None
 12133                                  ; Function:
 12134                                  ;	Input character from console, no echo
 12135                                  ; Returns:
 12136                                  ;	AL = character
 12137                                  
 12138 00001963 1E                      	push	ds
 12139 00001964 56                      	push	si
 12140                                  INTEST:
 12141 00001965 E8B141                  	call	STATCHK
 12142 00001968 753B                    	jnz	short GET ; 08/09/2018
 12143                                  ;*************************************************************************
 12144                                  ;hkn; SS override
 12145 0000196A 36803E[A00A]00          	cmp	byte [SS:PRINTER_FLAG],0  ; is printer idle?
 12146 00001970 7505                    	jnz	short no_sys_wait
 12147 00001972 B405                    	mov	ah,5			; get input status with system wait
 12148 00001974 E8D934                  	call	IOFUNC
 12149                                  no_sys_wait:
 12150                                  ;**************************************************************************
 12151 00001977 B484                    	MOV	AH,84h		; (Microsoft Networks - KEYBOARD BUSY LOOP)
 12152 00001979 CD2A                    	INT	int_IBM	 ; int 2Ah
 12153                                  
 12154                                  ;;; 7/15/86  update the date in the idle loop
 12155                                  ;;; Dec 19, 1986 D.C.L. changed following CMP to Byte Ptr from Word Ptr
 12156                                  ;;;;		 to shorten loop in consideration of the PC Convertible
 12157                                  
 12158                                  ;hkn; SS override
 12159 0000197B 36803E[E20D]FF          	CMP	byte [SS:DATE_FLAG],-1	; date is updated may be every
 12160 00001981 751B                    	JNZ	short NoUpdate		; 65535 x ? ms if no one calls
 12161                                  
 12162 00001983 50                      	PUSH	AX
 12163 00001984 53                      	PUSH	BX			; following is tricky,
 12164 00001985 51                      	PUSH	CX			; it may be called by critical handler
 12165 00001986 52                      	PUSH	DX			; at that time, DEVCALL is used by
 12166                                  					; other's READ or WRITE
 12167 00001987 1E                      	PUSH	DS			; save DS = SFT's segment
 12168                                  
 12169                                  ;hkn; READTIME must use ds = DOSDATA
 12170                                  ;hkn;	PUSH	CS			; READTIME must use DS=CS
 12171                                  
 12172 00001988 16                      	PUSH	SS ; 04/05/2019
 12173 00001989 1F                      	POP	DS
 12174                                  
 12175 0000198A B80000                  	MOV	AX,0			; therefore, we save DEVCALL
 12176 0000198D E89402                  	CALL	Save_Restore_Packet	; save DEVCALL packet
 12177                                  	;invoke	READTIME		; readtime
 12178 00001990 E803F2                  	call	READTIME
 12179 00001993 B80100                  	MOV	AX,1
 12180 00001996 E88B02                  	CALL	Save_Restore_Packet	; restore DEVCALL packet
 12181                                  
 12182                                  ;	; MSDOS 3.3 (IBMDOS.COM, Offset 1F8Ch)
 12183                                  ;	; (MSDOS 6.0 code does not contain IBM DOS FETCHI_TAG check)
 12184                                  ;	push	bx
 12185                                  ;	mov	bx,DATE_FLAG
 12186                                  ;	add	bx,2  ; mov bx,FETCHI_FLAG
 12187                                  ;	cmp	word [cs:bx],5872h
 12188                                  ;	jz	short FETCHI_TAG_chk_ok
 12189                                  ;	call	DOSINIT
 12190                                  ;FETCHI_TAG_chk_ok:
 12191                                  ;	pop	bx
 12192                                  
 12193 00001999 1F                      	POP	DS			; restore DS
 12194 0000199A 5A                      	POP	DX
 12195 0000199B 59                      	POP	CX
 12196 0000199C 5B                      	POP	BX
 12197 0000199D 58                      	POP	AX
 12198                                  NoUpdate:
 12199                                  
 12200                                  ;hkn; SS override
 12201 0000199E 36FF06[E20D]            	INC	word [SS:DATE_FLAG]
 12202                                  
 12203                                  ;;; 7/15/86 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 12204 000019A3 EBC0                    	JMP	short INTEST
 12205                                  GET:
 12206 000019A5 30E4                    	XOR	AH,AH
 12207 000019A7 E8A634                  	call	IOFUNC
 12208 000019AA 5E                      	POP	SI
 12209 000019AB 1F                      	POP	DS
 12210                                  ;;; 7/15/86
 12211                                  
 12212                                  ;hkn; SS override
 12213                                  	; MSDOS 6.0
 12214 000019AC 36C606[E10D]00          	MOV	BYTE [SS:SCAN_FLAG],0
 12215                                  	;
 12216 000019B2 3C00                    	CMP	AL,0	    ; extended code ( AL )
 12217 000019B4 7505                    	JNZ	short noscan
 12218                                  
 12219                                  ;hkn; SS override
 12220                                  	;MOV	BYTE [SS:SCAN_FLAG],1 ; set this flag for ALT_Q key
 12221                                  	; 20/06/2023
 12222 000019B6 36FE06[E10D]            	inc	byte [SS:SCAN_FLAG]
 12223                                  noscan:
 12224 000019BB C3                      	retn
 12225                                  ;
 12226                                  ;----------------------------------------------------------------------------
 12227                                  ;
 12228                                  ;**	$STD_CON_STRING_OUTPUT - Console String Output
 12229                                  ;
 12230                                  ;
 12231                                  ;	ENTRY	(DS:DX) Point to output string '$' terminated
 12232                                  ;	EXIT	none
 12233                                  ;	USES	ALL
 12234                                  ;
 12235                                  ;----------------------------------------------------------------------------
 12236                                  ;
 12237                                  
 12238                                  _$STD_CON_STRING_OUTPUT:	;System call 9
 12239                                  
 12240 000019BC 89D6                    	mov	si,dx
 12241                                  STRING_OUT1:	
 12242 000019BE AC                      	lodsb
 12243 000019BF 3C24                    	cmp	al,'$'
 12244 000019C1 74F8                    	je	short noscan
 12245                                  NEXT_STR1:
 12246 000019C3 E88702                  	call	OUTT
 12247 000019C6 EBF6                    	jmp	short STRING_OUT1
 12248                                  
 12249                                  ;----------------------------------------------------------------------------
 12250                                  ;
 12251                                  ;**	$STD_CON_STRING_INPUT - Input Line from Console
 12252                                  ;
 12253                                  ;	$STD_CON_STRING_INPUT Fills a buffer from console input until CR
 12254                                  ;
 12255                                  ;	ENTRY	(ds:dx) = input buffer
 12256                                  ;	EXIT	none
 12257                                  ;	USES	ALL
 12258                                  ;
 12259                                  ;----------------------------------------------------------------------------
 12260                                  
 12261                                  	; 15/01/2024 - Retro DOS v5.0
 12262                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:58D4h
 12263                                  
 12264                                  _$STD_CON_STRING_INPUT:		;System call 10
 12265                                  
 12266                                  	; 15/01/2024
 12267                                  	;mov	ax,ss
 12268                                  	;mov	es,ax
 12269 000019C8 16                      	push	ss
 12270 000019C9 07                      	pop	es
 12271                                  
 12272 000019CA 89D6                    	mov	si,dx
 12273 000019CC 30ED                    	xor	ch,ch
 12274 000019CE AD                      	lodsw
 12275                                  
 12276                                  ;	(AL) = the buffer length
 12277                                  ;	(AH) = the template length
 12278                                  
 12279 000019CF 08C0                            or	al,al
 12280 000019D1 74E8                            jz	short noscan	;Buffer is 0 length!!?
 12281 000019D3 88E3                    	mov	bl,ah		;Init template counter
 12282 000019D5 88EF                            mov	bh,ch		;Init template counter
 12283                                  
 12284                                  ;	(BL) = the number of bytes in the template
 12285                                  
 12286 000019D7 38D8                            cmp	al,bl
 12287 000019D9 7605                            jbe	short NOEDIT	;If length of buffer inconsistent with contents
 12288 000019DB 80380D                          cmp	byte [bx+si],c_CR ; 0Dh
 12289 000019DE 7402                            jz	short EDITON	;If CR correctly placed EDIT is OK
 12290                                  
 12291                                  ; The number of chars in the template is >= the number of chars in buffer or
 12292                                  ; there is no CR at the end of the template. This is an inconsistant state
 12293                                  ; of affairs. Pretend that the template was empty:
 12294                                  ;
 12295                                  
 12296                                  NOEDIT:	
 12297 000019E0 88EB                    	mov	bl,ch		;Reset buffer
 12298                                  EDITON: 
 12299 000019E2 88C2                    	mov	dl,al
 12300 000019E4 4A                      	dec	dx		;DL is # of bytes we can put in the buffer
 12301                                  
 12302                                  ;	Top level. We begin to read a line in.
 12303                                  
 12304                                  NEWLIN: 
 12305 000019E5 36A0[F901]              	mov	al,[SS:CARPOS]
 12306 000019E9 36A2[FA01]              	mov	[SS:STARTPOS],al ;Remember position in raw buffer
 12307                                  
 12308 000019ED 56                      	push	si
 12309 000019EE BF[FB01]                	mov	di,INBUF ;Build the new line here
 12310 000019F1 36882E[7905]            	mov	byte [SS:INSMODE],ch ;Insert mode off
 12311 000019F6 88EF                    	mov	bh,ch		;No chars from template yet
 12312 000019F8 88EE                    	mov	dh,ch		;No chars to new line yet
 12313 000019FA E866FF                  	call	_$STD_CON_INPUT_NO_ECHO ;Get first char
 12314 000019FD 3C0A                    	cmp	al,c_LF		; 0Ah	;Linefeed 
 12315 000019FF 7503                    	jnz	short GOTCH
 12316                                  
 12317                                  ;	This is the main loop of reading in a character and processing it.
 12318                                  ;
 12319                                  ;	(BH) = the index of the next byte in the template
 12320                                  ;	(BL) = the length of the template
 12321                                  ;	(DH) = the number of bytes in the buffer
 12322                                  ;	(DL) = the length of the buffer
 12323                                  
 12324                                  GETCH:
 12325 00001A01 E85FFF                  	call	_$STD_CON_INPUT_NO_ECHO
 12326                                  GOTCH:
 12327                                  ;
 12328                                  ; Brain-damaged Tim Patterson ignored ^F in case his BIOS did not flush the
 12329                                  ; input queue.
 12330                                  ;
 12331 00001A04 3C06                            cmp	al,"F"-"@"  ; CMP AL, 6  ; Ignore ^F
 12332 00001A06 74F9                    	jz	short GETCH
 12333                                  
 12334                                  ;	If the leading char is the function-key lead byte
 12335                                  
 12336                                  	;cmp	al,[SS:ESCCHAR]
 12337                                  
 12338                                  	; 04/05/2019 - Retro DOS v4.0
 12339                                  
 12340                                  ;hkn; 	ESCCHAR is in TABLE seg (DOSCODE)
 12341                                  
 12342 00001A08 2E3A06[960A]            	CMP	AL,[cs:ESCCHAR]
 12343 00001A0D 7439                            jz	short ESCAPE	;change reserved keyword DBM 5-7-87
 12344                                  
 12345                                  ;	Rubout and ^H are both destructive backspaces.
 12346                                  
 12347 00001A0F 3C7F                            cmp	al,c_DEL ; 7FH
 12348                                          ;jz	short BACKSPJ
 12349                                          ; 15/01/2024
 12350 00001A11 7466                    	je	short BACKSP
 12351 00001A13 3C08                    	cmp	al,c_BS  ; 8
 12352                                          ;jz	short BACKSPJ
 12353                                          ; 15/01/2024
 12354 00001A15 7462                    	je	short BACKSP
 12355                                  
 12356                                  	; 04/05/2019 -	MSDOS 6.0, also MSDOS 6.21 has bug (bullshit) here.
 12357                                  	;		Two NOPs -instead of a JMP short, as two bytes-
 12358                                  	;	   	after CMP and a CMP again!
 12359                                  	;		
 12360                                  	;		-It would be better if they use a 'JMP short' to 
 12361                                  	;	      	DOSCODE:5279h from DOSCODE:5271h and leave NOPs
 12362                                  	;		between them. Then, they would be able use a patch
 12363                                  	;		between 5271h and 5279h when if it will be required.
 12364                                  	;		I think Tim Patterson would not do this CMP mistake!-
 12365                                  	;	
 12366                                  	; (MSDOS.SYS, from DOSCODE:5271h to DOSCODE:5279h)
 12367                                  
 12368                                  	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12369                                  	;
 12370                                  	; (Note: nops below might be used for patching code for Windows 3.1)
 12371                                  
 12372                                  ;DOSCODE:526D	cmp     al, 8
 12373                                  ;DOSCODE:526F	jz      short BACKSPJ
 12374                                  ;DOSCODE:5271	cmp     al, 17h
 12375                                  ;DOSCODE:5273	nop
 12376                                  ;DOSCODE:5274	nop
 12377                                  ;DOSCODE:5275	cmp     al, 15h
 12378                                  ;DOSCODE:5277	nop
 12379                                  ;DOSCODE:5278	nop
 12380                                  ;DOSCODE:5279	cmp     al, 0Dh
 12381                                  ;DOSCODE:527B	jz      short ENDLIN
 12382                                  ;DOSCODE:527D	cmp     al, 0Ah
 12383                                  ;DOSCODE:527F	jz      short PHYCRLF
 12384                                  	
 12385                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12386                                  	; DOSCODE:525Dh
 12387                                  
 12388                                  ; 16/12/2022
 12389                                  %if 0
 12390                                  	; MSDOS 6.0
 12391                                  ;	^W deletes backward once and then backs up until a letter is before the
 12392                                  ;	cursor
 12393                                  
 12394                                  	CMP     AL,"W"-"@" ; 17h
 12395                                  
 12396                                  ;	The removal of the comment characters before the jump statement will
 12397                                  ;	cause ^W to backup a word.
 12398                                  
 12399                                  ;***	JZ	short WordDel
 12400                                  	NOP
 12401                                  	NOP
 12402                                  
 12403                                  	CMP     AL,"U"-"@" ; 15h
 12404                                  
 12405                                  ;	The removal of the comment characters before the jump statement will
 12406                                  ;	cause ^U to clear a line.
 12407                                  
 12408                                  ;***	JZ	short LineDel
 12409                                  	NOP
 12410                                  	NOP
 12411                                  
 12412                                  %endif
 12413                                  
 12414                                  ;	CR terminates the line.
 12415                                  
 12416 00001A17 3C0D                            cmp	al,c_CR ; 0Dh
 12417 00001A19 7430                            jz	short ENDLIN
 12418                                  
 12419                                  ;	LF goes to a new line and keeps on reading.
 12420                                  
 12421 00001A1B 3C0A                            cmp	al,c_LF ; 0Ah
 12422 00001A1D 7442                    	jz	short PHYCRLF
 12423                                  
 12424                                  ;	^X (or ESC) deletes the line and starts over
 12425                                  
 12426                                  	; MSDOS 3.3
 12427                                  	;cmp	al,[ss:CANCHAR] ; 1Bh
 12428                                  	;jz	short KILNEW
 12429                                  
 12430                                  	; MSDOS 6.0 (& MSDOS 6.21)
 12431                                  
 12432                                  ;hkn; 	CANCHAR is in TABLE seg (DOSCODE), so CS override
 12433                                  
 12434 00001A1F 2E3A06[950A]            	cmp	al,[cs:CANCHAR] ; 1Bh
 12435 00001A24 7440                    	jz	short KILNEW
 12436                                  	
 12437                                  	;cmp	al,CANCEL ; 1Bh	; Retro DOS v3.0
 12438                                  	;jz	short KILNEW
 12439                                  
 12440                                  ; Otherwise, we save the input character.
 12441                                  
 12442                                  SAVCH:	
 12443 00001A26 38D6                    	cmp	dh,dl
 12444 00001A28 7317                    	jnb	short BUFFUL		; buffer is full.
 12445 00001A2A AA                              stosb
 12446 00001A2B FEC6                    	inc	dh                      ; increment count in buffer.
 12447 00001A2D E8B102                  	call	BUFOUT			; Print control chars nicely
 12448                                  
 12449 00001A30 36803E[7905]00                  cmp	byte [SS:INSMODE], 0
 12450 00001A36 75C9                    	jnz	short GETCH		; insertmode => don't advance template
 12451 00001A38 38DF                            cmp	bh,bl
 12452 00001A3A 73C5                            jnb	short GETCH		; no more characters in template
 12453 00001A3C 46                              inc	si                      ; Skip to next char in template
 12454 00001A3D FEC7                            inc	bh                      ; remember position in template
 12455 00001A3F EBC0                            jmp	short GETCH
 12456                                  
 12457                                  	; 15/01/2024
 12458                                  ;BACKSPJ: 
 12459                                  	;jmp	short BACKSP
 12460                                  
 12461                                  BUFFUL: 
 12462 00001A41 B007                    	mov	al, 7			; Bell to signal full buffer
 12463 00001A43 E80702                  	call	OUTT
 12464 00001A46 EBB9                    	jmp	short GETCH
 12465                                  
 12466                                  ESCAPE: 
 12467                                  	;transfer OEMFunctionKey
 12468 00001A48 E976F0                  	JMP	OEMFunctionKey		; let the OEM's handle the key dispatch
 12469                                  
 12470                                  ENDLIN:
 12471 00001A4B AA                              stosb				; Put the CR in the buffer
 12472 00001A4C E8FE01                  	call	OUTT                    ; Echo it
 12473 00001A4F 5F                              pop	di                      ; Get start of user buffer
 12474 00001A50 8875FF                          mov	[di-1], dh		; Tell user how many bytes
 12475 00001A53 FEC6                            inc	dh			; DH is length including CR
 12476                                  
 12477                                  COPYNEW:
 12478                                  	; (IBMDOS.COM, MSDOS 2.0, STRIN.ASM)
 12479                                  	;mov	bp, es
 12480                                  	;mov	bx, ds
 12481                                  	;mov	es, bx
 12482                                  	;mov	ds, bp
 12483                                  	;mov	si, INBUF
 12484                                  	;mov	cl, dh
 12485                                  	;rep	movsb
 12486                                  	;retn
 12487                                  
 12488                                  	; CPMIO.ASM (MSDOS 6.0)
 12489                                  	; (IBMDOS.COM, MSDOS 3.3, Offset 2061h) 
 12490                                  	;SAVE	<DS,ES>
 12491 00001A55 1E                      	PUSH	DS
 12492 00001A56 06                      	PUSH	ES
 12493                                  	;RESTORE <DS,ES>		; XCHG ES,DS
 12494 00001A57 1F                      	POP	DS
 12495 00001A58 07                      	POP	ES
 12496                                  
 12497                                  ;;hkn; INBUF is in DOSDATA
 12498 00001A59 BE[FB01]                        MOV     SI,INBUF
 12499 00001A5C 88F1                            MOV     CL,DH                   ; set up count
 12500 00001A5E F3A4                            REP     MOVSB                   ; Copy final line to user buffer
 12501                                  OLDBAK_RETN:
 12502 00001A60 C3                              RETN
 12503                                  
 12504                                  ;	Output a CRLF to the user screen and do NOT store it into the buffer
 12505                                  
 12506                                  PHYCRLF:
 12507 00001A61 E81B01                  	CALL	CRLF
 12508 00001A64 EB9B                            JMP	short GETCH
 12509                                  
 12510                                  	; MSDOS 6.0 (& MSDOS 3.3, IBMDOS.COM, 1987)
 12511                                  
 12512                                  ; DOSCODE:52CAh (MSDOS 621, MSDOS.SYS)
 12513                                  
 12514                                  	; Note: Following routines were not used in IBMDOS.COM
 12515                                  	;	-CRTL+W, CRTL+U is not activated-
 12516                                  	;	but they were in the kernel code!?)
 12517                                  
 12518                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12519                                  	; DOSCODE:52B6h
 12520                                  
 12521                                  ;;;;;;;;
 12522                                  
 12523                                  ; 16/12/2022
 12524                                  %if 0
 12525                                  ;
 12526                                  ; Delete the previous line
 12527                                  ;
 12528                                  LineDel:
 12529                                  	OR      DH,DH
 12530                                  	JZ	short GETCH	 ; 06/12/2022
 12531                                  	Call    BackSpace
 12532                                  	JMP	short LineDel
 12533                                  
 12534                                  %endif
 12535                                  
 12536                                  ;
 12537                                  ; delete the previous word.
 12538                                  ;
 12539                                  WordDel:
 12540                                  WordLoop:
 12541                                  ;	Call    BackSpace               ; backspace the one spot
 12542                                  ;	OR      DH,DH
 12543                                  ;	JZ	short GetChj
 12544                                  ;	MOV     AL,[ES:DI-1]
 12545                                  ;	cmp     al,'0'
 12546                                  ;	jb	short GetChj
 12547                                  ;	cmp     al,'9'
 12548                                  ;	jbe	short WordLoop
 12549                                  ;	OR      AL,20h
 12550                                  ;	CMP     AL,'a'
 12551                                  ;	JB	short GetChj
 12552                                  ;	CMP     AL,'z'
 12553                                  ;	JBE	short WordLoop
 12554                                  ;GetChj: 
 12555                                  ;	JMP	GETCH
 12556                                  
 12557                                  ; 16/12/2022
 12558                                  %if 0
 12559                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12560                                  	; (Worddel is not called or jumped from anywhere!)
 12561                                  WordDel:
 12562                                  WordLoop:
 12563                                  	Call    BackSpace               ; backspace the one spot
 12564                                  	OR      DH,DH
 12565                                  	JZ	short GetChj
 12566                                  	MOV     AL,[ES:DI-1]
 12567                                  	cmp     al,'0'
 12568                                  	jb	short GetChj
 12569                                  	cmp     al,'9'
 12570                                  	jbe	short WordLoop
 12571                                  	OR      AL,20h
 12572                                  	CMP     AL,'a'
 12573                                  	JB	short GetChj
 12574                                  	CMP     AL,'z'
 12575                                  	JBE	short WordLoop
 12576                                  GetChj: 
 12577                                  	JMP	GETCH
 12578                                  
 12579                                  %endif
 12580                                  
 12581                                  ;;;;;;;;
 12582                                  
 12583                                  ; DOSCODE:52F3h (MSDOS 621, MSDOS.SYS)
 12584                                  
 12585                                  ; The user wants to throw away what he's typed in and wants to start over.
 12586                                  ; We print the backslash and then go to the next line and tab to the correct
 12587                                  ; spot to begin the buffered input.
 12588                                  
 12589                                  KILNEW:
 12590 00001A66 B05C                            mov	al,'\'
 12591 00001A68 E8E201                          call	OUTT            ;Print the CANCEL indicator
 12592 00001A6B 5E                              pop	si		;Remember start of edit buffer
 12593                                  PUTNEW:
 12594 00001A6C E81001                  	call	CRLF            ;Go to next line on screen
 12595 00001A6F 36A0[FA01]              	mov	al,[SS:STARTPOS]
 12596 00001A73 E84B02                  	call	TAB             ;Tab over
 12597 00001A76 E96CFF                          JMP     NEWLIN		;Start over again
 12598                                  
 12599                                  ;	Destructively back up one character position
 12600                                  
 12601                                  BACKSP:
 12602                                  	; 09/09/2018
 12603 00001A79 E80800                  	Call    BackSpace
 12604 00001A7C EB83                    	JMP     short GETCH	; 15/01/2024
 12605                                  
 12606                                  	; 15/01/2024
 12607                                  ;User really wants an ESC character in his line
 12608                                  TWOESC:	
 12609 00001A7E 2EA0[960A]              	mov	al,[cs:ESCCHAR] ; 10/06/2019
 12610 00001A82 EBA2                    	jmp	short SAVCH
 12611                                  
 12612                                  BackSpace:
 12613 00001A84 08F6                    	or	dh,dh
 12614 00001A86 7419                    	jz	short OLDBAK	;No chars in line, do nothing to line
 12615 00001A88 E85800                  	call	BACKUP          ;Do the backup
 12616 00001A8B 268A05                  	mov	al,[es:di]	;Get the deleted char
 12617 00001A8E 3C20                            cmp	al,20h	; ' '
 12618 00001A90 730F                    	jnb	short OLDBAK	;Was a normal char
 12619 00001A92 3C09                            cmp	al,c_HT ; 9
 12620 00001A94 741B                    	jz	short BAKTAB	;Was a tab, fix up users display
 12621                                  ;; 9/27/86 fix for ctrl-U backspace
 12622 00001A96 3C15                    	CMP     AL,"U"-"@" ; 15h ; ctrl-U is a section symbol not ^U
 12623 00001A98 7407                    	JZ	short OLDBAK
 12624 00001A9A 3C14                           	CMP     AL,"T"-"@" ; 14h ; ctrl-T is a paragraphs symbol not ^T
 12625 00001A9C 7403                    	JZ	short OLDBAK
 12626                                  ;; 9/27/86 fix for ctrl-U backspace
 12627 00001A9E E84500                          call	BACKMES         ;Was a control char, zap the '^'
 12628                                  OLDBAK:
 12629 00001AA1 36803E[7905]00                  cmp	byte [SS:INSMODE], 0
 12630 00001AA7 75B7                    	jnz	short OLDBAK_RETN ;In insert mode, done
 12631 00001AA9 08FF                    	or	bh,bh
 12632 00001AAB 74B3                            jz	short OLDBAK_RETN 
 12633                                  				;Not advanced in template, stay where we are
 12634 00001AAD FECF                    	dec	bh		;Go back in template
 12635 00001AAF 4E                              dec	si
 12636 00001AB0 C3                      	retn
 12637                                  BAKTAB:
 12638 00001AB1 57                              push	di
 12639 00001AB2 4F                              dec	di		;Back up one char
 12640 00001AB3 FD                              std			;Go backward
 12641 00001AB4 88F1                            mov	cl,dh		;Number of chars currently in line
 12642 00001AB6 B020                            mov	al,20h	; ' '
 12643 00001AB8 53                              push	bx
 12644 00001AB9 B307                            mov	bl,7		;Max
 12645 00001ABB E30E                            jcxz	FIGTAB		;At start, do nothing
 12646                                  FNDPOS:
 12647 00001ABD AE                              scasb			;Look back
 12648 00001ABE 7609                    	jbe	short CHKCNT
 12649 00001AC0 26807D0109              	cmp	byte [es:di+1],9
 12650 00001AC5 7409                    	jz	short HAVTAB	;Found a tab
 12651 00001AC7 FECB                    	dec	bl		;Back one char if non tab control char
 12652                                  CHKCNT:
 12653 00001AC9 E2F2                            loop	FNDPOS
 12654                                  FIGTAB:		
 12655 00001ACB 362A1E[FA01]            	sub	bl,[SS:STARTPOS]
 12656                                  HAVTAB:
 12657 00001AD0 28F3                    	sub	bl,dh
 12658 00001AD2 00D9                    	add	cl,bl
 12659 00001AD4 80E107                  	and	cl,7		;CX has correct number to erase
 12660 00001AD7 FC                      	cld			;Back to normal
 12661 00001AD8 5B                      	pop	bx
 12662 00001AD9 5F                      	pop	di
 12663 00001ADA 74C5                    	jz	short OLDBAK	;Nothing to erase
 12664                                  TABBAK:
 12665 00001ADC E80700                  	call	BACKMES
 12666 00001ADF E2FB                    	loop	TABBAK		;Erase correct number of chars
 12667 00001AE1 EBBE                    	jmp	short OLDBAK
 12668                                  
 12669                                  BACKUP:
 12670 00001AE3 FECE                            dec	dh		;Back up in line
 12671 00001AE5 4F                              dec	di
 12672                                  BACKMES:
 12673 00001AE6 B008                            mov	al,c_BS ; 8	;Backspace
 12674 00001AE8 E86201                          call	OUTT
 12675 00001AEB B020                            mov	al,20h ; ' '	;Erase
 12676 00001AED E85D01                          call	OUTT
 12677 00001AF0 B008                            mov	al,c_BS ; 8	;Backspace
 12678 00001AF2 E95801                  	jmp	OUTT		;Done
 12679                                  
 12680                                  	; 15/01/2024
 12681                                  ;User really wants an ESC character in his line
 12682                                  ;TWOESC:	
 12683                                  ;	mov	al,[cs:ESCCHAR] ; 10/06/2019
 12684                                  ;	jmp	SAVCH
 12685                                  
 12686                                  ;Copy the rest of the template
 12687                                  COPYLIN:
 12688 00001AF5 88D9                            mov	cl,bl		;Total size of template
 12689 00001AF7 28F9                    	sub	cl,bh		;Minus position in template, is number to move
 12690 00001AF9 EB07                            jmp	short COPYEACH
 12691                                  
 12692                                  COPYSTR:
 12693 00001AFB E83200                  	call	FINDOLD         ;Find the char
 12694 00001AFE EB02                    	jmp	short COPYEACH  ;Copy up to it
 12695                                  
 12696                                  ;Copy one char from template to line
 12697                                  COPYONE:
 12698 00001B00 B101                            mov	cl,1
 12699                                  ;Copy CX chars from template to line
 12700                                  COPYEACH:
 12701 00001B02 36C606[7905]00                  mov	byte [SS:INSMODE],0	;All copies turn off insert mode
 12702 00001B08 38D6                    	cmp	dh,dl
 12703 00001B0A 740F                            jz	short GETCH2		;At end of line, can't do anything
 12704 00001B0C 38DF                            cmp	bh,bl
 12705 00001B0E 740B                            jz	short GETCH2		;At end of template, can't do anything
 12706 00001B10 AC                              lodsb
 12707 00001B11 AA                              stosb
 12708 00001B12 E8CC01                  	call	BUFOUT
 12709 00001B15 FEC7                            inc	bh			;Ahead in template
 12710 00001B17 FEC6                            inc	dh			;Ahead in line
 12711 00001B19 E2E7                            loop	COPYEACH
 12712                                  GETCH2:
 12713 00001B1B E9E3FE                          jmp	GETCH
 12714                                  
 12715                                  ;Skip one char in template
 12716                                  SKIPONE:
 12717 00001B1E 38DF                    	cmp	bh,bl
 12718 00001B20 74F9                    	jz	short GETCH2		;At end of template
 12719 00001B22 FEC7                    	inc	bh			;Ahead in template
 12720 00001B24 46                      	inc	si
 12721                                          ;jmp	GETCH
 12722                                  	; 15/01/2024
 12723 00001B25 EBF4                    	jmp	short GETCH2
 12724                                  
 12725                                  SKIPSTR:
 12726 00001B27 E80600                  	call	FINDOLD                 ;Find out how far to go
 12727 00001B2A 01CE                            add	si,cx			;Go there
 12728 00001B2C 00CF                            add	bh,cl
 12729                                          ;jmp	GETCH
 12730                                  	; 15/01/2024
 12731 00001B2E EBEB                    	jmp	short GETCH2
 12732                                  
 12733                                  ;Get the next user char, and look ahead in template for a match
 12734                                  ;CX indicates how many chars to skip to get there on output
 12735                                  ;NOTE: WARNING: If the operation cannot be done, the return
 12736                                  ;       address is popped off and a jump to GETCH is taken.
 12737                                  ;       Make sure nothing extra on stack when this routine
 12738                                  ;       is called!!! (no PUSHes before calling it).
 12739                                  
 12740                                  FINDOLD:
 12741 00001B30 E830FE                          call	_$STD_CON_INPUT_NO_ECHO
 12742                                  
 12743                                  	; STRIN.ASM (MSDOS 2.11, 19/07/2018) 
 12744                                  
 12745                                  	;CMP     AL,[SS:ESCCHAR]	
 12746                                  	;JNZ     SHORT FINDSETUP
 12747                                  
 12748                                  	; CPMIO.ASM (MSDOS 6.0, 04/05/2019 - Retro DOS v4.0)
 12749                                  
 12750                                  ;hkn; ESCCHAR is in TABLE seg (DOSCODE), so CS override
 12751                                  
 12752 00001B33 2E3A06[960A]            	CMP	AL,[CS:ESCCHAR]		; did he type a function key?
 12753 00001B38 7505                    	JNZ	SHORT FINDSETUP		; no, set up for scan
 12754                                  
 12755 00001B3A E826FE                  	CALL	_$STD_CON_INPUT_NO_ECHO	; eat next char
 12756 00001B3D EB1D                            JMP	SHORT NOTFND		; go try again
 12757                                  FINDSETUP:
 12758 00001B3F 88D9                    	mov	cl,bl
 12759 00001B41 28F9                            sub	cl,bh		;CX is number of chars to end of template
 12760 00001B43 7417                    	jz	short NOTFND	;At end of template
 12761 00001B45 49                              dec	cx		;Cannot point past end, limit search
 12762 00001B46 7414                            jz	short NOTFND	;If only one char in template, forget it
 12763 00001B48 06                      	push	es
 12764 00001B49 1E                      	push	ds
 12765 00001B4A 07                      	pop	es
 12766 00001B4B 57                      	push	di
 12767 00001B4C 89F7                    	mov	di,si		;Template to ES:DI
 12768 00001B4E 47                      	inc	di
 12769 00001B4F F2AE                    	repne	scasb		;Look
 12770 00001B51 5F                      	pop	di
 12771 00001B52 07                      	pop	es
 12772 00001B53 7507                    	jnz	short NOTFND	;Didn't find the char
 12773 00001B55 F6D1                            not	cl		;Turn how far to go into how far we went
 12774 00001B57 00D9                            add	cl,bl		;Add size of template
 12775 00001B59 28F9                            sub	cl,bh		;Subtract current pos, result distance to skip
 12776                                  FINDOLD_RETN:
 12777 00001B5B C3                      	retn
 12778                                  
 12779                                  NOTFND:
 12780 00001B5C 5D                      	pop	bp              ;Chuck return address
 12781                                  	;jmp	GETCH
 12782                                  	; 15/01/2024
 12783                                  GETCH2_j:
 12784 00001B5D EBBC                    	jmp	short GETCH2
 12785                                  
 12786                                  REEDIT:
 12787 00001B5F B040                    	mov	al,'@'		;Output re-edit character
 12788 00001B61 E8E900                  	call	OUTT
 12789 00001B64 5F                      	pop	di
 12790 00001B65 57                      	push	di
 12791 00001B66 06                      	push	es
 12792 00001B67 1E                      	push	ds
 12793 00001B68 E8EAFE                  	call	COPYNEW		;Copy current line into template
 12794 00001B6B 1F                      	pop	ds
 12795 00001B6C 07                      	pop	es
 12796 00001B6D 5E                      	pop	si
 12797 00001B6E 88F3                    	mov	bl,dh		;Size of line is new size template
 12798 00001B70 E9F9FE                  	jmp	PUTNEW		;Start over again
 12799                                  
 12800                                  EXITINS:
 12801                                  ENTERINS:
 12802 00001B73 36F616[7905]            	not	byte [SS:INSMODE]
 12803                                  	;jmp	GETCH
 12804                                  	; 15/01/2024
 12805 00001B78 EBE3                    	jmp	short GETCH2_j
 12806                                  
 12807                                  ;Put a real live ^Z in the buffer (embedded)
 12808                                  CTRLZ:
 12809 00001B7A B01A                    	mov	al,"Z"-"@" ; 1Ah
 12810 00001B7C E9A7FE                          jmp	SAVCH
 12811                                  
 12812                                  ;Output a CRLF
 12813                                  CRLF:
 12814 00001B7F B00D                    	mov	al,c_CR ; 0Dh 
 12815 00001B81 E8C900                  	call	OUTT
 12816 00001B84 B00A                    	mov	al,c_LF ; 0Ah
 12817 00001B86 E9C400                  	jmp	OUTT
 12818                                  
 12819                                  ;
 12820                                  ;----------------------------------------------------------------------------
 12821                                  ;
 12822                                  ;**	$RAW_CON_IO - Do Raw Console I/O
 12823                                  ;
 12824                                  ;	Input or output raw character from console, no echo
 12825                                  ;
 12826                                  ;	ENTRY	DL = -1 if input
 12827                                  ;		   =  output character if output
 12828                                  ;	EXIT	(AL) = input character if input
 12829                                  ;	USES	all
 12830                                  ;
 12831                                  ;----------------------------------------------------------------------------
 12832                                  ; 20/07/2018 - Retro DOS v3.0
 12833                                  
 12834                                  ; 04/05/2019 - Retro DOS v4.0
 12835                                  ; DOSCODE:541Ch (MSDOS 6.21, MSDOS.SYS)
 12836                                  
 12837                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12838                                  ; DOSCODE:5408h (MSDOS 5.0, MSDOS.SYS)
 12839                                  
 12840                                  _$RAW_CON_IO:			; System call 6
 12841                                  
 12842 00001B89 88D0                            MOV	AL,DL
 12843 00001B8B 3CFF                            CMP	AL,-1
 12844 00001B8D 7541                    	JNZ	SHORT RAWOUT ; 16/12/2022
 12845                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12846                                  	;jz	short rci1
 12847                                  	;jmp	short RAWOUT
 12848                                  	; 16/12/202
 12849                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12850                                  	;nop
 12851                                  rci1:
 12852                                  			; Get pointer to register save area
 12853 00001B8F 36C43E[8405]            	LES	DI,[SS:USER_SP] ; 12/03/2018
 12854 00001B94 31DB                    	XOR	BX,BX
 12855                                      	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 12856 00001B96 E83023                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 12857                                          ;JC	SHORT RET17
 12858 00001B99 72C0                            jc	short FINDOLD_RETN
 12859 00001B9B B401                    	MOV	AH,1
 12860 00001B9D E8B032                  	CALL	IOFUNC
 12861 00001BA0 750B                    	JNZ	SHORT RESFLG
 12862 00001BA2 E8463F                  	CALL	SPOOLINT
 12863                                  	;OR	BYTE [ES:DI+16H],40H
 12864 00001BA5 26804D1640              	OR	BYTE [ES:DI+user_env.user_F],40H ; Set user's zero flag
 12865 00001BAA 30C0                    	XOR	AL,AL
 12866                                  RET17:
 12867 00001BAC C3                      	RETN
 12868                                  
 12869                                  RESFLG:
 12870                                  	;AND	BYTE [ES:DI+16H],0FFH-40H  ; 0BFh
 12871 00001BAD 26806516BF              	AND	BYTE [ES:DI+user_env.user_F],0FFH-40H
 12872                                  				; Reset user's zero flag
 12873                                  ;RILP:
 12874                                  rci0:
 12875 00001BB2 E8363F                       	CALL	SPOOLINT
 12876                                  ;
 12877                                  ;----------------------------------------------------------------------------
 12878                                  ;
 12879                                  ;**	$Raw_CON_INPUT - Raw Console Input
 12880                                  ;
 12881                                  ;	Input raw character from console, no echo
 12882                                  ;
 12883                                  ;	ENTRY	none
 12884                                  ;	EXIT	(al) = character
 12885                                  ;	USES	all
 12886                                  ;
 12887                                  ;----------------------------------------------------------------------------
 12888                                  ;
 12889                                  
 12890                                  ;rci0:	invoke	SPOOLINT
 12891                                  
 12892                                  	;entry	$RAW_CON_INPUT
 12893                                  
 12894                                  	; 04/05/2019 - Retro DOS v4.0
 12895                                  
 12896                                  ; DOSCODE:544Bh (MSDOS 6.21, MSDOS.SYS)
 12897                                  
 12898                                  	; 15/01/2024 - Retro DOS v5.0
 12899                                  
 12900                                  ; DOSCODE:5ACBh (PCDOS 7.1, IBMDOS.COM)
 12901                                  
 12902                                  _$RAW_CON_INPUT:		; System call 7
 12903 00001BB5 53                      	push	bx
 12904 00001BB6 31DB                    	XOR	BX,BX
 12905                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 12906 00001BB8 E80E23                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 12907 00001BBB 5B                      	pop	bx
 12908 00001BBC 72EE                    	JC	SHORT RET17
 12909 00001BBE B401                    	MOV	AH,1
 12910 00001BC0 E88D32                  	CALL	IOFUNC
 12911                                  	;JZ	SHORT RILP	; MSDOS 2.11
 12912                                  	;XOR	AH,AH
 12913                                          ;CALL	IOFUNC
 12914                                          ;RETN
 12915 00001BC3 7506                    	jnz	short rci5	; MSDOS 3.3 & MSDOS 6.0
 12916 00001BC5 B484                    	MOV	AH,84h
 12917 00001BC7 CD2A                    	INT	int_IBM  ; int 2Ah
 12918 00001BC9 EBE7                    	JMP	short rci0
 12919                                  rci5:	
 12920 00001BCB 30E4                    	XOR	AH,AH
 12921                                  	;CALL	IOFUNC
 12922                                  	;RETN
 12923                                  	; 18/12/2022
 12924 00001BCD E98032                  	jmp	IOFUNC
 12925                                  
 12926                                  ;       Output the character in AL to stdout
 12927                                  ;
 12928                                  	;entry	RAWOUT
 12929                                  RAWOUT:
 12930 00001BD0 53                      	PUSH    BX
 12931 00001BD1 BB0100                  	MOV     BX,1
 12932                                  
 12933                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 12934 00001BD4 E8F222                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 12935 00001BD7 721E                    	JC	SHORT RAWRET1
 12936                                  
 12937                                  	;
 12938                                  	; MSDOS 2.11
 12939                                          ;TEST	BYTE [SI+18H],080H	; output to file?
 12940                                          ;JZ	SHORT RAWNORM		; if so, do normally
 12941                                          ;PUSH	DS
 12942                                          ;PUSH	SI
 12943                                          ;LDS	SI,[SI+19H]		; output to special?
 12944                                  	;TEST	BYTE [SI+4],ISSPEC
 12945                                  	;POP	SI
 12946                                  	;
 12947                                          
 12948                                  	; MSDOS 3.3 & MSDOS 6.0
 12949                                  	;mov	bx,[si+5]
 12950 00001BD9 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags] ;hkn; DS set up by get_io_sft
 12951                                   ;
 12952                                   ; If we are a network handle OR if we are not a local device then go do the
 12953                                   ; output the hard way.
 12954                                   ;	
 12955                                  	;and	bx,8080h
 12956 00001BDC 81E38080                	AND	BX,sf_isnet+devid_device
 12957                                  	;cmp	bx,80h
 12958 00001BE0 81FB8000                	CMP	BX,devid_device
 12959 00001BE4 7513                    	jnz     short RAWNORM
 12960 00001BE6 1E                      	push    ds
 12961                                  	;lds	bx,[si+7]
 12962 00001BE7 C55C07                  	LDS	BX,[SI+SF_ENTRY.sf_devptr] ; output to special?
 12963                                  	;test	byte [bx+4],10h
 12964 00001BEA F6470410                	TEST	BYTE [BX+SYSDEV.ATT],ISSPEC
 12965                                  	;
 12966                                  
 12967 00001BEE 1F                      	POP	DS
 12968 00001BEF 7408                    	JZ	SHORT RAWNORM		; if not, do normally
 12969                                  
 12970                                  	;INT	int_fastcon  ; int 29h	; quickly output the char
 12971                                  	; 15/01/2024
 12972 00001BF1 9C                      	pushf			; simulate INT 29h
 12973 00001BF2 FF1EA400                	call    far [29h*4]	; call far [00A4h]
 12974                                  
 12975                                  	;JMP	SHORT RAWRET
 12976                                  ;RAWNORM:
 12977                                  ;	CALL    RAWOUT3
 12978                                  RAWRET: 
 12979 00001BF6 F8                      	CLC
 12980                                  RAWRET1:
 12981 00001BF7 5B                      	POP     BX
 12982                                  RAWRET2:
 12983 00001BF8 C3                      	RETN
 12984                                  RAWNORM:
 12985 00001BF9 E80700                  	CALL    RAWOUT3
 12986 00001BFC EBF8                    	jmp	short RAWRET
 12987                                  
 12988                                  ;	Output the character in AL to handle in BX
 12989                                  ;
 12990                                  ;	entry	RAWOUT2
 12991                                  
 12992                                  RAWOUT2:
 12993                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 12994                                  	;JC	SHORT RET18
 12995 00001BFE E8C822                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 12996 00001C01 72F5                    	JC	SHORT RAWRET2
 12997                                  RAWOUT3:
 12998 00001C03 50                      	PUSH	AX
 12999 00001C04 EB0C                    	JMP	SHORT RAWOSTRT
 13000                                  ROLP:
 13001 00001C06 E8E23E                  	CALL	SPOOLINT
 13002                                  
 13003                                  	; 01/05/2019 - Retro DOS v4.0
 13004                                  
 13005                                  	; MSDOS 6.0
 13006                                  	;OR	word [ss:DOS34_FLAG],CTRL_BREAK_FLAG ; 001000000000b
 13007                                  	; 17/12/2022
 13008 00001C09 36800E[1206]02          	or	byte [ss:DOS34_FLAG+1],(CTRL_BREAK_FLAG>>8) ; 02h
 13009                                  	;or	word [ss:DOS34_FLAG],200h
 13010                                  				;AN002; set control break
 13011                                  	;invoke DSKSTATCHK
 13012 00001C0F E8563E                  	call	DSKSTATCHK	;AN002; check control break
 13013                                  RAWOSTRT:
 13014 00001C12 B403                    	MOV	AH,3
 13015 00001C14 E83932                  	CALL	IOFUNC
 13016 00001C17 74ED                    	JZ	SHORT ROLP
 13017                                  
 13018                                  	; MSDOS 6.0
 13019                                  ;SR;
 13020                                  ; IOFUNC now returns ax = 0ffffh if there was an I24 on a status call and
 13021                                  ;the user failed. We do not send a char if this happens. We however return
 13022                                  ;to the caller with carry clear because this DOS call does not return any
 13023                                  ;status. 
 13024                                  ;
 13025 00001C19 40                      	inc	ax		;fail on I24 if ax = -1
 13026 00001C1A 58                      	POP	AX
 13027 00001C1B 7405                    	jz	short nosend	;yes, do not send char
 13028 00001C1D B402                    	MOV	AH,2
 13029 00001C1F E82E32                  	call	IOFUNC
 13030                                  nosend:
 13031 00001C22 F8                      	CLC			; Clear carry indicating successful
 13032 00001C23 C3                      	retn
 13033                                  
 13034                                  	; MSDOS 3.3 & MSDOS 2.11
 13035                                  	;POP	AX
 13036                                  	;MOV	AH,2
 13037                                          ;CALL	IOFUNC
 13038                                  	;CLC			; Clear carry indicating successful
 13039                                  ;RET18:    
 13040                                  	;RETN
 13041                                  
 13042                                  ;;10/08/2018
 13043                                  ; 20/07/2018 - Retro DOS v3.0
 13044                                  ; ---------------------------------------------------------------------------
 13045                                  ; Retro DOS v2.0 (MSDOS 2.11) - OUTMES
 13046                                  ; ---------------------------------------------------------------------------
 13047                                  
 13048                                  ; This routine is called at DOS init
 13049                                  
 13050                                  ;;	;procedure OUTMES,NEAR ; String output for internal messages
 13051                                  ;;OUTMES:
 13052                                  ;;	;LODS	CS:BYTE PTR [SI]
 13053                                  ;;	CS	LODSB
 13054                                  ;;	CMP     AL,"$" ; 24h
 13055                                  ;;	JZ	SHORT RET18
 13056                                  ;;	CALL	OUTT
 13057                                  ;;	JMP     SHORT OUTMES
 13058                                  
 13059                                  ; ---------------------------------------------------------------------------
 13060                                  
 13061                                  ; 20/07/2018 - Retro DOS v3.0
 13062                                  
 13063                                  ; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 2252h
 13064                                  
 13065                                  ;
 13066                                  ;----------------------------------------------------------------------------
 13067                                  ;
 13068                                  ; Inputs:
 13069                                  ;	AX=0 save the DEVCALL request packet
 13070                                  ;	  =1 restore the DEVCALL request packet
 13071                                  ; Function:
 13072                                  ;	save or restore the DEVCALL packet
 13073                                  ; Returns:
 13074                                  ;	none
 13075                                  ;
 13076                                  ;----------------------------------------------------------------------------
 13077                                  ;
 13078                                  
 13079                                  ; 04/05/2019 - Retro DOS v4.0
 13080                                  ; DOSCODE:54B9h (MSDOS 6.21, MSDOS.SYS)
 13081                                  
 13082                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13083                                  ; DOSCODE:54A5h (MSDOS 5.0, MSDOS.SYS)
 13084                                  
 13085                                  ; 12/05/2019
 13086                                  
 13087                                  	; 15/01/2024 - Retro DOS v5.0
 13088                                  	; DOSCODE:5B42h (PCDOS 7.1, IBMDOS.COM)
 13089                                  
 13090                                  Save_Restore_Packet:
 13091 00001C24 1E                      	PUSH	DS
 13092 00001C25 06                      	PUSH	ES
 13093 00001C26 56                      	PUSH	SI
 13094 00001C27 57                      	PUSH	DI
 13095                                  
 13096                                  	; 16/12/2022
 13097                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13098                                  	; 09/09/2018
 13099 00001C28 BF[BD0D]                	mov	di,FAKE_STACK_2F 
 13100 00001C2B BE[5A03]                	mov	si,DEVCALL
 13101                                  	;
 13102                                  	; 21/09/2023
 13103 00001C2E 09C0                    	or	ax,ax 
 13104                                  	;CMP	AX,0		; save packet
 13105 00001C30 7402                    	JZ	short save_packet ; 16/12/2022
 13106                                  	;je	short set_seg
 13107                                  
 13108                                  	; MSDOS 6.0
 13109                                  restore_packet:
 13110                                  ;	MOV	SI,OFFSET DOSDATA:Packet_Temp	;source
 13111                                  ;	MOV	DI,OFFSET DOSDATA:DEVCALL	;destination
 13112                                  	; MSDOS 3.3
 13113                                  	;mov	si,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 13114                                  	;mov	di,DEVCALL  ; 09/09/2018
 13115                                  	;
 13116                                  	;JMP	short set_seg
 13117                                  
 13118                                  	; 16/12/2022	
 13119                                  	; 09/09/2018
 13120 00001C32 87F7                    	xchg	si,di  ; DI = offset DEVCALL, SI = offset FAKE_STACK_2F
 13121                                  
 13122                                  ; 16/12/2022
 13123                                  %if 0
 13124                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13125                                  	cmp	ax,0		; save packet
 13126                                  	jz	short save_packet
 13127                                  	mov	si,FAKE_STACK_2F ; 07/12/2022
 13128                                  	mov	di,DEVCALL 
 13129                                  	jmp	short set_seg
 13130                                  
 13131                                  	; MSDOS 6.0
 13132                                  save_packet:
 13133                                  ;	MOV	DI,OFFSET DOSDATA:Packet_Temp	;destination
 13134                                  ;	MOV	SI,OFFSET DOSDATA:DEVCALL	;source
 13135                                  	; 09/09/2018
 13136                                  	; MSDOS 3.3
 13137                                  	;mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 13138                                  	;mov	si,DEVCALL ; 09/09/2018
 13139                                  
 13140                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13141                                  	mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 13142                                  	mov	si,DEVCALL
 13143                                  %endif
 13144                                  
 13145                                  ; 16/12/2022
 13146                                  save_packet:
 13147                                  ;set_seg:
 13148                                  	; MSDOS 3.3
 13149                                  	;mov	ax,cs
 13150                                  
 13151                                  	; MSDOS 6.0
 13152                                  	;MOV	AX,SS		; set DS,ES to DOSDATA
 13153                                  	;MOV	DS,AX
 13154                                  	;MOV	ES,AX
 13155                                  	; 15/01/2024
 13156 00001C34 16                      	push	ss
 13157 00001C35 1F                      	pop	ds
 13158 00001C36 1E                      	push	ds
 13159 00001C37 07                      	pop	es
 13160                                  
 13161 00001C38 B90B00                  	MOV	CX,11		; 11 words to move
 13162 00001C3B F3A5                    	REP	MOVSW
 13163                                  
 13164 00001C3D 5F                      	POP	DI
 13165 00001C3E 5E                      	POP	SI
 13166 00001C3F 07                      	POP	ES
 13167 00001C40 1F                      	POP	DS
 13168 00001C41 C3                      	retn
 13169                                  
 13170                                  ;============================================================================
 13171                                  ; CPMIO2.ASM, MSDOS 6.0, 1991
 13172                                  ;============================================================================
 13173                                  ; 20/07/2018 - Retro DOS v3.0
 13174                                  ; 01/05/2019 - Retro DOS v4.0
 13175                                  
 13176                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
 13177                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
 13178                                  ;hkn;	not valid. 
 13179                                  
 13180                                  ;
 13181                                  ;----------------------------------------------------------------------------
 13182                                  ;
 13183                                  ;**	$STD_CON_INPUT - System Call 1
 13184                                  ;
 13185                                  ;	Input character from console, echo
 13186                                  ;
 13187                                  ;	ENTRY	none
 13188                                  ;	EXIT	(al) = character
 13189                                  ;	USES	ALL
 13190                                  ;
 13191                                  ;----------------------------------------------------------------------------
 13192                                  ;
 13193                                  
 13194                                  _$STD_CON_INPUT:	;System call 1
 13195                                  	
 13196 00001C42 E81EFD                  	CALL	_$STD_CON_INPUT_NO_ECHO
 13197 00001C45 50                      	PUSH	AX
 13198 00001C46 E80400                  	CALL	OUTT
 13199 00001C49 58                      	POP	AX
 13200                                  CON_INPUT_RETN:	
 13201 00001C4A C3                      	RETN
 13202                                  
 13203                                  ;
 13204                                  ;----------------------------------------------------------------------------
 13205                                  ;
 13206                                  ;**	$STD_CON_OUTPUT - System Call 2
 13207                                  ;
 13208                                  ;	Output character to console
 13209                                  ;
 13210                                  ;	ENTRY	(dl) = character
 13211                                  ;	EXIT	none
 13212                                  ;	USES	all
 13213                                  ;
 13214                                  ;----------------------------------------------------------------------------
 13215                                  ;
 13216                                  
 13217                                  ; DOSCODE:54E9h (MSDOS 6.21, MSDOS.SYS)
 13218                                  
 13219                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13220                                  ; DOSCODE:54D5h (MSDOS 5.0, MSDOS.SYS)
 13221                                  
 13222                                  ; 15/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 13223                                  ; DOSCODE:5B70h (PCDOS 7.1, IBMDOS.COM)
 13224                                  
 13225                                  _$STD_CON_OUTPUT:	;System call 2
 13226                                  
 13227 00001C4B 88D0                    	MOV	AL,DL
 13228                                  OUTT:
 13229 00001C4D 3C20                    	CMP	AL,20H ; " "
 13230 00001C4F 725C                    	JB	SHORT CTRLOUT
 13231 00001C51 3C7F                    	CMP	AL,c_DEL ; 7Fh
 13232 00001C53 7405                    	JZ	SHORT OUTCH
 13233                                  OUTCHA:	
 13234                                  	;INC	BYTE PTR [CARPOS]
 13235 00001C55 36FE06[F901]            	INC	BYTE [SS:CARPOS]
 13236                                  OUTCH:
 13237 00001C5A 1E                      	PUSH	DS
 13238 00001C5B 56                      	PUSH	SI
 13239                                  	;INC	BYTE PTR [CHARCO]		;invoke statchk...
 13240                                  	;AND	BYTE PTR [CHARCO],00111111B	;AN000; every 64th char
 13241 00001C5C 36FE06[0003]            	INC	BYTE [SS:CHARCO]	
 13242                                  	;AND	BYTE [SS:CHARCO],00111111B
 13243                                  	; 01/05/2019 - Retro DOS v4.0
 13244 00001C61 368026[0003]3F          	and	byte [SS:CHARCO],3Fh
 13245 00001C67 7505                    	JNZ	SHORT OUTSKIP
 13246                                  
 13247 00001C69 50                      	PUSH	AX
 13248 00001C6A E8AC3E                  	CALL	STATCHK
 13249 00001C6D 58                      	POP	AX
 13250                                  OUTSKIP:
 13251 00001C6E E85FFF                  	CALL	RAWOUT				;output the character
 13252                                  
 13253 00001C71 5E                      	POP	SI
 13254 00001C72 1F                      	POP	DS
 13255                                  
 13256                                  	;TEST	BYTE PTR [PFLAG],-1
 13257                                  	;retz
 13258 00001C73 36F606[FE02]FF          	TEST	BYTE [SS:PFLAG],0FFh
 13259 00001C79 74CF                    	JZ	SHORT CON_INPUT_RETN
 13260                                  
 13261 00001C7B 53                      	PUSH	BX
 13262 00001C7C 1E                      	PUSH	DS
 13263 00001C7D 56                      	PUSH	SI
 13264 00001C7E BB0100                  	MOV	BX,1
 13265                                  	; 20/07/2018 - Retro DOS v3.0
 13266                                  	; MSDOS 3.3
 13267                                  	; MSDOS 6.0 (CPMIO2.ASM)
 13268 00001C81 E84522                  	CALL	GET_IO_SFT		;hkn; GET_IO_SFT will set up DS:SI
 13269                                  					;hkn; to sft entry
 13270 00001C84 7224                    	JC	SHORT TRIPOPJ
 13271                                  
 13272                                  	; 01/05/2019 - Retro DOS v4.0
 13273                                  
 13274                                  	;mov	bx,[si+5]
 13275 00001C86 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags]
 13276                                  	;test	bx,8000h
 13277                                  	;TEST	BX,sf_isnet	; 8000h		; output to NET?
 13278 00001C89 F6C780                  	test	bh,(sf_isnet>>8) ; 80h
 13279 00001C8C 751C                    	JNZ	short TRIPOPJ 			; if so, no echo
 13280                                  	;;test	bx,80h
 13281                                  	;TEST	BX,devid_device 		; output to file?
 13282 00001C8E F6C380                  	test	bl,devid_device ; 80h
 13283 00001C91 7417                    	JZ	SHORT TRIPOPJ 			; if so, no echo
 13284                                  	; 14/03/2018
 13285                                  	;call	GET_IO_FCB	 	; IBMDOS.COM, MSDOS 2.11
 13286                                  	;jc	short TRIPOPJ
 13287                                  	; MSDOS 2.11
 13288                                  	;test	byte [SI+18H], 80h
 13289                                  	;jz	short TRIPOPJ
 13290 00001C93 BB0400                  	MOV	BX,4
 13291 00001C96 E83022                  	CALL	GET_IO_SFT
 13292 00001C99 720F                    	JC	SHORT TRIPOPJ
 13293                                  	;;test	word [si+5], 800h
 13294                                  	;TEST	word [SI+SF_ENTRY.sf_flags],sf_net_spool ; 800H
 13295                                  	;test	byte [si+6],8 ; 08/11/2022
 13296 00001C9B F6440608                	test	byte [SI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8) ; 8 
 13297                                  						; StdPrn redirected?
 13298                                  	;;JZ	SHORT LISSTRT2J			; No, OK to echo
 13299                                  	;jz	LISSTRT2 ; 10/08/2018 
 13300                                  	; 16/12/2022
 13301 00001C9F 7503                    	jnz	short outch1
 13302 00001CA1 E98700                  	jmp	LISSTRT2
 13303                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13304                                  	;jz	short LISSTRT2J
 13305                                  outch1:
 13306                                  	;MOV	BYTE [PFLAG],0
 13307 00001CA4 36C606[FE02]00          	MOV	BYTE [SS:PFLAG],0		; If a spool, NEVER echo
 13308                                  	; MSDOS 2.11
 13309                                  	;mov	bx,4
 13310                                  	;jmp	short LISSTRT2
 13311                                  	
 13312                                  TRIPOPJ:
 13313                                  	; 20/07/2018
 13314 00001CAA E98100                  	JMP	TRIPOP
 13315                                  
 13316                                  	; 16/12/2022
 13317                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13318                                  ;LISSTRT2J:
 13319                                  ;	JMP	LISSTRT2
 13320                                  
 13321                                  CTRLOUT:
 13322 00001CAD 3C0D                    	CMP	AL,c_CR ; 0Dh
 13323 00001CAF 7420                    	JZ	SHORT ZERPOS
 13324 00001CB1 3C08                    	CMP	AL,c_BS ; 8
 13325 00001CB3 7424                    	JZ	SHORT BACKPOS
 13326 00001CB5 3C09                    	CMP	AL,c_HT ; 9
 13327 00001CB7 75A1                    	JNZ	SHORT OUTCH
 13328                                  	;MOV	AL,[CARPOS]
 13329 00001CB9 36A0[F901]              	MOV	AL,[SS:CARPOS]
 13330 00001CBD 0CF8                    	OR	AL,0F8H
 13331 00001CBF F6D8                    	NEG	AL
 13332                                  TAB:
 13333 00001CC1 51                      	PUSH	CX
 13334 00001CC2 88C1                    	MOV	CL,AL
 13335 00001CC4 B500                    	MOV	CH,0
 13336 00001CC6 E307                    	JCXZ	POPTAB
 13337                                  TABLP:
 13338 00001CC8 B020                    	MOV	AL," "
 13339 00001CCA E880FF                  	CALL	OUTT
 13340 00001CCD E2F9                    	LOOP	TABLP
 13341                                  POPTAB:
 13342 00001CCF 59                      	POP	CX
 13343                                  
 13344 00001CD0 C3                      	RETN
 13345                                  
 13346                                  ZERPOS:
 13347                                  	;MOV	BYTE PTR [CARPOS],0
 13348 00001CD1 36C606[F901]00          	MOV	BYTE [SS:CARPOS],0
 13349                                  	; 10/08/2018
 13350 00001CD7 EB81                    	JMP	short OUTCH ; 04/05/2019
 13351                                  	
 13352                                  	; 18/12/2022
 13353                                  ;OUTJ:	
 13354                                  	;JMP	OUTT
 13355                                  
 13356                                  BACKPOS:
 13357                                  	;DEC	BYTE PTR [CARPOS]
 13358 00001CD9 36FE0E[F901]            	DEC	BYTE [SS:CARPOS]
 13359 00001CDE E979FF                  	JMP	OUTCH
 13360                                  
 13361                                  BUFOUT:
 13362 00001CE1 3C20                    	CMP	AL," "
 13363 00001CE3 7315                    	JAE	SHORT OUTJ		;Normal char
 13364 00001CE5 3C09                    	CMP	AL,9
 13365 00001CE7 7411                    	JZ	SHORT OUTJ		;OUT knows how to expand tabs
 13366                                  	;DOS 3.3  7/14/86
 13367 00001CE9 3C15                    	CMP	AL,"U"-"@" ; 15h	; turn ^U to section symbol
 13368 00001CEB 740D                    	JZ	short CTRLU
 13369 00001CED 3C14                    	CMP	AL,"T"-"@" ; 14h	; turn ^T to paragraph symbol
 13370 00001CEF 7409                    	JZ	short CTRLU
 13371                                  NOT_CTRLU:
 13372                                  	;DOS 3.3  7/14/86
 13373 00001CF1 50                      	PUSH	AX
 13374 00001CF2 B05E                    	MOV	AL,"^"
 13375 00001CF4 E856FF                  	CALL	OUTT		;Print '^' before control chars
 13376 00001CF7 58                      	POP	AX
 13377 00001CF8 0C40                    	OR	AL,40H		;Turn it into Upper case mate
 13378                                  CTRLU:
 13379                                  	;CALL	OUTT
 13380                                  	; 18/12/2022
 13381                                  OUTJ:
 13382 00001CFA E950FF                  	jmp	OUTT
 13383                                  ;BUFOUT_RETN:
 13384                                  	;RETN
 13385                                  
 13386                                  ;
 13387                                  ;----------------------------------------------------------------------------
 13388                                  ;
 13389                                  ;**	$STD_AUX_INPUT - System Call 3
 13390                                  ;
 13391                                  ;	$STD_AUX_INPUT returns a character from Aux Input
 13392                                  ;
 13393                                  ;	ENTRY	none
 13394                                  ;	EXIT	(al) = character
 13395                                  ;	USES	all
 13396                                  ;
 13397                                  ;----------------------------------------------------------------------------
 13398                                  ;
 13399                                  
 13400                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13401                                  
 13402                                  _$STD_AUX_INPUT:	;System call 3
 13403                                  
 13404 00001CFD E8193E                  	CALL	STATCHK
 13405 00001D00 BB0300                  	MOV	BX,3
 13406 00001D03 E8C321                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 13407                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 13408                                  	;retc
 13409                                  	; 16/12/2022
 13410                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13411                                  	;JC	SHORT BUFOUT_RETN
 13412                                  	;JMP	SHORT TAISTRT
 13413                                  	; 07/12/2022
 13414 00001D06 7304                    	jnc	SHORT TAISTRT
 13415 00001D08 C3                      	retn	
 13416                                  
 13417                                  AUXILP:
 13418 00001D09 E8DF3D                  	CALL	SPOOLINT
 13419                                  TAISTRT:
 13420 00001D0C B401                    	MOV	AH,1
 13421 00001D0E E83F31                  	CALL	IOFUNC
 13422 00001D11 74F6                    	JZ	SHORT AUXILP
 13423 00001D13 30E4                    	XOR	AH,AH
 13424                                  	; 16/12/2022
 13425                                  	;CALL	IOFUNC
 13426                                  	;RETN
 13427                                  	; 07/12/2022
 13428 00001D15 E93831                  	jmp	IOFUNC
 13429                                  
 13430                                  ;
 13431                                  ;----------------------------------------------------------------------------
 13432                                  ;
 13433                                  ;**	$STD_AUX_OUTPUT - Output character to AUX
 13434                                  ;
 13435                                  ;	ENTRY	(dl) = character
 13436                                  ;	EXIT	none
 13437                                  ;	USES	all
 13438                                  ;
 13439                                  ;----------------------------------------------------------------------------
 13440                                  ;
 13441                                  
 13442                                  _$STD_AUX_OUTPUT:	;System call 4
 13443                                  
 13444 00001D18 53                      	PUSH	BX
 13445 00001D19 BB0300                  	MOV	BX,3
 13446 00001D1C EB04                    	JMP	SHORT SENDOUT
 13447                                  
 13448                                  ;
 13449                                  ;----------------------------------------------------------------------------
 13450                                  ;
 13451                                  ;**	$STD_PRINTER_OUTPUT - Output character to printer
 13452                                  ;
 13453                                  ;	ENTRY	(dl) = character
 13454                                  ;	EXIT	none
 13455                                  ;	USES	all
 13456                                  ;
 13457                                  ;----------------------------------------------------------------------------
 13458                                  ;
 13459                                  
 13460                                  _$STD_PRINTER_OUTPUT:	;System call 5
 13461                                  
 13462 00001D1E 53                      	PUSH	BX
 13463 00001D1F BB0400                  	MOV	BX,4
 13464                                  
 13465                                  SENDOUT:
 13466 00001D22 88D0                    	MOV	AL,DL
 13467 00001D24 50                      	PUSH	AX
 13468 00001D25 E8F13D                  	CALL	STATCHK
 13469 00001D28 58                      	POP	AX
 13470 00001D29 1E                      	PUSH	DS
 13471 00001D2A 56                      	PUSH	SI
 13472                                  LISSTRT2:
 13473 00001D2B E8D0FE                  	CALL	RAWOUT2
 13474                                  TRIPOP:
 13475 00001D2E 5E                      	POP	SI
 13476 00001D2F 1F                      	POP	DS
 13477 00001D30 5B                      	POP	BX
 13478                                  SCIS_RETN:	; 20/07/2018
 13479 00001D31 C3                      	RETN
 13480                                  ;
 13481                                  ;----------------------------------------------------------------------------
 13482                                  ;
 13483                                  ;**	$STD_CON_INPUT_STATUS - System Call 11
 13484                                  ;
 13485                                  ;	Check console input status
 13486                                  ;
 13487                                  ;	ENTRY	none
 13488                                  ;	EXIT	AL = -1 character available, = 0 no character
 13489                                  ;	USES	all
 13490                                  ;
 13491                                  ;----------------------------------------------------------------------------
 13492                                  ;
 13493                                  
 13494                                  _$STD_CON_INPUT_STATUS:		;System call 11
 13495                                  
 13496 00001D32 E8E43D                  	CALL	STATCHK
 13497 00001D35 B000                    	MOV	AL,0		; no xor!!
 13498                                  	;retz
 13499 00001D37 74F8                    	JZ	SHORT SCIS_RETN ; 15/04/2018
 13500                                  	;OR	AL,-1
 13501                                  	; 15/01/2024 (PCDOS 7.1 IBMDOS.COM)
 13502 00001D39 48                      	dec	ax ; al = -1 
 13503                                  ;SCIS_RETN:
 13504 00001D3A C3                      	RETN
 13505                                  
 13506                                  ;
 13507                                  ;----------------------------------------------------------------------------
 13508                                  ;
 13509                                  ;**	$STD_CON_INPUT_FLUSH - System Call 12
 13510                                  ;
 13511                                  ;	Flush console input buffer and perform call in AL
 13512                                  ;
 13513                                  ;	ENTRY	(AL) = DOS function to be called after flush (1,6,7,8,10)
 13514                                  ;	EXIT	(al) = 0 iff (al) was not one of the supported fcns
 13515                                  ;		return arguments for the fcn supplied in (AL)
 13516                                  ;	USES	all
 13517                                  ;
 13518                                  ;----------------------------------------------------------------------------
 13519                                  ;
 13520                                  
 13521                                  _$STD_CON_INPUT_FLUSH:		;System call 12
 13522                                  
 13523 00001D3B 50                      	PUSH	AX
 13524 00001D3C 52                      	PUSH	DX
 13525 00001D3D 31DB                    	XOR	BX,BX
 13526 00001D3F E88721                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 13527                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 13528 00001D42 7205                    	JC	SHORT BADJFNCON
 13529 00001D44 B404                    	MOV	AH,4
 13530 00001D46 E80731                  	CALL	IOFUNC
 13531                                  
 13532                                  BADJFNCON:
 13533 00001D49 5A                      	POP	DX
 13534 00001D4A 58                      	POP	AX
 13535 00001D4B 88C4                    	MOV	AH,AL
 13536 00001D4D 3C01                    	CMP	AL,1
 13537 00001D4F 7413                    	JZ	SHORT REDISPJ
 13538 00001D51 3C06                    	CMP	AL,6
 13539 00001D53 740F                    	JZ	SHORT REDISPJ
 13540 00001D55 3C07                    	CMP	AL,7
 13541 00001D57 740B                    	JZ	SHORT REDISPJ
 13542 00001D59 3C08                    	CMP	AL,8
 13543 00001D5B 7407                    	JZ	SHORT REDISPJ
 13544 00001D5D 3C0A                    	CMP	AL,10
 13545 00001D5F 7403                    	JZ	SHORT REDISPJ
 13546 00001D61 B000                    	MOV	AL,0
 13547 00001D63 C3                      	RETN
 13548                                  
 13549                                  REDISPJ:
 13550 00001D64 FA                      	CLI
 13551                                  	;transfer REDISP
 13552 00001D65 E90DE6                  	JMP	REDISP
 13553                                  
 13554                                  ;============================================================================
 13555                                  ; FCBIO.ASM, MSDOS 6.0, 1991
 13556                                  ;============================================================================
 13557                                  ; 20/07/2018 - Retro DOS v3.0
 13558                                  ; 17/05/2019 - Retro DOS v4.0
 13559                                  
 13560                                  ;**	FCBIO.ASM - Ancient 1.0 1.1 FCB system calls
 13561                                  ;
 13562                                  ;	$GET_FCB_POSITION
 13563                                  ;	$FCB_DELETE
 13564                                  ;	$GET_FCB_FILE_LENGTH
 13565                                  ;	$FCB_CLOSE
 13566                                  ;	$FCB_RENAME
 13567                                  ;	SaveFCBInfo
 13568                                  ;	ResetLRU
 13569                                  ;	SetOpenAge
 13570                                  ;	LRUFCB
 13571                                  ;	FCBRegen
 13572                                  ;	BlastSFT
 13573                                  ;	CheckFCB
 13574                                  ;	SFTFromFCB
 13575                                  ;	FCBHardErr
 13576                                  ;
 13577                                  ;	Revision history:
 13578                                  ;
 13579                                  ;		Created: ARR 4 April 1983"
 13580                                  ;			 MZ  6 June  1983 completion of functions
 13581                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 13582                                  ;					  times.  Change so successive closes work by
 13583                                  ;					  always returning OK.	Also, detect I/O to
 13584                                  ;					  already closed FCB and return EOF.
 13585                                  ;			 MZ 16 Jan   1984 More braindamage.  Need to separate info
 13586                                  ;					  out of sft into FCB for reconnection
 13587                                  ;
 13588                                  ;		A000	 version 4.00  Jan. 1988
 13589                                  
 13590                                  ;Break <$Get_FCB_Position - set random record fields to current pos>
 13591                                  ;----------------------------------------------------------------------------
 13592                                  ;
 13593                                  ;   $Get_FCB_Position - look at an FCB, retrieve the current position from the
 13594                                  ;	extent and next record field and set the random record field to point
 13595                                  ;	to that record
 13596                                  ;
 13597                                  ;   Inputs:	DS:DX point to a possible extended FCB
 13598                                  ;   Outputs:	The random record field of the FCB is set to the current record
 13599                                  ;   Registers modified: all
 13600                                  ;
 13601                                  ;----------------------------------------------------------------------------
 13602                                  ;
 13603                                  
 13604                                  _$GET_FCB_POSITION:
 13605 00001D68 E80A05                  	call	GetExtended		; point to FCB
 13606 00001D6B E8DB04                  	call	GetExtent		; DX:AX is current record
 13607                                  	;mov	[si+21h],ax
 13608 00001D6E 894421                  	MOV	[SI+SYS_FCB.RR],AX 	; drop in low order piece
 13609                                  	;mov	[si+23h],dl
 13610 00001D71 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; drop in high order piece
 13611                                  	;cmp	word [si+0Eh],64
 13612 00001D74 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 13613 00001D78 7303                    	JAE	short GetFCBBye
 13614                                  	;mov	[si+24h],dh
 13615 00001D7A 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 13616                                  GoodPath:	; 16/12/2022
 13617                                  GetFCBBye:
 13618 00001D7D E90CE9                  	jmp	FCB_RET_OK
 13619                                  
 13620                                  ;Break <$FCB_Delete - remove several files that match the input FCB>
 13621                                  ;----------------------------------------------------------------------------
 13622                                  ;
 13623                                  ;**	$FCB_Delete - Delete from FCB Template
 13624                                  ;
 13625                                  ;	given an FCB, remove all directory entries in the current
 13626                                  ;	directory that have names that match the FCB's ?  marks.
 13627                                  ;
 13628                                  ;	ENTRY	(DS:DX) = address of FCB
 13629                                  ;	EXIT	entries matching the FCB are deleted
 13630                                  ;		(al) = ff iff no entries were deleted
 13631                                  ;	USES	all
 13632                                  ;
 13633                                  ;----------------------------------------------------------------------------
 13634                                  ;
 13635                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13636                                  
 13637                                  _$FCB_DELETE:		; System call 19
 13638                                  					; OpenBuf is in DOSDATA
 13639 00001D80 BF[BE03]                	MOV	DI,OPENBUF 		; appropriate place 
 13640                                  
 13641 00001D83 E87457                  	call	TransFCB		; convert FCB to path
 13642 00001D86 7207                    	JC	short BadPath 		; signal no deletions
 13643                                  
 13644 00001D88 16                      	push	SS
 13645 00001D89 1F                      	pop	DS			; SS is DOSDATA
 13646                                  
 13647 00001D8A E8FC0D                  	call	DOS_DELETE		; wham
 13648                                  	;JC	short BadPath
 13649                                  	; 16/12/2022
 13650 00001D8D 73EE                    	jnc 	short GoodPath
 13651                                  ;GoodPath:
 13652                                  ;	;jmp	FCB_RET_OK		; do a good return
 13653                                  ;	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13654                                  ;	jmp	short GetFCBBye
 13655                                  
 13656                                  BadPath:
 13657                                  	; Error code is in AX
 13658                                  
 13659 00001D8F E9FDE8                  	jmp	FCB_RET_ERR		; let someone else signal the error
 13660                                  
 13661                                  ;Break <$Get_FCB_File_Length - return the length of a file>
 13662                                  ;----------------------------------------------------------------------------
 13663                                  ;
 13664                                  ;   $Get_FCB_File_Length - set the random record field to the length of the
 13665                                  ;	file in records (rounded up if partial).
 13666                                  ;
 13667                                  ;   Inputs:	DS:DX - point to a possible extended FCB
 13668                                  ;   Outputs:	Random record field updated to reflect the number of records
 13669                                  ;   Registers modified: all
 13670                                  ;
 13671                                  ;----------------------------------------------------------------------------
 13672                                  ;
 13673                                  	; 15/01/2024 - Retrodos v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 13674                                  
 13675                                  _$GET_FCB_FILE_LENGTH:
 13676                                  
 13677 00001D92 E8E004                  	call	GetExtended		; get real FCB pointer
 13678                                  					; DX points to Input FCB
 13679                                  
 13680                                  					; OpenBuf is in DOSDATA
 13681 00001D95 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 13682                                  
 13683 00001D98 1E                      	push	ds			; save pointer to true FCB
 13684 00001D99 56                      	push	si
 13685 00001D9A E85D57                  	call	TransFCB		; Trans name DS:DX, sets SATTRIB
 13686 00001D9D 5E                      	pop	si
 13687 00001D9E 1F                      	pop	ds
 13688 00001D9F 72EE                    	JC	short BadPath
 13689 00001DA1 1E                      	push	ds			; save pointer
 13690 00001DA2 56                      	push	si
 13691 00001DA3 16                      	push	ss		
 13692 00001DA4 1F                      	pop	ds
 13693 00001DA5 E84012                  	call	GET_FILE_INFO		; grab the info
 13694 00001DA8 5E                      	pop	si			; get pointer back
 13695 00001DA9 1F                      	pop	ds
 13696 00001DAA 72E3                    	JC	short BadPath 		; invalid something
 13697                                  	; 15/01/2024
 13698                                  	;MOV	DX,BX (*)		; get high order size
 13699                                  	;MOV	AX,DI (**)		; get low order size
 13700 00001DAC 89D8                    	mov	ax,bx ; hw of file size
 13701                                  	;
 13702                                  	;mov	bx,[si+0Eh]
 13703 00001DAE 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 13704 00001DB1 09DB                    	OR	BX,BX			; empty record => 0 size for file
 13705 00001DB3 7502                    	JNZ	short GetSize 		; not empty
 13706                                  	;MOV	BX,128
 13707 00001DB5 B380                    	mov	bl,128	; 15/01/2024
 13708                                  GetSize:
 13709                                  	; 15/01/2024
 13710                                  	;MOV	DI,AX			; save low order word
 13711                                  	;MOV	AX,DX			; move high order for divide
 13712                                  	;xchg	ax,dx ; (*)
 13713                                  	; ax = hw of file size
 13714                                  
 13715 00001DB7 31D2                    	XOR	DX,DX			; clear out high
 13716 00001DB9 F7F3                    	DIV	BX			; wham
 13717 00001DBB 50                      	PUSH	AX			; save dividend
 13718 00001DBC 89F8                    	MOV	AX,DI ; (**)		; get low order piece
 13719 00001DBE F7F3                    	DIV	BX			; wham
 13720 00001DC0 89D1                    	MOV	CX,DX			; save remainder
 13721 00001DC2 5A                      	POP	DX			; get high order dividend
 13722 00001DC3 E306                    	JCXZ	LengthStore		; no roundup
 13723 00001DC5 83C001                  	ADD	AX,1
 13724 00001DC8 83D200                  	ADC	DX,0			; 32-bit increment
 13725                                  LengthStore:
 13726                                  	;mov	[si+21h],ax
 13727 00001DCB 894421                  	MOV	[SI+SYS_FCB.RR],AX	; store low order
 13728                                  	;mov	[si+23h],dl
 13729 00001DCE 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; store high order
 13730 00001DD1 08F6                    	OR	DH,DH
 13731 00001DD3 74A8                    	JZ	short GoodPath		; not storing insignificant zero
 13732                                  	;mov	[si+24h],dh
 13733 00001DD5 887424                  	MOV	[SI+SYS_FCB.RR+3],DH	; save that high piece
 13734                                  	; 16/12/2022
 13735                                  GoodRet:
 13736                                  	;jmp	FCB_RET_OK
 13737 00001DD8 EBA3                    	jmp	short GoodPath
 13738                                  
 13739                                  ;Break <$FCB_Close - close a file>
 13740                                  ;----------------------------------------------------------------------------
 13741                                  ;
 13742                                  ;   $FCB_Close - given an FCB, look up the SFN and close it. Do not free it
 13743                                  ;	as the FCB may be used for further I/O
 13744                                  ;
 13745                                  ;   Inputs:	DS:DX point to FCB
 13746                                  ;   Outputs:	AL = FF if file was not found on disk
 13747                                  ;   Registers modified: all
 13748                                  ;
 13749                                  ;----------------------------------------------------------------------------
 13750                                  ;
 13751                                  	; 16/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 13752                                  
 13753                                  _$FCB_CLOSE:		; System call 16
 13754                                  
 13755 00001DDA 30C0                    	XOR	AL,AL			; default search attributes
 13756 00001DDC E89604                  	call	GetExtended		; DS:SI point to real FCB
 13757 00001DDF 7403                    	JZ	short NoAttr		; not extended
 13758 00001DE1 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 13759                                  NoAttr:
 13760                                  					; SS override
 13761 00001DE4 36A2[6B05]              	MOV	[SS:ATTRIB],AL		; stash away found attributes
 13762 00001DE8 E8DD03                  	call	SFTFromFCB
 13763 00001DEB 72EB                    	JC	short GoodRet 		; MZ 16 Jan Assume death
 13764                                  
 13765                                  	; If the sharer is present, then the SFT is not regenable. Thus, 
 13766                                  	; there is no need to set the SFT's attribute.
 13767                                  
 13768                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 13769                                  	;;; done
 13770                                  
 13771                                  	;mov	al,[es:di+4]
 13772 00001DED 268A4504                	MOV	AL,[ES:DI+SF_ENTRY.sf_attr]
 13773 00001DF1 30E4                    	XOR	AH,AH
 13774 00001DF3 50                      	PUSH	AX
 13775                                  
 13776                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 13777                                  	;;; done
 13778                                  
 13779 00001DF4 E82F5F                  	call	CheckShare
 13780 00001DF7 7508                    	JNZ	short NoStash
 13781 00001DF9 36A0[6B05]              	MOV	AL,[SS:ATTRIB]
 13782                                  	;mov	[es:di+4],al
 13783 00001DFD 26884504                	MOV	[ES:DI+SF_ENTRY.sf_attr],AL ; attempted attribute for close
 13784                                  NoStash:
 13785                                  
 13786                                  ; 16/01/2024
 13787                                  %if 0
 13788                                  	;mov	ax,[si+14h]
 13789                                  	MOV	AX,[SI+SYS_FCB.FDATE] ; move in the time and date
 13790                                  	;mov	[es:di+0Fh],ax
 13791                                  	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 13792                                  	;mov	ax,[si+16h]
 13793                                  	MOV	AX,[SI+SYS_FCB.FTIME]
 13794                                  	;mov	[es:di+0Dh],ax
 13795                                  	MOV	[ES:DI+SF_ENTRY.sf_time],AX
 13796                                  	;mov	ax,[si+10h]
 13797                                  	MOV	AX,[SI+SYS_FCB.FILSIZ]
 13798                                  	;mov	[es:di+11h],ax
 13799                                  	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 13800                                  	;mov	ax,[si+12h]
 13801                                  	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 13802                                  	;mov	[es:di+13h],ax
 13803                                  	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 13804                                  	;or	word [es:di+5],4000h
 13805                                  	; 17/12/2022
 13806                                  	or	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8) ; 40h
 13807                                  	;OR	word [ES:DI+SF_ENTRY.sf_flags],sf_close_nodate
 13808                                  %else
 13809                                  	; 16/01/2024 (PCDOS 7.1 IBMDOS.COM)
 13810 00001E01 1E                      	push	ds
 13811                                  	;lds	ax,[si+14h]
 13812 00001E02 C54414                  	lds	ax,[si+SYS_FCB.FDATE]	; move in the time and date
 13813                                  	;mov	[es:di+0Fh],ax
 13814 00001E05 2689450F                	mov	[es:di+SF_ENTRY.sf_date],ax
 13815                                  	;mov	[es:di+0Dh],ds		
 13816 00001E09 268C5D0D                	mov	[es:di+SF_ENTRY.sf_time],ds
 13817 00001E0D 1F                      	pop	ds
 13818                                  	;lds	ax,[si+10h]
 13819 00001E0E C54410                  	lds	ax,[si+SYS_FCB.FILSIZ]
 13820                                  	;mov	[es:di+11h],ax
 13821 00001E11 26894511                	mov	[es:di+SF_ENTRY.sf_size],ax
 13822                                  	;mov	[es:di+13h],ds
 13823 00001E15 268C5D13                	mov	[es:di+SF_ENTRY.sf_size+2],ds
 13824                                  	; 16/01/2024
 13825                                  	;;or	word [es:di+5], 4000h
 13826                                  	;or	word [es:di+SF_ENTRY.sf_flags], sf_close_nodate
 13827 00001E19 26804D0640              	or	byte [es:di+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8) ; 40h
 13828                                  %endif
 13829                                  
 13830 00001E1E 16                      	push	ss
 13831 00001E1F 1F                      	pop	ds
 13832 00001E20 E82219                  	call	DOS_CLOSE	; wham
 13833 00001E23 C43E[9E05]              	LES	DI,[THISSFT]
 13834                                  
 13835                                  	;;; 9/8/86 F.C. restore SFT attribute
 13836 00001E27 59                      	POP	CX
 13837                                  	;mov	[es:di+4],cl
 13838 00001E28 26884D04                	MOV	[ES:DI+SF_ENTRY.sf_attr],CL
 13839                                  	;;; 9/8/86 F.C. restore SFT attribute
 13840                                  
 13841 00001E2C 9C                      	PUSHF
 13842                                  	;test	word [es:di],0FFFFh
 13843                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],0
 13844                                  				; zero ref count gets blasted
 13845 00001E2D 26833D00                	cmp	word [ES:DI],0
 13846 00001E31 7507                    	jnz     short CloseOK
 13847 00001E33 50                      	PUSH	AX
 13848 00001E34 B04D                    	MOV	AL,'M' ; 4Dh
 13849 00001E36 E80903                  	call	BlastSFT
 13850 00001E39 58                      	POP	AX
 13851                                  CloseOK:
 13852 00001E3A 9D                      	POPF
 13853 00001E3B 739B                    	JNC	short GoodRet
 13854                                  	;cmp	al,6
 13855 00001E3D 3C06                    	CMP	AL,error_invalid_handle
 13856 00001E3F 7497                    	JZ	short GoodRet
 13857                                  	;mov	al,2
 13858 00001E41 B002                    	MOV	AL,error_file_not_found
 13859                                  fren90:
 13860                                  	; 16/12/2022
 13861                                  fcb_close_err:
 13862 00001E43 E949E8                  	jmp	FCB_RET_ERR
 13863                                  
 13864                                  ;
 13865                                  ;----------------------------------------------------------------------------
 13866                                  ;
 13867                                  ;**	$FCB_Rename - Rename a File
 13868                                  ;
 13869                                  ;	$FCB_Rename - rename a file in place within a directory. Renames
 13870                                  ;	multiple files copying from the meta characters.
 13871                                  ;
 13872                                  ;	ENTRY	DS:DX point to an FCB. The normal name field is the source
 13873                                  ;		    name of the files to be renamed. Starting at offset 11h
 13874                                  ;		    in the FCB is the destination name.
 13875                                  ;	EXIT	AL = 0 -> no error occurred and all files were renamed
 13876                                  ;		AL = FF -> some files may have been renamed but:
 13877                                  ;			rename to existing file or source file not found
 13878                                  ;	USES	ALL
 13879                                  ;
 13880                                  ;----------------------------------------------------------------------------
 13881                                  ;
 13882                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13883                                  	; 16/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 13884                                  
 13885                                  _$FCB_RENAME:		; System call 23
 13886                                  
 13887 00001E46 E82C04                  	call	GetExtended		; get pointer to real FCB
 13888 00001E49 52                      	push	dx
 13889 00001E4A 8A04                    	MOV	AL,[SI] 		; get drive byte
 13890 00001E4C 83C610                  	ADD	SI,10h			; point to destination
 13891                                  
 13892                                  					; RenBuf is in DOSDATA
 13893 00001E4F BF[3E04]                	MOV	DI,RENBUF		; point to destination buffer
 13894 00001E52 FF34                    	push	word [SI]
 13895 00001E54 1E                      	push	ds
 13896                                  	;push	di			; save source pointer for TransFCB
 13897                                  	; 16/01/2024 (Retro DOS v4 BugFix!)
 13898 00001E55 56                      	push	si
 13899 00001E56 8804                    	MOV	[SI],AL			; drop in real drive
 13900 00001E58 89F2                    	MOV	DX,SI			; let TransFCB know where the FCB is
 13901 00001E5A E89D56                  	call	TransFCB		; munch this pathname
 13902 00001E5D 5E                      	pop	si
 13903 00001E5E 1F                      	pop	ds	
 13904 00001E5F 8F04                    	pop	WORD [SI]		; get path back
 13905 00001E61 5A                      	pop	dx			; Original FCB pointer
 13906 00001E62 72DF                    	JC	short fren90		; bad path -> error
 13907                                  
 13908                                  					; SS override for WFP_Start & Ren_WFP
 13909 00001E64 368B36[B205]            	MOV	SI,[ss:WFP_START]	; get pointer
 13910 00001E69 368936[B405]            	MOV	[ss:REN_WFP],SI		; stash it
 13911                                  
 13912                                  					; OpenBuf is in DOSDATA
 13913 00001E6E BF[BE03]                	MOV	DI,OPENBUF		; appropriate spot
 13914 00001E71 E88656                  	call	TransFCB		; wham
 13915                                  					; NOTE that this call is pointing
 13916                                  					;  back to the ORIGINAL FCB so
 13917                                  					;  SATTRIB gets set correctly
 13918 00001E74 72CD                    	JC	short fren90		; error
 13919                                  	;;;
 13920                                  	; 16/01/2024 - Retro DOS 5.0
 13921                                  	; (PCDOS 7.1 IBMDOS.COM)
 13922 00001E76 36C606[7B12]43          	mov	byte [ss:PATHNAMELEN], 67 ; DIRSTRLEN = 67
 13923                                  	;mov	word [ss:PATHNAMELEN], 67 ; set pathname length to 67
 13924                                  	;;;
 13925 00001E7C E81D0F                  	call	DOS_RENAME
 13926 00001E7F 72C2                    	JC	short fren90
 13927                                  	; 16/12/2022
 13928 00001E81 E908E8                  	jmp	FCB_RET_OK
 13929                                  	
 13930                                  ;	Error -
 13931                                  ;
 13932                                  ;	(al) = error code
 13933                                  
 13934                                  	; 16/12/2022
 13935                                  ;fren90:	
 13936                                  ;	;jmp	FCB_RET_ERR
 13937                                  ;	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13938                                  ;	jmp	short fcb_close_err
 13939                                  
 13940                                  ;Break <Misbehavior fixers>
 13941                                  ;
 13942                                  ;   FCBs suffer from several problems. First, they are maintained in the
 13943                                  ;   user's space so he may move them at will. Second, they have a small
 13944                                  ;   reserved area that may be used for system information. Third, there was
 13945                                  ;   never any "rules for behavior" for FCBs; there was no protocol for their
 13946                                  ;   usage.
 13947                                  ;
 13948                                  ;   This results in the following misbehavior:
 13949                                  ;
 13950                                  ;	infinite opens of the same file:
 13951                                  ;
 13952                                  ;	While (TRUE) {			While (TRUE) {
 13953                                  ;	    FCBOpen (FCB);		    FCBOpen (FCB);
 13954                                  ;	    Read (FCB); 		    Write (FCB);
 13955                                  ;	    }				    }
 13956                                  ;
 13957                                  ;	infinite opens of different files:
 13958                                  ;
 13959                                  ;	While (TRUE) {			While (TRUE) {
 13960                                  ;	    FCBOpen (FCB[i++]); 	    FCBOpen (FCB[i++]);
 13961                                  ;	    Read (FCB); 		    Write (FCB);
 13962                                  ;	    }				    }
 13963                                  ;
 13964                                  ;	multiple closes of the same file:
 13965                                  ;
 13966                                  ;	FCBOpen (FCB);
 13967                                  ;	while (TRUE)
 13968                                  ;	    FCBClose (FCB);
 13969                                  ;
 13970                                  ;	I/O after closing file:
 13971                                  ;
 13972                                  ;	FCBOpen (FCB);
 13973                                  ;	while (TRUE) {
 13974                                  ;	    FCBWrite (FCB);
 13975                                  ;	    FCBClose (FCB);
 13976                                  ;	    }
 13977                                  ;
 13978                                  ;   The following is am implementation of a methodology for emulating the
 13979                                  ;   above with the exception of I/O after close. We are NOT attempting to
 13980                                  ;   resolve that particular misbehavior. We will enforce correct behaviour in
 13981                                  ;   FCBs when they refer to a network file or when there is file sharing on
 13982                                  ;   the local machine.
 13983                                  ;
 13984                                  ;   The reserved fields of the FCB (10 bytes worth) is divided up into various
 13985                                  ;   structures depending on the file itself and the state of operations of the
 13986                                  ;   OS. The information contained in this reserved field is enough to
 13987                                  ;   regenerate the SFT for the local non-shared file. It is assumed that this
 13988                                  ;   regeneration procedure may be expensive. The SFT for the FCB is
 13989                                  ;   maintained in a LRU cache as the ONLY performance inprovement.
 13990                                  ;
 13991                                  ;   No regeneration of SFTs is attempted for network FCBs.
 13992                                  ;
 13993                                  ;   To regenerate the SFT for a local FCB, it is necessary to determine if the
 13994                                  ;   file sharer is working. If the file sharer is present then the SFT is not
 13995                                  ;   regenerated.
 13996                                  ;
 13997                                  ;   Finally, if there is no local sharing, the full name of the file is no
 13998                                  ;   longer available. We can make up for this by using the following
 13999                                  ;   information:
 14000                                  ;
 14001                                  ;	The Drive number (from the DPB).
 14002                                  ;	The physical sector of the directory that contains the entry.
 14003                                  ;	The relative position of the entry in the sector.
 14004                                  ;	The first cluster field.
 14005                                  ;	The last used SFT.
 14006                                  ;      OR In the case of a device FCB
 14007                                  ;	The low 6 bits of sf_flags (indicating device type)
 14008                                  ;	The pointer to the device header
 14009                                  ;
 14010                                  ;   We read in the particular directory sector and examine the indicated
 14011                                  ;   directory entry. If it matches, then we are kosher; otherwise, we fail.
 14012                                  ;
 14013                                  ;   Some key items need to be remembered:
 14014                                  ;
 14015                                  ;	Even though we are caching SFTs, they may contain useful sharing
 14016                                  ;	information. We enforce good behavior on the FCBs.
 14017                                  ;
 14018                                  ;	Network support must not treat FCBs as impacting the ref counts on
 14019                                  ;	open VCs. The VCs may be closed only at process termination.
 14020                                  ;
 14021                                  ;	If this is not an installed version of the DOS, file sharing will
 14022                                  ;	always be present.
 14023                                  ;
 14024                                  ;	We MUST always initialize lstclus to = firclus when regenerating a
 14025                                  ;	file. Otherwise we start allocating clusters up the wazoo.
 14026                                  ;
 14027                                  ;	Always initialize, during regeneration, the mode field to both isFCB
 14028                                  ;	and open_for_both. This is so the FCB code in the sharer can find the
 14029                                  ;	proper OI record.
 14030                                  ;
 14031                                  ;   The test bits are:
 14032                                  ;
 14033                                  ;	00 -> local file
 14034                                  ;	40 -> sharing local
 14035                                  ;	80 -> network
 14036                                  ;	C0 -> local device
 14037                                  
 14038                                  ;Break	<SaveFCBInfo - store pertinent information from an SFT into the FCB>
 14039                                  ;----------------------------------------------------------------------------
 14040                                  ;
 14041                                  ;   SaveFCBInfo - given an FCB and its associated SFT, copy the relevant
 14042                                  ;	pieces of information into the FCB to allow for subsequent
 14043                                  ;	regeneration. Poke LRU also.
 14044                                  ;
 14045                                  ;   Inputs:	ThisSFT points to a complete SFT.
 14046                                  ;		DS:SI point to the FCB (not an extended one)
 14047                                  ;   Outputs:	The relevant reserved fields in the FCB are filled in.
 14048                                  ;		DS:SI preserved
 14049                                  ;		ES:DI point to sft
 14050                                  ;   Registers modified: All
 14051                                  ;
 14052                                  ;
 14053                                  ;----------------------------------------------------------------------------
 14054                                  ;
 14055                                  
 14056                                  	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14057                                  	; 20/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 14058                                  	
 14059                                  SaveFCBInfo:
 14060                                  
 14061 00001E84 36C43E[9E05]            	LES	DI,[SS:THISSFT]		; SS override
 14062 00001E89 E8CEF9                  	call	IsSFTNet
 14063 00001E8C 740B                    	JZ	short SaveLocal		; if not network then save local info
 14064                                  ;
 14065                                  ;----- In net support -----
 14066                                  ;
 14067                                  	; 17/05/2019 - Retro DOS v4.0
 14068                                  
 14069                                  	; MSDOS 3.3
 14070                                  	;;mov	ax,[es:di+1Dh]
 14071                                  	;mov	ax,[es:di+SF_ENTRY.sf_dirsec]
 14072                                  	;;mov	[si+1Ah],ax
 14073                                  	;mov	[si+fcb_net_handle],ax
 14074                                  	;push	es
 14075                                  	;push	di
 14076                                  	;;les	di,[es:di+19h]
 14077                                  	;LES	DI,[ES:DI+sf_netid]
 14078                                  	;;mov	[si+1Ch],di
 14079                                  	;MOV	[SI+fcb_netID],DI	; save net ID
 14080                                  	;;mov 	[si+1Eh],es
 14081                                  	;MOV	[SI+fcb_netID+2],ES
 14082                                  	;pop	di
 14083                                  	;pop	es
 14084                                  
 14085                                  	; MSDOS 6.0
 14086                                  	;mov	ax,[es:di+0Bh]
 14087 00001E8E 268B450B                	MOV	AX,[ES:DI+sf_serial_ID] ;AN000;;IFS. save IFS ID
 14088                                  	;mov	[si+1Ch],ax
 14089 00001E92 89441C                  	MOV	[SI+fcb_netID],ax	;AN000;;IFS.
 14090                                  	
 14091                                  	;mov	bl,80h
 14092 00001E95 B380                    	MOV	BL,FCBNETWORK
 14093                                  ;
 14094                                  ;----- END In net support -----
 14095                                  ;
 14096 00001E97 EB63                    	jmp	SHORT SaveSFN
 14097                                  
 14098                                  SaveLocal:
 14099                                  	;IF	Installed
 14100 00001E99 E88A5E                  	call	CheckShare
 14101                                  	;JZ	short SaveNoShare	; no sharer
 14102                                  	;JMP	short SaveShare		; sharer present
 14103                                  	; 16/12/2022
 14104                                  	; 28/07/2019
 14105 00001E9C 7559                    	jnz	short SaveShare
 14106                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14107                                  	;JZ	short SaveNoShare	; no sharer
 14108                                  	;JMP	short SaveShare		; sharer present
 14109                                  
 14110                                  SaveNoShare:
 14111                                  	;;test 	word [es:di+5],80h
 14112                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 14113 00001E9E 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; 80h	
 14114 00001EA3 7542                    	JNZ	short SaveNoShareDev	; Device
 14115                                  
 14116                                  	; Save no sharing local file information
 14117                                  
 14118                                  	;;mov	ax,[es:di+1Dh]  ; MSDOS 3.3
 14119                                  	;mov	ax,[es:di+1Bh]  ; MSDOS 6.0
 14120 00001EA5 268B451B                	MOV	AX,[ES:DI+SF_ENTRY.sf_dirsec] ; get directory sector F.C.
 14121                                  	;mov	[si+1Dh],ax
 14122 00001EA9 89441D                  	MOV	[SI+fcb_nsl_dirsec],AX
 14123                                  
 14124                                  	; MSDOS 6.0
 14125                                  
 14126                                  	;SR; Store high byte of directory sector
 14127                                  	;mov	ax,[es:di+1Dh]
 14128 00001EAC 268B451D                	mov	ax,[es:di+SF_ENTRY.sf_dirsec+2] ; get high word
 14129                                  	
 14130                                  	; SR;
 14131                                  	; We have to store the read-only and archive attributes of the file.
 14132                                  	; We extract it from the SFT and store it in the top two bits of the 
 14133                                  	; sector number ( sector number == 22 bits only )
 14134                                  
 14135                                  	;mov	bl,[es:di+4]
 14136 00001EB0 268A5D04                	mov	bl,[es:di+SF_ENTRY.sf_attr]
 14137 00001EB4 88DF                    	mov	bh,bl
 14138 00001EB6 D0CB                    	ror	bl,1
 14139 00001EB8 D0E7                    	shl	bh,1
 14140 00001EBA 08FB                    	or	bl,bh
 14141 00001EBC 80E3C0                  	and	bl,0C0h
 14142 00001EBF 08D8                    	or	al,bl
 14143                                  	;mov	[si+18h],al ; 08/11/2022
 14144 00001EC1 884418                  	mov	[si+fcb_sfn],al	; sector number = 22 bits
 14145                                  
 14146                                  	; MSDOS 6.0 (& MSDOS 3.3)
 14147                                  	;mov	al,[es:di+1Fh]
 14148 00001EC4 268A451F                	MOV	AL,[ES:DI+SF_ENTRY.sf_dirpos] ; location in sector
 14149                                  	;mov	[si+1Fh],al
 14150 00001EC8 88441F                  	MOV	[SI+fcb_nsl_dirpos],AL
 14151                                  
 14152                                  	; 20/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
 14153                                  	;;;
 14154                                  	;;mov	ax,[es:di+0Bh]	; .sf_firclus:
 14155                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_firclus] ; first cluster
 14156                                  	; 20/01/2024
 14157                                  	; (PCDOS 7.1 IBMDOS.COM - DOSCODE:5DF5h)
 14158                                  	; (Windows ME IO.SYS - BIOSCODE:5D60h)
 14159 00001ECB 268B452B                	mov	ax,[es:di+2Bh]  ; .sf_chain !!! (MSDOS 6.22)
 14160                                  	;mov	ax,[es:di+SF_ENTRY.sf_chain] ; first cluster (32 bit) !?
 14161                                  	;;;
 14162                                  	;mov	[si+1Bh],ax
 14163 00001ECF 89441B                  	MOV	[SI+fcb_nsl_firclus],AX
 14164 00001ED2 B300                    	MOV	BL,0
 14165                                  
 14166                                  	; Create the bits field from the dirty/device bits of the flags word 
 14167                                  	; and the mode byte
 14168                                  
 14169                                  SetFCBBits:
 14170                                  	;mov	ax,[es:di+5]
 14171 00001ED4 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 14172 00001ED8 24C0                    	AND	AL,0C0h 		; mask off drive bits
 14173                                  	;or	al,[es:di+2]
 14174 00001EDA 260A4502                	OR	AL,[ES:DI+SF_ENTRY.sf_mode] ; stick in open mode
 14175                                  	;mov	[si+1Ah], al
 14176 00001EDE 88441A                  	MOV	[SI+fcb_nsl_bits],AL	; save dirty info
 14177                                  
 14178                                  	; MSDOS 6.0
 14179                                  	
 14180                                  	; SR;
 14181                                  	; Check if we came here for local file or device. If for local file, 
 14182                                  	; skip setting of SFT index
 14183                                  	
 14184 00001EE1 08DB                    	or	bl,bl
 14185 00001EE3 7428                    	jz	short SaveNoSFN		; do not save SFN if local file
 14186                                  
 14187 00001EE5 EB15                    	JMP	short SaveSFN 		; go and save SFN
 14188                                  
 14189                                  	; Save no sharing local device information
 14190                                  
 14191                                  SaveNoShareDev:
 14192                                  	; 20/01/2024
 14193                                  	;;mov	ax,[es:di+7]
 14194                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_devptr]
 14195                                  	;;mov	[si+1Ah],ax
 14196                                  	;MOV	[SI+fcb_nsld_drvptr],AX
 14197                                  	;;mov	ax,[es:di+9]
 14198                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_devptr+2]
 14199                                  	;MOV	[SI+fcb_nsld_drvptr+2],AX
 14200                                  	; 20/01/2024 (PCDOS 7.1 IBMDOS.COM)
 14201 00001EE7 06                      	push	es
 14202 00001EE8 26C44507                	les	ax,[es:di+SF_ENTRY.sf_devptr]
 14203 00001EEC 89441A                  	mov	[si+fcb_nsld_drvptr],ax
 14204 00001EEF 8C441C                  	mov	[si+fcb_nsld_drvptr+2],es
 14205 00001EF2 07                      	pop	es
 14206                                  	
 14207                                  	;mov	bl,40h
 14208 00001EF3 B340                    	MOV	BL,FCBDEVICE
 14209                                  	; 28/12/2022
 14210 00001EF5 EBDD                    	JMP	short SetFCBBits	; go and save SFN
 14211                                  
 14212                                  SaveShare:
 14213                                  	;ENDIF
 14214                                  
 14215                                  ;----- In share support -----
 14216                                  
 14217                                  	;call	far [ss:ShSave]
 14218 00001EF7 36FF1E[B800]            	Call	far [ss:JShare+(10*4)] ; 10 = ShSave ; SS Override
 14219                                  
 14220                                  ;----- end in share support -----
 14221                                  
 14222                                  	; 17/05/2019
 14223                                  
 14224                                  SaveSFN:
 14225                                  	;lea	ax,[di-6]
 14226 00001EFC 8D45FA                  	LEA	AX,[DI-SFT.SFTable]
 14227                                  	
 14228                                  	; Adjust for offset to table.
 14229                                  	
 14230 00001EFF 362B06[4000]            	SUB	AX,[SS:SFTFCB]		; SS override for SftFCB
 14231                                  
 14232 00001F04 53                      	push	bx			;bx = FCB type (net/Share or local)
 14233                                  	;;mov	bl,53 ; MSDOS 3.3
 14234                                  	;mov	bl,59 ; MSDOS 6.0
 14235 00001F05 B33B                    	MOV	BL,SF_ENTRY.size
 14236 00001F07 F6F3                    	DIV	BL
 14237                                  	;mov	[si+18h],al
 14238 00001F09 884418                  	MOV	[SI+fcb_sfn],AL		; last used SFN
 14239 00001F0C 5B                      	pop	bx			;restore bx
 14240                                  
 14241                                  SaveNoSFN:
 14242                                  	;mov	ax,[es:di+5]
 14243 00001F0D 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 14244 00001F11 243F                    	AND	AL,3Fh			; get real drive
 14245 00001F13 08D8                    	OR	AL,BL
 14246                                  	;mov	[si+19h],al
 14247 00001F15 884419                  	MOV	[SI+fcb_l_drive],AL
 14248                                  
 14249 00001F18 36A1[1000]              	MOV	AX,[SS:FCBLRU]		; get lru count
 14250 00001F1C 40                      	INC	AX
 14251                                  	;mov	[es:di+15h],ax
 14252 00001F1D 26894515                	MOV	[ES:DI+sf_LRU],AX
 14253 00001F21 7506                    	JNZ	short SimpleStuff
 14254                                  	
 14255                                  	; lru flag overflowed. Run through all FCB sfts and adjust:  
 14256                                  	; LRU < 8000H get set to 0. Others -= 8000h. This LRU = 8000h
 14257                                  	
 14258                                  	;mov	bx,15h
 14259 00001F23 BB1500                  	MOV	BX,SF_ENTRY.sf_position
 14260 00001F26 E80500                  	call	ResetLRU
 14261                                  
 14262                                  	; Set new LRU to AX
 14263                                  SimpleStuff:
 14264 00001F29 36A3[1000]              	MOV	[SS:FCBLRU],AX
 14265 00001F2D C3                      	retn
 14266                                  
 14267                                  ;Break	<ResetLRU - reset overflowed lru counts>
 14268                                  ;----------------------------------------------------------------------------
 14269                                  ;
 14270                                  ;   ResetLRU - during lru updates, we may wrap at 64K. We must walk the
 14271                                  ;   entire set of SFTs and subtract 8000h from their lru counts and truncate
 14272                                  ;   at 0.
 14273                                  ;
 14274                                  ;   Inputs:	BX is offset into SFT field where lru firld is kept
 14275                                  ;		ES:DI point to SFT currently being updated
 14276                                  ;   Outputs:	All FCB SFTs have their lru fields truncated
 14277                                  ;		AX has 8000h
 14278                                  ;   Registers modified: none
 14279                                  ;
 14280                                  ;----------------------------------------------------------------------------
 14281                                  ;
 14282                                  
 14283                                  	; 17/05/2019 - Retro DOS v4.0
 14284                                  ResetLRU:
 14285                                  	; ResetLRU is only called from fcbio.asm. So SS can be assumed to be 
 14286                                  	; DOSDATA
 14287                                  
 14288 00001F2E B80080                  	MOV	AX,8000h
 14289 00001F31 06                      	push	es
 14290 00001F32 57                      	push	di
 14291                                  	;LES	DI,[CS:SFTFCB]		; get pointer to head
 14292 00001F33 36C43E[4000]            	LES	DI,[SS:SFTFCB] ; MSDOS 6.0
 14293                                  	;mov	cx,[es:di+4]
 14294 00001F38 268B4D04                	MOV	CX,[ES:DI+SFT.SFCount]
 14295                                  	;lea	di,[di+6]
 14296 00001F3C 8D7D06                  	LEA	DI,[DI+SFT.SFTable] 	; point at table
 14297                                  ovScan:
 14298 00001F3F 262901                  	SUB	[ES:DI+BX],AX		; decrement lru count
 14299 00001F42 7703                    	JA	short ovLoop
 14300 00001F44 268901                  	MOV	[ES:DI+BX],AX		; truncate at 0
 14301                                  ovLoop:
 14302                                  	;;add	di,53	; MSDOS 3.3
 14303                                  	;add	di,59	; MSDOS 6.0	
 14304 00001F47 83C73B                  	ADD	DI,SF_ENTRY.size	; advance to next
 14305 00001F4A E2F3                    	LOOP	ovScan
 14306 00001F4C 5F                      	pop	di
 14307 00001F4D 07                      	pop	es
 14308 00001F4E 268901                  	MOV	[ES:DI+BX],AX
 14309 00001F51 C3                      	retn
 14310                                  
 14311                                  ;IF  0  ; We dont need this routine any more.
 14312                                  ;
 14313                                  ;Break	<SetOpenAge - update the open age of a SFT>
 14314                                  ;----------------------------------------------------------------------------
 14315                                  ;
 14316                                  ;   SetOpenAge - In order to maintain the first N open files in the FCB cache,
 14317                                  ;   we keep the 'open age' or an LRU count based on opens. We update the
 14318                                  ;   count here and fill in the appropriate field.
 14319                                  ;
 14320                                  ;   Inputs:	ES:DI point to SFT
 14321                                  ;   Outputs:	ES:DI has the open age field filled in.
 14322                                  ;		If open age has wraparound, we will have subtracted 8000h
 14323                                  ;		    from all open ages.
 14324                                  ;   Registers modified: AX
 14325                                  ;
 14326                                  ;----------------------------------------------------------------------------
 14327                                  ;
 14328                                  ;SetOpenAge:
 14329                                  ;	; 20/07/2018 - Retro DOS v3.0
 14330                                  ;	; MSDOS 3.3 - IBMDOS.COM, Offset 2597h 
 14331                                  ;	; (& MSDOS 6.0, FCBIO.ASM)
 14332                                  ;
 14333                                  ;	; SetOpenAge is called from fcbio2.asm. SS can be assumed to be valid.
 14334                                  ;
 14335                                  ;	MOV	AX,[CS:OpenLRU]	; SS override
 14336                                  ;	INC	AX
 14337                                  ;	;mov	[es:di+17h],ax
 14338                                  ;	MOV	[ES:DI+sf_OpenAge],AX
 14339                                  ;	JNZ	short SetDone
 14340                                  ;	;mov	bx,17h
 14341                                  ;	MOV	BX,SF_ENTRY.sf_position+2 ; mov bx,sf_OpenAge
 14342                                  ;	call	ResetLRU
 14343                                  ;SetDone:
 14344                                  ;	MOV	[CS:OpenLRU],AX
 14345                                  ;	retn
 14346                                  ;
 14347                                  ;ENDIF	; SetOpenAge no longer needed
 14348                                  
 14349                                  ; 21/07/2018 - Retro DOS v3.0
 14350                                  ; LRUFCB for MSDOS 6.0 !
 14351                                  
 14352                                  ;Break	<LRUFCB - perform LRU on FCB sfts>
 14353                                  ;----------------------------------------------------------------------------
 14354                                  ;
 14355                                  ;   LRUFCB - find LRU fcb in cache. Set ThisSFT and return it. We preserve
 14356                                  ;	the first keepcount sfts if they are network sfts or if sharing is
 14357                                  ;	loaded.  If carry is set then NO BLASTING is NECESSARY.
 14358                                  ;
 14359                                  ;   Inputs:	none
 14360                                  ;   Outputs:	ES:DI point to SFT
 14361                                  ;		ThisSFT points to SFT
 14362                                  ;		SFT is zeroed
 14363                                  ;		Carry set of closes failed
 14364                                  ;   Registers modified: none
 14365                                  ;
 14366                                  ;----------------------------------------------------------------------------
 14367                                  ;
 14368                                  ; MSDOS 6.0
 14369                                  ;IF 0	; rewritten this routine
 14370                                  ;
 14371                                  ;LRUFCB: ; MSDOS 3.3 - IBMDOS.COM (1987) - Offset 25ADh
 14372                                  ;	call	save_world
 14373                                  ;	
 14374                                  ; Find nth oldest NET/SHARE FCB. We want to find its age for the second scan
 14375                                  ; to find the lease recently used one that is younger than the open age.  We
 14376                                  ; operate be scanning the list n times finding the least age that is greater
 14377                                  ; or equal to the previous minimum age.
 14378                                  ;
 14379                                  ;   BP is the count of times we need to go through this loop.
 14380                                  ;   AX is the current acceptable minimum age to consider
 14381                                  ;
 14382                                  ;	mov	bp,[CS:KEEPCOUNT]	; k = keepcount;
 14383                                  ;	XOR	AX,AX			; low = 0;
 14384                                  ;
 14385                                  ; If we've scanned the table n times, then we are done.
 14386                                  ;
 14387                                  ;lru1:
 14388                                  ;	CMP	bp,0			; while (k--) {
 14389                                  ;	JZ	short lru75
 14390                                  ;	DEC	bp
 14391                                  ;
 14392                                  ; Set up for scan.
 14393                                  ;
 14394                                  ;   AX is the minimum age for consideration
 14395                                  ;   BX is the minimum age found during the scan
 14396                                  ;   SI is the position of the entry that corresponds to BX
 14397                                  ;
 14398                                  ;	MOV	BX,-1			;     min = 0xffff;
 14399                                  ;	MOV	si,BX			;     pos = 0xffff;
 14400                                  ;	LES	DI,[CS:SFTFCB]		;     for (CX=FCBCount; CX>0; CX--)
 14401                                  ;	;mov	cx,[es:di+4]
 14402                                  ;	MOV	CX,[ES:DI+SFT.SFCount]
 14403                                  ;	;lea	di,[di+6]
 14404                                  ;	LEA	DI,[DI+SFT.SFTable]
 14405                                  ;
 14406                                  ; Innermost loop.  If the current entry is free, then we are done.  Or, if the
 14407                                  ; current entry is busy (indicating a previous aborted allocation), then we
 14408                                  ; are done.  In both cases, we use the found entry.
 14409                                  ;
 14410                                  ;lru2:
 14411                                  ;	cmp	word [es:di],0
 14412                                  ;	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0
 14413                                  ;	jz	short lru25
 14414                                  ;	;cmp	word [es:di],-1
 14415                                  ;	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy
 14416                                  ;	cmp	word [es:di],sf_busy
 14417                                  ;	jnz	short lru3
 14418                                  ;
 14419                                  ; The entry is usable without further scan.  Go and use it.
 14420                                  ;
 14421                                  ;lru25:
 14422                                  ;	MOV	si,DI			;	      pos = i;
 14423                                  ;	JMP	short lru11		;	      goto got;
 14424                                  ;
 14425                                  ; See if the entry is for the network or for the sharer.
 14426                                  ;
 14427                                  ;  If for the sharer or network then
 14428                                  ;	if the age < current minimum AND >= allowed minimum then
 14429                                  ;	    this entry becomes current minimum
 14430                                  ;
 14431                                  ;lru3:
 14432                                  ;	;test	word [es:di+5],8000h
 14433                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet 
 14434                                  ;					;	  if (!net[i]
 14435                                  ;	JNZ	short lru35
 14436                                  ;if installed
 14437                                  ;	call	CheckShare		;		&& !sharing)
 14438                                  ;	JZ	short lru5		;	  else
 14439                                  ;ENDIF
 14440                                  ;
 14441                                  ; This SFT is for the net or is for the sharer. See if it less than the
 14442                                  ; current minimum.
 14443                                  ;
 14444                                  ;lru35:
 14445                                  ;	;mov	dx,[es:di+17h]
 14446                                  ;	MOV	DX,[ES:DI+sf_OpenAge]
 14447                                  ;	CMP	DX,AX			;	  if (age[i] >= low &&
 14448                                  ;	JB	short lru5
 14449                                  ;	CMP	DX,BX
 14450                                  ;	JAE	short lru5		;	      age[i] < min) {
 14451                                  ;
 14452                                  ; entry is new minimum.  Remember his age.
 14453                                  ;
 14454                                  ;	mov	bx,DX			;	      min = age[i];
 14455                                  ;	mov	si,di			;	      pos = i;
 14456                                  ;
 14457                                  ; End of loop.	gp back for more
 14458                                  ;
 14459                                  ;lru5:
 14460                                  ;	;add	di,53
 14461                                  ;	add	di,SF_ENTRY.size
 14462                                  ;	loop	lru2			;	      }
 14463                                  ;
 14464                                  ; The scan is complete. If we have successfully found a new minimum (pos != -1)
 14465                                  ; set then threshold value to this new minimum + 1. Otherwise, the scan is
 14466                                  ; complete.  Go find LRU.
 14467                                  ;
 14468                                  ;lru6:	
 14469                                  ;	cmp	si,-1			; position not -1?
 14470                                  ;	jz	short lru75		; no, done with everything
 14471                                  ;	lea	ax,[bx+1]		; set new threshold age
 14472                                  ;	jmp	short lru1		; go and loop for more
 14473                                  ;lru65:	
 14474                                  ;	stc
 14475                                  ;	jmp	short LRUDead		;	  return -1;
 14476                                  ;
 14477                                  ; Main loop is done. We have AX being the age+1 of the nth oldest sharer or
 14478                                  ; network entry. We now make a second pass through to find the LRU entry
 14479                                  ; that is local-no-share or has age >= AX
 14480                                  ;
 14481                                  ;lru75:
 14482                                  ;	mov	bx,-1			; min = 0xffff;
 14483                                  ;	mov	si,bx			; pos = 0xffff;
 14484                                  ;	LES	DI,[CS:SFTFCB]		; for (CX=FCBCount; CX>0; CX--)
 14485                                  ;	;mov	cx,[es:di+4]
 14486                                  ;	MOV	CX,[ES:DI+SFT.SFCount]
 14487                                  ;	;lea	di,[di+6]
 14488                                  ;	LEA	DI,[DI+SFT.SFTable]
 14489                                  ;
 14490                                  ; If this is is local-no-share then go check for LRU else if age >= threshold
 14491                                  ; then check for lru.
 14492                                  ;
 14493                                  ;lru8:
 14494                                  ;	;test	word [es:di+5],8000h
 14495                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 14496                                  ;	jnz	short lru85		; is for network, go check age
 14497                                  ;	call	CheckShare		; sharer here?
 14498                                  ;	jz	short lru86		; no, go check lru
 14499                                  ;
 14500                                  ; Network or sharer.  Check age
 14501                                  ;
 14502                                  ;lru85:
 14503                                  ;	;cmp	[es:di+17h],ax
 14504                                  ;	cmp	[es:di+sf_OpenAge],ax
 14505                                  ;	jb	short lru9		; age is before threshold, skip it
 14506                                  ;
 14507                                  ; Check LRU
 14508                                  ;
 14509                                  ;lru86:
 14510                                  ;	;cmp	[es:di+15h],bx
 14511                                  ;	cmp	[es:di+sf_LRU],bx	; is LRU less than current LRU?
 14512                                  ;	jae	short lru9		; no, skip this
 14513                                  ;	mov	si,di			; remember position
 14514                                  ;	;mov	bx,[es:di+15h]
 14515                                  ;	mov	bx,[es:di+sf_LRU]	; remember new minimum LRU
 14516                                  ;
 14517                                  ; Done with this entry, go back for more.
 14518                                  ;
 14519                                  ;lru9:
 14520                                  ;	;add	di, 53
 14521                                  ;	add	di,SF_ENTRY.size
 14522                                  ;	loop	lru8
 14523                                  ;
 14524                                  ; Scan is complete. If we found NOTHING that satisfied us then we bomb
 14525                                  ; out. The conditions here are:
 14526                                  ;
 14527                                  ;  No local-no-shares AND all net/share entries are older than threshold
 14528                                  ;
 14529                                  ;lru10:
 14530                                  ;	cmp	si,-1			; if no one f
 14531                                  ;	jz	short lru65		;     return -1;
 14532                                  ;lru11:
 14533                                  ;	mov	di,si
 14534                                  ;	MOV	[CS:THISSFT],DI		; set thissft
 14535                                  ;	MOV	[CS:THISSFT+2],ES
 14536                                  ;
 14537                                  ; If we have sharing or thisSFT is a net sft, then close it until ref count
 14538                                  ; is 0.
 14539                                  ;
 14540                                  ;	;test	word [es:di+5],8000h
 14541                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 14542                                  ;	JNZ	short LRUClose
 14543                                  ;IF INSTALLED
 14544                                  ;	call	CheckShare
 14545                                  ;	JZ	short LRUDone
 14546                                  ;ENDIF
 14547                                  ;
 14548                                  ; Repeat close until ref count is 0
 14549                                  ;
 14550                                  ;LRUClose:
 14551                                  ;	push	ss
 14552                                  ;	pop	ds
 14553                                  ;	LES	DI,[THISSFT]
 14554                                  ;	cmp     word [es:di],0
 14555                                  ;	;CMP	word [ES:DI+SFT.sf_ref_count],0 ; is ref count still <> 0?
 14556                                  ;	JZ	short LRUDone 		; nope, all done
 14557                                  ;	call	DOS_CLOSE
 14558                                  ;	jnc	short LRUClose		; no error => clean up
 14559                                  ;	;cmp	al,6
 14560                                  ;	cmp	al,error_invalid_handle
 14561                                  ;	jz	short LRUClose
 14562                                  ;	stc
 14563                                  ;	JMP	short LRUDead
 14564                                  ;LRUDone:
 14565                                  ;	XOR	AL,AL
 14566                                  ;	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
 14567                                  ;
 14568                                  ;LRUDead:
 14569                                  ;	call	restore_world
 14570                                  ;	LES     DI,[CS:THISSFT]
 14571                                  ;	jnc	short LRUFCB_retn
 14572                                  ;LRUFCB_err:
 14573                                  ;	; mov	al, 23h	
 14574                                  ;	MOV	AL,error_FCB_unavailable
 14575                                  ;LRUFCB_retn:	
 14576                                  ;	retn:
 14577                                  ;
 14578                                  ;ENDIF	; LRUFCB has been rewritten below.
 14579                                  
 14580                                  ; 17/05/2019 - Retro DOS v4.0
 14581                                  ; LRUFCB for MSDOS 6.0 !
 14582                                  ;----------------------------------------------------------------------------
 14583                                  ;
 14584                                  ; LruFCB -- allocate the LRU SFT from the SFT Table. The LRU scheme
 14585                                  ; maintains separate counts for net/Share and local SFTs. We allocate a 
 14586                                  ; net/Share SFT only if we do not find a local SFT. This helps keep
 14587                                  ; net/Share SFTs which cannot be regenerated for as long as possible. We
 14588                                  ; optimize regeneration operations by keeping track of the current local
 14589                                  ; SFT. This avoids scanning of the SFTs as long as we have at least one 
 14590                                  ; local SFT in the SFT Block.
 14591                                  ;
 14592                                  ; Inputs: al = 0 => Regenerate SFT operation
 14593                                  ;	    = 1 => Allocate new SFT for Open/Create
 14594                                  ;
 14595                                  ; Outputs: Carry clear
 14596                                  ;	 	es:di = Address of allocated SFT
 14597                                  ;	  	ThisSFT = Address of allocated SFT
 14598                                  ;
 14599                                  ;	  carry set if closes of net/Share files failed 
 14600                                  ;		al = error_FCB_unavailable
 14601                                  ;
 14602                                  ; Registers affected: None
 14603                                  ;
 14604                                  ;----------------------------------------------------------------------------
 14605                                  
 14606                                  ;LruFCB	PROC	NEAR
 14607                                  LRUFCB:
 14608                                  	; 17/05/2019 - Retro DOS v4.0
 14609                                  	; DOSCODE:5805h (MSDOS 6.21, MSDOS.SYS)
 14610                                  
 14611                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14612                                  	; DOSCODE:57F1h (MSDOS 5.0, MSDOS.SYS)
 14613                                  
 14614                                  	; 20/01/2024 Retro DOS v5.0 (Modified PCDOS 7.1 IBMMDOS.COM)
 14615                                  	; DOSCODE:5E7Ch (PCDOS 7.1, IBMDOS.COM)
 14616                                  
 14617 00001F52 06                      	push	es	; * (MSDOS 6.21)
 14618                                  	
 14619 00001F53 E802E5                  	call	save_world
 14620                                  	
 14621                                  	;getdseg <ds>		;ds = DOSDATA
 14622 00001F56 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 14623                                  
 14624 00001F5B 08C0                    	or	al,al		;Check if regenerate allocation
 14625 00001F5D 7516                    	jnz	short lru1	;Try to find SFT to use
 14626                                  
 14627                                  	; This is a regen call. If LocalSFT contains the address of a valid 
 14628                                  	; local SFT, just return that SFT to reuse
 14629                                  
 14630                                  	; 20/01/2024
 14631                                  	;mov	di,[LocalSFT]
 14632                                  	;or	di,[LocalSFT+2]	;is address == 0?
 14633                                  	;jz	short lru1	;invalid local SFT, find one
 14634                                  
 14635                                  	; We have found a valid local SFT. Recycle this SFT
 14636                                  
 14637 00001F5F C43E[A710]              	les	di,[LocalSFT]
 14638                                  
 14639                                  	; 20/01/2024 (PCDOS 7.1 IBMDOS.COM)
 14640 00001F63 8CC1                    	mov	cx,es
 14641 00001F65 09F9                    	or	cx,di		; is address == 0?
 14642 00001F67 740C                    	jz	short lru1	; invalid local SFT, find one
 14643                                  
 14644                                  gotlocalSFT:
 14645 00001F69 893E[9E05]              	mov	[THISSFT],di
 14646 00001F6D 8C06[A005]              	mov	[THISSFT+2],es
 14647 00001F71 F8                      	clc
 14648 00001F72 E9A900                  	jmp	LRUDone		;clear up SFT and return
 14649                                  
 14650                                  lru1:
 14651 00001F75 C43E[4000]              	les	di,[SFTFCB]	;es:di = SF Table for FCBs
 14652                                  	;mov	cx,[es:di+4]
 14653 00001F79 268B4D04                	mov	cx,[es:di+SFT.SFCount]	;cx = number of SFTs
 14654                                  	;lea	di,[di+6]
 14655 00001F7D 8D7D06                  	lea	di,[di+SFT.SFTable]	;es:di = first SFT
 14656                                  
 14657                                  	; We scan through all the SFTs scanning for a free one. It also 
 14658                                  	; remembers the LRU SFT for net/Share SFTs and local SFTs separately. 
 14659                                  	; bx = min. LRU for local SFTs
 14660                                  	; si = pos. of local SFT with min. LRU
 14661                                  	; dx = min. LRU for net/Share SFTs
 14662                                  	; bp = pos. of net/Share SFT with min. LRU
 14663                                  
 14664 00001F80 BBFFFF                  	mov	bx,-1		; init. to 0xffff ( max. LRU value )
 14665 00001F83 89DE                    	mov	si,bx
 14666 00001F85 89DA                    	mov	dx,bx
 14667 00001F87 89DD                    	mov	bp,bx
 14668                                  
 14669                                  findSFT:
 14670                                  	;See if this SFT is a free one. If so, return it
 14671 00001F89 26830D00                	or	word [es:di],0
 14672                                  	;or	word [es:di+SF_ENTRY.sf_ref_count],0 ;reference count = 0 ?
 14673 00001F8D 744C                    	jz	short gotSFT	;yes, SFT is free
 14674                                  	;;cmp	word [es:di],-1
 14675                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy ;Is it busy?
 14676 00001F8F 26833DFF                	cmp	word [es:di],sf_busy ; -1 
 14677 00001F93 7446                    	jz	short gotSFT	;no, can use it
 14678                                  
 14679                                  	; Check if this SFT is local and store its address in LocalSFT. Can be 
 14680                                  	; used for a later regen.
 14681                                  
 14682                                  	; 16/12/2022
 14683                                  	; 08/11/2022
 14684                                  	;test	byte [es:di+6],80h
 14685 00001F95 26F6450680              	test	byte [es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8) ; 80h
 14686                                  	; 08/11/2022 Retro DOS v4.0 (MSDOS 5.0 MSDOS.SYS compatibility)
 14687                                  	;;test	word [es:di+5],8000h
 14688                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet ; network SFT?
 14689 00001F9A 7531                    	jnz	short lru5	;yes, get net/Share LRU
 14690                                  
 14691                                  ;IF installed
 14692 00001F9C E8875D                  	call	CheckShare	;Share present?
 14693                                  ;ENDIF
 14694 00001F9F 752C                    	jnz	short lru5	;yes, get net/Share LRU
 14695                                  
 14696                                  	;Local SFT, register its address
 14697                                  
 14698                                  	; !!HACK!!!
 14699                                  	; There is a slightly dirty hack out here in a desperate bid to save  
 14700                                  	; code space. There is similar code duplicated at label 'gotSFT'. We 
 14701                                  	; enter from there if al = 0, update the LocalSFT variable, and since 
 14702                                  	; al = 0, we jump out of the loop to the exit point. I have commented 
 14703                                  	; out the code that previously existed at label 'gotSFT'
 14704                                  
 14705                                  hackpoint:
 14706 00001FA1 893E[A710]              	mov	[LocalSFT],di
 14707 00001FA5 8C06[A910]              	mov	[LocalSFT+2],es	;store local SFT address
 14708                                  
 14709 00001FA9 08C0                    	or	al,al		;Is operation = REGEN?
 14710 00001FAB 74BC                    	jz	short gotlocalSFT ;yes, return this SFT for reuse
 14711                                  
 14712                                  	;Get LRU for local files
 14713                                  	
 14714                                  	;cmp	[es:di+15h],bx
 14715 00001FAD 26395D15                	cmp	[es:di+sf_LRU],bx ;SFT.LRU < min?
 14716 00001FB1 7306                    	jae	short lru4	;no, skip 
 14717                                  
 14718                                  	;mov	bx,[es:di+15h]
 14719 00001FB3 268B5D15                	mov	bx,[es:di+sf_LRU] ;yes, store new minimum
 14720 00001FB7 89FE                    	mov	si,di		;store SFT position
 14721                                  lru4:
 14722                                  	;add	di,59
 14723 00001FB9 83C73B                  	add	di,SF_ENTRY.size ;go to next SFT
 14724 00001FBC E2CB                    	loop	findSFT
 14725                                  	
 14726                                  	; 20/01/2024
 14727 00001FBE 49                      	dec	cx ; -1
 14728                                  
 14729                                  	; Check whether we got a net/Share or local SFT. If local SFT
 14730                                  	; available, we will reuse it instead of net/Share LRU
 14731                                  
 14732 00001FBF 89F7                    	mov	di,si
 14733                                  	;cmp	si,-1		;local SFT available?
 14734 00001FC1 39CE                    	cmp	si,cx ; 20/01/2024
 14735 00001FC3 7516                    	jnz	short gotSFT	;yes, return it
 14736                                  
 14737                                  	;No local SFT, see if we got a net/Share SFT
 14738                                  
 14739 00001FC5 89EF                    	mov	di,bp
 14740                                  
 14741 00001FC7 39CD                    	cmp	bp,cx ; -1 ; 20/01/2024
 14742                                  	;cmp	bp,-1		;net/Share SFT available?
 14743 00001FC9 752D                    	jnz	short gotnetSFT	;yes, return it
 14744                                  noSFT:
 14745                                  	; NB: This error should never occur. We always must have an LRU SFT.
 14746                                  	; This error can occur only if the SFT has been corrupted or the LRU
 14747                                  	; count is not maintained properly.
 14748                                  
 14749 00001FCB EB4E                    	jmp	short errorbadSFT ;error, no FCB available.
 14750                                  
 14751                                  	; Handle the LRU for net/Share SFTs
 14752                                  lru5:
 14753                                  	;cmp	[es:di+15h],dx
 14754 00001FCD 26395515                	cmp	[es:di+sf_LRU],dx ;SFT.LRU < min?
 14755 00001FD1 73E6                    	jae	short lru4	;no, skip
 14756                                  
 14757                                  	;mov	dx,[es:di+15h]
 14758 00001FD3 268B5515                	mov	dx,[es:di+sf_LRU] ;yes, store new minimum
 14759                                  
 14760 00001FD7 89FD                    	mov	bp,di		;store SFT position
 14761 00001FD9 EBDE                    	jmp	short lru4	;continue with next SFT
 14762                                  
 14763                                  gotSFT:
 14764 00001FDB 08C0                    	or	al,al
 14765 00001FDD 74C2                    	jz	short hackpoint	;save es:di in LocalSFT
 14766                                  
 14767                                  	; HACK!!!
 14768                                  	; The code here differs from the code at 'hackpoint' only in the 
 14769                                  	; order of the check for al. If al = 0, we can jump to 'hackpoint'
 14770                                  	; and then from there jump out to 'gotlocalSFT'. The original code
 14771                                  	; has been commented out below and replaced by the code just above.
 14772                                  
 14773                                  ;If regen, then this SFT can be registered as a local one ( even if free ).
 14774                                  ;
 14775                                  ;	or	al,al		  ;Regen?
 14776                                  ;	jnz	short notlocaluse ;yes, register it and return
 14777                                  ;
 14778                                  ;Register this SFT as a local one
 14779                                  ;
 14780                                  ;	mov	[LocalSFT],di
 14781                                  ;	mov	[LocalSFT+2],es
 14782                                  ;	jmp	gotlocalSFT	;return to caller
 14783                                  ;
 14784                                  ;notlocaluse:
 14785                                  
 14786                                  	; The caller is probably going to use this SFT for a net/Share file.
 14787                                  	; We will come here only on a Open/Create when the caller($FCB_OPEN)
 14788                                  	; does not really know whether it is a local file or not. We
 14789                                  	; invalidate LocalSFT if the SFT we are going to use was previously
 14790                                  	; registered as a local SFT that can be recycled.
 14791                                  
 14792 00001FDF 8CC0                    	mov	ax,es
 14793 00001FE1 393E[A710]              	cmp	[LocalSFT],di		;Offset same?
 14794 00001FE5 750E                    	jne	short notinvalid
 14795 00001FE7 3906[A910]              	cmp	[LocalSFT+2],ax		;Segments same?
 14796                                  	;je	short zerolocalSFT	;no, no need to invalidate
 14797                                  	; 20/01/2024 (PCDOS 7.1 IBMDOS.COM)
 14798 00001FEB 7508                    	jne	short notinvalid
 14799                                  zerolocalSFT:	
 14800 00001FED 31C0                    	xor	ax,ax ; 0
 14801 00001FEF A3[A710]                	mov	[LocalSFT],ax
 14802 00001FF2 A3[A910]                	mov	[LocalSFT+2],ax
 14803                                  	
 14804                                  notinvalid:
 14805 00001FF5 E971FF                  	jmp	gotlocalSFT
 14806                                  
 14807                                  	; The SFT we are going to use was registered in the LocalSFT variable.
 14808                                  	; Invalidate this variable i.e LocalSFT = NULL
 14809                                  
 14810                                  ;zerolocalSFT:
 14811                                  	;xor	ax,ax ; 0
 14812                                  	;mov	[LocalSFT],ax
 14813                                  	;mov	[LocalSFT+2],ax
 14814                                  	;
 14815                                  	;jmp	gotlocalSFT
 14816                                  
 14817                                  gotnetSFT:
 14818                                  	; We have an SFT that is currently net/Share. If it is going to be
 14819                                  	; used for a regen, we know it has to be a local SFT. Update the
 14820                                  	; LocalSFT variable
 14821                                  
 14822 00001FF8 08C0                    	or	al,al
 14823 00001FFA 7508                    	jnz	short closenet
 14824                                  
 14825 00001FFC 893E[A710]              	mov	[LocalSFT],di
 14826 00002000 8C06[A910]              	mov	[LocalSFT+2],es	;store local SFT address
 14827                                  closenet:
 14828 00002004 893E[9E05]              	mov	[THISSFT],di	; set thissft
 14829 00002008 8C06[A005]              	mov	[THISSFT+2],es	
 14830                                  
 14831                                  	; If we have sharing or thisSFT is a net sft, then close it until ref
 14832                                  	; count is 0.
 14833                                  	; NB: We come here only if it is a net/Share SFT that is going to be
 14834                                  	; recycled -- no need to check for this.
 14835                                  
 14836                                  LRUClose:
 14837 0000200C 26833D00                	cmp	word [es:di],0
 14838                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0 ; is ref count still <> 0?
 14839 00002010 740C                    	jz	short LRUDone	; nope, all done
 14840                                  
 14841 00002012 E83017                  	call	DOS_CLOSE
 14842 00002015 73F5                    	jnc	short LRUClose	; no error => clean up
 14843                                  
 14844                                  	; Bugbug: I dont know why we are trying to close after we get an
 14845                                  	; error closing. Seems like we could have a potential infinite loop
 14846                                  	; here. This has to be verified.
 14847                                  
 14848 00002017 3C06                    	cmp	al,error_invalid_handle ; 6
 14849 00002019 74F1                    	je	short LRUClose
 14850                                  errorbadSFT:
 14851 0000201B F9                      	stc
 14852 0000201C EB05                    	JMP	short LRUDead
 14853                                  LRUDone:
 14854 0000201E 30C0                    	XOR	AL,AL
 14855 00002020 E81F01                  	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
 14856                                  
 14857                                  LRUDead:
 14858 00002023 E81BE4                  	call	restore_world		; use macro
 14859                                  	
 14860 00002026 07                      	pop	es ; * (MSDOS 6.21)
 14861                                  
 14862                                  	;getdseg <es>
 14863 00002027 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 14864 0000202C 26C43E[9E05]            	les	di,[es:THISSFT]		;es:di points at allocated SFT
 14865                                  
 14866                                  	;;retnc
 14867                                  	;jc	short LruFCB_err
 14868                                  	;retn
 14869                                  
 14870                                  	; 16/12/2022
 14871                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14872 00002031 7302                    	jnc	short LruFCB_retn
 14873                                  	;jc	short LruFCB_err
 14874                                  	;retn
 14875                                  		
 14876                                  LruFCB_err:
 14877 00002033 B023                    	MOV	AL,error_FCB_unavailable ; 23h
 14878                                  LruFCB_retn:
 14879 00002035 C3                      	retn
 14880                                  	
 14881                                  ;LruFCB	ENDP
 14882                                  
 14883                                  ; 17/05/2019 - Retro DOS v4.0
 14884                                  
 14885                                  ; DOSCODE:58F3h (MSDOS 6.21, MSDOS.SYS)
 14886                                  
 14887                                  ; --------------------------------------------------------------------------
 14888                                  ;**** RegenCopyName -- This function copies the filename from the FCB to
 14889                                  ; SFT and also to DOS local buffers. There was duplicate code in FCBRegen
 14890                                  ; to copy the name to different destinations
 14891                                  ;
 14892                                  ; Inputs: ds:si = source string
 14893                                  ;	 es:di = destination string
 14894                                  ;	 cx = length of string
 14895                                  ;
 14896                                  ; Outputs: String copied to destination
 14897                                  ;
 14898                                  ; Registers affected: cx,di,si
 14899                                  ; --------------------------------------------------------------------------
 14900                                  
 14901                                  RegenCopyName:
 14902                                  CopyName:
 14903 00002036 AC                      	lodsb			;load character
 14904 00002037 E8C039                  	call	UCase		; convert char to upper case
 14905                                  StuffChar2:
 14906 0000203A AA                      	STOSB			;store converted character
 14907 0000203B E2F9                    	LOOP	CopyName	;
 14908                                  DoneName:
 14909 0000203D C3                      	retn
 14910                                  
 14911                                  ; --------------------------------------------------------------------------
 14912                                  
 14913                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14914                                  	; 21/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 14915                                  
 14916                                  FCBRegen:
 14917                                  	; called from SFTFromFCB. SS already DOSDATA
 14918                                  
 14919                                  	; General data filling. Mode is sf_isFCB + open_for_both, date/time 
 14920                                  	; we do not fill, size we do no fill, position we do not fill,
 14921                                  	; bit 14 of flags = TRUE, other bits = FALSE
 14922                                  
 14923                                  	;mov	al,[si+19h]
 14924 0000203E 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 14925                                  
 14926                                  	; We discriminate based on the first two bits in the reserved field.
 14927                                  	
 14928                                  	;test	al,80h
 14929 00002041 A880                    	test	AL,FCBSPECIAL		; check for no sharing test
 14930 00002043 741C                    	JZ	short RegenNoSharing	; yes, go regen from no sharing
 14931                                  
 14932                                  	; The FCB is for a network or a sharing based system. At this point 
 14933                                  	; we have already closed the SFT for this guy and reconnection is 
 14934                                  	; impossible.
 14935                                  	;
 14936                                  	; Remember that he may have given us a FCB with bogus information in
 14937                                  	; it. Check to see if sharing is present or if the redir is present.
 14938                                  	; If either is around, presume that we have cycled out the FCB and 
 14939                                  	; give the hard error. Otherwise, just return with carry set.
 14940                                  
 14941 00002045 E8DE5C                  	call	CheckShare		; test for sharer
 14942 00002048 7509                    	JNZ	short RegenFail		; yep, fail this.
 14943                                  	
 14944                                  	;mov	ax,1100h
 14945 0000204A B80011                  	MOV	AX,MultNET<<8		; install check on multnet
 14946 0000204D CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - INSTALLATION CHECK
 14947                                  			; Return: AL = 00h  not installed, OK to install
 14948                                  			; 01h  not installed, not OK to install
 14949                                  			; FFh  installed
 14950 0000204F 08C0                    	OR	AL,AL			; is it there?
 14951 00002051 740C                    	JZ	short RegenDead		; no, just fail the operation
 14952                                  RegenFail:
 14953                                  	; 17/05/2019 - Retro DOS v4.0
 14954                                  	;MOV	AX,[CS:USER_IN_AX]	; SS override
 14955 00002053 36A1[3A03]              	mov	ax,[SS:USER_IN_AX] ; MSDOS 6.0
 14956                                  
 14957                                  	;cmp	ah,10h
 14958 00002057 80FC10                  	cmp	AH,FCB_CLOSE
 14959 0000205A 7403                    	jz	short RegenDead
 14960 0000205C E89F01                  	call	FCBHardErr		; massive hard error.
 14961                                  RegenDead:
 14962 0000205F F9                      	STC				; carry set
 14963                                  FCBRegen_retn:
 14964 00002060 C3                      	retn
 14965                                  
 14966                                  	; Local FCB without sharing. Check to see if sharing is loaded. If 
 14967                                  	; so fail the operation.
 14968                                  
 14969                                  RegenNoSharing:
 14970 00002061 E8C25C                  	call	CheckShare		; Sharing around?
 14971 00002064 75ED                    	JNZ	short RegenFail
 14972                                  	
 14973                                  	; Find an SFT for this guy.
 14974                                  	
 14975                                  	; 17/05/2019 - Retro DOS v4.0
 14976                                  
 14977                                  	; MSDOS 3.3
 14978                                  	;call	LRUFCB
 14979                                  	;jc	short FCBRegen_retn
 14980                                  	
 14981                                  	; MSDOS 6.0
 14982 00002066 50                      	push	ax
 14983 00002067 B000                    	mov	al,0			;indicate it is a regen operation
 14984 00002069 E8E6FE                  	call	LRUFCB
 14985 0000206C 58                      	pop	ax
 14986 0000206D 72F1                    	jc	short FCBRegen_retn
 14987                                  
 14988                                  	;mov	word [es:di+2],8002h
 14989 0000206F 26C745020280            	MOV	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB+open_for_both+SHARING_COMPAT
 14990 00002075 243F                    	AND	AL,3Fh			; get drive number for flags
 14991 00002077 98                      	CBW
 14992                                  	;or	ax,4000h
 14993 00002078 0D0040                  	OR	AX,sf_close_nodate	; normal FCB operation
 14994                                  
 14995                                  	; The bits field consists of the upper two bits (dirty and device) 
 14996                                  	; from the SFT and the low 4 bits from the open mode.
 14997                                  
 14998                                  	;mov	cl,[si+1Ah]
 14999 0000207B 8A4C1A                  	MOV	CL,[SI+fcb_nsl_bits]	; stick in dirty bits.
 15000 0000207E 88CD                    	MOV	CH,CL
 15001 00002080 80E5C0                  	AND	CH,0C0h 		; mask off the dirty/device bits
 15002 00002083 08E8                    	OR	AL,CH
 15003                                  	;and	cl,0Fh
 15004 00002085 80E10F                  	AND	CL,access_mask		; get the mode bits
 15005                                  	;mov	[es:di+2],cl
 15006 00002088 26884D02                	MOV	[ES:DI+SF_ENTRY.sf_mode],CL
 15007                                  	;mov	[es:di+5],ax
 15008 0000208C 26894505                	MOV	[ES:DI+SF_ENTRY.sf_flags],AX ; initial flags
 15009                                  	;MOV	AX,[CS:PROC_ID]		; SS override
 15010 00002090 36A1[3C03]              	mov	ax,[ss:PROC_ID] ; MSDOS 6.0
 15011                                  	;mov	[es:di+31h],ax
 15012 00002094 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX
 15013 00002098 1E                      	push	ds
 15014 00002099 56                      	push	si
 15015 0000209A 06                      	push	es
 15016 0000209B 57                      	push	di
 15017 0000209C 16                      	push	ss
 15018 0000209D 07                      	pop	es
 15019 0000209E BF[4B05]                	MOV	DI,NAME1		; NAME1 is in DOSDATA
 15020                                  
 15021 000020A1 B90800                  	MOV	CX,8
 15022 000020A4 46                      	INC	SI			; Skip past drive byte to name in FCB
 15023                                  
 15024                                  	; MSDOS 3.3
 15025                                  ;RegenCopyName:
 15026                                  	;lodsb
 15027                                  	;call	UCase
 15028                                  	;stosb
 15029                                  	;loop	RegenCopyName
 15030                                  
 15031                                  	; MSDOS 6.0
 15032 000020A5 E88EFF                  	call	RegenCopyName		;copy the name to NAME1
 15033                                  
 15034 000020A8 16                      	push	ss	; SS is DOSDATA
 15035 000020A9 1F                      	pop	ds
 15036                                  
 15037                                  	;mov	byte [ATTRIB],16h
 15038 000020AA C606[6B05]16            	MOV	byte [ATTRIB],attr_hidden+attr_system+attr_directory
 15039                                  					; Must set this to something interesting
 15040                                  					; to call DEVNAME.
 15041 000020AF E8D62A                  	call	DEVNAME 		; check for device
 15042 000020B2 5E                      	pop	si
 15043 000020B3 07                      	pop	es
 15044 000020B4 5E                      	pop	si
 15045 000020B5 1F                      	pop	ds
 15046 000020B6 7219                    	JC	short RegenFileNoSharing ; not found on device list => file
 15047                                  
 15048                                  	; Device found. We can ignore disk-specific info
 15049                                  
 15050                                  	;mov	[es:di+5],bh
 15051 000020B8 26887D05                	MOV	[ES:DI+SF_ENTRY.sf_flags],BH ; device parms
 15052                                  	;mov	byte [es:di+4],0
 15053 000020BC 26C6450400              	MOV	byte [ES:DI+SF_ENTRY.sf_attr],0 ; attribute
 15054                                  					; SS override
 15055                                  	;LDS	SI,[CS:DEVPT]		; get device driver
 15056 000020C1 36C536[9A05]            	lds	si,[ss:DEVPT] ; MSDOS 6.0
 15057                                  	;mov	[es:di+7],si
 15058 000020C6 26897507                	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 15059                                  	;mov	[es:di+9],ds
 15060 000020CA 268C5D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 15061 000020CE C3                      	retn				; carry is clear
 15062                                  
 15063                                  RegenDeadJ:
 15064 000020CF EB8E                    	JMP	short RegenDead
 15065                                  
 15066                                  	; File found. Just copy in the remaining pieces.
 15067                                  
 15068                                  RegenFileNoSharing:
 15069                                  	;mov	ax,[es:di+5]
 15070 000020D1 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 15071 000020D5 83E03F                  	AND	AX,03Fh
 15072 000020D8 1E                      	push	ds
 15073 000020D9 56                      	push	si
 15074 000020DA E8D652                  	call	FIND_DPB
 15075                                  	;mov	[es:di+7],si
 15076 000020DD 26897507                	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 15077                                  	;mov	[es:di+9],ds
 15078 000020E1 268C5D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 15079 000020E5 5E                      	pop	si
 15080 000020E6 1F                      	pop	ds
 15081 000020E7 72E6                    	jc	short RegenDeadJ	; if find DPB fails, then drive
 15082                                  					; indicator was bogus
 15083                                  	;mov	ax,[si+1Dh]
 15084 000020E9 8B441D                  	MOV	AX,[SI+fcb_nsl_dirsec]
 15085                                  	;;mov	[es:di+1Dh],ax ; MSDOS 3.3
 15086                                  	;mov	[es:di+1Bh],ax ; MSDOS 6.0
 15087 000020EC 2689451B                	MOV	[ES:DI+SF_ENTRY.sf_dirsec],AX
 15088                                  
 15089                                  	; MSDOS 6.0
 15090                                  
 15091                                  	; SR;
 15092                                  	; Extract the read-only and archive bits from the top 2 bits of the sector
 15093                                  	; number
 15094                                  
 15095                                  	;mov	al,[si+18h]
 15096 000020F0 8A4418                  	mov	al,[si+fcb_sfn]
 15097 000020F3 24C0                    	and	al,0C0h		;get the 2 attribute bits
 15098 000020F5 88C4                    	mov	ah,al
 15099 000020F7 D0C4                    	rol	ah,1
 15100 000020F9 D0E8                    	shr	al,1
 15101 000020FB 08E0                    	or	al,ah
 15102 000020FD 243F                    	and	al,03Fh		;mask off unused bits
 15103                                  	;mov	[es:di+4],al
 15104 000020FF 26884504                	mov	[es:di+SF_ENTRY.sf_attr],al
 15105                                  
 15106                                  	; SR;
 15107                                  	; Update the higher word of the directory sector from the FCB
 15108                                  
 15109                                  	;;mov	al,[si+18h]
 15110 00002103 8A4418                  	mov	al,[si+fcb_sfn]
 15111 00002106 243F                    	and	al,03Fh		;mask off top 2 bits -- attr bits
 15112 00002108 28E4                    	sub	ah,ah
 15113                                  	;mov	[es:di+1Dh],ax
 15114 0000210A 2689451D                	mov	[es:di+SF_ENTRY.sf_dirsec+2],ax ;update high word
 15115                                  
 15116                                  	; 21/01/2024
 15117                                  	; MSDOS 6.0 (& MSDOS 3.3)
 15118                                  	;mov	ax,[si+1Bh]
 15119 0000210E 8B441B                  	MOV	AX,[SI+fcb_nsl_firclus]
 15120                                  	;;mov	[es:di+0Bh],ax
 15121                                  	;MOV	[ES:DI+SF_ENTRY.sf_firclus],AX
 15122                                  	;;;
 15123                                  	; 21/01/2024 (PCDOS 7.1 IBMDOS.COM)
 15124 00002111 2689452B                	mov	[es:di+2Bh],ax	; .sf_chain !!! (MSDOS 6.22)
 15125                                  	;mov	[es:di+SF_ENTRY.sf_chain],ax ; first cluster (32 bit) !?
 15126                                  	;;;	
 15127                                  
 15128                                  	;;mov	[es:di+1Bh],ax ; MSDOS 3.3
 15129                                  	;mov	[es:di+35h],ax ; MSDOS 6.0
 15130 00002115 26894535                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 15131                                  
 15132                                  	;;;
 15133                                  	; 21/01/2024 (PCDOS 7.1 IBMDOS.COM)
 15134 00002119 31C0                    	xor     ax, ax	; 0
 15135 0000211B 2689452D                	mov     es:[di+2Dh], ax ; 0
 15136 0000211F 2689452D                	mov	[es:di+SF_ENTRY.sf_chain+2],ax
 15137                                  				; .sf_chain ! (MSDOS 6.22)
 15138                                  				; high word of first cluster (32 bit) !?
 15139 00002123 26894537                	mov	[es:di+37h],ax ; 0
 15140                                  	;mov	[es:di+SF_ENTRY.sf_lstclus+2],ax ; hw of last cluster
 15141                                  	;;;
 15142                                  
 15143                                  	;mov	al,[si+1Fh]
 15144 00002127 8A441F                  	MOV	AL,[SI+fcb_nsl_dirpos]
 15145                                  	;mov  	[es:di+1Fh],al
 15146 0000212A 2688451F                	MOV	[ES:DI+SF_ENTRY.sf_dirpos],AL
 15147                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 15148 0000212E 26FF05                  	inc	word [ES:DI]		; Increment reference count.
 15149                                  					; Existing FCB entries would be
 15150                                  					; flushed unnecessarily because of
 15151                                  					; check in CheckFCB of the ref_count.
 15152                                  					; July 22/85 - BAS
 15153                                  	;;;
 15154                                  	; 21/01/2024 (PCDOS 7.1 IBMDOS.COM)
 15155 00002131 E84B27                  	call	set_sftfcb_entry ; put SFT entry number in the SFTFCB table
 15156                                  				 ; as FCB index number
 15157                                  	;;;
 15158                                  
 15159                                  	;lea	si,[si+1]
 15160 00002134 8D7401                  	LEA	SI,[SI+SYS_FCB.name]
 15161                                  	;lea	di,[di+20h]
 15162 00002137 8D7D20                  	LEA	DI,[DI+SF_ENTRY.sf_name]
 15163                                  	;mov	cx,11
 15164 0000213A B90B00                  	MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 15165                                  	
 15166                                  	; MSDOS 6.0
 15167 0000213D E8F6FE                  	call	RegenCopyName	;copy name to SFT 
 15168                                  	
 15169                                  	; MSDOS 3.3
 15170                                  ;RegenCopyName2:
 15171                                  	;lodsb
 15172                                  	;call    UCase
 15173                                  	;stosb
 15174                                  	;loop    RegenCopyName2
 15175                                  
 15176 00002140 F8                      	clc
 15177 00002141 C3                      	retn
 15178                                  
 15179                                  ; 17/05/2019 - Retro DOS v4.0
 15180                                  ; 21/01/2024 - Retro DOS v5.0
 15181                                  
 15182                                  ;**	BlastSFT - FIll SFT with Garbage
 15183                                  ; --------------------------------------------------------------------------
 15184                                  ;	BlastSFT is used when an SFT is no longer needed; it's called with
 15185                                  ;	various garbage values to put into the SFT.  I don't know why,
 15186                                  ;	presumably to help with debugging (jgl).  We clear the few fields
 15187                                  ;	necessary to show that the SFT is free after filling it.
 15188                                  ;
 15189                                  ;	ENTRY	(es:di) = address of SFT
 15190                                  ;		(al) = fill character
 15191                                  ;	EXIT	(ax) = -1
 15192                                  ;		'C' clear
 15193                                  ;	USES	AX, CX, Flags
 15194                                  
 15195                                  BlastSFT:
 15196                                  	; 21/01/2024 (PCDOS 7.1 IBMDOS.COM)
 15197                                  	;;;
 15198 00002142 E88E27                  	call	SFT_FREE
 15199                                  	;;;
 15200 00002145 57                      	push	di
 15201                                  	;mov	cx,53 ; MSDOS 3.3
 15202                                  	;mov	cx,59 ; MSDOS 6.0
 15203 00002146 B93B00                  	mov	cx,SF_ENTRY.size
 15204 00002149 F3AA                    	rep	stosb
 15205 0000214B 5F                      	pop	di
 15206 0000214C 29C0                    	sub	ax,ax	; 0		; clear 'C'-----------------;
 15207 0000214E 268905                  	mov	[es:di],ax
 15208                                  	;mov	[es:di+SF_ENTRY.sf_ref_count],ax ; set ref count    ;
 15209                                  	;mov	[es:di+15h],ax
 15210 00002151 26894515                	mov	[es:di+sf_LRU],ax	; set lru		    ;
 15211 00002155 48                      	dec	ax	; -1					    ;
 15212                                  	;mov	[es:di+17h],ax ; 0FFFFh ; -1
 15213 00002156 26894517                	mov	[es:di+sf_OpenAge],ax	; set open age to -1	    ;
 15214                                  BlastSFT_retn:
 15215 0000215A C3                      	retn				; return with 'C' clear     ;
 15216                                  
 15217                                  ;Break	<CheckFCB - see if the SFT pointed to by the FCB is still OK>
 15218                                  ; --------------------------------------------------------------------------
 15219                                  ;
 15220                                  ;   CheckFCB - examine an FCB and its contents to see if it needs to be
 15221                                  ;   regenerated.
 15222                                  ;
 15223                                  ;   Inputs:	DS:SI point to FCB (not extended)
 15224                                  ;		AL is SFT index
 15225                                  ;   Outputs:	Carry Set - FCB needs to be regened
 15226                                  ;		Carry clear - FCB is OK. ES:DI point to SFT
 15227                                  ;   Registers modified: AX and BX
 15228                                  ;
 15229                                  ; --------------------------------------------------------------------------
 15230                                  
 15231                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15232                                  	; DOSCODE:59F0h (MSDOS 5.0, MSDOS.SYS)
 15233                                  
 15234                                  	; 21/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 15235                                  	; DOSCODE:607Eh (PCDOS 7.1 IBMDOS.COM)
 15236                                  CheckFCB:
 15237                                  		
 15238                                  	; called from $fcb_open and sftfromfcb. SS already set up to DOSDATA
 15239                                  
 15240                                  	; MSDOS 3.3
 15241                                  
 15242                                  	; LES	DI,[CS:SFTFCB]
 15243                                  
 15244                                  	; MSDOS 6.0
 15245                                  	
 15246                                  	; SR;
 15247                                  	; We check if the given FCB is for a local file. If so, we return a 
 15248                                  	; bad SFT status forcing the caller to regenerate the SFT.
 15249                                  
 15250                                  	;test	byte [si+19h],0C0h
 15251 0000215B F64419C0                	test	byte [si+fcb_l_drive],FCBNETWORK|FCBSHARE|FCBDEVICE
 15252 0000215F 7447                    	jz	short BadSFT		;Local file, return bad SFT
 15253 00002161 36C43E[4000]            	LES     DI,[SS:SFTFCB]		; SS override
 15254                                  
 15255                                  	; MSDOS 6.0 (& MSDOS 3.3)
 15256                                  	;cmp	[es:di+4],al
 15257 00002166 26384504                	CMP	[ES:DI+SFT.SFCount],AL
 15258 0000216A 723C                    	JC	short BadSFT
 15259                                  	;;mov	bl,53 ; MSDOS 3.3
 15260                                  	;mov	bl,59 ; MSDOS 6.0
 15261 0000216C B33B                    	MOV	BL,SF_ENTRY.size
 15262 0000216E F6E3                    	MUL	BL
 15263                                  	;lea	di,[di+6]
 15264 00002170 8D7D06                  	LEA	DI,[DI+SFT.SFTable]
 15265 00002173 01C7                    	ADD	DI,AX
 15266                                  	;MOV	AX,[CS:PROC_ID]	; MSDOS 3.3
 15267 00002175 36A1[3C03]              	mov	ax,[SS:PROC_ID] ; MSDOS 6.0  ; SS override
 15268                                  	;cmp	[es:di+31h],ax
 15269 00002179 26394531                	CMP	[ES:DI+SF_ENTRY.sf_PID],AX
 15270 0000217D 7529                    	JNZ	short BadSFT		; must match process
 15271 0000217F 26833D00                	cmp	word [es:di],0
 15272                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],0
 15273 00002183 7423                    	JZ	short BadSFT		; must also be in use
 15274                                  	;mov	al,[si+19h]
 15275 00002185 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 15276                                  	;test	al,80h
 15277 00002188 A880                    	test	AL,FCBSPECIAL		; a special FCB?
 15278 0000218A 7428                    	JZ	short CheckNoShare	; No. try local or device
 15279                                  
 15280                                  	; Since we are a special FCB, try NOT to use a bogus test instruction.
 15281                                  	; FCBSHARE is a superset of FCBNETWORK.
 15282                                  
 15283 0000218C 50                      	PUSH	AX
 15284                                  	;and	al,0C0h
 15285 0000218D 24C0                    	AND	AL,FCBMASK
 15286                                  	;cmp	al,0C0h
 15287 0000218F 3CC0                    	CMP	AL,FCBSHARE		; net FCB?
 15288 00002191 58                      	POP	AX
 15289 00002192 7516                    	JNZ	short CheckNet		; no
 15290                                  					; yes
 15291                                  ;
 15292                                  ;----- In share support -----
 15293                                  ;
 15294                                  	;call	far [cs:JShare+(11*4)]
 15295 00002194 36FF1E[BC00]            	Call    far [ss:JShare+(11*4)] ; 11 = ShChk ; SS Override
 15296 00002199 720D                    	JC	short BadSFT
 15297                                  
 15298                                  ; 21/01/2024
 15299                                  %if 0
 15300                                  	JMP	SHORT CheckD
 15301                                  ;
 15302                                  ;----- End in share support -----
 15303                                  ;
 15304                                  	; 09/11/2022
 15305                                  	; (There is not any procedure/sub
 15306                                  	;  which calls or jumps to CheckFirClus here)
 15307                                  	;;;
 15308                                  CheckFirClus:
 15309                                  	;cmp     bx,[es:di+0Bh]
 15310                                  	; 07/12/2022
 15311                                  	CMP	BX,[ES:DI+SF_ENTRY.sf_firclus]
 15312                                  	JNZ	short BadSFT
 15313                                  	;;;
 15314                                  %endif
 15315                                  
 15316                                  CheckD: 
 15317 0000219B 243F                    	AND	AL,3Fh
 15318                                  	;mov	ah,[es:di+5]
 15319 0000219D 268A6505                	MOV	AH,[ES:DI+SF_ENTRY.sf_flags]
 15320 000021A1 80E43F                  	AND	AH,3Fh
 15321 000021A4 38C4                    	CMP	AH,AL
 15322                                  	; 16/12/2022
 15323 000021A6 74B2                    	jz	short BlastSFT_retn	; carry is clear
 15324                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15325                                  	;jnz	short BadSFT
 15326                                  ;CheckD_retn:
 15327                                  	;retn
 15328                                  BadSFT: 
 15329 000021A8 F9                      	STC
 15330 000021A9 C3                      	retn
 15331                                  				
 15332                                  CheckNet:
 15333                                  	; 17/05/2019 - Retro DOS v4.0
 15334                                  	
 15335                                  ;----- In net support -----
 15336                                  
 15337                                  	; MSDOS 3.3
 15338                                  	;;mov	ax,[si+1Ah]
 15339                                  	;mov	ax,[si+fcb_net_handle]
 15340                                  	;;cmp	ax,[es:di+1Dh]
 15341                                  	;cmp	ax,[ES:DI+SF_ENTRY.sf_dirsec]
 15342                                  	;jnz	short BadSFT
 15343                                  	;;cmp	ax,[es:di+19h]
 15344                                  	;cmp	ax,[ES:DI+sf_netid]
 15345                                  	;jnz     short BadSFT
 15346                                  	;;mov	ax,[si+1Eh]
 15347                                  	;mov	ax,[si+fcb_l_attr]
 15348                                  	;;cmp	ax,[es:di+1Bh]
 15349                                  	;cmp	ax,[es:di+SF_ENTRY.sf_lstclus]
 15350                                  	;jnz     short BadSFT
 15351                                  
 15352                                  	; MSDOS 6.0
 15353                                  	;mov	ax,[si+1Ch]
 15354 000021AA 8B441C                  	MOV	AX,[SI+fcb_netID]	;AN000;IFS.DOS 4.00
 15355                                  	; 09/11/2022
 15356                                  	;cmp	ax,[es:di+0Bh] 
 15357 000021AD 263B450B                	CMP	AX,[ES:DI+sf_serial_ID]	;AN000;IFS.DOS 4.00
 15358 000021B1 75F5                    	JNZ	short BadSFT
 15359                                  
 15360                                  ;----- END In net support -----
 15361                                  
 15362                                  CheckNet_retn:
 15363 000021B3 C3                      	retn
 15364                                  
 15365                                  CheckNoShare:
 15366                                  
 15367                                  ; 16/12/2022
 15368                                  ;	; 09/11/2022 (following test instruction is nonsense!)
 15369                                  ;	; (I am leaving it here for MSDOS 5.0 MSDOS.SYS compatibility)
 15370                                  ;	;test	al,40h
 15371                                  ;	test	AL,FCBDEVICE		; Device?
 15372                                  ;	;jnz	short $+2 ; 09/11/2022
 15373                                  ;	JNZ	short CheckNoShareDev 	; Yes
 15374                                  
 15375                                  	; MSDOS 3.3 - IBMDOS.COM - Offset 27EFh
 15376                                  	;;mov	bx,[si+1Dh]
 15377                                  	;MOV	BX,[SI+fcb_nsl_dirsec]
 15378                                  	;;cmp	bx,[es:di+1Dh]
 15379                                  	;cmp	bx,[ES:DI+SF_ENTRY.sf_dirsec]
 15380                                  	;jnz	short BadSFT
 15381                                  	;;mov	bl,[si+1Fh]
 15382                                  	;MOV	bl,[SI+fcb_nsl_dirpos]
 15383                                  	;;cmp	bl,[es:di+1Fh]
 15384                                  	;cmp	bl,[ES:DI+SF_ENTRY.sf_dirpos]
 15385                                  	;jnz	short BadSFT
 15386                                  	;;mov	bl,[si+1Ah]
 15387                                  	;MOV	bl,[SI+fcb_nsl_bits]
 15388                                  	;;mov	bh,[es:di+5]
 15389                                  	;MOV	bh,[ES:DI+SF_ENTRY.sf_flags]
 15390                                  	;xor	bh,bl
 15391                                  	;and	bh,0C0h
 15392                                  	;jnz	short BadSFT
 15393                                  	;;xor	bl,[es:di+2]
 15394                                  	;xor	bl,[ES:DI+SF_ENTRY.sf_mode]
 15395                                  	;and	bl,0Fh
 15396                                  	;jnz	short BadSFT
 15397                                  	;push	di
 15398                                  	;push	si
 15399                                  	;;lea	di,[di+20h]  ; MSDOS 3.3
 15400                                  	;LEA	DI,[DI+SF_ENTRY.sf_name]
 15401                                  	;;lea	si,[si+1]
 15402                                  	;LEA	SI,[SI+SYS_FCB.name]
 15403                                  	;;mov	cx,11
 15404                                  	;MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 15405                                  	;repe	cmpsb
 15406                                  	;pop	si
 15407                                  	;pop	di
 15408                                  	;jnz	short BadSFT
 15409                                  	;;mov	bx,[si+1Bh]
 15410                                  	;MOV	bX,[SI+fcb_nsl_firclus]
 15411                                  	;jmp	short CheckFirClus
 15412                                  
 15413                                  	; MSDOS 6.0
 15414                                  
 15415                                  	; SR;
 15416                                  	; The code below to match a local FCB with its SFT can no longer be
 15417                                  	; used. We just return a no-match status. This check is done right
 15418                                  	; at the top.
 15419                                  
 15420                                  CheckNoShareDev:
 15421                                  	;mov	bx,[si+1Ah]
 15422 000021B4 8B5C1A                  	MOV	BX,[SI+fcb_nsld_drvptr]
 15423                                  	;cmp	bx,[es:di+7]
 15424 000021B7 263B5D07                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr]
 15425 000021BB 75EB                    	JNZ	short BadSFT
 15426                                  	;mov	bx,[si+1Ch]
 15427 000021BD 8B5C1C                  	MOV	BX,[SI+fcb_nsld_drvptr+2]
 15428                                  	;cmp	bx,[es:di+9]
 15429 000021C0 263B5D09                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr+2]
 15430 000021C4 75E2                    	JNZ	short BadSFT
 15431 000021C6 EBD3                    	JMP	short CheckD
 15432                                  
 15433                                  ;Break	<SFTFromFCB - take a FCB and obtain a SFT from it>
 15434                                  ;----------------------------------------------------------------------------
 15435                                  ;
 15436                                  ;   SFTFromFCB - the workhorse of this compatability crap. Check to see if
 15437                                  ;	the SFT for the FCB is Good. If so, make ThisSFT point to it. If not
 15438                                  ;	good, get one from the cache and regenerate it. Overlay the LRU field
 15439                                  ;	with PID
 15440                                  ;
 15441                                  ;   Inputs:	DS:SI point to FCB
 15442                                  ;   Outputs:	ThisSFT point to appropriate SFT
 15443                                  ;		Carry clear -> OK ES:DI -> SFT
 15444                                  ;		Carry set -> error in ax
 15445                                  ;   Registers modified: ES,DI, AX
 15446                                  ;
 15447                                  ;----------------------------------------------------------------------------
 15448                                  
 15449                                  SFTFromFCB:
 15450                                  	; called from fcbio and $fcb_close. SS already set up to DOSDATA
 15451                                  
 15452                                  	; 17/05/2019 - Retro DOS v4.0
 15453                                  
 15454 000021C8 50                      	push	ax
 15455 000021C9 53                      	push	bx
 15456                                  	;mov	al,[si+18h]
 15457 000021CA 8A4418                  	MOV	AL,[SI+fcb_sfn] 	; set SFN for check
 15458 000021CD E88BFF                  	call	CheckFCB
 15459 000021D0 5B                      	pop	bx
 15460 000021D1 58                      	pop	ax
 15461                                  	;MOV	[CS:THISSFT],DI		; SS override
 15462                                  	;MOV	[CS:THISSFT+2],ES
 15463 000021D2 36893E[9E05]            	MOV	[SS:THISSFT],DI		; SS override
 15464 000021D7 368C06[A005]            	MOV	[SS:THISSFT+2],ES
 15465 000021DC 7311                    	JNC	short Set_SFT		; no problems, just set thissft
 15466                                  	
 15467                                  	; 09/11/2022 (MSDOS 5.0)
 15468                                  	; 31/05/2019
 15469 000021DE 06                      	push	es ; * (MSDOS 6.21) & (MSDOS 5.0)
 15470 000021DF E876E2                  	call	save_world
 15471 000021E2 E859FE                  	call	FCBRegen
 15472 000021E5 E859E2                  	call	restore_world		; use macro restore world
 15473 000021E8 07                      	pop	es ; * (MSDOS 6.21) ; 31/05/2019 ; 09/11/2022 (MSDOS 5.0)	
 15474                                  
 15475                                  	;MOV	AX,[CS:EXTERR]		; SS override
 15476 000021E9 36A1[2403]              	MOV	AX,[SS:EXTERR]		; SS override
 15477 000021ED 72C4                    	jc	short CheckNet_retn
 15478                                  
 15479                                  Set_SFT: 
 15480                                  	;LES	DI,[CS:THISSFT]		; SS override for THISSFT & PROC_ID
 15481 000021EF 36C43E[9E05]            	les	di,[ss:THISSFT]
 15482                                  	;PUSH	word [CS:PROC_ID]	; set process id
 15483 000021F4 36FF36[3C03]            	push	word [ss:PROC_ID]
 15484                                  	;pop	word [es:di+31h]
 15485 000021F9 268F4531                	POP     word [ES:DI+SF_ENTRY.sf_PID]
 15486 000021FD C3                      	retn				; carry is clear
 15487                                  
 15488                                  ;Break	<FCBHardErr - generate INT 24 for hard errors on FCBS>
 15489                                  ;----------------------------------------------------------------------------
 15490                                  ;
 15491                                  ;   FCBHardErr - signal to a user app that he is trying to use an
 15492                                  ;	unavailable FCB.
 15493                                  ;
 15494                                  ;   Inputs:	none.
 15495                                  ;   Outputs:	none.
 15496                                  ;   Registers modified: all
 15497                                  ;
 15498                                  ;----------------------------------------------------------------------------
 15499                                  
 15500                                  	; 21/01/2024 - Retro DOS v5.0
 15501                                  FCBHardErr:
 15502                                  	; 17/05/2019 - Retro DOS v4.0
 15503 000021FE 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 15504                                  	;
 15505                                  	;mov	ax,23h
 15506 00002203 B82300                  	MOV	AX,error_FCB_unavailable
 15507                                  	;;mov	byte [cs:ALLOWED],8
 15508                                  	;MOV	byte [CS:ALLOWED],Allowed_FAIL
 15509 00002206 26C606[4B03]08          	mov	byte [es:ALLOWED],Allowed_FAIL	
 15510                                  	
 15511                                  	;LES	BP,[CS:THISDPB]
 15512 0000220C 26C42E[8A05]            	les	bp,[es:THISDPB]
 15513                                  	
 15514 00002211 BF0100                  	MOV	DI,1			; Fake some registers
 15515 00002214 89F9                    	MOV	CX,DI
 15516                                  	;;;
 15517                                  	; 21/01/2024 (PCDOS 7.1 IBMDOS.COM) 
 15518 00002216 31D2                    	xor	dx,dx ; 0
 15519                                  	;cmp	[es:bp+0Fh],dx
 15520 00002218 2639560F                	cmp	[es:bp+DPB.FAT_SIZE],dx ; 0
 15521 0000221C 740B                    	jz	short fcbharderr_fat32 ; FAT32
 15522 0000221E 268916[0706]            	mov	[es:HIGH_SECTOR],dx ; 0
 15523                                  	;mov	dx,[es:bp+0Bh]
 15524 00002223 268B560B                	mov	dx,[es:bp+DPB.FIRST_SECTOR]
 15525 00002227 EB0D                    	jmp	short fcbharderr_fat
 15526                                  fcbharderr_fat32:
 15527                                  	;mov	dx,[es:bp+2Bh]
 15528 00002229 268B562B                	mov	dx,[es:bp+DPB.FCLUS_FSECTOR+2]
 15529 0000222D 268916[0706]            	mov	[es:HIGH_SECTOR],dx
 15530                                  	;mov	dx,[es:bp+29h]
 15531 00002232 268B5629                	mov	dx,[es:bp+DPB.FCLUS_FSECTOR]
 15532                                  fcbharderr_fat: 
 15533                                  	;;;
 15534                                  	; 21/01/2024
 15535                                  	;;mov	dx,[es:bp+0Bh]
 15536                                  	;MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 15537                                  	
 15538 00002236 E87F3A                  	call	HARDERR
 15539 00002239 F9                      	STC
 15540 0000223A C3                      	retn
 15541                                  
 15542                                  ;============================================================================
 15543                                  ; FCBIO2.ASM, MSDOS 6.0, 1991
 15544                                  ;============================================================================
 15545                                  ; 21/07/2018 - Retro DOS v3.0
 15546                                  ; 17/05/2019 - Retro DOS v4.0
 15547                                  
 15548                                  ;**	FCBIO2.ASM - Ancient 1.0 1.1 FCB system calls
 15549                                  ;
 15550                                  ;	GetRR
 15551                                  ;	GetExtent
 15552                                  ;	SetExtent
 15553                                  ;	GetExtended
 15554                                  ;	GetRecSize
 15555                                  ;	FCBIO
 15556                                  ;	$FCB_OPEN
 15557                                  ;	$FCB_CREATE
 15558                                  ;	$FCB_RANDOM_WRITE_BLOCK
 15559                                  ;	$FCB_RANDOM_READ_BLOCK
 15560                                  ;	$FCB_SEQ_READ
 15561                                  ;	$FCB_SEQ_WRITE
 15562                                  ;	$FCB_RANDOM_READ
 15563                                  ;	$FCB_RANDOM_WRITE
 15564                                  ;
 15565                                  ;	Revision history:
 15566                                  ;
 15567                                  ;		Created: ARR 4 April 1983
 15568                                  ;			 MZ  6 June  1983 completion of functions
 15569                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 15570                                  ;				  times.  Change so successive closes work by
 15571                                  ;				  always returning OK.	Also, detect I/O to
 15572                                  ;				  already closed FCB and return EOF.
 15573                                  ;		 MZ 16 Jan   1984 More braindamage.  Need to separate info
 15574                                  ;				  out of sft into FCB for reconnection
 15575                                  ;
 15576                                  ;	    A000   version 4.00	Jan. 1988
 15577                                  
 15578                                  ; Defintions for FCBOp flags
 15579                                  
 15580                                  RANDOM	equ 2				; random operation
 15581                                  FCBREAD equ 4				; doing a read
 15582                                  BLOCK	equ 8				; doing a block I/O
 15583                                  
 15584                                  ;Break <GetRR - return the random record field in DX:AX>
 15585                                  ;---------------------------------------------------------------------------
 15586                                  ;
 15587                                  ;   GetRR - correctly load DX:AX with the random record field (3 or 4 bytes)
 15588                                  ;	from the FCB pointed to by DS:SI
 15589                                  ;
 15590                                  ;   Inputs:	DS:SI point to an FCB
 15591                                  ;		BX has record size
 15592                                  ;   Outputs:	DX:AX contain the contents of the random record field
 15593                                  ;   Registers modified: none
 15594                                  ;---------------------------------------------------------------------------
 15595                                  
 15596                                  GetRR:
 15597                                  	;mov	ax,[si+21h]
 15598 0000223B 8B4421                  	MOV	AX,[SI+SYS_FCB.RR]	; get low order part
 15599                                  	;mov	dx,[si+23h]
 15600 0000223E 8B5423                  	MOV	DX,[SI+SYS_FCB.RR+2]	; get high order part
 15601 00002241 83FB40                  	CMP	BX,64			; ignore MSB of RR if recsiz > 64
 15602 00002244 7202                    	JB	short GetRRBye
 15603                                  GetExtent_bye:	; 21/01/2024
 15604 00002246 30F6                    	XOR	DH,DH
 15605                                  GetRRBye:
 15606 00002248 C3                      	retn
 15607                                  
 15608                                  ;Break <GetExtent - retrieve next location for sequential IO>
 15609                                  ;---------------------------------------------------------------------------
 15610                                  ;
 15611                                  ;   GetExtent - Construct the next record to perform I/O from the EXTENT and
 15612                                  ;	NR fields in the FCB.
 15613                                  ;
 15614                                  ;   Inputs:	DS:SI - point to FCB
 15615                                  ;   Outputs:	DX:AX contain the contents of the random record field
 15616                                  ;   Registers modified: none
 15617                                  ;---------------------------------------------------------------------------
 15618                                  
 15619                                  GetExtent:
 15620                                  	;mov	al,[si+20h]
 15621 00002249 8A4420                  	MOV	AL,[SI+SYS_FCB.NR]	; get low order piece
 15622                                  	;mov	dx,[si+0Ch]
 15623 0000224C 8B540C                  	MOV	DX,[SI+SYS_FCB.EXTENT]	; get high order piece
 15624 0000224F D0E0                    	SHL	AL,1
 15625 00002251 D1EA                    	SHR	DX,1
 15626 00002253 D0D8                    	RCR	AL,1	; move low order bit of DL to high order of AH
 15627 00002255 88D4                    	MOV	AH,DL
 15628 00002257 88F2                    	MOV	DL,DH
 15629                                  	; 21/01/2024 (PCDOS 7.1 IBMDOS.COM)
 15630                                  	;XOR	DH,DH
 15631                                  	;retn
 15632 00002259 EBEB                    	jmp	short GetExtent_bye
 15633                                  
 15634                                  ;Break <SetExtent - update the extent/NR field>
 15635                                  ;---------------------------------------------------------------------------
 15636                                  ;
 15637                                  ;   SetExtent - change the position of an FCB by filling in the extent/NR
 15638                                  ;	fields
 15639                                  ;
 15640                                  ;   Inputs:	DS:SI point to FCB
 15641                                  ;		DX:AX is a record location in file
 15642                                  ;   Outputs:	Extent/NR fields are filled in
 15643                                  ;   Registers modified: CX
 15644                                  ;---------------------------------------------------------------------------
 15645                                  
 15646                                  SetExtent:
 15647 0000225B 50                      	push	ax
 15648 0000225C 52                      	push	dx
 15649 0000225D 89C1                    	MOV	CX,AX
 15650 0000225F 247F                    	AND	AL,7FH			; next rec field
 15651                                  	;mov	[si+20h],al
 15652 00002261 884420                  	MOV	[SI+SYS_FCB.NR],AL
 15653 00002264 80E180                  	AND	CL,80H			; save upper bit
 15654 00002267 D1E1                    	SHL	CX,1
 15655 00002269 D1D2                    	RCL	DX,1			; move high bit of CX to low bit of DX
 15656 0000226B 88E8                    	MOV	AL,CH
 15657 0000226D 88D4                    	MOV	AH,DL
 15658                                  	;mov	[si+0Ch], ax
 15659 0000226F 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; all done
 15660 00002272 5A                      	pop	dx
 15661 00002273 58                      	pop	ax
 15662 00002274 C3                      	retn
 15663                                  
 15664                                  ;Break <GetExtended - find FCB in potential extended fcb>
 15665                                  ;---------------------------------------------------------------------------
 15666                                  ;
 15667                                  ;   GetExtended - Make DS:SI point to FCB from DS:DX
 15668                                  ;
 15669                                  ;   Inputs:	DS:DX point to a possible extended FCB
 15670                                  ;   Outputs:	DS:SI point to the FCB part
 15671                                  ;		zeroflag set if not extended fcb
 15672                                  ;   Registers modified: SI
 15673                                  ;---------------------------------------------------------------------------
 15674                                  
 15675                                  GetExtended:
 15676 00002275 89D6                    	MOV	SI,DX			; point to Something
 15677 00002277 803CFF                  	CMP	BYTE [SI],-1		; look for extention
 15678 0000227A 7503                    	JNZ	short GetBye		; not there
 15679 0000227C 83C607                  	ADD	SI,7			; point to FCB
 15680                                  GetBye:
 15681 0000227F 39D6                    	CMP	SI,DX			; set condition codes
 15682                                  getextd_retn:
 15683 00002281 C3                      	retn
 15684                                  
 15685                                  ;Break <GetRecSize - return in BX the FCB record size>
 15686                                  ;---------------------------------------------------------------------------
 15687                                  ;
 15688                                  ;   GetRecSize - return in BX the record size from the FCB at DS:SI
 15689                                  ;
 15690                                  ;   Inputs:	DS:SI point to a non-extended FCB
 15691                                  ;   Outputs:	BX contains the record size
 15692                                  ;   Registers modified: None
 15693                                  ;---------------------------------------------------------------------------
 15694                                  
 15695                                  	; 22/01/2024
 15696                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15697                                  GetRecSize:
 15698                                  	;mov	bx,[si+0Eh]
 15699 00002282 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 15700 00002285 09DB                    	OR	BX,BX			; is it nul?
 15701                                  	;jz	short getextd_retn
 15702                                  	; 22/01/2024 (BugFix)
 15703 00002287 75F8                    	jnz	short getextd_retn
 15704                                  	;MOV	BX,128			; use default size
 15705 00002289 B380                    	mov	bl,128	; (PCDOS 7.1 IBMDOS.COM)
 15706                                  	;mov	[si+0Eh],bx
 15707 0000228B 895C0E                  	MOV	[SI+SYS_FCB.RECSIZ],BX	; stuff it back
 15708 0000228E C3                      	retn
 15709                                  
 15710                                  ; 23/01/2024 - Retro DOS v5.0
 15711                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:61B3h
 15712                                  
 15713                                  ; 22/07/2018 - Retro DOS v3.0
 15714                                  
 15715                                  ;BREAK <$FCB_Random_write_Block - write a block of records to a file >
 15716                                  ;----------------------------------------------------------------------------
 15717                                  ;
 15718                                  ;   $FCB_Random_Write_Block - retrieve a location from the FCB, seek to it
 15719                                  ;	and write a number of blocks from it.
 15720                                  ;
 15721                                  ;   Inputs:	DS:DX point to an FCB
 15722                                  ;   Outputs:	AL = 0 write was successful and the FCB position is updated
 15723                                  ;		AL <> 0 Not enough room on disk for the output
 15724                                  ;
 15725                                  ;----------------------------------------------------------------------------
 15726                                  
 15727                                  _$FCB_RANDOM_WRITE_BLOCK:
 15728                                  	;mov	AL,0Ah	
 15729 0000228F B00A                    	MOV	AL,RANDOM+BLOCK
 15730 00002291 EB12                    	JMP	short FCBIO	; 23/01/2024
 15731                                  
 15732                                  ;BREAK <$FCB_Random_Read_Block - read a block of records to a file >
 15733                                  ;----------------------------------------------------------------------------
 15734                                  ;
 15735                                  ;   $FCB_Random_Read_Block - retrieve a location from the FCB, seek to it
 15736                                  ;	and read a number of blocks from it.
 15737                                  ;
 15738                                  ;   Inputs:	DS:DX point to an FCB
 15739                                  ;   Outputs:	AL = error codes defined above
 15740                                  ;
 15741                                  ;----------------------------------------------------------------------------
 15742                                  
 15743                                  _$FCB_RANDOM_READ_BLOCK:
 15744                                  	;mov	AL,0Eh	
 15745 00002293 B00E                    	MOV	AL,RANDOM+FCBREAD+BLOCK
 15746 00002295 EB0E                    	JMP	short FCBIO	; 23/01/2024
 15747                                  
 15748                                  ;BREAK <$FCB_Seq_Read - read the next record from a file >
 15749                                  ;----------------------------------------------------------------------------
 15750                                  ;
 15751                                  ;   $FCB_Seq_Read - retrieve the next record from an FCB and read it into
 15752                                  ;	memory
 15753                                  ;
 15754                                  ;   Inputs:	DS:DX point to an FCB
 15755                                  ;   Outputs:	AL = error codes defined above
 15756                                  ;
 15757                                  ;----------------------------------------------------------------------------
 15758                                  
 15759                                  _$FCB_SEQ_READ:
 15760                                  	;mov	AL,4	
 15761 00002297 B004                    	MOV	AL,FCBREAD
 15762 00002299 EB0A                    	JMP	short FCBIO	; 23/01/2024
 15763                                  
 15764                                  ;BREAK <$FCB_Seq_Write - write the next record to a file >
 15765                                  ;----------------------------------------------------------------------------
 15766                                  ;
 15767                                  ;   $FCB_Seq_Write - retrieve the next record from an FCB and write it to the
 15768                                  ;	file
 15769                                  ;
 15770                                  ;   Inputs:	DS:DX point to an FCB
 15771                                  ;   Outputs:	AL = error codes defined above
 15772                                  ;
 15773                                  ;----------------------------------------------------------------------------
 15774                                  
 15775                                  _$FCB_SEQ_WRITE:
 15776 0000229B B000                    	MOV	AL,0
 15777 0000229D EB06                    	JMP	short FCBIO	; 23/01/2024
 15778                                  
 15779                                  ;BREAK <$FCB_Random_Read - Read a single record from a file >
 15780                                  ;----------------------------------------------------------------------------
 15781                                  ;
 15782                                  ;   $FCB_Random_Read - retrieve a location from the FCB, seek to it and read a
 15783                                  ;	record from it.
 15784                                  ;
 15785                                  ;   Inputs:	DS:DX point to an FCB
 15786                                  ;   Outputs:	AL = error codes defined above
 15787                                  ;
 15788                                  ;----------------------------------------------------------------------------
 15789                                  
 15790                                  _$FCB_RANDOM_READ:
 15791                                  	;mov	AL,6	
 15792 0000229F B006                    	MOV	AL,RANDOM+FCBREAD
 15793                                  	; 23/01/2024
 15794                                  	;jmp	FCBIO 		; single block
 15795 000022A1 EB02                    	jmp	short FCBIO
 15796                                  
 15797                                  ;BREAK <$FCB_Random_Write - write a single record to a file >
 15798                                  ;----------------------------------------------------------------------------
 15799                                  ;
 15800                                  ;   $FCB_Random_Write - retrieve a location from the FCB, seek to it and write
 15801                                  ;	a record to it.
 15802                                  ;
 15803                                  ;   Inputs:	DS:DX point to an FCB
 15804                                  ;   Outputs:	AL = error codes defined above
 15805                                  ;
 15806                                  ;----------------------------------------------------------------------------
 15807                                  
 15808                                  _$FCB_RANDOM_WRITE:
 15809                                  	;mov	AL,2	
 15810 000022A3 B002                    	MOV	AL,RANDOM
 15811                                  	; 23/01/2024
 15812                                  	;;jmp	FCBIO
 15813                                  	;jmp	short FCBIO
 15814                                  
 15815                                  ;BREAK <FCBIO - do internal FCB I/O>
 15816                                  ;---------------------------------------------------------------------------
 15817                                  ;
 15818                                  ;   FCBIO - look at FCBOP and merge all FCB operations into a single routine.
 15819                                  ;
 15820                                  ;   Inputs:	FCBOP flags which operations need to be performed
 15821                                  ;		DS:DX point to FCB
 15822                                  ;		CX may have count of number of records to xfer
 15823                                  ;   Outputs:	AL has error code
 15824                                  ;   Registers modified: all
 15825                                  ;---------------------------------------------------------------------------
 15826                                  
 15827                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15828                                  	; DOSCODE:5B17h (MSDOS 5.0 MSDOS.SYS)
 15829                                  
 15830                                  	; 23/01/2024
 15831                                  	; DOSCODE:5B2Bh (MSDOS 6.22 MSDOS.SYS)
 15832                                  
 15833                                  	; 23/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 15834                                  	; DOSCODE:61C9h (PCDOS 7.1 IBMDOS.COM)
 15835                                  
 15836                                  FCBIO:
 15837                                  
 15838                                  FEOF	EQU	1
 15839                                  FTRIM	EQU	2
 15840                                  
 15841                                  %define	FCBErr	byte [bp-1]  ; byte	
 15842                                  %define	cRec	word [bp-3]  ; word	
 15843                                  ;%define RecPos	word [bp-7]  ; dword
 15844                                  %define RecPosL	word [bp-7]  ; word
 15845                                  %define RecPosH	word [bp-5]  ; word
 15846                                  %define	RecSize	word [bp-9]  ; word
 15847                                  ;%define bPos	word [bp-13] ; dword
 15848                                  %define bPosL	word [bp-13] ; word
 15849                                  %define bPosH	word [bp-11] ; word
 15850                                  %define cByte	word [bp-15] ; word	
 15851                                  %define cResult word [bp-17] ; word	
 15852                                  %define	cRecRes	word [bp-19] ; word
 15853                                  %define	FCBOp	byte [bp-20] ; byte
 15854                                  ; 23/01/2024
 15855                                  %define bPos bp-13
 15856                                  
 15857                                  	;Enter
 15858                                  
 15859 000022A5 55                      	push	bp
 15860 000022A6 89E5                    	mov	bp,sp
 15861 000022A8 83EC14                  	sub	sp,20
 15862                                  	;mov	[bp-20],al
 15863 000022AB 8846EC                  	MOV	FCBOp,AL
 15864                                  	;mov	byte [bp-1],0
 15865 000022AE C646FF00                	MOV	FCBErr,0		;   FCBErr = 0;
 15866 000022B2 E8C0FF                  	call	GetExtended		;   FCB = GetExtended ();
 15867                                  	;test	byte [bp-20],8
 15868 000022B5 F646EC08                	TEST	FCBOp,BLOCK		;   if ((OP&BLOCK) == 0)
 15869 000022B9 7503                    	JNZ	short GetPos
 15870 000022BB B90100                  	MOV	CX,1			;	cRec = 1;
 15871                                  GetPos:
 15872                                  	;mov	[bp-3],cx
 15873 000022BE 894EFD                  	MOV	cRec,CX 		;*Tail coalesce
 15874 000022C1 E885FF                  	call	GetExtent		;   RecPos = GetExtent ();
 15875 000022C4 E8BBFF                  	call	GetRecSize		;   RecSize = GetRecSize ();
 15876                                  	;mov	[bp-9],bx
 15877 000022C7 895EF7                  	MOV	RecSize,BX
 15878                                  	;test	byte [bp-20],2
 15879 000022CA F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&RANDOM) <> 0)
 15880 000022CE 7403                    	JZ	short GetRec
 15881 000022D0 E868FF                  	call	GetRR			;	RecPos = GetRR ();
 15882                                  GetRec:
 15883                                  	;mov	[bp-7],ax
 15884 000022D3 8946F9                  	MOV	RecPosL,AX		;*Tail coalesce
 15885                                  	;mov	[bp-5],dx
 15886 000022D6 8956FB                  	MOV	RecPosH,DX
 15887 000022D9 E87FFF                  	call	SetExtent		;   SetExtent (RecPos);
 15888                                  	;mov	ax,[bp-5]
 15889 000022DC 8B46FB                  	MOV	AX,RecPosH		;   bPos = RecPos * RecSize;
 15890 000022DF F7E3                    	MUL	BX
 15891 000022E1 89C7                    	MOV	DI,AX
 15892                                  	;mov	ax,[bp-7]
 15893 000022E3 8B46F9                  	MOV	AX,RecPosL
 15894 000022E6 F7E3                    	MUL	BX
 15895 000022E8 01FA                    	ADD	DX,DI
 15896                                  	;mov	[bp-13],ax
 15897 000022EA 8946F3                  	MOV	bPosL,AX
 15898                                  	;mov	[bp-11],dx
 15899 000022ED 8956F5                  	MOV	bPosH,DX
 15900                                  	;mov	ax,[bp-3]
 15901 000022F0 8B46FD                  	MOV	AX,cRec 		;   cByte = cRec * RecSize;
 15902 000022F3 F7E3                    	MUL	BX
 15903                                  	;mov	[bp-15],ax
 15904 000022F5 8946F1                  	MOV	cByte,AX
 15905                                  
 15906                                  ;hkn; 	SS override
 15907 000022F8 360306[2C03]            	ADD	AX,[SS:DMAADD]		;   if (cByte+DMA > 64K) {
 15908 000022FD 83D200                  	ADC	DX,0
 15909 00002300 7419                    	JZ	short DoOper
 15910                                  	;mov	byte [bp-1],2
 15911 00002302 C646FF02                	MOV	FCBErr,FTRIM		;	FCBErr = FTRIM;
 15912                                  
 15913                                  ;hkn; 	SS override
 15914 00002306 36A1[2C03]              	MOV	AX,[SS:DMAADD]		;	cRec = (64K-DMA)/RecSize;
 15915 0000230A F7D8                    	NEG	AX
 15916 0000230C 7501                    	JNZ	short DoDiv
 15917 0000230E 48                      	DEC	AX
 15918                                  DoDiv:
 15919 0000230F 31D2                    	XOR	DX,DX
 15920 00002311 F7F3                    	DIV	BX
 15921                                  	;mov	[bp-3],ax
 15922 00002313 8946FD                  	MOV	cRec,AX
 15923 00002316 F7E3                    	MUL	BX			;	cByte = cRec * RecSize;
 15924                                  	;mov	[bp-15],ax
 15925 00002318 8946F1                  	MOV	cByte,AX		;	}
 15926                                  DoOper:
 15927 0000231B 31DB                    	XOR	BX,BX
 15928                                  	;mov	[bp-17],bx
 15929 0000231D 895EEF                  	MOV	cResult,BX		;   cResult = 0;
 15930                                  	;cmp	[bp-15],bx
 15931 00002320 395EF1                  	CMP	cByte,BX		;   if (cByte <> 0 ||
 15932 00002323 7506                    	JNZ	short DoGetExt
 15933                                  	;test	byte [bp-1],2
 15934 00002325 F646FF02                	TEST	FCBErr,FTRIM		;	(FCBErr&FTRIM) == 0) {
 15935                                  	;JZ	short DoGetExt
 15936                                  	;JMP	short SkipOp
 15937                                  	; 16/12/2022
 15938 00002329 756E                    	jnz	short SkipOp
 15939                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15940                                  	;JZ	short DoGetExt
 15941                                  	;JMP	short SkipOp
 15942                                  DoGetExt:
 15943 0000232B E89AFE                  	call	SFTFromFCB		;	if (!SFTFromFCB (SFT,FCB))
 15944 0000232E 730F                    	JNC	short ContinueOp
 15945                                  FCBDeath:
 15946 00002330 E85CE3                  	call	FCB_RET_ERR		; signal error, map for extended
 15947                                  	;mov	word [bp-19],0
 15948 00002333 C746ED0000              	MOV	cRecRes,0		; no bytes transferred
 15949                                  	;mov	byte [bp-1],1
 15950 00002338 C646FF01                	MOV	FCBErr,FEOF		;	    return FTRIM;
 15951 0000233C E9E700                  	JMP	FCBSave 		; bam!
 15952                                  ContinueOp:
 15953                                  	; 23/01/2024
 15954                                  	; (PCDOS 7.1 IBMDOS.COM)
 15955                                  	;
 15956                                  	;;mov	ax,[si+10h]
 15957                                  	;MOV	AX,[SI+SYS_FCB.FILSIZ]
 15958                                  	;;mov	[es:di+11h],ax
 15959                                  	;MOV	[ES:DI+SF_ENTRY.sf_size],AX
 15960                                  	;;mov	ax,[si+12h]
 15961                                  	;MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 15962                                  	;;mov	[es:di+13h],ax
 15963                                  	;MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 15964                                  	;;;
 15965 0000233F 1E                      	push	ds
 15966 00002340 C54410                  	lds	ax,[si+SYS_FCB.FILSIZ]
 15967 00002343 26894511                	mov	[es:di+SF_ENTRY.sf_size],ax
 15968 00002347 268C5D13                	mov	[es:di+SF_ENTRY.sf_size+2],ds
 15969 0000234B C546F3                  	lds	ax,[bPos] ; lds ax,[bp-13]
 15970 0000234E 8CDA                    	mov	dx,ds
 15971 00002350 1F                      	pop	ds
 15972                                  	;;;
 15973                                  	;;mov	ax,[bp-13]
 15974                                  	;MOV	AX,bPosL
 15975                                  	;;mov	dx,[bp-11]
 15976                                  	;MOV	DX,bPosH
 15977                                  	
 15978                                  	;mov	[es:di+15h],ax
 15979 00002351 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 15980                                  	;xchg	dx,[es:di+17h]
 15981 00002355 26875517                	XCHG	[ES:DI+SF_ENTRY.sf_position+2],DX
 15982 00002359 52                      	PUSH	DX			; save away Open age.
 15983                                  	;mov	cx,[bp-15]
 15984 0000235A 8B4EF1                  	MOV	CX,cByte		;	cResult =
 15985                                  
 15986                                  ;hkn; DOS_Read is in DOSCODE
 15987 0000235D BF[4D3B]                	MOV	DI,DOS_READ		;	    *(OP&FCBRead ? DOS_Read
 15988                                  	;test	byte [bp-20],4
 15989 00002360 F646EC04                	TEST	FCBOp,FCBREAD		;		 : DOS_Write)(cRec);
 15990 00002364 7503                    	JNZ	short DoContext
 15991                                  
 15992                                  ;hkn; DOS_Write is in DOSCODE
 15993 00002366 BF[763D]                	MOV	DI,DOS_WRITE
 15994                                  DoContext:
 15995 00002369 55                      	push	bp
 15996 0000236A 1E                      	push	ds
 15997 0000236B 56                      	push	si
 15998                                  
 15999                                  ;hkn; SS is DOSDATA
 16000 0000236C 16                      	push	ss
 16001 0000236D 1F                      	pop	ds
 16002                                  
 16003                                  ;; Fix for disk full
 16004 0000236E FFD7                    	CALL	DI	; DOS_READ or DOS_WRITE	
 16005                                  	
 16006 00002370 5E                      	pop	si
 16007 00002371 1F                      	pop	ds
 16008 00002372 5D                      	pop	bp
 16009 00002373 72BB                    	JC	short FCBDeath
 16010                                  	
 16011 00002375 36803E[0B06]00          	CMP	BYTE [SS:DISK_FULL],0	; treat disk full as error
 16012 0000237B 7406                    	JZ	short NODSKFULL
 16013 0000237D 36C606[0B06]00          	MOV	BYTE [SS:DISK_FULL],0	; clear the flag
 16014                                  
 16015                                  	; 23/01/2024
 16016                                  	; (PCDOS 7.1 IBMDOS.COM)
 16017                                  	;;mov	byte [bp-1],1 
 16018                                  	;MOV	FCBErr,FEOF		; set disk full flag
 16019                                  
 16020                                  NODSKFULL:
 16021                                  ;; Fix for disk full
 16022                                  	;mov	[bp-17],cx
 16023 00002383 894EEF                  	MOV	cResult,CX
 16024 00002386 E8FBFA                  	call	SaveFCBInfo		;	SaveFCBInfo (FCB);
 16025                                  	;pop	word [es:di+17h]	
 16026 00002389 268F4517                	POP	WORD [ES:DI+SF_ENTRY.sf_position+2] ; restore open age
 16027                                  			       ; (sf_OpenAge = SF_ENTRY.sf_position+2)
 16028                                  
 16029                                  	; 23/01/2024
 16030                                  	; (PCDOS 7.1 IBMDOS.COM)
 16031                                  	;
 16032                                  	;;mov	ax,[es:di+11h]
 16033                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 16034                                  	;;mov	[si+10h],ax
 16035                                  	;MOV	[SI+SYS_FCB.FILSIZ],AX
 16036                                  	;;mov	ax,[es:di+13h]
 16037                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 16038                                  	;;mov	[si+12h],ax
 16039                                  	;MOV	[SI+SYS_FCB.FILSIZ+2],AX
 16040                                  	;;;
 16041 0000238D 06                      	push	es
 16042 0000238E 26C44511                	les	ax,[es:di+SF_ENTRY.sf_size]
 16043 00002392 894410                  	mov	[si+SYS_FCB.FILSIZ],ax
 16044 00002395 8C4412                  	mov	[si+SYS_FCB.FILSIZ+2],es
 16045 00002398 07                      	pop	es
 16046                                  	;;;
 16047                                  					;	}
 16048                                  SkipOp:
 16049                                  	;mov	ax,[bp-17]
 16050 00002399 8B46EF                  	MOV	AX,cResult		;   cRecRes = cResult / RecSize;
 16051 0000239C 31D2                    	XOR	DX,DX
 16052                                  	;div	word [bp-9]
 16053 0000239E F776F7                  	DIV	RecSize
 16054                                  	;mov	[bp-19],ax
 16055 000023A1 8946ED                  	MOV	cRecRes,AX
 16056                                  	;add	[bp-7],ax
 16057 000023A4 0146F9                  	ADD	RecPosL,AX		;   RecPos += cRecResult;
 16058                                  	;adc	word [bp-5],0
 16059 000023A7 8356FB00                	ADC	RecPosH,0
 16060                                  
 16061                                  ; If we have not gotten the expected number of records, we signal an EOF
 16062                                  ; condition. On input, this is EOF. On output this is usually disk full.
 16063                                  ; BUT... Under 2.0 and before, all device output IGNORED this condition. So
 16064                                  ; do we.
 16065                                  
 16066                                  	;cmp	ax,[bp-3]
 16067 000023AB 3B46FD                  	CMP	AX,cRec 		;   if (cRecRes <> cRec)
 16068 000023AE 7411                    	JZ	short TryBlank
 16069                                  	;test	byte [bp-20],4
 16070 000023B0 F646EC04                	TEST	FCBOp,FCBREAD		;	if (OP&FCBRead || !DEVICE)
 16071 000023B4 7507                    	JNZ	short SetEOF
 16072                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16073                                  	; MSDOS 3.3
 16074                                  	;;test	word [es:di+5],80h
 16075                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 16076                                  	;JNZ	short TryBlank
 16077                                  	; MSDOS 5.0 & MSDOS 6.0
 16078                                  	;test	byte [es:di+5],80h
 16079 000023B6 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 16080 000023BB 7504                    	jnz	short TryBlank
 16081                                  
 16082                                  SetEOF:
 16083                                  	;mov	byte [bp-1],1
 16084 000023BD C646FF01                	MOV	FCBErr,FEOF		;	FCBErr = FEOF;
 16085                                  TryBlank:				;
 16086 000023C1 09D2                    	OR	DX,DX			;   if (cResult%RecSize <> 0) {
 16087 000023C3 7426                    	JZ	short SetExt
 16088                                  	;add	word [bp-7],1
 16089 000023C5 8346F901                	ADD	RecPosL,1		;	RecPos++;
 16090                                  	;adc	word [bp-5],0
 16091 000023C9 8356FB00                	ADC	RecPosH,0
 16092                                  	;test	byte [bp-20],4
 16093 000023CD F646EC04                	TEST	FCBOp,FCBREAD		;	if(OP&FCBRead) <> 0) {
 16094 000023D1 7418                    	JZ	short SetExt
 16095                                  	;inc	word [bp-19]
 16096 000023D3 FF46ED                  	INC	cRecRes 		;	cRecRes++;
 16097                                  	;mov	byte [bp-1],3
 16098 000023D6 C646FF03                	MOV	FCBErr,FTRIM+FEOF	;	FCBErr = FTRIM | FEOF;
 16099                                  	;mov	cx,[bp-9]
 16100 000023DA 8B4EF7                  	MOV	CX,RecSize		;	Blank (RecSize-cResult%RecSize,
 16101 000023DD 29D1                    	SUB	CX,DX			;	       DMA+cResult);
 16102 000023DF 30C0                    	XOR	AL,AL
 16103                                  ;hkn; 	SS override
 16104 000023E1 36C43E[2C03]            	les     di,[ss:DMAADD]
 16105                                  	;add	di,[bp-17]
 16106 000023E6 037EEF                  	ADD	DI,cResult
 16107 000023E9 F3AA                    	REP	STOSB			;   }	}
 16108                                  SetExt:
 16109                                  	;mov	dx,[bp-5]
 16110 000023EB 8B56FB                  	MOV	DX,RecPosH
 16111                                  	;mov	ax,[bp-7]
 16112 000023EE 8B46F9                  	MOV	AX,RecPosL
 16113                                  	;test	byte [bp-20],2
 16114 000023F1 F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&Random) == 0 ||
 16115 000023F5 7406                    	JZ	short DoSetExt
 16116                                  	;test	byte [bp-20],8
 16117 000023F7 F646EC08                	TEST	FCBOp,BLOCK		;	(OP&BLOCK) <> 0)
 16118 000023FB 7403                    	JZ	short TrySetRR
 16119                                  DoSetExt:
 16120 000023FD E85BFE                  	call	SetExtent		;	SetExtent (RecPos, FCB);
 16121                                  TrySetRR:
 16122                                  	;test	byte [bp-20],8
 16123 00002400 F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 16124 00002404 740F                    	JZ	short TryReturn
 16125                                  	;mov	[si+21h],ax
 16126 00002406 894421                  	MOV	[SI+SYS_FCB.RR],AX	;	FCB->RR = RecPos;
 16127                                  	;mov	[si+23h],dl
 16128 00002409 885423                  	MOV	[SI+SYS_FCB.RR+2],DL
 16129                                  	;cmp	word [si+0Eh],64
 16130 0000240C 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 16131 00002410 7303                    	JAE	short TryReturn
 16132                                  	;mov	[si+24h],dh
 16133 00002412 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 16134                                  TryReturn: 
 16135                                  	;test	byte [bp-20],4
 16136 00002415 F646EC04                	TEST	FCBOp,FCBREAD		;   if (!(FCBOP & FCBREAD)) {
 16137 00002419 750B                    	JNZ	short FCBSave
 16138 0000241B 1E                      	push	ds			;	FCB->FDate = date;
 16139 0000241C E84DE7                  	call	DATE16			;	FCB->FTime = time;
 16140 0000241F 1F                      	pop	ds
 16141                                  	;mov	[si+14h],ax
 16142 00002420 894414                  	MOV	[SI+SYS_FCB.FDATE],AX
 16143                                  	;mov	[si+16h],dx
 16144 00002423 895416                  	MOV	[SI+SYS_FCB.FTIME],DX	;	}
 16145                                  FCBSave: 
 16146                                  	;test	byte [bp-20],8
 16147 00002426 F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 16148 0000242A 7409                    	jz	short DoReturn
 16149                                  	;mov	cx,[bp-19]
 16150 0000242C 8B4EED                  	MOV	CX,cRecRes		;	user_CX = cRecRes;
 16151 0000242F E845E0                  	call    Get_User_Stack
 16152                                  	;mov	[si+4],cx
 16153 00002432 894C04                  	MOV	[SI+user_env.user_CX],CX
 16154                                  DoReturn:
 16155                                  	;mov	al,[bp-1]
 16156 00002435 8A46FF                  	MOV	AL,FCBErr		;   return (FCBERR);
 16157                                  	;Leave	
 16158 00002438 89EC                    	mov     sp,bp
 16159 0000243A 5D                      	pop     bp
 16160 0000243B C3                      	retn
 16161                                  
 16162                                  ; 22/07/2018 - Retro DOS v3.0
 16163                                  
 16164                                  ;Break <$FCB_Open - open an old-style FCB>
 16165                                  ;---------------------------------------------------------------------------
 16166                                  ;
 16167                                  ;   $FCB_Open - CPM compatability file open. The user has formatted an FCB
 16168                                  ;	for us and asked to have the rest filled in.
 16169                                  ;
 16170                                  ;   Inputs:	DS:DX point to an unopenned FCB
 16171                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 16172                                  ;		FCB has the following fields filled in:
 16173                                  ;		    Time/Date Extent/NR Size
 16174                                  ;---------------------------------------------------------------------------
 16175                                  
 16176                                  	; 23/01/2024 - Retro DOS v5.0
 16177                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6362h
 16178                                  
 16179                                  _$FCB_OPEN:			; System call 15
 16180                                  	
 16181                                  	;mov	ax,2 
 16182 0000243C B80200                  	MOV	AX,SHARING_COMPAT+open_for_both
 16183                                  
 16184                                  ;hkn; DOS_Open is in DOSCODE
 16185 0000243F B9[2032]                	MOV	CX,DOS_OPEN
 16186                                  
 16187                                  ; The following is common code for Creation and openning of FCBs. AX is
 16188                                  ; either attributes (for create) or open mode (for open)... DS:DX points to
 16189                                  ; the FCB
 16190                                  
 16191                                  DoAccess:
 16192 00002442 1E                      	push	ds
 16193 00002443 52                      	push	dx
 16194 00002444 51                      	push	cx
 16195 00002445 50                      	push	ax			; save FCB pointer away
 16196                                  
 16197                                  ;hkn; 	OpenBuf is in DOSDATA
 16198 00002446 BF[BE03]                	MOV	DI,OPENBUF
 16199 00002449 E8AE50                  	call	TransFCB		; crunch the fcb
 16200 0000244C 58                      	pop	ax
 16201 0000244D 59                      	pop	cx
 16202 0000244E 5A                      	pop	dx
 16203 0000244F 1F                      	pop	ds			; get fcb
 16204 00002450 7303                    	JNC	short FindFCB		; everything seems ok
 16205                                  FCBOpenErr:
 16206                                  	; AL has error code
 16207 00002452 E93AE2                  	jmp	FCB_RET_ERR
 16208                                  FindFCB:
 16209 00002455 E81DFE                  	call	GetExtended		; DS:SI will point to FCB
 16210                                  
 16211                                  	; 17/05/2019 - Retro DOS v4.0
 16212                                  
 16213                                  	; MSDOS 3.3
 16214                                  	;call	LRUFCB
 16215                                  	;jc	short HardMessage
 16216                                  
 16217                                  	; MSDOS 6.0
 16218 00002458 50                      	push	ax
 16219 00002459 B001                    	mov	al,1			;indicate Open/Create operation
 16220 0000245B E8F4FA                  	call	LRUFCB			; get a sft entry (no error)
 16221 0000245E 58                      	pop	ax
 16222 0000245F 722A                    	jc	short HardMessage
 16223                                  	
 16224                                  	;mov	word [es:di+2],8000h
 16225 00002461 26C745020080            	mov	word [es:di+SF_ENTRY.sf_mode],sf_isFCB
 16226 00002467 1E                      	push	ds
 16227 00002468 56                      	push	si	
 16228 00002469 53                      	push	bx			; save fcb pointer
 16229 0000246A 89CE                    	MOV	SI,CX
 16230                                  
 16231                                  ;hkn; SS is DOSDATA
 16232 0000246C 16                      	push	ss
 16233 0000246D 1F                      	pop	ds			    ; let DOS_Open see variables
 16234 0000246E FFD6                    	CALL	SI ; DOS_OPEN or DOS_CREATE ; go open the file
 16235 00002470 5B                      	pop	bx
 16236 00002471 5E                      	pop	si
 16237 00002472 1F                      	pop	ds			; get fcb
 16238                                  
 16239                                  ;hkn; SS override
 16240 00002473 36C43E[9E05]            	LES	DI,[SS:THISSFT]		; get sf pointer
 16241 00002478 7318                    	JNC	short FCBOK		; operation succeeded
 16242                                  failopen:
 16243 0000247A 50                      	PUSH	AX
 16244 0000247B B052                    	MOV	AL,"R"	; 52h		; clear out field (free sft)
 16245 0000247D E8C2FC                  	call	BlastSFT
 16246 00002480 58                      	POP	AX
 16247                                  	;cmp	ax,4
 16248 00002481 83F804                  	CMP	AX,error_too_many_open_files
 16249 00002484 7405                    	JZ	short HardMessage
 16250                                  	;cmp	ax,24h
 16251 00002486 83F824                  	CMP	AX,error_sharing_buffer_exceeded
 16252 00002489 7505                    	jnz	short DeadFCB
 16253                                  HardMessage:
 16254 0000248B 50                      	PUSH	AX
 16255 0000248C E86FFD                  	call	FCBHardErr
 16256 0000248F 58                      	POP	AX
 16257                                  DeadFCB:
 16258                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16259                                  	;jmp	FCB_RET_ERR
 16260 00002490 EBC0                    	jmp	short FCBOpenErr
 16261                                  FCBOK:
 16262                                  	; MSDOS 6.0
 16263 00002492 E8C5F3                  	call	IsSFTNet		;AN007;F.C. >32mb  Non Fat file?
 16264 00002495 7531                    	JNZ	short FCBOK2		;AN007;F.C. >32mb  yes
 16265 00002497 E88C58                  	call	CheckShare		;AN000;F.C. >32mb  share around?
 16266                                  	;JNZ	short FCBOK2		;AN000;F.C. >32mb  yes
 16267                                  	; 23/01/2024 - Retro DOS v5.0
 16268                                  	; (PCDOS 7.1 IBMDOS.COM)
 16269 0000249A 750A                    	jnz	short FCBOK1
 16270                                  
 16271                                  ;SR;
 16272                                  ; If we reach here, we know we have got a local SFT. Let's update the 
 16273                                  ; LocalSFT variable to reflect this.
 16274                                  
 16275 0000249C 36893E[A710]            	mov	[ss:LocalSFT],di
 16276 000024A1 368C06[A910]            	mov	[ss:LocalSFT+2],es; Store the SFT address
 16277                                  ;;SR;
 16278                                  ;; The check below is not valid anymore since we regenerate for media > 32M.
 16279                                  ;;
 16280                                  ;;	CMP	WORD [ES:DI+SF_ENTRY.sf_dirsec+2],0 
 16281                                  ;;					       ;AN000;F.C. >32mb  if dirsec >32mb
 16282                                  ;;	JZ	short FCBOK2		       ;AN000;F.C. >32mb    then error
 16283                                  ;;	MOV	AX,error_sys_comp_not_loaded   ;AN000;F.C. >32mb
 16284                                  ;;	JMP	short failopen		       ;AN000;F.C. >32mb
 16285                                  
 16286                                  	; 23/01/2024 - Retro DOS v5.0
 16287                                  	; (PCDOS 7.1 IBMDOS.COM)
 16288                                  	;;;
 16289                                  FCBOK1:
 16290                                  	;test	byte [es:di+5],80h
 16291 000024A6 26F6450580              	test	byte [es:di+SF_ENTRY.sf_flags],devid_device
 16292 000024AB 751B                    	jnz	short FCBOK2	; local device
 16293                                  	;test	byte [es:di+4],8
 16294 000024AD 26F6450408              	test	byte [es:di+SF_ENTRY.sf_attr],attr_volume_id
 16295 000024B2 7514                    	jnz	short FCBOK2
 16296                                  		; local file
 16297 000024B4 06                      	push	es
 16298 000024B5 57                      	push	di
 16299                                  	;les	di,[es:di+0Fh]
 16300 000024B6 26C47D07                	les	di,[es:di+SF_ENTRY.sf_devptr] ; local file's DPB
 16301                                  	;cmp	word [es:di+0Fh],0
 16302 000024BA 26837D0F00              	cmp	word [es:di+DPB.FAT_SIZE],0 ; (16 bit FAT size)	
 16303 000024BF 5F                      	pop	di
 16304 000024C0 07                      	pop	es
 16305 000024C1 7505                    	jnz	short FCBOK2	; not FAT32 (ok)
 16306                                  	;mov	ax,0Fh		; error_invalid_drive (for FAT32)
 16307 000024C3 B80F00                  	mov	ax,error_invalid_drive
 16308 000024C6 EBB2                    	jmp	short failopen
 16309                                  	;;; 
 16310                                  
 16311                                  FCBOK2:
 16312                                  	; MSDOS 6.0 (& MSDOS 3.3)
 16313 000024C8 26FF05                  	inc	word [es:di]
 16314                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count] ; increment reference count
 16315                                  
 16316                                  	; 23/01/2024 - Retro DOS v5.0
 16317                                  	; (PCDOS 7.1 IBMDOS.COM)
 16318                                  	;;;
 16319 000024CB E8B123                  	call	set_sftfcb_entry
 16320                                  	;;;
 16321                                  
 16322 000024CE E8B3F9                  	call	SaveFCBInfo
 16323                                  
 16324                                  	; MSDOS 3.3
 16325                                  	;call	SetOpenAge
 16326                                  	; MSDOS 6.0 (& MSDOS 3.3)
 16327                                  	;test	word [es:di+5],80h
 16328                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 16329 000024D1 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device  ; 28/07/2019
 16330 000024D6 7508                    	JNZ	short FCBNoDrive	; do not munge drive on devices
 16331                                  
 16332 000024D8 8A04                    	MOV	AL,[SI]			; get drive byte
 16333 000024DA E8A84F                  	call	GETTHISDRV		; convert
 16334                                  	;INC	AL
 16335                                  	; 17/12/2022
 16336 000024DD 40                      	inc	ax
 16337 000024DE 8804                    	MOV	[SI],AL			; stash in good drive letter
 16338                                  
 16339                                  FCBNoDrive:
 16340                                  	;mov	word [si+0Eh],128
 16341 000024E0 C7440E8000              	MOV	word [SI+SYS_FCB.RECSIZ],80h ; stuff in default record size
 16342                                  
 16343                                  	; 23/01/2024 - Retro DOS v5.0
 16344                                  	; (PCDOS 7.1 IBMDOS.COM)
 16345                                  	;;;
 16346                                  	;;mov	ax,[es:di+0Dh]
 16347                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_time] ; set time
 16348                                  	;;mov	[si+16h],ax
 16349                                  	;MOV	[SI+SYS_FCB.FTIME],AX
 16350                                  	;;mov	ax,[es:di+0Fh]
 16351                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_date] ; set date
 16352                                  	;;mov	[si+14h],ax
 16353                                  	;MOV	[SI+SYS_FCB.FDATE],AX
 16354                                  	;;mov	ax,[es:di+11h]
 16355                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_size] ; set sizes
 16356                                  	;;mov	[si+10h],ax
 16357                                  	;MOV	[SI+SYS_FCB.FILSIZ],AX
 16358                                  	;;mov	ax,[es:di+13h]
 16359                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 16360                                  	;;mov	[si+12h],ax
 16361                                  	;MOV	[SI+SYS_FCB.FILSIZ+2],AX
 16362                                  	;
 16363 000024E5 06                      	push	es
 16364                                  	;les	ax,[es:di+0Dh]
 16365 000024E6 26C4450D                	les	ax,[es:di+SF_ENTRY.sf_time]
 16366                                  	;mov	[si+16h],ax
 16367 000024EA 894416                  	mov	[si+SYS_FCB.FTIME],ax	; set time
 16368                                  	;mov	[si+14h],es
 16369 000024ED 8C4414                  	mov	[si+SYS_FCB.FDATE],es	; set date
 16370 000024F0 07                      	pop	es
 16371 000024F1 06                      	push	es
 16372                                  	;les	ax,[es:di+11h]
 16373 000024F2 26C44511                	les	ax,[es:di+SF_ENTRY.sf_size] ; set size
 16374                                  	;mov	[si+10h],ax
 16375 000024F6 894410                  	mov	[si+SYS_FCB.FILSIZ],ax
 16376                                  	;mov	[si+12h],ax
 16377 000024F9 8C4412                  	mov	[si+SYS_FCB.FILSIZ+2],es
 16378 000024FC 07                      	pop	es
 16379                                  	;;;
 16380                                  	
 16381 000024FD 31C0                    	XOR	AX,AX			; convenient zero
 16382                                  	;mov	[si+0Ch],ax
 16383 000024FF 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; point to beginning of file
 16384                                  
 16385                                  ; We must scan the set of FCB SFTs for one that appears to match the current
 16386                                  ; one.	We cheat and use CheckFCB to match the FCBs.
 16387                                  
 16388                                  ;hkn; 	SS override
 16389 00002502 36C43E[4000]            	LES	DI,[SS:SFTFCB]		; get the pointer to head of the list
 16390                                  	;mov	ah,[es:di+4]
 16391 00002507 268A6504                	MOV	AH,[ES:DI+SFT.SFCount]	; get number of SFTs to scan
 16392                                  OpenScan:
 16393                                  	;cmp	al,[si+18h]
 16394 0000250B 3A4418                  	CMP	AL,[SI+fcb_sfn]		; don't compare ourselves
 16395 0000250E 7407                    	JZ	short SkipCheck
 16396 00002510 50                      	push	ax			; preserve count
 16397 00002511 E847FC                  	call	CheckFCB		; do they match
 16398 00002514 58                      	pop	ax			; get count back
 16399 00002515 7309                    	JNC	short OpenFound		; found a match!
 16400                                  SkipCheck:
 16401 00002517 FEC0                    	INC	AL			; advance to next FCB
 16402 00002519 38E0                    	CMP	AL,AH			; table full?
 16403 0000251B 75EE                    	JNZ	short OpenScan		; no, go for more
 16404                                  OpenDone:
 16405 0000251D 30C0                    	xor	al,al			; return success
 16406 0000251F C3                      	retn
 16407                                  
 16408                                  ; The SFT at ES:DI is the one that is already in use for this FCB. We set the
 16409                                  ; FCB to use this one. We increment its ref count. We do NOT close it at all.
 16410                                  ; Consider:
 16411                                  ;
 16412                                  ;   open (foo)	delete (foo) open (bar)
 16413                                  ;
 16414                                  ; This causes us to recycle (potentially) bar through the same local SFT as
 16415                                  ; foo even though foo is no longer needed; this is due to the server closing
 16416                                  ; foo for us when we delete it. Unfortunately, we cannot see this closure.
 16417                                  ; If we were to CLOSE bar, the server would then close the only reference to
 16418                                  ; bar and subsequent I/O would be lost to the redirector.
 16419                                  ;
 16420                                  ; This gets solved by NOT closing the sft, but zeroing the ref count
 16421                                  ; (effectively freeing the SFT) and informing the sharer (if relevant) that
 16422                                  ; the SFT is no longer in use. Note that the SHARER MUST keep its ref counts
 16423                                  ; around. This will allow us to access the same file through multiple network
 16424                                  ; connections and NOT prematurely terminate when the ref count on one
 16425                                  ; connection goes to zero.
 16426                                  
 16427                                  OpenFound:
 16428                                  	;mov	[si+18h],al
 16429 00002520 884418                  	MOV	[SI+fcb_sfn],AL 	; assign with this
 16430 00002523 26FF05                  	inc	word [es:di]
 16431                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 16432                                  					; remember this new invocation
 16433                                  	; 23/01/2024 - Retro DOS v5.0
 16434                                  	; (PCDOS 7.1 IBMDOS.COM)
 16435                                  	;;;
 16436 00002526 E85623                  	call	set_sftfcb_entry
 16437                                  	;;;
 16438                                  
 16439                                  	; 24/01/2024
 16440 00002529 16                      	push	ss
 16441 0000252A 1F                      	pop	ds
 16442                                  	
 16443                                  	;MOV	AX,[SS:FCBLRU]		; update LRU counts
 16444 0000252B A1[1000]                	mov	ax,[FCBLRU] ; 24/01/2024
 16445                                  	;mov	[es:di+15h],ax
 16446 0000252E 26894515                	MOV	[ES:DI+sf_LRU],AX
 16447                                  ;
 16448                                  ; We have an FCB sft that is now of no use. We release sharing info and then
 16449                                  ; blast it to prevent other reuse.
 16450                                  ;
 16451                                  	;push	ss
 16452                                  	;pop	ds
 16453                                  	
 16454 00002532 C43E[9E05]              	LES	DI,[THISSFT]
 16455 00002536 26FF0D                  	dec	word [es:di]
 16456                                  	;DEC	word [ES:DI+SF_ENTRY.sf_ref_count]
 16457                                  					; free the newly allocated SFT
 16458 00002539 E82258                  	call	ShareEnd
 16459 0000253C B043                    	MOV	AL,'C'	 ; 43h
 16460 0000253E E801FC                  	call	BlastSFT
 16461 00002541 EBDA                    	JMP	short OpenDone
 16462                                  
 16463                                  ;BREAK	<$FCB_Create - create a new directory entry>
 16464                                  ;----------------------------------------------------------------------------
 16465                                  ;
 16466                                  ;   $FCB_Create - CPM compatability file create. The user has formatted an
 16467                                  ;	FCB for us and asked to have the rest filled in.
 16468                                  ;
 16469                                  ;   Inputs:	DS:DX point to an unopenned FCB
 16470                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 16471                                  ;		FCB has the following fields filled in:
 16472                                  ;		    Time/Date Extent/NR Size
 16473                                  ;----------------------------------------------------------------------------
 16474                                  
 16475                                  _$FCB_CREATE:		; System call 22
 16476                                  
 16477                                  ;hkn; DOS_Create is in DOSCODE
 16478 00002543 B9[EF30]                	MOV	CX,DOS_CREATE		; routine to call
 16479 00002546 31C0                    	XOR	AX,AX			; attributes to create
 16480 00002548 E82AFD                  	call	GetExtended		; get extended FCB
 16481 0000254B 7403                    	JZ	short DoAccessJ		; not an extended FCB
 16482 0000254D 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 16483                                  DoAccessJ:
 16484 00002550 E9EFFE                  	JMP	DoAccess		; do dirty work
 16485                                  
 16486                                  ;============================================================================
 16487                                  ; SEARCH.ASM, MSDOS 6.0, 1991
 16488                                  ;============================================================================
 16489                                  ; 22/07/2018 - Retro DOS v3.0
 16490                                  ; 17/05/2019 - Retro DOS v4.0
 16491                                  
 16492                                  ; DOSCODE:5DDFh (MSDOS 6.21, MSDOS.SYS)
 16493                                  
 16494                                  ; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16495                                  ; DOSCODE:5DCBh (MSDOS 5.0, MSDOS.SYS)
 16496                                  
 16497                                  ;**	Search.asm
 16498                                  ;----------------------------------------------------------------------------
 16499                                  ;	Directory search system calls.
 16500                                  ;	These will be passed direct text of the pathname from the user. 
 16501                                  ;	They will need to be passed through the macro expander prior to
 16502                                  ;	being sent through the low-level stuff. 
 16503                                  ;	I/O specs are defined in DISPATCH. The system calls are:
 16504                                  ;
 16505                                  ;	$Dir_Search_First	  written
 16506                                  ;	$Dir_Search_Next	  written
 16507                                  ;	$Find_First	  written
 16508                                  ;	$Find_Next		  written
 16509                                  ;	PackName		  written
 16510                                  ;
 16511                                  ;	Modification history:
 16512                                  ;
 16513                                  ;	  Created: ARR 4 April 1983
 16514                                  
 16515                                  ;----------------------------------------------------------------------------
 16516                                  ; Procedure Name : $DIR_SEARCH_FIRST
 16517                                  ;
 16518                                  ; Inputs:
 16519                                  ;	DS:DX Points to unopenned FCB
 16520                                  ; Function:
 16521                                  ;	Directory is searched for first matching entry and the directory
 16522                                  ;	entry is loaded at the disk transfer address
 16523                                  ; Returns:
 16524                                  ;	AL = -1 if no entries matched, otherwise 0
 16525                                  ;----------------------------------------------------------------------------
 16526                                  
 16527                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 2B88h
 16528                                  	
 16529                                  	; 24/01/2024
 16530                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:5DCBh
 16531                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:5DDFh
 16532                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:647Bh
 16533                                  	; Windows ME IO.SYS - BIOSCODE:61E5h
 16534                                  
 16535                                  _$DIR_SEARCH_FIRST:
 16536 00002553 368916[A605]            	MOV	[SS:THISFCB],DX
 16537 00002558 368C1E[A805]            	MOV	[SS:THISFCB+2],DS
 16538 0000255D 89D6                    	MOV	SI,DX
 16539 0000255F 803CFF                  	CMP	BYTE [SI],0FFH
 16540 00002562 7503                    	JNZ	short NORMFCB4
 16541 00002564 83C607                  	ADD	SI,7			; Point to drive select byte
 16542                                  NORMFCB4:
 16543 00002567 FF34                    	push	word [SI]		; Save original drive byte for later
 16544                                  
 16545 00002569 16                      	push	ss
 16546 0000256A 07                      	pop	es			; get es to address DOSGroup
 16547                                  
 16548 0000256B BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 16549 0000256E E8894F                  	call	TransFCB		; convert the FCB, set SATTRIB EXTFCB
 16550 00002571 7304                    	JNC	short SearchIt		; no error, go and look
 16551 00002573 5B                      	pop	bx			; Clean stack
 16552                                  
 16553                                  ; Error code is in AX
 16554                                  
 16555                                  	; 09/11/2022
 16556                                  dcf_errj:
 16557 00002574 E918E1                  	jmp	FCB_RET_ERR		; error
 16558                                  
 16559                                  SearchIt:
 16560 00002577 16                      	push	ss
 16561 00002578 1F                      	pop	ds			; get ready for search
 16562                                  	;push	word [DMAADD]
 16563                                  	;push	word [DMAADD+2]
 16564                                  	; 24/01/2024
 16565 00002579 C43E[2C03]              	les	di,[DMAADD]
 16566 0000257D 57                      	push	di
 16567 0000257E 06                      	push	es
 16568 0000257F C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 16569 00002585 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 16570                                  	; MSDOS 3.3
 16571                                  	;call	DOS_SEARCH_FIRST
 16572                                  	; MSDOS 6.0
 16573 00002589 E8B70F                  	call	GET_FAST_SEARCH		; search
 16574 0000258C 8F06[2E03]              	pop	word [DMAADD+2]
 16575 00002590 8F06[2C03]              	pop	word [DMAADD]
 16576 00002594 735A                    	JNC	short SearchSet		; no error, transfer info
 16577 00002596 5B                      	pop	bx			; Clean stack
 16578                                  
 16579                                  ; Error code is in AX
 16580                                  
 16581                                  	; 09/11/2022
 16582                                  	;jmp	FCB_RET_ERR
 16583 00002597 EBDB                    	jmp	short dcf_errj
 16584                                  
 16585                                  ;----------------------------------------------------------------------------
 16586                                  ;
 16587                                  ; Procedure Name : $DIR_SEARCH_NEXT
 16588                                  ;
 16589                                  ; Inputs:
 16590                                  ;	DS:DX points to unopenned FCB returned by $DIR_SEARCH_FIRST
 16591                                  ; Function:
 16592                                  ;	Directory is searched for the next matching entry and the directory
 16593                                  ;	entry is loaded at the disk transfer address
 16594                                  ; Returns:
 16595                                  ;	AL = -1 if no entries matched, otherwise 0
 16596                                  ;----------------------------------------------------------------------------
 16597                                  
 16598                                  	; 24/01/2024
 16599                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:5E5Fh
 16600                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:5E73h
 16601                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6517h
 16602                                  	; Windows ME IO.SYS - BIOSCODE:6273h
 16603                                  
 16604                                  _$DIR_SEARCH_NEXT:
 16605 00002599 368916[A605]            	MOV	[SS:THISFCB],DX
 16606 0000259E 368C1E[A805]            	MOV	[SS:THISFCB+2],DS
 16607                                  	; 24/01/2024 (PCDOS 7.1)
 16608                                  	;MOV	byte [SS:SATTRIB],0
 16609                                  	;MOV	byte [SS:EXTFCB],0
 16610 000025A3 B000                    	mov	al,0
 16611 000025A5 36A2[6D05]              	mov	[SS:SATTRIB],al ; 0
 16612 000025A9 36A2[6D05]              	mov	[SS:SATTRIB],al ; 0
 16613                                  
 16614 000025AD 16                      	push	ss
 16615 000025AE 07                      	pop	es
 16616                                  
 16617 000025AF BF[BE04]                	MOV	DI,SEARCHBUF
 16618                                  
 16619 000025B2 89D6                    	MOV	SI,DX
 16620 000025B4 803CFF                  	CMP	BYTE [SI],0FFh
 16621 000025B7 750D                    	JNZ	short NORMFCB6
 16622 000025B9 83C606                  	ADD	SI,6
 16623 000025BC AC                      	LODSB
 16624                                  
 16625 000025BD 36A2[6D05]              	MOV	[SS:SATTRIB],AL
 16626 000025C1 36FE0E[6C05]            	DEC	byte [SS:EXTFCB]
 16627                                  NORMFCB6:
 16628 000025C6 AC                      	LODSB				; Get original user drive byte
 16629 000025C7 50                      	push	ax			; Put it on stack
 16630 000025C8 8A4414                  	MOV	AL,[SI+20]		; Get correct search contin drive byte
 16631 000025CB AA                      	STOSB				; Put in correct place
 16632 000025CC B90A00                  	MOV	CX,20/2
 16633 000025CF F3A5                    	REP	MOVSW			; Transfer in rest of search contin info
 16634                                  
 16635 000025D1 16                      	push	ss
 16636 000025D2 1F                      	pop	ds
 16637                                  
 16638                                  	;push	word [DMAADD]
 16639                                  	;push	word [DMAADD+2]
 16640                                  	; 24/01/2024
 16641 000025D3 C43E[2C03]              	les	di,[DMAADD]
 16642 000025D7 57                      	push	di
 16643 000025D8 06                      	push	es
 16644 000025D9 C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 16645 000025DF 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 16646 000025E3 E85D10                  	call	DOS_SEARCH_NEXT 	; Find it
 16647 000025E6 8F06[2E03]              	pop	word [DMAADD+2]
 16648 000025EA 8F06[2C03]              	pop	word [DMAADD]
 16649 000025EE 724A                    	JC	short SearchNoMore
 16650                                  	; 24/01/2024
 16651                                  	;JMP	SearchSet		; Ok set return
 16652                                  
 16653                                  ;;;	; 24/01/2024 - Retro DOS v5.0
 16654                                  
 16655                                  ; The search was successful (or the search-next). We store the information
 16656                                  ; into the user's FCB for continuation.
 16657                                  
 16658                                  SearchSet:
 16659 000025F0 BE[BE04]                	MOV	SI,SEARCHBUF
 16660 000025F3 C43E[A605]              	LES	DI,[THISFCB]		; point to the FCB
 16661 000025F7 F606[6C05]FF            	TEST	byte [EXTFCB],0FFh
 16662 000025FC 7403                    	JZ	short NORMFCB1
 16663 000025FE 83C707                  	ADD	DI,7			; Point past the extension
 16664                                  NORMFCB1:
 16665 00002601 5B                      	pop	bx			; Get original drive byte
 16666 00002602 08DB                    	OR	BL,BL
 16667 00002604 7506                    	JNZ	short SearchDrv
 16668 00002606 8A1E[3603]              	MOV	BL,[CURDRV]
 16669 0000260A FEC3                    	INC	BL
 16670                                  SearchDrv:
 16671 0000260C AC                      	LODSB				; Get correct search contin drive byte
 16672 0000260D 86C3                    	XCHG	AL,BL			; Search byte to BL, user byte to AL
 16673 0000260F 47                      	INC	DI
 16674                                  	;STOSB				; Store the correct "user" drive byte
 16675                                  					;  at the start of the search info
 16676 00002610 B90A00                  	MOV	CX,20/2
 16677 00002613 F3A5                    	REP	MOVSW			; Rest of search cont info, SI -> entry
 16678 00002615 86C3                    	XCHG	AL,BL			; User drive byte back to BL, search
 16679                                  					;   byte to AL
 16680 00002617 AA                      	STOSB				; Search contin drive byte at end of
 16681                                  					;   contin info
 16682 00002618 C43E[2C03]              	LES	DI,[DMAADD]
 16683 0000261C F606[6C05]FF            	TEST	byte [EXTFCB],0FFh
 16684 00002621 740D                    	JZ	short NORMFCB2
 16685 00002623 B0FF                    	MOV	AL,0FFh
 16686 00002625 AA                      	STOSB
 16687 00002626 FEC0                    	INC	AL
 16688                                  	;MOV	CX,5
 16689                                  	; 17/12/2022
 16690 00002628 B105                    	mov	cl,5
 16691 0000262A F3AA                    	REP	STOSB
 16692 0000262C A0[6D05]                	MOV	AL,[SATTRIB]
 16693 0000262F AA                      	STOSB
 16694                                  NORMFCB2:
 16695 00002630 88D8                    	MOV	AL,BL			; User Drive byte
 16696 00002632 AA                      	STOSB
 16697                                  	;MOV	CX,16			; 32 / 2 words of dir entry
 16698                                  	; 17/12/2022
 16699 00002633 B110                    	mov	cl,16
 16700 00002635 F3A5                    	REP	MOVSW
 16701 00002637 E952E0                  	jmp	FCB_RET_OK
 16702                                  ;;;
 16703                                  
 16704                                  SearchNoMore:
 16705 0000263A C43E[A605]              	LES	DI,[THISFCB]
 16706 0000263E F606[6C05]FF            	TEST	byte [EXTFCB],0FFh
 16707 00002643 7403                    	JZ	short NORMFCB8
 16708 00002645 83C707                  	ADD	DI,7			; Point past the extension
 16709                                  NORMFCB8:
 16710 00002648 5B                      	pop	bx			; Get original drive byte
 16711 00002649 26881D                  	MOV	[ES:DI],BL		; Store the correct "user" drive byte
 16712                                  					;  at the right spot
 16713                                  ; error code is in AX
 16714                                  
 16715 0000264C E940E0                  	jmp	FCB_RET_ERR
 16716                                  
 16717                                  ; 17/05/2019 - Retro DOS v4.0
 16718                                  
 16719                                  ; DOSCODE:5EE6h (MSDOS 6.21, MSDOS.SYS)
 16720                                  
 16721                                  ;---------------------------------------------------------------------------
 16722                                  ;
 16723                                  ;   Procedure Name : $FIND_FIRST
 16724                                  ; 
 16725                                  ;   Assembler usage:
 16726                                  ;	    MOV AH, FindFirst
 16727                                  ;	    LDS DX, name
 16728                                  ;	    MOV CX, attr
 16729                                  ;	    INT 21h
 16730                                  ;	; DMA address has datablock
 16731                                  ;
 16732                                  ;   Error Returns:
 16733                                  ;	    AX = error_path_not_found
 16734                                  ;	       = error_no_more_files
 16735                                  ;---------------------------------------------------------------------------
 16736                                  
 16737                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16738                                  	; DOSCODE:5ED2h (MSDOS 5.0, MSDOS.SYS)
 16739                                  
 16740                                  	; 24/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 16741                                  	; DOSCODE:6594h (PCDOS 7.1, IBMDOS.COM)
 16742                                  
 16743                                  _$FIND_FIRST:
 16744 0000264F 89D6                    	MOV	SI,DX			; get name in appropriate place
 16745 00002651 36880E[6D05]            	MOV	[SS:SATTRIB],CL		; Search attribute to correct loc
 16746                                  
 16747 00002656 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 16748                                  
 16749 00002659 E8044F                  	call	TransPathSet		; convert the path
 16750 0000265C 7305                    	JNC	short Find_it 		; no error, go and look
 16751                                  FindError:
 16752                                  	;mov	al,3
 16753 0000265E B003                    	mov	al, error_path_not_found ; error and map into one.
 16754                                  	; 09/11/2022
 16755                                  FF_errj:
 16756 00002660 E917E0                  	jmp	SYS_RET_ERR
 16757                                  Find_it:
 16758 00002663 16                      	push	ss
 16759 00002664 1F                      	pop	ds
 16760                                  
 16761                                  	;push	word [DMAADD]
 16762                                  	;push	word [DMAADD+2]
 16763                                  	; 24/01/2024 (PCDOS 7.1 IBMDOS.COM)
 16764 00002665 C43E[2C03]              	les	di,[DMAADD]
 16765 00002669 57                      	push	di
 16766 0000266A 06                      	push	es
 16767                                  	
 16768 0000266B C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 16769 00002671 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 16770                                  	; MSDOS 3.3
 16771                                  	;call	DOS_SEARCH_FIRST
 16772                                  	; MSDOS 6.0
 16773 00002675 E8CB0E                  	call	GET_FAST_SEARCH 	; search
 16774 00002678 8F06[2E03]              	pop	word [DMAADD+2]
 16775 0000267C 8F06[2C03]              	pop	word [DMAADD]
 16776                                  	
 16777                                  	; 16/12/2022
 16778                                  	;JNC	short FindSet 		; no error, transfer info
 16779 00002680 72DE                    	jc	short FF_errj	; jmp SYS_RET_ERR
 16780                                  	;
 16781                                  	;jmp	SYS_RET_ERR
 16782                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16783                                  ;FFF_errj:
 16784                                  	;jmp	short FF_errj	; jmp SYS_RET_ERR
 16785                                  
 16786                                  FindSet:
 16787 00002682 BE[BE04]                	MOV	SI,SEARCHBUF
 16788 00002685 C43E[2C03]              	LES	DI,[DMAADD]
 16789 00002689 B91500                  	MOV	CX,21
 16790 0000268C F3A4                    	REP	MOVSB
 16791 0000268E 56                      	PUSH	SI			; Save pointer to start of entry
 16792                                  	;mov	al,[si+0Bh]
 16793 0000268F 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 16794 00002692 AA                      	STOSB
 16795                                  	;add	si,16h ; 22
 16796 00002693 83C616                  	ADD	SI,dir_entry.dir_time
 16797 00002696 A5                      	MOVSW				; dir_time
 16798 00002697 A5                      	MOVSW				; dir_date
 16799 00002698 46                      	INC	SI
 16800 00002699 46                      	INC	SI			; Skip dir_first
 16801 0000269A A5                      	MOVSW				; dir_size (2 words)
 16802 0000269B A5                      	MOVSW
 16803 0000269C 5E                      	POP	SI			; Point back to dir_name
 16804 0000269D E83300                   	CALL	PackName
 16805 000026A0 E9CDDF                  	jmp	SYS_RET_OK		; bye with no errors
 16806                                  
 16807                                  ;---------------------------------------------------------------------------
 16808                                  ;
 16809                                  ;   Procedure Name : $FIND_NEXT
 16810                                  ;
 16811                                  ;   Assembler usage:
 16812                                  ;	; dma points at area returned by find_first
 16813                                  ;	    MOV AH, findnext
 16814                                  ;	    INT 21h
 16815                                  ;	; next entry is at dma
 16816                                  ;
 16817                                  ;   Error Returns:
 16818                                  ;	    AX = error_no_more_files
 16819                                  ;---------------------------------------------------------------------------
 16820                                  
 16821                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16822                                  
 16823                                  	; 24/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 16824                                  	; DOSCODE:65ECh (PCDOS 7.1, IBMDOS.COM)
 16825                                  
 16826                                  _$FIND_NEXT:
 16827 000026A3 16                      	push	ss
 16828 000026A4 07                      	pop	es
 16829                                  
 16830 000026A5 BF[BE04]                	MOV	DI,SEARCHBUF
 16831                                  
 16832 000026A8 36C536[2C03]            	LDS	SI,[SS:DMAADD]
 16833                                  
 16834 000026AD B91500                  	MOV	CX,21
 16835 000026B0 F3A4                    	REP	MOVSB			; Put the search continuation info
 16836                                  					;  in the right place
 16837 000026B2 16                      	push	ss
 16838 000026B3 1F                      	pop	ds			; get ready for search
 16839                                  	
 16840                                  	; 24/01/2024 (Retro DOS v5-v4)
 16841                                  	;push	word [DMAADD]
 16842                                  	;push	word [DMAADD+2]
 16843 000026B4 C43E[2C03]              	les	di,[DMAADD]
 16844 000026B8 57                      	push	di
 16845 000026B9 06                      	push	es
 16846 000026BA C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 16847 000026C0 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 16848 000026C4 E87C0F                  	call	DOS_SEARCH_NEXT 	; Find it
 16849 000026C7 8F06[2E03]              	pop	word [DMAADD+2]
 16850 000026CB 8F06[2C03]              	pop	word [DMAADD]
 16851 000026CF 73B1                    	JNC	short FindSet 		; No error, set info
 16852                                  	;jmp	SYS_RET_ERR
 16853                                  	; 16/12/2022
 16854 000026D1 EB8D                    	jmp	short FF_errj	; jmp SYS_RET_ERR
 16855                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16856                                  	;jmp	short FFF_errj	; jmp SYS_RET_ERR
 16857                                  
 16858                                  ;---------------------------------------------------------------------------
 16859                                  ;**	PackName - Convert file names from FCB to ASCIZ format.
 16860                                  ;
 16861                                  ;	PackName transfers a file name from DS:SI to ES:DI and converts it to
 16862                                  ;	the ASCIZ format.
 16863                                  ;
 16864                                  ;	ENTRY	(DS:SI) = 11 character FCB or dir entry name
 16865                                  ;		(ES:DI) = destination area (13 bytes)
 16866                                  ;	EXIT	(ds:SI) and (es:DI) advanced
 16867                                  ;	USES	al, CX, SI, DI, Flags  (BUGBUG - not verified - jgl)
 16868                                  ;---------------------------------------------------------------------------
 16869                                  
 16870                                  	; 25/01/2024 - Retro DOS v5.0
 16871                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6627h
 16872                                  
 16873                                  PackName:
 16874                                  ;	Move over 8 characters to cover the name component, then trim it's
 16875                                  ;	trailing blanks.
 16876                                  
 16877                                  	;MOV	CX,8			; Pack the name
 16878                                  	;REP	MOVSB			; Move all of it
 16879                                  	; 25/01/2024
 16880 000026D3 B90400                  	mov	cx,4
 16881 000026D6 F3A5                    	rep	movsw
 16882                                  main_kill_tail:
 16883 000026D8 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 16884 000026DD 7507                    	JNZ	short find_check_dot
 16885 000026DF 4F                      	DEC	DI			; Back up over trailing space
 16886 000026E0 41                      	INC	CX
 16887 000026E1 83F908                  	CMP	CX,8
 16888 000026E4 72F2                    	JB	short main_kill_tail
 16889                                  find_check_dot:
 16890                                  	;CMP	WORD [SI],(" " << 8) | " "
 16891 000026E6 813C2020                	cmp     word [si],2020h 
 16892 000026EA 7506                    	JNZ	short got_ext 		; Some chars in extension
 16893 000026EC 807C0220                	CMP	BYTE [SI+2]," "
 16894 000026F0 740F                    	JZ	short find_done		; No extension
 16895                                  got_ext:
 16896 000026F2 B02E                    	MOV	AL,"."	; 2Eh
 16897 000026F4 AA                      	STOSB
 16898                                  	;MOV	CX,3
 16899                                  	;; 18/12/2022
 16900                                  	;;mov	cl,3
 16901                                  	;;REP	MOVSB
 16902                                  	;movsb
 16903                                  	;movsb
 16904                                  	;movsb
 16905                                  	; 25/01/2024
 16906 000026F5 A5                      	movsw
 16907 000026F6 A4                      	movsb
 16908                                  ext_kill_tail:
 16909 000026F7 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 16910 000026FC 7503                    	JNZ	short find_done
 16911 000026FE 4F                      	DEC	DI			; Back up over trailing space
 16912 000026FF EBF6                    	JMP	short ext_kill_tail
 16913                                  find_done:
 16914 00002701 31C0                    	XOR	AX,AX
 16915 00002703 AA                      	STOSB				; NUL terminate
 16916 00002704 C3                      	retn
 16917                                  
 16918                                  ;---------------------------------------------------------------------------
 16919                                  
 16920                                  ; 24/01/2024
 16921                                  %if 0
 16922                                  	; 17/05/2019 - Retro DOS v4.0
 16923                                  GET_FAST_SEARCH:
 16924                                  	; 22/07/2018
 16925                                  	; MSDOS 6.0
 16926                                  	; 17/12/2022
 16927                                  	OR	byte [ss:DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)  ; 04h
 16928                                  	;OR	word [ss:DOS34_FLAG],SEARCH_FASTOPEN  ; 400h
 16929                                  					;FO.trigger fastopen ;AN000;
 16930                                  	;call	DOS_SEARCH_FIRST
 16931                                  	;retn
 16932                                  	; 17/12/2022
 16933                                  	jmp	DOS_SEARCH_FIRST
 16934                                  %endif
 16935                                  
 16936                                  ;============================================================================
 16937                                  ; PATH.ASM, MSDOS 6.0, 1991
 16938                                  ;============================================================================
 16939                                  ; 06/08/2018 - Retro DOS v3.0
 16940                                  ; 17/05/2019 - Retro DOS v4.0
 16941                                  
 16942                                  ; DOSCODE:5FB0h (MSDOS 6.21, MSDOS.SYS)
 16943                                  
 16944                                  ;**	Directory related system calls. These will be passed direct text of the
 16945                                  ;	pathname from the user. They will need to be passed through the macro
 16946                                  ;	expander prior to being sent through the low-level stuff. I/O specs are
 16947                                  ;	defined in DISPATCH. The system calls are:
 16948                                  ;
 16949                                  ;	$CURRENT_DIR  Written
 16950                                  ;	$RMDIR	  Written
 16951                                  ;	$CHDIR	  Written
 16952                                  ;	$MKDIR	  Written
 16953                                  ;
 16954                                  ;
 16955                                  ;	Modification history:
 16956                                  ;
 16957                                  ;	    Created: ARR 4 April 1983
 16958                                  ;		 MZ 10 May 1983     CurrentDir implemented
 16959                                  ;		 MZ 11 May 1983     RmDir, ChDir, MkDir implemented
 16960                                  ;		 EE 19 Oct 1983     RmDir no longer allows you to delete a
 16961                                  ;				    current directory.
 16962                                  ;		 MZ 19 Jan 1983     Brain damaged applications rely on success
 16963                                  
 16964                                  ;	I_Need	ThisCDS,DWORD		; pointer to Current CDS
 16965                                  ;	I_Need	WFP_Start,WORD		; pointer to beginning of directory text
 16966                                  ;	I_Need	Curr_Dir_End,WORD	; offset to end of directory part
 16967                                  ;	I_Need	OpenBuf,128		; temp spot for translated name
 16968                                  ;	I_need	fSplice,BYTE		; TRUE => do splice
 16969                                  ;	I_Need	NoSetDir,BYTE		; TRUE => no exact match on splice
 16970                                  ;	I_Need	cMeta,BYTE
 16971                                  ;	I_Need	DrvErr,BYTE					;AN000;
 16972                                  
 16973                                  ;BREAK <$CURRENT_DIR - dump the current directory into user space>
 16974                                  ;----------------------------------------------------------------------------
 16975                                  ;
 16976                                  ;   Procedure Name : $CURRENT_DIR
 16977                                  ;
 16978                                  ;   Assembler usage:
 16979                                  ;		LDS	SI,area
 16980                                  ;		MOV	DL,drive
 16981                                  ;		INT	21h
 16982                                  ;	    ; DS:SI is a pointer to 64 byte area that contains drive
 16983                                  ;	    ; current directory.
 16984                                  ;   Error returns:
 16985                                  ;	    AX = error_invalid_drive
 16986                                  ;
 16987                                  ;----------------------------------------------------------------------------
 16988                                  
 16989                                  	; 06/08/2018 - Retro DOS v3.0
 16990                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 2D4Eh
 16991                                  
 16992                                  	; 25/01/2024 - Retro DOS v5.0
 16993                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:5F9Ch  ; Retro DOS v4.1 (& v4.0)
 16994                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:5FB0h ; Retro DOS v4.2
 16995                                  	; Windows ME IO.SYS - BIOSCODE:6393h
 16996                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6664h ; Retro DOS v5.0
 16997                                  
 16998                                  _$CURRENT_DIR:
 16999 00002705 E8FBF1                  	call	ECritDisk
 17000 00002708 88D0                    	MOV	AL,DL			; get drive number (0=def, 1=A)
 17001 0000270A E85C4D                  	call	GetVisDrv		; grab it
 17002 0000270D 7310                    	JNC	short CurrentValidate 	; no error -> go and validate dir
 17003                                  CurdirErr:
 17004 0000270F E81EF2                  	call	LCritDisk
 17005                                  
 17006                                  	; MSDOS 3.3
 17007                                  	;mov	al,0Fh
 17008                                  	
 17009                                  	; MSDOS 6.0
 17010 00002712 1E                      	push	ds
 17011 00002713 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 17012 00002718 A0[1006]                	mov	al,[DrvErr]		;IFS.			;AN000;
 17013 0000271B 1F                      	pop	ds
 17014                                  
 17015                                  curdir_errj:
 17016 0000271C E95BDF                  	jmp	SYS_RET_ERR		;IFS. make noise	;AN000;
 17017                                  
 17018                                  CurrentValidate:
 17019 0000271F 1E                      	push	ds			; save destination
 17020 00002720 56                      	push	si
 17021                                  	
 17022                                  	;LDS	SI,[CS:THISCDS] ; MSDOS 3.3
 17023                                  	
 17024                                  	; MSDOS 6.0
 17025 00002721 2E8E1E[0700]            	mov     ds,[cs:DosDSeg]
 17026                                  	; 25/01/2024 (PCDOS 7.1 IBMDOS.COM)
 17027 00002726 C606[4C03]00            	mov	byte [NoSetDir],0 ; *
 17028                                  	
 17029                                  	; 25/01/2024
 17030                                  	;lds     si,[THISCDS]
 17031                                  
 17032                                  ; 16/12/2022
 17033                                  %if 0
 17034                                  	; 09/11/2022 (following test instruction is nonsense!)
 17035                                  	; (I am leaving it here for MSDOS 5.0 MSDOS.SYS compatibility)
 17036                                  
 17037                                  	;test	word [si+43h],8000h
 17038                                  	TEST	word [SI+curdir.flags],curdir_isnet
 17039                                  	;jnz	short $+2  ; 09/11/2022	
 17040                                  	jnz	short DoCheck
 17041                                  %endif
 17042                                  
 17043                                  ; Random optimization nuked due to some utilities using GetCurrentDir to do
 17044                                  ; media check.
 17045                                  ;	CMP	word [SI+curdir.ID],0
 17046                                  ;	JZ	short GetDst
 17047                                  DoCheck:
 17048                                  	;MOV	byte [cs:NoSetDir],0	; interested only in contents
 17049                                  
 17050                                  	; 25/01/2024
 17051                                  	; MSDOS 6.0
 17052                                  	;push	ds
 17053                                  	;mov	ds,[cs:DosDSeg]
 17054                                  	;mov	byte [NoSetDir],0 ; *
 17055                                  	;pop	ds
 17056                                  
 17057 0000272B BF[BE03]                	MOV	DI,OPENBUF
 17058 0000272E E8E424                  	call	ValidateCDS		; output is ES:DI -> CDS
 17059                                  
 17060 00002731 06                      	push	es	 		; swap source and destination
 17061 00002732 57                      	push	di
 17062 00002733 5E                      	pop	si
 17063 00002734 1F                      	pop	ds
 17064                                  GetDst:
 17065 00002735 5F                      	pop	di
 17066 00002736 07                      	pop	es			; get real destination
 17067 00002737 72D6                    	JC	short CurdirErr
 17068                                  	;ADD	SI,curdir.text ; add si,0 ; 09/08/2018
 17069                                  	;
 17070                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17071                                  	; DOSCODE:5FE2h (MSDOS 5.0, MSDOS.SYS)
 17072                                  	; 16/12/2022
 17073                                  	;add	si,0  ; add si,curdir.text
 17074                                  	;
 17075                                  	;add	si,[si+4Fh] ; 17/05/2019
 17076 00002739 03744F                  	ADD	SI,[SI+curdir.end]
 17077 0000273C 803C5C                  	CMP	BYTE [SI],'\'	; 5Ch	; root or subdirs present?
 17078 0000273F 7501                    	JNZ	short CurrentCopy
 17079 00002741 46                      	INC	SI
 17080                                  CurrentCopy:
 17081                                  ;	call	FStrCpy
 17082                                  ;; 10/29/86 E5 char
 17083 00002742 50                      	PUSH	AX
 17084 00002743 AC                      	LODSB				; get char
 17085 00002744 08C0                    	OR	AL,AL
 17086 00002746 7413                    	JZ	short FOK
 17087 00002748 3C05                    	CMP	AL,05H
 17088 0000274A 740D                    	JZ	short FCHANGE
 17089 0000274C EB01                    	JMP	short FFF
 17090                                  FCPYNEXT:
 17091 0000274E AC                      	LODSB				; get char
 17092                                  FFF:
 17093 0000274F 3C5C                    	CMP	AL,'\'			; beginning of directory
 17094 00002751 7508                    	JNZ	short FOK		; no
 17095 00002753 AA                      	STOSB				; put into user's buffer
 17096 00002754 AC                      	LODSB				; 1st char of dir is 05?
 17097 00002755 3C05                    	CMP	AL,05H
 17098 00002757 7502                    	JNZ	short FOK		; no
 17099                                  FCHANGE:
 17100 00002759 B0E5                    	MOV	AL,0E5H			; make it E5
 17101                                  FOK:
 17102 0000275B AA                      	STOSB				; put into user's buffer
 17103 0000275C 08C0                    	OR	AL,AL			; final char
 17104 0000275E 75EE                    	JNZ	short FCPYNEXT		; no
 17105 00002760 58                      	POP	AX
 17106                                  
 17107                                  ;; 10/29/86 E5 char
 17108 00002761 30C0                    	xor	AL,AL			; MZ 19 Jan 84
 17109 00002763 E8CAF1                  	call	LCritDisk
 17110 00002766 E907DF                  	jmp	SYS_RET_OK		; no more, bye!
 17111                                  
 17112                                  ; 17/05/2019 - Retro DOS v4.0
 17113                                  
 17114                                  ; DOSCODE:6029h (MSDOS 6.21, MSDOS.SYS)
 17115                                  
 17116                                  ;BREAK <$RmDir -- Remove a directory>
 17117                                  ;----------------------------------------------------------------------------
 17118                                  ;
 17119                                  ; Procedure Name : $RmDir
 17120                                  ;
 17121                                  ; Inputs:
 17122                                  ;	DS:DX Points to asciz name
 17123                                  ; Function:
 17124                                  ;	Delete directory if empty
 17125                                  ; Returns:
 17126                                  ;	STD XENIX Return
 17127                                  ;	AX = error_path_not_found If path bad
 17128                                  ;	AX = error_access_denied If
 17129                                  ;		Directory not empty
 17130                                  ;		Path not directory
 17131                                  ;		Root directory specified
 17132                                  ;		Directory malformed (. and .. not first two entries)
 17133                                  ;		User tries to delete a current directory
 17134                                  ;	AX = error_current_directory
 17135                                  ;
 17136                                  ;----------------------------------------------------------------------------
 17137                                  
 17138                                  	; 10/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17139                                  	; DOSCODE:6015h (MSDOS 5.0, MSDOS.SYS)
 17140                                  
 17141                                  	; 25/01/2025 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 17142                                  	; DOSCODE:66C8h (PCDOS 7.1, IBMDOS.COM)
 17143                                  
 17144                                  _$RMDIR:
 17145 00002769 52                      	push	dx			; Save ptr to name
 17146 0000276A 1E                      	push	ds
 17147 0000276B 89D6                    	mov	si,dx			; Load ptr into si
 17148 0000276D BF[BE03]                	mov	di,OPENBUF		; di = ptr to buf for trans name
 17149 00002770 57                      	push	di
 17150 00002771 E8F44D                  	call	TransPathNoSet		; Translate the name
 17151 00002774 5F                      	pop	di			; di = ptr to buf for trans name
 17152 00002775 7306                    	jnc	short rmlset		; If transpath succeeded, continue
 17153 00002777 1F                      	pop	ds
 17154 00002778 5A                      	pop	dx			; Restore the name
 17155                                  	;mov	al,3
 17156 00002779 B003                    	mov	al,error_path_not_found ; Otherwise, return an error
 17157                                  	; 16/12/2022
 17158                                  rmdir_errj: ; 10/08/2018
 17159                                  chdir_errj:
 17160 0000277B EB9F                    	jmp	short curdir_errj
 17161                                  	;jmp	SYS_RET_ERR
 17162                                  rmlset:
 17163 0000277D 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1	;   if (cMeta >= 0)
 17164 00002783 7518                    	Jnz	short rmerr		;	return (-1);
 17165 00002785 16                      	push	ss
 17166 00002786 07                      	pop	es
 17167 00002787 30C0                    	xor	al,al			; al = 0 , ie drive a:
 17168                                  rmloop: 
 17169 00002789 E84E4D                  	call	GetCDSFromDrv		; Get curdir for drive in al
 17170 0000278C 7215                    	jc	short rmcont		; If error, exit loop & cont normally
 17171                                  
 17172                                  	; 25/01/2024 - Retro DOS v5.0
 17173                                  	; (PCDOS 7.1 IBMDOS.COM)
 17174                                  	;;;
 17175                                  	;;test	word [si+43h],4000h
 17176                                  	;test	word [si+curdir.flags],curdir_inuse
 17177 0000278E F6444440                	test	byte [si+curdir.flags+1],(curdir_inuse>>8)
 17178 00002792 7405                    	jz	short rmdir_nxt
 17179                                  	;;;
 17180                                  
 17181 00002794 E810F0                  	call	StrCmp			; Are the 2 paths the same?
 17182 00002797 7404                    	jz	short rmerr		; Yes, report error.
 17183                                  rmdir_nxt:	; 25/01/2024
 17184 00002799 FEC0                    	inc	al			; No, inc al to next drive number
 17185 0000279B EBEC                    	jmp	short rmloop		; Go check next drive.
 17186                                  rmerr:
 17187 0000279D 1F                      	pop	ds
 17188 0000279E 5A                      	pop	dx			; Restore ptr the name
 17189                                  	;mov	al,10h
 17190 0000279F B010                    	mov	al,error_current_directory ; error
 17191                                  	; 16/12/2022
 17192                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17193                                  ;chdir_errj:
 17194 000027A1 EBD8                    	jmp	short rmdir_errj
 17195                                  rmcont:
 17196 000027A3 1F                      	pop	ds
 17197 000027A4 5A                      	pop	dx			; Restore ptr the name
 17198 000027A5 BE[763A]                	MOV	SI,DOS_RMDIR
 17199                                  
 17200                                  	; 25/01/2024 - Retro DOS v5.0
 17201                                  	; (PCDOS 7.1 IBMDOS.COM)
 17202                                  	;;;
 17203 000027A8 E896F0                  	call	TestNet
 17204 000027AB BF4300                  	mov	di,67		; DIRSTRLEN
 17205 000027AE 7303                    	jnc	short rmcont2   ; local directory
 17206 000027B0 BF8000                  	mov	di,128
 17207                                  rmcont2:
 17208                                  	;;;
 17209 000027B3 E99900                  	JMP	DoDirCall
 17210                                  
 17211                                  ; 17/05/2019 - Retro DOS v4.0
 17212                                  
 17213                                  ; DOSCODE:6065h (MSDOS 6.21, MSDOS.SYS)
 17214                                  
 17215                                  ;BREAK <$ChDir -- Change current directory on a drive>
 17216                                  ;----------------------------------------------------------------------------
 17217                                  ;
 17218                                  ; $ChDir - Top-level change directory system call.  This call is responsible
 17219                                  ; for setting up the CDS for the specified drive appropriately.  There are
 17220                                  ; several cases to consider:
 17221                                  ;
 17222                                  ;   o	Local, simple CDS.  In this case, we take the input path and convert
 17223                                  ;	it into a WFP.	We verify the existance of this directory and then
 17224                                  ;	copy the WFP into the CDS and set up the ID field to point to the
 17225                                  ;	directory cluster.
 17226                                  ;   o	Net CDS.  We form the path from the root (including network prefix)
 17227                                  ;	and verify its existance (via DOS_Chdir).  If successful, we copy the
 17228                                  ;	WFP back into the CDS.
 17229                                  ;   o	SUBST'ed CDS.  This is no different than the local, simple CDS.
 17230                                  ;   o	JOIN'ed CDS.  This is trouble as there are two CDS's at work.  If we
 17231                                  ;	call TransPath, we will get the PHYSICAL CDS that the path refers to
 17232                                  ;	and the PHYSICAL WFP that the input path refers to.  This is perfectly
 17233                                  ;	good for the validation but not for currency.  We call TransPathNoSet
 17234                                  ;	to process the path but to return the logical CDS and the logical
 17235                                  ;	path.  We then copy the logical path into the logical CDS.
 17236                                  ;
 17237                                  ; Inputs:
 17238                                  ;	DS:DX Points to asciz name
 17239                                  ; Returns:
 17240                                  ;	STD XENIX Return
 17241                                  ;	AX = chdir_path_not_found if error
 17242                                  ;
 17243                                  ;----------------------------------------------------------------------------
 17244                                  	
 17245                                  	; 25/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
 17246                                  	
 17247                                  _$CHDIR:
 17248                                  	; 25/01/2024
 17249                                  	;;;
 17250 000027B6 36C606[7B12]43          	mov	byte [ss:PATHNAMELEN],67 ; Retro DOS v5.0
 17251                                  	;mov	word [ss:PATHNAMELEN],67 ; DIRSTRLEN = 67
 17252                                  	;;;
 17253 000027BC BF[BE03]                	MOV	DI,OPENBUF		; spot for translated name
 17254 000027BF 89D6                    	MOV	SI,DX			; get source
 17255 000027C1 E8984D                  	call	TransPath		; go munge the path and get real CDS
 17256 000027C4 7304                    	JNC	short ChDirCrack	; no errors, try path
 17257                                  ChDirErrP:
 17258                                  	;mov	al,3
 17259 000027C6 B003                    	MOV	AL,error_path_not_found
 17260                                  ChDirErr:
 17261                                  	;jmp	SYS_RET_ERR 	; oops!
 17262                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17263 000027C8 EBB1                    	jmp	short chdir_errj
 17264                                  
 17265                                  ChDirCrack:
 17266 000027CA 803E[7A05]FF            	CMP	byte [CMETA],-1		; No meta chars allowed.
 17267 000027CF 75F5                    	JNZ	short ChDirErrP
 17268                                  
 17269                                  ; We cannot do a ChDir (yet) on a raw CDS. This is treated as a path not
 17270                                  ; found.
 17271                                  
 17272 000027D1 C43E[A205]              	LES	DI,[THISCDS]
 17273 000027D5 83FFFF                  	CMP	DI,-1			;   if (ThisCDS == NULL)
 17274 000027D8 74EC                    	JZ	short ChDirErrP		;	error ();
 17275                                  
 17276                                  ; Find out if the directory exists.
 17277                                  
 17278 000027DA E85612                  	call	DOS_CHDIR
 17279                                  	;Jc	short ChDirErr
 17280                                  	; 16/12/2022
 17281 000027DD 729C                    	jc	short chdir_errj
 17282                                  ;
 17283                                  ; Get back CDS to see if a join as seen. Set the currency pointer (only if
 17284                                  ; not network). If one was seen, all we need to do is copy in the text
 17285                                  ;
 17286                                  	; 25/01/2024 - Retro DOS V5.0
 17287 000027DF FF36[E30A]              	push	word [DIRSTART_HW] ; *
 17288                                  
 17289 000027E3 C43E[A205]              	LES	DI,[THISCDS]
 17290                                  	;test	word [es:di+43h],2000h
 17291                                  	; 17/12/2022
 17292 000027E7 26F6454420              	test	byte [ES:DI+curdir.flags+1],curdir_splice>>8
 17293                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice
 17294                                  
 17295                                  	; 25/01/2024 (PCDOS 7.1)
 17296                                  	;mov	dx,[DIRSTART_HW]
 17297                                  
 17298 000027EC 742B                    	JZ	short GotCDS
 17299                                  
 17300                                  ; The CDS was joined. Let's go back and grab the logical CDS.
 17301                                  
 17302 000027EE 06                      	push	es	
 17303 000027EF 57                      	push	di
 17304                                  	;push	dx ; 25/01/2024 (PCDOS 7.1)
 17305 000027F0 51                      	push	cx ; word [DIRSTART]	; save CDS and cluster...
 17306 000027F1 E883DC                  	call	Get_User_Stack		; get original text
 17307                                  	
 17308                                  	;mov	di,[si+6]
 17309 000027F4 8B7C06                  	MOV	DI,[SI+user_env.user_DX]
 17310                                  	;mov	ds,[si+0Eh]
 17311 000027F7 8E5C0E                  	MOV	DS,[SI+user_env.user_DS]
 17312                                  	
 17313 000027FA BE[BE03]                	MOV	SI,OPENBUF		; spot for translated name
 17314 000027FD 87F7                    	XCHG	SI,DI
 17315 000027FF 30C0                    	XOR	AL,AL			; do no splicing
 17316 00002801 57                      	push	di
 17317 00002802 E8634D                  	call	TransPathNoSet		; Munge path
 17318 00002805 5E                      	pop	si
 17319                                  
 17320                                  ; There should NEVER be an error here.
 17321                                  
 17322                                  ;IF FALSE
 17323                                  ;	JNC SKipErr
 17324                                  ;	fmt <>,<>,<"$p: Internal CHDIR error\n">
 17325                                  ;SkipErr:
 17326                                  ;ENDIF
 17327 00002806 C43E[A205]              	LES	DI,[THISCDS]		; get new CDS
 17328                                  	;mov	word [es:di+49h],-1
 17329 0000280A 26C74549FFFF            	MOV	word [ES:DI+curdir.ID],-1
 17330                                  					; no valid cluster here...
 17331                                  	;;; 25/01/2024 (PCDOS 7.1)
 17332                                  	;mov	word [es:di+4Bh],-1
 17333 00002810 26C7454BFFFF            	mov	word [es:di+curdir.ID+2],-1
 17334                                  	;;;
 17335 00002816 59                      	pop	cx ; word [DIRSTART]
 17336                                  	;pop	dx ; 25/01/2024 (PCDOS 7.1)
 17337 00002817 5F                      	pop	di
 17338 00002818 07                      	pop	es
 17339                                  
 17340                                  ; ES:DI point to the physical CDS, CX is the ID (local only)
 17341                                  
 17342                                  GotCDS:
 17343                                  	; 25/01/2024 - Retro DOS v5.0
 17344 00002819 5A                      	pop	dx ; word [DIRSTART_HW] ; *
 17345                                  
 17346                                  ; wfp_start points to the text. See if it is long enough
 17347                                  
 17348                                  	; MSDOS 3.3
 17349                                  	;push	ss
 17350                                  	;pop	ds
 17351                                  	;mov	si,[WFP_START]
 17352                                  	;push	cx
 17353                                  	;call	DStrLen
 17354                                  	;cmp	cx,67 ; cmp cx,DIRSTRLEN
 17355                                  	;pop	cx
 17356                                  	;ja	short ChDirErrP
 17357                                  
 17358                                  	; MSDOS 6.0
 17359 0000281A E85C00                  	CALL	Check_PathLen		;PTM.		;AN000;
 17360 0000281D 77A7                    	JA	short ChDirErrP
 17361                                  	; MSDOS 3.3 & MSDOS 6.0
 17362                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet ; 8000h
 17363                                  	; 17/12/2022
 17364 0000281F 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8
 17365 00002824 7518                    	JNZ	short SkipRecency
 17366                                  	; MSDOS 6.0
 17367                                  	;test	word [es:di+43h],2000h
 17368                                  	; 17/12/2022
 17369 00002826 26F6454420              	test	byte [ES:DI+curdir.flags+1],curdir_splice>>8
 17370                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice 
 17371                                  					;PTM. for Join and Subst ;AN000;
 17372 0000282B 7405                    	JZ	short setdirclus	;PTM.		;AN000;
 17373 0000282D B9FFFF                  	MOV	CX,-1			;PTM.		;AN000;
 17374                                  	;;; 25/01/2024 (PCDOS 7.1 IBMDOS.COM)
 17375 00002830 89CA                    	mov	dx,cx
 17376                                  setdirclus:
 17377                                  	;mov	[es:di+49h],cx
 17378 00002832 26894D49                	MOV	[ES:DI+curdir.ID],CX
 17379                                  	;;; 25/01/2024 (PCDOS 7.1 IBMDOS.COM)
 17380 00002836 2689554B                	mov	[es:di+curdir.ID+2],dx
 17381                                  	;;;
 17382 0000283A C43E[A205]              	LES	DI,[THISCDS]		; get logical CDS
 17383                                  SkipRecency:
 17384 0000283E E897EF                  	call	FStrCpy
 17385 00002841 30C0                    	XOR	AL,AL
 17386                                  mkdir_ok:
 17387 00002843 E92ADE                  	jmp	SYS_RET_OK
 17388                                  
 17389                                  ; 17/05/2019 - Retro DOS v4.0
 17390                                  
 17391                                  ; DOSCODE:60E1h (MSDOS 6.21, MSDOS.SYS)
 17392                                  
 17393                                  ;BREAK <$MkDir - Make a directory entry>
 17394                                  ;---------------------------------------------------------------------------
 17395                                  ;
 17396                                  ; Procedure Name : $MkDir
 17397                                  ; Inputs:
 17398                                  ;	DS:DX Points to asciz name
 17399                                  ; Function:
 17400                                  ;	Make a new directory
 17401                                  ; Returns:
 17402                                  ;	STD XENIX Return
 17403                                  ;	AX = mkdir_path_not_found if path bad
 17404                                  ;	AX = mkdir_access_denied  If
 17405                                  ;		Directory cannot be created
 17406                                  ;		Node already exists
 17407                                  ;		Device name given
 17408                                  ;		Disk or directory(root) full
 17409                                  ;---------------------------------------------------------------------------
 17410                                  
 17411                                  	; 10/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17412                                  
 17413                                  	; 25/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 17414                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:67B0h
 17415                                  
 17416                                  _$MKDIR:
 17417                                  	;MOV	SI,DOS_MKDIR
 17418                                  	;;;
 17419                                  	; 25/01/2024 (PCDOS 7.1 IBMDOS.COM)
 17420 00002846 36C606[7B12]43          	mov	byte [ss:PATHNAMELEN],67 ; Retro DOS v5.0
 17421                                  	;mov	word [ss:PATHNAMELEN],67 ; DIRSTRLEN (standard length = 67)
 17422                                  mkdir_x:	; (windows) extended length (128)
 17423 0000284C BE[4339]                	mov	si,DOS_MKDIR
 17424                                  	;;;
 17425                                  DoDirCall:
 17426 0000284F BF[BE03]                	MOV	DI,OPENBUF		; spot for translated name
 17427                                  
 17428 00002852 56                      	push	si
 17429 00002853 89D6                    	MOV	SI,DX			; get source
 17430 00002855 E8044D                  	call	TransPath		; go munge the path
 17431 00002858 5E                      	pop	si
 17432 00002859 7305                    	JNC	short MkDirCrack	; no errors, try path
 17433                                  MkErrP:
 17434 0000285B B003                    	MOV	AL,error_path_not_found	; oops!
 17435                                  MkErr:
 17436 0000285D E91ADE                  	jmp	SYS_RET_ERR
 17437                                  MkDirCrack:
 17438 00002860 36803E[7A05]FF          	CMP	byte [SS:CMETA],-1
 17439 00002866 75F3                    	JNZ	short MkErrP
 17440                                  
 17441                                  	; MSDOS 3.3
 17442                                  	;push	ss
 17443                                  	;pop	ds
 17444                                  	;call	si
 17445                                  	;jb	short MkErr
 17446                                  	;;jmp	short mkdir_ok
 17447                                  	;jmp	SYS_RET_OK
 17448                                  
 17449                                  	; MSDOS 6.0
 17450 00002868 56                      	PUSH	SI			;PTM.			;AN000;
 17451                                  		; 25/01/2024 (PCDOS 7.1 IBMDOS.COM)
 17452                                  		; check path len > [PATNAMELEN] ; 67 or 128
 17453 00002869 E80D00                  	CALL	Check_PathLen		;PTM. check path len > 67 ? ;AN000;
 17454 0000286C 5E                      	POP	SI			;PTM.			;AN000;
 17455 0000286D 7604                    	JBE	short pathok		;PTM.			;AN000;
 17456                                  	;mov	al,5
 17457 0000286F B005                    	MOV	AL,error_access_denied	;PTM. ops!
 17458                                  	;jmp	SYS_RET_ERR		;PTM.
 17459 00002871 EBEA                    	jmp	short MkErr
 17460                                  pathok:
 17461 00002873 FFD6                    	CALL	SI			; go get file
 17462 00002875 72E6                    	JC	short MkErr		; error
 17463                                  	; 16/12/2022
 17464                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17465 00002877 EBCA                    	jmp	short mkdir_ok		; ok
 17466                                  	;jmp	SYS_RET_OK
 17467                                  
 17468                                  ;----------------------------------------------------------------------------
 17469                                  ;
 17470                                  ; Procedure Name : Check_PathLen
 17471                                  ;
 17472                                  ; Inputs:
 17473                                  ;	nothing
 17474                                  ; Function:
 17475                                  ;	check if final path length greater than 67
 17476                                  ; Returns:
 17477                                  ;	Above flag set if > 67
 17478                                  ;
 17479                                  ;---------------------------------------------------------------------------
 17480                                  
 17481                                  	; 25/01/2024 - Retro DOS v5.0
 17482                                  	; (PCDOS 7.1 IBMDOS.COM)
 17483                                  
 17484                                  Check_PathLen:
 17485                                  	; 09/09/2018
 17486                                  	;mov	SI,[WFP_START]
 17487 00002879 368B36[B205]            	MOV	SI,[SS:WFP_START] ; MSDOS 6.0
 17488                                  Check_PathLen2:
 17489                                  	; 25/01/2024 - Retro DOS v5.0
 17490                                  	; Note: dx is not changed in 'Check_PathLen';
 17491                                  	;	no need to push/pop (*)
 17492                                  	;
 17493 0000287E 16                      	push	ss
 17494 0000287F 1F                      	pop	ds
 17495                                  	;mov	SI,[WFP_START]	  ; MSDOS 3.3
 17496 00002880 51                      	push	CX
 17497                                  	; (PCDOS 7.1 IBMDOS.COM)
 17498                                  	;push	dx ; 25/01/2024	(*)
 17499 00002881 E86BEF                  	CALL	DStrLen
 17500                                  	; (PCDOS 7.1 IBMDOS.COM)
 17501 00002884 3B0E[7B12]              	cmp	cx,[PATHNAMELEN] ; 67 or 128
 17502                                  	;CMP	CX,DIRSTRLEN ; 67
 17503                                  	;pop	dx
 17504 00002888 59                      	POP	CX
 17505 00002889 C3                      	retn
 17506                                  
 17507                                  ;============================================================================
 17508                                  ; IOCTL.ASM, MSDOS 6.0, 1991
 17509                                  ;============================================================================
 17510                                  ; 07/08/2018 - Retro DOS v3.0
 17511                                  ; 17/05/2019 - Retro DOS v4.0
 17512                                  
 17513                                  ;**	IOCTL system call.
 17514                                  ;----------------------------------------------------------------------------
 17515                                  ;	$IOCTL
 17516                                  ;
 17517                                  ;	  Revision history:
 17518                                  ;
 17519                                  ;		Created: ARR 4 April 1983
 17520                                  ;
 17521                                  ;		GenericIOCTL added:		KGS	22 April 1985
 17522                                  ;
 17523                                  ;		A000	version 4.00	Jan. 1988
 17524                                  ;
 17525                                  ;		Used jump table to dispatch IOCTL functions. HKN 3/12/90
 17526                                  ;
 17527                                  
 17528                                  ;BREAK <IOCTL - munge on a handle to do device specific stuff>
 17529                                  ;---------------------------------------------------------------------------
 17530                                  ;
 17531                                  ;   Assembler usage:
 17532                                  ;	    MOV     BX, Handle
 17533                                  ;	    MOV     DX, Data
 17534                                  ;
 17535                                  ;	(or LDS     DX,BUF
 17536                                  ;	    MOV     CX,COUNT)
 17537                                  ;
 17538                                  ;	    MOV     AH, Ioctl
 17539                                  ;	    MOV     AL, Request
 17540                                  ;	    INT     21h
 17541                                  ;
 17542                                  ;   AH = 0  Return a combination of low byte of sf_flags and device driver
 17543                                  ;	    attribute word in DX, handle in BX:
 17544                                  ;	    DH = high word of device driver attributes
 17545                                  ;	    DL = low byte of sf_flags
 17546                                  ;	 1  Set the bits contained in DX to sf_flags.  DH MUST be 0.  Handle
 17547                                  ;	    in BX.
 17548                                  ;	 2  Read CX bytes from the device control channel for handle in BX
 17549                                  ;	    into DS:DX.  Return number read in AX.
 17550                                  ;	 3  Write CX bytes to the device control channel for handle in BX from
 17551                                  ;	    DS:DX.  Return bytes written in AX.
 17552                                  ;	 4  Read CX bytes from the device control channel for drive in BX
 17553                                  ;	    into DS:DX.  Return number read in AX.
 17554                                  ;	 5  Write CX bytes to the device control channel for drive in BX from
 17555                                  ;	    DS:DX.  Return bytes written in AX.
 17556                                  ;	 6  Return input status of handle in BX. If a read will go to the
 17557                                  ;	    device, AL = 0FFh, otherwise 0.
 17558                                  ;	 7  Return output status of handle in BX. If a write will go to the
 17559                                  ;	    device, AL = 0FFh, otherwise 0.
 17560                                  ;	 8  Given a drive in BX, return 1 if the device contains non-
 17561                                  ;	    removable media, 0 otherwise.
 17562                                  ;	 9  Return the contents of the device attribute word in DX for the
 17563                                  ;	    drive in BX.  0200h is the bit for shared.	1000h is the bit for
 17564                                  ;	    network. 8000h is the bit for local use.
 17565                                  ;	 A  Return 8000h if the handle in BX is for the network or not.
 17566                                  ;	 B  Change the retry delay and the retry count for the system. BX is
 17567                                  ;	    the count and CX is the delay.
 17568                                  ;
 17569                                  ;   Error returns:
 17570                                  ;	    AX = error_invalid_handle
 17571                                  ;	       = error_invalid_function
 17572                                  ;	       = error_invalid_data
 17573                                  ;
 17574                                  ;-------------------------------------------------------------------------------
 17575                                  ;
 17576                                  ;   This is the documentation copied from DOS 4.0 it is much better
 17577                                  ;   than the above
 17578                                  ;
 17579                                  ;	There are several basic forms of IOCTL calls:
 17580                                  ;
 17581                                  ;
 17582                                  ;	** Get/Set device information:	**
 17583                                  ;
 17584                                  ;	ENTRY	(AL) = function code
 17585                                  ;		  0 - Get device information
 17586                                  ;		  1 - Set device information
 17587                                  ;		(BX) = file handle
 17588                                  ;		(DX) = info for "Set Device Information"
 17589                                  ;	EXIT	'C' set if error
 17590                                  ;		  (AX) = error code
 17591                                  ;		'C' clear if OK
 17592                                  ;		  (DX) = info for "Get Device Information"
 17593                                  ;	USES	ALL
 17594                                  ;
 17595                                  ;
 17596                                  ;	**  Read/Write Control Data From/To Handle  **
 17597                                  ;
 17598                                  ;	ENTRY	(AL) = function code
 17599                                  ;		  2 - Read device control info
 17600                                  ;		  3 - Write device control info
 17601                                  ;		(BX) = file handle
 17602                                  ;		(CX) = transfer count
 17603                                  ;		(DS:DX) = address for data
 17604                                  ;	EXIT	'C' set if error
 17605                                  ;		  (AX) = error code
 17606                                  ;		'C' clear if OK
 17607                                  ;		  (AX) = count of bytes transfered
 17608                                  ;	USES	ALL
 17609                                  ;
 17610                                  ;
 17611                                  ;	**  Read/Write Control Data From/To Block Device  **
 17612                                  ;
 17613                                  ;	ENTRY	(AL) = function code
 17614                                  ;		  4 - Read device control info
 17615                                  ;		  5 - Write device control info
 17616                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 17617                                  ;		(CX) = transfer count
 17618                                  ;		(DS:DX) = address for data
 17619                                  ;	EXIT	'C' set if error
 17620                                  ;		  (AX) = error code
 17621                                  ;		'C' clear if OK
 17622                                  ;		  (AX) = count of bytes transfered
 17623                                  ;	USES	ALL
 17624                                  ;
 17625                                  ;
 17626                                  ;	**  Get Input/Output Status  **
 17627                                  ;
 17628                                  ;	ENTRY	(AL) = function code
 17629                                  ;		  6 - Get Input status
 17630                                  ;		  7 - Get Output Status
 17631                                  ;		(BX) = file handle
 17632                                  ;	EXIT	'C' set if error
 17633                                  ;		  (AX) = error code
 17634                                  ;		'C' clear if OK
 17635                                  ;		  (AL) = 00 if not ready
 17636                                  ;		  (AL) = FF if ready
 17637                                  ;	USES	ALL
 17638                                  ;
 17639                                  ;
 17640                                  ;	**  Get Drive Information  **
 17641                                  ;
 17642                                  ;	ENTRY	(AL) = function code
 17643                                  ;		  8 - Check for removable media
 17644                                  ;		  9 - Get device attributes
 17645                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 17646                                  ;	EXIT	'C' set if error
 17647                                  ;		  (AX) = error code
 17648                                  ;		'C' clear if OK
 17649                                  ;		  (AX) = 0/1 media is removable/fixed (func. 8)
 17650                                  ;		  (DX) = device attribute word (func. 9)
 17651                                  ;	USES	ALL
 17652                                  ;
 17653                                  ;
 17654                                  ;	**  Get Redirected bit	**
 17655                                  ;
 17656                                  ;	ENTRY	(AL) = function code
 17657                                  ;		  0Ah - Network stuff
 17658                                  ;		(BX) = file handle
 17659                                  ;	EXIT	'C' set if error
 17660                                  ;		  (AX) = error code
 17661                                  ;		'C' clear if OK
 17662                                  ;		  (DX) = SFT flags word, 8000h set if network file
 17663                                  ;	USES	ALL
 17664                                  ;
 17665                                  ;
 17666                                  ;	**  Change sharer retry parameters  **
 17667                                  ;
 17668                                  ;	ENTRY	(AL) = function code
 17669                                  ;		  0Bh - Set retry parameters
 17670                                  ;		(CX) = retry loop count
 17671                                  ;		(DX) = number of retries
 17672                                  ;	EXIT	'C' set if error
 17673                                  ;		  (AX) = error code
 17674                                  ;		'C' clear if OK
 17675                                  ;	USES	ALL
 17676                                  ;
 17677                                  ;
 17678                                  ;   =================================================================
 17679                                  ;
 17680                                  ;	**  New Standard Control  **
 17681                                  ;
 17682                                  ;	ALL NEW IOCTL FACILITIES SHOULD USE THIS FORM.	THE OTHER
 17683                                  ;	FORMS ARE OBSOLETE.
 17684                                  ;
 17685                                  ;   =================================================================
 17686                                  ;
 17687                                  ;	ENTRY	(AL) = function code
 17688                                  ;		  0Ch - Control Function subcode
 17689                                  ;		(BX) = File Handle
 17690                                  ;		(CH) = Category Indicator
 17691                                  ;		(CL) = Function within category
 17692                                  ;		(DS:DX) = address for data, if any
 17693                                  ;		(SI) = Passed to device as argument, use depends upon function
 17694                                  ;		(DI) = Passed to device as argument, use depends upon function
 17695                                  ;	EXIT	'C' set if error
 17696                                  ;		  (AX) = error code
 17697                                  ;		'C' clear if OK
 17698                                  ;		  (SI) = Return value, meaning is function dependent
 17699                                  ;		  (DI) = Return value, meaning is function dependent
 17700                                  ;		  (DS:DX) = Return address, use is function dependent
 17701                                  ;	USES	ALL
 17702                                  ;
 17703                                  ;    ============== Generic IOCTL Definitions for DOS 3.2 ============
 17704                                  ;     (See inc\ioctl.inc for more info)
 17705                                  ;
 17706                                  ;	ENTRY	(AL) = function code
 17707                                  ;		  0Dh - Control Function subcode
 17708                                  ;		(BL) = Drive Number (0 = Default, 1= 'A')
 17709                                  ;		(CH) = Category Indicator
 17710                                  ;		(CL) = Function within category
 17711                                  ;		(DS:DX) = address for data, if any
 17712                                  ;		(SI) = Passed to device as argument, use depends upon function
 17713                                  ;		(DI) = Passed to device as argument, use depends upon function
 17714                                  ;
 17715                                  ;	EXIT	'C' set if error
 17716                                  ;		  (AX) = error code
 17717                                  ;		'C' clear if OK
 17718                                  ;		  (DS:DX) = Return address, use is function dependent
 17719                                  ;	USES	ALL
 17720                                  ;
 17721                                  ;---------------------------------------------------------------------------
 17722                                  	
 17723                                  	; 17/05/2019 - Retro DOS v4.0
 17724                                  	; DOSCODE:611Eh (MSDOS 6.21, MSDOS.SYS)
 17725                                  
 17726                                  	; 11/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17727                                  	; DOSCODE:610Ah (MSDOS 5.0, MSDOS.SYS)
 17728                                  
 17729                                  	; 14/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 17730                                  	; DOSCODE:67F7h (PCDOS 7.1, IBMDOS.COM)
 17731                                  
 17732                                  IOCTLJMPTABLE:	;label	word
 17733                                  	; MSDOS 3.3 (& MSDOS 6.0)
 17734 0000288A [C628]                  	dw	ioctl_getset_data	; 0
 17735 0000288C [C628]                  	dw	ioctl_getset_data   	; 1
 17736 0000288E [1029]                  	dw	ioctl_control_string	; 2
 17737 00002890 [1029]                  	dw	ioctl_control_string	; 3
 17738 00002892 [A32A]                  	dw	ioctl_get_dev		; 4
 17739 00002894 [A32A]                  	dw	ioctl_get_dev		; 5
 17740 00002896 [2829]                  	dw	ioctl_status		; 6
 17741 00002898 [2829]                  	dw	ioctl_status		; 7
 17742 0000289A [022A]                  	dw	ioctl_rem_media		; 8
 17743 0000289C [4B2A]                  	dw	ioctl_drive_attr	; 9
 17744 0000289E [952A]                  	dw	ioctl_handle_redir	; A
 17745 000028A0 [3D2A]                  	dw	Set_Retry_Parameters	; B
 17746 000028A2 [4429]                  	dw	GENERICIOCTLHANDLE	; C
 17747 000028A4 [5E29]                  	dw	GENERICIOCTL		; D
 17748                                  	; MSDOS 6.0 (& MSDOS 3.3)
 17749 000028A6 [442B]                  	dw	ioctl_drive_owner	; E
 17750 000028A8 [442B]                  	dw	ioctl_drive_owner	; F
 17751                                  	; MSDOS 6.0
 17752 000028AA [4429]                  	dw	query_handle_support	; 10h
 17753 000028AC [5E29]                  	dw	query_device_support	; 11h
 17754                                  
 17755                                  	; 11/11/2022
 17756                                  _$IOCTL:
 17757 000028AE 8CDE                    	MOV	SI,DS			; Stash DS for calls 2,3,4 and 5
 17758 000028B0 16                      	push	ss
 17759 000028B1 1F                      	pop	ds			;hkn; SS is DOSDATA
 17760                                  
 17761                                  	; MSDOS 3.3
 17762                                  	;cmp	al,0Fh 
 17763                                  	; MSDOS 6.0
 17764 000028B2 3C11                    	cmp	al,11h			; al must be between 0 & 11h
 17765 000028B4 770D                    	ja	short ioctl_bad_funj2	; if not bad function #
 17766                                  
 17767                                  	; 14/01/2024
 17768                                  	; 28/05/2019
 17769                                  	;push	AX	; 14/01/2024	; Need to save AL for generic IOCTL
 17770 000028B6 89C7                    	mov	di,ax			; di NOT a PARM
 17771 000028B8 81E7FF00                	and	di,0FFh			; di = al
 17772 000028BC D1E7                    	shl	di,1			; di = index into jmp table
 17773                                  	;pop	AX			; Restore AL for generic IOCTL
 17774                                  
 17775                                  
 17776 000028BE 2EFFA5[8A28]            	jmp	word [CS:DI+IOCTLJMPTABLE]
 17777                                  
 17778                                  ioctl_bad_funj2:
 17779 000028C3 E90401                  	JMP	ioctl_bad_fun  ; 10/08/2018
 17780                                  
 17781                                  ;--------------------------------------------------------------------------
 17782                                  ;
 17783                                  ; IOCTL: AL = 0,1
 17784                                  ;
 17785                                  ; ENTRY: DS = DOSDATA
 17786                                  ;
 17787                                  ;--------------------------------------------------------------------------
 17788                                  
 17789                                  	; 29/01/2024 - Retro DOS v5.0
 17790                                  ioctl_getset_data:
 17791                                  	; MSDOS 6.0
 17792 000028C6 E89847                  	call	SFFromHandle		; ES:DI -> SFT
 17793 000028C9 7305                    	JNC	short ioctl_check_permissions ; have valid handle
 17794                                  ioctl_bad_handle:
 17795                                  	;mov	al,6
 17796 000028CB B006                    	mov	al,error_invalid_handle
 17797                                  ioctl_error:
 17798 000028CD E9AADD                  	jmp	SYS_RET_ERR
 17799                                  
 17800                                  ioctl_check_permissions:
 17801 000028D0 3C00                    	CMP	AL,0
 17802                                  	;mov	al,[es:di+5]
 17803 000028D2 268A4505                	MOV	AL,[ES:DI+SF_ENTRY.sf_flags]; Get low byte of flags
 17804 000028D6 7419                    	JZ	short ioctl_read	; read the byte
 17805                                  
 17806 000028D8 08F6                    	or	dh,dh
 17807 000028DA 7404                    	JZ	short ioctl_check_device ; can I set with this data?
 17808                                  	;mov	al,0Dh
 17809 000028DC B00D                    	mov	al,error_invalid_data	; no DH <> 0
 17810                                  	;jmp	SYS_RET_ERR
 17811 000028DE EBED                    	jmp	short ioctl_error
 17812                                  
 17813                                  ioctl_check_device:
 17814 000028E0 A880                    	test	AL,devid_device  ; 80h	; can I set this handle?
 17815 000028E2 74DF                    	jz	short ioctl_bad_funj2
 17816 000028E4 80CA80                  	OR	DL,devid_device 	; Make sure user doesn't turn off the
 17817                                  					;   device bit!! He can muck with the
 17818                                  					;   others at will.
 17819                                  	;MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 17820                                  	; 29/01/2024
 17821                                  	;;;
 17822 000028E7 E819EA                  	call	set_exerr_locus_ser ; (PCDOS 7.1 IBMDOS.COM)
 17823                                  	;;;
 17824 000028EA 26885505                	MOV	BYTE [ES:DI+SF_ENTRY.sf_flags],DL  ;AC000;MS.; Set flags
 17825                                  ioctl_ok:
 17826 000028EE E97FDD                  	jmp	SYS_RET_OK
 17827                                  
 17828                                  ioctl_read:
 17829                                  	;MOV	byte [EXTERR_LOCUS],errLOC_Disk  ; 2
 17830                                  	; 29/01/2024
 17831                                  	;;;
 17832 000028F1 E80AEA                  	call	set_exerr_locus_disk ; (PCDOS 7.1 IBMDOS.COM)
 17833                                  	;;;
 17834 000028F4 30E4                    	XOR	AH,AH
 17835 000028F6 A880                    	test	AL,devid_device 	; Should I set high byte
 17836 000028F8 740B                    	JZ	short ioctl_no_high	; no
 17837                                  	;MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 17838                                  	; 29/01/2024
 17839                                  	;;;
 17840 000028FA E806EA                  	call	set_exerr_locus_ser ; (PCDOS 7.1 IBMDOS.COM)
 17841                                  	;;;
 17842                                  	;les	di,[es:di+7]
 17843 000028FD 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 17844                                  	;mov	ah,[es:di+5]
 17845 00002901 268A6505                	MOV	AH,[ES:DI+SYSDEV.ATT+1] ; Get high byte
 17846                                  ioctl_no_high:
 17847 00002905 89C2                    	MOV	DX,AX
 17848                                  ioctl_set_dx:	; 16/12/2022
 17849 00002907 E86DDB                  	call	Get_User_Stack
 17850                                  	;mov	[si+6],dx
 17851 0000290A 895406                  	MOV	[SI+user_env.user_DX],DX
 17852                                  	;;jmp	SYS_RET_OK
 17853                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17854                                  ioctl_ok_j:
 17855                                  	; 16/12/2022
 17856 0000290D E963DD                  	jmp	SYS_RET_OK_clc	 ; (after 'Get_User_Stack') 
 17857                                  	;jmp	short ioctl_ok
 17858                                  	; 26/07/2019
 17859                                  	;jmp	SYS_RET_OK_clc
 17860                                  
 17861                                  ;--------------------------------------------------------------------------
 17862                                  ;
 17863                                  ; IOCTL: AL = 2,3
 17864                                  ;
 17865                                  ; ENTRY: DS = DOSDATA
 17866                                  ;	 SI = user's DS
 17867                                  ;
 17868                                  ;--------------------------------------------------------------------------
 17869                                  
 17870                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17871                                  ioctl_control_string:
 17872 00002910 E84E47                  	call	SFFromHandle		; ES:DI -> SFT
 17873 00002913 72B6                    	JC	short ioctl_bad_handle	; invalid handle
 17874                                  	; 07/12/2022
 17875                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
 17876                                  	;jz	short ioctl_bad_funj2			; No it is a file
 17877                                  	; MSDOS 5.0 & MSDOS 6.0
 17878 00002915 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
 17879 0000291A 74A7                    	jz	short ioctl_bad_funj2			; No it is a file
 17880                                  	;MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 17881                                  	; 29/01/2024
 17882                                  	;;;
 17883 0000291C E8E4E9                  	call	set_exerr_locus_ser ; (PCDOS 7.1 IBMDOS.COM)
 17884                                  	;;;
 17885 0000291F 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 17886 00002923 30DB                    	XOR	BL,BL			; Unit number of char dev = 0
 17887 00002925 E98301                  	JMP	ioctl_do_string
 17888                                  
 17889                                  ;--------------------------------------------------------------------------
 17890                                  ;
 17891                                  ; IOCTL: AL = 6,7
 17892                                  ;
 17893                                  ; ENTRY: DS = DOSDATA
 17894                                  ;
 17895                                  ;--------------------------------------------------------------------------
 17896                                  
 17897                                  ioctl_status:
 17898 00002928 B401                    	MOV	AH,1
 17899 0000292A 2C06                    	SUB	AL,6			; 6=0,7=1
 17900 0000292C 7402                    	JZ	short ioctl_get_status
 17901 0000292E B403                    	MOV	AH,3
 17902                                  ioctl_get_status:
 17903 00002930 50                      	PUSH	AX
 17904 00002931 E89515                  	call	GET_IO_SFT
 17905 00002934 58                      	POP	AX
 17906                                  	;JNC	short DO_IOFUNC
 17907                                  	;JMP	short ioctl_bad_handle	; invalid SFT
 17908                                  	; 16/12/2022
 17909 00002935 7294                    	jc	short ioctl_bad_handle
 17910                                  DO_IOFUNC:
 17911 00002937 E81625                  	call	IOFUNC
 17912 0000293A 88C4                    	MOV	AH,AL
 17913 0000293C B0FF                    	MOV	AL,0FFH
 17914                                  	;JNZ	short ioctl_status_ret
 17915                                  	; 29/01/2024
 17916 0000293E 75AE                    	jnz	short ioctl_ok
 17917 00002940 FEC0                    	INC	AL
 17918                                  ioctl_status_ret:
 17919                                  	;jmp	SYS_RET_OK
 17920                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17921                                  	;jmp	short ioctl_ok_j
 17922                                  	; 16/12/2022
 17923 00002942 EBAA                    	jmp	short ioctl_ok
 17924                                  
 17925                                  ;--------------------------------------------------------------------------
 17926                                  ;
 17927                                  ; Generic IOCTL entry point. AL = C, D, 10h, 11h
 17928                                  ;
 17929                                  ;	here we invoke the Generic IOCTL using the IOCTL_Req structure.
 17930                                  ;	SI:DX -> Users Device Parameter Table
 17931                                  ;	IOCALL -> IOCTL_Req structure
 17932                                  ;
 17933                                  ; 	If on entry AL >= IOCTL_QUERY_HANDLE the function is a
 17934                                  ;	QueryIOCtlSupport call ELSE it's a standard generic IOCtl
 17935                                  ;	call.
 17936                                  ;
 17937                                  ; BUGBUG: Don't push anything on the stack between GENERIOCTL: and 
 17938                                  ;         the call to Check_If_Net because Check_If_Net gets our
 17939                                  ;         return address off the stack if the drive is invalid.
 17940                                  ;
 17941                                  ;--------------------------------------------------------------------------
 17942                                  
 17943                                  	; 29/01/2024 - Retro DOS v5.0
 17944                                  
 17945                                  query_handle_support:	; Entry point for handles
 17946                                  GENERICIOCTLHANDLE:
 17947 00002944 E81A47                  	call	SFFromHandle		; Get SFT for device.
 17948 00002947 727E                    	jc	short ioctl_bad_handlej
 17949                                  
 17950                                  	;test	word [es:di+5],8000h
 17951                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet	; M031;
 17952                                  	;test	byte [es:di+6],80h
 17953 00002949 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 17954 0000294E 757A                    	jnz	short ioctl_bad_fun	; Cannot do this over net.
 17955                                  
 17956                                  	;mov	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 17957                                  	; 29/01/2024
 17958                                  	;;;
 17959 00002950 E8B0E9                  	call	set_exerr_locus_ser ; (PCDOS 7.1 IBMDOS.COM)
 17960                                  	;;;
 17961                                  
 17962                                  	;les	di,[es:di+7]
 17963 00002953 26C47D07                	les	di,[es:di+SF_ENTRY.sf_devptr]	; Get pointer to device.
 17964                                  	;;;
 17965                                  	; 29/01/2024 - PCDOS 7.1 IBMDOS.COM
 17966 00002957 C606[B103]FF            	mov	byte [IOCTL_drvnum],0FFh	; invalidate drive number
 17967                                  					; (for extended -lock/unlock- functions)
 17968                                  	;;;
 17969 0000295C EB16                    	jmp	short Do_GenIOCTL
 17970                                  
 17971                                  	; 29/01/2024 - Retro DOS v5.0
 17972                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:68DAh
 17973                                  	; (WINME IO.SYS - BIOSCODE:6612h)
 17974                                  
 17975                                  query_device_support:	; Entry point for devices:
 17976                                  GENERICIOCTL:
 17977                                  	;mov	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 17978                                  	; 29/01/2024
 17979                                  	;;;
 17980 0000295E E89DE9                  	call	set_exerr_locus_disk
 17981 00002961 80FD48                  	cmp	ch,48h			; category (extended, disk lock/unlock)
 17982 00002964 7405                    	je      short GenIOCTL_chk_net	; extended (MSDOS/PCDOS 7)
 17983                                  	;;;
 17984                                  
 17985 00002966 80FD08                  	cmp	ch,IOC_DC ; 8		; Only disk devices are allowed to use
 17986 00002969 755F                    	jne	short ioctl_bad_fun	; no handles with Generic IOCTL.
 17987                                  
 17988                                  	; 29/01/2024 
 17989                                  	;;;
 17990                                  GenIOCTL_chk_net:
 17991 0000296B 881E[B103]              	mov	[IOCTL_drvnum],bl	; drive number
 17992                                  	;;;
 17993                                  
 17994 0000296F E8C301                  	CALL	Check_If_Net		; ES:DI := Get_hdr_block of device in BL
 17995 00002972 7556                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 17996                                  
 17997                                  Do_GenIOCTL:
 17998                                  	; 29/01/2024 - Retro DOS v5.0 
 17999                                  	;;;
 18000 00002974 80FD48                  	cmp	ch,48h			; category code 48h for FAT32
 18001 00002977 7456                    	je	short GenIOCTL_extended ; MSDOS/PCDOS 7 functions (lock/unlock)
 18002                                  	;cmp	ch,8
 18003 00002979 80FD08                  	cmp	ch,IOC_DC ; 8          	; disk control
 18004 0000297C 7451                    	je	short GenIOCTL_extended
 18005                                  GenIOCTL_normal:			; MSDOS 5-6.22 functions
 18006                                  	;;;
 18007                                  
 18008                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320 
 18009                                  					; Can device handle Generic IOCTL funcs
 18010                                  	; 09/09/2018
 18011                                  	;test	byte [es:di+4],40h
 18012 0000297E 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 18013 00002983 7445                    	jz	short ioctl_bad_fun
 18014                                  
 18015                                  	; 17/05/2019 - Retro DOS v4.0
 18016                                  
 18017                                  	; MSDOS 6.0
 18018                                  	;mov	byte [IOCALL_REQFUNC],19 ; 13h
 18019 00002985 C606[7E03]13            	mov	byte [IOCALL_REQFUNC],GENIOCTL ; Assume real Request
 18020                                  	;cmp	al,10h
 18021 0000298A 3C10                    	cmp	AL,IOCTL_QUERY_HANDLE	; See if this is just a query
 18022 0000298C 7C0C                    	jl	short SetIOCtlBlock
 18023                                  	
 18024                                  	;TEST	word [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
 18025                                  	;test	byte [es:di+4],80h 
 18026 0000298E 26F6450480              	TEST	byte [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
 18027 00002993 7435                    	jz	short ioctl_bad_fun	; No support for query 
 18028                                  	;
 18029                                  	;mov	byte [IOCALL_REQFUNC],19h	
 18030 00002995 C606[7E03]19            	mov	byte [IOCALL_REQFUNC],IOCTL_QUERY ; Just a query (5.00)
 18031                                  
 18032                                  SetIOCtlBlock:
 18033 0000299A 06                      	PUSH	ES			; DEVIOCALL2 expects Device header block
 18034 0000299B 57                      	PUSH	DI			; in DS:SI
 18035                                  					; Setup Generic IOCTL Request Block
 18036                                  	;mov	byte [IOCALL_REQLEN],23
 18037 0000299C C606[7C03]17            	mov	byte [IOCALL_REQLEN],IOCTL_REQ.size
 18038                                  	; 07/09/2018 (MSDOS 3.3)
 18039                                  	;;mov	byte [IOCALL_REQFUNC],19
 18040                                  	;mov	byte [IOCALL_REQFUNC],GENIOCTL ; 07/09/2018
 18041                                  	;
 18042 000029A1 881E[7D03]              	MOV	[IOCALL_REQUNIT],BL
 18043 000029A5 882E[8903]              	MOV	[IOCALL+IOCTL_REQ.MAJORFUNCTION],CH
 18044 000029A9 880E[8A03]              	MOV	[IOCALL+IOCTL_REQ.MINORFUNCTION],CL
 18045 000029AD 8936[8B03]              	MOV	[IOCALL+IOCTL_REQ.REG_SI],SI
 18046 000029B1 893E[8D03]              	MOV	[IOCALL+IOCTL_REQ.REG_DI],DI
 18047 000029B5 8916[8F03]              	MOV	[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET],DX
 18048 000029B9 8936[9103]              	MOV	[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET+2],SI
 18049                                  
 18050                                  ;hkn; IOCALL is in DOSDATA
 18051 000029BD BB[7C03]                	MOV	BX,IOCALL
 18052                                  
 18053 000029C0 16                      	PUSH	SS
 18054 000029C1 07                      	POP	ES
 18055                                  					; DS:SI -> Device header.
 18056 000029C2 5E                      	POP	SI
 18057 000029C3 1F                      	POP	DS
 18058                                  	; 10/08/2018
 18059 000029C4 E91D01                  	jmp	ioctl_do_IO		; Perform Call to device driver
 18060                                  	
 18061                                  ioctl_bad_handlej:
 18062 000029C7 E901FF                  	jmp	ioctl_bad_handle
 18063                                  
 18064                                  	; 29/01/2024
 18065                                  ioctl_bad_fun:
 18066 000029CA B001                    	mov	al, error_invalid_function  ; 1
 18067 000029CC E9ABDC                  	jmp	SYS_RET_ERR	
 18068                                  
 18069                                  	; 29/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 18070                                  GenIOCTL_extended:
 18071 000029CF 80F96A                  	cmp	cl,6Ah			; UNLOCK LOGICAL VOLUME
 18072                                  	;je	short GenIOCTL_chk_lock
 18073 000029D2 740E                    	je	short GenIOCTL_lock_unlock
 18074 000029D4 80F94A                  	cmp	cl,4Ah			; LOCK LOGICAL VOLUME
 18075 000029D7 75A5                    	jne	short GenIOCTL_normal
 18076                                  ;GenIOCTL_chk_lock:
 18077                                  	;cmp	cl,4Ah			; LOCK LOGICAL VOLUME
 18078                                  	;jne	short GenIOCTL_lock_unlock
 18079 000029D9 80FF04                  	cmp	bh,4			; lock level (0-4)
 18080 000029DC 7404                    	je	short GenIOCTL_lock_unlock
 18081 000029DE 08FF                    	or	bh,bh
 18082 000029E0 75E8                    	jnz	short ioctl_bad_fun
 18083                                  GenIOCTL_lock_unlock:
 18084 000029E2 8A1E[B103]              	mov	bl,[IOCTL_drvnum]	; drive number (1=A:, 2=B: ..)
 18085 000029E6 30FF                    	xor	bh,bh
 18086 000029E8 4B                      	dec	bx
 18087 000029E9 80FB1A                  	cmp	bl,26			; logical disk number limit
 18088 000029EC 73DC                    	jnb	short ioctl_bad_fun
 18089 000029EE 80F96A                  	cmp	cl,6Ah			; UNLOCK LOGICAL VOLUME
 18090 000029F1 7507                    	jne	short GenIOCTL_lock
 18091 000029F3 80A7[2F14]7F            	and	byte [bx+drive_flags],7Fh ; UNLOCK
 18092 000029F8 EB05                    	jmp	short GenIOCTL_OK
 18093                                  GenIOCTL_lock:
 18094 000029FA 808F[2F14]80            	or	byte [bx+drive_flags],80h ; LOCK
 18095                                  GenIOCTL_OK:
 18096 000029FF E96EDC                  	jmp	SYS_RET_OK
 18097                                  
 18098                                  ;---------------------------------------------------------------------------
 18099                                  ;
 18100                                  ; IOCTL: AL = 8
 18101                                  ;
 18102                                  ; ENTRY: DS = DOSDATA
 18103                                  ;
 18104                                  ; BUGBUG: Don't push anything on the stack between ioctl_rem_media: and 
 18105                                  ;         the call to Check_If_Net because Check_If_Net gets our
 18106                                  ;         return address off the stack if the drive is invalid.
 18107                                  ;
 18108                                  ;-------------------------------------------------------------------------
 18109                                  
 18110                                  	; 30/01/2024
 18111                                  ioctl_rem_media:
 18112                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18113 00002A02 E83001                  	CALL	Check_If_Net
 18114 00002A05 75C3                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 18115                                  					;   certainly don't know how to do this
 18116                                  					;   call.
 18117                                  	;test	word [es:di+4],800h
 18118                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL ; See if device can
 18119                                  	;test	byte [es:di+5],8
 18120 00002A07 26F6450508              	TEST	byte [es:di+SYSDEV.ATT+1],(DEVOPCL>>8)
 18121 00002A0C 74BC                    	JZ	short ioctl_bad_fun		; NO
 18122                                  
 18123                                  ;hkn; SS override for IOCALL
 18124                                  	; 30/01/2024
 18125                                  	; ds = ss = DOSDATA segment ('Get_Driver_BL' in 'Check_If_Net')
 18126                                  	;MOV	byte [SS:IOCALL_REQFUNC],DEVRMD ; 15
 18127 00002A0E C606[7E03]0F            	mov	byte [IOCALL_REQFUNC],DEVRMD ; 15
 18128 00002A13 B00D                    	MOV	AL,REMHL  ; 13
 18129 00002A15 88DC                    	MOV	AH,BL			; Unit number
 18130                                  	;MOV	[SS:IOCALL_REQLEN],AX
 18131 00002A17 A3[7C03]                	mov	[IOCALL_REQLEN],ax	
 18132 00002A1A 31C0                    	XOR	AX,AX
 18133                                  	;MOV	[SS:IOCALL_REQSTAT],AX
 18134 00002A1C A3[7F03]                	mov	[IOCALL_REQSTAT],ax ; 0
 18135                                  	
 18136 00002A1F 06                      	PUSH	ES
 18137 00002A20 1F                      	POP	DS
 18138 00002A21 89FE                    	MOV	SI,DI			; DS:SI -> driver
 18139 00002A23 16                      	PUSH	SS
 18140 00002A24 07                      	POP	ES
 18141                                  
 18142                                  ;hkn; IOCALL is in DOSDATA (msconst.asm)
 18143                                  	; 30/01/2024
 18144                                  	; (ds <> ss, ss = DOSDATA segment)
 18145 00002A25 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 18146 00002A28 1E                      	push	ds
 18147 00002A29 56                      	push	si
 18148 00002A2A E8F825                  	call	DEVIOCALL2
 18149 00002A2D 5E                      	pop	si
 18150 00002A2E 1F                      	pop	ds
 18151                                  
 18152                                  ;hkn; SS override
 18153 00002A2F 36A1[7F03]              	MOV	AX,[SS:IOCALL_REQSTAT]	; Get Status word
 18154                                  	;AND	AX,STBUI ; 200h		; Mask to busy bit
 18155                                  	; 29/01/2024
 18156 00002A33 80E402                  	and	ah,STBUI>>8 ; 2
 18157 00002A36 B109                    	MOV	CL,9
 18158 00002A38 D3E8                    	SHR	AX,CL			; Busy bit to bit 0
 18159                                  ioctl_da_ok_j:	; 11/11/2022
 18160 00002A3A E933DC                  	jmp	SYS_RET_OK
 18161                                  
 18162                                  	; 29/01/2024
 18163                                  ;--------------------------------------------------------------------------
 18164                                  ;
 18165                                  ; IOCTL: AL = B
 18166                                  ;
 18167                                  ; ENTRY: DS = DOSDATA
 18168                                  ;
 18169                                  ;--------------------------------------------------------------------------
 18170                                  
 18171                                  Set_Retry_Parameters:
 18172                                  	; 09/09/2018
 18173 00002A3D 890E[1C00]              	MOV	[RetryLoop],CX		; 0 retry loop count allowed
 18174 00002A41 09D2                    	OR	DX,DX			; zero retries not allowed
 18175 00002A43 7485                    	JZ	short ioctl_bad_fun
 18176                                  	; 29/01/2024
 18177                                  	;jnz	short set_new_retry_cnt
 18178                                  	;jmp	ioctl_bad_fun
 18179                                  ;set_new_retry_cnt:
 18180 00002A45 8916[1A00]              	MOV	[RetryCount],DX		; Set new retry count
 18181                                  doneok:
 18182                                  	;jmp	SYS_RET_OK		; Done
 18183                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18184                                  	;jmp	short ioctl_status_ret
 18185                                  	; 16/12/2022
 18186                                  	;jmp	short ioctl_ok	 ; jmp SYS_RET_OK
 18187                                  	; 29/01/2024
 18188 00002A49 EBEF                    	jmp	short ioctl_da_ok_j
 18189                                  
 18190                                  ;-------------------------------------------------------------------------
 18191                                  ;
 18192                                  ; IOCTL: AL = 9
 18193                                  ;
 18194                                  ; ENTRY: DS = DOSDATA
 18195                                  ;
 18196                                  ;-------------------------------------------------------------------------
 18197                                  
 18198                                  	; 30/01/2024 - Retro DOS v5.0
 18199                                  
 18200                                  ioctl_drive_attr:
 18201                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18202 00002A4B 88D8                    	mov	al,bl
 18203 00002A4D E8354A                  	call	GETTHISDRV
 18204 00002A50 723E                    	jc	short ioctl_drv_err
 18205 00002A52 E8B500                  	call	Get_Driver_BL
 18206                                  	; MSDOS 6.0
 18207 00002A55 7239                    	JC	short ioctl_drv_err	; drive not valid
 18208                                  
 18209                                  	; 30/01/2024 - Retro DOS v5.0
 18210                                  	; 30/01/2024 - PCDOS 7.1 IBMDOS.COM
 18211                                  	;;;
 18212                                  	;mov	dx,942h		; 0942h -> Attribute word
 18213                                  	;			; bit 11 - open/close/remmedia calls supported
 18214                                  	;			; bit 8 - (new type driver)
 18215                                  	;			; bit 6 - Generic IOCTL call supported
 18216                                  	;			; bit 1 - driver supports 32-bit sector addressing
 18217                                  	;jnz     short ioctl_drive_attr2 ; NET device
 18218                                  			; 30/01/2024
 18219                                  			; NOTE: 'jnz' condition is correct for Windows ME
 18220                                  			; 'Get_Driver_BL ' because it tests bit 0 of [drive_flags] 	
 18221                                  			; but in PCDOS 7.1 'Get_Driver_BL', this flag
 18222                                  			;	 (remote or removable? disk flag) is not tested
 18223                                  			; the last test is net device test)
 18224                                  	;;;;
 18225                                  
 18226                                  	;mov	dx,[es:di+4]
 18227 00002A57 268B5504                	mov	dx,[es:di+SYSDEV.ATT]	
 18228                                  				; get device attribute word
 18229                                  ;ioctl_drive_attr2: ; 30/01/2024
 18230 00002A5B 88C3                    	MOV	BL,AL		; Phys letter to BL (A=0)
 18231                                  
 18232                                  ;hkn; SS override
 18233                                  	; 30/01/2024
 18234                                  	; (MSDOS 6.22 IO.SYS - DOSCODE:62B8h)
 18235                                  	; (PCDOS 7.1 IBMDOS.COM - DOSCODE:69DBh)
 18236                                  	;LES	DI,[SS:THISCDS]	; NOTE: PCDOS 7.1 has bug here,
 18237                                  				; ds must be same with ss here...
 18238                                  				; because there is 'les di, [ds:THISCDS]' in
 18239                                  				; Get_Driver_BL
 18240                                  				; and a second 'test byte ptr es:[ di+44h],80h'
 18241                                  				; is not necessary; also its result (jnz)
 18242                                  				; overwrites DS. /// Erdogan Tan - 30/01/2024
 18243                                  	; 30/01/2024
 18244                                  	; Retro DOS v5.0
 18245                                  	; (Windows ME IO.SYS - BIOSCODE:67ABh)
 18246 00002A5D C43E[A205]              	les	di,[THISCDS] 
 18247                                  
 18248                                  	;test	word [es:di+43h],8000h
 18249                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 18250                                  	;test	byte [es:di+44h],80h
 18251 00002A61 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 18252 00002A66 7403                    	JZ	short IOCTLShare
 18253                                  
 18254                                  	;or	dx,1000h ; (MSDOS 3.3)
 18255                                  
 18256                                  ;	Net devices don't return a device attribute word.
 18257                                  ;	Bit 12 = 1, meaning net device, all others = 0.
 18258                                  
 18259 00002A68 BA0010                  	MOV	DX,1000h ; MSDOS 6.0
 18260                                  
 18261                                  IOCTLShare:
 18262                                  	; 30/01/2024
 18263                                  	; ds = ss = DOSDATA segment
 18264                                  	;push	ss
 18265                                  	;pop	ds
 18266                                  	
 18267 00002A6B BE[BE03]                	MOV	SI,OPENBUF
 18268 00002A6E 80C341                  	ADD	BL,"A"	; 41h
 18269 00002A71 881C                    	MOV	[SI],BL
 18270 00002A73 C744013A00              	MOV	WORD [SI+1],003AH ; ":",0
 18271 00002A78 B80003                  	MOV	AX,0300h
 18272 00002A7B F8                      	CLC
 18273                                  	;INT	int_IBM
 18274 00002A7C CD2A                    	int     2Ah	; Microsoft Networks - CHECK DIRECT I/O
 18275                                  			; DS:SI -> ASCIZ disk device name 
 18276                                  			; (may be full path or only drive
 18277                                  			; specifier--must include the colon)
 18278                                  			; Return: CF clear if absolute disk access allowed
 18279 00002A7E 7303                    	JNC	short IOCTLLocal	; Not shared
 18280                                  	;OR	DX,0200H		; Shared, bit 9
 18281                                  	; 17/12/2022
 18282 00002A80 80CE02                  	or	dh,02h
 18283                                  IOCTLLocal:
 18284                                  	;test	word [es:di+43h],1000h
 18285                                  	;TEST	word [ES:DI+curdir.flags],curdir_local
 18286                                  	;test	byte [es:di+44h],10h
 18287 00002A83 26F6454410              	TEST	byte [ES:DI+curdir.flags+1],(curdir_local>>8)
 18288                                  	;JZ	short ioctl_set_DX
 18289                                  	; 16/12/2022
 18290 00002A88 7403                    	jz	short _ioctl_set_DX
 18291                                  	;OR	DX,8000h
 18292                                  	; 17/12/2022
 18293 00002A8A 80CE80                  	or	dh,80h
 18294                                  ;ioctl_set_DX:
 18295                                  _ioctl_set_DX:
 18296                                  	; 16/12/2022
 18297 00002A8D E977FE                  	jmp	ioctl_set_dx
 18298                                  ; 16/12/2022
 18299                                  %if 0	
 18300                                  	call	Get_User_Stack
 18301                                  	MOV	[SI+user_env.user_DX],DX
 18302                                  	;;jmp	SYS_RET_OK
 18303                                  	;; 25/06/2019
 18304                                  	;jmp	SYS_RET_OK_clc
 18305                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18306                                  ioctl_gd_ok_j:
 18307                                  	jmp	short ioctl_da_ok_j
 18308                                  %endif
 18309                                  
 18310                                  ioctl_drv_err:
 18311 00002A90 B00F                    	mov	al,error_invalid_drive ; 0Fh
 18312                                  ioctl_gd_err_j:	; 11/11/2022
 18313 00002A92 E9E5DB                  	jmp	SYS_RET_ERR
 18314                                  
 18315                                  ;--------------------------------------------------------------------------
 18316                                  ;
 18317                                  ; IOCTL: AL = A
 18318                                  ;
 18319                                  ; ENTRY: DS = DOSDATA
 18320                                  ;
 18321                                  ;--------------------------------------------------------------------------
 18322                                  
 18323                                  ioctl_handle_redir:
 18324 00002A95 E8C945                  	call	SFFromHandle		; ES:DI -> SFT
 18325 00002A98 7303                    	JNC	short ioctl_got_sft	; have valid handle
 18326 00002A9A E92EFE                  	jmp	ioctl_bad_handle ; 10/08/2018
 18327                                  
 18328                                  ioctl_got_sft:
 18329                                  	;mov	dx,[es:di+5]
 18330 00002A9D 268B5505                	MOV	DX,[ES:DI+SF_ENTRY.sf_flags] ; Get flags
 18331                                  	;JMP	short ioctl_set_DX	; pass dx to user and return
 18332                                  	; 16/12/2022
 18333 00002AA1 EBEA                    	jmp	short _ioctl_set_DX
 18334                                  
 18335                                  	; 16/12/2022
 18336                                  ;ioctl_bad_funj:
 18337                                  	;JMP	ioctl_bad_fun
 18338                                  
 18339                                  ;--------------------------------------------------------------------------
 18340                                  ;
 18341                                  ; IOCTL: AL= 4,5
 18342                                  ;
 18343                                  ; ENTRY: DS = DOSDATA
 18344                                  ;	 SI = user's DS
 18345                                  ;
 18346                                  ;
 18347                                  ; BUGBUG: Don't push anything on the stack between ioctl_get_dev: and 
 18348                                  ;         the call to Check_If_Net because Check_If_Net gets our
 18349                                  ;         return address off the stack if the drive is invalid.
 18350                                  ;
 18351                                  ;-------------------------------------------------------------------------
 18352                                  
 18353                                  	; 30/01/2024 - Retro DOS v5.0
 18354                                  
 18355                                  ioctl_get_dev:
 18356 00002AA3 E88F00                  	CALL	Check_If_Net
 18357                                  	;JNZ	short ioctl_bad_funj	; There are no "net devices", and they
 18358                                  					; certainly don't know how to do this
 18359                                  					; call.
 18360                                  	; 16/12/2022
 18361 00002AA6 7403                    	jz	short ioctl_do_string
 18362                                  ioctl_bad_funj:
 18363 00002AA8 E91FFF                  	JMP	ioctl_bad_fun
 18364                                  
 18365                                  ioctl_do_string:
 18366                                  	;test	word [es:di+4],4000h
 18367                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVIOCTL; See if device accepts control
 18368                                  	;test	byte [es:di+5],40h
 18369 00002AAB 26F6450540              	TEST	byte [ES:DI+SYSDEV.ATT+1],(DEVIOCTL>>8)
 18370 00002AB0 74F6                    	JZ	short ioctl_bad_funj		; NO
 18371                                  					; assume IOCTL read
 18372 00002AB2 C606[7E03]03            	MOV	byte [IOCALL_REQFUNC],DEVRDIOCTL  ; 3
 18373                                  
 18374 00002AB7 A801                    	TEST	AL,1			; is it func. 4/5 or 2/3
 18375 00002AB9 7405                    	JZ	short ioctl_control_call ; it is read. goto ioctl_control_call
 18376                                  
 18377                                  					; it is an IOCTL write
 18378 00002ABB C606[7E03]0C            	MOV	byte [IOCALL_REQFUNC],DEVWRIOCTL ; 12
 18379                                  
 18380                                  ioctl_control_call:
 18381                                  	; 30/01/2024
 18382 00002AC0 B016                    	MOV	AL,DRDWRHL ; 22	; MSDOS 6.22 MSDOS.SYS, Windows ME IO.SYS
 18383                                  	;mov	al,20 ; PCDOS 7.1 IBMDOS.COM
 18384                                  ioctl_setup_pkt:
 18385 00002AC2 88DC                    	MOV	AH,BL			; Unit number
 18386 00002AC4 A3[7C03]                	MOV	[IOCALL_REQLEN],AX
 18387 00002AC7 31C0                    	XOR	AX,AX
 18388 00002AC9 A3[7F03]                	MOV	[IOCALL_REQSTAT],AX ; 0
 18389 00002ACC A2[8903]                	MOV	[IOMED],AL
 18390 00002ACF 890E[8E03]              	MOV	[IOSCNT],CX
 18391 00002AD3 8916[8A03]              	MOV	[IOXAD],DX
 18392 00002AD7 8936[8C03]              	MOV	[IOXAD+2],SI
 18393 00002ADB 06                      	PUSH	ES
 18394 00002ADC 1F                      	POP	DS
 18395 00002ADD 89FE                    	MOV	SI,DI			; DS:SI -> driver
 18396 00002ADF 16                      	PUSH	SS
 18397 00002AE0 07                      	POP	ES
 18398                                  
 18399 00002AE1 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 18400                                  ioctl_do_IO:
 18401 00002AE4 E83E25                  	call	DEVIOCALL2
 18402                                  
 18403                                  ;hkn; SS override for IOCALL
 18404                                  	;test	word [SS:IOCALL_REQSTAT],8000h
 18405                                  	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
 18406                                  	;test	byte [SS:IOCALL_REQSTAT+1],80h
 18407 00002AE7 36F606[8003]80          	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
 18408 00002AED 7507                    	JNZ	short ioctl_string_err
 18409                                  
 18410                                  ;hkn; SS override
 18411 00002AEF 36A1[8E03]              	MOV	AX,[SS:IOSCNT]		; Get actual bytes transferred
 18412                                  	; 16/12/2022
 18413 00002AF3 E97ADB                  	jmp	SYS_RET_OK
 18414                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18415                                  	;jmp	short ioctl_gd_ok_j
 18416                                  
 18417                                  ioctl_string_err:
 18418 00002AF6 368B3E[7F03]            	MOV	DI,[SS:IOCALL_REQSTAT]	;Get Error
 18419                                  device_err:
 18420 00002AFB 81E7FF00                	AND	DI,STECODE ; 00FFh	; mask out irrelevant bits
 18421 00002AFF 89F8                    	MOV	AX,DI
 18422 00002B01 E8B033                  	call	SET_I24_EXTENDED_ERROR
 18423                                  
 18424                                  ;hkn; use SS override
 18425                                  ;hkn;	mov	ax,[CS:EXTERR]
 18426 00002B04 36A1[2403]              	mov	ax,[SS:EXTERR]
 18427                                  	;jmp	SYS_RET_ERR
 18428                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18429 00002B08 EB88                    	jmp	short ioctl_gd_err_j
 18430                                  
 18431                                  ; 17/05/2019 - Retro DOS v4.0
 18432                                  
 18433                                  ;--------------------------------------------------------------------------
 18434                                  ; Proc name : Get_Driver_BL
 18435                                  ;
 18436                                  ;	DS is DOSDATA
 18437                                  ;	BL is drive number (0=default)
 18438                                  ;	Returns pointer to device in ES:DI, unit number in BL if carry clear
 18439                                  ;	No regs modified
 18440                                  ;
 18441                                  ;---------------------------------------------------------------------------
 18442                                  
 18443                                  	; 30/01/2024 - Retro DOS v5.0
 18444                                  
 18445                                  Get_Driver_BL:
 18446 00002B0A 50                      	PUSH	AX
 18447 00002B0B 88D8                    	MOV	AL,BL			; Drive
 18448 00002B0D E87549                  	call	GETTHISDRV
 18449 00002B10 7221                    	jc	short ioctl_bad_drv
 18450 00002B12 30DB                    	XOR	BL,BL			; Unit zero on Net device
 18451 00002B14 C606[2303]03            	MOV	byte [EXTERR_LOCUS],errLOC_Net ; 3
 18452 00002B19 C43E[A205]              	LES	DI,[THISCDS]
 18453                                  	;test	word [es:di+43h],8000h
 18454                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 18455                                  	;test	byte [es:di+44h],80h
 18456 00002B1D 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 18457                                  	;les	di,[es:di+45h]
 18458 00002B22 26C47D45                	LES	DI,[ES:DI+curdir.devptr] ; ES:DI -> Dpb or net dev
 18459 00002B26 750B                    	JNZ	short got_dev_ptr	 ; Is net
 18460                                  	;;;
 18461                                  	; 30/01/2024 - PCDOS 7.1 IBMDOS.COM
 18462                                  	;MOV	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 18463 00002B28 E8D3E7                  	call	set_exerr_locus_disk
 18464                                  	;;;
 18465                                  	;mov	bl,[es:di+1]
 18466 00002B2B 268A5D01                	MOV	BL,[ES:DI+DPB.UNIT]	; Unit number
 18467                                  	;les	di,[es:di+13h]
 18468 00002B2F 26C47D13                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Driver addr
 18469                                  got_dev_ptr:
 18470                                  	; 30/01/2024
 18471                                  	; cf=0
 18472                                  	;CLC
 18473                                  ioctl_bad_drv:
 18474 00002B33 58                      	POP	AX
 18475 00002B34 C3                      	retn
 18476                                  
 18477                                  ;-------------------------------------------------------------------------
 18478                                  ; Proc Name : Check_If_Net:
 18479                                  ;
 18480                                  ;
 18481                                  ; Checks if the device is over the net or not. Returns result in ZERO flag.
 18482                                  ; If no device is found, the return address is popped off the stack, and a
 18483                                  ; jump is made to ioctl_drv_err.
 18484                                  ;
 18485                                  ; On Entry:
 18486                                  ; Registers same as those for Get_Driver_BL
 18487                                  ;
 18488                                  ; On Exit:
 18489                                  ; ZERO flag	- set if not a net device
 18490                                  ;		- reset if net device
 18491                                  ; ES:DI -> the device
 18492                                  ;
 18493                                  ;
 18494                                  ; BUGBUG: This function assumes the following stack setup on entry
 18495                                  ;
 18496                                  ;	  SP+2 -> Error return address
 18497                                  ;	  SP   -> Normal return address
 18498                                  ;
 18499                                  ;-------------------------------------------------------------------------
 18500                                  
 18501                                  	; 30/01/2024 - Retro DOS v5.0
 18502                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:639Ch
 18503                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6A91h
 18504                                  	; Windows ME IO.SYS - BIOSCODE:68E1h
 18505                                  
 18506                                  Check_If_Net:
 18507                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18508 00002B35 E8D2FF                  	CALL	Get_Driver_BL
 18509 00002B38 7201                    	JC	short ioctl_drv_err_pop	; invalid drive letter
 18510                                  
 18511                                  ; 30/01/2024 ('Get_Driver_BL' returns with
 18512                                  ;	      'curdir_isnet' condition/ZF, no need to a second test)
 18513                                  %if 0
 18514                                  	;;;
 18515                                  	; (PCDOS 7.1 IBMDOS.COM, Windows ME IO.SYS)
 18516                                  	PUSH	ES
 18517                                  	PUSH	DI
 18518                                  	LES	DI,[THISCDS]
 18519                                  	;test	word [es:di+43h],8000h
 18520                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 18521                                  	;test	byte [es:di+44h],80h
 18522                                  	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 18523                                  	POP	DI
 18524                                  	POP	ES
 18525                                  	;;;
 18526                                  %endif
 18527 00002B3A C3                      	retn
 18528                                  
 18529                                  ioctl_drv_err_pop:
 18530 00002B3B 58                      	pop	ax			; pop off return address
 18531 00002B3C E951FF                  	jmp	ioctl_drv_err
 18532                                  
 18533                                  ioctl_bad_funj3:
 18534 00002B3F E988FE                  	jmp	ioctl_bad_fun
 18535                                  
 18536                                  ioctl_string_errj:
 18537 00002B42 EBB2                    	jmp	short ioctl_string_err  ; 25/05/2019
 18538                                  
 18539                                  ;--------------------------------------------------------------------------
 18540                                  ;
 18541                                  ; IOCTL: AL = E, F
 18542                                  ;
 18543                                  ; ENTRY: DS = DOSDATA
 18544                                  ;
 18545                                  ;
 18546                                  ; BUGBUG: Don't push anything on the stack between ioctl_drive_owner: and 
 18547                                  ;         the call to Check_If_Net because Check_If_Net gets our
 18548                                  ;         return address off the stack if the drive is invalid.
 18549                                  ;
 18550                                  ;--------------------------------------------------------------------------
 18551                                  
 18552                                  ioctl_drive_owner:
 18553                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18554 00002B44 E8EEFF                  	Call	Check_If_Net
 18555 00002B47 75F6                    	JNZ	short ioctl_bad_funj3 	; There are no "net devices", and they
 18556                                  					;   certainly don't know how to do this
 18557                                  					;   call.
 18558                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320	; See if device can handle this
 18559                                  	; 09/09/2018
 18560                                  	;test	byte [es:di+4],40h
 18561 00002B49 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 18562 00002B4E 74EF                    	JZ	short ioctl_bad_funj3 	; NO
 18563                                  	;mov	byte [IOCALL_REQFUNC],23
 18564 00002B50 C606[7E03]17            	mov	byte [IOCALL_REQFUNC],DEVGETOWN	; default to get owner
 18565 00002B55 3C0E                    	cmp	al,0Eh			; Get Owner ?
 18566 00002B57 7405                    	jz	short GetOwner
 18567                                  SetOwner:
 18568 00002B59 C606[7E03]18            	MOV	byte [IOCALL_REQFUNC],DEVSETOWN ; 24
 18569                                  GetOwner:
 18570 00002B5E B00D                    	MOV	AL,OWNHL ; 13
 18571 00002B60 88DC                    	MOV	AH,BL			; Unit number
 18572 00002B62 A3[7C03]                	MOV	[IOCALL_REQLEN],AX
 18573 00002B65 31C0                    	XOR	AX,AX
 18574 00002B67 A3[7F03]                	MOV	[IOCALL_REQSTAT],AX
 18575 00002B6A 06                      	PUSH	ES
 18576 00002B6B 1F                      	POP	DS
 18577 00002B6C 89FE                    	MOV	SI,DI			; DS:SI -> driver
 18578 00002B6E 16                      	PUSH	SS
 18579 00002B6F 07                      	POP	ES
 18580 00002B70 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 18581 00002B73 1E                      	push	ds
 18582 00002B74 56                      	push	si
 18583 00002B75 E8AD24                  	call	DEVIOCALL2
 18584 00002B78 5E                      	pop	si
 18585 00002B79 1F                      	pop	ds
 18586                                  ;hkn; SS override
 18587                                  	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
 18588                                  	;test	byte [SS:IOCALL_REQSTAT+1],80h
 18589 00002B7A 36F606[8003]80          	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
 18590 00002B80 75C0                    	jnz	short ioctl_string_errj
 18591 00002B82 36A0[7D03]              	MOV	AL,[SS:IOCALL_REQUNIT]	; Get owner returned by device
 18592                                  					; owner returned is 1-based.
 18593 00002B86 E9E7DA                  	jmp	SYS_RET_OK
 18594                                  
 18595                                  ;============================================================================
 18596                                  ; DELETE.ASM, MSDOS 6.0, 1991
 18597                                  ;============================================================================
 18598                                  ; 07/08/2018 - Retro DOS v3.0
 18599                                  ; 17/05/2019 - Retro DOS v4.0
 18600                                  
 18601                                  ;	TITLE	DOS_DELETE - Internal DELETE call for MS-DOS
 18602                                  ;	NAME	DOS_DELETE
 18603                                  
 18604                                  ;
 18605                                  ;	Microsoft Confidential
 18606                                  ;	Copyright (C) Microsoft Corporation 1991
 18607                                  ;	All Rights Reserved.
 18608                                  ;
 18609                                  
 18610                                  ;**	DELETE.ASM - Low level routine for deleting files
 18611                                  ;----------------------------------------------------------------------------
 18612                                  ;		DOS_DELETE
 18613                                  ;		REN_DEL_Check
 18614                                  ;		FastOpen_Delete	       ; DOS 3.3
 18615                                  ;		FastOpen_Update	       ; DOS 3.3
 18616                                  
 18617                                  ;   Revision history:
 18618                                  ;
 18619                                  ;   A000  version 4.00	Jan. 1988
 18620                                  ;   A001  Fastopen Rename fix	April 1989
 18621                                  
 18622                                  ;Installed = TRUE
 18623                                  
 18624                                  ;	i_need	NoSetDir,BYTE
 18625                                  ;	i_need	Creating,BYTE
 18626                                  ;	i_need	DELALL,BYTE
 18627                                  ;	i_need	THISDPB,DWORD
 18628                                  ;	i_need	THISSFT,DWORD
 18629                                  ;	i_need	THISCDS,DWORD
 18630                                  ;	i_need	CURBUF,DWORD
 18631                                  ;	i_need	ATTRIB,BYTE
 18632                                  ;	i_need	SATTRIB,BYTE
 18633                                  ;	i_need	WFP_START,WORD
 18634                                  ;	i_need	REN_WFP,WORD			 ;BN001
 18635                                  ;	i_need	NAME1,BYTE			 ;BN001
 18636                                  ;	i_need	FoundDel,BYTE
 18637                                  ;	i_need	AUXSTACK,BYTE
 18638                                  ;	i_need	VOLCHNG_FLAG,BYTE
 18639                                  ;	i_need	JShare,DWORD
 18640                                  ;	i_need	FastOpenTable,BYTE		  ; DOS 3.3
 18641                                  ;	i_need	FastTable,BYTE			  ; DOS 4.00
 18642                                  ;
 18643                                  ;	i_need	Del_ExtCluster,WORD		  ; DOS 4.00
 18644                                  ;
 18645                                  ;	i_need	SAVE_BX,WORD			  ; DOS 4.00
 18646                                  ;	i_need	DMAADD,DWORD
 18647                                  ;	i_need	RENAMEDMA,BYTE
 18648                                  
 18649                                  ;----------------------------------------------------------------------------
 18650                                  ;
 18651                                  ; Procedure Name : DOS_DELETE
 18652                                  ;
 18653                                  ; Inputs:
 18654                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 18655                                  ;		terminated)
 18656                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 18657                                  ;		( = -1 if current dir not involved, else
 18658                                  ;		 Points to first char after last "/" of current dir part)
 18659                                  ;	[THISCDS] Points to CDS being used
 18660                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 18661                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 18662                                  ; Function:
 18663                                  ;	Delete the specified file(s)
 18664                                  ; Outputs:
 18665                                  ;	CARRY CLEAR
 18666                                  ;		OK
 18667                                  ;	CARRY SET
 18668                                  ;	    AX is error code
 18669                                  ;		error_file_not_found
 18670                                  ;			Last element of path not found
 18671                                  ;		error_path_not_found
 18672                                  ;			Bad path (not in curr dir part if present)
 18673                                  ;		error_bad_curr_dir
 18674                                  ;			Bad path in current directory part of path
 18675                                  ;		error_access_denied
 18676                                  ;			Attempt to delete device or directory
 18677                                  ;		***error_sharing_violation***
 18678                                  ;			Deny both access required, generates an INT 24.
 18679                                  ;			This error is NOT returned. The INT 24H is generated,
 18680                                  ;			  and the file is ignored (not deleted). Delete will
 18681                                  ;			  simply continue on looking for more files.
 18682                                  ;			  Carry will NOT be set in this case.
 18683                                  ; DS preserved, others destroyed
 18684                                  ;
 18685                                  ;----------------------------------------------------------------------------
 18686                                  
 18687                                  FILEFOUND   equ 01h
 18688                                  FILEDELETED equ 10h
 18689                                  
 18690                                  	; 12/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 18691                                  	; DOSCODE:63E9h (MSDOS 5.0, MSDOS.SYS)
 18692                                  
 18693                                  	; 30/01/2024 - Retro DOS v5.0 (Modified MSDOS 5.0 IBMDOS.COM)
 18694                                  	; DOSCODE:6B11h (PCDOS 7.1, IBMDOS.COM)
 18695                                  
 18696                                  DOS_DELETE:
 18697                                  
 18698                                  ;hkn; DOS_Delete is called from file.asm and fcbio.asm. DS has been set up 
 18699                                  ;hkn; appropriately at this point.
 18700                                  
 18701 00002B89 E8B5EC                  	call	TestNet
 18702 00002B8C 7306                    	JNC	short LOCAL_DELETE
 18703                                  
 18704                                  ;IF NOT Installed
 18705                                  ;	transfer NET_DELETE
 18706                                  ;ELSE
 18707                                  	;MOV	AX,(MultNET SHL 8) | 19
 18708                                  	;INT	2FH
 18709                                  	;return
 18710                                  
 18711 00002B8E B81311                  	mov	ax,1113h
 18712 00002B91 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
 18713                                  			; SS = DS = DOS CS, SDA first filename pointer -> 
 18714                                  			;		fully-qualified filename in DOS CS
 18715                                  			; SDA CDS pointer -> current directory structure for drive with file
 18716                                  			; Return: CF set on error
 18717 00002B93 C3                      	retn
 18718                                  ;ENDIF
 18719                                  
 18720                                  LOCAL_DELETE:
 18721 00002B94 C606[6F05]00            	MOV	byte [FOUNDDEL],0	; No files found and no files deleted
 18722 00002B99 E867ED                  	call	ECritDisk
 18723                                  	;mov	word [CREATING],0E500h
 18724 00002B9C C706[7E05]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Assume not del *.*
 18725 00002BA2 8B36[B205]              	MOV	SI,[WFP_START]
 18726                                  SKPNUL:
 18727 00002BA6 AC                      	LODSB
 18728 00002BA7 08C0                    	OR	AL,AL
 18729 00002BA9 75FB                    	JNZ	short SKPNUL		; go to end
 18730 00002BAB 83EE04                  	SUB	SI,4			; Back over possible "*.*"
 18731 00002BAE 813C2A2E                	CMP	WORD [SI],2E2Ah ; "*."
 18732 00002BB2 7506                    	JNZ	short TEST_QUEST
 18733 00002BB4 807C022A                	CMP	BYTE [SI+2],"*"
 18734 00002BB8 741F                    	JZ	short CHECK_ATTS
 18735                                  TEST_QUEST:
 18736 00002BBA 83EE09                  	SUB	SI,9		; Back over possible "????????.???"
 18737 00002BBD 87FE                    	XCHG	DI,SI
 18738                                  
 18739 00002BBF 16                      	push	ss
 18740                                  	;pop	ds ; ! Retro DOS v3.0 BUG !
 18741 00002BC0 07                      	pop	es ; 17/05/2019
 18742                                  
 18743 00002BC1 B83F3F                  	MOV	AX,"??" ; 3F3Fh
 18744 00002BC4 B90400                  	MOV	CX,4		; four sets of "??"
 18745 00002BC7 F3AF                    	REPE	SCASW
 18746 00002BC9 751C                    	JNZ	short NOT_ALL
 18747 00002BCB 87FE                    	XCHG	DI,SI
 18748 00002BCD AD                      	LODSW
 18749 00002BCE 3D2E3F                  	CMP	AX,3F2Eh ; ".?"
 18750 00002BD1 7514                    	JNZ	short NOT_ALL
 18751 00002BD3 AD                      	LODSW
 18752 00002BD4 3D3F3F                  	CMP	AX,"??"
 18753 00002BD7 750E                    	JNZ	short NOT_ALL
 18754                                  CHECK_ATTS:
 18755 00002BD9 A0[6D05]                	MOV	AL,[SATTRIB]
 18756                                  	;and	al,1Fh
 18757 00002BDC 241F                    	AND	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 18758                                  					; Look only at hidden bits
 18759                                  	;cmp	al,1Fh
 18760 00002BDE 3C1F                    	CMP	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 18761                                  					; All must be set
 18762 00002BE0 7505                    	JNZ	short NOT_ALL
 18763                                  
 18764                                  ; NOTE WARNING DANGER-----
 18765                                  ;    This DELALL stuff is not safe. It allows directories to be deleted.
 18766                                  ;	It should ONLY be used by FORMAT in the ROOT directory.
 18767                                  
 18768 00002BE2 C606[7F05]00            	MOV	byte [DELALL],0		; DEL *.* - flag deleting all
 18769                                  NOT_ALL:
 18770 00002BE7 C606[4C03]01            	MOV	byte [NoSetDir],1
 18771 00002BEC E8EB1C                  	call	GetPathNoSet
 18772 00002BEF 7312                    	JNC	short Del_found
 18773 00002BF1 750B                    	JNZ	short _bad_path
 18774 00002BF3 08C9                    	OR	CL,CL
 18775 00002BF5 7407                    	JZ	short _bad_path
 18776                                  No_file:
 18777 00002BF7 B80200                  	MOV	AX,error_file_not_found
 18778                                  ErrorReturn:
 18779 00002BFA F9                      	STC
 18780                                  	;call	LCritDisk
 18781                                  	;retn
 18782                                  	; 18/12/2022
 18783 00002BFB E932ED                  	jmp	LCritDisk
 18784                                  
 18785                                  _bad_path:
 18786 00002BFE B80300                  	MOV	AX,error_path_not_found
 18787 00002C01 EBF7                    	JMP	short ErrorReturn
 18788                                  
 18789                                  Del_found:
 18790 00002C03 750C                    	JNZ	short NOT_DIR		; Check for dir specified
 18791 00002C05 803E[7F05]00            	CMP	byte [DELALL],0		; DelAll = 0 allows delete of dir.
 18792 00002C0A 7405                    	JZ	short NOT_DIR
 18793                                  Del_access_err:
 18794 00002C0C B80500                  	MOV	AX,error_access_denied
 18795 00002C0F EBE9                    	JMP	short ErrorReturn
 18796                                  
 18797                                  NOT_DIR:
 18798 00002C11 08E4                    	OR	AH,AH			; Check if device name
 18799 00002C13 78F7                    	JS	short Del_access_err	; Can't delete I/O devices
 18800                                  
 18801                                  ; Main delete loop. CURBUF+2:BX points to a matching directory entry.
 18802                                  
 18803                                  DELFILE:
 18804 00002C15 800E[6F05]01            	OR	byte [FOUNDDEL],FILEFOUND ; file found, not deleted yet
 18805                                  
 18806                                  ; If we are deleting the Volume ID, then we set VOLUME_CHNG flag to make
 18807                                  ; DOS issue a build BPB call the next time this drive is accessed.
 18808                                  
 18809 00002C1A 1E                      	PUSH	DS
 18810 00002C1B 8A26[7F05]              	MOV	AH,[DELALL]
 18811 00002C1F C53E[E205]              	LDS	DI,[CURBUF]
 18812                                  	
 18813                                  ;hkn; SS override
 18814 00002C23 36F606[6B05]01          	TEST	byte [SS:ATTRIB],attr_read_only ; are we deleting RO files too?
 18815 00002C29 7509                    	JNZ	short DoDelete		; yes
 18816                                  
 18817 00002C2B F6470B01                	TEST	byte [BX+dir_entry.dir_attr],attr_read_only
 18818 00002C2F 7403                    	JZ	short DoDelete		; not read only
 18819                                  
 18820                                  	; 30/01/2024 (PCDOS 7.1 IBMDOS.COM)
 18821                                  Skip_it:
 18822 00002C31 1F                      	POP	DS
 18823 00002C32 EB57                    	JMP	SHORT DELNXT		; Skip it (Note ES:BP not set)
 18824                                  
 18825                                  DoDelete:
 18826 00002C34 E8AF00                  	call	REN_DEL_Check		; Sets ES:BP = [THISDPB]
 18827                                  	;JNC	short DEL_SHARE_OK
 18828                                  	;POP	DS
 18829                                  	;JMP	SHORT DELNXT		; Skip it
 18830                                  	; 30/01/2024
 18831 00002C37 72F8                    	jc	short Skip_it
 18832                                  
 18833                                  DEL_SHARE_OK:
 18834                                  	; 17/05/2019 - Retro DOS v4.0
 18835                                  	; MSDOS 6.0
 18836                                  	;test	byte [di+5],40h
 18837 00002C39 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 18838                                  					;LB. if already dirty		  ;AN000;
 18839 00002C3D 7507                    	JNZ	short yesdirty		;LB.  don't increment dirty count ;AN000;
 18840 00002C3F E8FE38                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 18841                                  	;or	byte [di+5],40h
 18842 00002C42 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty
 18843                                  yesdirty:
 18844 00002C46 8827                    	mov	[bx],ah 
 18845                                  	;MOV	[BX+dir_entry.dir_name],AH ; Put in E5H or 0
 18846                                  	;;;
 18847                                  	; 30/01/2024 - Retro DOS v5.0
 18848                                  	; (PCDOS 7.1 IBMDOS.COM)
 18849 00002C48 31DB                    	xor	bx,bx ; 0
 18850                                  	;cmp	[es:bp+0Fh],bx
 18851 00002C4A 26395E0F                	cmp	[es:bp+DPB.FAT_SIZE],bx ; 0
 18852 00002C4E 7503                    	jnz     short yesdirty_fc_1	;  not FAT32
 18853 00002C50 8B5CFA                  	mov     bx,[si-6]		;  high word of the first cluster (FAT32)
 18854                                  yesdirty_fc_1:
 18855                                  	;mov	[ss:CLUSTNUM_HW],bx 
 18856 00002C53 89DA                    	mov	dx,bx ; * ; 30/01/2024 - Retro DOS v5.0
 18857                                  	;;;
 18858                                  
 18859 00002C55 8B1C                    	MOV	BX,[SI] 		; Get firclus pointer
 18860 00002C57 1F                      	POP	DS
 18861                                  	;;;
 18862 00002C58 8916[EF0A]              	mov	[CLUSTNUM_HW],dx ; * ; 30/01/2024 - Retro DOS v5.0
 18863                                  	;;;
 18864 00002C5C 800E[6F05]10            	OR	byte [FOUNDDEL],FILEDELETED ; 10h ; Deleted file
 18865                                  
 18866                                  	; 30/01/2024
 18867                                  	;CMP	BX,2
 18868                                  	;JB	short DELNXT		; File has invalid FIRCLUS (too small)
 18869                                  	;;;
 18870                                  	; 30/01/2024 - Retro DOS v5.0
 18871                                  	; (PCDOS 7.1 IBMDOS.COM)
 18872                                  	;cmp	word [CLUSTNUM_HW],0
 18873 00002C61 21D2                    	and	dx,dx ; 30/01/2024 - Retro DOS v5.0
 18874 00002C63 7505                    	jnz	short yesdirty_fc_2
 18875 00002C65 83FB02                  	cmp	bx,2
 18876 00002C68 7221                    	jb	short DELNXT		; File has invalid FIRCLUS (too small)
 18877                                  yesdirty_fc_2:
 18878                                  	;cmp	word [es:bp+0Fh],0
 18879 00002C6A 26837E0F00              	cmp	word [es:bp+DPB.FAT_SIZE],0
 18880 00002C6F 750C                    	jnz     short yesdirty_fc_3	; not FAT32
 18881                                  	;push	bx
 18882                                  	;mov	bx,[CLUSTNUM_HW]
 18883                                  	;;cmp	bx,[es:bp+2Fh]
 18884                                  	;cmp	bx,[es:bp+DPB.LAST_CLUSTER+2]
 18885                                  	;30/01/2024 - Retro DOS v5.0
 18886                                  	;mov	dx,[CLUSTNUM_HW]
 18887                                  	; dx = [CLUSTNUM_HW] ; *
 18888 00002C71 263B562F                	cmp	dx,[es:bp+DPB.LAST_CLUSTER+2]
 18889                                  	;pop	bx
 18890 00002C75 750A                    	jne	short yesdirty_fc_4
 18891                                  	;cmp	bx,[es:bp+2Dh]
 18892 00002C77 263B5E2D                	cmp	bx,[es:bp+DPB.LAST_CLUSTER]
 18893 00002C7B EB04                    	jmp     short yesdirty_fc_4
 18894                                  yesdirty_fc_3:
 18895                                  	;;;
 18896                                  	;cmp	bx,[es:bp+0Dh]
 18897 00002C7D 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 18898                                  yesdirty_fc_4:	; 30/01/2024
 18899 00002C81 7708                    	JA	short DELNXT		; File has invalid FIRCLUS (too big)
 18900                                  
 18901 00002C83 E8EE2B                  	call	RELEASE 		; Free file data
 18902 00002C86 7258                    	JC	short No_fileJ
 18903                                  
 18904                                  ; DOS 3.3  FastOpen
 18905                                  
 18906 00002C88 E8D900                  	CALL	FastOpen_Delete 	; delete the dir info in fastopen
 18907                                  
 18908                                  ; DOS 3.3  FastOpen
 18909                                  
 18910                                  DELNXT:
 18911 00002C8B C42E[8A05]              	LES	BP,[THISDPB]		; Possible to get here without this set
 18912 00002C8F E86E1A                  	call	GETENTRY		; Registers need to be reset
 18913 00002C92 724C                    	JC	short No_fileJ
 18914 00002C94 E8A719                  	call	NEXTENT
 18915                                  	;JNC	short DELFILE
 18916                                  	; 30/01/2024
 18917 00002C97 7203                    	jc	short DELNXT2
 18918 00002C99 E979FF                  	jmp	DELFILE
 18919                                  DELNXT2:
 18920 00002C9C C42E[8A05]              	LES	BP,[THISDPB]		; NEXTENT sets ES=DOSGROUP
 18921                                  	
 18922                                  	;;;
 18923                                  	; 30/01/2024 - Retro DOS v5.0
 18924                                  	; (PCDOS 7.1 IBMDOS.COM)
 18925                                  	;
 18926 00002CA0 E8EE07                  	call	update_fat32_fsinfo
 18927                                  	;;;
 18928                                  
 18929                                  	; 12/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18930                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 18931                                  	;;mov	al,[es:bp+0]
 18932                                  	; 15/12/2022
 18933 00002CA3 268A4600                	MOV	AL,[ES:BP]
 18934 00002CA7 E88537                  	call	FLUSHBUF
 18935 00002CAA 7234                    	JC	short No_fileJ
 18936                                  ;
 18937                                  ; Now we need to test FoundDel for our flags. The cases to consider are:
 18938                                  ;
 18939                                  ;   not found not deleted		file not found
 18940                                  ;   not found	  deleted		*** impossible ***
 18941                                  ;	found not deleted		access denied (read-only)
 18942                                  ;	found	  deleted		no error
 18943                                  ;
 18944 00002CAC F606[6F05]10            	TEST	byte [FOUNDDEL],FILEDELETED ; did we delete a file?
 18945 00002CB1 7426                    	JZ	short DelError		; no, figure out what's wrong.
 18946                                  
 18947                                  ; We set VOLCHNG_FLAG to indicate that we have changed the volume label
 18948                                  ; and to force the DOS to issue a media check.
 18949                                  
 18950 00002CB3 F606[6B05]08            	TEST	byte [ATTRIB],attr_volume_id ; 8
 18951 00002CB8 741C                    	jz	short No_Set_Flag
 18952 00002CBA 50                      	PUSH	AX
 18953 00002CBB 06                      	PUSH	ES
 18954 00002CBC 57                      	PUSH	DI
 18955 00002CBD C43E[A205]              	LES	DI,[THISCDS]
 18956 00002CC1 268A25                  	MOV	AH,[ES:DI]		; Get drive
 18957 00002CC4 80EC41                  	SUB	AH,'A'                  ; Convert to 0-based
 18958 00002CC7 8826[A10A]              	mov	[VOLCHNG_FLAG],AH
 18959                                  	
 18960                                  	; MSDOS 6.0
 18961 00002CCB 30FF                    	XOR	BH,BH			;>32mb delete volume id from boot record ;AN000;
 18962 00002CCD E8EB04                  	call	Set_Media_ID		;>32mb set volume id to boot record	 ;AN000;
 18963                                  	 
 18964 00002CD0 E8B633                  	call	FATREAD_CDS		; force media check
 18965 00002CD3 5F                      	POP	DI
 18966 00002CD4 07                      	POP	ES
 18967 00002CD5 58                      	POP	AX
 18968                                  No_Set_Flag:
 18969                                  	;call	LCritDisk		; carry is clear
 18970                                  	;retn
 18971                                  	; 18/12/2022
 18972 00002CD6 E957EC                  	jmp	LCritDisk
 18973                                  DelError:
 18974 00002CD9 F606[6F05]01            	TEST	byte [FOUNDDEL],FILEFOUND ; not deleted. Did we find file?
 18975 00002CDE 7503                    	JNZ	short Del_access_errJ 	; yes. Access denied
 18976                                  No_fileJ:
 18977 00002CE0 E914FF                  	JMP	No_file ; 10/08/2018 		; Nope
 18978                                  Del_access_errJ:
 18979 00002CE3 E926FF                  	JMP	Del_access_err ; 10/08/2018
 18980                                  
 18981                                  ; 08/08/2018 - Retro DOS v3.0
 18982                                  
 18983                                  ;Break	<REN_DEL_Check - check for access for rename and delete>
 18984                                  ;---------------------------------------------------------------------------
 18985                                  ; Procedure Name : REN_DEL_Check
 18986                                  ;
 18987                                  ; Inputs:
 18988                                  ;	[THISDPB] set
 18989                                  ;	[CURBUF+2]:BX points to entry
 18990                                  ;	[CURBUF+2]:SI points to firclus field of entry
 18991                                  ;	[WFP_Start] points to name
 18992                                  ; Function:
 18993                                  ;	Check for Exclusive access on given file.
 18994                                  ;	  Used by RENAME, SET_FILE_INFO, and DELETE.
 18995                                  ; Outputs:
 18996                                  ;	ES:BP = [THISDPB]
 18997                                  ;	NOTE: The WFP string pointed to by [WFP_Start] Will be Modified. The
 18998                                  ;		last element will be loaded from the directory entry. This is
 18999                                  ;		so the name given to the sharer doesn't have any meta chars in
 19000                                  ;		it.
 19001                                  ;	Carry set if sharing violation, INT 24H generated
 19002                                  ;	    NOTE THAT AX IS NOT error_sharing_violation.
 19003                                  ;		This is because input AX is preserved.
 19004                                  ;		Caller must set the error if needed.
 19005                                  ;	Carry clear
 19006                                  ;		OK
 19007                                  ; AX,DS,BX,SI,DI preserved
 19008                                  ;---------------------------------------------------------------------------
 19009                                  
 19010                                  	; 31/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 19011                                  	
 19012                                  REN_DEL_Check:
 19013                                  
 19014 00002CE6 1E                      	PUSH	DS
 19015 00002CE7 57                      	PUSH	DI
 19016 00002CE8 50                      	PUSH	AX
 19017 00002CE9 53                      	PUSH	BX
 19018 00002CEA 56                      	PUSH	SI		; Save CURBUF pointers
 19019                                  	
 19020 00002CEB 16                      	push	ss
 19021 00002CEC 07                      	pop	es
 19022                                  
 19023                                  ;hkn; context ES will assume ES to DOSDATA
 19024                                  ;hkn; ASSUME	ES:DOSGROUP
 19025                                  
 19026                                  ;hkn; SS override
 19027 00002CED 368B3E[B205]            	MOV	DI,[SS:WFP_START] ; ES:DI -> WFP
 19028 00002CF2 89DE                    	MOV	SI,BX
 19029                                  
 19030                                  ;hkn; SS override
 19031 00002CF4 368E1E[E405]            	MOV	DS,[SS:CURBUF+2] ; DS:SI -> entry (FCB style name)
 19032 00002CF9 89FB                    	MOV	BX,DI		; Set backup limit for skipback
 19033                                  	;ADD	BX,2		; Skip over d: to point to leading '\'
 19034                                  	; 31/01/2024
 19035 00002CFB 43                      	inc	bx
 19036 00002CFC 43                      	inc	bx
 19037 00002CFD E8E1EA                  	call	StrLen		; CX is length of ES:DI including NUL
 19038 00002D00 49                      	DEC	CX		; Don't include nul in count
 19039 00002D01 01CF                    	ADD	DI,CX		; Point to NUL at end of string
 19040 00002D03 E8394A                  	call	SkipBack	; Back up one element
 19041 00002D06 47                      	INC	DI		; Point to start of last element
 19042                                  
 19043                                  	; 17/05/2019 - Retro DOS v4.0
 19044                                  ;hkn; SS override
 19045                                  	; MSDOS 6.0
 19046 00002D07 36893E[0106]            	MOV	[SS:SAVE_BX],DI	;IFS. save for DOS_RENAME   ;AN000;
 19047                                  	;
 19048 00002D0C E8C4F9                  	call	PackName	; Transfer name from entry to ASCIZ tail.
 19049 00002D0F 5E                      	POP	SI		; Get back entry pointers
 19050 00002D10 5B                      	POP	BX
 19051 00002D11 53                      	PUSH	BX
 19052 00002D12 56                      	PUSH	SI		; Back on stack
 19053                                  	
 19054 00002D13 16                      	push	ss
 19055 00002D14 1F                      	pop	ds
 19056                                  
 19057                                  ;hkn; context DS will assume ES to DOSDATA
 19058                                  ;hkn; ASSUME	DS:DOSGROUP
 19059                                  
 19060                                  ; Close the file if possible by us.
 19061                                  ;
 19062                                  ;if installed
 19063 00002D15 FF1E[C400]              	Call	far [JShare+(13*4)] ; 13 = ShCloseFile
 19064                                  ;else
 19065                                  ;	Call	ShCloseFile
 19066                                  ;endif
 19067                                  	;;;
 19068                                  	; 31/01/2024 - Retro DOS v5.0
 19069                                  	; PCDOS 7.1 IBMDOS.COM
 19070 00002D19 803E[0303]FF            	cmp	byte [fShare],0FFh
 19071 00002D1E 750A                    	jne	short rdc_1
 19072 00002D20 8C06[A005]              	mov	[THISSFT+2],es
 19073 00002D24 893E[9E05]              	mov	[THISSFT],di
 19074 00002D28 EB0A                    	jmp	short rdc_2
 19075                                  rdc_1:
 19076                                  	;;;
 19077 00002D2A 8C1E[A005]              	MOV	[THISSFT+2],DS
 19078                                  
 19079                                  ;hkn; AUXSTACK is in DOSDATA
 19080 00002D2E C706[9E05][6507]        	MOV	word [THISSFT],AUXSTACK-SF_ENTRY.size  ; RENAMEDMA+(384-59)
 19081                                  				; Scratch space
 19082                                  rdc_2:		; 30/01/2024
 19083 00002D34 30E4                    	XOR	AH,AH		; Indicate file to DOOPEN (high bit off)
 19084 00002D36 E8C527                  	call	DOOPEN		; Fill in SFT for share check
 19085 00002D39 C43E[9E05]              	LES	DI,[THISSFT]
 19086                                  	;mov	word [es:di+2],10h
 19087 00002D3D 26C745021000            	MOV	word [ES:DI+SF_ENTRY.sf_mode],SHARING_DENY_BOTH ; 10h
 19088                                  				; requires exclusive access
 19089                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],1 ; Pretend open
 19090 00002D43 26C7050100              	mov	word [ES:DI],1
 19091 00002D48 E81850                  	call	ShareEnter
 19092 00002D4B 720D                    	jc	short CheckDone
 19093 00002D4D C43E[9E05]              	LES	DI,[THISSFT]
 19094                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],0
 19095 00002D51 26C7050000              	mov	word [ES:DI],0	; Pretend closed and free
 19096                                  	
 19097 00002D56 E80550                  	call	ShareEnd	; Tell sharer we're done with THISSFT
 19098 00002D59 F8                      	CLC
 19099                                  CheckDone:
 19100 00002D5A C42E[8A05]              	LES	BP,[THISDPB]
 19101 00002D5E 5E                      	POP	SI
 19102 00002D5F 5B                      	POP	BX
 19103 00002D60 58                      	POP	AX
 19104 00002D61 5F                      	POP	DI
 19105 00002D62 1F                      	POP	DS
 19106 00002D63 C3                      	retn
 19107                                  
 19108                                  ;Break	<FastOpen_Delete - delete dir info in fastopen>
 19109                                  ;---------------------------------------------------------------------------
 19110                                  ; Procedure Name : FastOpen_Delete
 19111                                  ; Inputs:
 19112                                  ;	None
 19113                                  ; Function:
 19114                                  ;	Call FastOpen to delete the dir info.
 19115                                  ; Outputs:
 19116                                  ;	None
 19117                                  ;---------------------------------------------------------------------------
 19118                                  
 19119                                  	; 31/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 19120                                  
 19121                                  FastOpen_Delete:
 19122 00002D64 9C                      	PUSHF			; save flag
 19123 00002D65 56                      	PUSH	SI		; save registers
 19124 00002D66 57                      	push	di ; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19125 00002D67 53                      	PUSH	BX
 19126 00002D68 50                      	PUSH	AX
 19127                                  	;mov	si,[WFP_START] ; MSDOS 3.3
 19128                                  ;hkn; SS override
 19129                                  	; 17/05/2019 - Retro DOS v4.0
 19130                                  	; MSDOS 6.0
 19131 00002D69 368B36[B205]            	MOV	SI,[ss:WFP_START] ; ds:si points to path name
 19132                                  	
 19133 00002D6E B003                    	MOV	AL,FONC_delete	; al = 3
 19134                                  
 19135                                  ; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19136                                  %if 0 
 19137                                  fastinvoke:
 19138                                  ;hkn; FastTable is in DOSDATA
 19139                                  	MOV	BX,FastTable+2
 19140                                  	CALL	far [BX]	; call fastopen
 19141                                  	POP	AX		; restore registers
 19142                                  	POP	BX
 19143                                  	;pop	di ; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19144                                  	POP	SI
 19145                                  	POPF			; restore flag
 19146                                  	retn
 19147                                  %else
 19148 00002D70 EB0F                    	jmp	short fastinvoke ; 31/01/2024
 19149                                  %endif
 19150                                  
 19151                                  	; 13/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19152                                  	; DOSCODE:65A0h (MSDOS 5.0 MSDOS.SYS)
 19153                                  
 19154                                  	; 31/01/2024 Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 19155                                  	; DOSCODE:65B4h (MSDOS 6.22 MSDOS.SYS)
 19156                                  	; DOSCODE:6D07h (PCDOS 7.1 IBMDOS.COM)
 19157                                  
 19158                                  ;Break	<FastOpen_Rename - Rename directory>	   ; PTR 5622
 19159                                  ;---------------------------------------------------------------------------
 19160                                  ; PROCEDURE Name : FastOpen_Rename
 19161                                  ;
 19162                                  ; Inputs:
 19163                                  ;	 REN_WFP   = Path Name
 19164                                  ;	 NAME1	   = New Name
 19165                                  ; Function:
 19166                                  ;	Call FastOpen to rename the dir entry in the cache
 19167                                  ; Outputs:
 19168                                  ;	None
 19169                                  ;---------------------------------------------------------------------------
 19170                                  
 19171                                  FastOpen_Rename:
 19172                                  	; 17/05/2019 - Retro DOS v4.0
 19173                                  	; 08/08/2018 - Retro DOS v3.0
 19174                                  	; MSDOS 6.0
 19175 00002D72 9C                      	PUSHF			;AN001 save flag
 19176 00002D73 56                      	PUSH	SI		;AN001 save registers
 19177 00002D74 57                      	PUSH	DI		;AN001
 19178 00002D75 53                      	PUSH	BX		;AN001
 19179 00002D76 50                      	PUSH	AX		;AN001
 19180                                  	;
 19181                                  ;hkn; SS override
 19182 00002D77 368B36[B405]            	MOV	SI,[SS:REN_WFP]	;AN001	;;AN001  ds:si-->Path name addrs
 19183                                  
 19184                                  ;hkn; NAME1 is in DOSDATA
 19185 00002D7C BF[4B05]                	MOV	DI,NAME1	;;AN001  ds:di-->New name addrs
 19186                                  	;mov	al,6
 19187 00002D7F B006                    	MOV	AL,FONC_Rename	;;AN001  al = 6
 19188                                  
 19189                                  fastinvoke:	; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19190                                  	
 19191                                  ;hkn; FastTable is in DOSDATA
 19192 00002D81 BB[6512]                	MOV	BX,FastTable+2
 19193 00002D84 FF1F                    	CALL	far [BX]	;;AN001  call fastopen
 19194                                  	
 19195 00002D86 58                      	POP	AX		; restore registers  ;AN001
 19196 00002D87 5B                      	POP	BX				     ;AN001
 19197 00002D88 5F                      	POP	DI				     ;AN001
 19198 00002D89 5E                      	POP	SI				     ;AN001
 19199 00002D8A 9D                      	POPF			; restore flag	     ;AN001
 19200 00002D8B C3                      	retn					     ;AN001
 19201                                  
 19202                                  ;Break	<FastOpen_Update - update dir info in fastopen>
 19203                                  ;---------------------------------------------------------------------------
 19204                                  ; Procedure Name : FastOpen_Update
 19205                                  ;
 19206                                  ; Inputs:
 19207                                  ;	DL     drive number (A=0,B=1,,,)
 19208                                  ;	CX     first cluster #
 19209                                  ;	AH     0 updates dir entry
 19210                                  ;	       1 updates CLUSNUM , BP = new CLUSNUM
 19211                                  ;	ES:DI  directory entry
 19212                                  ; Function:
 19213                                  ;	Call FastOpen to update the dir info.
 19214                                  ; Outputs:
 19215                                  ;	None
 19216                                  ;---------------------------------------------------------------------------
 19217                                  
 19218                                  FastOpen_Update:
 19219 00002D8C 9C                      	PUSHF			; save flag
 19220 00002D8D 56                      	PUSH	SI
 19221 00002D8E 57                      	push	di ; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19222 00002D8F 53                      	PUSH	BX		; save regs
 19223 00002D90 50                      	PUSH	AX
 19224 00002D91 B004                    	MOV	AL,FONC_update	; al = 4
 19225 00002D93 EBEC                    	JMP	short fastinvoke
 19226                                  
 19227                                  	; 17/05/2019
 19228                                  
 19229                                  	; MSDOS 6.0
 19230                                  ;entry Fast_Dispatch		; future fastxxxx entry	;AN000;
 19231                                  ;---------------------------------------------------------------------------
 19232                                  Fast_Dispatch:
 19233                                  ;hkn; FastTable is in DOSDATA
 19234 00002D95 BE[6512]                	MOV	SI,FastTable+2	; index to the	     ;AN000;
 19235                                  ;hkn; use SS override
 19236 00002D98 36FF1C                  	CALL	far [SS:SI]	; RMFD call fastopen
 19237 00002D9B C3                      	retn
 19238                                  
 19239                                  ;============================================================================
 19240                                  ; RENAME.ASM, MSDOS 6.0, 1991
 19241                                  ;============================================================================
 19242                                  ; 08/08/2018 - Retro DOS v3.0
 19243                                  ; 17/05/2019 - Retro DOS v4.0
 19244                                  
 19245                                  ;	TITLE	DOS_RENAME - Internal RENAME call for MS-DOS
 19246                                  ;	NAME	DOS_RENAME
 19247                                  
 19248                                  ;**	Low level routine for renaming files
 19249                                  ;----------------------------------------------------------------------------
 19250                                  ;	DOS_RENAME
 19251                                  ;
 19252                                  ;	Modification history:
 19253                                  ;
 19254                                  ;	    Created: ARR 30 March 1983
 19255                                  
 19256                                  ;----------------------------------------------------------------------------
 19257                                  ;
 19258                                  ; Procedure Name : DOS_RENAME
 19259                                  ;
 19260                                  ; Inputs:
 19261                                  ;	[WFP_START] Points to SOURCE WFP string ("d:/" must be first 3
 19262                                  ;		chars, NUL terminated)
 19263                                  ;	[CURR_DIR_END] Points to end of Current dir part of string [SOURCE]
 19264                                  ;		( = -1 if current dir not involved, else
 19265                                  ;		 Points to first char after last "/" of current dir part)
 19266                                  ;	[REN_WFP] Points to DEST WFP string ("d:/" must be first 3
 19267                                  ;		chars, NUL terminated)
 19268                                  ;	[THISCDS] Points to CDS being used
 19269                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 19270                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 19271                                  ; Function:
 19272                                  ;	Rename the specified file(s)
 19273                                  ;	NOTE: This routine uses most of AUXSTACK as a temp buffer.
 19274                                  ; Outputs:
 19275                                  ;	CARRY CLEAR
 19276                                  ;	    OK
 19277                                  ;	CARRY SET
 19278                                  ;	    AX is error code
 19279                                  ;		error_file_not_found
 19280                                  ;			No match for source, or dest path invalid
 19281                                  ;		error_not_same_device
 19282                                  ;			Source and dest are on different devices
 19283                                  ;		error_access_denied
 19284                                  ;			Directory specified (not simple rename),
 19285                                  ;			Device name given, Destination exists.
 19286                                  ;			NOTE: In third case some renames may have
 19287                                  ;			 been done if metas.
 19288                                  ;		error_path_not_found
 19289                                  ;			Bad path (not in curr dir part if present)
 19290                                  ;			SOURCE ONLY
 19291                                  ;		error_bad_curr_dir
 19292                                  ;			Bad path in current directory part of path
 19293                                  ;			SOURCE ONLY
 19294                                  ;		error_sharing_violation
 19295                                  ;			Deny both access required, generates an INT 24.
 19296                                  ; DS preserved, others destroyed
 19297                                  ;
 19298                                  ;----------------------------------------------------------------------------
 19299                                  
 19300                                  	; 14/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19301                                  	; 31/01/2024 Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 19302                                  
 19303                                  DOS_RENAME:
 19304                                  
 19305                                  ;hkn; DOS_RENAME is called from file.asm and fcbio.asm. DS has been set up
 19306                                  ;hkn; at this point to DOSDATA.
 19307                                  
 19308 00002D9C E8A2EA                  	call	TestNet
 19309 00002D9F 7306                    	JNC	short LOCAL_RENAME
 19310                                  
 19311                                  ;IF NOT Installed
 19312                                  ;	transfer NET_RENAME
 19313                                  ;ELSE
 19314                                  	;MOV	AX,(MultNET SHL 8) OR 17
 19315                                  	;INT	2FH
 19316                                  	;return
 19317                                  
 19318 00002DA1 B81111                  	mov     ax, 1111h
 19319 00002DA4 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
 19320                                  			; SS = DS = DOS CS, 
 19321                                  			; SDA first filename pointer = offset of fully-qualified old name
 19322                                  			; SDA CDS pointer -> current directory
 19323                                  			; Return: CF set on error
 19324 00002DA6 C3                      	retn
 19325                                  ;ENDIF
 19326                                  
 19327                                  LOCAL_RENAME:
 19328 00002DA7 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 19329 00002DAC 8B36[B205]              	MOV	SI,[WFP_START]
 19330 00002DB0 8B3E[B405]              	MOV	DI,[REN_WFP]
 19331 00002DB4 8A04                    	MOV	AL,[SI]
 19332 00002DB6 8A25                    	MOV	AH,[DI]
 19333 00002DB8 0D2020                  	OR	AX,2020H		; Lower case
 19334 00002DBB 38E0                    	CMP	AL,AH
 19335 00002DBD 7405                    	JZ	short SAMEDRV
 19336 00002DBF B81100                  	MOV	AX,error_not_same_device ; 11h
 19337 00002DC2 F9                      	STC
 19338 00002DC3 C3                      	retn
 19339                                  
 19340                                  SAMEDRV:
 19341 00002DC4 FF36[2E03]              	PUSH	WORD [DMAADD+2]
 19342 00002DC8 FF36[2C03]              	PUSH	WORD [DMAADD]
 19343 00002DCC 8C1E[2E03]              	MOV	[DMAADD+2],DS
 19344                                  
 19345                                  ;hkn; RENAMEDMA is in DOSDATA
 19346 00002DD0 C706[2C03][2006]        	MOV	WORD [DMAADD],RENAMEDMA
 19347 00002DD6 C606[7005]00            	MOV	byte [FOUND_DEV],0	; Rename fails on DEVS, assume not a dev
 19348 00002DDB E825EB                  	call	ECritDisk
 19349 00002DDE E86807                  	call	DOS_SEARCH_FIRST	; Sets [NoSetDir] to 1, [CURBUF+2]:BX
 19350                                  					;    points to entry
 19351 00002DE1 7314                    	JNC	short Check_Dev
 19352 00002DE3 83F812                  	CMP	AX,error_no_more_files ; 12h
 19353 00002DE6 7503                    	JNZ	short GOTERR
 19354 00002DE8 B80200                  	MOV	AX,error_file_not_found ; 2
 19355                                  GOTERR:
 19356 00002DEB F9                      	STC
 19357                                  RENAME_POP:
 19358 00002DEC 8F06[2C03]              	POP	WORD [DMAADD]
 19359 00002DF0 8F06[2E03]              	POP	WORD [DMAADD+2]
 19360                                  	;call	LCritDisk
 19361                                  	;retn
 19362                                  	; 16/12/2022
 19363 00002DF4 E939EB                  	jmp	LCritDisk
 19364                                  
 19365                                  Check_Dev:
 19366                                  	; 17/05/2019 - Retro DOS v4.0
 19367                                  	;mov	ax,5
 19368 00002DF7 B80500                  	MOV	AX,error_access_denied	; Assume error
 19369                                  	
 19370                                  	; MSDOS 6.0
 19371 00002DFA 1E                      	PUSH	DS			      ;PTM.			    ;AN000;
 19372 00002DFB C536[2C03]              	LDS	SI,[DMAADD]		      ;PTM.  check if source a dir  ;AN000;
 19373                                  	;add	si,21
 19374 00002DFF 83C615                  	ADD	SI,find_buf.attr	      ;PTM.			    ;AN000;
 19375                                  	;test	byte [si+11],10h
 19376 00002E02 F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;PTM.	    ;AN000;
 19377 00002E06 7407                    	JZ	short notdir		      ;PTM.			    ;AN000;
 19378 00002E08 8B36[B405]              	MOV	SI,[REN_WFP]		      ;PTM.  if yes, make sure path ;AN000;
 19379 00002E0C E86FFA                  	call	Check_PathLen2		      ;PTM.   length < 67	    ;AN000;
 19380                                  notdir:
 19381 00002E0F 1F                      	POP	DS			      ;PTM.			    ;AN000;
 19382 00002E10 77D9                    	JA	short GOTERR		      ;PTM.			    ;AN000;
 19383                                  
 19384                                  	; MSDOS 3.3 & MSDOS 6.0
 19385 00002E12 803E[7005]00            	CMP	byte [FOUND_DEV],0
 19386 00002E17 75D2                    	JNZ	short GOTERR
 19387                                  
 19388                                  ; At this point a source has been found. There is search continuation info (a
 19389                                  ; la DOS_SEARCH_NEXT) for the source at RENAMEDMA, together with the first
 19390                                  ; directory entry found.
 19391                                  ; [THISCDS], [THISDPB], and [THISDRV] are set and will remain correct
 19392                                  ; throughout the RENAME since it is known at this point that the source and
 19393                                  ; destination are both on the same device.
 19394                                  ; [SATTRIB] is also set.
 19395                                  
 19396 00002E19 89DE                    	MOV	SI,BX
 19397                                  	;add	si,26
 19398 00002E1B 83C61A                  	ADD	SI,dir_entry.dir_first
 19399 00002E1E E8C5FE                  	call	REN_DEL_Check
 19400 00002E21 7305                    	JNC	short REN_OK1
 19401 00002E23 B82000                  	MOV	AX,error_sharing_violation  ; 20h
 19402 00002E26 EBC4                    	JMP	short RENAME_POP
 19403                                  
 19404                                  ;------------------------------------------------------------------------------
 19405                                  ; Check if the source is a file or directory. If file, delete the entry
 19406                                  ; from the Fastopen cache. If directory, rename it later
 19407                                  ;------------------------------------------------------------------------------
 19408                                  
 19409                                  REN_OK1:				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 19410                                  	; MSDOS 6.0
 19411                                  	; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19412                                  	;PUSH	SI
 19413 00002E28 C536[2C03]              	LDS	SI,[DMAADD]		;BN00X; PTM. check if source a dir ;AN000;
 19414                                  	;add	si,21
 19415 00002E2C 83C615                  	ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
 19416                                  	;test	byte [si+11],10h
 19417 00002E2F F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM. ;AN000;
 19418                                  	;JZ	short NOT_DIR1		;;BN00XPTM.			;AN000;
 19419 00002E33 7503                    	jnz	short SWAP_SOURCE ; 31/01/2024
 19420                                  	;POP	SI			;BN00X
 19421                                  	;JMP	SHORT SWAP_SOURCE	;BN00X
 19422                                  ;NOT_DIR1:				;;BN00X it is a file, delete the entry
 19423                                  	;POP	SI
 19424                                  
 19425                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19426 00002E35 E82CFF                  	call	FastOpen_Delete 	; delete dir info in fastopen DOS 3.3
 19427                                  SWAP_SOURCE:
 19428                                  	; MSDOS 3.3
 19429                                  	;MOV	SI,[REN_WFP]
 19430                                  	;MOV	[WFP_START],SI
 19431                                  	; MSDOS 6.0
 19432 00002E38 A1[B205]                	MOV	AX,[WFP_START]		; Swap source and destination
 19433 00002E3B 8B36[B405]              	MOV	SI,[REN_WFP]		; Swap source and destination
 19434 00002E3F 8936[B205]              	MOV	[WFP_START],SI		; WFP_START = Destination path
 19435 00002E43 A3[B405]                	MOV	[REN_WFP],AX		; REN_WFP   = Source path
 19436                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19437 00002E46 C706[B605]FFFF          	MOV	word [CURR_DIR_END],-1	; No current dir on dest
 19438                                  	;mov	word [CREATING],0E5FFh
 19439 00002E4C C706[7E05]FFE5          	MOV	WORD [CREATING],DIRFREE*256+0FFh  ; Creating, not DEL *.*
 19440                                  					; A rename is like a CREATE_NEW as far
 19441                                  					; as the destination is concerned.
 19442 00002E52 E8851A                  	call	GetPathNoSet
 19443                                  
 19444                                  ;   If this GETPATH fails due to file not found, we know all renames will work
 19445                                  ;   since no files match the destination name. If it fails for any other
 19446                                  ;   reason, the rename fails on a path not found, or whatever (also fails if
 19447                                  ;   we find a device or directory). If the GETPATH succeeds, we aren't sure
 19448                                  ;   if the rename should fail because we haven't built an explicit name by
 19449                                  ;   substituting for the meta chars in it. In this case the destination file
 19450                                  ;   spec with metas is in [NAME1] and the explicit source name is at RENAMEDMA
 19451                                  ;   in the directory entry part.
 19452                                  	
 19453 00002E55 722A                    	JC	short NODEST
 19454                                  	
 19455                                  	; MSDOS 6.0
 19456                                  	;JZ	short BAD_ACC 		; Dest string is a directory	;AC000;
 19457                                  	; !! MSDOS 3.3 !!
 19458                                  	;JZ	short BAD_ACC ; !!	; Dest string is a directory
 19459                                  
 19460 00002E57 08E4                    	OR	AH,AH			; Device?
 19461 00002E59 7933                    	JNS	short SAVEDEST		; No, continue
 19462                                  BAD_ACC:
 19463 00002E5B B80500                  	MOV	AX,error_access_denied
 19464 00002E5E F9                      	STC
 19465                                  RENAME_CLEAN:
 19466 00002E5F 9C                      	PUSHF				; Save carry state
 19467 00002E60 50                      	PUSH	AX			; and error code (if carry set)
 19468                                  	;;;
 19469                                  	; 31/01/2024 - Retro DOS v5.0
 19470                                  	; (PCDOS 7.1 IBMDOS.COM)
 19471 00002E61 C42E[8A05]              	les	bp,[THISDPB]
 19472 00002E65 E82906                  	call	update_fat32_fsinfo
 19473                                  	;;;
 19474 00002E68 A0[7605]                	MOV	AL,[THISDRV]
 19475 00002E6B E8C135                  	call	FLUSHBUF
 19476 00002E6E 58                      	POP	AX
 19477 00002E6F 803E[4A03]00            	CMP	byte [FAILERR],0
 19478 00002E74 7504                    	JNZ	short BAD_ERR		; User FAILed to I 24
 19479 00002E76 9D                      	POPF
 19480 00002E77 E972FF                  	JMP	RENAME_POP
 19481                                  
 19482                                  BAD_ERR:
 19483 00002E7A 58                      	POP	AX			; Saved flags
 19484                                  	; 16/12/202
 19485                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 19486                                  BAD_PATH: ; *
 19487 00002E7B B80300                  	MOV	AX,error_path_not_found
 19488 00002E7E E96AFF                  	JMP	GOTERR
 19489                                  
 19490                                  NODEST:
 19491 00002E81 75F8                    	JNZ	short BAD_PATH
 19492 00002E83 803E[4A03]00            	CMP	byte [FAILERR],0
 19493 00002E88 75F1                    	JNZ	short BAD_PATH		; Search for dest failed 
 19494                                  					; because user FAILed on I 24
 19495                                  	; 14/11/2022
 19496 00002E8A 08C9                    	OR	CL,CL
 19497                                  	;JNZ	short SAVEDEST
 19498                                  	; 17/05/2019
 19499 00002E8C 74ED                    	jz	short BAD_PATH ; *
 19500                                  ;BAD_PATH: ; *
 19501                                  ;	MOV	AX,error_path_not_found
 19502                                  ;	;STC
 19503                                  ;	;JMP	RENAME_POP
 19504                                  ;	; 17/05/2019
 19505                                  ;	jmp	GOTERR 
 19506                                  
 19507                                  ; 16/12/2022
 19508                                  %if 0
 19509                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 19510                                  	or	cl,cl
 19511                                  	jnz	short SAVEDEST
 19512                                  	;jz	short BAD_PATH ; *
 19513                                  BAD_PATH: ; *
 19514                                  	;mov	ax,3
 19515                                  	mov	ax,error_path_not_found
 19516                                  	stc
 19517                                  	jmp	RENAME_POP
 19518                                  %endif
 19519                                  
 19520                                  SAVEDEST:
 19521 00002E8E 16                      	push	ss
 19522 00002E8F 07                      	pop	es
 19523                                  
 19524                                  ;hkn; NAME1 & NAME2 is in DOSDATA
 19525 00002E90 BF[5705]                	MOV	DI,NAME2
 19526 00002E93 BE[4B05]                	MOV	SI,NAME1
 19527                                  
 19528 00002E96 B90B00                  	MOV	CX,11
 19529 00002E99 F3A4                    	REP	MOVSB			; Save dest with metas at NAME2
 19530                                  	;;;
 19531                                  	; 31/01/2024
 19532                                  	; (PCDOS 7.1 IBMDOS.COM)
 19533 00002E9B A1[E30A]                	mov	ax,[DIRSTART_HW]
 19534 00002E9E A3[ED0A]                	mov	[DESTSTART_HW],ax
 19535                                  	;;;
 19536 00002EA1 A1[C205]                	MOV	AX,[DIRSTART]
 19537 00002EA4 A3[6405]                	MOV	[DESTSTART],AX
 19538                                  BUILDDEST:
 19539                                  	; 31/01/2024
 19540                                  	;push	ss
 19541                                  	;pop	es			; needed due to JMP BUILDDEST below
 19542                                  
 19543                                  ;hkn; RENAMEDMA, NAME1, NAME2 in DOSDATA
 19544 00002EA7 BB[3506]                	MOV	BX,RENAMEDMA+21		; Source of replace chars
 19545 00002EAA BF[4B05]                	MOV	DI,NAME1		; Real dest name goes here
 19546 00002EAD BE[5705]                	MOV	SI,NAME2		; Raw dest
 19547                                  
 19548 00002EB0 B90B00                  	MOV	CX,11
 19549                                  
 19550                                  	; 17/05/2019 - Retro DOS v4.0
 19551                                  
 19552                                  	; MSDOS 6.0
 19553 00002EB3 E82601                  	CALL	NEW_RENAME		;IFS. replace ? chars	;AN000;
 19554                                  
 19555                                  	; MSDOS 3.3
 19556                                  
 19557                                  ; 08/08/2018 - Retro DOS v3.0
 19558                                  ; MSDOS 6.0 
 19559                                  ;---------------------------------------------------------------------------
 19560                                  ;Procedure: NEW_RENAME
 19561                                  ;
 19562                                  ;Input: DS:SI -> raw string with ?
 19563                                  ;	ES:DI -> destination string
 19564                                  ;	DS:BX -> source string
 19565                                  ;Function: replace ? chars of raw string with chars in source string and
 19566                                  ;	   put in destination string
 19567                                  ;Output: ES:DI-> new string
 19568                                  ;---------------------------------------------------------------------------
 19569                                  ;
 19570                                  ;NEW_RENAME:
 19571                                  ;NEWNAM:
 19572                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 341Ah
 19573                                  ;	LODSB
 19574                                  ;	CMP	AL,"?"
 19575                                  ;	JNZ	short NOCHG
 19576                                  ;	MOV	AL,[BX] 		; Get replace char
 19577                                  ;NOCHG:
 19578                                  ;	STOSB
 19579                                  ;	INC	BX			; Next replace char
 19580                                  ;	LOOP	NEWNAM
 19581                                  ;	; MSDOS 6.0
 19582                                  ;	;retn
 19583                                  
 19584                                  	; MSDOS 3.3 & MSDOS 6.0
 19585                                  	;mov	byte [ATTRIB],16h
 19586 00002EB6 C606[6B05]16            	MOV	byte [ATTRIB],attr_all	; Stop duplicates with any attributes
 19587 00002EBB C606[7E05]FF            	MOV	byte [CREATING],0FFH
 19588 00002EC0 E8C51C                  	call	DEVNAME 		; Check if we built a device name
 19589 00002EC3 7396                    	JNC	short BAD_ACC
 19590                                  	;;;
 19591                                  	; 31/01/2024
 19592                                  	; (PCDOS 7.1 IBMDOS.COM)
 19593 00002EC5 8B1E[ED0A]              	mov	bx,[DESTSTART_HW]
 19594 00002EC9 891E[F50A]              	mov	[ROOTCLUST_HW],bx
 19595                                  	;;;
 19596 00002ECD 8B1E[6405]              	MOV	BX,[DESTSTART]
 19597 00002ED1 C42E[8A05]              	LES	BP,[THISDPB]
 19598 00002ED5 E8EA18                  	call	SETDIRSRCH		; Reset search to start of dir
 19599 00002ED8 7281                    	JC	short BAD_ACC 		; Screw up
 19600 00002EDA E81717                  	call	FINDENTRY		; See if new name already exists
 19601                                  	;JNC	short BAD_ACC 		; Error if found
 19602                                  	; 31/01/2024
 19603 00002EDD 7346                    	jnc	short BAD_ACCJ
 19604 00002EDF 803E[4A03]00            	CMP	byte [FAILERR],0
 19605 00002EE4 753F                    	JNZ	short BAD_ACCJ		; Find failed because user FAILed to I 24
 19606 00002EE6 A1[6405]                	MOV	AX,[DESTSTART]		; DIRSTART of dest
 19607                                  	;;;
 19608                                  	; 31/01/2024
 19609 00002EE9 8B16[ED0A]              	mov	dx,[DESTSTART_HW]
 19610 00002EED C42E[8A05]              	les	bp,[THISDPB]
 19611 00002EF1 26837E0F00              	cmp	word [es:bp+DPB.FAT_SIZE],0
 19612                                  	;cmp	word [es:bp+0Fh],0
 19613 00002EF6 7506                    	jnz	short builddst_1	; not FAT32
 19614 00002EF8 3B16[3106]              	cmp	dx,[RENAMEDMA+17]	; DIRSTART_HW of source
 19615 00002EFC 7506                    	jne	short builddst_2
 19616                                  builddst_1:
 19617                                  	;;;
 19618 00002EFE 3B06[2F06]              	CMP	AX,[RENAMEDMA+15]	; DIRSTART of source
 19619 00002F02 7451                    	JZ	short SIMPLE_RENAME	; If =, just give new name
 19620                                  builddst_2:	; 31/01/2024
 19621                                  	;mov	al,[RENAMEDMA+32]
 19622 00002F04 A0[4006]                	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr]
 19623 00002F07 A810                    	TEST	AL,attr_directory ; 10h
 19624 00002F09 751A                    	JNZ	short BAD_ACCJ		; Can only do a simple rename on dirs,
 19625                                  					; otherwise the . and .. entries get
 19626                                  					; wiped.
 19627 00002F0B A2[6B05]                	MOV	[ATTRIB],AL
 19628 00002F0E 8C1E[A005]              	MOV	[THISSFT+2],DS
 19629                                  
 19630                                  ;hkn; AUXSTACK is in DOSDATA
 19631                                  	;mov	si,RENAMEDMA+145h
 19632 00002F12 BE[6507]                	MOV	SI,AUXSTACK-SF_ENTRY.size ; RENAMEDMA+325
 19633 00002F15 8936[9E05]              	MOV	[THISSFT],SI
 19634                                  	;mov	word [SI+2],2
 19635 00002F19 C744020200              	MOV	word [SI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 19636 00002F1E 31C9                    	XOR	CX,CX			; Set "device ID" for call into makenode
 19637 00002F20 E84324                  	call	RENAME_MAKE		; This is in mknode
 19638 00002F23 7303                    	JNC	short GOT_DEST
 19639                                  BAD_ACCJ:
 19640 00002F25 E933FF                  	JMP	BAD_ACC
 19641                                  
 19642                                  GOT_DEST:
 19643 00002F28 53                      	push	bx
 19644 00002F29 C43E[9E05]              	LES	DI,[THISSFT]		; RENAME_MAKE entered this into sharing
 19645 00002F2D E82E4E                  	call	ShareEnd		; we need to remove it.
 19646 00002F30 5B                      	pop	bx
 19647                                  
 19648                                  ; A zero length entry with the correct new name has now been made at
 19649                                  ;   [CURBUF+2]:BX.
 19650                                  
 19651 00002F31 C43E[E205]              	LES	DI,[CURBUF]
 19652                                  
 19653                                  ; 31/01/2024 - Retro DOS v5.0
 19654                                  %if 0
 19655                                  	; MSDOS 6.0
 19656                                  	;test	byte [es:di+5],40h
 19657                                  	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 19658                                  					;LB. if already dirty		  ;AN000;
 19659                                  	JNZ	short yesdirty1		;LB.  don't increment dirty count ;AN000;
 19660                                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 19661                                  	;or	byte [es:di+5],40h
 19662                                  	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 19663                                  yesdirty1:
 19664                                  %else
 19665                                  	; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19666 00002F35 E8FC35                  	call	SET_BUF_DIRTY
 19667                                  %endif
 19668 00002F38 89DF                    	MOV	DI,BX
 19669                                  	;add	di,11
 19670 00002F3A 83C70B                  	ADD	DI,dir_entry.dir_attr	; Skip name
 19671                                  
 19672                                  ;hkn; RENAMEDMA is in DOSDATA
 19673                                  	;mov	si,[RENAMEDMA+32]
 19674 00002F3D BE[4006]                	MOV	SI,RENAMEDMA+21+dir_entry.dir_attr
 19675                                  	;mov	cx,21
 19676 00002F40 B91500                  	MOV	CX,dir_entry.size-dir_entry.dir_attr
 19677 00002F43 F3A4                    	REP	MOVSB
 19678 00002F45 E86E00                  	CALL	GET_SOURCE
 19679 00002F48 7269                    	JC	short RENAME_OVER
 19680 00002F4A 89DF                    	MOV	DI,BX
 19681 00002F4C 8E06[E405]              	MOV	ES,[CURBUF+2]
 19682 00002F50 B0E5                    	MOV	AL,DIRFREE ; 0E5h
 19683 00002F52 AA                      	STOSB				; "free" the source
 19684 00002F53 EB13                    	JMP	SHORT DIRTY_IT
 19685                                  
 19686                                  SIMPLE_RENAME:
 19687 00002F55 E85E00                  	CALL	GET_SOURCE		; Get the source back
 19688 00002F58 7259                    	JC	short RENAME_OVER
 19689 00002F5A 89DF                    	MOV	DI,BX
 19690 00002F5C 8E06[E405]              	MOV	ES,[CURBUF+2]
 19691                                  
 19692                                  ;hkn; NAME1 is in DOSDATA
 19693 00002F60 BE[4B05]                	MOV	SI,NAME1		; New Name
 19694 00002F63 B90B00                  	MOV	CX,11
 19695 00002F66 F3A4                    	REP	MOVSB
 19696                                  DIRTY_IT:
 19697 00002F68 8B3E[E205]              	MOV	DI,[CURBUF]
 19698                                  
 19699                                  ; 31/01/2024 - Retro DOS v5.0
 19700                                  %if 0
 19701                                  	; MSDOS 6.0
 19702                                  	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 19703                                  					;LB. if already dirty		  ;AN000;
 19704                                  	JNZ	short yesdirty2		;LB.  don't increment dirty count ;AN000;
 19705                                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 19706                                  	
 19707                                  	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 19708                                  %else
 19709                                  	; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19710 00002F6C E8C535                  	call	SET_BUF_DIRTY
 19711                                  %endif
 19712                                  	
 19713                                  ;------------------------------------------------------------------------------
 19714                                  ; Check if the source is a directory of file. If directory rename it to the
 19715                                  ; the new name in the Fastopen cache buffer. If file name it has been
 19716                                  ; previously deleted.
 19717                                  ;------------------------------------------------------------------------------
 19718                                  
 19719                                  ;yesdirty2:	; 31/01/2024
 19720                                  	; MSDOS 6.0
 19721 00002F6F 56                      	PUSH	SI
 19722 00002F70 C536[2C03]              	LDS	SI,[DMAADD]		;;BN00XPTM. chek if source a dir ;AN000;
 19723                                  	;add	si,21
 19724 00002F74 83C615                  	ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
 19725                                  	;test	byte [si+0Bh],10h
 19726 00002F77 F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM.	;AN000;
 19727 00002F7B 7403                    	JZ	short NOT_DIR2		;;BN00XPTM.			;AN000;
 19728 00002F7D E8F2FD                  	call	FastOpen_Rename		;;BN00X rename dir entry in fastopen
 19729                                  	; 31/01/2024
 19730                                  	;POP	SI
 19731                                  	;JMP	SHORT NOT_DIRTY1
 19732                                  NOT_DIR2:				;;BN00X it is a file, delete the entry
 19733 00002F80 5E                      	POP	SI
 19734                                  NOT_DIRTY1:				;;BN00X
 19735                                  NEXT_SOURCE:
 19736                                  ;hkn; RENAMEDMA is in DOSDATA
 19737 00002F81 BE[2106]                	MOV	SI,RENAMEDMA+1		;Name
 19738                                  
 19739                                  ; WARNING! Rename_Next leaves the disk critical section *ALWAYS*. We need
 19740                                  ; to enter it before going to RENAME_Next.
 19741                                  
 19742 00002F84 E87CE9                  	call	ECritDisk
 19743 00002F87 C606[7E05]00            	MOV	byte [CREATING],0 ; Correct setting for search (we changed it
 19744                                  				  ;  to FF when we made the prev new file).
 19745 00002F8C E80007                  	call	RENAME_NEXT
 19746                                  
 19747                                  ; Note, now, that we have exited the previous ENTER and so are back to where
 19748                                  ; we were before.
 19749                                  
 19750 00002F8F 7222                    	JC	short RENAME_OVER
 19751                                  
 19752                                  	;lea	si,[bx+26]
 19753 00002F91 8D771A                  	LEA	SI,[BX+dir_entry.dir_first]
 19754 00002F94 E84FFD                  	call	REN_DEL_Check
 19755 00002F97 7306                    	JNC	short REN_OK2
 19756 00002F99 B82000                  	MOV	AX,error_sharing_violation ; 20h
 19757                                  jmp_to_rename_clean: ; 28/12/2022
 19758 00002F9C E9C0FE                  	JMP	RENAME_CLEAN ; 10/08/2018
 19759                                  
 19760                                  ;------------------------------------------------------------------------------
 19761                                  ; Check if file or directory. If file, delete file from the Fastopen cache,
 19762                                  ; if directory, rename directory name in the Fastopen cache.
 19763                                  ;-----------------------------------------------------------------------------
 19764                                  
 19765                                  REN_OK2:
 19766                                  	; MSDOS 6.0
 19767                                  	;mov	al,[RERNAMEDMA+32]
 19768 00002F9F A0[4006]                	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr] ; PTR P5622
 19769                                  	;test	al,10h
 19770 00002FA2 A810                    	TEST	AL,attr_directory	;;BN00X directory
 19771 00002FA4 7408                    	JZ	short Ren_Directory	;;BN00X no - file, delete it
 19772                                  	
 19773                                  	; MSDOS 3.3 & MSDOS 6.0
 19774 00002FA6 E8BBFD                  	call	FastOpen_Delete 	;;BN00X delete dir info in fastopen DOS 3.3
 19775                                  jmp_to_builddest: ; 28/12/2022
 19776                                  	; 31/01/2024
 19777 00002FA9 16                      	push	ss
 19778 00002FAA 07                      	pop	es
 19779 00002FAB E9F9FE                  	JMP	BUILDDEST		;;BN00X
 19780                                  
 19781                                  	; MSDOS 6.0
 19782                                  Ren_Directory:
 19783 00002FAE E8C1FD                  	call	FastOpen_Rename 	;;BN00X delete dir info in fastopen DOS 3.3
 19784                                  	;JMP	BUILDDEST
 19785                                  	; 28/12/2022
 19786 00002FB1 EBF6                    	jmp	short jmp_to_builddest
 19787                                  
 19788                                  RENAME_OVER:
 19789 00002FB3 F8                      	CLC
 19790                                  	;JMP	RENAME_CLEAN ; 10/08/2018
 19791                                  	; 28/12/2022
 19792 00002FB4 EBE6                    	jmp	short jmp_to_rename_clean
 19793                                  
 19794                                  ;----------------------------------------------------------------------------
 19795                                  ; Procedure: GET_SOURCE
 19796                                  ;
 19797                                  ; Inputs:
 19798                                  ;	RENAMEDMA has source info
 19799                                  ; Function:
 19800                                  ;	Re-find the source
 19801                                  ; Output:
 19802                                  ;	[CURBUF] set
 19803                                  ;	[CURBUF+2]:BX points to entry
 19804                                  ;	Carry set if error (currently user FAILed to I 24)
 19805                                  ; DS preserved, others destroyed
 19806                                  ;----------------------------------------------------------------------------
 19807                                  
 19808                                  GET_SOURCE:
 19809                                  	;;;
 19810                                  	; 01/02/2024 - Retro DOS v5.0
 19811                                  	; (PCDOS 7.1 IBMDOS.COM)
 19812 00002FB6 C42E[8A05]              	les	bp,[THISDPB]
 19813 00002FBA 31DB                    	xor	bx,bx ; 0
 19814                                  	;cmp	[es:bp+0Fh],bx
 19815 00002FBC 26395E0F                	cmp	[es:bp+DPB.FAT_SIZE],bx ; > 0 ?
 19816 00002FC0 7504                    	jnz	short gs_cont		; yes, it is not FAT32
 19817 00002FC2 8B1E[3106]              	mov	bx,[RENAMEDMA+17]	; DirStart+2
 19818                                  gs_cont:
 19819 00002FC6 891E[F50A]              	mov	[ROOTCLUST_HW],bx	; hw of cluster number
 19820                                  	;;;
 19821 00002FCA 8B1E[2F06]              	MOV	BX,[RENAMEDMA+15]	; DirStart
 19822                                  	; 01/02/2024
 19823                                  	;LES	BP,[THISDPB]
 19824 00002FCE E8F117                  	call	SETDIRSRCH
 19825 00002FD1 7214                    	JC	short gs_ret_label	; retc
 19826 00002FD3 E8911B                  	call	STARTSRCH
 19827 00002FD6 A1[2D06]                	MOV	AX,[RENAMEDMA+13]	; Lastent
 19828                                  	;call	GETENT
 19829                                  	; 18/12/2022
 19830 00002FD9 E92717                  	jmp	GETENT
 19831                                  ;gs_ret_label:
 19832                                  	;retn
 19833                                  
 19834                                  ; MSDOS 6.0 
 19835                                  ;---------------------------------------------------------------------------
 19836                                  ;Procedure: NEW_RENAME
 19837                                  ;
 19838                                  ;Input: DS:SI -> raw string with ?
 19839                                  ;	ES:DI -> destination string
 19840                                  ;	DS:BX -> source string
 19841                                  ;Function: replace ? chars of raw string with chars in source string and
 19842                                  ;	   put in destination string
 19843                                  ;Output: ES:DI-> new string
 19844                                  ;---------------------------------------------------------------------------
 19845                                  
 19846                                  NEW_RENAME:
 19847                                  	; 17/05/2019 - Retro DOS v4.0
 19848                                  NEWNAM:
 19849                                  	; DOSCODE:680Eh (MSDOS 6.21, MSDOS.SYS)
 19850 00002FDC AC                      	LODSB
 19851 00002FDD 3C3F                    	CMP	AL,"?" ; 3Fh
 19852 00002FDF 7502                    	JNZ	short NOCHG
 19853 00002FE1 8A07                    	MOV	AL,[BX] 		; Get replace char
 19854                                  NOCHG:
 19855 00002FE3 AA                      	STOSB
 19856 00002FE4 43                      	INC	BX			; Next replace char
 19857 00002FE5 E2F5                    	LOOP	NEWNAM
 19858                                  	; MSDOS 6.0
 19859                                  gs_ret_label:	; 18/12/2022
 19860 00002FE7 C3                      	retn
 19861                                  
 19862                                  ;============================================================================
 19863                                  ; FINFO.ASM, MSDOS 6.0, 1991
 19864                                  ;============================================================================
 19865                                  ; 08/08/2018 - Retro DOS v3.0
 19866                                  ; 17/05/2019 - Retro DOS v4.0
 19867                                  
 19868                                  ;**	Low level routines for returning file information and setting file
 19869                                  ;	attributes
 19870                                  ;
 19871                                  ;	GET_FILE_INFO
 19872                                  ;	SET_FILE_ATTRIBUTE
 19873                                  ;
 19874                                  ;	Modification history:
 19875                                  ;
 19876                                  ;	    Created: ARR 30 March 1983
 19877                                  ;
 19878                                  ;	M025: Return access_denied if attempting to set
 19879                                  ;	      attribute of root directory.
 19880                                  ;
 19881                                  
 19882                                  ;SUBTTL GET_FILE_INFO -- Get File Information
 19883                                  
 19884                                  ;---------------------------------------------------------------------------
 19885                                  ; Procedure Name : GET_FILE_INFO
 19886                                  ;
 19887                                  ; Inputs:
 19888                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 19889                                  ;		terminated)
 19890                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 19891                                  ;		( = -1 if current dir not involved, else
 19892                                  ;		 Points to first char after last "/" of current dir part)
 19893                                  ;	[THISCDS] Points to CDS being used
 19894                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 19895                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 19896                                  ; Function:
 19897                                  ;	Get Information about a file
 19898                                  ; Returns:
 19899                                  ;	CARRY CLEAR
 19900                                  ;	    AX = Attribute of file
 19901                                  ;	    CX = Time stamp of file
 19902                                  ;	    DX = Date stamp of file
 19903                                  ;	    BX:DI = Size of file (32 bit)
 19904                                  ;	CARRY SET
 19905                                  ;	    AX is error code
 19906                                  ;		error_file_not_found
 19907                                  ;			Last element of path not found
 19908                                  ;		error_path_not_found
 19909                                  ;			Bad path (not in curr dir part if present)
 19910                                  ;		error_bad_curr_dir
 19911                                  ;			Bad path in current directory part of path
 19912                                  ; DS preserved, others destroyed
 19913                                  ;---------------------------------------------------------------------------
 19914                                  
 19915                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19916                                  
 19917                                  GET_FILE_INFO:
 19918                                  
 19919                                  ;hkn; get_file_info is called from file.asm and fcbio.asm. DS has been set 
 19920                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 19921                                  
 19922 00002FE8 E856E8                  	call	TestNet
 19923 00002FEB 7306                    	JNC	short LOCAL_INFO
 19924                                  
 19925                                  ;IF NOT Installed
 19926                                  ;	transfer NET_GET_FILE_INFO
 19927                                  ;ELSE
 19928                                  ;	MOV	AX,(MultNET SHL 8) OR 15
 19929                                  ;	INT	2FH
 19930                                  ;	return
 19931                                  
 19932 00002FED B80F11                  	mov     ax, 110Fh
 19933 00002FF0 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
 19934                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 19935                                  			; SDA CDS pointer -> current directory
 19936                                  			; Return: CF set on error, AX = file attributes
 19937 00002FF2 C3                      	retn
 19938                                  ;ENDIF
 19939                                  
 19940                                  LOCAL_INFO:
 19941 00002FF3 E80DE9                  	call	ECritDisk
 19942 00002FF6 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 19943                                  	; MSDOS 3.3
 19944                                  	;call	GETPATH
 19945                                  	; MSDOS 6.0
 19946 00002FFB E8C900                  	call	GET_FAST_PATH
 19947                                  	; MSDOS 3.3 & MSDOS 6.0
 19948 00002FFE 7312                    	JNC	short info_check_dev
 19949                                  NO_PATH:
 19950 00003000 750B                    	JNZ	short bad_path1
 19951 00003002 08C9                    	OR	CL,CL
 19952 00003004 7407                    	JZ	short bad_path1
 19953                                  info_no_file:
 19954 00003006 B80200                  	MOV	AX,error_file_not_found
 19955                                  BadRet:
 19956 00003009 F9                      	STC
 19957                                  JustRet:
 19958                                  	;call	LCritDisk
 19959                                  	;retn
 19960                                  	; 18/12/2022
 19961 0000300A E923E9                  	jmp	LCritDisk
 19962                                  
 19963                                  bad_path1:
 19964 0000300D B80300                  	MOV	AX,error_path_not_found
 19965 00003010 EBF7                    	jmp	short BadRet
 19966                                  
 19967                                  info_check_dev:
 19968 00003012 08E4                    	OR	AH,AH
 19969 00003014 78F0                    	JS	short info_no_file	; device
 19970                                  
 19971                                  	; MSDOS 6.0
 19972                                  ;SR;
 19973                                  ; If root dir then CurBuf == -1. Check for this case and return subdir attr
 19974                                  ;for a root dir
 19975                                  
 19976 00003016 833E[E205]FF            	cmp	word [CURBUF],-1	;is it a root dir?
 19977 0000301B 7506                    	jne	short not_root		;no, CurBuf ptr is valid
 19978                                  
 19979 0000301D 30E4                    	xor	ah,ah
 19980 0000301F B010                    	mov	al,attr_directory ; 10h
 19981                                  	;clc
 19982                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 19983                                  	; (DOSCODE:683Eh)
 19984                                  	; 16/12/2022
 19985                                  	;clc
 19986 00003021 EBE7                    	jmp	short JustRet
 19987                                  
 19988                                  not_root:
 19989                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19990 00003023 1E                      	PUSH	DS
 19991 00003024 8E1E[E405]              	MOV	DS,[CURBUF+2]
 19992 00003028 89DE                    	MOV	SI,BX
 19993 0000302A 31DB                    	XOR	BX,BX			; Assume size=0 (dir)
 19994 0000302C 89DF                    	MOV	DI,BX
 19995                                  	;mov	cx,[si+16h]
 19996 0000302E 8B4C16                  	MOV	CX,[SI+dir_entry.dir_time]
 19997                                  	;mov	dx,[si+18h]
 19998 00003031 8B5418                  	MOV	DX,[SI+dir_entry.dir_date]
 19999 00003034 30E4                    	XOR	AH,AH
 20000                                  	;mov	al,[si+0Bh]
 20001 00003036 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 20002                                  	;test	al,10h
 20003 00003039 A810                    	TEST	AL,attr_directory
 20004 0000303B 7506                    	JNZ	short NO_SIZE
 20005                                  	;mov	di,[si+1Ch]
 20006 0000303D 8B7C1C                  	MOV	DI,[SI+dir_entry.dir_size_l]
 20007                                  	;mov	bx,[si+1Eh]
 20008 00003040 8B5C1E                  	MOV	BX,[SI+dir_entry.dir_size_h]
 20009                                  NO_SIZE:
 20010 00003043 1F                      	POP	DS
 20011                                  	;CLC
 20012                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20013                                  	; (DOSCODE:6864h)
 20014                                  	; 16/12/2022
 20015                                  	;clc
 20016 00003044 EBC4                    	jmp	short JustRet
 20017                                  
 20018                                  ;Break	<SET_FILE_ATTRIBUTE -- Set File Attribute>
 20019                                  ;-------------------------------------------------------------------------------
 20020                                  ; Procedure Name : SET_FILE_ATTRIBUTE
 20021                                  ; Inputs:
 20022                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 20023                                  ;		terminated)
 20024                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 20025                                  ;		( = -1 if current dir not involved, else
 20026                                  ;		 Points to first char after last "/" of current dir part)
 20027                                  ;	[THISCDS] Points to CDS being used
 20028                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 20029                                  ;	[SATTRIB] is attribute of search (determines what files may be found)
 20030                                  ;	AX is new attributes to give to file
 20031                                  ; Function:
 20032                                  ;	Set File Attributes
 20033                                  ; Returns:
 20034                                  ;	CARRY CLEAR
 20035                                  ;	    No error
 20036                                  ;	CARRY SET
 20037                                  ;	    AX is error code
 20038                                  ;		error_file_not_found
 20039                                  ;			Last element of path not found
 20040                                  ;		error_path_not_found
 20041                                  ;			Bad path (not in curr dir part if present)
 20042                                  ;		error_bad_curr_dir
 20043                                  ;			Bad path in current directory part of path
 20044                                  ;		error_access_denied
 20045                                  ;			Attempt to set an attribute which cannot be set
 20046                                  ;			(attr_directory, attr_volume_ID)
 20047                                  ;		error_sharing_violation
 20048                                  ;			Sharing mode of file did not allow the change
 20049                                  ;			(this request requires exclusive write/read access)
 20050                                  ;			(INT 24H generated)
 20051                                  ; DS preserved, others destroyed
 20052                                  ;----------------------------------------------------------------------------
 20053                                  
 20054                                  	; 01/02/2024 - Retro DOS v5.0
 20055                                  
 20056                                  SET_FILE_ATTRIBUTE:
 20057                                  
 20058                                  ;hkn; set_file_attr is called from file.asm. DS has been set 
 20059                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 20060                                  
 20061 00003046 A9D8FF                  	TEST	AX,~attr_changeable ; 0FFD8h
 20062 00003049 7412                    	JZ	short set_look
 20063                                  _BAD_ACC:
 20064                                  	;MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1
 20065                                  	;;;
 20066                                  	; 01/02/2024 - Retro DOS v5.0
 20067                                  	; (PCDOS 7.1 IBMDOS.COM)
 20068 0000304B E8A7E2                  	call	set_exerr_locus_unk
 20069                                  	;;;
 20070 0000304E C606[2703]07            	MOV	byte [EXTERR_CLASS],errCLASS_Apperr ; 7
 20071 00003053 C606[2603]04            	MOV	byte [EXTERR_ACTION],errACT_Abort ; 4
 20072 00003058 B80500                  	MOV	AX,error_access_denied ; 5
 20073 0000305B F9                      	STC
 20074 0000305C C3                      	retn
 20075                                  	
 20076                                  set_look:
 20077 0000305D E8E1E7                  	call	TestNet
 20078 00003060 7308                    	JNC	short LOCAL_SET
 20079                                  
 20080                                  ;IF NOT Installed
 20081                                  ;	transfer NET_SEQ_SET_FILE_ATTRIBUTE
 20082                                  ;ELSE
 20083 00003062 50                      	PUSH	AX
 20084                                  	
 20085                                  	;MOV	AX,(MultNET SHL 8) OR 14
 20086                                  	;INT	2FH
 20087                                  
 20088 00003063 B80E11                  	mov     ax, 110Eh
 20089 00003066 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
 20090                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 20091                                  			; SDA CDS pointer -> current directory
 20092                                  			; STACK: WORD new file attributes
 20093                                  			; Return: CF set on error
 20094                                  
 20095 00003068 5B                      	POP	BX			; clean stack
 20096 00003069 C3                      	retn
 20097                                  ;ENDIF
 20098                                  
 20099                                  LOCAL_SET:
 20100 0000306A E896E8                  	call	ECritDisk
 20101 0000306D 50                      	PUSH	AX			; Save new attributes
 20102 0000306E C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 20103 00003073 E85E18                  	call	GETPATH 		; get path through fastopen if there	;AC000;
 20104 00003076 7308                    	JNC	short set_check_device
 20105 00003078 5B                      	POP	BX			; Clean stack (don't zap AX)
 20106 00003079 EB85                    	JMP	short NO_PATH
 20107                                  
 20108                                  	; MSDOS 6.0
 20109                                  cannot_set_root:			; M025:
 20110 0000307B B80500                  	mov	ax,error_access_denied	; M025: return error is attempting
 20111                                  	;stc				; M025: to set attr. of root
 20112                                  	;jmp	short OK_BYE		; M025:
 20113                                  	; 01/02/2024
 20114 0000307E EB89                    	jmp	short BadRet
 20115                                  
 20116                                  set_check_device:
 20117 00003080 08E4                    	OR	AH,AH
 20118 00003082 7906                    	JNS	short set_check_share
 20119 00003084 58                      	POP	AX
 20120 00003085 E8A8E8                  	call	LCritDisk
 20121 00003088 EBC1                    	JMP	short _BAD_ACC 		; device
 20122                                  
 20123                                  set_check_share:
 20124 0000308A 58                      	POP	AX			; Get new attributes
 20125                                  
 20126                                  	; MSDOS 6.0
 20127 0000308B 833E[E205]FF            	cmp	word [CURBUF], -1	; M025: Q: is this the root dir
 20128 00003090 74E9                    	je	short cannot_set_root	; M025: Y: return error
 20129                                  
 20130                                  	; MSDOS 3.3 & MSDOS 6.0
 20131 00003092 E851FC                  	call	REN_DEL_Check
 20132 00003095 7305                    	JNC	short set_do
 20133 00003097 B82000                  	MOV	AX,error_sharing_violation ; 32
 20134 0000309A EB28                    	jmp	short OK_BYE
 20135                                  
 20136                                  set_do:
 20137                                  	; MSDOS 3.3 & MSDOS 6.0
 20138 0000309C C43E[E205]              	LES	DI,[CURBUF]
 20139 000030A0 2680670BD8              	AND	BYTE [ES:BX+dir_entry.dir_attr],~attr_changeable ; 0D8h
 20140 000030A5 2608470B                	OR	BYTE [ES:BX+dir_entry.dir_attr],AL
 20141                                  
 20142                                  ; 01/02/2024 - Retro DOS v5.0
 20143                                  %if 0
 20144                                  	; MSDOS 6.0
 20145                                  	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 20146                                  					;LB. if already dirty		  ;AN000;
 20147                                  	JNZ	short yesdirty3		;LB.  don't increment dirty count ;AN000;
 20148                                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 20149                                  	
 20150                                  	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 20151                                  yesdirty3:
 20152                                  %else
 20153                                  	; 01/02/2024
 20154                                  	; (PCDOS 7.1 IBMDOS.COM)
 20155 000030A9 E88834                  	call	SET_BUF_DIRTY
 20156                                  %endif
 20157 000030AC A0[7605]                	MOV	AL,[THISDRV]
 20158                                  ;;;; 10/1/86 F.C update fastopen cache
 20159 000030AF 52                      	PUSH	DX
 20160 000030B0 57                      	PUSH	DI
 20161 000030B1 B400                    	MOV	AH,0		  ; dir entry update
 20162 000030B3 88C2                    	MOV	DL,AL		  ; drive number A=0,B=1,,
 20163 000030B5 89DF                    	MOV	DI,BX		  ; ES:DI -> dir entry
 20164 000030B7 E8D2FC                  	call	FastOpen_Update
 20165 000030BA 5F                      	POP	DI
 20166 000030BB 5A                      	POP	DX
 20167                                  ;;;; 9/11/86 F.C update fastopen cache
 20168 000030BC E87033                  	call	FLUSHBUF
 20169 000030BF 7303                    	JNC	short OK_BYE
 20170 000030C1 B80200                  	MOV	AX,error_file_not_found
 20171                                  OK_BYE:
 20172                                  	;call	LCritDisk
 20173                                  	;retn
 20174                                  	; 16/12/2022
 20175 000030C4 E969E8                  	jmp	LCritDisk
 20176                                  
 20177                                  ;----------------------------------------------------------------------------
 20178                                  
 20179                                  	; 17/05/2019 - Retro DOS v4.0
 20180                                  
 20181                                  	; MSDOS 6.0
 20182                                  GET_FAST_PATH:
 20183                                  ;hkn; use SS override for FastOpenFlg
 20184 000030C7 36800E[6D12]01          	OR	byte [ss:FastOpenFlg],FastOpen_Set
 20185                                  					;FO. trigger fastopen	;AN000;
 20186 000030CD E80418                  	call	GETPATH
 20187 000030D0 9C                      	PUSHF			 	;FO.			;AN000;
 20188 000030D1 368026[6D12]80          	AND	byte [ss:FastOpenFlg],Fast_yes 
 20189                                  					;FO. clear all fastopen flags ;AN000;
 20190 000030D7 9D                      	POPF				;FO.			;AN000;
 20191 000030D8 C3                      	retn
 20192                                  
 20193                                  ;============================================================================
 20194                                  ; DUP.ASM, MSDOS 6.0, 1991
 20195                                  ;============================================================================
 20196                                  ; 08/08/2018 - Retro DOS v3.0
 20197                                  ; 17/05/2019 - Retro DOS v4.0
 20198                                  
 20199                                  ;** 	Low level DUP routine for use by EXEC when creating a new process.
 20200                                  ;   	Exports the DUP to the server machine and increments the SFT ref count
 20201                                  ;
 20202                                  ;	DOS_DUP
 20203                                  ;
 20204                                  ;	Modification history:
 20205                                  ;
 20206                                  ;	  Created: ARR 30 March 1983
 20207                                  
 20208                                  ;BREAK <DOS_DUP -- DUP SFT across network>
 20209                                  ;---------------------------------------------------------------------------
 20210                                  ; Procedure Name : DOS_DUP
 20211                                  ;
 20212                                  ; Inputs:
 20213                                  ;	[THISSFT] set to the SFT for the file being DUPed
 20214                                  ;		(a non net SFT is OK, in this case the ref
 20215                                  ;		 count is simply incremented)
 20216                                  ; Function:
 20217                                  ;	Signal to the devices that a logical open is occurring
 20218                                  ; Returns:
 20219                                  ;	ES:DI point to SFT
 20220                                  ;    Carry clear
 20221                                  ;	SFT ref_count is incremented
 20222                                  ; Registers modified: None.
 20223                                  ; NOTE:
 20224                                  ;	This routine is called from $CREATE_PROCESS_DATA_BLOCK at DOSINIT
 20225                                  ;	time with SS NOT DOSGROUP. There will be no Network handles at
 20226                                  ;	that time.
 20227                                  ;---------------------------------------------------------------------------
 20228                                  
 20229                                  DOS_DUP:
 20230                                  	;LES	DI,[CS:THISSFT]  ; MSDOS 3.3
 20231                                  
 20232                                  	; MSDOS 6.0
 20233 000030D9 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 20234 000030DE 26C43E[9E05]            	les	di,[es:THISSFT]
 20235                                  
 20236                                  	;Entry	Dos_Dup_Direct
 20237                                  DOS_Dup_Direct:
 20238 000030E3 E874E7                  	call	IsSFTNet
 20239 000030E6 7503                    	JNZ	short DO_INC
 20240 000030E8 E8B61E                  	call	DEV_OPEN_SFT
 20241                                  DO_INC:
 20242                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 20243 000030EB 26FF05                  	inc	word [ES:DI]		; Clears carry (if this ever wraps
 20244                                  					;   we're in big trouble anyway)
 20245 000030EE C3                      	retn
 20246                                  
 20247                                  ;============================================================================
 20248                                  ; CREATE.ASM, MSDOS 6.0, 1991
 20249                                  ;============================================================================
 20250                                  ; 08/08/2018 - Retro DOS v3.0
 20251                                  ; 18/05/2019 - Retro DOS v4.0
 20252                                  
 20253                                  ;TITLE	DOS_CREATE/DOS_CREATE_NEW - Internal CREATE calls for MS-DOS
 20254                                  ;NAME	DOS_CREATE
 20255                                  ;----------------------------------------------------------------------------
 20256                                  ;**	Internal Create and Create new to create a local or NET file and SFT.
 20257                                  ;
 20258                                  ;	DOS_CREATE
 20259                                  ;	DOS_CREATE_NEW
 20260                                  ;	SET_MKND_ERR
 20261                                  ;	SET_Media_ID
 20262                                  ;	SET_EXT_Mode
 20263                                  ;
 20264                                  ;	Revision history:
 20265                                  ;
 20266                                  ;	    A000 version 4.00	  Jan. 1988
 20267                                  ;	    A001  D490 -- Change IOCTL subfunctios from 63h,43h to 66h, 46h
 20268                                  
 20269                                  ;Installed = TRUE
 20270                                  
 20271                                  ;	i_need	THISSFT,DWORD
 20272                                  ;	i_need	THISCDS,DWORD
 20273                                  ;	I_need	EXTERR,WORD
 20274                                  ;	I_Need	ExtErr_locus,BYTE
 20275                                  ;	I_need	JShare,DWORD
 20276                                  ;	I_need	VOLCHNG_FLAG,BYTE
 20277                                  ;	I_need	SATTRIB,BYTE
 20278                                  ;	I_need	CALLVIDM,DWORD
 20279                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000; extended open
 20280                                  ;	I_need	NAME1,BYTE			  ;AN000;
 20281                                  ;	I_need	NO_NAME_ID,BYTE 		  ;AN000;
 20282                                  ;	I_need	Packet_Temp,WORD		  ;AN000;
 20283                                  ;	I_need	DOS34_FLAG,WORD 		  ;AN000;
 20284                                  ;	I_need	SAVE_BX,WORD			  ;AN000;
 20285                                  
 20286                                  ;***	DOS_CREATE - Create a File
 20287                                  ;----------------------------------------------------------------------------
 20288                                  ;	DOS_Create is called to create the specified file, truncating
 20289                                  ;	the old one if it exists.
 20290                                  ;
 20291                                  ;	ENTRY	AX is Attribute to create
 20292                                  ;		(ds) = DOSDATA
 20293                                  ;		[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 20294                                  ;			terminated)
 20295                                  ;		[CURR_DIR_END] Points to end of Current dir part of string
 20296                                  ;			( = -1 if current dir not involved, else
 20297                                  ;			 Points to first char after last "/" of current dir part)
 20298                                  ;		[THISCDS] Points to CDS being used
 20299                                  ;			(Low word = -1 if NUL CDS (Net direct request))
 20300                                  ;		[THISSFT] Points to SFT to fill in if file created
 20301                                  ;			(sf_mode field set so that FCB may be detected)
 20302                                  ;		[SATTRIB] Is attribute of search, determines what files can be found
 20303                                  ;
 20304                                  ;	EXIT	sf_ref_count is NOT altered
 20305                                  ;		CARRY CLEAR
 20306                                  ;		    THISSFT filled in.
 20307                                  ;			sf_mode = unchanged for FCB, sharing_compat + open_for_both
 20308                                  ;		CARRY SET
 20309                                  ;		    AX is error code
 20310                                  ;			error_path_not_found
 20311                                  ;				Bad path (not in curr dir part if present)
 20312                                  ;			error_bad_curr_dir
 20313                                  ;				Bad path in current directory part of path
 20314                                  ;			error_access_denied
 20315                                  ;				Attempt to re-create read only file , or
 20316                                  ;				create a second volume id or create a dir
 20317                                  ;			error_sharing_violation
 20318                                  ;				The sharing mode was correct but not allowed
 20319                                  ;				generates an INT 24
 20320                                  ;	USES	all but DS
 20321                                  ;----------------------------------------------------------------------------
 20322                                  
 20323                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20324                                  	; DOSCODE:6920h (MSDOS 5.0, MSDOS.SYS)
 20325                                  
 20326                                  	; 01/02/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 20327                                  	; DOSCODE:708Ah (PCDOS 7.1, IBMDOS.COM)
 20328                                  
 20329                                  DOS_CREATE:
 20330                                  	; 18/05/2019 - Retro DOS v4.0
 20331                                  	; DOSCODE:6934h (MSDOS 6.21, MSDOS.SYS)
 20332                                  
 20333                                  ;hkn; dispatched to from file.asm and fcbio.asm. DS set up to DOSDATA at 
 20334                                  ;hkn; this point.
 20335                                  
 20336 000030EF 30E4                    	XOR	AH,AH		; Truncate is OK
 20337                                  
 20338                                  ;	Enter here from Dos_Create_New
 20339                                  ;
 20340                                  ;	(ah) = 0 iff truncate OK
 20341                                  
 20342                                  Create_inter:
 20343 000030F1 A8C0                    	TEST	AL,~(attr_all+attr_ignore+attr_volume_id) ; 80h
 20344                                  				; Mask out any meaningless bits
 20345 000030F3 7511                    	JNZ	short AttErr
 20346 000030F5 A808                    	TEST	AL,attr_volume_id
 20347 000030F7 7407                    	JZ	short NoReset
 20348                                  	
 20349                                  	; MSDOS 6.0
 20350                                  	; 16/12/2022
 20351 000030F9 800E[1106]80            	OR	byte [DOS34_FLAG],DBCS_VOLID ; 80h ;AN000;FOR dbcs volid
 20352                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20353                                  	;or	word [DOS34_FLAG],DBCS_VOLID ; 80h 
 20354                                  	
 20355 000030FE B008                    	MOV	AL,attr_volume_id ; 8
 20356                                  NoReset:
 20357 00003100 0C20                    	OR	AL,attr_archive ; File changed  ; 20h
 20358 00003102 A850                    	TEST	AL,attr_directory+attr_device ; 50h
 20359 00003104 7408                    	JZ	short ATT_OK
 20360                                  AttErr:
 20361 00003106 B80500                  	MOV	AX,5		; Attribute problem
 20362                                  	;MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1
 20363                                  	; 01/02/2024
 20364 00003109 E8E9E1                  	call	set_exerr_locus_unk
 20365 0000310C EB62                    	JMP	SHORT SET_MKND_ERR ; Gotta use MKDIR to make dirs, NEVER allow
 20366                                  				   ;	attr_device to be set.
 20367                                  ATT_OK:
 20368 0000310E C43E[9E05]              	LES	DI,[THISSFT]
 20369 00003112 06                      	PUSH	ES
 20370 00003113 C436[A205]              	LES	SI,[THISCDS]
 20371 00003117 83FEFF                  	CMP	SI,-1
 20372 0000311A 751B                    	JNE	short TEST_RE_NET
 20373                                  
 20374                                  ;	No CDS, it must be redirected.
 20375                                  
 20376 0000311C 07                      	POP	ES
 20377                                  
 20378                                  	; MSDOS 6.0
 20379                                  ;Extended open hooks
 20380                                  	;test	byte [EXTOPEN_ON],1
 20381 0000311D F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 20382 00003122 740D                    	JZ	short NOEXTOP 		    ;AN000;EO. no, do normal
 20383                                  IFS_extopen:				    ;AN000;EO.
 20384 00003124 50                      	PUSH	AX			    ;AN000;EO. pass create attr
 20385                                  	;MOV	AX,(MultNET SHL 8) OR 46    ;AN000;EO. issue extended open verb
 20386 00003125 B82E11                  	mov	ax,112Eh
 20387                                  NOEXTOP2:	; 01/02/2024 (PCDOS 7.1 IBMDOS.COM)
 20388 00003128 CD2F                    	INT	2FH			    ;AN000;EO.
 20389 0000312A 5B                      	POP	BX			    ;AN000;EO. trash bx
 20390 0000312B C606[F605]00            	MOV	byte [EXTOPEN_ON],0	    ;AN000;EO.
 20391 00003130 C3                      	retn				    ;AN000;EO.
 20392                                  NOEXTOP:				    ;AN000;
 20393                                  ;Extended open hooks
 20394                                  
 20395                                  ;IF NOT Installed
 20396                                  ;	transfer NET_SEQ_CREATE
 20397                                  ;ELSE
 20398 00003131 50                      	PUSH	AX
 20399                                  
 20400                                  	;MOV	AX,(MultNET SHL 8) OR 24
 20401                                  	;INT	2FH
 20402                                  
 20403 00003132 B81811                  	mov     ax,1118h
 20404                                  	; 01/02/2024
 20405                                  	;int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
 20406                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 20407                                  			; SDA first filename pointer -> fully-qualified name of file
 20408                                  			; STACK: WORD file creation mode???
 20409                                  
 20410                                  	;POP	BX			; BX is trashed anyway
 20411                                  	;retn
 20412 00003135 EBF1                    	jmp	short NOEXTOP2 ; 01/02/2024
 20413                                  ;ENDIF
 20414                                  
 20415                                  ;	We have a CDS. See if it's network
 20416                                  
 20417                                  TEST_RE_NET:
 20418                                  	;;test	word [es:si+43h],8000h
 20419                                  	;TEST	word [ES:SI+curdir.flags],curdir_isnet
 20420                                  	; 07/12/2022
 20421                                  	;test	byte [es:si+44h],80h
 20422                                  	; 17/12/2022
 20423 00003137 26F6444480              	test	byte [ES:SI+curdir.flags+1],curdir_isnet>>8
 20424 0000313C 07                      	POP	ES
 20425 0000313D 7417                    	JZ	short LOCAL_CREATE
 20426                                  
 20427                                  	; MSDOS 6.0
 20428 0000313F E8CA00                  	CALL	Set_EXT_mode		    ;AN000;EO.
 20429 00003142 7205                    	JC	SHORT dochk		    ;AN000;EO.
 20430                                  	;;or	word [es:di+2],2
 20431                                  	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.
 20432                                  	; 17/12/2022
 20433 00003144 26804D0202              	or	byte [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.
 20434                                  
 20435                                  ;Extended open hooks
 20436                                  dochk:
 20437 00003149 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 20438 0000314E 75D4                    	JNZ	short IFS_extopen	    ;AN000;EO. yes, issue extended open
 20439                                  ;Extended open hooks
 20440                                  
 20441                                  ;IF NOT Installed
 20442                                  ;	transfer NET_CREATE
 20443                                  ;ELSE
 20444 00003150 50                      	PUSH	AX
 20445                                  	
 20446                                  	;MOV	AX,(MultNET SHL 8) OR 23
 20447                                  	;INT	2FH
 20448                                  	
 20449 00003151 B81711                  	mov     ax,1117h
 20450                                  	
 20451                                  	; 01/02/2024
 20452                                  	;int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
 20453                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 20454                                  			; SDA first filename pointer -> fully-qualified name of file to open
 20455                                  			; SDA CDS pointer -> current directory
 20456                                  			; Return: CF set on error
 20457                                  
 20458                                  	;POP	BX			; BX is trashed anyway
 20459                                  ;nomore:
 20460                                  	;retn
 20461 00003154 EBD2                    	jmp	short NOEXTOP2 ; 01/02/2024
 20462                                  ;ENDIF
 20463                                  
 20464                                  ;**	It's a local create. We have a local CDS for it.
 20465                                  
 20466                                  LOCAL_CREATE:
 20467                                  	; MSDOS 6.0
 20468 00003156 E8B300                  	CALL	Set_EXT_mode	;AN000;EO. set mode if from extended open
 20469 00003159 7205                    	JC	short setdone	;AN000;EO.
 20470                                  	
 20471                                  	; MSDOS 3.3 & MSDOS 6.0
 20472                                  	; 17/12/2022
 20473                                  	;;or	word [es:di+2],2
 20474                                  	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 20475                                  	;or	byte [es:di+2],2
 20476 0000315B 26804D0202              	or	byte [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 20477                                  setdone:
 20478 00003160 E8A0E7                  	call	ECritDisk
 20479 00003163 E8DA21                  	call	MakeNode
 20480 00003166 7317                    	JNC	short Create_ok
 20481 00003168 C606[A10A]FF            	mov	byte [VOLCHNG_FLAG],-1	; indicate no change in volume label
 20482 0000316D E8C0E7                  	call	LCritDisk
 20483                                  
 20484                                  	;entry	SET_MKND_ERR
 20485                                  SET_MKND_ERR:
 20486                                  
 20487                                  ;	Looks up MakeNode errors and converts them. AL is MakeNode
 20488                                  ;	error, SI is GETPATH bad spot return if path_not_found error.
 20489                                  
 20490                                  ;hkn; CRTERRTAB is in TABLE seg (DOSCODE)
 20491 00003170 BB[7731]                	MOV     BX,CRTERRTAB
 20492                                  	;XLAT  ; MSDOS 3.3
 20493                                  	; 18/05/2019 - Retro DOS v4.0
 20494 00003173 2E                      	CS
 20495 00003174 D7                      	XLAT
 20496                                  CreatBadRet:
 20497 00003175 F9                      	STC
 20498 00003176 C3                      	retn
 20499                                  
 20500                                  ; 13/05/2019 - Retro DOS v4.0
 20501                                  ; DOSCODE:69C4h (MSDOS 6.21, MSDOS.SYS)
 20502                                  ; ---------------------------------------------------------------------------
 20503                                  
 20504                                  ;** Internal Create and Create new to create a local or NET file and SFT.
 20505                                  
 20506                                  ; 17/07/2018 - Retro DOS v3.0
 20507                                  ; Offset 12B1h of IBMDOS.COM (MSDOS 3.3), 1987
 20508                                  
 20509                                  ;CRTERRTAB: ; 19/07/2018 - MSDOS 3.3	
 20510                                  ;	db	0,5,52h,50h,3,5,20h
 20511                                  
 20512                                  ;CRTERRTAB: ; 18/05/2019 - MSDOS 6.0	
 20513                                  ;	db	0,5,52h,50h,3,5,20h,2
 20514                                  
 20515                                  ; 08/08/2018
 20516                                  
 20517                                  CRTERRTAB:	;LABEL BYTE	; Lookup table for MakeNode returns
 20518 00003177 00                      	DB	0			; none
 20519 00003178 05                      	DB	error_access_denied	; MakeNode error 1
 20520 00003179 52                      	DB	error_cannot_make	; MakeNode error 2
 20521 0000317A 50                      	DB	error_file_exists	; MakeNode error 3
 20522 0000317B 03                      	DB	error_path_not_found	; MakeNode error 4
 20523 0000317C 05                      	DB	error_access_denied	; MakeNode error 5
 20524 0000317D 20                      	DB	error_sharing_violation ; MakeNode error 6
 20525                                  	; MSDOS 6.0
 20526 0000317E 02                      	DB	error_file_not_found	; MakeNode error 7
 20527                                  
 20528                                  ; ---------------------------------------------------------------------------
 20529                                  
 20530                                  ; We have just created a new file. This results in the truncation of old
 20531                                  ; files. We must inform the sharer to slash all the open SFT's for this
 20532                                  ; file to the current size.
 20533                                  
 20534                                  ; If we created a volume id on the diskette, set the VOLCHNG_FLAG to logical
 20535                                  ; drive number to force a Build BPB after Media Check.
 20536                                  
 20537                                  ;;; FASTOPEN 8/29/86
 20538                                  Create_ok:
 20539 0000317F E8E2FB                  	call	FastOpen_Delete
 20540                                  ;;; FASTOPEN 8/29/86
 20541 00003182 A0[6D05]                	mov	al,[SATTRIB]
 20542 00003185 A808                    	test	al,attr_volume_id
 20543 00003187 741C                    	jz	short NoVolLabel
 20544 00003189 C43E[A205]              	LES	DI,[THISCDS]
 20545                                  	;mov	ah,[ES:DI+curdir.text]	; get drive letter
 20546 0000318D 268A25                  	mov	ah,[ES:DI] ; 09/08/2018
 20547 00003190 80EC41                  	sub	ah,'A'	; 41h		; convert to drive number
 20548 00003193 8826[A10A]              	mov	[VOLCHNG_FLAG],ah	;Set flag to indicate volid change
 20549                                  	
 20550                                  	; 18/05/2019 - Retro DOS v4.0
 20551                                  
 20552                                  	; MSDOS 6.0
 20553 00003197 B701                    	MOV	BH,1			;AN000;>32mb set volume id to boot record
 20554 00003199 E81F00                  	CALL	Set_Media_ID		;AN000;>32mb
 20555                                  	
 20556 0000319C E864E7                  	call	ECritDisk
 20557 0000319F E8E72E                  	call	FATREAD_CDS		; force a media check
 20558 000031A2 E88BE7                  	call	LCritDisk
 20559                                  
 20560                                  NoVolLabel:
 20561 000031A5 B80200                  	MOV	ax,2
 20562 000031A8 C43E[9E05]              	LES	DI,[THISSFT]
 20563                                  ;if installed
 20564                                  	;call	JShare + 14 * 4
 20565 000031AC FF1E[C800]              	call	far [JShare+(14*4)] ; 14 = ShSU
 20566                                  ;else
 20567                                  ;	Call	ShSU
 20568                                  ;endif
 20569 000031B0 E87DE7                  	call	LCritDisk
 20570 000031B3 E95601                  	jmp	SET_SFT_MODE
 20571                                  
 20572                                  ;---------------------------------------------------------------------------
 20573                                  ; Procedure Name : Dos_Create_New
 20574                                  ;
 20575                                  ; Inputs:
 20576                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 20577                                  ;		terminated)
 20578                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 20579                                  ;		( = -1 if current dir not involved, else
 20580                                  ;		 Points to first char after last "/" of current dir part)
 20581                                  ;	[THISCDS] Points to CDS being used
 20582                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 20583                                  ;	[THISSFT] Points to SFT to fill in if file created
 20584                                  ;		(sf_mode field set so that FCB may be detected)
 20585                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 20586                                  ;	AX is Attribute to create
 20587                                  ; Function:
 20588                                  ;	Try to create the specified file truncating an old one that exists
 20589                                  ; Outputs:
 20590                                  ;	sf_ref_count is NOT altered
 20591                                  ;	CARRY CLEAR
 20592                                  ;	    THISSFT filled in.
 20593                                  ;		sf_mode = sharing_compat + open_for_both for Non-FCB SFT
 20594                                  ;	CARRY SET
 20595                                  ;	    AX is error code
 20596                                  ;		error_path_not_found
 20597                                  ;			Bad path (not in curr dir part if present)
 20598                                  ;		error_bad_curr_dir
 20599                                  ;			Bad path in current directory part of path
 20600                                  ;		error_access_denied
 20601                                  ;			Create a second volume id or create a dir
 20602                                  ;		error_file_exists
 20603                                  ;			Already a file by this name
 20604                                  ; DS preserved, others destroyed
 20605                                  ;---------------------------------------------------------------------------
 20606                                  
 20607                                  DOS_Create_New:
 20608 000031B6 B401                    	MOV	AH,1		; Truncate is NOT OK
 20609 000031B8 E936FF                  	JMP	Create_inter
 20610                                  
 20611                                  ; MSDOS 6.0
 20612                                  ;---------------------------------------------------------------------------
 20613                                  ; Procedure Name : Set_Media_ID
 20614                                  ;
 20615                                  ; Inputs:
 20616                                  ;	NAME1= Volume ID
 20617                                  ;	BH= 0, delete volume id
 20618                                  ;	    1, set new volume id
 20619                                  ;	DS= DOSGROUP
 20620                                  ; Function:
 20621                                  ;	Set Volume ID to DOS 4.00 Boot record.
 20622                                  ; Outputs:
 20623                                  ;	CARRY CLEAR
 20624                                  ;	    volume id set
 20625                                  ;	CARRY SET
 20626                                  ;	    AX is error code
 20627                                  ;---------------------------------------------------------------------------
 20628                                  
 20629                                  	; 18/05/2019 - Retro DOS v4.0
 20630                                  	; 01/02/2024 - Retro DOS v5.0
 20631                                  Set_Media_ID:
 20632 000031BB 50                      	PUSH	AX		;AN000;;>32mb
 20633 000031BC 06                      	PUSH	ES		;AN000;;>32mb
 20634 000031BD 57                      	PUSH	DI		;AN000;;>32mb
 20635                                  
 20636 000031BE FEC4                    	INC	AH		;AN000;;>32mb  bl=drive #
 20637 000031C0 88E3                    	MOV	BL,AH		;AN000;;>32mb  bl=drive # (A=1,B=2,,,)
 20638 000031C2 B00D                    	MOV	AL,0DH		;AN000;;>32mb  generic IOCTL
 20639                                  	;MOV	CX,0866H	;AN001;;>32mb  get media id
 20640                                  	; 01/02/2024
 20641                                  	; (PCDOS 7.1 IBMDOS.COM)
 20642 000031C4 B96648                  	mov	cx,4866h	; ch = FAT32 disk drive (CATEGORY CODE)
 20643                                  				; cl = minor code,
 20644                                  				;      get volume serial number (and name)
 20645                                  
 20646                                  ;hkn; PACKET_TEMP is in DOSDATA
 20647 000031C7 BA[BD0D]                	MOV	DX,Packet_Temp	;AN000;>32mb
 20648                                  
 20649                                  Set_Media_ID_1:
 20650                                  	; 01/02/2024
 20651 000031CA 51                      	push	cx
 20652                                  
 20653 000031CB 53                      	PUSH	BX		;AN000;;>32mb
 20654 000031CC 52                      	PUSH	DX		;AN000;;>32mb
 20655 000031CD 30FF                    	XOR	BH,BH		;AN000;;>32mb
 20656                                  
 20657                                  	;invoke	$IOCTL		;AN000;;>32mb
 20658 000031CF E8DCF6                  	call	_$IOCTL	
 20659                                  
 20660 000031D2 5A                      	POP	DX		;AN000;;>32mb
 20661 000031D3 5B                      	POP	BX		;AN000;;>32mb
 20662                                  
 20663                                  	; 01/02/2024
 20664 000031D4 59                      	pop	cx
 20665                                  	;JC	short geterr	;AN000;;>32mb
 20666 000031D5 730A                    	jnc	short Set_Media_ID_2
 20667 000031D7 80FD48                  	cmp	ch,48h		; is it FAT32 disk drive request?
 20668 000031DA F9                      	stc
 20669 000031DB 7529                    	jne	short geterr	; (ch=8 request failed!)
 20670 000031DD B508                    	mov	ch,8		; set category code for (old) FAT disk drive
 20671                                  				; (except FAT32)
 20672 000031DF EBE9                    	jmp     short Set_Media_ID_1 ; and try again
 20673                                  
 20674                                  Set_Media_ID_2:
 20675 000031E1 08FF                    	OR	BH,BH		;AN000;;>32mb delete volume id
 20676 000031E3 7405                    	JZ	short NoName	;AN000;>32mb yes
 20677                                  
 20678                                  ;hkn; NAME1 is in DOSDATA
 20679 000031E5 BE[4B05]                	MOV	SI,NAME1	;AN000;>32mb
 20680                                  
 20681 000031E8 EB03                    	JMP	SHORT doset	;AN000;>32mb yes
 20682                                  NoName: 			;AN000;
 20683                                  
 20684                                  ;hkn; NO_NAME_ID is in DOSDATA
 20685 000031EA BE[0A0E]                	MOV	SI,NO_NAME_ID	;AN000;>32mb
 20686                                  
 20687                                  doset:				;AN000;
 20688 000031ED 89D7                    	MOV	DI,DX		;AN000;;>32mb
 20689                                  	;add	di,6
 20690 000031EF 83C706                  	ADD	DI,MEDIA_ID_INFO.MEDIA_Label ;AN000;;>32mb
 20691                                  
 20692                                  ;hkn; ES & DS must point to SS
 20693                                  ;hkn;	PUSH	CS		;AN000;;>32mb  move new volume id to packet
 20694 000031F2 16                      	PUSH	SS		;AN000;;>32mb  move new volume id to packet
 20695                                  
 20696 000031F3 1F                      	POP	DS		;AN000;;>32mb
 20697                                  
 20698                                  ;hkn;	PUSH	CS		;AN000;;>32mb
 20699 000031F4 16                      	PUSH	SS		;AN000;;>32mb
 20700                                  
 20701 000031F5 07                      	POP	ES		;AN000;;>32mb
 20702                                  
 20703                                  	; 01/02/2024
 20704 000031F6 51                      	push	cx
 20705                                  
 20706 000031F7 B90B00                  	MOV	CX,11		;AN000;;>32mb
 20707 000031FA F3A4                    	REP	MOVSB		;AN000;;>32mb
 20708                                  
 20709                                  	;MOV	CX,0846H	;AN001;;>32mb
 20710                                  	; 01/02/2024
 20711 000031FC 59                      	pop	cx
 20712 000031FD B146                    	mov	cl,46h		; set volume serial number (and name)
 20713                                  	;
 20714 000031FF B00D                    	MOV	AL,0DH		;AN000;;>32mb
 20715 00003201 30FF                    	XOR	BH,BH		;AN000;;>32mb
 20716                                  	;invoke	$IOCTL		;AN000;;>32mb  set volume id
 20717 00003203 E8A8F6                  	call	_$IOCTL	
 20718                                  geterr: 			;AN000;
 20719                                  ;hkn;	PUSH	CS		;AN000;>32mb
 20720 00003206 16                      	PUSH	SS		;AN000;>32mb
 20721                                  
 20722 00003207 1F                      	POP	DS		;AN000;>32mb   ds= dosgroup
 20723                                  
 20724 00003208 5F                      	POP	DI		;AN000;;>32mb
 20725 00003209 07                      	POP	ES		;AN000;;>32mb
 20726 0000320A 58                      	POP	AX		;AN000;;>32mb
 20727 0000320B C3                      	retn			;AN000;>32mb
 20728                                  
 20729                                  ; MSDOS 6.0
 20730                                  ;---------------------------------------------------------------------------
 20731                                  ; Procedure Name : Set_EXT_mode
 20732                                  ;
 20733                                  ; Inputs:
 20734                                  ;	[EXTOPEN_ON]= flag for extended open
 20735                                  ;	SAVE_BX= mode specified in Extended Open
 20736                                  ; Function:
 20737                                  ;	Set mode in ThisSFT
 20738                                  ; Outputs:
 20739                                  ;	carry set,mode is set if from Extended Open
 20740                                  ;	carry clear, mode not set yet
 20741                                  ;---------------------------------------------------------------------------
 20742                                  
 20743                                  ; 13/05/2019 - Retro DOS v4.0
 20744                                  
 20745                                  Set_EXT_mode:
 20746                                  
 20747                                  ;hkn; SS override
 20748 0000320C 36F606[F605]01          	TEST	byte [ss:EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 20749 00003212 740B                    	JZ	short NOTEX		    ;AN000;EO. no, do normal
 20750 00003214 50                      	PUSH	AX			    ;AN000;EO.
 20751                                  
 20752                                  ;hkn; SS override
 20753 00003215 36A1[0106]              	MOV	AX,[ss:SAVE_BX]		    ;AN000;EO.
 20754                                  	;or	[es:di+2],ax
 20755 00003219 26094502                	OR	[ES:DI+SF_ENTRY.sf_mode],AX ;AN000;EO.
 20756 0000321D 58                      	POP	AX			    ;AN000;EO.
 20757 0000321E F9                      	STC				    ;AN000;EO.
 20758                                  NOTEX:					    ;AN000;
 20759 0000321F C3                      	retn				    ;AN000;EO.
 20760                                  
 20761                                  ;============================================================================
 20762                                  ; OPEN.ASM, MSDOS 6.0, 1991
 20763                                  ;============================================================================
 20764                                  ; 08/08/2018 - Retro DOS v3.0
 20765                                  ; 18/05/2019 - Retro DOS v4.0
 20766                                  
 20767                                  ;	TITLE	DOS_OPEN - Internal OPEN call for MS-DOS
 20768                                  ;	NAME	DOS_OPEN
 20769                                  
 20770                                  ;**	OPEN.ASM - File Open
 20771                                  ;----------------------------------------------------------------------------
 20772                                  ;	Low level routines for openning a file from a file spec.
 20773                                  ;	Also misc routines for sharing errors
 20774                                  ;
 20775                                  ;	DOS_Open
 20776                                  ;	Check_Access_AX
 20777                                  ;	SHARE_ERROR
 20778                                  ;	SET_SFT_MODE
 20779                                  ;	Code_Page_Mismatched_Error		   ; DOS 4.00
 20780                                  ;
 20781                                  ;	Revision history:
 20782                                  ;
 20783                                  ;	    Created: ARR 30 March 1983
 20784                                  ;	    A000	version 4.00   Jan. 1988
 20785                                  ;
 20786                                  ;	M034 - The value in save_bx must be pushed on to the stack for
 20787                                  ; 	       remote extended opens and not save_cx.
 20788                                  ;
 20789                                  ;	M035 - if open made from exec then we must set the appropriate bits
 20790                                  ;	       on the stack before calling off to the redir.
 20791                                  ;	M042 - Bit 11 of DOS34_FLAG set indicates that the redir knows how 
 20792                                  ;	       to handle open from exec. In this case set the appropriate bit
 20793                                  ;	       else do not.
 20794                                  ;----------------------------------------------------------------------------	
 20795                                  
 20796                                  ;Installed = TRUE
 20797                                  
 20798                                  ;	i_need	NoSetDir,BYTE
 20799                                  ;	i_need	THISSFT,DWORD
 20800                                  ;	i_need	THISCDS,DWORD
 20801                                  ;	i_need	CURBUF,DWORD
 20802                                  ;	i_need	CurrentPDB,WORD
 20803                                  ;	i_need	CURR_DIR_END,WORD
 20804                                  ;	I_need	RetryCount,WORD
 20805                                  ;	I_need	Open_Access,BYTE
 20806                                  ;	I_need	fSharing,BYTE
 20807                                  ;	i_need	JShare,DWORD
 20808                                  ;	I_need	FastOpenFlg,byte
 20809                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000;; DOS 4.00
 20810                                  ;	I_need	ALLOWED,BYTE			  ;AN000;; DOS 4.00
 20811                                  ;	I_need	EXTERR,WORD			  ;AN000;; DOS 4.00
 20812                                  ;	I_need	EXTERR_LOCUS,BYTE		  ;AN000;; DOS 4.00
 20813                                  ;	I_need	EXTERR_ACTION,BYTE		  ;AN000;; DOS 4.00
 20814                                  ;	I_need	EXTERR_CLASS,BYTE		  ;AN000;; DOS 4.00
 20815                                  ;	I_need	CPSWFLAG,BYTE			  ;AN000;; DOS 4.00
 20816                                  ;	I_need	EXITHOLD,DWORD			  ;AN000;; DOS 4.00
 20817                                  ;	I_need	THISDPB,DWORD			  ;AN000;; DOS 4.00
 20818                                  ;	I_need	SAVE_CX,WORD			  ;AN000;; DOS 4.00
 20819                                  ;	I_need	SAVE_BX,WORD			  ;M034
 20820                                  ;
 20821                                  ;	I_need	DOS_FLAG,BYTE
 20822                                  ;	I_need	DOS34_FLAG,WORD			  ;M042
 20823                                  
 20824                                  ;Break	<DOS_Open - internal file access>
 20825                                  ;---------------------------------------------------------------------------
 20826                                  ; Procedure Name : DOS_Open
 20827                                  ;
 20828                                  ; Inputs:
 20829                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 20830                                  ;		terminated)
 20831                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 20832                                  ;		( = -1 if current dir not involved, else
 20833                                  ;		 Points to first char after last "/" of current dir part)
 20834                                  ;	[THISCDS] Points to CDS being used
 20835                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 20836                                  ;	[THISSFT] Points to SFT to fill in if file found
 20837                                  ;		(sf_mode field set so that FCB may be detected)
 20838                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 20839                                  ;	AX is Access and Sharing mode
 20840                                  ;	  High NIBBLE of AL (Sharing Mode)
 20841                                  ;		sharing_compat	   file is opened in compatibility mode
 20842                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 20843                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 20844                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 20845                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 20846                                  ;	  Low NIBBLE of AL (Access Mode)
 20847                                  ;		open_for_read	file is opened for reading
 20848                                  ;		open_for_write	file is opened for writing
 20849                                  ;		open_for_both	file is opened for both reading and writing.
 20850                                  ;
 20851                                  ;	  For FCB SFTs AL should = sharing_compat + open_for_both
 20852                                  ;		(not checked)
 20853                                  ; Function:
 20854                                  ;	Try to open the specified file
 20855                                  ; Outputs:
 20856                                  ;	sf_ref_count is NOT altered
 20857                                  ;	CARRY CLEAR
 20858                                  ;	    THISSFT filled in.
 20859                                  ;	CARRY SET
 20860                                  ;	    AX is error code
 20861                                  ;		error_file_not_found
 20862                                  ;			Last element of path not found
 20863                                  ;		error_path_not_found
 20864                                  ;			Bad path (not in curr dir part if present)
 20865                                  ;		error_bad_curr_dir
 20866                                  ;			Bad path in current directory part of path
 20867                                  ;		error_invalid_access
 20868                                  ;			Bad sharing mode or bad access mode or bad combination
 20869                                  ;		error_access_denied
 20870                                  ;			Attempt to open read only file for writting, or
 20871                                  ;			open a directory
 20872                                  ;		error_sharing_violation
 20873                                  ;			The sharing mode was correct but not allowed
 20874                                  ;			generates an INT 24 on compatibility mode SFTs
 20875                                  ; DS preserved, others destroyed
 20876                                  ;----------------------------------------------------------------------------
 20877                                  
 20878                                  ; 18/05/2019 - Retro DOS v4.0
 20879                                  ; DOSCODE:6A60h (MSDOS 6.21, MSDOS.SYS)
 20880                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20881                                  ; DOSCODE:6A4Ch (MSDOS 5.0, MSDOS.SYS)
 20882                                  
 20883                                  ; 01/02/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 20884                                  ; DOSCODE:71BBh (PCDOS 7.1, IBMDOS.COM)
 20885                                  
 20886                                  DOS_OPEN:
 20887                                  	; DS has been set up to DOSDATA in file.asm and fcbio2.asm. 
 20888                                  
 20889 00003220 C606[4C03]00            	MOV	byte [NoSetDir],0
 20890 00003225 E83301                  	CALL	Check_Access_AX
 20891 00003228 722B                    	JC	short do_ret_label	    ; retc
 20892                                  
 20893 0000322A C43E[9E05]              	LES	DI,[THISSFT]
 20894 0000322E 30E4                    	XOR	AH,AH
 20895                                  
 20896                                  	; sleaze! move only access/sharing mode in. Leave sf_isFCB unchanged
 20897                                  
 20898 00003230 26884502                	MOV	[ES:DI+SF_ENTRY.sf_mode],AL ; For moment do this on FCBs too
 20899 00003234 06                      	PUSH	ES
 20900 00003235 C436[A205]              	LES	SI,[THISCDS]
 20901                                  	; 18/08/2018
 20902 00003239 83FEFF                  	CMP	SI,-1 ; 0FFFFh
 20903 0000323C 7530                    	JNZ	short TEST_RE_NET1
 20904 0000323E 07                      	POP	ES
 20905                                  
 20906                                  	; MSDOS 6.0
 20907                                  ;Extended open hooks
 20908 0000323F F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;FT. from extended open		;AN000;
 20909 00003244 7410                    	JZ	short _NOEXTOP 		    ;FT. no, do normal			;AN000;
 20910                                  _IFS_extopen:									;AN000;
 20911 00003246 A0[0106]                	MOV	AL,[SAVE_BX]		    ; M034 - save_bx has original bx  
 20912                                  					    ; with which call was made. This
 20913                                  					    ; has the open access bits. 
 20914                                  	;;MOV	AL,[SAVE_CX]		    ; M034 - FT. al= create attribute
 20915                                  	
 20916 00003249 50                      	PUSH	AX			    ;FT. pass create attr to IFS	;AN000;
 20917                                  	;mov	ax,112Eh
 20918                                  	;MOV	AX,(MultNET SHL 8) OR 46    ;FT. issue extended open verb	;AN000;
 20919 0000324A B82E11                  	mov	ax,(MultNET*256)+46 
 20920 0000324D CD2F                    	INT	2FH			    ;FT.				;AN000;
 20921 0000324F 5B                      	POP	BX			    ;FT. trash bx			;AN000;
 20922 00003250 C606[F605]00            	MOV	byte [EXTOPEN_ON],0	    ;FT.				;AN000;
 20923                                  
 20924                                  do_ret_label:
 20925 00003255 C3                      	retn				    ;FT.				;AN000;
 20926                                  _NOEXTOP:
 20927                                  ;Extended open hooks
 20928                                  	;
 20929                                  ;IF NOT Installed
 20930                                  	;transfer NET_SEQ_OPEN
 20931                                  ;ELSE
 20932                                  	
 20933                                  do_net_int2f:
 20934 00003256 F606[8600]01            	test	byte [DOS_FLAG],EXECOPEN ; Q: was this open call made from exec
 20935 0000325B 7409                    	jz	short not_exec_open	; N: just do net open
 20936                                  					; Y: check to see if redir is aware
 20937                                  					;    of this 
 20938                                  	
 20939                                  					; M042 - start
 20940                                  	;test	word [DOS34_FLAG],EXEC_AWARE_REDIR ; 800h
 20941 0000325D F606[1206]08            	test	byte [DOS34_FLAG+1],(EXEC_AWARE_REDIR>>8)
 20942                                  					; Q: does this redir know how to 
 20943                                  					;    this
 20944 00003262 7402                    	jz	short not_exec_open	; N: just do net open
 20945                                  					; Y: set bit 3 of access byte and 
 20946                                  					;    set sharing mode to DENY_WRITE
 20947                                  					; M042 - end
 20948                                  	
 20949                                  	; NOTE: This specific mode has not been set for the code assembled
 20950                                  	; under the "NOT Installed" conditional. Currently Installed is 
 20951                                  	; always one.
 20952                                  					; M035 - set the bits on the stack
 20953                                  	;mov	al,23h
 20954 00003264 B023                    	mov	AL,SHARING_DENY_WRITE+EXEC_OPEN
 20955                                  	
 20956                                  not_exec_open:
 20957                                  	; MSDOS 3.3 & MSDOS 6.0
 20958 00003266 50                      	PUSH	AX
 20959                                  
 20960                                  	;MOV	AX,(MultNET SHL 8) OR 22
 20961                                  	;INT	2FH
 20962                                  
 20963 00003267 B81611                  	mov     ax,1116h
 20964 0000326A CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE
 20965                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 20966                                  			; SDA first filename pointer -> fully-qualified name of file to open
 20967                                  			; STACK: WORD file open mode
 20968                                  			; Return: CF set on error
 20969                                  
 20970 0000326C 5B                      	POP	BX			; clean stack
 20971                                  ;do_ret_label: ; 09/08/2018
 20972 0000326D C3                      	retn
 20973                                  ;ENDIF
 20974                                  
 20975                                  TEST_RE_NET1:
 20976                                  	;TEST	word [ES:SI+curdir.flags],curdir_isnet
 20977                                  	; 17/12/2022
 20978 0000326E 26F6444480              	test	byte [ES:SI+curdir.flags+1],curdir_isnet>>8
 20979 00003273 07                      	POP	ES
 20980                                  	; 18/05/2019
 20981 00003274 7409                    	JZ	short LOCAL_OPEN
 20982                                  
 20983                                  ;Extended open hooks
 20984                                  	; MSDOS 6.0
 20985 00003276 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;FT. from extended open	;AN000;
 20986 0000327B 75C9                    	JNZ	short _IFS_extopen	      ;FT. issue extended open	;AN000;
 20987                                  ;Extended open hooks
 20988                                  
 20989                                  ;IF NOT Installed
 20990                                  ;	transfer NET_OPEN
 20991                                  ;ELSE
 20992 0000327D EBD7                    	jmp	short do_net_int2f
 20993                                  ;ENDIF
 20994                                  
 20995                                  LOCAL_OPEN:
 20996                                  	; MSDOS 3.3 & MSDOS 6.0
 20997 0000327F E881E6                  	call	ECritDisk
 20998                                  
 20999                                  ; DOS 3.3 FastOPen 6/16/86
 21000                                  
 21001                                  	;or	byte [FastOpenFlg],5
 21002 00003282 800E[6D12]05            	OR	byte [FastOpenFlg],FastOpen_Set+Special_Fill_Set ; only open can
 21003                                  
 21004 00003287 E84A16                  	call	GETPATH
 21005                                  
 21006                                  ; DOS 3.3 FastOPen 6/16/86
 21007                                  
 21008 0000328A 731D                    	JNC	short Open_found
 21009 0000328C 7511                    	JNZ	short bad_path2
 21010 0000328E 08C9                    	OR	CL,CL
 21011 00003290 740D                    	JZ	short bad_path2
 21012                                  OpenFNF:
 21013 00003292 B80200                  	MOV	AX,error_file_not_found	; 2
 21014                                  OpenBadRet:
 21015                                  ;hkn; FastOpenFlg is in DOSDATA use SS override
 21016                                  	; 12/08/2018
 21017                                  	;mov	byte [cs:FastOpenFlg],0 ; IBMDOS.COM (MSDOS 3.3) offset 36CAh
 21018                                  	; MSDOS 6.0
 21019 00003295 368026[6D12]80          	AND	BYTE [SS:FastOpenFlg],Fast_yes    ;; DOS 3.3
 21020 0000329B F9                      	STC
 21021                                  	;call	LCritDisk
 21022                                  	; 16/12/2022
 21023 0000329C E991E6                  	jmp	LCritDisk
 21024                                  	;;JMP	Clear_FastOpen ; 10/08/2018
 21025                                  	;retn 	; 08/09/2018
 21026                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21027                                  	;jmp	Clear_FastOpen
 21028                                  
 21029                                  bad_path2:
 21030 0000329F B80300                  	MOV	AX,error_path_not_found	; 3
 21031 000032A2 EBF1                    	JMP	short OpenBadRet
 21032                                  
 21033                                  Open_Bad_Access:
 21034 000032A4 B80500                  	MOV	AX,error_access_denied	; 5
 21035 000032A7 EBEC                    	JMP	short OpenBadRet
 21036                                  
 21037                                  Open_found:
 21038 000032A9 74F9                    	JZ	short Open_Bad_Access 	; test for directories
 21039 000032AB 08E4                    	OR	AH,AH
 21040 000032AD 783E                    	JS	short open_ok		; Devices don't have attributes
 21041 000032AF 8E06[E405]              	MOV	ES,[CURBUF+2]		; get buffer location
 21042                                  	;mov	al,[es:bx+0Bh]
 21043 000032B3 268A470B                	MOV	AL,[ES:BX+dir_entry.dir_attr]
 21044 000032B7 A808                    	TEST	AL,attr_volume_id	; can't open volume ids
 21045 000032B9 75E9                    	JNZ	short Open_Bad_Access
 21046 000032BB A801                    	TEST	AL,attr_read_only	; check write on read only
 21047 000032BD 742E                    	JZ	short open_ok
 21048                                  
 21049                                  ; The file is marked READ-ONLY. We verify that the open mode allows access to
 21050                                  ; the read-only file. Unfortunately, with FCB's and net-FCB's we cannot
 21051                                  ; determine at the OPEN time if such access is allowed. Thus, we defer such
 21052                                  ; processing until the actual write operation:
 21053                                  ;
 21054                                  ; If FCB, then we change the mode to be read_only.
 21055                                  ; If net_FCB, then we change the mode to be read_only.
 21056                                  ; If not open for read then error.
 21057                                  
 21058 000032BF 1E                      	push	ds
 21059 000032C0 56                      	push	si
 21060 000032C1 C536[9E05]              	LDS	SI,[THISSFT]
 21061                                  	;mov	cx,[si+2]
 21062 000032C5 8B4C02                  	MOV	CX,[SI+SF_ENTRY.sf_mode]
 21063                                  	; 17/12/2022
 21064                                  	;test	ch,80h
 21065 000032C8 F6C580                  	test	ch,sf_isFCB>>8
 21066                                  	;TEST	CX,sf_isFCB ; 8000h	; is it FCB?
 21067 000032CB 750A                    	JNZ	short ResetAccess	; yes, reset the access
 21068 000032CD 88CA                    	MOV	DL,CL
 21069 000032CF 80E2F0                  	AND	DL,SHARING_MASK	; 0F0h
 21070 000032D2 80FA70                  	CMP	DL,SHARING_NET_FCB ; 70h ; is it net FCB?
 21071 000032D5 7508                    	JNZ	short NormalOpen	; no
 21072                                  ResetAccess:
 21073                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)	
 21074                                  	;AND	CX,~access_mask	; 0FFF0h ; clear access
 21075                                  	; 16/12/2022
 21076                                  	;and	cl,0F0h ; 18/05/2019
 21077                                  	;;;
 21078                                  	; 01/02/2024 - Retro DOS v5.0
 21079                                  	; (PCDOS 7.1 IBMDOS.COM)
 21080                                  	;and	cx,0FFFCh
 21081 000032D7 80E1FC                  	and	cl,0FCh ; ~3 ; ~open_mode_mask ; clear access
 21082                                  	;;;
 21083                                  ;	OR	CX,open_for_read ; 0	; stick in open_for_read
 21084 000032DA 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],CX
 21085 000032DD EB0C                    	JMP	SHORT FillSFT
 21086                                  
 21087                                  ; The SFT is normal. See if the requested access is open_for_read
 21088                                  
 21089                                  NormalOpen:
 21090                                  	;AND	CL,access_mask	; 0Fh	; remove extras
 21091                                  	;;;
 21092                                  	; 01/02/2024 - Retro DOS v5.0
 21093                                  	; (PCDOS 7.1 IBMDOS.COM)
 21094 000032DF 80E103                  	and     cl,3		; it was 'and cl,0Fh' in MSDOS 6.22
 21095                                  				; (and cl,access_mask)
 21096                                  				; this may be open_mode_mask
 21097                                  	;;;
 21098 000032E2 80F900                  	CMP	CL,open_for_read ; 0	; is it open for read?
 21099 000032E5 7404                    	JZ	short FillSFT	; yes
 21100 000032E7 5E                      	pop	si
 21101 000032E8 1F                      	pop	ds
 21102 000032E9 EBB9                    	JMP	short Open_Bad_Access
 21103                                  ;
 21104                                  ; All done, restore registers and fill the SFT.
 21105                                  ;
 21106                                  FillSFT:
 21107 000032EB 5E                      	pop	si
 21108 000032EC 1F                      	pop	ds
 21109                                  open_ok:
 21110 000032ED E80E22                  	call	DOOPEN			; Fill in SFT
 21111                                  
 21112                                  ;hkn; FastOpenFlg is in DOSDATA. use SS override
 21113                                  	; 18/05/2019
 21114                                  	;and	byte [ss:FastOpenFlag],80h
 21115 000032F0 368026[6D12]80          	AND	BYTE [SS:FastOpenFlg],Fast_yes	;; DOS 3.3
 21116                                  	; 12/08/2018
 21117                                  	;and	byte [FastOpenFlg],Fast_yes	
 21118                                  
 21119                                  	; MSDOS 6.0
 21120 000032F6 E84300                  	CALL	DO_SHARE_CHECK
 21121 000032F9 7303                    	JNC	short SHARE_OK
 21122                                  	;call	LCritDisk
 21123                                  	; 16/12/2022
 21124 000032FB E932E6                  	jmp	LCritDisk
 21125                                  	;;JMP	short Clear_FastOpen
 21126                                  	;retn	; 18/05/2019
 21127                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21128                                  	;jmp	short Clear_FastOpen	
 21129                                  
 21130                                  	; MSDOS 3.3
 21131                                  ;DO_SHARE_CHECK:
 21132                                  ;	MOV	CX,[RetryCount]		; Get # tries to do
 21133                                  ;OpenShareRetry:
 21134                                  ;	push	cx			; Save number left to do
 21135                                  ;	call	SHARE_CHECK		; Final Check
 21136                                  ;	pop	cx			; CX = # left
 21137                                  ;	JNC	short SHARE_OK		; No problem with access
 21138                                  ;	call	Idle
 21139                                  ;	LOOP	OpenShareRetry		; One more retry used up
 21140                                  ;OpenShareFail:
 21141                                  ;	LES	DI,[THISSFT]
 21142                                  ;	call	SHARE_ERROR
 21143                                  ;	JNC	short DO_SHARE_CHECK	; User wants more retry
 21144                                  	
 21145                                  	;12/08/2018
 21146                                  	;mov	byte [ss:FastOpenFlg],0
 21147                                  	;08/09/2018
 21148                                  	;mov	byte [FastOpenFlg],0
 21149                                  	;call	LCritDisk
 21150                                  	;JMP	short Clear_FastOpen
 21151                                  	;retn
 21152                                  
 21153                                  SHARE_OK:
 21154                                  	; MSDOS 3.3 & MSDOS 6.0
 21155 000032FE B80300                  	MOV	AX,3
 21156 00003301 C43E[9E05]              	LES	DI,[THISSFT]
 21157                                  ;if installed
 21158                                  	;call	JShare + 14 * 4
 21159 00003305 FF1E[C800]              	call	far [JShare+(14*4)]  ; 14 = ShSU
 21160                                  ;else
 21161                                  ;	Call	ShSU
 21162                                  ;endif
 21163 00003309 E824E6                  	call	LCritDisk
 21164                                  	
 21165                                  	;FallThru Set_SFT_Mode
 21166                                  
 21167                                  ;----------------------------------------------------------------------------
 21168                                  ; Procedure Name : SET_SFT_MODE
 21169                                  ;
 21170                                  ; Finish SFT initialization for new reference. Set the correct mode.
 21171                                  ;
 21172                                  ;   Inputs:
 21173                                  ;	ThisSFT points to SFT
 21174                                  ;
 21175                                  ;   Outputs:
 21176                                  ;	Carry clear
 21177                                  ;   Registers modified: AX.
 21178                                  ;---------------------------------------------------------------------------
 21179                                  
 21180                                  ;hkn; called from create. DS already set up to DOSDATA.
 21181                                  
 21182                                  SET_SFT_MODE:
 21183 0000330C C43E[9E05]              	LES	DI,[THISSFT]
 21184 00003310 E88E1C                  	call	DEV_OPEN_SFT
 21185                                  	;test	word [es:di+2],8000h
 21186                                  	; 17/12/2022
 21187                                  	;test	byte [es:di+3],80h
 21188 00003313 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],sf_isFCB>>8
 21189                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; Clears carry
 21190 00003318 7407                    	JZ	short Clear_FastOpen	; sf_mode correct (retz)
 21191 0000331A A1[3003]                	MOV	AX,[CurrentPDB]
 21192                                  	;mov	[es:di+31h],ax
 21193 0000331D 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX ; For FCB sf_PID=PDB
 21194                                  
 21195                                  Clear_FastOpen:
 21196 00003321 C3                      	retn			       ;;;;; DOS 3.3
 21197                                  
 21198                                  ;----------------------------------------------------------------------------
 21199                                  ; Procedure Name : SHARE_ERROR
 21200                                  ;
 21201                                  ; Called on sharing violations. ES:DI points to SFT. AX has error code
 21202                                  ; If SFT is FCB or compatibility mode gens INT 24 error.
 21203                                  ; Returns carry set AX=error_sharing_violation if user says ignore (can't
 21204                                  ; really ignore). Carry clear if user wants a retry. ES, DI, DS preserved
 21205                                  ;---------------------------------------------------------------------------
 21206                                  
 21207                                  SHARE_ERROR:
 21208                                  	; 17/12/2022
 21209                                  	;test	byte [es:di+3],80h
 21210 00003322 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],sf_isFCB>>8 ; 80h
 21211                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; 8000h
 21212 00003327 7509                    	JNZ	short _HARD_ERR
 21213 00003329 268A4D02                	MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 21214 0000332D 80E1F0                  	AND	CL,SHARING_MASK  ; 0F0h
 21215                                  	;CMP	CL,SHARING_COMPAT ; 0
 21216                                  	;JNE	short _NO_HARD_ERR
 21217                                  	; 21/09/2023
 21218 00003330 7505                    	jnz	short _NO_HARD_ERR
 21219                                  _HARD_ERR:
 21220 00003332 E8034A                  	call	SHARE_VIOLATION
 21221                                  	;retnc				; User wants retry
 21222 00003335 73EA                    	jnc	short Clear_FastOpen
 21223                                  _NO_HARD_ERR:
 21224 00003337 B82000                  	MOV	AX,error_sharing_violation  ; 20h
 21225 0000333A F9                      	STC
 21226 0000333B C3                      	retn
 21227                                  
 21228                                  ; MSDOS 6.0
 21229                                  ;----------------------------------------------------------------------------
 21230                                  ; Procedure Name : DO_SHARE_CHECK
 21231                                  ;
 21232                                  ; Input: THISDPB, WFP_Start, THISSFT set
 21233                                  ; Functions: check file sharing mode is valid
 21234                                  ; Output: carry set, error
 21235                                  ;	  carry clear, share ok
 21236                                  ;----------------------------------------------------------------------------
 21237                                  
 21238                                  	; 18/05/2019 - Retro DOS v4.0
 21239                                  DO_SHARE_CHECK:
 21240 0000333C E8C4E5                  	call	ECritDisk		; enter critical section
 21241                                  OPN_RETRY:
 21242 0000333F 8B0E[1A00]              	MOV	CX,[RetryCount]		; Get # tries to do
 21243                                  OpenShareRetry:
 21244 00003343 51                      	push	cx			; Save number left to do
 21245 00003344 E8EC49                  	call	SHARE_CHECK		; Final Check
 21246 00003347 59                      	pop	cx			; CX = # left
 21247 00003348 730E                    	JNC	short Share_Ok2		; No problem with access
 21248 0000334A E8AFE4                  	call	Idle
 21249 0000334D E2F4                    	LOOP	OpenShareRetry		; One more retry used up
 21250                                  OpenShareFail:
 21251 0000334F C43E[9E05]              	LES	DI,[THISSFT]
 21252 00003353 E8CCFF                  	call	SHARE_ERROR
 21253 00003356 73E7                    	JNC	short OPN_RETRY		; User wants more retry
 21254                                  Share_Ok2:
 21255                                  	;call	LCritDisk		; leave critical section
 21256                                  	;retn
 21257                                  	; 18/12/2022
 21258 00003358 E9D5E5                  	jmp	LCritDisk
 21259                                  
 21260                                  ;-----------------------------------------------------------------------------
 21261                                  ; Procedure Name : Check_Access
 21262                                  ;
 21263                                  ; Inputs:
 21264                                  ;	AX is mode
 21265                                  ;	  High NIBBLE of AL (Sharing Mode)
 21266                                  ;		sharing_compat	   file is opened in compatibility mode
 21267                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 21268                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 21269                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 21270                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 21271                                  ;	  Low NIBBLE of AL (Access Mode)
 21272                                  ;		open_for_read	file is opened for reading
 21273                                  ;		open_for_write	file is opened for writing
 21274                                  ;		open_for_both	file is opened for both reading and writing.
 21275                                  ; Function:
 21276                                  ;	Check this access mode for correctness
 21277                                  ; Outputs:
 21278                                  ;	[open_access] = AL input
 21279                                  ;	Carry Clear
 21280                                  ;		Mode is correct
 21281                                  ;		AX unchanged
 21282                                  ;	Carry Set
 21283                                  ;		Mode is bad
 21284                                  ;		AX = error_invalid_access
 21285                                  ; No other registers effected
 21286                                  ;----------------------------------------------------------------------------
 21287                                  
 21288                                  	; 23/01/2024 - Retro DOS v5.0
 21289                                  Check_Access_AX:
 21290 0000335B A2[6E05]                	MOV	[OPEN_ACCESS],AL
 21291 0000335E 53                      	PUSH	BX
 21292                                  
 21293                                  ;	If sharing, then test for special sharing mode for FCBs
 21294                                  
 21295 0000335F 88C3                    	MOV	BL,AL
 21296 00003361 80E3F0                  	AND	BL,SHARING_MASK ; 0F0h
 21297                                  
 21298                                  	;CMP	byte [FSHARING],-1
 21299                                  	;JNZ	short CheckShareMode	; not through server call, must be ok
 21300                                  	; 23/01/2024
 21301                                  	; PCDOS 7.1 IBMDOS.COM
 21302 00003364 803E[7205]00            	cmp	byte [FSHARING],0
 21303 00003369 7405                    	jz	short CheckShareMode	; not through server call, must be ok
 21304                                  
 21305 0000336B 80FB70                  	CMP	BL,SHARING_NET_FCB ; 70h
 21306 0000336E 7405                    	JZ	short CheckAccessMode	; yes, we have an FCB
 21307                                  CheckShareMode:
 21308 00003370 80FB40                  	CMP	BL,40h			; is this a good sharing mode?
 21309 00003373 770D                    	JA	short Make_Bad_Access
 21310                                  CheckAccessMode:
 21311 00003375 88C3                    	MOV	BL,AL
 21312                                  	; 23/01/2024
 21313 00003377 80E303                  	and	bl,3 ; PCDOS 7.1 IBMDOS.COM	
 21314                                  	;AND	BL,access_mask ; 0Fh
 21315 0000337A 80FB02                  	CMP	BL,2
 21316 0000337D 7703                    	JA	short Make_Bad_Access
 21317 0000337F 5B                      	POP	BX
 21318 00003380 F8                      	CLC
 21319 00003381 C3                      	retn
 21320                                  
 21321                                  Make_Bad_Access:
 21322 00003382 B80C00                  	MOV	AX,error_invalid_access ; 0Ch
 21323 00003385 5B                      	POP	BX
 21324 00003386 F9                      	STC
 21325 00003387 C3                      	retn
 21326                                  
 21327                                  ;============================================================================
 21328                                  ; DINFO.ASM, MSDOS 6.0, 1991
 21329                                  ;============================================================================
 21330                                  ; 08/08/2018 - Retro DOS v3.0
 21331                                  ; 18/05/2019 - Retro DOS v4.0
 21332                                  ; 02/02/2024 - Retro DOS v5.0
 21333                                  
 21334                                  ;**	Low level routine for returning disk drive information from a local
 21335                                  ;	  or NET device
 21336                                  ;
 21337                                  ;	DISK_INFO
 21338                                  ;
 21339                                  ;	  Modification history:
 21340                                  ;
 21341                                  ;		Created: ARR 30 March 1983
 21342                                  
 21343                                  ;	Break	<DISK_INFO -- Get Disk Drive Information>
 21344                                  ;---------------------------------------------------------------------------
 21345                                  ; Procedure Name : DISK_INFO
 21346                                  ;
 21347                                  ; Inputs:
 21348                                  ;	[THISCDS] Points to the Macro List Structure of interest
 21349                                  ;		(It MAY NOT be NUL, error not detected)
 21350                                  ; Function:
 21351                                  ;	Get Interesting Drive Information
 21352                                  ; Returns:
 21353                                  ;	DX = Number of free allocation units
 21354                                  ;	BX = Total Number of allocation units on disk
 21355                                  ;	CX = Sector size
 21356                                  ;	AL = Sectors per allocation unit
 21357                                  ;	AH = FAT ID BYTE
 21358                                  ;	Carry set if error (currently user FAILed to I 24)
 21359                                  ; Segs except ES preserved, others destroyed
 21360                                  ;----------------------------------------------------------------------------
 21361                                  
 21362                                  ;hkn; called from getset.asm and misc.asm. DS has already been set up to
 21363                                  ;hkn; DOSDATA. 
 21364                                  
 21365                                  	; 02/02/2024 - Retro DOS v5.0
 21366                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:732Bh
 21367                                  
 21368                                  DISK_INFO:
 21369                                  	; 08/08/2018 - Retro DOS v3.0
 21370                                  	; IBM DOS.COM (MSDOS 3.3, 1987) - Offset 37C5h
 21371                                  
 21372 00003388 E8B6E4                  	call	TestNet
 21373 0000338B 7318                    	JNC	short LOCAL_DSK_INFO
 21374                                  
 21375                                  	;;;
 21376                                  	; 02/02/2024 (PCDOS 7.1 IBMDOS.COM)
 21377 0000338D 31F6                    	xor     si,si	; free cluster count hw = 0
 21378 0000338F 31FF                    	xor     di,di	; number of clusters hw = 0
 21379                                  	;;;
 21380                                  
 21381                                  ;IF NOT Installed
 21382                                  ;	transfer NET_DISK_INFO
 21383                                  ;ELSE
 21384                                  	;MOV	AX,(MultNET SHL 8) OR 12
 21385                                  	;INT	2FH
 21386                                  	;return
 21387                                  
 21388 00003391 B80C11                  	mov     ax,110Ch
 21389 00003394 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
 21390                                  			; ES:DI -> current directory
 21391                                  			; Return: AL = sectors per cluster, BX = total clusters
 21392                                  			; CX = bytes per sector, DX = number of available clusters
 21393                                  	;;;
 21394                                  	; 02/02/2024 (PCDOS 7.1 IBMDOS.COM)
 21395 00003396 83FBFF                  	cmp	bx,0FFFFh
 21396 00003399 7502                    	jne	short dsk_info_1
 21397 0000339B 89DF                    	mov	di,bx
 21398                                  dsk_info_1:
 21399 0000339D 83FAFF                  	cmp	dx,0FFFFh
 21400 000033A0 7502                    	jne	short disk_info_retn
 21401 000033A2 89D6                    	mov	si,dx
 21402                                  disk_info_retn:
 21403                                  	;;;
 21404 000033A4 C3                      	retn
 21405                                  ;ENDIF
 21406                                  
 21407                                  LOCAL_DSK_INFO:
 21408                                  	;MOV	byte [EXTERR_LOCUS],errLOC_Disk
 21409                                  	;;;
 21410                                  	; 02/02/2024 (PCDOS 7.1 IBMDOS.COM)
 21411 000033A5 E856DF                  	call	set_exerr_locus_disk
 21412                                  	;;;
 21413 000033A8 E858E5                  	call	ECritDisk
 21414 000033AB E8DB2C                  	call	FATREAD_CDS		; perform media check.
 21415                                  	;JC	short CRIT_LEAVE
 21416                                  	;;; 02/02/2024
 21417 000033AE 720D                    	jc	short dsk_info_2
 21418 000033B0 31C0                    	xor	ax,ax
 21419 000033B2 A3[EF0A]                	mov	[CLUSTNUM_HW],ax ; 0	; clear high word of cluster number
 21420                                  	;;;
 21421 000033B5 BB0200                  	MOV	BX,2
 21422 000033B8 E8372B                  	call	UNPACK			; Get first FAT sector into CURBUF
 21423                                  	;JC	short CRIT_LEAVE
 21424                                  	;;;
 21425                                  	; 02/02/2024 - Retro DOS v5.0
 21426 000033BB 7303                    	jnc	short dsk_info_3
 21427                                  dsk_info_2:
 21428                                  	;jmp	CRIT_LEAVE
 21429 000033BD E970E5                  	jmp	LCritDisk
 21430                                  dsk_info_3:
 21431                                  	;;;
 21432 000033C0 C536[E205]              	LDS	SI,[CURBUF]
 21433                                  	; 02/02/2024
 21434                                  	;;mov	ah,[si+20]
 21435                                  	;mov	ah,[si+24] ; PCDOS 71. IBMDOS.COM
 21436 000033C4 8A6418                  	MOV	AH,[SI+BUFINSIZ]	; get FAT ID BYTE
 21437                                  
 21438                                  ;hkn; SS is DOSDATA
 21439 000033C7 16                      	push	ss
 21440 000033C8 1F                      	pop	ds
 21441                                  
 21442                                  ; 02/02/2024 - Retro DOS v5.0
 21443                                  %if 0
 21444                                  	;mov	cx,[es:bp+0Dh]
 21445                                  	MOV	CX,[ES:BP+DPB.MAX_CLUSTER]
 21446                                  
 21447                                  ; Examine the current free count. If it indicates that we have an invalid
 21448                                  ; count, do the expensive calculation.
 21449                                  
 21450                                  	;mov	dx,[es:bp+1Fh]
 21451                                  	MOV	DX,[ES:BP+DPB.FREE_CNT] ; get free count
 21452                                  	CMP	DX,-1			; is it valid?
 21453                                  	JZ	short DoScan
 21454                                  
 21455                                  ; Check to see if it is in a reasonable range. If so, trust it and return.
 21456                                  ; Otherwise, we need to blast out an internal error message and then recompute
 21457                                  ; the count.
 21458                                  
 21459                                  	CMP	DX,CX			; is it in a reasonable range?
 21460                                  	JB	short GotVal		; yes, trust it.
 21461                                  DoScan:
 21462                                  	XOR	DX,DX
 21463                                  	DEC	CX
 21464                                  SCANFREE:
 21465                                  	call	UNPACK
 21466                                  	JC	short CRIT_LEAVE
 21467                                  	JNZ	short NOTFREECLUS
 21468                                  	INC	DX			; A free one
 21469                                  NOTFREECLUS:
 21470                                  	INC	BX			; Next cluster
 21471                                  	LOOP	SCANFREE
 21472                                  	DEC	BX			; BX was next cluster. Convert to
 21473                                  ReturnVals:
 21474                                  	DEC	BX			; count
 21475                                  	;mov	al,[es:bp+4]
 21476                                  	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
 21477                                  	INC	AL			; Sectors/cluster
 21478                                  	;mov	cx,[es:bp+2]
 21479                                  	MOV	CX,[ES:BP+DPB.SECTOR_SIZE] ; Bytes/sector
 21480                                  	;mov	[es:bp+1Fh],dx
 21481                                  	MOV	[ES:BP+DPB.FREE_CNT],DX
 21482                                  	CLC
 21483                                  CRIT_LEAVE:
 21484                                  	;call	LCritDisk
 21485                                  	;retn
 21486                                  	; 17/12/2022
 21487                                  	jmp	LCritDisk
 21488                                  
 21489                                  ; We have correctly computed everything previously. Load up registers for
 21490                                  ; return.
 21491                                  
 21492                                  GotVal: 
 21493                                  	MOV	BX,CX			; get cluster count
 21494                                  	JMP	short ReturnVals
 21495                                  
 21496                                  %else
 21497                                  	; 02/02/2024 (PCDOS 7.1 IBMDOS.COM)
 21498 000033C9 31F6                    	xor	si,si	; 0
 21499 000033CB 89F7                    	mov	di,si	; 0
 21500                                  	;mov	dx,[es:bp+1Fh]
 21501 000033CD 268B561F                	mov	dx,[es:bp+DPB.FREE_CNT]	; get free count
 21502                                  	;cmp	[es:bp+0Fh],si
 21503 000033D1 2639760F                	cmp	[es:bp+DPB.FAT_SIZE],si ; FAT32 (16 bit FAT size = 0) ?
 21504 000033D5 7406                    	jz	short dsk_info_4	; yes
 21505                                  	;mov	cx,[es:bp+0Dh]
 21506 000033D7 268B4E0D                	mov	cx,[es:bp+DPB.MAX_CLUSTER]
 21507 000033DB EB18                    	jmp	short dsk_info_5 ; zf=0, si=di=0
 21508                                  
 21509                                  dsk_info_4:
 21510                                  	;mov	di,[es:bp+2Fh]
 21511 000033DD 268B7E2F                	mov	di,[es:bp+DPB.LAST_CLUSTER+2]
 21512                                  	;mov	cx,[es:bp+2Dh]
 21513 000033E1 268B4E2D                	mov	cx,[es:bp+DPB.LAST_CLUSTER]
 21514                                  	;mov	si,[es:bp+21h]
 21515 000033E5 268B7621                	mov	si,[es:bp+DPB.FREE_CNT_HW] ; hw of free cluster count
 21516 000033E9 39F2                    	cmp	dx,si			; same (zero) ?
 21517                                  ;dsk_info_5:
 21518 000033EB 7504                    	jnz	short dsk_info_6	; not same (not zero)
 21519 000033ED 42                      	inc	dx
 21520 000033EE 740B                    	jz	short dsk_info_8	; 0FFFFh -> 0 (free count is invalid/initial)
 21521                                  					; free count calculation is needed
 21522 000033F0 4A                      	dec	dx
 21523                                  dsk_info_6:
 21524 000033F1 39FE                    	cmp	si,di			; same hw ?
 21525 000033F3 7502                    	jne	short dsk_info_7	; no
 21526                                  dsk_info_5:	; 02/02/2024 - Retro DOS v5.0 
 21527 000033F5 39CA                    	cmp	dx,cx			; same lw ?
 21528                                  dsk_info_7:
 21529 000033F7 7268                    	jb	short GotVal		; free cluster count < last cluster number
 21530 000033F9 31D2                    	xor	dx,dx	; 0
 21531                                  dsk_info_8:
 21532 000033FB 31F6                    	xor	si,si	; 0
 21533 000033FD 83E901                  	sub	cx,1			; last cluster number - 1 = number of clusters
 21534 00003400 19F7                    	sbb	di,si
 21535                                  	;or	byte [es:bp+18h],1
 21536 00003402 26804E1801              	or	byte [es:bp+DPB.FIRST_ACCESS],1 ; set first access bit 0
 21537                                  					; (Update flag for FSINFO sector)
 21538                                  SCANFREE:
 21539 00003407 56                      	push	si
 21540 00003408 FF36[F30A]              	push	word [CCONTENT_HW]
 21541 0000340C 57                      	push	di
 21542 0000340D E8E22A                  	call	UNPACK
 21543 00003410 5F                      	pop	di
 21544 00003411 8F06[F30A]              	pop	word [CCONTENT_HW]
 21545 00003415 5E                      	pop	si
 21546 00003416 7246                    	jc	short CRIT_LEAVE
 21547 00003418 7504                    	jnz	short NOTFREECLUS
 21548 0000341A 42                      	inc	dx			; a free one
 21549 0000341B 7501                    	jnz	short NOTFREECLUS
 21550 0000341D 46                      	inc	si			; increase hw of free cluster count
 21551                                  
 21552                                  NOTFREECLUS:
 21553 0000341E 43                      	inc	bx			; next cluster
 21554 0000341F 7504                    	jnz	short NOTFREECLUS2
 21555 00003421 FF06[EF0A]              	inc	word [CLUSTNUM_HW]	; increase hw of (next) cluster number
 21556                                  
 21557                                  NOTFREECLUS2:
 21558 00003425 83E901                  	sub	cx,1			; decrease remain cluster count for calculation
 21559 00003428 83DF00                  	sbb	di,0
 21560 0000342B 75DA                    	jnz	short SCANFREE
 21561 0000342D E302                    	jcxz	NOTFREECLUS3		; calculation completed
 21562 0000342F EBD6                    	jmp	short SCANFREE
 21563                                  
 21564                                  NOTFREECLUS3:
 21565 00003431 8B3E[EF0A]              	mov	di,[CLUSTNUM_HW]
 21566 00003435 83EB01                  	sub	bx,1
 21567 00003438 83DF00                  	sbb	di,0			; di:bx = last cluster number
 21568                                  
 21569                                  ReturnVals:
 21570 0000343B 31C9                    	xor	cx,cx
 21571 0000343D 83EB01                  	sub	bx,1
 21572 00003440 19CF                    	sbb	di,cx			; di:bx = number of clusters
 21573                                  	;mov	al,[es:bp+4]
 21574 00003442 268A4604                	mov	al,[es:bp+DPB.CLUSTER_MASK] ; spc - 1
 21575 00003446 FEC0                    	inc	al			; sectors per cluster
 21576                                  	;mov	[es:bp+1Fh],dx		
 21577 00003448 2689561F                	mov	[es:bp+DPB.FREE_CNT],dx	; free cluster count,lw
 21578                                  	;cmp	[es:bp+0Fh],cx ; 0
 21579 0000344C 26394E0F                	cmp	[es:bp+DPB.FAT_SIZE],cx ; 0 ; FAT32 (16 bit FAT size = 0) ?
 21580 00003450 7507                    	jnz	short ReturnVals2	; no
 21581                                  	;mov	[es:bp+21h],si
 21582 00003452 26897621                	mov	[es:bp+DPB.FREE_CNT_HW],si ; hw of free cluster count
 21583                                  
 21584 00003456 E83800                  	call	update_fat32_fsinfo
 21585                                  
 21586                                  ReturnVals2:
 21587                                  	;mov	cx,[es:bp+2]
 21588 00003459 268B4E02                	mov	cx,[es:bp+DPB.SECTOR_SIZE] ; bytes per sector
 21589 0000345D F8                      	clc
 21590                                  
 21591                                  CRIT_LEAVE:
 21592                                  	;call	LCritDisk
 21593                                  	;retn
 21594 0000345E E9CFE4                  	jmp	LCritDisk
 21595                                  
 21596                                  GotVal:
 21597 00003461 89CB                    	mov	bx,cx
 21598 00003463 EBD6                    	jmp	short ReturnVals
 21599                                  
 21600                                  %endif
 21601                                  
 21602                                  ; =============== S U B R O U T I N E =======================================
 21603                                  
 21604                                  ; 03/02/2024 - Retro DOS v5.0
 21605                                  
 21606                                  modify_spc:
 21607 00003465 50                      	push	ax			; ax = sectors per cluster
 21608 00003466 52                      	push	dx
 21609 00003467 F7E1                    	mul	cx			; bytes per sector
 21610                                  	;cmp	dx,0
 21611 00003469 21D2                    	and	dx,dx
 21612 0000346B 7503                    	jnz	short mspc_1
 21613 0000346D 3D0040                  	cmp	ax,16384		; 16 kilobytes (per cluster)
 21614                                  					; ***
 21615                                  					; actual disk size limit
 21616                                  					; without invalidating cluster counts is
 21617                                  					; 2 GB (512K clusters * 8 sectors per cluster)
 21618                                  					;      (128K clusters * 32 sectors per cluster)
 21619                                  mspc_1:
 21620 00003470 5A                      	pop	dx
 21621 00003471 58                      	pop	ax
 21622 00003472 760E                    	jbe	short mspc_3		; bytes per cluster <= 16 KB
 21623                                                                          ; ***
 21624                                                                          ; bytes per cluster > 16 KB
 21625 00003474 31FF                    	xor	di,di			; 0
 21626 00003476 BBFEFF                  	mov	bx,0FFFEh		; (invalidated)
 21627 00003479 09F6                    	or	si,si			; hw of free cluster count
 21628 0000347B 7404                    	jz	short mspc_2		; si = 0
 21629 0000347D 89FE                    	mov	si,di			; si = 0
 21630 0000347F 89DA                    	mov	dx,bx			; dx = bx = 0FFFEh (invalidated)
 21631                                  mspc_2:
 21632 00003481 C3                      	retn
 21633                                  
 21634                                  mspc_3:
 21635 00003482 D1E0                    	shl	ax,1			; sectors per clust = sectors per clust * 2
 21636                                  					; (ax <= 32768) -modified spc limit-
 21637 00003484 D1EF                    	shr	di,1			; cluster count = cluster count /2
 21638                                  					; di:bx = modified value of total clusters
 21639                                  mspc_4:
 21640 00003486 D1DB                    	rcr	bx,1
 21641 00003488 D1EE                    	shr	si,1			; free clusters = free clusters / 2
 21642 0000348A D1DA                    	rcr	dx,1			; si:dx = modified value of free clusters
 21643                                  
 21644                                  ; ---------------------------------------------------------------------------
 21645                                  
 21646                                  	; 03/02/2024
 21647                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:7431h
 21648                                  
 21649                                  modify_cluster_count:
 21650 0000348C 09FF                    	or	di,di			; hw of cluster count
 21651 0000348E 75D5                    	jnz	short modify_spc
 21652 00003490 C3                      	retn
 21653                                  
 21654                                  ; =============== S U B R O U T I N E =======================================
 21655                                  
 21656                                  ; write FSINFO sector onto disk
 21657                                  
 21658                                  ; 03/02/2024 - Retro DOS v5.0
 21659                                  ; --------------------------------
 21660                                  ; FAT32 FSInfo Sector Structure
 21661                                  ; --------------------------------
 21662                                  ; ref: Microsoft FAT32 File System Specification (2000)
 21663                                  
 21664                                  struc FSINFO		; Offset ;
 21665 00000000 ????????                .LeadSig:	resb 4	  ; 0		; Value 0x41615252. Lead Signature.
 21666 00000004 <res 1E0h>              .Reserved1:	resb 480  ; 4		; Reserved. Must be 0. Never be used.
 21667 000001E4 ????????                .StrucSig:	resb 4	  ; 484		; Value 0x61417272. Fields Signature.
 21668 000001E8 ????????                .Free_Count:	resb 4	  ; 488		; Last known free cluster count. (*) 
 21669 000001EC ????????                .Nxt_Free:	resb 4	  ; 492		; Start clus for free clus srch. (**)
 21670 000001F0 <res Ch>                .Reserved2:	resb 12	  ; 496		; Reserved. Must be 0. Never be used.
 21671 000001FC ????????                .TrailSig:	resb 4	  ; 508		; Value 0xAA550000. Trail Signature.
 21672                                  .size:
 21673                                  endstruc
 21674                                  
 21675                                  ; (*) If the value is 0xFFFFFFFF, then the free count is unknown
 21676                                  ;     and must be computed.
 21677                                  ; (**) If the value is 0xFFFFFFFF, then free cluster search must be started
 21678                                  ;     from cluster 2.
 21679                                  ; Lead Signature, Fields (Structure) Signature and Trail Signature
 21680                                  ; are used to validate FSInfo sector.
 21681                                  
 21682                                  ; --------------------------------
 21683                                  
 21684                                  	; 03/02/2024 - Retro DOS v5.0
 21685                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:7436h
 21686                                  	; (Windows ME IO.SYS - BIOSCODE:7227h)
 21687                                  
 21688                                  update_fat32_fsinfo:
 21689 00003491 51                      	push	cx
 21690 00003492 52                      	push	dx
 21691 00003493 31C9                    	xor	cx,cx
 21692                                  	;mov	dx,[es:bp+25h]
 21693 00003495 268B5625                	mov	dx,[es:bp+DPB.FSINFO_SECTOR]
 21694                                  	;cmp	[es:bp+0Fh],cx
 21695 00003499 26394E0F                	cmp	[es:bp+DPB.FAT_SIZE],cx ; 0
 21696                                  				; (16bit FAT size field = 0 for FAT32 fs)
 21697 0000349D 7505                    	jne	short u_fat32_inf_1
 21698 0000349F 83FAFF                  	cmp	dx,0FFFFh ; -1
 21699 000034A2 7508                    	jne	short u_fat32_inf_2
 21700                                  
 21701                                  u_fat32_inf_1:
 21702 000034A4 5A                      	pop	dx
 21703 000034A5 59                      	pop	cx
 21704                                  	;and	byte [es:bp+18h],0F4h
 21705 000034A6 26806618F4              	and	byte [es:bp+DPB.FIRST_ACCESS],0F4h ; clear bit 0,1 and 3
 21706                                  					; bit 0 - FSINFO update (dirty) bit
 21707                                  					; bit 1 - BPB_RootClus update bit
 21708                                  					; bit 3 - BPB_ExtFlags update bit
 21709 000034AB C3                      	retn
 21710                                  
 21711                                  u_fat32_inf_2:
 21712 000034AC 50                      	push	ax
 21713 000034AD 53                      	push	bx
 21714 000034AE 57                      	push	di
 21715 000034AF 56                      	push	si
 21716 000034B0 1E                      	push	ds
 21717 000034B1 36803E[7900]00          	cmp	byte [ss:BuffInHMA],0	; is buffers in HMA?
 21718 000034B7 740A                    	jz	short u_fat32_inf_3	; no
 21719 000034B9 36C53E[7A00]            	lds	di,[ss:LoMemBuff]	; read it into scratch buffer
 21720                                  	;sub	di,24
 21721 000034BE 83EF18                  	sub	di,BUFINSIZ		; space for buffer header
 21722                                  					; (buffer header size = 24)
 21723                                  	;clc
 21724 000034C1 EB0E                    	jmp	short u_fat32_inf_4
 21725                                  
 21726                                  u_fat32_inf_3:
 21727 000034C3 06                      	push	es
 21728 000034C4 55                      	push	bp
 21729 000034C5 E8F12D                  	call	GETCURHEAD		; ds:di = first buffer in queue
 21730 000034C8 52                      	push	dx
 21731 000034C9 E8CB2F                  	call	BUFWRITE		; BufWrite writes a buffer to the disk,
 21732                                  					;  if it's dirty.
 21733 000034CC 5A                      	pop	dx
 21734 000034CD 5D                      	pop	bp
 21735 000034CE 07                      	pop	es
 21736                                  ;u_fat32_inf_4:
 21737 000034CF 726A                    	jc	short u_fat32_inf_5
 21738                                  u_fat32_inf_4:
 21739 000034D1 31C9                    	xor	cx,cx
 21740                                  	;lea	bx,[di+24]
 21741 000034D3 8D5D18                  	lea	bx,[di+BUFINSIZ]	; buffer data address
 21742                                  	;mov	byte [ss:ALLOWED],18h
 21743 000034D6 36C606[4B03]18          	mov	byte [ss:ALLOWED],Allowed_FAIL+Allowed_RETRY
 21744 000034DC 36890E[0706]            	mov	[ss:HIGH_SECTOR],cx ; 0
 21745 000034E1 41                      	inc	cx			; cx = sector count = 1
 21746                                  					; es:bp = DPB
 21747 000034E2 53                      	push	bx			; ds:bx = buffer (data) address
 21748 000034E3 52                      	push	dx			; HIGH_SECTOR:dx = disk sector address
 21749 000034E4 E89A0A                  	call	DREAD		 	; read fs info sector
 21750 000034E7 5A                      	pop	dx
 21751 000034E8 5B                      	pop	bx
 21752 000034E9 7250                    	jc	short u_fat32_inf_5
 21753                                  
 21754                                  	;cmp	word [bx+FSINFO.LeadSig],5252h	
 21755 000034EB 813F5252                	cmp	word [bx],5252h		; 'RR'
 21756 000034EF 754A                    	jne	short u_fat32_inf_5
 21757                                  	;cmp	word [bx+2],4161h	; 'aA' ; (NASM syntax)
 21758 000034F1 817F026141              	cmp	word [bx+FSINFO.LeadSig+2],4161h
 21759 000034F6 7543                    	jne	short u_fat32_inf_5
 21760                                  	
 21761                                  	;cmp	word [bx+1E4h],7272h	; 'rr' at offset 484
 21762 000034F8 81BFE4017272            	cmp	word [bx+FSINFO.StrucSig],7272h
 21763 000034FE 753B                    	jne	short u_fat32_inf_5
 21764                                  
 21765                                  	;cmp	word [bx+1E6h],6141h	; 'Aa' at offset 486
 21766 00003500 81BFE6014161            	cmp	word [bx+FSINFO.StrucSig+2],6141h
 21767 00003506 7533                    	jne	short u_fat32_inf_5
 21768                                  
 21769                                  	;cmp	word [bx+1FEh],0AA55h	; boot signature at offset 510
 21770 00003508 81BFFE0155AA            	cmp	word [bx+FSINFO.TrailSig+2],0AA55h
 21771 0000350E 752B                    	jne	short u_fat32_inf_5
 21772                                  	
 21773                                  	;mov	ax,[es:bp+1Fh]
 21774 00003510 268B461F                	mov	ax,[es:bp+DPB.FREE_CNT]
 21775                                  	;mov	[bx+1E8h],ax 
 21776 00003514 8987E801                	mov	[bx+FSINFO.Free_Count],ax ; at offset 488
 21777                                  	;mov	ax,[es:bp+21h]
 21778 00003518 268B4621                	mov	ax,[es:bp+DPB.FREE_CNT+2]
 21779                                  	;mov	[bx+1EAh],ax
 21780 0000351C 8987EA01                	mov	[bx+FSINFO.Free_Count+2],ax
 21781                                  
 21782                                  	;mov	ax,[es:bp+39h]
 21783 00003520 268B4639                	mov	ax,[es:bp+DPB.FAT32_NXTFREE]
 21784                                  	;mov	[bx+1ECh],ax
 21785 00003524 8987EC01                	mov	[bx+FSINFO.Nxt_Free],ax	; at offset 492
 21786                                  	;mov	ax,[es:bp+3Bh]
 21787 00003528 268B463B                	mov	ax,[es:bp+DPB.FAT32_NXTFREE+2]
 21788                                  	;mov	[bx+1EEh],ax
 21789 0000352C 8987EE01                	mov	[bx+FSINFO.Nxt_Free+2],ax
 21790                                  
 21791 00003530 31C9                    	xor	cx,cx
 21792 00003532 36890E[0706]            	mov	[ss:HIGH_SECTOR],cx ; 0
 21793 00003537 41                      	inc	cx	; 1
 21794 00003538 E8A60A                  	call	DWRITE
 21795                                  
 21796                                  u_fat32_inf_5:
 21797 0000353B 1F                      	pop	ds
 21798 0000353C 5E                      	pop	si
 21799 0000353D 5F                      	pop	di
 21800 0000353E 5B                      	pop	bx
 21801 0000353F 58                      	pop	ax
 21802 00003540 E961FF                  	jmp	u_fat32_inf_1
 21803                                  
 21804                                  ;============================================================================
 21805                                  ; ISEARCH.ASM, MSDOS 6.0, 1991
 21806                                  ;============================================================================
 21807                                  ; 22/07/2018 - Retro DOS v3.0
 21808                                  
 21809                                  ;	TITLE	DOS_SEARCH - Internal SEARCH calls for MS-DOS
 21810                                  ;	NAME	DOS_SEARCH
 21811                                  
 21812                                  ;**	Low level routines for doing local and NET directory searches
 21813                                  ;
 21814                                  ;	DOS_SEARCH_FIRST
 21815                                  ;	DOS_SEARCH_NEXT
 21816                                  ;	RENAME_NEXT
 21817                                  ;
 21818                                  ;	Revision history:
 21819                                  ;
 21820                                  ;	    Created: ARR 30 March 1983
 21821                                  ;	    A000	version 4.00  Jan. 1988
 21822                                  ;	    A001	PTM 3564 -- search for fastopen
 21823                                  
 21824                                  ;Installed = TRUE
 21825                                  
 21826                                  ;--------------------------------------------------------------------------
 21827                                  ;
 21828                                  ; Procedure Name : DOS_SEARCH_FIRST
 21829                                  ;
 21830                                  ; Inputs:
 21831                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 21832                                  ;		terminated)
 21833                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 21834                                  ;		( = -1 if current dir not involved, else
 21835                                  ;		 Points to first char after last "/" of current dir part)
 21836                                  ;	[THISCDS] Points to CDS being used
 21837                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 21838                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 21839                                  ;	[DMAADD] Points to 53 byte buffer
 21840                                  ; Function:
 21841                                  ;	Initiate a search for the given file spec
 21842                                  ; Outputs:
 21843                                  ;	CARRY CLEAR
 21844                                  ;	    The 53 bytes ot DMAADD are filled in as follows:
 21845                                  ;
 21846                                  ;	LOCAL
 21847                                  ;	    Drive Byte (A=1, B=2, ...) High bit clear
 21848                                  ;		NEVER STORE DRIVE BYTE AFTER  found_it
 21849                                  ;	    11 byte search name with Meta chars in it
 21850                                  ;	    Search Attribute Byte, attribute of search
 21851                                  ;	    WORD LastEnt value
 21852                                  ;	    WORD DirStart
 21853                                  ;	    4 byte pad
 21854                                  ;	    32 bytes of the directory entry found
 21855                                  ;	NET
 21856                                  ;	    21 bytes First byte has high bit set
 21857                                  ;	    32 bytes of the directory entry found
 21858                                  ;
 21859                                  ;	CARRY SET
 21860                                  ;	    AX = error code
 21861                                  ;		error_no_more_files
 21862                                  ;			No match for this file
 21863                                  ;		error_path_not_found
 21864                                  ;			Bad path (not in curr dir part if present)
 21865                                  ;		error_bad_curr_dir
 21866                                  ;			Bad path in current directory part of path
 21867                                  ; DS preserved, others destroyed
 21868                                  ;---------------------------------------------------------------------------
 21869                                  
 21870                                  ; 24/01/2024
 21871                                  %if 1
 21872                                  	; 17/05/2019 - Retro DOS v4.0
 21873                                  GET_FAST_SEARCH:
 21874                                  	; 22/07/2018
 21875                                  	; MSDOS 6.0
 21876                                  	; 17/12/2022
 21877 00003543 36800E[1206]04          	OR	byte [ss:DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)  ; 04h
 21878                                  	;OR	word [ss:DOS34_FLAG],SEARCH_FASTOPEN  ; 400h
 21879                                  					;FO.trigger fastopen ;AN000;
 21880                                  	;call	DOS_SEARCH_FIRST
 21881                                  	;retn
 21882                                  	; 24/01/2024
 21883                                  	; 17/12/2022
 21884                                  	;jmp	DOS_SEARCH_FIRST
 21885                                  %endif
 21886                                  
 21887                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21888                                  	; DOSCODE:6C22h (MSDOS 5.0, MSDOS.SYS)
 21889                                  
 21890                                  	; 03/02/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 21891                                  	; DOSCODE:74E9h (PCDOS 7.1, IBMDOS.COM)
 21892                                  
 21893                                  DOS_SEARCH_FIRST:
 21894                                  	; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 3826h
 21895                                  
 21896 00003549 C43E[A205]              	LES	DI,[THISCDS]
 21897 0000354D 83FFFF                  	CMP	DI,-1
 21898 00003550 7506                    	JNZ	short TEST_RE_NET2
 21899                                  
 21900                                  ;IF NOT Installed
 21901                                  ;	transfer NET_SEQ_SEARCH_FIRST
 21902                                  ;ELSE
 21903                                  	;mov	ax,1119h
 21904 00003552 B81911                  	MOV	AX,(MultNET<<8)|25
 21905 00003555 CD2F                    	INT	2Fh
 21906 00003557 C3                      	retn
 21907                                  ;ENDIF
 21908                                  
 21909                                  TEST_RE_NET2:
 21910                                  	;test	word [es:di+43h],8000h
 21911                                  	; 17/12/2022
 21912                                  	;test	byte [es:di+44h],80h
 21913                                  	; 28/12/2022
 21914 00003558 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8
 21915                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 21916 0000355D 7406                    	JZ	short LOCAL_SEARCH_FIRST
 21917                                  
 21918                                  ;IF NOT Installed
 21919                                  ;	transfer NET_SEARCH_FIRST
 21920                                  ;ELSE
 21921                                  	;mov	ax,111Bh
 21922 0000355F B81B11                  	MOV	AX,(MultNET<<8)|27
 21923 00003562 CD2F                    	INT	2FH
 21924 00003564 C3                      	retn
 21925                                  ;ENDIF
 21926                                  	; 18/05/2019 - Retro DOS v4.0
 21927                                  LOCAL_SEARCH_FIRST:
 21928 00003565 E89BE3                  	call	ECritDisk
 21929                                  	; MSDOS 6.0
 21930                                  	;;test	word [DOS34_FLAG],400h
 21931                                  	; 17/12/2022
 21932                                  	;test	byte [DOS34_FLAG+1],04h
 21933 00003568 F606[1206]04            	test	byte [DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)
 21934                                  	;TEST	word [DOS34_FLAG],SEARCH_FASTOPEN ;AN000;
 21935 0000356D 7405                    	JZ	short NOFN			;AN000;
 21936                                  	;or	byte [FastOpenFlg],1
 21937 0000356F 800E[6D12]01            	OR	byte [FastOpenFlg],FastOpen_Set	;AN000;
 21938                                  NOFN:						;AN000;
 21939 00003574 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 21940                                  
 21941                                  ; 03/02/2024
 21942                                  %if 0
 21943                                  	; MSDOS 6.0
 21944                                  	CALL	CHECK_QUESTION		;AN000;;FO. is '?' in path
 21945                                  	JNC	short norm_GETPATH	;AN000;;FO. no
 21946                                  %else
 21947                                  	; 03/02/2024
 21948 00003579 16                      	push	ss
 21949 0000357A 1F                      	pop	ds			;AN000;;FO. ds:si -> final path
 21950 0000357B 8B36[B205]              	mov	si,[WFP_START]		;AN000;;FO.
 21951                                  getnext:				;AN000;
 21952 0000357F AC                      	lodsb				;AN000;;FO. get char
 21953 00003580 08C0                    	or	al,al			;AN000;;FO. is it null
 21954 00003582 7409                    	jz	short NO_Question	;AN000;;FO. yes
 21955 00003584 3C3F                    	cmp	al,'?'                  ;AN000;;FO. is '?'
 21956 00003586 75F7                    	jne	short getnext 		;AN000;;FO. no
 21957                                  %endif
 21958                                  	;and	byte [FastOpenFlg],80h
 21959 00003588 8026[6D12]80            	AND	byte [FastOpenFlg],Fast_yes ;AN000;;FO. reset fastopen
 21960                                  NO_Question:	; 03/02/2024
 21961                                  norm_GETPATH:
 21962 0000358D E84413                  	call	GETPATH
 21963                                  	; BX = offset NAME1
 21964                                  ;_getdone:
 21965 00003590 7318                    	JNC	short find_check_dev
 21966 00003592 7511                    	JNZ	short bad_path3
 21967 00003594 08C9                    	OR	CL,CL
 21968 00003596 740D                    	JZ	short bad_path3
 21969                                  find_no_more:
 21970                                  	;mov	ax,12h
 21971 00003598 B81200                  	MOV	AX,error_no_more_files
 21972                                  BadBye:
 21973                                  	; MSDOS 6.0
 21974 0000359B 368026[6D12]80          	AND	byte [SS:FastOpenFlg],Fast_yes  ;AN000;;FO. reset fastopen
 21975                                  
 21976 000035A1 F9                      	STC
 21977                                  	;call	LCritDisk
 21978                                  	;retn
 21979                                  	; 18/12/2022
 21980 000035A2 E98BE3                  	jmp	LCritDisk
 21981                                  
 21982                                  bad_path3:
 21983                                  	;mov	ax,3
 21984 000035A5 B80300                  	MOV	AX,error_path_not_found
 21985 000035A8 EBF1                    	JMP	short BadBye
 21986                                  
 21987                                  find_check_dev:
 21988 000035AA 08E4                    	OR	AH,AH
 21989 000035AC 790A                    	JNS	short found_entry
 21990 000035AE C706[4803]FFFF          	MOV	word [LASTENT],-1	; Cause DOS_SEARCH_NEXT to fail
 21991 000035B4 FE06[7005]              	INC	byte [FOUND_DEV]	; Tell DOS_RENAME we found a device
 21992                                  found_entry:
 21993                                  
 21994                                  ; We set the physical drive byte here Instead of after found_it; Doing
 21995                                  ; a search-next may not have wfp_start set correctly
 21996                                  
 21997 000035B8 C43E[2C03]              	LES	DI,[DMAADD]
 21998 000035BC 8B36[B205]              	MOV	SI,[WFP_START]		; get pointer to beginning
 21999 000035C0 AC                      	LODSB
 22000 000035C1 2C40                    	SUB	AL,'A'-1                ; logical drive
 22001 000035C3 AA                      	STOSB				; High bit not set (local)
 22002                                  found_it:
 22003 000035C4 C43E[2C03]              	LES	DI,[DMAADD]
 22004 000035C8 47                      	INC	DI
 22005                                  
 22006                                  	; MSDOS 6.0
 22007 000035C9 1E                      	PUSH	DS				  ;FO.;AN001; save ds
 22008                                  	;test	byte [FastOpenFlg],10h
 22009 000035CA F606[6D12]10            	TEST	byte [FastOpenFlg],Set_For_Search ;FO.;AN001; from fastopen
 22010 000035CF 7408                    	JZ	short notfast			  ;FO.;AN001;
 22011 000035D1 89DE                    	MOV	SI,BX				  ;FO.;AN001;
 22012 000035D3 8E1E[E405]              	MOV	DS,[CURBUF+2]			  ;FO.;AN001;
 22013 000035D7 EB03                    	JMP	SHORT movmov			  ;FO.;AN001;
 22014                                  
 22015                                  notfast:
 22016 000035D9 BE[4B05]                	MOV	SI,NAME1		; find_buf 2 = formatted name
 22017                                  movmov:
 22018                                  ; Special E5 code
 22019 000035DC A4                      	MOVSB
 22020 000035DD 26807DFF05              	CMP	BYTE [ES:DI-1],5
 22021 000035E2 7505                    	JNZ	short NOTKANJB
 22022 000035E4 26C645FFE5              	MOV	BYTE [ES:DI-1],0E5H
 22023                                  NOTKANJB:
 22024                                  	;MOV	CX,10
 22025                                  	;REP	MOVSB
 22026                                  	; 03/02/2024
 22027 000035E9 B90500                  	mov	cx,5
 22028 000035EC F3A5                    	rep	movsw
 22029                                  
 22030                                  	; 08/09/2018
 22031 000035EE 1F                      	POP	DS			;FO.;AN001; restore ds
 22032                                  
 22033 000035EF A0[6B05]                	MOV	AL,[ATTRIB]
 22034 000035F2 AA                      	STOSB
 22035 000035F3 50                      	PUSH	AX			; Save AH device info
 22036 000035F4 A1[4803]                	MOV	AX,[LASTENT]
 22037 000035F7 AB                      	STOSW
 22038 000035F8 A1[C205]                	MOV	AX,[DIRSTART]
 22039 000035FB AB                      	STOSW
 22040                                  
 22041                                  	; 03/02/2024 - Retro DOS v5.0
 22042                                  	; PCDOS 7.1 IBMDOS.COM
 22043                                  	;;;
 22044 000035FC A1[E30A]                	MOV	AX,[DIRSTART_HW]
 22045 000035FF AB                      	STOSW
 22046 00003600 83C702                  	add	di,2
 22047                                  ; 4 bytes of 21 byte cont structure left for NET stuff
 22048                                  	;ADD	DI,4
 22049                                  	;;;
 22050                                  	
 22051 00003603 58                      	POP	AX			; Recover AH device info
 22052 00003604 08E4                    	OR	AH,AH
 22053 00003606 781B                    	JS	short DOSREL		; Device entry is DOSGROUP relative
 22054 00003608 833E[E205]FF            	CMP	WORD [CURBUF],-1
 22055 0000360D 7510                    	JNZ	short OKSTORE
 22056                                  
 22057                                  	; MSDOS 6.0
 22058 0000360F F606[6D12]10            	TEST	byte [FastOpenFlg],Set_For_Search
 22059                                  					;AN000;;FO. from fastopen and is good
 22060 00003614 7509                    	JNZ	short OKSTORE		;AN000;;FO.
 22061                                  
 22062                                  	; The user has specified the root directory itself, rather than some
 22063                                  	; contents of it. We can't "find" that.
 22064                                  
 22065 00003616 26C745F8FFFF            	MOV	WORD [ES:DI-8],-1	; Cause DOS_SEARCH_NEXT to fail by
 22066                                  					;   stuffing a -1 at Lastent
 22067 0000361C E979FF                  	JMP	find_no_more
 22068                                  
 22069                                  OKSTORE:
 22070 0000361F 8E1E[E405]              	MOV	DS,[CURBUF+2]
 22071                                  DOSREL:
 22072                                  	; BX = offset NAME1 (from GETPATH)
 22073 00003623 89DE                    	MOV	SI,BX			; SI-> start of entry
 22074                                  
 22075                                  ; NOTE: DOS_RENAME depends on BX not being altered after this point
 22076                                  
 22077                                  	;;mov	cx,32
 22078                                  	;MOV	CX,dir_entry.size
 22079                                  	; 03/02/2024
 22080 00003625 B91000                  	mov	cx,dir_entry.size>>1
 22081                                  ;;;;; 7/29/86
 22082 00003628 89F8                    	MOV	AX,DI			; save the 1st byte addr
 22083                                  	;REP	MOVSB
 22084 0000362A F3A5                    	rep	movsw
 22085                                  	;
 22086 0000362C 89C7                    	MOV	DI,AX			; restore 1st byte addr
 22087 0000362E 26803D05                	CMP	BYTE [ES:DI],05H	; special char check
 22088 00003632 7504                    	JNZ	short NO05
 22089 00003634 26C605E5                	MOV	BYTE [ES:DI],0E5H	; convert it back to E5
 22090                                  NO05:
 22091                                  
 22092                                  ;;;;; 7/29/86
 22093                                  
 22094                                  ;hkn; FastOpenflg is in DOSDATA use SS
 22095                                  	; 16/12/2022
 22096                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22097                                  	; MSDOS 6.0
 22098                                  	;AND	byte [SS:FastOpenFlg],Fast_yes ;AN000;;FO. reset fastopen
 22099                                  	; 18/05/2019 - Retro DOS v4.0
 22100 00003638 16                      	push	ss
 22101 00003639 1F                      	pop	ds
 22102                                  	; 16/12/2022
 22103 0000363A 8026[6D12]80            	AND	byte [FastOpenFlg],Fast_yes ; 80h
 22104                                  
 22105                                  ;hkn; SS is DOSDATA
 22106                                  	;push	ss
 22107                                  	;pop	ds
 22108 0000363F F8                      	CLC
 22109                                  	;call	LCritDisk
 22110                                  	;retn
 22111                                  	; 16/12/2022
 22112 00003640 E9EDE2                  	jmp	LCritDisk
 22113                                  
 22114                                  ;BREAK <DOS_SEARCH_NEXT - scan for subsequent matches>
 22115                                  ;----------------------------------------------------------------------------
 22116                                  ;
 22117                                  ; Procedure Name : DOS_SEARCH_NEXT
 22118                                  ;
 22119                                  ; Inputs:
 22120                                  ;	[DMAADD] Points to 53 byte buffer returned by DOS_SEARCH_FIRST
 22121                                  ;	    (only first 21 bytes must have valid information)
 22122                                  ; Function:
 22123                                  ;	Look for subsequent matches
 22124                                  ; Outputs:
 22125                                  ;	CARRY CLEAR
 22126                                  ;	    The 53 bytes at DMAADD are updated for next call
 22127                                  ;		(see DOS_SEARCH_FIRST)
 22128                                  ;	CARRY SET
 22129                                  ;	    AX = error code
 22130                                  ;		error_no_more_files
 22131                                  ;			No more files to find
 22132                                  ; DS preserved, others destroyed
 22133                                  ;---------------------------------------------------------------------------
 22134                                  
 22135                                  ;hkn; called from search.asm. DS already set up at this point.
 22136                                  
 22137                                  	; 03/02/2024 - Retro DOS v5.0
 22138                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:75ECh
 22139                                  
 22140                                  DOS_SEARCH_NEXT:
 22141 00003643 C43E[2C03]              	LES	DI,[DMAADD]	; 24/01/2024 (Retro DOS v5-v4)
 22142 00003647 268A05                  	MOV	AL,[ES:DI]
 22143 0000364A A880                    	TEST	AL,80H			; Test for NET
 22144 0000364C 7406                    	JZ	short LOCAL_SEARCH_NEXT
 22145                                  ;IF NOT Installed
 22146                                  ;	transfer NET_SEARCH_NEXT
 22147                                  ;ELSE
 22148                                  	;mov	ax,111Ch
 22149 0000364E B81C11                  	MOV	AX,(MultNET<<8)|28
 22150 00003651 CD2F                    	INT	2FH  ; Multiplex - NETWORK REDIRECTOR - FINDNEXT
 22151                                  		     ; SS = DS = DOS CS, [DTA] = 21-byte findfirst search data
 22152                                  		     ; Return: CF set on error, AX = DOS error code
 22153                                  		     ; CF clear if successful
 22154 00003653 C3                      	retn
 22155                                  ;ENDIF
 22156                                  
 22157                                  LOCAL_SEARCH_NEXT:
 22158                                  	;AL is drive A=1
 22159                                  	;mov	byte [EXTERR_LOCUS],2
 22160 00003654 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 22161 00003659 E8A7E2                  	call	ECritDisk
 22162                                  
 22163                                  ;hkn; DummyCDS is in DOSDATA
 22164 0000365C C706[A205][F304]        	MOV     word [THISCDS],DUMMYCDS
 22165                                  ;hkn; Segment address is DOSDATA - use ds
 22166                                  ;hkn;	MOV     WORD [THISCDS+2],CS
 22167 00003662 8C1E[A405]              	mov	[THISCDS+2],DS
 22168                                  
 22169 00003666 0440                    	ADD	AL,'A'-1
 22170 00003668 E85D3D                  	call	InitCDS
 22171                                  
 22172                                  ;	call	GETTHISDRV		; Set CDS pointer
 22173                                  
 22174 0000366B 7253                    	JC	short No_files		; Bogus drive letter
 22175 0000366D C43E[A205]              	LES	DI,[THISCDS]		; Get CDS pointer
 22176                                  	;les	bp,[es:di+45h]
 22177 00003671 26C46D45                	LES	BP,[ES:DI+curdir.devptr] ; Get DPB pointer
 22178 00003675 E8EFCF                  	call	GOTDPB			; [THISDPB] = ES:BP
 22179                                  
 22180                                  	; 16/12/2022
 22181 00003678 268A4600                	mov	al,[ES:BP]
 22182                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22183                                  	;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[ES:BP+0]
 22184 0000367C A2[7605]                	mov	[THISDRV],AL
 22185                                  	;mov	word [CREATING],0E500h
 22186 0000367F C706[7E05]00E5          	MOV	WORD [CREATING],(DIRFREE*256)+0
 22187 00003685 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 22188 0000368A C536[2C03]              	LDS	SI,[DMAADD]
 22189 0000368E AC                      	LODSB				; Drive Byte
 22190                                  
 22191                                  	;entry	RENAME_NEXT		; Entry used by DOS_RENAME
 22192                                  RENAME_NEXT:
 22193                                  	;context ES
 22194 0000368F 16                      	push	ss
 22195 00003690 07                      	pop	es			; THIS BLOWS ES:BP POINTER TO DPB
 22196                                  
 22197                                  ;hkn; NAME1 is in DOSDATA
 22198 00003691 BF[4B05]                	MOV	DI,NAME1
 22199                                  
 22200 00003694 B90B00                  	MOV	CX,11
 22201 00003697 F3A4                    	REP	MOVSB			; Search name
 22202 00003699 AC                      	LODSB				; Attribute
 22203                                  
 22204                                  ;hkn; SS override
 22205 0000369A 36A2[6B05]              	MOV	[SS:ATTRIB],AL
 22206 0000369E AD                      	LODSW				; LastEnt
 22207 0000369F 09C0                    	OR	AX,AX
 22208                                  	; 03/02/2024
 22209                                  	;JNS	short cont_load
 22210 000036A1 781D                    	js	short No_files
 22211                                  ;No_files:
 22212                                  	;JMP	find_no_more
 22213                                  
 22214                                  cont_load:
 22215 000036A3 50                      	PUSH	AX			; Save LastEnt
 22216 000036A4 AD                      	LODSW				; DirStart
 22217 000036A5 89C3                    	MOV	BX,AX
 22218                                  
 22219                                  	;;;
 22220                                  	; 03/02/2024 - Retro DOS v5.0
 22221                                  	; (PCDOS 7.1 IBMDOS.COM)
 22222 000036A7 AD                      	lodsw				; DIRSTART_HW
 22223                                  	;;;
 22224                                  
 22225                                  ;hkn; SS is DOSDATA
 22226                                  	;context DS
 22227 000036A8 16                      	push	ss
 22228 000036A9 1F                      	pop	ds
 22229 000036AA C42E[8A05]              	LES	BP,[THISDPB]		; Recover ES:BP
 22230                                  
 22231                                  	;;;
 22232                                  	; 03/02/2024 - Retro DOS v5.0
 22233                                  	; (PCDOS 7.1 IBMDOS.COM)
 22234                                  	
 22235                                  	;cmp	word [es:bp+0Fh],0
 22236 000036AE 26837E0F00              	cmp	word [es:bp+DPB.FAT_SIZE],0
 22237 000036B3 7402                    	jz	short cont_load2 ; FAT32 fs
 22238 000036B5 31C0                    	xor	ax,ax ; 0
 22239                                  cont_load2:
 22240 000036B7 A3[F50A]                	mov	[ROOTCLUST_HW],ax	; 0 or DIRSTART_HW
 22241                                  	;;;
 22242                                  
 22243                                  	;invoke	SetDirSrch
 22244 000036BA E80511                  	call	SETDIRSRCH
 22245 000036BD 7304                    	JNC	short SEARCH_GOON
 22246 000036BF 58                      	POP	AX			; Clean stack
 22247                                  	;JMP	short No_files
 22248                                  	; 03/02/2024
 22249                                  No_files:
 22250 000036C0 E9D5FE                  	JMP	find_no_more
 22251                                  
 22252                                  SEARCH_GOON:
 22253 000036C3 E8A114                  	call	STARTSRCH
 22254 000036C6 58                      	POP	AX			; Restore LastEnt
 22255 000036C7 E83910                  	call	GETENT
 22256 000036CA 72F4                    	JC	short No_files
 22257 000036CC E86F0F                  	call	NEXTENT
 22258 000036CF 72EF                    	JC	short No_files
 22259 000036D1 30E4                    	XOR	AH,AH			; If Search_Next, can't be a DEV
 22260 000036D3 E9EEFE                  	JMP	found_it ; 10/08/2018
 22261                                  
 22262                                  ; MSDOS 6.0
 22263                                  ;---------------------------------------------------------------------------
 22264                                  ;
 22265                                  ; Procedure Name : CHECK_QUESTION
 22266                                  ;
 22267                                  ; Input: [WFP_START]= pointer to final path
 22268                                  ; Function: check '?' char
 22269                                  ; Output: carry clear, if no '?'
 22270                                  ;	 carry set, if '?' exists
 22271                                  ;---------------------------------------------------------------------------
 22272                                  
 22273                                  ; 03/02/2024
 22274                                  %if 0
 22275                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22276                                  CHECK_QUESTION:
 22277                                  ;hkn;	wfp_start is in DOSDATA;hkn;	MOV	WORD PTR ThisCDS+2,CS
 22278                                  ;hkn;	PUSH	CS			;AN000;;FO.
 22279                                  	push	ss
 22280                                  	POP	DS			;AN000;;FO. ds:si -> final path
 22281                                  	; 16/12/2022
 22282                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22283                                  	MOV	SI,[WFP_START]		;AN000;;FO.
 22284                                  	;mov	si,[ss:WFP_START]
 22285                                  getnext:				;AN000;
 22286                                  	LODSB				;AN000;;FO. get char
 22287                                  	OR	AL,AL			;AN000;;FO. is it null
 22288                                  	JZ	short NO_Question	;AN000;;FO. yes
 22289                                  	CMP	AL,'?'                  ;AN000;;FO. is '?'
 22290                                  	JNZ	short getnext 		;AN000;;FO. no
 22291                                  	STC				;AN000;;FO.
 22292                                  NO_Question:				;AN000;
 22293                                  	retn				;AN000;;FO.
 22294                                  %endif
 22295                                  
 22296                                  ;============================================================================
 22297                                  ; ABORT.ASM, MSDOS 6.0, 1991
 22298                                  ;============================================================================
 22299                                  ; 23/07/2018 - Retro DOS v3.0
 22300                                  ; 18/05/2019 - Retro DOS v4.0
 22301                                  
 22302                                  ;**
 22303                                  ;
 22304                                  ; Internal Abort call closes all handles and FCBs associated with a process.
 22305                                  ;  If process has NET resources a close all is sent out over the net.
 22306                                  ;
 22307                                  ;   DOS_ABORT
 22308                                  ;
 22309                                  ;   Modification history:
 22310                                  ;
 22311                                  ;       Created: ARR 30 March 1983
 22312                                  ;
 22313                                  ;	M038	SR	10/16/90	Free SFT with the PSP of the process
 22314                                  ;				being terminated only if it is busy.
 22315                                  ;
 22316                                  
 22317                                  ;Break   <DOS_ABORT -- CLOSE all files for process>
 22318                                  ;--------------------------------------------------------------------------
 22319                                  ;
 22320                                  ; Procedure Name : DOS_ABORT
 22321                                  ;
 22322                                  ; Inputs:
 22323                                  ;       [CurrentPDB] set to PID of process aborting
 22324                                  ; Function:
 22325                                  ;       Close all files and free all SFTs for this PID
 22326                                  ; Returns:
 22327                                  ;       None
 22328                                  ; All destroyed except stack
 22329                                  ;---------------------------------------------------------------------------
 22330                                  
 22331                                  	; 03/02/2024 - Retro DOS v5.0
 22332                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:7685h
 22333                                  	; (Win ME IO.SYS - BIOSCODE:74F4h) 
 22334                                  
 22335                                  DOS_ABORT:
 22336 000036D6 368E06[3003]            	MOV     ES,[SS:CurrentPDB]	; SS override
 22337 000036DB 268B0E3200              	MOV     CX,[ES:PDB.JFN_Length]  ; Number of JFNs
 22338                                  reset_free_jfn:
 22339 000036E0 89CB                    	MOV     BX,CX
 22340 000036E2 51                      	PUSH    CX
 22341 000036E3 4B                      	DEC     BX                      ; get jfn (start with last one)
 22342                                  
 22343 000036E4 E8153A                  	CALL	_$CLOSE
 22344 000036E7 59                      	POP     CX
 22345 000036E8 E2F6                    	LOOP    reset_free_jfn          ; and do 'em all
 22346                                  
 22347                                  ; Note: We do need to explicitly close FCBs. Reasons are as follows: If we
 22348                                  ; are running in the no-sharing no-network environment, we are simulating the
 22349                                  ; 2.0 world and thus if the user doesn't close the file, that is his problem
 22350                                  ; BUT... the cache remains in a state with garbage that may be reused by the
 22351                                  ; next process. We scan the set and blast the ref counts of the FCBs we own.
 22352                                  ;
 22353                                  ; If sharing is loaded, then the following call to close process will
 22354                                  ; correctly close all FCBs. We will then need to walk the list AFTER here.
 22355                                  ;
 22356                                  ; Finally, the following call to NET_Abort will cause an EOP to be sent to all
 22357                                  ; known network resources. These resources are then responsible for cleaning
 22358                                  ; up after this process.
 22359                                  ;
 22360                                  ; Sleazy, eh?
 22361                                  
 22362                                  	;context DS			; SS is DOSDATA
 22363 000036EA 16                      	push	ss
 22364 000036EB 1F                      	pop	ds  ; 09/09/2018
 22365                                  
 22366                                  	;CallInstall Net_Abort, MultNET, 29
 22367 000036EC B81D11                  	mov	ax,111Dh
 22368 000036EF CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR 
 22369                                  			;	    - CLOSE ALL REMOTE FILES FOR PROCESS
 22370                                  			; DS???, SS = DOS CS
 22371                                  ;if installed
 22372 000036F1 FF1E[A000]              	call	far [JShare+(4*4)]	; 4 = MFTCloseP
 22373                                  ;else
 22374                                  ;	call 	MFTCloseP
 22375                                  ;endif
 22376                                  
 22377                                  ; Scan the FCB cache for guys that belong to this process and zap their ref
 22378                                  ; counts.
 22379                                  					; SS override
 22380 000036F5 36C43E[4000]            	les     di,[ss:SFTFCB]		; grab the pointer to the table
 22381                                  
 22382                                  	;;;
 22383                                  	; 03/02/2024 - Retro DOS v5.0
 22384                                  	; PCDOS 7.1 IBMDOS.COM
 22385                                  SFTFCB_check:
 22386 000036FA 8CC1                    	mov	cx,es
 22387 000036FC 09F9                    	or	cx,di
 22388 000036FE E31C                    	jcxz	FCBScanDone
 22389 00003700 57                      	push	di
 22390                                  SFTFCB_OK:
 22391                                  	;;;
 22392                                  	;mov	cx,[es:di+4]
 22393 00003701 268B4D04                	mov     cx,[es:di+SFT.SFCount]
 22394 00003705 E315                    	jcxz    FCBScanDone
 22395                                  	;lea	di,[di+6]
 22396 00003707 8D7D06                  	LEA     DI,[DI+SFT.SFTable]	; point at table
 22397 0000370A 36A1[3C03]              	mov     ax,[SS:PROC_ID]		; SS override
 22398                                  FCBTest:
 22399                                  	;cmp	[es:di+31h],ax
 22400 0000370E 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax ; is this one of ours
 22401 00003712 7503                    	jnz	short FCBNext		; no, skip it
 22402                                  
 22403                                  ; 03/02/2024 - Retro DOS v5.0
 22404                                  %if 0
 22405                                  	mov	word [es:di],0
 22406                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0 ; yes, blast ref count
 22407                                  %else
 22408                                  	; 03/02/2024
 22409                                  	; PCDOS 7.1 IBMDOS.COM
 22410 00003714 E8BC11                  	call    SFT_FREE
 22411                                  %endif
 22412                                  
 22413                                  FCBNext:
 22414 00003717 83C73B                  	add     di,SF_ENTRY.size ; 59 (for MSDOS 6.0)
 22415 0000371A E2F2                    	loop    FCBTest
 22416                                  FCBScanDone:
 22417                                  
 22418                                  ; Walk the SFT to eliminate all busy SFT's for this process.
 22419                                  
 22420 0000371C 31DB                    	XOR     BX,BX
 22421                                  Scan:
 22422 0000371E 53                      	push    bx
 22423 0000371F E85539                  	call	SFFromSFN
 22424 00003722 5B                      	pop     bx
 22425                                  	;jnc	short Scan1
 22426                                  	;retn
 22427                                  
 22428                                  	; 18/12/2022
 22429                                  	;jc	short NO_Question ; retn
 22430                                  	; 03/02/2024
 22431 00003723 7232                    	jc	short RET2
 22432                                  
 22433                                  ;M038
 22434                                  ; Do what the comment above says, check for busy state
 22435                                  
 22436                                  Scan1:
 22437                                  	;cmp	word [es:di],0
 22438                                  	;jz	short scan_next  ; MSDOS 3.3
 22439                                  	; MSDOS 6.0
 22440 00003725 26833DFF                	cmp	word [es:di],sf_busy ; -1
 22441                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy
 22442                                  				; Is Sft busy? ;M038
 22443 00003729 7517                    	jnz	short scan_next ; no
 22444                                  ;
 22445                                  ; we have a SFT that is busy. See if it is for the current process
 22446                                  ;
 22447 0000372B 36A1[3C03]              	mov     ax,[SS:PROC_ID]		; SS override
 22448                                  	;cmp	[es:di+31h],ax
 22449 0000372F 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax
 22450 00003733 750D                    	jnz	short scan_next
 22451 00003735 36A1[3E03]              	mov     ax,[SS:USER_ID]		; SS override
 22452                                  	;sub	ax,[es:di+2Fh] ; PCDOS 7.1 IBMDOS.COM ; 03/02/2024
 22453                                  	;cmp	[es:di+2Fh],ax
 22454 00003739 2639452F                	cmp	[es:di+SF_ENTRY.sf_UID],ax
 22455 0000373D 7503                    	jnz	short scan_next
 22456                                  
 22457                                  ; This SFT is labelled as ours.
 22458                                  
 22459                                  ; 03/02/2024 - Retro DOS v5.0
 22460                                  %if 0
 22461                                  	mov	word [es:di],0
 22462                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0
 22463                                  %else
 22464                                  	; 03/02/2024
 22465                                  	; PCDOS 7.1 IBMDOS.COM
 22466 0000373F E89111                  	call    SFT_FREE
 22467                                  %endif
 22468                                  
 22469                                  scan_next:
 22470 00003742 43                      	inc     bx
 22471 00003743 EBD9                    	jmp     short Scan
 22472                                  
 22473                                  ;============================================================================
 22474                                  ; CLOSE.ASM, MSDOS 6.0, 1991
 22475                                  ;============================================================================
 22476                                  ; 23/07/2018 - Retro DOS v3.0
 22477                                  ; 18/05/2019 - Retro DOS v4.0
 22478                                  
 22479                                  ;**	Internal Close and Commit calls to close a local or NET SFT.
 22480                                  ;
 22481                                  ;	DOS_CLOSE
 22482                                  ;	DOS_COMMIT
 22483                                  ;	FREE_SFT
 22484                                  ;	SetSFTTimes
 22485                                  ;
 22486                                  ;	Revision history:
 22487                                  ;
 22488                                  ;	   AN000  version 4.00	Jan. 1988
 22489                                  ;	   A005   PTM 3718 --- lost clusters when fastopen installed
 22490                                  ;	   A011   PTM 4766 --- C2 fastopen problem
 22491                                  
 22492                                  ;Installed = TRUE
 22493                                  
 22494                                  ;Break <DOS_CLOSE -- CLOSE FILE from SFT>
 22495                                  ;---------------------------------------------------------------------------
 22496                                  ;
 22497                                  ; Procedure Name : DOS_CLOSE
 22498                                  ;
 22499                                  ; Inputs:
 22500                                  ;	[THISSFT] set to the SFT for the file being used
 22501                                  ; Function:
 22502                                  ;	Close the indicated file via the SFT
 22503                                  ; Returns:
 22504                                  ;	sf_ref_count decremented otherwise
 22505                                  ;	ES:DI point to SFT
 22506                                  ;	Carry set if error
 22507                                  ;	    AX has error code
 22508                                  ; DS preserved, others destroyed
 22509                                  ;---------------------------------------------------------------------------
 22510                                  
 22511                                  ;hkn; DOS_CLOSE called from fcbio.asm and handle.asm. DS alreday set up.
 22512                                  
 22513                                  ; 18/05/2019 - Retro DOS v4.0
 22514                                  ; DOSCODE:6E2Eh (MSDOS 6.21, MSDOS.SYS)
 22515                                  
 22516                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22517                                  ; DOSCODE:6E1Ah (MSDOS 5.0, MSDOS.SYS)
 22518                                  
 22519                                  ; 23/07/2018 - IBMDOS.COM (MSDOS 3.3), 1987 - Offset 39D0h
 22520                                  
 22521                                  	; 03/02/2024 - Retro DOS v5.0
 22522                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:76FEh
 22523                                  	; (Win ME IO.SYS - BIOSCODE:7579h) 
 22524                                  
 22525                                  DOS_CLOSE:
 22526 00003745 C43E[9E05]              	LES	DI,[THISSFT]
 22527                                  	;mov	bx,[ES:DI+5]
 22528 00003749 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 22529                                  
 22530                                  ; Network closes are handled entirely by the net code.
 22531                                  
 22532                                  	;;test	bx,8000h
 22533                                  	;TEST	BX,sf_isnet
 22534                                  	; 17/12/2022
 22535                                  	;test	bh,80h
 22536 0000374D F6C780                  	test	bh,(sf_isnet>>8)
 22537 00003750 7406                    	JZ	short LocalClose
 22538                                  
 22539                                  	;CallInstall Net_Close,MultNET,6
 22540 00003752 B80611                  	mov     ax,1106h
 22541 00003755 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE FILE
 22542                                  			; ES:DI -> SFT
 22543                                  			; SFT DPB field -> DPB of drive containing file
 22544                                  			; Return: CF set on error, AX = DOS error code
 22545                                  			; CF clear if successful
 22546                                  RET2:		; 03/02/2024
 22547 00003757 C3                      	retn
 22548                                  
 22549                                  ; All closes release the sharing information.
 22550                                  ; No commit releases sharing information
 22551                                  ;
 22552                                  ; All closes decrement the ref count.
 22553                                  ; No commit decrements the ref count.
 22554                                  
 22555                                  LocalClose:
 22556 00003758 E8A8E1                  	call	ECritDisk
 22557 0000375B E8C901                  	CALL	SetSFTTimes
 22558 0000375E E84C01                  	CALL	FREE_SFT		; dec ref count or mark as busy
 22559                                  
 22560                                  ;hkn; SS is DOSDATA
 22561                                  	;Context DS
 22562 00003761 16                      	push	ss
 22563 00003762 1F                      	pop	ds
 22564                                  
 22565 00003763 50                      	push	ax
 22566 00003764 53                      	push	bx
 22567 00003765 E8F645                  	call	ShareEnd
 22568 00003768 5B                      	pop	bx
 22569 00003769 58                      	pop	ax
 22570                                  
 22571                                  ; Commit enters here. AX from commit MUST be <> 1, BX is flags word
 22572                                  
 22573                                  CloseEntry:
 22574 0000376A 50                      	PUSH	AX
 22575                                  
 22576                                  ; File clean or device does not get stamped nor disk looked at.
 22577                                  
 22578                                  	;test	bx,0C0h
 22579                                  	; 17/12/2022
 22580 0000376B F6C3C0                  	test	bl,devid_file_clean+devid_device
 22581                                  	;TEST	BX,devid_file_clean+devid_device
 22582 0000376E 7403                    	JZ	short rdir
 22583                                  	; 14/11/2022
 22584 00003770 E90101                  	JMP	FREE_SFT_OK		; either clean or device
 22585                                  	;jnz	short FREE_SFT_OK ; 24/07/2019	
 22586                                  
 22587                                  ; Retrieve the directory entry for the file
 22588                                  
 22589                                  rdir:
 22590 00003773 E84401                  	CALL	DirFromSFT
 22591                                  	;mov	al,5
 22592 00003776 B005                    	MOV	AL,error_access_denied
 22593                                  	
 22594                                  	; 03/02/2024
 22595                                  	;JNC	short clook
 22596                                  	;; 14/11/2022
 22597                                  	;JMP	CloseFinish		; pretend the close worked.
 22598                                  	;;jc	short CloseFinish ; 24/07/2019
 22599                                  	
 22600                                  	;;;
 22601                                  	; 03/02/2024 - Retro DOS v5.0
 22602                                  	; (PCDOS 7.1 IBMDOS.COM)
 22603 00003778 7240                    	jc	short jmp_to_CloseFinish ; pretend the close worked.
 22604                                  rdir2:
 22605                                  	;test	word [si+2],4
 22606 0000377A F6440204                	test	byte [si+SF_ENTRY.sf_mode],4 ; devid_device_null
 22607                                  					; bit 2 - null device
 22608 0000377E 751F                    	jnz	short clook
 22609                                  
 22610 00003780 1E                      	push	ds
 22611 00003781 53                      	push	bx
 22612 00003782 C55C07                  	lds	bx,[si+7]
 22613 00003785 C55C07                  	lds	bx,[si+SF_ENTRY.sf_devptr] ; pointer to DPB
 22614                                  
 22615 00003788 8A1F                    	mov	bl,[bx]			; DPB.DRIVE
 22616 0000378A 30FF                    	xor	bh,bh  ; 0
 22617 0000378C 36F687[2F14]04          	test	byte [ss:bx+drive_flags],4
 22618                                  					; bit 2 - last access date/time flag?
 22619                                  					; or disk accessed flag !?
 22620 00003792 5B                       	pop	bx
 22621 00003793 7409                    	jz	short skip_upd_laccdt	; no support for last access date&time
 22622 00003795 1F                      	pop	ds
 22623 00003796 1E                      	push	ds
 22624 00003797 E8D2D3                  	call	DATE16
 22625                                  	;mov	[es:di+12h],ax
 22626 0000379A 26894512                	mov	[es:di+dir_entry.dir_lstaccdate],ax
 22627                                  skip_upd_laccdt:
 22628 0000379E 1F                      	pop	ds
 22629                                  	;;;
 22630                                  
 22631                                  clook:
 22632                                  
 22633                                  ; ES:DI points to entry
 22634                                  ; DS:SI points to SFT
 22635                                  ; ES:BX points to buffer header
 22636                                  
 22637 0000379F 57                      	push	di
 22638 000037A0 56                      	push	si
 22639                                  	;lea	si,[si+20h]
 22640 000037A1 8D7420                  	LEA	SI,[SI+SF_ENTRY.sf_name]
 22641                                  
 22642                                  ; ES:DI point to directory entry
 22643                                  ; DS:SI point to unpacked name
 22644                                  
 22645 000037A4 E84EE0                  	call	XCHGP
 22646                                  
 22647                                  ; ES:DI point to unpacked name
 22648                                  ; DS:SI point to directory entry
 22649                                  
 22650 000037A7 E8F20E                  	call	MetaCompare
 22651 000037AA E848E0                  	call	XCHGP
 22652 000037AD 5E                      	pop	si
 22653 000037AE 5F                      	pop	di
 22654 000037AF 740C                    	JZ	short CLOSE_GO		; Name OK
 22655                                  Bye:	
 22656 000037B1 89F7                    	MOV	DI,SI
 22657 000037B3 1E                      	PUSH	DS
 22658 000037B4 07                      	POP	ES			; ES:DI points to SFT
 22659 000037B5 16                      	PUSH	SS
 22660 000037B6 1F                      	POP	DS
 22661 000037B7 F9                      	STC
 22662                                  	;mov	al,2
 22663 000037B8 B002                    	MOV	AL,error_file_not_found
 22664                                  	
 22665                                  jmp_to_CloseFinish: ; 03/02/2024
 22666                                  	;JMP	CloseFinish ; 24/07/2019
 22667                                  	; 03/02/2024
 22668                                  	; (PCDOS 7.1 IBMDOS.COM)
 22669 000037BA E9DF00                  	jmp	CloseFinish2
 22670                                  
 22671                                  	; 18/05/2019 - Retro DOS v4.0
 22672                                  CLOSE_GO:
 22673                                  	; 03/02/2024
 22674                                  	;mov	al,[si+4]
 22675 000037BD 8A4404                  	mov	al,[si+SF_ENTRY.sf_attr]
 22676                                  	
 22677                                  	; MSDOS 6.0
 22678                                  	;test	word [si+2],8000h
 22679                                  	;TEST	word [SI+SF_ENTRY.sf_mode],sf_isFCB ; FCB ?
 22680                                  	; 17/12/2022
 22681                                  	;test	byte [si+3],80h
 22682 000037C0 F6440380                	test	byte [SI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8) ; FCB ?
 22683 000037C4 740A                    	JZ	short nofcb		; no, set dir attr, sf_attr
 22684                                  	; MSDOS 3.3 & MSDOS 6.0
 22685                                  	;mov	ch,[es:di+0Bh]
 22686 000037C6 268A6D0B                	MOV	CH,[ES:DI+dir_entry.dir_attr]
 22687                                  
 22688                                  	; 03/02/2024
 22689                                  	;;mov	al,[si+4]
 22690                                  	;MOV	AL,[SI+SF_ENTRY.sf_attr]
 22691                                  
 22692                                  ;hkn; SS override
 22693 000037CA 36A2[6B05]              	MOV	[SS:ATTRIB],AL
 22694                                  	; MSDOS 3.3
 22695                                  	;;call	MatchAttributes
 22696                                  	;;JNZ	short Bye		; attributes do not match
 22697                                  	; 18/05/2019
 22698 000037CE EB04                    	JMP	SHORT setattr		;FT.
 22699                                  nofcb:
 22700                                  	; 03/02/2024
 22701                                  	; MSDOS 6.0
 22702                                  	;;mov	al,[si+4]
 22703                                  	;MOV	AL,[SI+SF_ENTRY.sf_attr] ;FT.		;AN000;
 22704                                  
 22705 000037D0 2688450B                	MOV	[ES:DI+dir_entry.dir_attr],AL ;FT.	;AN000;
 22706                                  setattr:
 22707                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22708                                  	;or	byte [es:di+0Bh],20h
 22709 000037D4 26804D0B20              	OR	BYTE [ES:DI+dir_entry.dir_attr],attr_archive ;Set archive
 22710                                  	; MSDOS 6.0
 22711                                  	;mov	ax,[es:di+1Ah]
 22712 000037D9 268B451A                	MOV	AX,[ES:DI+dir_entry.dir_first] ;AN011
 22713                                  					;F.O. save old first cluster
 22714                                  ;hkn; SS override
 22715 000037DD 36A3[0310]              	MOV	[SS:OLD_FIRSTCLUS],AX	;AN011;F.O. save old first cluster
 22716                                  
 22717                                  	;;;
 22718                                  	; 03/02/2024
 22719                                  	; PCDOS 7.1 IBMDOS.COM
 22720                                  	;mov	ax,[es:di+14h]
 22721 000037E1 268B4514                	mov	ax,[ES:DI+dir_entry.dir_fclus_hi] ; old first cluster, hw
 22722 000037E5 36A3[0310]              	MOV	[ss:OLD_FIRSTCLUS],ax
 22723                                  	;;;
 22724                                  
 22725                                  	;;mov	ax,[si+0Bh]
 22726                                  	;MOV	AX,[SI+SF_ENTRY.sf_firclus]
 22727                                  	;;;
 22728                                  	; 03/02/2024
 22729                                  	; PCDOS 7.1 IBMDOS.COM
 22730 000037E9 8B442B                  	mov     ax,[si+2Bh]	; mov ax,[si+SF_ENTRY.sf_chain]
 22731                                  				; first cluster (32 bit) low word !
 22732                                  	;;;	
 22733                                  	;mov	[es:di+1Ah],ax
 22734 000037EC 2689451A                	MOV	[ES:DI+dir_entry.dir_first],AX	;Set firclus pointer
 22735                                  	;;; 03/02/2024
 22736 000037F0 8B442D                  	mov     ax,[si+2Dh]	; mov ax,[si+SF_ENTRY.sf_chain+2]
 22737                                  				; first cluster (32 bit) high word
 22738                                  	;mov	[es:di+14h],ax
 22739 000037F3 26894514                	mov	[es:di+dir_entry.dir_fclus_hi],ax
 22740                                  	;;;
 22741                                  
 22742                                  ; 03/02/2024
 22743                                  %if 0
 22744                                  	;mov	ax,[si+11h]
 22745                                  	MOV	AX,[SI+SF_ENTRY.sf_size]
 22746                                  	;mov	[es:di+1Ch],ax
 22747                                  	MOV	[ES:DI+dir_entry.dir_size_l],AX	;Set size
 22748                                  	;mov	ax,[si+13h]
 22749                                  	MOV	AX,[SI+SF_ENTRY.sf_size+2]
 22750                                  	;mov	[es:di+1Eh],ax
 22751                                  	MOV	[ES:DI+dir_entry.dir_size_h],AX
 22752                                  	;mov	ax,[si+0Fh]
 22753                                  	MOV	AX,[SI+SF_ENTRY.sf_date]
 22754                                  	;mov	[es:di+18h],ax
 22755                                  	MOV	[ES:DI+dir_entry.dir_date],AX	;Set date
 22756                                  	;mov	ax,[si+0Dh]
 22757                                  	MOV	AX,[SI+SF_ENTRY.sf_time]
 22758                                  	;mov	[es:di+16h],ax
 22759                                  	MOV	[ES:DI+dir_entry.dir_time],AX	;Set time
 22760                                  %else
 22761                                  	; 03/02/2024 - Retro DOS v5.0
 22762 000037F7 56                      	push	si
 22763 000037F8 83C60D                  	add	si,0Dh
 22764 000037FB AD                      	lodsw	; [si+SF_ENTRY.sf_time]
 22765 000037FC 26894516                	mov	[es:di+dir_entry.dir_time],ax	; Set time
 22766 00003800 AD                      	lodsw	; [si+SF_ENTRY.sf_date]
 22767 00003801 26894518                	mov	[es:di+dir_entry.dir_date],ax	; Set date
 22768 00003805 AD                      	lodsw	; [si+SF_ENTRY.sf_size]
 22769 00003806 2689451C                	mov	[es:di+dir_entry.dir_size_l],ax	; Set size
 22770 0000380A AD                      	lodsw	; [si+SF_ENTRY.sf_size+2]
 22771 0000380B 2689451E                	mov	[es:di+dir_entry.dir_size_h],ax
 22772 0000380F 5E                      	pop	si
 22773                                  %endif
 22774                                  
 22775                                  	; MSDOS 6.0
 22776                                  ;; File Tagging
 22777 00003810 26F6470540              	TEST	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty
 22778                                  				  ;LB. if already dirty		    ;AN000;
 22779 00003815 7508                    	JNZ	short yesdirty4	  ;LB.  don't increment dirty count ;AN000;
 22780                                  	; 02/06/2019
 22781 00003817 E8262D                  	call	INC_DIRTY_COUNT   ;LB.				    ;AN000;
 22782                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22783                                  	;or	byte [es:bx+5],40h
 22784 0000381A 26804F0540              	OR	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty
 22785                                  yesdirty4:
 22786 0000381F 1E                      	push	ds
 22787 00003820 56                      	push	si
 22788                                  
 22789                                  ; 03/02/2024
 22790                                  %if 0
 22791                                  	; MSDOS 6.0
 22792                                  	;mov	cx,[si+0Bh]
 22793                                  	; 07/12/2022
 22794                                  	MOV	CX,[SI+SF_ENTRY.sf_firclus] ; do this for Fastopen
 22795                                  %else
 22796                                  	; 03/02/2024
 22797                                  	; PCDOS 7.1
 22798 00003821 8B4C2B                  	mov	cx,[si+2Bh]		; [es:di+SF_ENTRY.sf_chain]
 22799                                  					; first cluster (32 bit) low word !?
 22800                                  %endif
 22801                                  
 22802                                  ;hkn; SS override
 22803 00003824 36A0[7605]              	MOV	AL,[SS:THISDRV]
 22804                                  	; MSDOS 3.3 
 22805                                  	;push	ss
 22806                                  	;pop	ds
 22807                                  	;MOV	AL,[THISDRV]
 22808                                  ;;; 10/1/86  update fastopen cache
 22809                                  	; MSDOS 3.3 & MSDOS 6.0
 22810 00003828 52                      	PUSH	DX
 22811 00003829 B400                    	MOV	AH,0			; dir entry update
 22812 0000382B 88C2                    	MOV	DL,AL			; drive number A=0, B=1,,,
 22813                                  	;;;
 22814                                  	; 03/02/2024 - Retro DOS v5.0
 22815                                  	; PCDOS 7.1
 22816 0000382D 53                      	push	bx ; *
 22817 0000382E 8B5C2D                  	mov	bx,[si+2Dh]		; [es:di+SF_ENTRY.sf_chain+2]
 22818                                  					; first cluster (32 bit) high word !?
 22819 00003831 09DB                    	or	bx,bx
 22820 00003833 7511                    	jnz	short do_update2
 22821                                  	;;;
 22822                                  	; MSDOS 6.0
 22823 00003835 09C9                    	OR	CX,CX			;AN005; first cluster 0; may be truncated
 22824 00003837 750D                    	JNZ	short do_update2	;AN005; no, do update
 22825 00003839 B403                    	MOV	AH,3			;AN005; do a delete cache entry
 22826                                  	;mov	di,[si+1Bh]
 22827 0000383B 8B7C1B                  	MOV	DI,[SI+SF_ENTRY.sf_dirsec] ;AN005; cx:di = dir sector
 22828                                  	;mov	cx,[si+1Dh]
 22829 0000383E 8B4C1D                  	MOV	CX,[SI+SF_ENTRY.sf_dirsec+2] ;AN005;
 22830                                  	;mov	dh,[si+1Fh]
 22831 00003841 8A741F                  	MOV	DH,[SI+SF_ENTRY.sf_dirpos] ;AN005; dh = dir pos
 22832 00003844 EB1A                    	JMP	SHORT do_update 	;AN011;F.O.
 22833                                  
 22834                                  do_update2:				;AN011;F.O.
 22835                                  	;;;
 22836                                  	; 03/02/2024
 22837                                  	; PCDOS 7.1
 22838 00003846 363B1E[6112]            	cmp	bx,[ss:OLD_FIRSTCLUS_HW] ; same as old first cluster?
 22839 0000384B 7507                    	jnz	short do_update3 ; no
 22840                                  	;;;
 22841                                  
 22842                                  ;hkn; SS override fort OLD_FIRSTCLUS
 22843                                  	; 
 22844 0000384D 363B0E[0310]            	CMP	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O. same as old first cluster?
 22845 00003852 740C                    	JZ	short do_update		;AN011;F.O. yes
 22846                                  do_update3:	; 03/02/2024
 22847 00003854 B402                    	MOV	AH,2			;AN011;F.O. delete the old entry
 22848 00003856 368B0E[0310]            	MOV	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O.
 22849                                  	;;;
 22850                                  	; 03/02/2024
 22851                                  	; PCDOS 7.1
 22852 0000385B 368B1E[6112]            	mov	bx,[ss:OLD_FIRSTCLUS_HW]
 22853                                  	;;; 
 22854                                  do_update:				;AN005;
 22855                                  ;hkn; SS is DOSDATA
 22856                                  	;Context DS
 22857 00003860 16                      	push	ss
 22858 00003861 1F                      	pop	ds
 22859                                  	;;;
 22860                                  	; 03/02/2024 - Retro DOS v5.0
 22861 00003862 87DE                    	xchg	bx,si	; PCDOS 7.1 IBMDOS.COM
 22862                                  	;;;
 22863                                  	; MSDOS 3.3 & MSDOS 6.0
 22864 00003864 E825F5                  	call	FastOpen_Update 	; invoke fastopen
 22865                                  	;;;
 22866                                  	; 03/02/2024
 22867 00003867 87DE                    	xchg	bx,si	; PCDOS 7.1 IBMDOS.COM
 22868 00003869 5B                      	pop	bx ; *
 22869                                  	;;;
 22870 0000386A 5A                      	POP	DX
 22871                                  
 22872                                  ;;; 10/1/86  update fastopen cache
 22873 0000386B E8C12B                  	call	FLUSHBUF		; flush all relevant buffers
 22874 0000386E 5F                      	pop	di
 22875 0000386F 07                      	pop	es
 22876                                  	;mov	al,5
 22877 00003870 B005                    	MOV	AL,error_access_denied
 22878 00003872 7215                    	JC	short CloseFinish
 22879                                  FREE_SFT_OK:
 22880                                  	; 03/02/2024
 22881                                  	;CLC				; signal no error.
 22882                                  	
 22883                                  	;;;
 22884                                  	; 03/02/2024 - Retro DOS v5.0
 22885                                  	; PCDOS 7.1 IBMDOS.COM
 22886                                  	;test	word [es:di+5],8080h
 22887 00003874 26F745058080            	test	word [es:di+SF_ENTRY.sf_flags],sf_isnet+devid_device
 22888 0000387A 7520                    	jnz	short CloseFinish2
 22889 0000387C 06                      	push	es
 22890 0000387D 55                      	push	bp
 22891                                  	;les	bp,[es:di+7]
 22892 0000387E 26C46D07                	les	bp,[es:di+SF_ENTRY.sf_devptr] ; DPB
 22893 00003882 E80CFC                  	call	update_fat32_fsinfo
 22894 00003885 5D                      	pop	bp
 22895 00003886 07                      	pop	es
 22896 00003887 EB13                    	jmp	short CloseFinish2
 22897                                  	
 22898                                  CloseFinish:	; 03/02/2024 - Retro DOS v5.0
 22899 00003889 1E                      	push    ds
 22900 0000388A 53                      	push    bx
 22901 0000388B 26C55D07                	lds     bx,[es:di+7]		; [es:di+SF_ENTRY.sf_devptr] ; DPB
 22902 0000388F 8A1F                    	mov     bl,[bx]			; DPB.DRIVE
 22903 00003891 30FF                    	xor     bh,bh ; 0
 22904 00003893 3680A7[2F14]FB          	and     byte [ss:bx+drive_flags],0FBh ; clear bit 2
 22905                                  					; bit 2 - last access date/time flag?
 22906                                  					; or disk accessed (successful) flag !?
 22907 00003899 5B                      	pop     bx
 22908 0000389A 1F                      	pop     ds
 22909 0000389B F9                      	stc
 22910                                  	;;;
 22911                                  
 22912                                  CloseFinish2:	 ; 03/02/2024 - Retro DOS v5.0
 22913                                  ;Closefinish:
 22914                                  
 22915                                  ; Indicate to the device that the SFT is being closed.
 22916                                  
 22917                                  ;;;; 7/21/86
 22918 0000389C 9C                      	PUSHF				; save flag from DirFromSFT
 22919 0000389D E80917                  	call	DEV_CLOSE_SFT
 22920 000038A0 9D                      	POPF
 22921                                  ;;;; 7/21/86
 22922                                  ;
 22923                                  ; See if the ref count indicates that we have busied the SFT. If so, mark the
 22924                                  ; SFT as being free. Note that we do NOT need to be in critSFT as we are ONLY
 22925                                  ; going to be moving from busy to free.
 22926                                  ;
 22927 000038A1 59                      	POP	CX			; get old ref count
 22928 000038A2 9C                      	PUSHF
 22929                                  	; 03/02/2024
 22930                                  	;DEC	CX			; if cx != 1
 22931                                  	;JNZ	short NoFree		; then do NOT free SFT
 22932 000038A3 E203                    	loop	NoFree ; PCDOS 7.1 IBMDOS.COM
 22933                                  
 22934                                  ; 03/02/2024 - Retro DOS v5.0
 22935                                  %if 0
 22936                                  	mov	[es:di],cx
 22937                                  	;MOV	[ES:DI+SF_ENTRY.sf_ref_Count],CX ; mov [es:di+0],cx
 22938                                  %else
 22939                                  	; 03/02/2024
 22940                                  	; PCDOS 7.1 IBMDOS.COM
 22941 000038A5 E82B10                  	call    SFT_FREE
 22942                                  %endif
 22943                                  
 22944                                  NoFree:
 22945 000038A8 E885E0                  	call	LCritDisk
 22946 000038AB 9D                      	POPF
 22947 000038AC C3                      	retn
 22948                                  
 22949                                  ;---------------------------------------------------------------------------
 22950                                  ;
 22951                                  ; Procedure Name : FREE_SFT
 22952                                  ;
 22953                                  ; ES:DI -> SFT. Decs sft_ref_count. If the count goes to 0, mark it as busy.
 22954                                  ; Flags preserved. Return old ref count in AX
 22955                                  ;
 22956                                  ; Note that busy is indicated by the SFT ref count being -1.
 22957                                  ;
 22958                                  ;---------------------------------------------------------------------------
 22959                                  
 22960                                  FREE_SFT:
 22961 000038AD 9C                      	PUSHF		; Save carry state
 22962 000038AE 268B05                  	mov	ax,[es:di]
 22963                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 22964 000038B1 48                      	DEC	AX
 22965 000038B2 7501                    	JNZ	short SetCount
 22966 000038B4 48                      	DEC	AX
 22967                                  SetCount:
 22968 000038B5 268705                  	xchg	ax,[es:di]
 22969                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 22970 000038B8 9D                      	POPF
 22971 000038B9 C3                      	retn
 22972                                  
 22973                                  	; 18/05/2019 - Retro DOS v4.0
 22974                                  
 22975                                  ;----------------------------------------------------------------------------
 22976                                  ;
 22977                                  ; Procedure Name : DirFromSFT
 22978                                  ;
 22979                                  ;   DirFromSFT - locate a directory entry given an SFT.
 22980                                  ;
 22981                                  ;   Inputs:	ES:DI point to SFT
 22982                                  ;		DS = DOSDATA
 22983                                  ;   Outputs:
 22984                                  ;		EXTERR_LOCUS = errLOC_Disk
 22985                                  ;		CurBuf points to buffer
 22986                                  ;		Carry Clear -> operation OK
 22987                                  ;		    ES:DI point to entry
 22988                                  ;		    ES:BX point to buffer
 22989                                  ;		    DS:SI point to SFT
 22990                                  ;		Carry SET   -> operation failed
 22991                                  ;		    registers trashified
 22992                                  ;   Registers modified: ALL
 22993                                  ;----------------------------------------------------------------------------
 22994                                  
 22995                                  	; 04/02/2024 - Retro DOS v5.0
 22996                                  	; PCDOS 7.1 IBMDOS.COM
 22997                                  
 22998                                  DirFromSFT:
 22999                                  	;;mov	byte [EXTERR_LOCUS],2
 23000                                  	;MOV	byte [EXTERR_LOCUS],errLOC_Disk
 23001                                  	; 04/02/2024
 23002 000038BA E841DA                  	call	set_exerr_locus_disk
 23003                                  	;
 23004 000038BD 06                      	push	es
 23005 000038BE 57                      	push	di
 23006                                  	; MSDOS 3.3
 23007                                  	;;mov	dx,[es:di+1Dh]
 23008                                  	;MOV	dx,[ES:DI+SF_ENTRY.sf_dirsec]
 23009                                  	; MSDOS 6.0
 23010                                  	;mov	dx,[es:[di+1Dh]
 23011 000038BF 268B551D                	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec+2]  ;F.C. >32mb
 23012 000038C3 8916[0706]              	MOV	[HIGH_SECTOR],DX		 ;F.C. >32mb
 23013                                  	; 04/02/2024
 23014 000038C7 52                      	push	dx
 23015                                  	;mov	dx,[es:di+1Bh]
 23016 000038C8 268B551B                	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec]
 23017                                  	; 04/02/2024
 23018                                  	; 19/05/2019
 23019                                  	;PUSH	word [HIGH_SECTOR]	;F.C. >32mb
 23020                                  	; MSDOS 3.3 & MSDOS 6.0
 23021 000038CC 52                      	PUSH	DX
 23022 000038CD E8A827                  	call	FATREAD_SFT		; ES:BP points to DPB, [THISDRV] set
 23023                                  					; [THISDPB] set
 23024 000038D0 5A                      	POP	DX
 23025 000038D1 8F06[0706]              	POP	word [HIGH_SECTOR]	;F.C. >32mb
 23026 000038D5 721E                    	JC	short PopDone
 23027                                  	; 22/09/2023
 23028                                  	;XOR	AL,AL	; *		; Pre read
 23029                                  	;;mov	byte [ALLOWED],18h
 23030                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 23031                                  	;call	GETBUFFR
 23032                                  	; 22/09/2023
 23033 000038D7 E8512A                  	call	GETBUFFER ; * 		; Pre read
 23034 000038DA 7219                    	JC	short PopDone
 23035 000038DC 5E                      	pop	si
 23036 000038DD 1F                      	pop	ds			; Get back SFT pointer
 23037                                  
 23038                                  ;hkn; SS override
 23039 000038DE 36C43E[E205]            	LES	DI,[SS:CURBUF]
 23040                                  	;or	byte [es:di+5],4
 23041 000038E3 26804D0504              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 23042 000038E8 89FB                    	MOV	BX,DI			; ES:BX point to buffer header
 23043                                  	;;;lea	di,[di+16] ; MSDOS 3.3
 23044                                  	;;lea	di,[di+20] ; MSDOS 6.0
 23045                                  	; 04/02/2024
 23046                                  	;lea	di,[di+24] ; MSDOS 7.1
 23047 000038EA 8D7D18                  	LEA	DI,[DI+BUFINSIZ] 	; Point to buffer
 23048                                  	;mov	al,32
 23049 000038ED B020                    	MOV	AL,dir_entry.size
 23050                                  	;mul	byte [si+1Fh] ; MSDOS 6.0
 23051 000038EF F6641F                  	MUL	byte [SI+SF_ENTRY.sf_dirpos]
 23052 000038F2 01C7                    	ADD	DI,AX			; Point at the entry
 23053 000038F4 C3                      	retn				; carry is clear
 23054                                  PopDone:
 23055 000038F5 5F                      	pop	di
 23056 000038F6 07                      	pop	es
 23057                                  PopDone_retn:
 23058 000038F7 C3                      	retn
 23059                                  
 23060                                  ;----------------------------------------------------------------------------
 23061                                  ;
 23062                                  ;**	DOS_Commit - UPdate Directory Entries
 23063                                  ;
 23064                                  ;	ENTRY	same as DOS_CLOSE (??? BUGBUG - update this jgl)
 23065                                  ;		(DS) = DOSGROUP
 23066                                  ;	EXIT	Same as DOS_CLOSE except ref_count field is not altered
 23067                                  ;	USES	all but DS
 23068                                  ;
 23069                                  ;----------------------------------------------------------------------------
 23070                                  
 23071                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23072                                  ; DOSCODE:6F72h (MSDOS 5.0, MSDOS.SYS)
 23073                                  
 23074                                  ; 04/02/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 23075                                  ; DOSCODE:78B8h (PCDOS 7.1 IBMDOS.COM)
 23076                                  
 23077                                  DOS_COMMIT:
 23078                                  	;hkn; called from srvcall. DS already set up.
 23079 000038F8 C43E[9E05]              	LES	DI,[THISSFT]
 23080                                  	;mov	bx,[es:di+5]
 23081 000038FC 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 23082                                  	;test	bx,0C0h
 23083                                  	; 17/12/2022
 23084 00003900 F6C3C0                  	test	bl,devid_file_clean+devid_device ;Clears carry
 23085                                  	;TEST	BX,devid_file_clean+devid_device ;Clears carry
 23086 00003903 75F2                    	jnz	short PopDone_retn
 23087                                  	;test	bx,8000h
 23088                                  	; 17/12/2022
 23089                                  	;test	bh,80h
 23090 00003905 F6C780                  	test	bh,(sf_isnet>>8) ; 80h
 23091                                  	;TEST	BX,sf_isnet ; 8000h
 23092 00003908 7406                    	JZ	short LOCAL_COMMIT
 23093                                  
 23094                                  ;IF NOT Installed
 23095                                  ;	transfer NET_COMMIT
 23096                                  ;ELSE
 23097                                  	;mov	ax,1107h
 23098 0000390A B80711                  	MOV	AX,(MultNET<<8)|7
 23099 0000390D CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
 23100                                  			; ES:DI -> SFT
 23101                                  			; SFT DPB field -> DPB of drive containing file
 23102                                  			; Return: CF set on error, AX = DOS error code
 23103                                  			; CF clear if successful
 23104                                  localcommit_retn: ; 18/12/2022	
 23105 0000390F C3                      	retn
 23106                                  ;ENDIF
 23107                                  
 23108                                  ; Perform local commit operation by doing a close but not releaseing the SFT.
 23109                                  ; There are three ways we can do this. One is to enter a critical section to
 23110                                  ; protect a potential free. The second is to increment the ref count to mask
 23111                                  ; the close decrementing.
 23112                                  ;
 23113                                  ; The proper way is to let the caller's of close decide if a decrement should
 23114                                  ; be done. We do this by providing another entry into close after the
 23115                                  ; decrement and after the share information release.
 23116                                  
 23117                                  ; DOSCODE:6FA0h (MSDOS 6.21, MSDOS.SYS)
 23118                                  ; DOSCODE:6F8Ch (MSDOS 5.0, MSDOS.SYS) 
 23119                                  
 23120                                  LOCAL_COMMIT:
 23121 00003910 E8F0DF                  	call	ECritDisk
 23122                                  	; MSDOS 6.0
 23123 00003913 E8EDDF                  	call	ECritDisk	;PTM.
 23124 00003916 E80E00                  	call	SetSFTTimes
 23125 00003919 B8FFFF                  	MOV	AX,-1 ; 0FFFFh
 23126 0000391C E84BFE                  	call	CloseEntry
 23127                                  	; MSDOS 6.0
 23128 0000391F 9C                      	PUSHF			;PTM.				;AN000;
 23129 00003920 E87E16                  	call	DEV_OPEN_SFT	;PTM.  increment device count	;AN000;
 23130 00003923 9D                      	POPF			;PTM.				;AN000;
 23131                                  	;call	LCritDisk	;PTM.				;AN000;
 23132                                  	; 18/12/2022
 23133 00003924 E909E0                  	jmp	LCritDisk
 23134                                  ;localcommit_retn:
 23135                                  ;	retn
 23136                                  
 23137                                  ;Break	<SetSFTTimes - signal a change in the times for an SFT>
 23138                                  ;----------------------------------------------------------------------------
 23139                                  ;
 23140                                  ; Procedure Name : SetSFTTimes
 23141                                  ;
 23142                                  ;   SetSFTTimes - Examine the flags for a SFT and set the time appropriately.
 23143                                  ;   Reflect these times in other SFT's for the same file.
 23144                                  ;
 23145                                  ;   Inputs:	ES:DI point to SFT
 23146                                  ;		BX = sf_flags set appropriately
 23147                                  ;   Outputs:	Set sft times to current time if File & dirty & !nodate
 23148                                  ;   Registers modified: All except ES:DI, BX, AX
 23149                                  ;
 23150                                  ;----------------------------------------------------------------------------
 23151                                  
 23152                                  	; 04/02/2024 - Retro DOS v5.0
 23153                                  	; PCDOS 7.1 IBMDOS.COM 
 23154                                  
 23155                                  SetSFTTimes:
 23156                                  
 23157                                  ; 04/02/2024
 23158                                  %if 0
 23159                                  ;	File clean or device does not get stamped nor disk looked at.
 23160                                  	
 23161                                  	;test	bx,0C0h
 23162                                  	; 17/12/2022
 23163                                  	test	bl,devid_file_clean+devid_device
 23164                                  	;TEST	BX,devid_file_clean+devid_device
 23165                                  	;retnz				; clean or device => no timestamp
 23166                                  	jnz	short localcommit_retn
 23167                                  
 23168                                  ;	file and dirty. See if date is good
 23169                                  
 23170                                  	;test	bx,4000h
 23171                                  	; 17/12/2022
 23172                                  	;test	bh,40h
 23173                                  	test	bh,(sf_close_nodate>>8)
 23174                                  	;TEST	BX,sf_close_nodate
 23175                                  	;retnz				; nodate => no timestamp
 23176                                  	jnz	short localcommit_retn
 23177                                  %else
 23178                                  	; 04/02/2024
 23179                                  	; (PCDOS 7.1 IBMDOS.COM)
 23180                                  	;test	bx,40C0h
 23181 00003927 F7C3C040                	test	bx,sf_close_nodate+devid_file_clean+devid_device
 23182 0000392B 75E2                    	jnz	short localcommit_retn
 23183                                  %endif
 23184                                  
 23185 0000392D 50                      	push	ax
 23186 0000392E 53                      	push	bx
 23187 0000392F E83AD2                  	call	DATE16			; Date/Time to AX/DX
 23188                                  	;mov	[es:di+0Fh],ax
 23189 00003932 2689450F                	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 23190                                  	;mov	[es:di+0Dh],dx
 23191 00003936 2689550D                	MOV	[ES:DI+SF_ENTRY.sf_time],DX
 23192 0000393A 31C0                    	XOR	AX,AX
 23193                                  ;if installed
 23194                                  	;call	JShare + 14 * 4
 23195 0000393C FF1E[C800]              	call	far [JShare+(14*4)]	; 14 = ShSU
 23196                                  ;else
 23197                                  ;	call	ShSU
 23198                                  ;endif
 23199 00003940 5B                      	pop	bx
 23200 00003941 58                      	pop	ax
 23201 00003942 C3                      	retn
 23202                                  
 23203                                  ;============================================================================
 23204                                  ; DIRCALL.ASM, MSDOS 6.0, 1991
 23205                                  ;============================================================================
 23206                                  ; 23/07/2018 - Retro DOS v3.0
 23207                                  ; 18/05/2019 - Retro DOS v4.0
 23208                                  
 23209                                  ; DOSCODE:6FDAh (MSDOS 6.21, MSDOS.SYS)
 23210                                  
 23211                                  ;TITLE DIRCALL - Directory manipulation internal calls
 23212                                  ;NAME  DIRCALL
 23213                                  
 23214                                  ;**	Low level directory manipulation routines for making removing and
 23215                                  ;	  verifying local or NET directories
 23216                                  ;
 23217                                  ;	DOS_MKDIR
 23218                                  ;	DOS_CHDIR
 23219                                  ;	DOS_RMDIR
 23220                                  ;
 23221                                  ;	Modification history:
 23222                                  ;
 23223                                  ;		Created: ARR 30 March 1983
 23224                                  
 23225                                  ;BREAK <DOS_MkDir - Make a directory entry>
 23226                                  ;---------------------------------------------------------------------------
 23227                                  ;
 23228                                  ; Procedure Name : DOS_MkDir
 23229                                  ;
 23230                                  ; Inputs:
 23231                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 23232                                  ;		terminated)
 23233                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 23234                                  ;		( = -1 if current dir not involved, else
 23235                                  ;		 Points to first char after last "/" of current dir part)
 23236                                  ;	[THISCDS] Points to CDS being used
 23237                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 23238                                  ; Function:
 23239                                  ;	Make a new directory
 23240                                  ; Returns:
 23241                                  ;	Carry Clear
 23242                                  ;		No error
 23243                                  ;	Carry Set
 23244                                  ;	    AX is error code
 23245                                  ;		error_path_not_found
 23246                                  ;			Bad path (not in curr dir part if present)
 23247                                  ;		error_bad_curr_dir
 23248                                  ;			Bad path in current directory part of path
 23249                                  ;		error_access_denied
 23250                                  ;			Already exists, device name
 23251                                  ; DS preserved, Others destroyed
 23252                                  ;---------------------------------------------------------------------------
 23253                                  
 23254                                  ;hkn; called from path.asm. DS already set up.
 23255                                  
 23256                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23257                                  ; DOSCODE:6FC6h (MSDOS 5.0, MSDOS.SYS)
 23258                                  
 23259                                  ; burada kaldým.. 04/02/2024
 23260                                  
 23261                                  DOS_MKDIR:
 23262 00003943 E8FBDE                  	call	TestNet
 23263 00003946 7313                    	JNC	short LOCAL_MKDIR
 23264                                  
 23265                                  ;IF NOT Installed
 23266                                  ;	transfer NET_MKDIR
 23267                                  ;ELSE
 23268                                  	;mov	ax,1103h
 23269 00003948 B80311                  	MOV	AX,(MultNET<<8)|3
 23270 0000394B CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY
 23271                                  			; SS = DOS CS
 23272                                  			; SDA first filename pointer -> fully-qualified directory name
 23273                                  			; SDA CDS pointer -> current directory
 23274                                  			; Return: CF set on error, AX = DOS error code
 23275                                  			; CF clear if successful
 23276 0000394D C3                      	retn
 23277                                  ;ENDIF
 23278                                  
 23279                                  NODEACCERRJ:
 23280                                  	;mov	ax,5
 23281 0000394E B80500                  	MOV	AX,error_access_denied
 23282                                  _BadRet:
 23283 00003951 F9                      	STC
 23284                                  	;call	LCritDisk
 23285                                  	;retn
 23286                                  	; 18/12/2022
 23287 00003952 E9DBDF                  	jmp	LCritDisk
 23288                                  
 23289                                  PATHNFJ:
 23290 00003955 E8D8DF                  	call	LCritDisk
 23291 00003958 E915F8                  	jmp	SET_MKND_ERR	; Map the MakeNode error and return
 23292                                  
 23293                                  LOCAL_MKDIR:
 23294 0000395B E8A5DF                  	call	ECritDisk
 23295                                  
 23296                                  ; MakeNode requires an SFT to fiddle with. We Use a temp spot (RENBUF)
 23297                                  
 23298 0000395E 8C16[A005]              	MOV	[THISSFT+2],SS
 23299                                  
 23300                                  ;hkn; DOSDATA
 23301 00003962 C706[9E05][3E04]        	MOV	WORD [THISSFT],RENBUF
 23302                                  
 23303                                  ;  NOTE: Need WORD PTR because MASM takes type of
 23304                                  ;   TempSFT (byte) instead of type of sf_mft (word).
 23305                                  
 23306                                  	;mov	word [RENBUF+33h],0 ; MSDOS 6.0
 23307 00003968 C706[7104]0000          	MOV	WORD [RENBUF+SF_ENTRY.sf_MFT],0
 23308                                  				; make sure SHARER won't complain.
 23309                                  	;mov	al,10h
 23310 0000396E B010                    	MOV	AL,attr_directory
 23311 00003970 E8CD19                  	call	MakeNode
 23312 00003973 72E0                    	JC	short PATHNFJ
 23313 00003975 83F803                  	CMP	AX,3
 23314 00003978 74D4                    	JZ	short NODEACCERRJ ; Can't make a device into a directory
 23315 0000397A C42E[8A05]              	LES	BP,[THISDPB]	; Makenode zaps this
 23316 0000397E C53E[E205]              	LDS	DI,[CURBUF]
 23317 00003982 29FE                    	SUB	SI,DI
 23318 00003984 56                      	PUSH	SI		; Pointer to dir_first
 23319                                  	; MSDOS 6.0
 23320                                  	;push	word [DI+8]
 23321 00003985 FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;F.C. >32mb
 23322                                  	; MSDOS 3.3 & MSDOS 6.0
 23323                                  	;push	word [di+6]
 23324 00003988 FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Sector of new node
 23325 0000398B 16                      	push	ss
 23326 0000398C 1F                      	pop	ds
 23327 0000398D FF36[C205]              	PUSH	word [DIRSTART]	; Parent for .. entry
 23328 00003991 31C0                    	XOR	AX,AX
 23329 00003993 A3[C205]                	MOV	[DIRSTART],AX	; Null directory
 23330 00003996 E8E318                  	call	NEWDIR
 23331 00003999 726F                    	JC	short NODEEXISTSPOPDEL ; No room
 23332 0000399B E8650D                  	call	GETENT		; First entry
 23333 0000399E 726A                    	JC	short NODEEXISTSPOPDEL ; Screw up
 23334 000039A0 C43E[E205]              	LES	DI,[CURBUF]
 23335                                  
 23336                                  	; MSDOS 6.0
 23337 000039A4 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 23338                                  				 ;LB. if already dirty		    ;AN000;
 23339 000039A9 7508                    	JNZ	short yesdirty5	 ;LB.   don't increment dirty count ;AN000;
 23340 000039AB E8922B                  	call	INC_DIRTY_COUNT  ;LB.				    ;AN000;
 23341                                  	
 23342                                  	; MSDOS 3.3 & MSDOS 6.0
 23343                                  	;or	byte [es:di+5],40h  ; 07/12/2022
 23344 000039AE 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 23345                                  yesdirty5:
 23346                                  	;;add	di,16 ; MSDOS 3.3
 23347                                  	;add	di,20 ; MSDOS 6.0
 23348 000039B3 83C718                  	ADD	DI,BUFINSIZ	; Point at buffer
 23349 000039B6 B82E20                  	MOV	AX,202EH	; ". "
 23350 000039B9 8B16[C205]              	MOV	DX,[DIRSTART]	; Point at itself
 23351 000039BD E85C19                  	call	SETDOTENT
 23352 000039C0 B82E2E                  	MOV	AX,2E2EH	; ".."
 23353 000039C3 5A                      	POP	DX		; Parent
 23354 000039C4 E85519                  	call	SETDOTENT
 23355 000039C7 C42E[8A05]              	LES	BP,[THISDPB]
 23356                                  	; 22/09/2023
 23357                                  	;;mov	byte [ALLOWED],18h
 23358                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 23359 000039CB 5A                      	POP	DX		; Entry sector
 23360                                  	; MSDOS 6.0
 23361 000039CC 8F06[0706]              	POP	word [HIGH_SECTOR] ;F.C. >32mb
 23362                                  
 23363                                  	;XOR	AL,AL ; *	; Pre read
 23364                                  	;call	GETBUFFR
 23365                                  	; 22/09/2023
 23366 000039D0 E85829                  	call	GETBUFFER ; *	; Pre read
 23367 000039D3 725B                    	JC	short NODEEXISTSP
 23368 000039D5 8B16[C205]              	MOV	DX,[DIRSTART]
 23369 000039D9 C53E[E205]              	LDS	DI,[CURBUF]
 23370                                  	;or	byte [di+5],4
 23371 000039DD 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 23372 000039E1 5E                      	POP	SI		; dir_first pointer
 23373 000039E2 01FE                    	ADD	SI,DI
 23374 000039E4 8914                    	MOV	[SI],DX
 23375 000039E6 31D2                    	XOR	DX,DX
 23376 000039E8 895402                  	MOV	[SI+2],DX	; Zero size
 23377 000039EB 895404                  	MOV	[SI+4],DX
 23378                                  DIRUP:
 23379                                  	; MSDOS 6.0
 23380 000039EE F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 23381                                  	;			 ;LB. if already dirty 		   ;AN000;
 23382 000039F2 7507                    	JNZ	short yesdirty6	 ;LB.  don't increment dirty count ;AN000;
 23383 000039F4 E8492B                  	call	INC_DIRTY_COUNT  ;LB.				   ;AN000;
 23384                                  	
 23385                                  	; MSDOS 3.3 & MSDOS 6.0
 23386                                  	;or	byte [di+5],40h
 23387 000039F7 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty	; Dirty buffer
 23388                                  yesdirty6:
 23389 000039FB 16                      	push	ss
 23390 000039FC 1F                      	pop	ds
 23391 000039FD 268A4600                	mov	al,[es:bp]
 23392                                  	;MOV	AL,[ES:BP+DPB.DRIVE]  ; mov al,[es:bp+0]
 23393 00003A01 E82B2A                  	call	FLUSHBUF
 23394                                  	;mov	ax,5
 23395 00003A04 B80500                  	MOV	AX,error_access_denied
 23396                                  	;call	LCritDisk
 23397                                  	;retn
 23398                                  	; 18/12/2022
 23399 00003A07 E926DF                  	jmp	LCritDisk
 23400                                  
 23401                                  NODEEXISTSPOPDEL:
 23402 00003A0A 5A                      	POP	DX		; Parent
 23403 00003A0B 5A                      	POP	DX		; Entry sector
 23404                                  	; MSDOS 6.0 
 23405 00003A0C 8F06[0706]              	POP	word [HIGH_SECTOR] ; F.C. >32mb
 23406 00003A10 C42E[8A05]              	LES	BP,[THISDPB]
 23407                                  	; 22/09/2023
 23408                                  	;;mov	byte [ALLOWED],18h
 23409                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 23410                                  	;XOR	AL,AL ; *	; Pre read
 23411                                  	;call	GETBUFFR
 23412                                  	; 22/09/2023
 23413 00003A14 E81429                  	call	GETBUFFER ; *	; Pre read
 23414 00003A17 7217                    	JC	short NODEEXISTSP
 23415 00003A19 C53E[E205]              	LDS	DI,[CURBUF]
 23416                                  	;or	byte [di+5],4
 23417 00003A1D 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 23418 00003A21 5E                      	POP	SI		; dir_first pointer
 23419 00003A22 01FE                    	ADD	SI,DI
 23420                                  	;sub	si,1Ah ; 26
 23421 00003A24 83EE1A                  	SUB	SI,dir_entry.dir_first	;Point back to start of dir entry
 23422 00003A27 C604E5                  	MOV	BYTE [SI],0E5H	; Free the entry
 23423 00003A2A E8C1FF                  	CALL	DIRUP		; Error doesn't matter since erroring anyway
 23424                                  NODEEXISTS:
 23425 00003A2D E91EFF                  	JMP	NODEACCERRJ ; 10/08/2018
 23426                                  
 23427                                  NODEEXISTSP:
 23428 00003A30 5E                      	POP	SI		; Clean stack
 23429 00003A31 EBFA                    	JMP	short NODEEXISTS
 23430                                  
 23431                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23432                                  
 23433                                  ;BREAK <DOS_ChDir -- Verify a directory>
 23434                                  ;----------------------------------------------------------------------------
 23435                                  ;
 23436                                  ; Procedure Name : DOS_ChDir
 23437                                  ;
 23438                                  ; Inputs:
 23439                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 23440                                  ;		terminated)
 23441                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 23442                                  ;		( = -1 if current dir not involved, else
 23443                                  ;		 Points to first char after last "/" of current dir part)
 23444                                  ;	[THISCDS] Points to CDS being used May not be NUL
 23445                                  ; Function:
 23446                                  ;	Validate the path for potential new current directory
 23447                                  ; Returns:
 23448                                  ;	NOTE:
 23449                                  ;	    [SATTRIB] is modified by this call
 23450                                  ;	Carry Clear
 23451                                  ;	    CX is cluster number of the DIR, LOCAL CDS ONLY
 23452                                  ;		Caller must NOT set ID fields on a NET CDS.
 23453                                  ;	Carry Set
 23454                                  ;	    AX is error code
 23455                                  ;		error_path_not_found
 23456                                  ;			Bad path
 23457                                  ;		error_access_denied
 23458                                  ;			device or file name
 23459                                  ; DS preserved, Others destroyed
 23460                                  ;----------------------------------------------------------------------------
 23461                                  
 23462                                  ;hkn; called from path.asm and dir2.asm. DS already set up.
 23463                                  
 23464                                  ; 18/05/2019 - Retro DOS v4.0
 23465                                  ; DOSCODE:70DAh (MSDOS 6.21, MSDOS.SYS)
 23466                                  
 23467                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23468                                  ; DOSCODE:70C6h (MSDOS 5.0, MSDOS.SYS)
 23469                                  
 23470                                  DOS_CHDIR:
 23471 00003A33 E80BDE                  	call	TestNet
 23472 00003A36 7306                    	JNC	short LOCAL_CHDIR
 23473                                  
 23474                                  ;IF NOT Installed
 23475                                  ;	transfer NET_CHDIR
 23476                                  ;ELSE
 23477                                  	;mov	ax,1105h
 23478 00003A38 B80511                  	MOV	AX,(MultNET<<8)|5
 23479 00003A3B CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CHDIR
 23480                                  			; SS = DOS CS
 23481                                  			; SDA first filename pointer -> fully-qualified directory name
 23482                                  			; SDA CDS pointer -> current directory
 23483                                  			; Return: CF set on error, AX = DOS error code
 23484                                  			; CF clear if successful
 23485 00003A3D C3                      	retn
 23486                                  ;ENDIF
 23487                                  
 23488                                  LOCAL_CHDIR:
 23489 00003A3E E8C2DE                  	call	ECritDisk
 23490                                  	; MSDOS 6.0
 23491                                  	;;test	word [es:di+43h],2000h
 23492                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice ;PTM.
 23493                                  	; 17/12/2022
 23494                                  	;test	byte [es:di+44h],20h
 23495 00003A41 26F6454420              	test	byte [ES:DI+curdir.flags+1],(curdir_splice>>8) ;PTM.
 23496 00003A46 7406                    	JZ	short nojoin		   ;PTM.
 23497                                  	;mov	word [es:di+49h], 0FFFFh
 23498 00003A48 26C74549FFFF            	MOV	word [ES:DI+curdir.ID],0FFFFH ;PTM.
 23499                                  nojoin:
 23500                                  	; MSDOS 3.3 & MSDOS 6.0
 23501 00003A4E C606[4C03]00            	MOV	byte [NoSetDir],0 ; FALSE
 23502                                  	;mov	byte [SATTRIB],16h
 23503 00003A53 C606[6D05]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 23504                                  				; Dir calls can find these
 23505                                  ; DOS 3.3  6/24/86 FastOpen
 23506 00003A58 800E[6D12]01            	OR	byte [FastOpenFlg],FastOpen_Set	; set fastopen flag
 23507 00003A5D E8740E                  	call	GETPATH
 23508 00003A60 9C                      	PUSHF						;AN000;
 23509 00003A61 8026[6D12]80            	AND	byte [FastOpenFlg],Fast_yes ; clear it all ;AC000;
 23510 00003A66 9D                      	POPF						;AN000;
 23511                                  ; DOS 3.3  6/24/86 FastOpen
 23512                                  
 23513                                  	; MSDOS 3.3
 23514                                  	;mov	byte [FastOpenFlg],0
 23515                                  	
 23516                                  	;mov	ax,3
 23517 00003A67 B80300                  	MOV	AX,error_path_not_found
 23518 00003A6A 7207                    	JC	short ChDirDone
 23519 00003A6C 753A                    	JNZ	short NOTDIRPATH	; Path not a DIR
 23520 00003A6E 8B0E[C205]              	MOV	CX,[DIRSTART]		; Get cluster number
 23521 00003A72 F8                      	CLC
 23522                                  ChDirDone:
 23523                                  	;call	LCritDisk
 23524                                  	;retn
 23525                                  	; 18/12/2022
 23526 00003A73 E9BADE                  	jmp	LCritDisk
 23527                                  
 23528                                  ;BREAK <DOS_RmDir -- Remove a directory>
 23529                                  ;----------------------------------------------------------------------------
 23530                                  ;
 23531                                  ; Procedure Name : DOS_RmDir
 23532                                  ;
 23533                                  ; Inputs:
 23534                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 23535                                  ;		terminated)
 23536                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 23537                                  ;		( = -1 if current dir not involved, else
 23538                                  ;		 Points to first char after last "/" of current dir part)
 23539                                  ;	[THISCDS] Points to CDS being used
 23540                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 23541                                  ; Function:
 23542                                  ;	Remove a directory
 23543                                  ;	NOTE: Attempt to remove current directory must be detected by caller
 23544                                  ; Returns:
 23545                                  ;	NOTE:
 23546                                  ;	    [SATTRIB] is modified by this call
 23547                                  ;	Carry Clear
 23548                                  ;		No error
 23549                                  ;	Carry Set
 23550                                  ;	    AX is error code
 23551                                  ;		error_path_not_found
 23552                                  ;			Bad path (not in curr dir part if present)
 23553                                  ;		error_bad_curr_dir
 23554                                  ;			Bad path in current directory part of path
 23555                                  ;		error_access_denied
 23556                                  ;			device or file name, root directory
 23557                                  ;			Bad directory ('.' '..' messed up)
 23558                                  ; DS preserved, Others destroyed
 23559                                  ;----------------------------------------------------------------------------
 23560                                  
 23561                                  ;hkn; called from path.asm. DS already set up.
 23562                                  
 23563                                  ; 18/05/2019 - Retro DOS v4.0
 23564                                  ; DOSCODE:711Fh (MSDOS 6.21, MSDOS.SYS)
 23565                                  
 23566                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23567                                  ; DOSCODE:710Bh (MSDOS 5.0, MSDOS.SYS)
 23568                                  
 23569                                  DOS_RMDIR:
 23570 00003A76 E8C8DD                  	call	TestNet
 23571 00003A79 7306                    	JNC	short LOCAL_RMDIR
 23572                                  
 23573                                  ;IF NOT Installed
 23574                                  ;	transfer NET_RMDIR
 23575                                  ;ELSE
 23576                                  	;mov	ax,1101h
 23577 00003A7B B80111                  	MOV	AX,(MultNET<<8)|1
 23578 00003A7E CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
 23579                                  			; SS = DOS CS
 23580                                  			; SDA first filename pointer -> fully-qualified directory name
 23581                                  			; SDA CDS pointer -> current directory
 23582                                  			; Return: CF set on error, AX = DOS error code
 23583                                  			; CF clear if successful
 23584 00003A80 C3                      	retn
 23585                                  ;ENDIF
 23586                                  
 23587                                  LOCAL_RMDIR:
 23588 00003A81 E87FDE                  	call	ECritDisk
 23589 00003A84 C606[4C03]00            	MOV	byte [NoSetDir],0
 23590                                  	;mov	byte [SATTRIB],16h
 23591 00003A89 C606[6D05]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 23592                                  					; Dir calls can find these
 23593 00003A8E E8430E                  	call	GETPATH
 23594 00003A91 720C                    	JC	short NOPATH		; Path not found
 23595 00003A93 7513                    	JNZ	short NOTDIRPATH	; Path not a DIR
 23596 00003A95 8B3E[C205]              	MOV	DI,[DIRSTART]
 23597 00003A99 09FF                    	OR	DI,DI			; Root ?
 23598 00003A9B 750E                    	JNZ	short rmdir_get_buf	; No
 23599 00003A9D EB09                    	JMP	SHORT NOTDIRPATH
 23600                                  
 23601                                  NOPATH:
 23602                                  	;mov	ax,3
 23603 00003A9F B80300                  	MOV	AX,error_path_not_found
 23604 00003AA2 E9ACFE                  	JMP	_BadRet
 23605                                  
 23606                                  NOTDIRPATHPOP:
 23607 00003AA5 58                      	POP	AX  ; MSDOS 6.0		;F.C. >32mb
 23608 00003AA6 58                      	POP	AX
 23609                                  NOTDIRPATHPOP2:
 23610 00003AA7 58                      	POP	AX
 23611                                  NOTDIRPATH:
 23612 00003AA8 E9A3FE                  	JMP	NODEACCERRJ
 23613                                  
 23614                                  rmdir_get_buf:
 23615 00003AAB C53E[E205]              	LDS	DI,[CURBUF]
 23616 00003AAF 29FB                    	SUB	BX,DI		; Compute true offset
 23617 00003AB1 53                      	PUSH	BX		; Save entry pointer
 23618                                  	
 23619                                  	; MSDOS 6.0
 23620                                  	;push	word [di+8]
 23621 00003AB2 FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2] ;F.C. >32mb
 23622                                  	
 23623                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23624                                  	;push	word [di+6]
 23625 00003AB5 FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Save sector number
 23626                                  
 23627                                  ;hkn; SS is DOSDATA
 23628                                  	;context DS
 23629 00003AB8 16                      	push	ss
 23630 00003AB9 1F                      	pop	ds
 23631                                  	;context ES
 23632 00003ABA 16                      	push	ss
 23633 00003ABB 07                      	pop	es
 23634                                  
 23635                                  ;hkn; NAME1 is in DOSDATA
 23636 00003ABC BF[4B05]                	MOV	DI,NAME1
 23637 00003ABF B03F                    	MOV	AL,'?'
 23638 00003AC1 B90B00                  	MOV	CX,11
 23639 00003AC4 F3AA                    	REP	STOSB
 23640 00003AC6 30C0                    	XOR	AL,AL
 23641 00003AC8 AA                      	STOSB				; Nul terminate it
 23642 00003AC9 E89B10                  	call	STARTSRCH		; Set search
 23643 00003ACC E8310C                  	call	GETENTRY		; Get start of directory
 23644 00003ACF 72D4                    	JC	short NOTDIRPATHPOP	; Screw up
 23645 00003AD1 8E1E[E405]              	MOV	DS,[CURBUF+2]
 23646 00003AD5 89DE                    	MOV	SI,BX
 23647 00003AD7 AD                      	LODSW
 23648                                  	;CMP	AX,(' ' SHL 8) OR '.'   ; First entry '.'?
 23649 00003AD8 3D2E20                  	cmp	ax,202Eh ; ". "
 23650 00003ADB 75C8                    	JNZ	short NOTDIRPATHPOP	; Nope
 23651                                  	;add	si,30
 23652 00003ADD 83C61E                  	ADD	SI,dir_entry.size-2 ; Next entry
 23653 00003AE0 AD                      	LODSW
 23654                                  	;CMP	AX,('.' SHL 8) OR '.'   ; Second entry '..'?
 23655                                  	;cmp	ax, '..'
 23656 00003AE1 3D2E2E                  	cmp	ax,2E2Eh
 23657 00003AE4 75BF                    	JNZ	short NOTDIRPATHPOP	; Nope
 23658                                  
 23659                                  ;hkn; SS is DOSDATA
 23660                                  	;context DS
 23661 00003AE6 16                      	push	ss
 23662 00003AE7 1F                      	pop	ds
 23663 00003AE8 C706[4803]0200          	MOV	word [LASTENT],2	; Skip . and ..
 23664 00003AEE E80F0C                  	call	GETENTRY		; Get next entry
 23665 00003AF1 72B2                    	JC	short NOTDIRPATHPOP	; Screw up
 23666                                  	;mov	byte [ATTRIB],16h
 23667 00003AF3 C606[6B05]16            	MOV	byte [ATTRIB],attr_directory+attr_hidden+attr_system
 23668 00003AF8 E80D0B                  	call	SRCH			; Do a search
 23669 00003AFB 73A8                    	JNC	short NOTDIRPATHPOP	; Found another entry!
 23670 00003AFD 803E[4A03]00            	CMP	byte [FAILERR],0
 23671 00003B02 75A1                    	JNZ	short NOTDIRPATHPOP	; Failure of search due to I 24 FAIL
 23672 00003B04 C42E[8A05]              	LES	BP,[THISDPB]
 23673 00003B08 8B1E[C205]              	MOV	BX,[DIRSTART]
 23674 00003B0C E8651D                  	call	RELEASE 		; Release data in sub dir
 23675 00003B0F 7294                    	JC	short NOTDIRPATHPOP	; Screw up
 23676 00003B11 5A                      	POP	DX			; Sector # of entry
 23677 00003B12 8F06[0706]              	POP	word [HIGH_SECTOR] ; MSDOS 6.0	; F.C. >32mb
 23678                                  	; 22/09/2023
 23679                                  	;;mov	byte [ALLOWED],18h
 23680                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 23681                                  	;XOR	AL,AL ; *		; Pre read
 23682                                  	;call	GETBUFFR		; Get sector back
 23683 00003B16 E81228                  	call	GETBUFFER ; *		; Pre Read
 23684 00003B19 728C                    	JC	short NOTDIRPATHPOP2	; Screw up
 23685 00003B1B C53E[E205]              	LDS	DI,[CURBUF]
 23686                                  	;or	byte [di+5],4
 23687 00003B1F 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 23688 00003B23 5B                      	POP	BX			; Pointer to start of entry
 23689 00003B24 01FB                    	ADD	BX,DI			; Corrected
 23690 00003B26 C607E5                  	MOV	BYTE [BX],0E5H		; Free the entry
 23691                                  
 23692                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 23693 00003B29 1E                      	PUSH	DS
 23694                                  
 23695                                  ;hkn; SS is DOSDATA
 23696                                  	;context DS
 23697 00003B2A 16                      	push	ss
 23698 00003B2B 1F                      	pop	ds
 23699                                  
 23700                                  	; MSDOS 6.0
 23701 00003B2C E835F2                  	call	FastOpen_Delete 	; call fastopen to delete an entry
 23702                                  
 23703                                  ;	; MSDOS 3.3
 23704                                  ;_FastOpen_Delete:
 23705                                  ;	push	ax
 23706                                  ;	mov	si,[WFP_START]
 23707                                  ;	mov	bx,FastTable
 23708                                  ;	;mov	al,3  ; FONC_delete
 23709                                  ;	mov	al,FONC_delete
 23710                                  ;	call	far [BX+2]  ; FastTable+2
 23711                                  ;	pop	ax
 23712                                  
 23713 00003B2F 1F                      	POP	DS
 23714                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 23715                                  
 23716 00003B30 E9BBFE                  	JMP	DIRUP			; In MKDIR, dirty buffer and flush
 23717                                  
 23718                                  ;============================================================================
 23719                                  ; DISK.ASM, MSDOS 6.0, 1991
 23720                                  ;============================================================================
 23721                                  ; 23/07/2018 - Retro DOS v3.0 
 23722                                  ; 04/05/2019 - Retro DOS v4.0
 23723                                  
 23724                                  ;	TITLE	DISK - Disk utility routines
 23725                                  ;	NAME	Disk
 23726                                  
 23727                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 23728                                  ;
 23729                                  ;	SWAPCON
 23730                                  ;	SWAPBACK
 23731                                  ;	DOS_READ
 23732                                  ;	DOS_WRITE
 23733                                  ;	get_io_sft
 23734                                  ;	DirRead
 23735                                  ;	FIRSTCLUSTER
 23736                                  ;	SET_BUF_AS_DIR
 23737                                  ;	FATSecRd
 23738                                  ;	DREAD
 23739                                  ;	CHECK_WRITE_LOCK
 23740                                  ;	CHECK_READ_LOCK
 23741                                  ;
 23742                                  ;	Revision history:
 23743                                  ;
 23744                                  ;		A000   version 4.00  Jan. 1988
 23745                                  ;
 23746                                  ;----------------------------------------------------------------------------
 23747                                  ;
 23748                                  ; M065 : B#5276. On raw read/write of a block of characters if a critical
 23749                                  ;		error happens, DOS retries the entire block assuming that
 23750                                  ;		zero characters were transferred. Modified the code to take
 23751                                  ;		into account the number of characters transfered before
 23752                                  ;		retrying the operation.
 23753                                  ;
 23754                                  ;----------------------------------------------------------------------------
 23755                                  ;
 23756                                  
 23757                                  ;Installed = TRUE
 23758                                  
 23759                                  ;Break	<SwapCon, Swap Back - Old-style I/O to files>
 23760                                  
 23761                                  ; **** Drivers for file input from devices ****
 23762                                  ;----------------------------------------------------------------------------
 23763                                  ;   Indicate that there is no more I/O occurring through another SFT outside
 23764                                  ;   of handles 0 and 1
 23765                                  ;
 23766                                  ;   Inputs:	DS is DOSDATA
 23767                                  ;   Outputs:	CONSWAP is set to false.
 23768                                  ;   Registers modified: none
 23769                                  ;----------------------------------------------------------------------------
 23770                                  
 23771                                  ; IBMDOS.COM (MSDOS 3.3) - Offset 3CF8h
 23772                                  
 23773                                  ; DOSCODE:71E3h (MSDOS 6.21, MSDOS.SYS)
 23774                                  ; 04/05/2019 - Retro DOS v4.0
 23775                                  
 23776                                  ; DOSCODE:71CFh (MSDOS 5.0, MSDOS.SYS)
 23777                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23778                                  
 23779                                  SWAPBACK:
 23780 00003B33 C606[5703]00            	MOV	BYTE [CONSWAP],0	; signal no conswaps
 23781 00003B38 C3                      	retn
 23782                                  
 23783                                  ;----------------------------------------------------------------------------
 23784                                  ;
 23785                                  ; Procedure Name : SWAPCON
 23786                                  ;
 23787                                  ;   Copy ThisSFT to CONSFT for use by the 1-12 primitives.
 23788                                  ;
 23789                                  ;   Inputs:	ThisSFT as the sft of the desired file
 23790                                  ;		DS is DOSDATA
 23791                                  ;   Outputs:	CONSWAP is set.  CONSFT = ThisSFT.
 23792                                  ;   Registers modified: none
 23793                                  ;--------------------------------------------------------------------------
 23794                                  
 23795                                  SWAPCON:
 23796                                  	; MSDOS 3.3
 23797                                  	;push	es
 23798                                  	;push	di
 23799                                  	;mov	byte [CONSWAP],1
 23800                                  	;les	di,[THISSFT]
 23801                                  	;mov	word [CONSFT],di
 23802                                  	;mov	word [CONSFT+2],es
 23803                                  	;pop	di
 23804                                  	;pop	es
 23805                                  	;retn
 23806                                  
 23807                                  	; MSDOS 6.0
 23808 00003B39 C606[5703]01            	mov	byte [CONSWAP],1	; ConSwap = TRUE
 23809 00003B3E 50                      	push	ax
 23810 00003B3F A1[9E05]                	mov	ax,[THISSFT]
 23811 00003B42 A3[E605]                	mov	[CONSFT],ax
 23812 00003B45 A1[A005]                	mov	ax,[THISSFT+2]
 23813 00003B48 A3[E805]                	mov	[CONSFT+2],ax
 23814 00003B4B 58                      	pop	ax
 23815 00003B4C C3                      	retn
 23816                                  
 23817                                  ; DOSCODE:71FDh (MSDOS 6.21, MSDOS.SYS)
 23818                                  ; 04/05/2019 - Retro DOS v4.0
 23819                                  
 23820                                  ;Break	<DOS_READ -- MAIN READ ROUTINE AND DEVICE IN ROUTINES>
 23821                                  ;-----------------------------------------------------------------------------
 23822                                  ;
 23823                                  ; Inputs:
 23824                                  ;	ThisSFT set to the SFT for the file being used
 23825                                  ;	[DMAADD] contains transfer address
 23826                                  ;	CX = No. of bytes to read
 23827                                  ;	DS = DOSDATA
 23828                                  ; Function:
 23829                                  ;	Perform read operation
 23830                                  ; Outputs:
 23831                                  ;    Carry clear
 23832                                  ;	SFT Position and cluster pointers updated
 23833                                  ;	CX = No. of bytes read
 23834                                  ;	ES:DI point to SFT
 23835                                  ;    Carry set
 23836                                  ;	AX is error code
 23837                                  ;	CX = 0
 23838                                  ;	ES:DI point to SFT
 23839                                  ; DS preserved, all other registers destroyed
 23840                                  ;
 23841                                  ;-----------------------------------------------------------------------------
 23842                                  
 23843                                  ;hkn; called from fcbio.asm, handle.asm and dev.asm. DS is be set up.
 23844                                  
 23845                                  ; DOSCODE:71E9h (MSDOS 5.0, MSDOS.SYS)
 23846                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23847                                  
 23848                                  DOS_READ:
 23849 00003B4D C43E[9E05]              	LES	DI,[THISSFT]
 23850                                  
 23851                                  ; Verify that the sft has been opened in a mode that allows reading.
 23852                                  
 23853                                  	;mov	al,[es:di+2]
 23854 00003B51 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 23855                                  	;and	al,0Fh
 23856 00003B55 240F                    	AND	AL,access_mask
 23857                                  	;cmp	al,1
 23858 00003B57 3C01                    	CMP	AL,open_for_write
 23859 00003B59 7503                    	JNE	short READ_NO_MODE	; Is read or both
 23860 00003B5B E90306                  	jmp	SET_ACC_ERR
 23861                                  
 23862                                  READ_NO_MODE:
 23863 00003B5E E8E104                  	call	SETUP
 23864 00003B61 E30B                    	JCXZ	NoIORet 		; no bytes to read - fast return
 23865 00003B63 E8F4DC                  	call	IsSFTNet
 23866 00003B66 7408                    	JZ	short LOCAL_READ
 23867                                  
 23868                                  ;IF NOT Installed
 23869                                  ;	transfer NET_READ
 23870                                  ;ELSE
 23871                                  	;mov	ax,1108h
 23872 00003B68 B80811                  	MOV	AX,(MultNET<<8)|8
 23873 00003B6B CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - READ FROM REMOTE FILE
 23874                                  			; ES:DI -> SFT
 23875                                  			; SFT DPB field -> DPB of drive containing file
 23876                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 23877                                  			; Return: CF set on error, CX = bytes read
 23878 00003B6D C3                      	retn
 23879                                  ;ENDIF
 23880                                  
 23881                                  ; The user ended up requesting 0 bytes of input. We do nothing for this case
 23882                                  ; except return immediately.
 23883                                  
 23884                                  NoIORet:
 23885 00003B6E F8                      	CLC
 23886 00003B6F C3                      	retn
 23887                                  
 23888                                  LOCAL_READ:
 23889                                  	;test	word [es:di+5],80h
 23890                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device  ; Check for named device I/O
 23891 00003B70 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; 02/06/2019
 23892 00003B75 750E                    	JNZ	short READDEV
 23893                                  
 23894                                  	;mov	byte [EXTERR_LOCUS],2
 23895 00003B77 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 23896 00003B7C E884DD                  	call	ECritDisk
 23897 00003B7F E89B05                  	call	DISKREAD
 23898                                  
 23899                                  critexit:
 23900                                  	;call	LCritDisk
 23901                                  	;retn
 23902                                  	; 16/12/2022
 23903 00003B82 E9ABDD                  	jmp	LCritDisk
 23904                                  
 23905                                  ; We are reading from a device. Examine the status of the device to see if we
 23906                                  ; can short-circuit the I/O. If the device in the EOF state or if it is the
 23907                                  ; null device, we can safely indicate no transfer.
 23908                                  
 23909                                  READDEV:
 23910                                  	;mov	byte [EXTERR_LOCUS],4
 23911 00003B85 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 23912                                  	;mov	bl,[es:di+5]
 23913 00003B8A 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 23914 00003B8E C43E[2C03]              	LES	DI,[DMAADD]
 23915                                  	;test	bl,40h
 23916 00003B92 F6C340                  	test	BL,devid_device_EOF	; End of file?
 23917 00003B95 7407                    	JZ	short ENDRDDEVJ3
 23918                                  	;test	bl,4
 23919 00003B97 F6C304                  	test	BL,devid_device_null	; NUL device?
 23920 00003B9A 7405                    	JZ	short TESTRAW 		; NO
 23921 00003B9C 30C0                    	XOR	AL,AL			; Indicate EOF by setting zero
 23922                                  ENDRDDEVJ3:
 23923                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 23924                                  	;JMP	short ENDRDDEVJ2
 23925                                  	; 16/12/2022
 23926 00003B9E E96701                  	jmp	ENDRDDEV ; 04/05/2019
 23927                                  
 23928                                  ; We need to hit the device. Figure out if we do a raw read or we do the
 23929                                  ; bizarre std_con_string_input.
 23930                                  
 23931                                  TESTRAW:
 23932                                  	;test	bl,20h
 23933 00003BA1 F6C320                  	test	BL,devid_device_raw	; Raw mode?
 23934 00003BA4 7508                    	JNZ	short DVRDRAW 		; Yes, let the device do all local editing
 23935                                  	;test	bl,1
 23936 00003BA6 F6C301                  	test	BL,devid_device_con_in	; Is it console device?
 23937 00003BA9 7461                    	JZ	short NOTRDCON
 23938 00003BAB E98F01                  	JMP	READCON
 23939                                  
 23940                                  DVRDRAW:
 23941 00003BAE 06                      	PUSH	ES
 23942 00003BAF 1F                      	POP	DS			; Xaddr to DS:DI
 23943                                  
 23944                                  	; 04/05/2019 - Retro DOS v4.0
 23945                                  
 23946                                  	; MSDOS 6.0
 23947                                  ;SR;
 23948                                  ;Check for win386 presence -- if present, do polled read of characters
 23949                                  
 23950 00003BB0 36F606[A110]01          	test	byte [ss:IsWin386],1 ; 19/05/2019
 23951 00003BB6 7408                    	jz	short ReadRawRetry	;not present
 23952 00003BB8 F6C301                  	test	bl,devid_device_con_in	;is it console device
 23953 00003BBB 7403                    	jz	short ReadRawRetry	;no, do normal read
 23954 00003BBD E9BA00                  	jmp	do_polling		;yes, do win386 polling loop
 23955                                  
 23956                                  ReadRawRetry:
 23957 00003BC0 89FB                    	MOV	BX,DI			; DS:BX transfer addr
 23958 00003BC2 31C0                    	XOR	AX,AX			; Media Byte, unit = 0
 23959 00003BC4 89C2                    	MOV	DX,AX			; Start at 0
 23960 00003BC6 E8D214                  	call	SETREAD
 23961 00003BC9 1E                      	PUSH	DS			; Save Seg part of Xaddr
 23962                                  
 23963                                  ;hkn; SS override
 23964 00003BCA 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 23965 00003BCF E85014                  	call	DEVIOCALL
 23966 00003BD2 89FA                    	MOV	DX,DI			; DS:DX is preserved by INT 24
 23967 00003BD4 B486                    	MOV	AH,86H			; Read error
 23968                                  
 23969                                  ;hkn; SS override
 23970 00003BD6 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 23971                                  	; MSDOS 3.3
 23972                                  	;test	di,8000h
 23973                                  	;jz	short CRDROK
 23974                                  	; MSDOS 6.0
 23975 00003BDB 09FF                    	or	di,di
 23976 00003BDD 7923                    	jns	short CRDROK		; no errors
 23977                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23978 00003BDF E8A520                  	call	CHARHARD
 23979 00003BE2 89D7                    	MOV	DI,DX			; DS:DI is Xaddr
 23980                                  
 23981                                  	; 04/05/2019
 23982                                  
 23983                                  	; MSDOS 6.0
 23984 00003BE4 36033E[6C03]            	add	di,[ss:CALLSCNT]	; update ptr and count to reflect the	M065
 23985 00003BE9 362B0E[6C03]            	sub	cx,[ss:CALLSCNT]	; number of chars xferred		M065
 23986                                  
 23987                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23988 00003BEE 08C0                    	OR	AL,AL
 23989 00003BF0 7410                    	JZ	short CRDROK		; Ignore
 23990 00003BF2 3C03                    	CMP	AL,3
 23991 00003BF4 7403                    	JZ	short CRDFERR 		; fail.
 23992 00003BF6 1F                      	POP	DS			; Recover saved seg part of Xaddr
 23993 00003BF7 EBC7                    	JMP	short ReadRawRetry	; Retry
 23994                                  
 23995                                  ; We have encountered a device-driver error. We have informed the user of it
 23996                                  ; and he has said for us to fail the system call.
 23997                                  
 23998                                  CRDFERR:
 23999 00003BF9 5F                      	POP	DI			; Clean stack
 24000                                  DEVIOFERR:
 24001                                  
 24002                                  ;hkn; SS override
 24003 00003BFA 36C43E[9E05]            	LES	DI,[SS:THISSFT]
 24004 00003BFF E95D05                  	jmp	SET_ACC_ERR_DS
 24005                                  
 24006                                  CRDROK:
 24007 00003C02 5F                      	POP	DI			; Chuck saved seg of Xaddr
 24008 00003C03 89D7                    	MOV	DI,DX
 24009                                  
 24010                                  ;hkn; SS override
 24011 00003C05 36033E[6C03]            	ADD	DI,[ss:CALLSCNT]	; Amount transferred
 24012                                  	;JMP	SHORT ENDRDDEVJ3
 24013                                  	; 16/12/2022
 24014 00003C0A EB6B                    	jmp	short ENDRDDEVJ2
 24015                                  
 24016                                  ; We are going to do a cooked read on some character device. There is a
 24017                                  ; problem here, what does the data look like? Is it a terminal device, line
 24018                                  ; CR line CR line CR, or is it file data, line CR LF line CR LF? Does it have
 24019                                  ; a ^Z at the end which is data, or is the ^Z not data?  In any event we're
 24020                                  ; going to do this: Read in pieces up to CR (CRs included in data) or ^z (^z
 24021                                  ; included in data). this "simulates" the way con works in cooked mode
 24022                                  ; reading one line at a time. With file data, however, the lines will look
 24023                                  ; like, LF line CR. This is a little weird.
 24024                                  
 24025                                  NOTRDCON:
 24026 00003C0C 8CC0                    	MOV	AX,ES
 24027 00003C0E 8ED8                    	MOV	DS,AX
 24028 00003C10 89FB                    	MOV	BX,DI
 24029 00003C12 31D2                    	XOR	DX,DX
 24030 00003C14 89D0                    	MOV	AX,DX
 24031 00003C16 51                      	PUSH	CX
 24032 00003C17 B90100                  	MOV	CX,1
 24033 00003C1A E87E14                  	call	SETREAD
 24034 00003C1D 59                      	POP	CX
 24035                                  
 24036                                  ;hkn; SS override
 24037 00003C1E 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 24038                                  	;lds	si,[si+7]
 24039 00003C23 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 24040                                  DVRDLP:
 24041 00003C26 E83F1E                  	call	DSKSTATCHK
 24042 00003C29 E8F913                  	call	DEVIOCALL2
 24043 00003C2C 57                      	PUSH	DI		; Save "count" done
 24044 00003C2D B486                    	MOV	AH,86H
 24045                                  
 24046                                  ;hkn; SS override
 24047 00003C2F 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 24048                                  	
 24049                                  	; MSDOS 3.3
 24050                                  	;test	di,8000h
 24051                                  	;jz	short CRDOK
 24052                                  	; MSDOS 6.0
 24053 00003C34 09FF                    	or	di,di
 24054 00003C36 7917                    	jns	short CRDOK
 24055                                  	
 24056 00003C38 E84C20                  	call	CHARHARD
 24057 00003C3B 5F                      	POP	DI
 24058                                  
 24059                                  ;hkn; SS override
 24060 00003C3C 36C706[6C03]0100        	MOV	word [SS:CALLSCNT],1
 24061 00003C43 3C01                    	CMP	AL,1
 24062 00003C45 74DF                    	JZ	short DVRDLP		;Retry
 24063 00003C47 3C03                    	CMP	AL,3
 24064 00003C49 74AF                    	JZ	short DEVIOFERR		; FAIL
 24065 00003C4B 30C0                    	XOR	AL,AL			; Ignore, Pick some random character
 24066 00003C4D EB12                    	JMP	SHORT DVRDIGN
 24067                                  
 24068                                  CRDOK:
 24069 00003C4F 5F                      	POP	DI
 24070                                  
 24071                                  ;hkn; SS override
 24072 00003C50 36833E[6C03]01          	CMP	word [SS:CALLSCNT],1
 24073                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 24074 00003C56 751F                    	JNZ	short ENDRDDEVJ2
 24075                                  	; 16/12/2022
 24076                                  	;jnz	short ENDRDDEV ; 24/07/2019
 24077                                  
 24078 00003C58 1E                      	PUSH	DS
 24079                                  
 24080                                  ;hkn; SS override
 24081 00003C59 368E1E[6A03]            	MOV	DS,[SS:CALLXAD+2]
 24082 00003C5E 8A05                    	MOV	AL,[DI]			; Get the character we just read
 24083 00003C60 1F                      	POP	DS
 24084                                  DVRDIGN:
 24085                                  
 24086                                  ;hkn; SS override
 24087 00003C61 36FF06[6803]            	INC	WORD [SS:CALLXAD]	; Next character
 24088 00003C66 36C706[5D03]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 24089 00003C6D 47                      	INC	DI			; Next character
 24090 00003C6E 3C1A                    	CMP	AL,1Ah			; ^Z?
 24091                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 24092 00003C70 7405                    	JZ	short ENDRDDEVJ2	; Yes, done zero set (EOF)
 24093                                  	; 16/12/2022
 24094                                  	;jz	short ENDRDDEV ; 24/07/2019	
 24095 00003C72 3C0D                    	CMP	AL,c_CR  ; 0Dh		; CR?
 24096 00003C74 E0B0                    	LOOPNZ	DVRDLP			; Loop if no, else done
 24097 00003C76 40                      	INC	AX			; Resets zero flag so NOT EOF, unless
 24098                                  					;  AX=FFFF which is not likely
 24099                                  ENDRDDEVJ2:
 24100                                  	; 16/12/2022
 24101                                  	;JMP	short ENDRDDEV		; changed short to long for win386
 24102                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24103 00003C77 E98E00                  	jmp	ENDRDDEV
 24104                                  
 24105                                  	; 04/05/2019
 24106                                  
 24107                                  	; MSDOS 6.0
 24108                                  ;SR;
 24109                                  ;Polling code for raw read on CON when WIN386 is present
 24110                                  ;
 24111                                  ;At this point -- ds:di is transfer address
 24112                                  ;		  cx is count
 24113                                  
 24114                                  do_polling:
 24115 00003C7A 89FB                    	mov	bx,di			;ds:bx is Xfer address
 24116 00003C7C 31C0                    	xor	ax,ax
 24117 00003C7E 89C2                    	mov	dx,ax
 24118 00003C80 E81814                  	call	SETREAD			;prepare device packet
 24119                                  
 24120                                  do_io:
 24121                                  ;Change read to a NON-DESTRUCTIVE READ, NO WAIT
 24122                                  
 24123 00003C83 26C6470205              	mov	byte [es:bx+2],DEVRDND ; 5 ;Change command code
 24124 00003C88 1E                      	push	ds
 24125 00003C89 36C536[9E05]            	lds	si,[ss:THISSFT]		;get device header
 24126 00003C8E E89113                  	call	DEVIOCALL		;call device driver
 24127 00003C91 1F                      	pop	ds
 24128                                  	
 24129                                  	;test	word [es:bx+3],8000h
 24130                                  	; 16/12/2022
 24131                                  	;test	byte [es:bx+4],80h
 24132 00003C92 26F6470480              	test	byte [es:bx+SRHEAD.REQSTAT+1],STERR>>8 
 24133                                  	;test	word [es:bx+SRHEAD.REQSTAT],STERR ;check if error
 24134 00003C97 7413                    	jz	short check_busy	;no
 24135                                  
 24136 00003C99 1E                      	push	ds
 24137 00003C9A 89FA                    	mov	dx,di
 24138                                  	;invoke charhard		;invoke int 24h handler
 24139 00003C9C E8E81F                  	call	CHARHARD
 24140 00003C9F 89D7                    	mov	di,dx
 24141 00003CA1 08C0                    	or	al,al
 24142 00003CA3 745D                    	jz	short pop_done_read	;ignore by user, assume read done
 24143 00003CA5 3C03                    	cmp	al,3
 24144 00003CA7 7448                    	jz	short devrderr		;user asked to fail
 24145 00003CA9 1F                      	pop	ds
 24146 00003CAA EBD7                    	jmp	short do_io		;user asked to retry
 24147                                  
 24148                                  check_busy:
 24149                                  	;test	word [es:bx+3],200h
 24150                                  	; 16/12/2022
 24151 00003CAC 26F6470402              	test	byte [es:bx+SRHEAD.REQSTAT+1],02h
 24152                                  	;test	word [es:bx+SRHEAD.REQSTAT],0200h ;see if busy bit set
 24153 00003CB1 7547                    	jnz	short no_char		;yes, no character available
 24154                                  
 24155                                  ;Character is available. Read in 1 character at a time until all characters
 24156                                  ;are read in or no character is available
 24157                                  
 24158 00003CB3 26C6470204              	mov	byte [es:bx+2],DEVRD ; 4 ;command code is READ now
 24159 00003CB8 26C747120100            	mov	word [es:bx+18],1	;change count to 1 character
 24160 00003CBE 1E                      	push	ds
 24161 00003CBF 36C536[9E05]            	lds	si,[ss:THISSFT]
 24162 00003CC4 E85B13                  	call	DEVIOCALL
 24163                                  
 24164 00003CC7 89FA                    	mov	dx,di
 24165 00003CC9 B486                    	mov	ah,86h
 24166                                  	;mov	di,[es:bx+3]
 24167 00003CCB 268B7F03                	mov	di,[es:bx+SRHEAD.REQSTAT] ;get returned status
 24168 00003CCF F7C70080                	test	di,STERR ; 8000h	;was there an error during read?
 24169 00003CD3 7410                    	jz	short next_char		;no,read next character
 24170                                  
 24171                                  	;invoke	charhard		;invoke int 24h handler
 24172 00003CD5 E8AF1F                  	call	CHARHARD
 24173 00003CD8 89D7                    	mov	di,dx			;restore di
 24174 00003CDA 08C0                    	or	al,al			;
 24175 00003CDC 7424                    	jz	short pop_done_read	;ignore by user,assume read is done
 24176 00003CDE 3C03                    	cmp	al,3
 24177 00003CE0 740F                    	jz	short devrderr		;user issued a 'fail',indicate error
 24178 00003CE2 1F                      	pop	ds
 24179 00003CE3 EB9E                    	jmp	short do_io		;user issued a retry
 24180                                  
 24181                                  next_char:
 24182 00003CE5 1F                      	pop	ds
 24183 00003CE6 89D7                    	mov	di,dx
 24184 00003CE8 49                      	dec	cx			;decrement count
 24185 00003CE9 E318                    	jcxz	done_read		;all characters read in
 24186 00003CEB 26FF470E                	inc	word [es:bx+14]		;update transfer address
 24187 00003CEF EB92                    	jmp	short do_io			;read next character in
 24188                                  
 24189                                  devrderr:
 24190 00003CF1 5F                      	pop	di			;discard segment address
 24191 00003CF2 36C43E[9E05]            	les	di,[ss:THISSFT]
 24192                                  	;transfer SET_ACC_ERR_DS	;indicate error
 24193 00003CF7 E96504                  	jmp     SET_ACC_ERR_DS
 24194                                  
 24195                                  no_char:
 24196                                  ;Since no character is available, we let win386 switch the VM out
 24197                                  
 24198 00003CFA 50                      	push	ax
 24199 00003CFB B484                    	mov	ah,84h	; Microsoft Networks - KEYBOARD BUSY LOOP
 24200 00003CFD CD2A                    	int	2Ah			;indicate idle to WIN386
 24201                                  
 24202                                  ;When control returns from WIN386, we continue the raw read
 24203                                  
 24204 00003CFF 58                      	pop	ax
 24205 00003D00 EB81                    	jmp	do_io
 24206                                  
 24207                                  pop_done_read:
 24208 00003D02 1F                      	pop	ds
 24209                                  done_read:
 24210 00003D03 36033E[6C03]            	add	di,[ss:CALLSCNT] ; 19/05/2019
 24211                                  
 24212                                  	; 16/12/2022
 24213                                  
 24214                                  	;jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit
 24215                                  	;jmp	ENDRDDEV ; 04/05/2019
 24216                                  
 24217                                  	; 04/05/2019 - Retro DOS v4.0
 24218                                  ENDRDDEV:
 24219 00003D08 16                      	push	ss
 24220 00003D09 1F                      	pop	ds
 24221 00003D0A EB1F                    	jmp	short endrddev1
 24222                                  
 24223                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24224                                  	;jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit
 24225                                  
 24226                                  TRANBUF:
 24227 00003D0C AC                      	LODSB
 24228 00003D0D AA                      	STOSB
 24229 00003D0E 3C0D                    	CMP	AL,c_CR ; 0Dh	; Check for carriage return
 24230 00003D10 7503                    	JNZ	short NORMCH
 24231 00003D12 C6040A                  	MOV	BYTE [SI],c_LF ; 0Ah
 24232                                  NORMCH:
 24233 00003D15 3C0A                    	CMP	AL,c_LF ; 0Ah
 24234 00003D17 E0F3                    	LOOPNZ	TRANBUF
 24235 00003D19 7507                    	JNZ	short ENDRDCON
 24236 00003D1B 31F6                    	XOR	SI,SI		; Cause a new buffer to be read
 24237 00003D1D E82DDF                  	call	OUTT		; Transmit linefeed
 24238 00003D20 0C01                    	OR	AL,1		; Clear zero flag--not end of file
 24239                                  ENDRDCON:
 24240                                  ;hkn; SS is DOSDATA
 24241 00003D22 16                      	push	ss
 24242 00003D23 1F                      	pop	ds
 24243 00003D24 E80CFE                  	CALL	SWAPBACK
 24244 00003D27 8936[2200]              	MOV	[CONTPOS],SI
 24245                                  
 24246                                  	; 16/12/2022
 24247                                  ;ENDRDDEV:
 24248                                  ;;hkn; SS is DOSDATA
 24249                                  ;	push	ss
 24250                                  ;	pop	ds
 24251                                  endrddev1:	; 04/05/2019
 24252 00003D2B 893E[B805]              	MOV	[NEXTADD],DI
 24253 00003D2F 7509                    	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
 24254 00003D31 C43E[9E05]              	LES	DI,[THISSFT]
 24255                                  	;and	byte [es:di+5],0BFh
 24256 00003D35 26806505BF              	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF 
 24257                                  				; Mark as no more data available
 24258                                  SETSFTC:
 24259                                  	; 31/07/2019
 24260                                  	;call	SETSFT
 24261                                  	;retn
 24262 00003D3A E9B604                  	jmp	SETSFT
 24263                                  
 24264                                  ; 16/12/2022
 24265                                  %if 0
 24266                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24267                                  ENDRDDEV:
 24268                                  ;hkn; SS is DOSDATA
 24269                                  	push	ss
 24270                                  	pop	ds
 24271                                  	MOV	[NEXTADD],DI
 24272                                  	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
 24273                                  	LES	DI,[THISSFT]
 24274                                  	;and	byte [es:di+5],0BFh
 24275                                  	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF 
 24276                                  				; Mark as no more data available
 24277                                  SETSFTC:
 24278                                  	;call	SETSFT
 24279                                  	;retn
 24280                                  	jmp	SETSFT	
 24281                                  %endif
 24282                                  
 24283                                  READCON:
 24284 00003D3D E8F9FD                  	CALL	SWAPCON
 24285 00003D40 8B36[2200]              	MOV	SI,[CONTPOS]
 24286 00003D44 09F6                    	OR	SI,SI
 24287 00003D46 75C4                    	JNZ	short TRANBUF
 24288 00003D48 803E[7B02]80            	CMP	BYTE [CONBUF],128 ; 80h
 24289 00003D4D 7406                    	JZ	short GETBUF
 24290 00003D4F C706[7B02]80FF          	MOV	WORD [CONBUF],0FF80H ; Set up 128-byte buffer with no template
 24291                                  GETBUF:
 24292 00003D55 51                      	PUSH	CX
 24293 00003D56 06                      	PUSH	ES
 24294 00003D57 57                      	PUSH	DI
 24295                                  
 24296                                  ;hkn; CONBUF is in DOSDATA
 24297 00003D58 BA[7B02]                	MOV	DX,CONBUF
 24298                                  
 24299 00003D5B E86ADC                  	call	_$STD_CON_STRING_INPUT	; Get input buffer
 24300 00003D5E 5F                      	POP	DI
 24301 00003D5F 07                      	POP	ES
 24302 00003D60 59                      	POP	CX
 24303                                  
 24304                                  ;hkn; CONBUF is in DOSDATA
 24305 00003D61 BE[7D02]                	MOV	SI,CONBUF+2
 24306                                  
 24307 00003D64 803C1A                  	CMP	BYTE [SI],1AH	; Check for Ctrl-Z in first character
 24308 00003D67 75A3                    	JNZ	short TRANBUF
 24309 00003D69 B01A                    	MOV	AL,1AH
 24310 00003D6B AA                      	STOSB
 24311 00003D6C 4F                      	DEC	DI
 24312 00003D6D B00A                    	MOV	AL,c_LF
 24313 00003D6F E8DBDE                  	call	OUTT		; Send linefeed
 24314 00003D72 31F6                    	XOR	SI,SI
 24315 00003D74 EBAC                    	JMP	short ENDRDCON ; 04/05/2019
 24316                                  
 24317                                  ; 24/07/2018 - Retro DOS v3.0
 24318                                  
 24319                                  ;Break	<DOS_WRITE -- MAIN WRITE ROUTINE AND DEVICE OUT ROUTINES>
 24320                                  ;---------------------------------------------------------------------------
 24321                                  ;
 24322                                  ; Procedure Name : DOS_WRITE
 24323                                  ;
 24324                                  ; Inputs:
 24325                                  ;	ThisSFT set to the SFT for the file being used
 24326                                  ;	[DMAADD] contains transfer address
 24327                                  ;	CX = No. of bytes to write
 24328                                  ; Function:
 24329                                  ;	Perform write operation
 24330                                  ;	NOTE: If CX = 0 on input, file is truncated or grown
 24331                                  ;		to current sf_position
 24332                                  ; Outputs:
 24333                                  ;    Carry clear
 24334                                  ;	SFT Position and cluster pointers updated
 24335                                  ;	CX = No. of bytes written
 24336                                  ;	ES:DI point to SFT
 24337                                  ;    Carry set
 24338                                  ;	AX is error code
 24339                                  ;	CX = 0
 24340                                  ;	ES:DI point to SFT
 24341                                  ; DS preserved, all other registers destroyed
 24342                                  ;---------------------------------------------------------------------------
 24343                                  
 24344                                  ;hkn; called from fcbio2.asm, handle.asm and dev.asm. DS is set up at this 
 24345                                  ;hkn; point to DOSDATA.
 24346                                  
 24347                                  ; 04/05/2019 - Retro DOS v4.0
 24348                                  ; DOSCODE:742Ch (MSDOS 6.21, MSDOS.SYS)
 24349                                  
 24350                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24351                                  ; DOSCODE:7418h (MSDOS 5.0, MSDOS.SYS)
 24352                                  
 24353                                  DOS_WRITE:
 24354 00003D76 C43E[9E05]              	LES	DI,[THISSFT]
 24355                                  	;mov	al,[ES:DI+2]
 24356 00003D7A 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 24357                                  	;and	al,0Fh
 24358 00003D7E 240F                    	AND	AL,access_mask
 24359                                  	;cmp	al,0
 24360 00003D80 3C00                    	CMP	AL,open_for_read
 24361 00003D82 7503                    	JNE	short Check_FCB_RO		 ;Is write or both
 24362                                  BadMode:
 24363 00003D84 E9DA03                  	jmp	SET_ACC_ERR
 24364                                  
 24365                                  ; NOTE: The following check for writting to a Read Only File is performed
 24366                                  ;	    ONLY on FCBs!!!!
 24367                                  ;	We ALLOW writes to Read Only files via handles to allow a CREATE
 24368                                  ;	    of a read only file which can then be written to.
 24369                                  ;	This is OK because we are NOT ALLOWED to OPEN a RO file via handles
 24370                                  ;	    for writting, or RE-CREATE an EXISTING RO file via handles. Thus,
 24371                                  ;	    CREATing a NEW RO file, or RE-CREATing an existing file which
 24372                                  ;	    is NOT RO to be RO, via handles are the only times we can write
 24373                                  ;	    to a read-only file.
 24374                                  
 24375                                  Check_FCB_RO:
 24376                                  	;;test	word [es:di+2],8000h
 24377                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 24378                                  	;JZ	short WRITE_NO_MODE	; Not an FCB
 24379                                  	
 24380                                  	;test	byte [es:di+3],80h
 24381 00003D87 26F6450380              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 24382 00003D8C 7407                    	JZ	short WRITE_NO_MODE	; Not an FCB
 24383                                  
 24384                                  	;test	byte [es:di+4],1
 24385 00003D8E 26F6450401              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_read_only
 24386 00003D93 75EF                    	JNZ	short BadMode 		; Can't write to Read_Only files via FCB
 24387                                  WRITE_NO_MODE:
 24388 00003D95 E8AA02                  	call	SETUP
 24389 00003D98 E8BFDA                  	call	IsSFTNet
 24390 00003D9B 7406                    	JZ	short LOCAL_WRITE
 24391                                  
 24392                                  ;IF NOT Installed
 24393                                  ;	transfer NET_WRITE
 24394                                  ;ELSE
 24395                                  	;mov	ax,1109h
 24396 00003D9D B80911                  	MOV	AX,(MultNET<<8)|9
 24397 00003DA0 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
 24398                                  			; ES:DI -> SFT
 24399                                  			; SFT DPB field -> DPB of drive containing file
 24400                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 24401                                  			; Return: CF set on error, CX = bytes written
 24402 00003DA2 C3                      	retn
 24403                                  ;ENDIF
 24404                                  
 24405                                  LOCAL_WRITE:
 24406                                  	;;test	word [es:di+5],80h
 24407                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 24408                                  	;jnz	short WRTDEV
 24409                                  
 24410                                  	;test	byte [es:di+5],80h
 24411 00003DA3 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; Check for named device I/O
 24412 00003DA8 756E                    	jnz	short WRTDEV
 24413                                  
 24414                                  	;mov	byte [EXTERR_LOCUS],2
 24415 00003DAA C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 24416 00003DAF E851DB                  	call	ECritDisk
 24417                                  
 24418 00003DB2 E8F404                  	call	DISKWRITE
 24419                                  
 24420                                  	; 04/05/2019 - Retro DOS v4.0
 24421                                  
 24422                                  	; MSDOS 6.0
 24423                                  ; Extended Open
 24424 00003DB5 7210                    	JC	short nocommit
 24425                                  	
 24426 00003DB7 C43E[9E05]              	LES	DI,[THISSFT]
 24427                                  	
 24428                                  	;;test	word [ES:DI+2],4000h
 24429                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],AUTO_COMMIT_WRITE
 24430                                  	;JZ	short nocommit
 24431                                  	
 24432                                  	;test	byte [ES:DI+3],40h
 24433 00003DBB 26F6450340              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(AUTO_COMMIT_WRITE>>8)
 24434 00003DC0 7405                    	JZ	short nocommit
 24435                                  	
 24436 00003DC2 51                      	PUSH	CX
 24437 00003DC3 E832FB                  	call	DOS_COMMIT
 24438 00003DC6 59                      	POP	CX
 24439                                  nocommit:
 24440                                  ; Extended Open
 24441                                  	;call	LCritDisk
 24442                                  	;retn
 24443                                  	; 18/12/2022
 24444 00003DC7 E966DB                  	jmp	LCritDisk
 24445                                  
 24446                                  DVWRTRAW:
 24447 00003DCA 31C0                    	XOR	AX,AX			; Media Byte, unit = 0
 24448 00003DCC E8FF12                  	call	SETWRITE
 24449 00003DCF 1E                      	PUSH	DS			; Save seg of transfer
 24450                                  
 24451                                  ;hkn; SS override
 24452 00003DD0 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 24453 00003DD5 E84A12                  	call	DEVIOCALL		; DS:SI -> DEVICE
 24454                                  
 24455 00003DD8 89FA                    	MOV	DX,DI			; Offset part of Xaddr saved in DX
 24456 00003DDA B487                    	MOV	AH,87H
 24457                                  
 24458                                  ;hkn; SS override
 24459 00003DDC 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 24460                                  
 24461                                  	; MSDOS 3.3
 24462                                  	;test	di,8000h
 24463                                  	;jz	short CWRTROK
 24464                                  
 24465                                  	; MSDOS 6.0
 24466 00003DE1 09FF                    	or	di,di
 24467 00003DE3 7920                    	jns	short CWRTROK
 24468                                  	
 24469                                  	; MSDOS 3.3 (& MSDOS 6.0)
 24470 00003DE5 E89F1E                  	call	CHARHARD
 24471                                  
 24472                                  	; 04/05/2019  - Retro DOS v4.0
 24473                                  
 24474                                  	; MSDOS 6.0
 24475 00003DE8 362B0E[6C03]            	sub	cx,[ss:CALLSCNT]	; update ptr & count to reflect	M065
 24476 00003DED 89D3                    	mov	bx,dx			; number of chars xferred	M065
 24477 00003DEF 36031E[6C03]            	add	bx,[ss:CALLSCNT]	;				M065
 24478 00003DF4 89DF                    	mov	di,bx			;				M065
 24479                                  	
 24480                                  	; MSDOS 3.3
 24481                                  	;MOV	BX,DX			; Recall transfer addr		M065
 24482                                  
 24483                                  	; MSDOS 3.3 (& MSDOS 6.0)
 24484 00003DF6 08C0                    	OR	AL,AL
 24485 00003DF8 740B                    	JZ	short CWRTROK 		; Ignore
 24486 00003DFA 3C03                    	CMP	AL,3
 24487 00003DFC 7403                    	JZ	short CWRFERR
 24488 00003DFE 1F                      	POP	DS			; Recover saved seg of transfer
 24489 00003DFF EBC9                    	JMP	short DVWRTRAW		; Try again
 24490                                  CWRFERR:
 24491 00003E01 58                      	POP	AX			; Chuck saved seg of transfer
 24492 00003E02 E9F4FD                  	JMP	CRDFERR 		; Will pop one more stack element
 24493                                  CWRTROK:
 24494 00003E05 58                      	POP	AX			; Chuck saved seg of transfer
 24495 00003E06 1F                      	POP	DS
 24496 00003E07 A1[6C03]                	MOV	AX,[CALLSCNT]		; Get actual number of bytes transferred
 24497                                  ENDWRDEV:
 24498 00003E0A C43E[9E05]              	LES	DI,[THISSFT]
 24499 00003E0E 89C1                    	MOV	CX,AX
 24500                                  	;call	ADDREC
 24501                                  	;retn
 24502                                  	; 16/12/2022
 24503                                  	; 10/06/2019
 24504 00003E10 E90104                  	jmp	ADDREC
 24505                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24506                                  	;call	ADDREC
 24507                                  	;retn
 24508                                  	
 24509                                  WRTNUL:
 24510 00003E13 89CA                    	MOV	DX,CX			; Entire transfer done
 24511                                  WRTCOOKJ:
 24512 00003E15 E98D00                  	JMP	WRTCOOKDONE
 24513                                  WRTDEV:
 24514                                  	;mov	byte [EXTERR_LOCUS],4
 24515 00003E18 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 24516                                  	;or	byte [es:di+5],40h
 24517 00003E1D 26804D0540              	OR	BYTE [ES:DI+SF_ENTRY.sf_flags],devid_device_EOF
 24518                                  					; Reset EOF for input
 24519                                  	;mov	bl,[es:di+5]
 24520 00003E22 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 24521 00003E26 31C0                    	XOR	AX,AX
 24522 00003E28 E3E0                    	JCXZ	ENDWRDEV		; problem of creating on a device.
 24523 00003E2A 1E                      	PUSH	DS
 24524 00003E2B 88D8                    	MOV	AL,BL
 24525 00003E2D C51E[2C03]              	LDS	BX,[DMAADD]		; Xaddr to DS:BX
 24526 00003E31 89DF                    	MOV	DI,BX			; Xaddr to DS:DI
 24527 00003E33 31D2                    	XOR	DX,DX			; Set starting point
 24528                                  	;test	al,20h
 24529 00003E35 A820                    	test	AL,devid_device_raw	; Raw?
 24530                                  	;JZ	short TEST_DEV_CON
 24531                                  	;JMP	DVWRTRAW
 24532                                  	; 16/12/2022
 24533 00003E37 7591                    	jnz	short DVWRTRAW
 24534                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24535                                  	;JZ	short TEST_DEV_CON
 24536                                  	;JMP	short DVWRTRAW
 24537                                  
 24538                                  TEST_DEV_CON:
 24539                                  	;test	al,2
 24540 00003E39 A802                    	test	AL,devid_device_con_out ; Console output device?
 24541 00003E3B 756E                    	jnz	short WRITECON
 24542                                  	;test	al,4
 24543 00003E3D A804                    	test	AL,devid_device_null
 24544 00003E3F 75D2                    	JNZ	short WRTNUL
 24545 00003E41 89D0                    	MOV	AX,DX
 24546 00003E43 803F1A                  	CMP	BYTE [BX],1Ah		; ^Z?
 24547 00003E46 74CD                    	JZ	short WRTCOOKJ		; Yes, transfer nothing
 24548 00003E48 51                      	PUSH	CX
 24549 00003E49 B90100                  	MOV	CX,1
 24550 00003E4C E87F12                  	call	SETWRITE
 24551 00003E4F 59                      	POP	CX
 24552                                  
 24553                                  ;hkn; SS override
 24554 00003E50 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 24555                                  ;
 24556                                  ;SR; Removed X25 support from here
 24557                                  ;
 24558                                  	;lds	si,[si+7]
 24559 00003E55 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 24560                                  DVWRTLP:
 24561 00003E58 E80D1C                  	call	DSKSTATCHK
 24562 00003E5B E8C711                  	call	DEVIOCALL2
 24563 00003E5E 57                      	PUSH	DI
 24564 00003E5F B487                    	MOV	AH,87H
 24565                                  
 24566                                  ;hkn; SS override
 24567 00003E61 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 24568                                  	
 24569                                  	; MSDOS 3.3
 24570                                  	;test	di,8000h
 24571                                  	;jz	short CWROK
 24572                                  
 24573                                  	; MSDOS 6.0
 24574 00003E66 09FF                    	or	di,di
 24575 00003E68 7916                    	jns	short CWROK
 24576                                  	
 24577                                  	; MSDOS 3.3 (& MSDOS 6.0)
 24578 00003E6A E81A1E                  	call	CHARHARD
 24579 00003E6D 5F                      	POP	DI
 24580                                  
 24581                                  ;hkn; SS override
 24582 00003E6E 36C706[6C03]0100        	MOV	word [SS:CALLSCNT],1
 24583 00003E75 3C01                    	CMP	AL,1
 24584 00003E77 74DF                    	JZ	short DVWRTLP 	; Retry
 24585 00003E79 08C0                    	OR	AL,AL
 24586 00003E7B 740C                    	JZ	short DVWRTIGN	; Ignore
 24587                                  	; 10/08/2018
 24588 00003E7D E979FD                  	JMP	CRDFERR 	; Fail, pops one stack element
 24589                                  CWROK:
 24590 00003E80 5F                      	POP	DI
 24591                                  
 24592                                  ;hkn; SS override
 24593 00003E81 36833E[6C03]00          	CMP	word [SS:CALLSCNT],0
 24594 00003E87 741C                    	JZ	short WRTCOOKDONE
 24595                                  DVWRTIGN:
 24596 00003E89 42                      	INC	DX
 24597                                  
 24598                                  ;hkn; SS override for CALLXAD
 24599 00003E8A 36FF06[6803]            	INC	WORD [SS:CALLXAD]
 24600 00003E8F 47                      	INC	DI
 24601 00003E90 1E                      	PUSH	DS
 24602 00003E91 368E1E[6A03]            	MOV	DS,[SS:CALLXAD+2]
 24603 00003E96 803D1A                  	CMP	BYTE [DI],1Ah	; ^Z?
 24604 00003E99 1F                      	POP	DS
 24605 00003E9A 7409                    	JZ	short WRTCOOKDONE
 24606                                  
 24607                                  ;hkn; SS override
 24608 00003E9C 36C706[5D03]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 24609 00003EA3 E2B3                    	LOOP	DVWRTLP
 24610                                  WRTCOOKDONE:
 24611 00003EA5 89D0                    	MOV	AX,DX
 24612 00003EA7 1F                      	POP	DS
 24613 00003EA8 E95FFF                  	JMP	ENDWRDEV ; 10/08/2018
 24614                                  
 24615                                  WRITECON:
 24616 00003EAB 1E                      	PUSH	DS
 24617                                  
 24618                                  ;hkn; SS is DOSDATA
 24619 00003EAC 16                      	push	ss
 24620 00003EAD 1F                      	pop	ds
 24621 00003EAE E888FC                  	CALL	SWAPCON
 24622 00003EB1 1F                      	POP	DS
 24623 00003EB2 89DE                    	MOV	SI,BX
 24624 00003EB4 51                      	PUSH	CX
 24625                                  WRCONLP:
 24626 00003EB5 AC                      	LODSB
 24627 00003EB6 3C1A                    	CMP	AL,1Ah		; ^Z?
 24628 00003EB8 7405                    	JZ	short CONEOF
 24629 00003EBA E890DD                  	call	OUTT
 24630 00003EBD E2F6                    	LOOP	WRCONLP
 24631                                  CONEOF:
 24632 00003EBF 58                      	POP	AX			; Count
 24633 00003EC0 29C8                    	SUB	AX,CX			; Amount actually written
 24634 00003EC2 1F                      	POP	DS
 24635 00003EC3 E86DFC                  	CALL	SWAPBACK
 24636 00003EC6 E941FF                  	JMP	ENDWRDEV
 24637                                  
 24638                                  ;---------------------------------------------------------------------------
 24639                                  ;
 24640                                  ; Procedure Name : get_io_sft
 24641                                  ;
 24642                                  ;   Convert JFN number in BX to sf_entry in DS:SI We get the normal SFT if
 24643                                  ;   CONSWAP is FALSE or if the handle desired is 2 or more. Otherwise, we
 24644                                  ;   retrieve the sft from ConSFT which is set by SwapCon.
 24645                                  ;
 24646                                  ;---------------------------------------------------------------------------
 24647                                  
 24648                                  ; 04/05/2019 - Retro DOS v4.0
 24649                                  ; DOSCODE:7583h (MSDOS 6.21, MSDOS.SYS)
 24650                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24651                                  ; DOSCODE:756Fh (MSDOS 5.0, MSDOS.SYS)
 24652                                  
 24653                                  GET_IO_SFT:
 24654                                  	;test	byte [SS:CONSWAP],0FFh
 24655 00003EC9 36803E[5703]00          	cmp	byte [SS:CONSWAP],0			;smr;SS Override
 24656 00003ECF 7512                    	JNZ	short GetRedir
 24657                                  GetNormal:
 24658 00003ED1 16                      	push	ss
 24659 00003ED2 1F                      	pop	ds
 24660 00003ED3 06                      	PUSH	ES
 24661 00003ED4 57                      	PUSH	DI
 24662 00003ED5 E88931                  	call	SFFromHandle
 24663 00003ED8 7206                    	JC	short RET44P
 24664 00003EDA 8CC6                    	MOV	SI,ES
 24665 00003EDC 8EDE                    	MOV	DS,SI
 24666 00003EDE 89FE                    	MOV	SI,DI
 24667                                  RET44P:
 24668 00003EE0 5F                      	POP	DI
 24669 00003EE1 07                      	POP	ES
 24670 00003EE2 C3                      	retn
 24671                                  GetRedir:
 24672 00003EE3 83FB01                  	CMP	BX,1
 24673 00003EE6 77E9                    	JA	short GetNormal
 24674 00003EE8 36C536[E605]            	LDS	SI,[SS:CONSFT]
 24675 00003EED F8                      	CLC
 24676                                  get_io_sft_retn:
 24677 00003EEE C3                      	retn
 24678                                  
 24679                                  ;Break	<DIRREAD -- READ A DIRECTORY SECTOR>
 24680                                  ;---------------------------------------------------------------------------
 24681                                  ;
 24682                                  ; Procedure Name : DIRREAD
 24683                                  ;
 24684                                  ; Inputs:
 24685                                  ;	AX = Directory block number (relative to first block of directory)
 24686                                  ;	ES:BP = Base of drive parameters
 24687                                  ;	[DIRSEC] = First sector of first cluster of directory
 24688                                  ;	[CLUSNUM] = Next cluster
 24689                                  ;	[CLUSFAC] = Sectors/Cluster
 24690                                  ; Function:
 24691                                  ;	Read the directory block into [CURBUF].
 24692                                  ; Outputs:
 24693                                  ;	[NXTCLUSNUM] = Next cluster (after the one skipped to)
 24694                                  ;	[SECCLUSPOS] Set
 24695                                  ;	ES:BP unchanged
 24696                                  ;	[CURBUF] Points to Buffer with dir sector
 24697                                  ;	Carry set if error (user said FAIL to I 24)
 24698                                  ; DS preserved, all other registers destroyed.
 24699                                  ;---------------------------------------------------------------------------
 24700                                  
 24701                                  ;hkn; called from dir.asm. DS already set up to DOSDATA.
 24702                                  
 24703                                  DIRREAD:
 24704                                  
 24705                                  ; Note that ClusFac is the sectors per cluster. This is NOT necessarily
 24706                                  ; the same as what is in the DPB! In the case of the root directory, we have
 24707                                  ; ClusFac = # sectors in the root directory. The root directory is detected
 24708                                  ; by DIRStart = 0.
 24709                                  
 24710 00003EEF 31D2                    	XOR	DX,DX
 24711                                  	;CMP	word [DIRSTART],0
 24712                                  	; 21/09/2023
 24713 00003EF1 3916[C205]              	cmp	[DIRSTART],dx ; 0
 24714 00003EF5 7503                    	jnz	short SubDir
 24715 00003EF7 92                      	XCHG	AX,DX
 24716 00003EF8 EB0C                    	JMP	short DoRead
 24717                                  
 24718                                  ; Convert the sector number in AX into cluster and sector-within-cluster pair
 24719                                  
 24720                                  SubDir:
 24721 00003EFA 88C2                    	MOV	DL,AL
 24722                                  	;and	dl,[es:bp+4]
 24723 00003EFC 26225604                	AND	DL,[ES:BP+DPB.CLUSTER_MASK]
 24724                                  
 24725                                  ;	(DX) = sector-in-cluster
 24726                                  
 24727                                  	;mov	cl,[es:bp+5]
 24728 00003F00 268A4E05                	MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 24729 00003F04 D3E8                    	SHR	AX,CL
 24730                                  
 24731                                  ;	(DX) = position in cluster
 24732                                  ;	(AX) = number of clusters to skip
 24733                                  
 24734                                  DoRead:
 24735 00003F06 8816[7305]              	MOV	[SECCLUSPOS],DL
 24736 00003F0A 89C1                    	MOV	CX,AX
 24737 00003F0C 88D4                    	MOV	AH,DL
 24738                                  
 24739                                  ;	(CX) = number of clusters to skip.
 24740                                  ;	(AH) = remainder
 24741                                  
 24742                                  	; 04/05/2019 - Retro DOS v4.0
 24743                                  	 
 24744                                  	; MSDOS 6.0
 24745                                  	;MOV	DX,[DIRSEC+2]	     	  ;>32mb
 24746                                  	;MOV	[HIGH_SECTOR],DX	  ;>32mb
 24747                                  	;MOV	DX,[DIRSEC]
 24748                                  	;ADD	DL,AH
 24749                                  	;ADC	DH,0
 24750                                  	;ADC	word [HIGH_SECTOR],0	  ;>32mb
 24751                                  	; 21/09/2023
 24752 00003F0E 31DB                    	xor	bx,bx ; 0
 24753 00003F10 8B16[BE05]              	mov	dx,[DIRSEC]
 24754 00003F14 00E2                    	add	dl,ah
 24755 00003F16 10DE                    	adc	dh,bl ; 0
 24756 00003F18 131E[C005]              	adc	bx,[DIRSEC+2]
 24757 00003F1C 891E[0706]              	mov	[HIGH_SECTOR],bx
 24758                                  
 24759 00003F20 8B1E[BC05]              	MOV	BX,[CLUSNUM]
 24760 00003F24 891E[DC05]              	MOV	[NXTCLUSNUM],BX
 24761 00003F28 E319                    	JCXZ	FIRSTCLUSTER
 24762                                  SKPCLLP:
 24763 00003F2A E8C51F                  	call	UNPACK
 24764 00003F2D 72BF                    	jc	short get_io_sft_retn
 24765 00003F2F 87DF                    	XCHG	BX,DI
 24766 00003F31 E8A71F                  	call	IsEOF			; test for eof based on fat size
 24767 00003F34 7302                    	JAE	short HAVESKIPPED
 24768 00003F36 E2F2                    	LOOP	SKPCLLP
 24769                                  HAVESKIPPED:
 24770 00003F38 891E[DC05]              	MOV	[NXTCLUSNUM],BX
 24771 00003F3C 89FA                    	MOV	DX,DI
 24772 00003F3E 88E3                    	MOV	BL,AH
 24773 00003F40 E85818                  	call	FIGREC
 24774                                  
 24775                                  	;entry	FIRSTCLUSTER
 24776                                  
 24777                                  FIRSTCLUSTER:
 24778                                  	; 22/09/2023
 24779                                  	;;mov	byte [ALLOWED],18h
 24780                                  	;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 24781                                  	;XOR	AL,AL ; *	; Indicate pre-read
 24782                                  	;call	GETBUFFR
 24783 00003F43 E8E523                  	call	GETBUFFER ; *	; pre-read
 24784 00003F46 72A6                    	jc	short get_io_sft_retn
 24785                                  
 24786                                  	;entry	SET_BUF_AS_DIR
 24787                                  
 24788                                  SET_BUF_AS_DIR:
 24789                                  
 24790                                  ;	Set the type of CURBUF to be a directory sector.
 24791                                  ;	Only flags are modified.
 24792                                  
 24793 00003F48 1E                      	PUSH	DS
 24794 00003F49 56                      	PUSH	SI
 24795 00003F4A C536[E205]              	LDS	SI,[CURBUF]
 24796                                  	;or	byte [si+5],4
 24797 00003F4E 804C0504                	OR	byte [SI+BUFFINFO.buf_flags],buf_isDIR	; Clears carry
 24798 00003F52 5E                      	POP	SI
 24799 00003F53 1F                      	POP	DS
 24800                                  dirread_retn:
 24801 00003F54 C3                      	retn
 24802                                  
 24803                                  ;Break	<FATSECRD -- READ A FAT SECTOR>
 24804                                  ;----------------------------------------------------------------------------
 24805                                  ;
 24806                                  ; Procedure Name : FATSECRD
 24807                                  ; Inputs:
 24808                                  ;	Same as DREAD
 24809                                  ;	DS:BX = Transfer address
 24810                                  ;	CX = Number of sectors
 24811                                  ;	DX = Absolute record number
 24812                                  ;	ES:BP = Base of drive parameters
 24813                                  ; Function:
 24814                                  ;	Calls BIOS to perform FAT read.
 24815                                  ; Outputs:
 24816                                  ;	Same as DREAD
 24817                                  ;---------------------------------------------------------------------------
 24818                                  
 24819                                  	; 04/05/2019 - Retro DOS v4.0
 24820                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)	
 24821                                  
 24822                                  FATSECRD:
 24823                                  ;hkn; SS override
 24824                                  	;mov	byte [ss:ALLOWED],18h
 24825 00003F55 36C606[4B03]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 24826 00003F5B 89CF                    	MOV	DI,CX
 24827                                  	;mov	cl,[es:bp+8]
 24828 00003F5D 268A4E08                	MOV	CL,[ES:BP+DPB.FAT_COUNT]
 24829                                  	; MSDOS 3.3
 24830                                  	;;mov	al,[es:bp+0Fh]
 24831                                  	;MOV	AL,[ES:BP+DPB.FAT_SIZE] 				
 24832                                  	;XOR	AH,AH
 24833                                  	; MSDOS 6.0
 24834                                  	;mov	ax,[es:bp+0Fh]
 24835 00003F61 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE] ;>32mb
 24836 00003F65 30ED                    	XOR	CH,CH	
 24837 00003F67 52                      	PUSH	DX
 24838                                  NXTFAT:
 24839                                  	; MSDOS 6.0
 24840                                  ;hkn; SS override
 24841 00003F68 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0	;>32mb FAT sectors cannot exceed
 24842 00003F6F 51                      	PUSH	CX			;32mb
 24843 00003F70 50                      	PUSH	AX
 24844 00003F71 89F9                    	MOV	CX,DI
 24845 00003F73 E85B00                  	call	DSKREAD
 24846 00003F76 58                      	POP	AX
 24847 00003F77 59                      	POP	CX
 24848 00003F78 7420                    	JZ	short RET41P		; Carry clear
 24849 00003F7A 01C2                    	ADD	DX,AX
 24850 00003F7C E2EA                    	LOOP	NXTFAT
 24851 00003F7E 5A                      	POP	DX
 24852 00003F7F 89F9                    	MOV	CX,DI
 24853                                  
 24854                                  ; NOTE FALL THROUGH
 24855                                  
 24856                                  ;Break	<DREAD -- DO A DISK READ>
 24857                                  ;---------------------------------------------------------------------------
 24858                                  ;
 24859                                  ; Procedure Name : DREAD
 24860                                  ;
 24861                                  ; Inputs:
 24862                                  ;	DS:BX = Transfer address
 24863                                  ;	CX = Number of sectors
 24864                                  ;	DX = Absolute record number	      (LOW)
 24865                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 24866                                  ;	ES:BP = Base of drive parameters
 24867                                  ;	[ALLOWED] must be set in case call to HARDERR needed
 24868                                  ; Function:
 24869                                  ;	Calls BIOS to perform disk read. If BIOS reports
 24870                                  ;	errors, will call HARDERRRW for further action.
 24871                                  ; Outputs:
 24872                                  ;	Carry set if error (currently user FAILED to INT 24)
 24873                                  ; DS,ES:BP preserved. All other registers destroyed.
 24874                                  ;---------------------------------------------------------------------------
 24875                                  
 24876                                  	;entry	DREAD
 24877                                  DREAD:
 24878 00003F81 E84D00                  	call	DSKREAD
 24879 00003F84 74CE                    	jz	short dirread_retn	; Carry clear
 24880                                  ;hkn; SS override
 24881 00003F86 36C606[7505]00          	MOV	BYTE [SS:READOP],0
 24882 00003F8C E89A00                  	call	HARDERRRW
 24883 00003F8F 3C01                    	CMP	AL,1			; Check for retry
 24884 00003F91 74EE                    	JZ	short DREAD
 24885 00003F93 3C03                    	CMP	AL,3			; Check for FAIL
 24886 00003F95 F8                      	CLC
 24887 00003F96 7501                    	JNZ	short NO_CAR		; Ignore
 24888 00003F98 F9                      	STC
 24889                                  NO_CAR:
 24890 00003F99 C3                      	retn
 24891                                  RET41P: 
 24892 00003F9A 5A                      	POP	DX
 24893 00003F9B C3                      	retn
 24894                                  
 24895                                  ; 24/07/2018 - Retro DOS v3.0
 24896                                  
 24897                                  ;Break	<CHECK_WRITE_LOCK>
 24898                                  ;---------------------------------------------------------------------------
 24899                                  ;
 24900                                  ; Procedure Name : CHECK_WRITE_LOCK
 24901                                  ;
 24902                                  ; Inputs:
 24903                                  ;	output of SETUP
 24904                                  ;	ES:DI -> SFT
 24905                                  ; Function:
 24906                                  ;	check write lock
 24907                                  ; Outputs:
 24908                                  ;	Carry set if error
 24909                                  ;	Carry clear if ok
 24910                                  ;
 24911                                  ;----------------------------------------------------------------------------
 24912                                  
 24913                                  	; 04/05/2019 - Retro DOS v4.0
 24914                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24915                                  
 24916                                  CHECK_WRITE_LOCK:
 24917                                  	; MSDOS 6.0
 24918                                  	;test	byte [es:di+4],8
 24919 00003F9C 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 24920                                  	;JZ	short write_cont			     ;no
 24921                                  	;;call	SET_ACC_ERR_DS
 24922                                  	;;retn
 24923                                  	;;jnz	SET_ACC_ERR_DS
 24924                                  	; 19/08/2018
 24925                                  	;jz	short write_cont
 24926                                  	;jmp	SET_ACC_ERR_DS
 24927                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24928 00003FA1 7403                    	JZ	short write_cont
 24929                                  	;call	SET_ACC_ERR_DS
 24930                                  	;retn
 24931                                  	; 16/12/2022
 24932 00003FA3 E9B901                  	jmp	SET_ACC_ERR_DS
 24933                                  
 24934                                  write_cont:				;
 24935 00003FA6 51                      	PUSH	CX			;save reg
 24936 00003FA7 09C9                    	OR	CX,CX			;
 24937 00003FA9 7501                    	JNZ	short Not_Truncate	;
 24938 00003FAB 49                      	dec	cx			;(cx) = -1; check for lock on whole file
 24939                                  Not_Truncate:				;
 24940 00003FAC B080                    	MOV	AL,80H			;check write access
 24941 00003FAE E8393D                  	call	LOCK_CHECK		;check lock
 24942 00003FB1 59                      	POP	CX			;restore reg
 24943 00003FB2 7305                    	JNC	short WRITE_OK		;lock ok
 24944 00003FB4 E85F01                  	call	WRITE_LOCK_VIOLATION	;issue I24
 24945 00003FB7 73ED                    	JNC	short write_cont	;retry
 24946                                  WRITE_OK:				;
 24947 00003FB9 C3                      	retn				;
 24948                                  
 24949                                  ;Break	<CHECK_READ_LOCK>
 24950                                  ;---------------------------------------------------------------------------
 24951                                  ;
 24952                                  ; Procedure Name : CHECK_READ_LOC
 24953                                  ;
 24954                                  ; Inputs:
 24955                                  ;	ES:DI -> SFT
 24956                                  ;	output of SETUP
 24957                                  ; Function:
 24958                                  ;	check read lock
 24959                                  ; Outputs:
 24960                                  ;	Carry set if error
 24961                                  ;	Carry clear if ok
 24962                                  ;----------------------------------------------------------------------------
 24963                                  
 24964                                  CHECK_READ_LOCK:
 24965                                  	; MSDOS 6.0
 24966                                  	;test	byte [es:di+4],8
 24967 00003FBA 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 24968                                  	;JZ	short do_retry			   	     ; no
 24969                                  	;;call	SET_ACC_ERR
 24970                                  	;;retn
 24971                                  	;;jnz	SET_ACC_ERR
 24972                                  	; 16/12/2022
 24973                                  	; 28/07/2019
 24974 00003FBF 7403                    	jz	short do_retry
 24975 00003FC1 E99D01                  	jmp	SET_ACC_ERR
 24976                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24977                                  	;JZ	short do_retry
 24978                                  	;call	SET_ACC_ERR
 24979                                  	;retn
 24980                                  do_retry:				;
 24981 00003FC4 30C0                    	xor	al,al			;check read access
 24982 00003FC6 E8213D                  	call	LOCK_CHECK		;check lock
 24983 00003FC9 7305                    	JNC	short READLOCK_OK 	;lock ok
 24984 00003FCB E82801                  	call	READ_LOCK_VIOLATION	;issue I24
 24985 00003FCE 73F4                    	JNC	short do_retry		;retry
 24986                                  READLOCK_OK:				;
 24987 00003FD0 C3                      	retn				;
 24988                                  
 24989                                  ;============================================================================
 24990                                  ; DISK2.ASM, MSDOS 6.0, 1991
 24991                                  ;============================================================================
 24992                                  ; 24/07/2018 - Retro DOS v3.0
 24993                                  ; 04/05/2019 - Retro DOS v4.0
 24994                                  
 24995                                  ;	TITLE	DISK2 - Disk utility routines
 24996                                  ;	NAME	Disk2
 24997                                  
 24998                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 24999                                  ;
 25000                                  ;	DskRead
 25001                                  ;	DWRITE
 25002                                  ;	DSKWRITE
 25003                                  ;	HarderrRW
 25004                                  ;	SETUP
 25005                                  ;	BREAKDOWN
 25006                                  ;	READ_LOCK_VIOLATION
 25007                                  ;	WRITE_LOCK_VIOLATION
 25008                                  ;	DISKREAD
 25009                                  ;	SET_ACC_ERR_DS
 25010                                  ;	SET_ACC_ERR
 25011                                  ;	SETSFT
 25012                                  ;	SETCLUS
 25013                                  ;	AddRec
 25014                                  ;
 25015                                  ;	Revision history:
 25016                                  ;
 25017                                  ;		AN000 version 4.00 Jan. 1988
 25018                                  ;		M039 DB 10/17/90 - Disk read/write optimization
 25019                                  
 25020                                  ; 04/05/2019 - Retro DOS v4.0
 25021                                  ; DOSCODE:7699h (MSDOS 6.21, MSDOS.SYS)
 25022                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25023                                  ; DOSCODE:7685h (MSDOS 5.0, MSDOS.SYS)
 25024                                  
 25025                                  ;Break	<DSKREAD -- PHYSICAL DISK READ>
 25026                                  ;---------------------------------------------------------------------------
 25027                                  ;
 25028                                  ; Procedure Name : DSKREAD
 25029                                  ;
 25030                                  ; Inputs:
 25031                                  ;	DS:BX = Transfer addr
 25032                                  ;	CX = Number of sectors
 25033                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 25034                                  ;	DX = Absolute record number	       (LOW)
 25035                                  ;	ES:BP = Base of drive parameters
 25036                                  ; Function:
 25037                                  ;	Call BIOS to perform disk read
 25038                                  ; Outputs:
 25039                                  ;	DI = CX on entry
 25040                                  ;	CX = Number of sectors unsuccessfully transfered
 25041                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 25042                                  ;	Zero set if OK (from BIOS) (carry clear)
 25043                                  ;	Zero clear if error (carry clear)
 25044                                  ; SI Destroyed, others preserved
 25045                                  ;---------------------------------------------------------------------------
 25046                                  
 25047                                  DSKREAD:
 25048 00003FD1 51                      	PUSH	CX
 25049                                  	;mov	ah,[es:bp+17h] ; 04/05/2019
 25050 00003FD2 268A6617                	MOV	AH,[ES:BP+DPB.MEDIA]
 25051                                  	;mov	al,[es:bp+1]
 25052 00003FD6 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 25053 00003FDA 53                      	PUSH	BX
 25054 00003FDB 06                      	PUSH	ES
 25055 00003FDC E8BC10                  	call	SETREAD
 25056 00003FDF EB27                    	JMP	short DODSKOP
 25057                                  
 25058                                  ;Break	<DWRITE -- SEE ABOUT WRITING>
 25059                                  ;--------------------------------------------------------------------------
 25060                                  ;
 25061                                  ; Procedure Name : DWRITE
 25062                                  ;
 25063                                  ; Inputs:
 25064                                  ;	DS:BX = Transfer address
 25065                                  ;	CX = Number of sectors
 25066                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 25067                                  ;	DX = Absolute record number	       (LOW)
 25068                                  ;	ES:BP = Base of drive parameters
 25069                                  ;	[ALLOWED] must be set in case HARDERR called
 25070                                  ; Function:
 25071                                  ;	Calls BIOS to perform disk write. If BIOS reports
 25072                                  ;	errors, will call HARDERRRW for further action.
 25073                                  ; Output:
 25074                                  ;	Carry set if error (currently, user FAILed to I 24)
 25075                                  ; BP preserved. All other registers destroyed.
 25076                                  ;----------------------------------------------------------------------------
 25077                                  
 25078                                  	;entry	DWRITE
 25079                                  DWRITE:
 25080 00003FE1 E81600                  	CALL	DSKWRITE
 25081 00003FE4 7413                    	jz	short dw_ret_label	; Carry clear (retz)
 25082                                  
 25083                                  ;hkn; SS override
 25084 00003FE6 36C606[7505]01          	MOV	BYTE [SS:READOP],1
 25085 00003FEC E83A00                  	call	HARDERRRW
 25086 00003FEF 3C01                    	CMP	AL,1		; Check for retry
 25087 00003FF1 74EE                    	JZ	short DWRITE
 25088 00003FF3 3C03                    	CMP	AL,3		; Check for FAIL
 25089 00003FF5 F8                      	CLC
 25090 00003FF6 7501                    	JNZ	short NO_CAR2 	; Ignore
 25091 00003FF8 F9                      	STC
 25092                                  NO_CAR2:
 25093                                  dw_ret_label:
 25094 00003FF9 C3                      	retn
 25095                                  
 25096                                  ;Break	<DSKWRITE -- PHYSICAL DISK WRITE>
 25097                                  ;---------------------------------------------------------------------------
 25098                                  ;
 25099                                  ; Procedure Name : DSKWRITE
 25100                                  ;
 25101                                  ; Inputs:
 25102                                  ;	DS:BX = Transfer addr
 25103                                  ;	CX = Number of sectors
 25104                                  ;	DX = Absolute record number	       (LOW)
 25105                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 25106                                  ;	ES:BP = Base of drive parameters
 25107                                  ; Function:
 25108                                  ;	Call BIOS to perform disk read
 25109                                  ; Outputs:
 25110                                  ;	DI = CX on entry
 25111                                  ;	CX = Number of sectors unsuccessfully transfered
 25112                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 25113                                  ;	Zero set if OK (from BIOS) (carry clear)
 25114                                  ;	Zero clear if error (carry clear)
 25115                                  ; SI Destroyed, others preserved
 25116                                  ;
 25117                                  ;----------------------------------------------------------------------------
 25118                                  
 25119                                  	;entry	DSKWRITE
 25120                                  DSKWRITE:
 25121 00003FFA 51                      	PUSH	CX
 25122                                  	;mov	ah,[es:bp+17h] ; 04/05/2019
 25123 00003FFB 268A6617                	MOV	AH,[ES:BP+DPB.MEDIA]
 25124                                  	;mov	al,[es:bp+1]
 25125 00003FFF 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 25126 00004003 53                      	PUSH	BX
 25127 00004004 06                      	PUSH	ES
 25128 00004005 E8C610                  	call	SETWRITE
 25129                                  DODSKOP:
 25130 00004008 8CD9                    	MOV	CX,DS		; Save DS
 25131 0000400A 1F                      	POP	DS		; DS:BP points to DPB
 25132 0000400B 1E                      	PUSH	DS
 25133                                  
 25134                                  	;lds	si,[ds:bp+13h] ; 04/05/2019
 25135 0000400C 3EC57613                	LDS	SI,[ds:BP+DPB.DRIVER_ADDR] ; 07/09/2018
 25136 00004010 E81210                  	call	DEVIOCALL2
 25137                                  
 25138 00004013 8ED9                    	MOV	DS,CX		; Restore DS
 25139 00004015 07                      	POP	ES		; Restore ES
 25140 00004016 5B                      	POP	BX
 25141                                  
 25142                                  ;hkn; SS override
 25143 00004017 368B0E[6C03]            	MOV	CX,[SS:CALLSCNT] ; Number of sectors transferred
 25144 0000401C 5F                      	POP	DI
 25145 0000401D 29F9                    	SUB	CX,DI
 25146 0000401F F7D9                    	NEG	CX		; Number of sectors not transferred
 25147                                  
 25148                                  ;hkn; SS override
 25149 00004021 36A1[5D03]              	MOV	AX,[SS:DEVCALL_REQSTAT]
 25150                                  	;test	ax,8000h
 25151                                  	; 17/12/2022
 25152                                  	;test	ah,80h
 25153 00004025 F6C480                  	test	ah,(STERR>>8)
 25154                                  	;test	AX,STERR
 25155 00004028 C3                      	retn
 25156                                  
 25157                                  ;Break	<HardErrRW - map extended errors and call harderr>
 25158                                  ;---------------------------------------------------------------------------
 25159                                  ;
 25160                                  ; Procedure Name : HardErrRW
 25161                                  ;
 25162                                  ; Inputs:
 25163                                  ;	AX is error code from read or write
 25164                                  ;	Other registers set as per HARDERR
 25165                                  ; Function:
 25166                                  ;	Checks the error code for special extended
 25167                                  ;	errors and maps them if needed. Then invokes
 25168                                  ;	Harderr
 25169                                  ; Outputs:
 25170                                  ;	Of HARDERR
 25171                                  ; AX may be modified prior to call to HARDERR.
 25172                                  ; No other registers altered.
 25173                                  ;
 25174                                  ;---------------------------------------------------------------------------
 25175                                  
 25176                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25177                                  HARDERRRW:
 25178                                  	;cmp	al,0Fh
 25179 00004029 3C0F                    	CMP	AL,error_I24_wrong_disk
 25180 0000402B 7512                    	JNZ	short DO_ERR			; Nothing to do
 25181                                  
 25182                                  	; MSDOS 3.3
 25183                                  	;push	ds
 25184                                  	;push	si
 25185                                  	;lds	si,[ss:CALLVIDRW]
 25186                                  	;mov	[ss:EXTERRPT+2], ds
 25187                                  	;mov	[ss:EXTERRPT], si
 25188                                  	;pop	si
 25189                                  	;pop	ds
 25190                                  
 25191                                  	; MSDOS 6.0
 25192 0000402D 50                      	push	ax
 25193 0000402E 36A1[7003]              	mov	ax,[SS:CALLVIDRW]		; get ptr lo  ;smr;SS Override
 25194 00004032 36A3[2803]              	mov	[ss:EXTERRPT],ax		; set ext err ptr lo
 25195 00004036 36A1[7203]              	mov	ax,[SS:CALLVIDRW+2]		; get ptr hi from dev
 25196 0000403A 36A3[2A03]              	mov	[ss:EXTERRPT+2],ax		; set ext err ptr hi
 25197 0000403E 58                      	pop	ax
 25198                                  DO_ERR:
 25199                                  	;;call	HARDERR
 25200                                  	;;retn
 25201                                  	; 16/12/2022
 25202                                  	; 10/06/2019
 25203 0000403F E9761C                  	jmp	HARDERR	
 25204                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25205                                  	;call	HARDERR
 25206                                  	;retn
 25207                                  
 25208                                  ; 24/07/2018 - Retro DOS v3.0
 25209                                  
 25210                                  ;Break	<SETUP -- SETUP A DISK READ OR WRITE FROM USER>
 25211                                  ;----------------------------------------------------------------------------
 25212                                  ;
 25213                                  ; Procedure Name : SETUP
 25214                                  ;
 25215                                  ; Inputs:
 25216                                  ;	ES:DI point to SFT (value also in THISSFT)
 25217                                  ;	DMAAdd contains transfer address
 25218                                  ;	CX = Byte count
 25219                                  ;	DS = DOSDATA
 25220                                  ;   WARNING Stack must be clean, two ret addrs on stack, 1st of caller,
 25221                                  ;		2nd of caller of caller.
 25222                                  ; Outputs:
 25223                                  ;	    CX = byte count
 25224                                  ;	    [THISDPB] = Base of drive parameters if file
 25225                                  ;		      = Pointer to device header if device or NET
 25226                                  ;	    ES:DI Points to SFT
 25227                                  ;	    [NEXTADD] = Displacement of disk transfer within segment
 25228                                  ;	    [TRANS] = 0 (No transfers yet)
 25229                                  ;	    BytPos = Byte position in file
 25230                                  ;
 25231                                  ;	The following fields are relevant to local files (not devices) only:
 25232                                  ;
 25233                                  ;	    SecPos = Position of first sector (local files only)
 25234                                  ;	    [BYTSECPOS] = Byte position in first sector (local files only)
 25235                                  ;	    [CLUSNUM] = First cluster (local files only)
 25236                                  ;	    [SECCLUSPOS] = Sector within first cluster (local files only)
 25237                                  ;	    [THISDRV] = Physical unit number (local files only)
 25238                                  ;
 25239                                  ;      RETURNS ONE LEVEL UP WITH:
 25240                                  ;	   CX = 0
 25241                                  ;	   CARRY = Clear
 25242                                  ;	IF AN ERROR IS DETECTED
 25243                                  ; All other registers destroyed
 25244                                  ;----------------------------------------------------------------------------
 25245                                  
 25246                                  ;hkn; called from disk.asm. DS has been set up to DOSDATA.
 25247                                  
 25248                                  ; DOSCODE:770Bh (MSDOS 6.21, MSDOS.SYS)
 25249                                  
 25250                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25251                                  ; DOSCODE:76F7h (MSDOS 5.0, MSDOS.SYS)
 25252                                  
 25253                                  SETUP:
 25254                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 411Bh
 25255                                  
 25256                                  	;lds 	si,[es:di+7]
 25257 00004042 26C57507                	LDS	SI,[ES:DI+SF_ENTRY.sf_devptr]
 25258                                  
 25259                                  ;hkn; SS override
 25260 00004046 368C1E[8C05]            	MOV	[SS:THISDPB+2],DS
 25261                                  
 25262                                  ;hkn; SS is DOSDATA
 25263 0000404B 16                      	push	ss
 25264 0000404C 1F                      	pop	ds
 25265                                  
 25266 0000404D 8936[8A05]              	MOV	[THISDPB],SI
 25267                                  
 25268 00004051 8B1E[2C03]              	MOV	BX,[DMAADD]
 25269 00004055 891E[B805]              	MOV	[NEXTADD],BX		;Set NEXTADD to start of Xaddr
 25270 00004059 C606[7405]00            	MOV	BYTE [TRANS],0		;No transferes
 25271                                  	;mov	ax,[es:di+15h]
 25272 0000405E 268B4515                	MOV	AX,[ES:DI+SF_ENTRY.sf_position]
 25273                                  	;mov	dx,[es:di+17h]
 25274 00004062 268B5517                	MOV	DX,[ES:DI+SF_ENTRY.sf_position+2]
 25275 00004066 8916[D005]              	MOV	[BYTPOS+2],DX		;Set it
 25276 0000406A A3[CE05]                	MOV	[BYTPOS],AX
 25277                                  	;test	word [es:di+5],8080h
 25278 0000406D 26F745058080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet+devid_device
 25279 00004073 753C                    	JNZ	short NOSETSTUFF	;Following not done on devs or NET
 25280 00004075 06                      	PUSH	ES
 25281 00004076 C42E[8A05]              	LES	BP,[THISDPB]		;Point at the DPB
 25282                                  
 25283                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25284                                  	;;mov	bl,[es:bp+0]
 25285                                  	;MOV	BL,[ES:BP+DPB.DRIVE]
 25286                                  	; 05/12/2022
 25287 0000407A 268A5E00                	mov	bl,[es:bp]
 25288                                  	
 25289 0000407E 881E[7605]              	MOV	[THISDRV],BL		;Set THISDRV
 25290                                  	;mov	bx,[es:bp+2]
 25291 00004082 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 25292                                  
 25293                                  	;; MSDOS 3.3
 25294                                  	;cmp	dx,bx
 25295                                  	;jnb	short EOFERR
 25296                                  	;div	bx
 25297                                  	;mov	[SECPOS],ax
 25298                                  	;mov	[BYTSECPOS],dx
 25299                                  	;mov	dx,ax
 25300                                  	;;and	al,[es:bp+4]
 25301                                  	;AND	AL,[ES:BP+DPB.CLUSTER_MASK]
 25302                                  	;mov	[SECCLUSPOS],al
 25303                                  	;mov	ax,cx
 25304                                  	;;mov	cl,[es:bp+5]
 25305                                  	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 25306                                  	;shr	dx,cl
 25307                                  	;mov	[CLUSNUM],dx
 25308                                  	;pop	es
 25309                                  	;mov	cx,ax
 25310                                  
 25311                                  	; 04/05/2019 - Retro DOS v4.0
 25312                                  
 25313                                  	; MSDOS 6.0
 25314                                  ;M039: Optimized this section.
 25315 00004086 51                              PUSH    CX			;SHR32 and DIV32 use CX.
 25316 00004087 E83405                  	call	DIV32			;DX:AX/BX = CX:AX + DX (rem)
 25317 0000408A 8916[CC05]              	MOV	[BYTSECPOS],DX
 25318 0000408E A3[C405]                	MOV	[SECPOS],AX
 25319 00004091 890E[C605]              	MOV	[SECPOS+2],CX
 25320 00004095 89CA                    	MOV	DX,CX
 25321                                  
 25322 00004097 89C3                    	MOV	BX,AX
 25323                                  	;and	bl,[es:bp+4]
 25324 00004099 26225E04                	AND	BL,[ES:BP+DPB.CLUSTER_MASK]
 25325 0000409D 881E[7305]              	MOV	[SECCLUSPOS],BL
 25326                                  
 25327 000040A1 E84105                  	call	SHR32			;(DX:AX SHR dpb_cluster_shift)
 25328 000040A4 59                      	POP	CX			;CX = byte count.
 25329 000040A5 751F                    	JNZ	short EOFERR		;cluster number above 64k
 25330                                  	;cmp	ax,[es:bp+0Dh]
 25331 000040A7 263B460D                	CMP	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  if > disk size ;AN000;
 25332 000040AB 7719                    	JA	short EOFERR		   ;>32mb  then EOF       ;AN000;
 25333                                  
 25334 000040AD A3[BC05]                	MOV	[CLUSNUM],AX
 25335 000040B0 07                      	POP	ES			; ES:DI point to SFT
 25336                                  ;M039
 25337                                  
 25338                                  NOSETSTUFF:
 25339 000040B1 89C8                    	MOV	AX,CX		; AX = Byte count.
 25340 000040B3 0306[2C03]              	ADD	AX,[DMAADD]	; See if it will fit in one segment
 25341 000040B7 730C                    	JNC	short setup_OK	; Must be less than 64
 25342 000040B9 A1[2C03]                	MOV	AX,[DMAADD]
 25343 000040BC F7D8                    	NEG	AX		; Amount of room left in segment (know
 25344                                  				;    less than 64K since max value of CX
 25345                                  				;    is FFFF).
 25346 000040BE 7501                    	JNZ	short NoDec
 25347 000040C0 48                      	DEC	AX
 25348                                  NoDec:
 25349 000040C1 89C1                    	MOV	CX,AX		; Can do this much
 25350 000040C3 E304                    	JCXZ	NOROOM		; Silly user gave Xaddr of FFFF in segment
 25351                                  setup_OK:
 25352 000040C5 C3                      	retn
 25353                                  
 25354                                  EOFERR:
 25355 000040C6 07                      	POP	ES		; ES:DI point to SFT
 25356 000040C7 31C9                    	XOR	CX,CX		; No bytes read
 25357                                  ;;;;;;;;;;; 7/18/86
 25358                                  	; MSDOS 3.3
 25359                                  	;MOV	BYTE [DISK_FULL],1 ; set disk full flag
 25360                                  ;;;;;;;;;;;
 25361                                  NOROOM:
 25362 000040C9 5B                      	POP	BX		; Kill return address
 25363 000040CA F8                      	CLC
 25364 000040CB C3                      	retn			; RETURN TO CALLER OF CALLER
 25365                                  
 25366                                  ;Break	<BREAKDOWN -- CUT A USER READ OR WRITE INTO PIECES>
 25367                                  ;---------------------------------------------------------------------------
 25368                                  ;
 25369                                  ; Procedure Name : BREAKDOWN
 25370                                  ;
 25371                                  ; Inputs:
 25372                                  ;	CX = Length of disk transfer in bytes
 25373                                  ;	ES:BP = Base of drive parameters
 25374                                  ;	[BYTSECPOS] = Byte position within first sector
 25375                                  ;	DS = DOSDATA
 25376                                  ; Outputs:
 25377                                  ;	[BYTCNT1] = Bytes to transfer in first sector
 25378                                  ;	[SECCNT] = No. of whole sectors to transfer
 25379                                  ;	[BYTCNT2] = Bytes to transfer in last sector
 25380                                  ; AX, BX, DX destroyed. No other registers affected.
 25381                                  ;---------------------------------------------------------------------------
 25382                                  
 25383                                  BREAKDOWN:
 25384 000040CC A1[CC05]                	MOV	AX,[BYTSECPOS]
 25385 000040CF 89CB                    	MOV	BX,CX
 25386 000040D1 09C0                    	OR	AX,AX
 25387 000040D3 740E                    	JZ	short SAVFIR	; Partial first sector?
 25388                                  	;sub	ax,[es:bp+2]
 25389 000040D5 262B4602                	SUB	AX,[ES:BP+DPB.SECTOR_SIZE]
 25390 000040D9 F7D8                    	NEG	AX		; Max number of bytes left in first sector
 25391 000040DB 29C3                    	SUB	BX,AX		; Subtract from total length
 25392 000040DD 7304                    	JAE	short SAVFIR
 25393 000040DF 01D8                    	ADD	AX,BX		; Don't use all of the rest of the sector
 25394 000040E1 31DB                    	XOR	BX,BX		; And no bytes are left
 25395                                  SAVFIR:
 25396 000040E3 A3[D205]                	MOV	[BYTCNT1],AX
 25397 000040E6 89D8                    	MOV	AX,BX
 25398 000040E8 31D2                    	XOR	DX,DX
 25399                                  	;div	word [ES:BP+2]
 25400 000040EA 26F77602                	DIV	word [ES:BP+DPB.SECTOR_SIZE]  ; How many whole sectors?
 25401 000040EE A3[D605]                	MOV	[SECCNT],AX
 25402 000040F1 8916[D405]              	MOV	[BYTCNT2],DX	; Bytes remaining for last sector
 25403                                  	; MSDOS 3.3
 25404                                  	;OR	DX,[BYTCNT1]	; SMR ONESECTORFIX BUGBUG
 25405                                  	;retnz			; NOT (BYTCNT1 = BYTCNT2 = 0)
 25406                                  	;CMP	AX,1
 25407                                  	;retnz
 25408                                  	;MOV	AX,[ES:BP+DPB.SECTOR_SIZE] ; Buffer EXACT one sector I/O
 25409                                  	;MOV	[BYTCNT2],AX
 25410                                  	;MOV	[SECCNT],DX	; DX = 0
 25411                                  _RET45:
 25412 000040F5 C3                      	retn
 25413                                  
 25414                                  ; DOSCODE:77BFh (MSDOS 6.21, MSDOS.SYS)
 25415                                  
 25416                                  ;----------------------------------------------------------------------------
 25417                                  ;
 25418                                  ; Procedure Name : READ_LOCK_VIOLATION
 25419                                  ;
 25420                                  ; ES:DI points to SFT. This entry used by NET_READ
 25421                                  ; Carry set if to return error (CX=0,AX=error_sharing_violation).
 25422                                  ; Else do retrys.
 25423                                  ; ES:DI,DS,CX preserved
 25424                                  ;
 25425                                  ;----------------------------------------------------------------------------
 25426                                  
 25427                                  READ_LOCK_VIOLATION:
 25428 000040F6 C606[7505]00            	MOV	byte [READOP],0
 25429                                  ERR_ON_CHECK:
 25430                                  	;;test	word [es:di+2],8000h
 25431                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 25432                                  	;JNZ	short HARD_ERR
 25433                                  
 25434                                  	; 04/05/2019
 25435                                  	;test	byte [es:di+3],80h
 25436 000040FB 26F6450380              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 25437 00004100 7508                    	JNZ	short HARD_ERR
 25438                                  
 25439                                  	;PUSH	CX
 25440                                  	;;mov	cl,[es:di+2]
 25441                                  	;MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 25442                                  	;;and	cl,0F0h
 25443                                  	;AND	CL,SHARING_MASK
 25444                                  	;;cmp	cl,0
 25445                                  	;CMP	CL,SHARING_COMPAT
 25446                                  	;POP	CX
 25447                                  	;JNE	short NO_HARD_ERR
 25448                                  	; 21/09/2023
 25449 00004102 268A4502                	mov	al,[ES:DI+SF_ENTRY.sf_mode]
 25450 00004106 24F0                    	and	al,SHARING_MASK
 25451                                  	;cmp	al,SHARING_COMPAT
 25452                                  	;jne	short NO_HARD_ERR
 25453 00004108 7505                    	jnz	short NO_HARD_ERR
 25454                                  HARD_ERR:
 25455 0000410A E8F33B                  	call	LOCK_VIOLATION
 25456 0000410D 73E6                    	jnc	short _RET45		; User wants Retrys
 25457                                  NO_HARD_ERR:
 25458 0000410F 31C9                    	XOR	CX,CX			;No bytes transferred
 25459                                  	;mov	ax,21h
 25460 00004111 B82100                  	MOV	AX,error_lock_violation
 25461 00004114 F9                      	STC
 25462 00004115 C3                      	retn
 25463                                  
 25464                                  ;----------------------------------------------------------------------------
 25465                                  ;
 25466                                  ; Procedure Name : WRITE_LOCK_VIOLATION
 25467                                  ;
 25468                                  ; Same as READ_LOCK_VIOLATION except for READOP.
 25469                                  ; This entry used by NET_WRITE
 25470                                  ;
 25471                                  ;----------------------------------------------------------------------------
 25472                                  
 25473                                  WRITE_LOCK_VIOLATION:
 25474 00004116 C606[7505]01            	MOV	byte [READOP],1
 25475 0000411B EBDE                    	JMP	short ERR_ON_CHECK
 25476                                  
 25477                                  ; 04/05/2019 - Retro DOS v4.0
 25478                                  
 25479                                  ; DOSCODE:77ECh (MSDOS 6.21, MSDOS.SYS)
 25480                                  
 25481                                  ;Break	<DISKREAD -- PERFORM USER DISK READ>
 25482                                  ;----------------------------------------------------------------------------
 25483                                  ;
 25484                                  ; Procedure Name : DISKREAD
 25485                                  ;
 25486                                  ; Inputs:
 25487                                  ;	Outputs of SETUP
 25488                                  ; Function:
 25489                                  ;	Perform disk read
 25490                                  ; Outputs:
 25491                                  ;    Carry clear
 25492                                  ;	CX = No. of bytes read
 25493                                  ;	ES:DI point to SFT
 25494                                  ;	SFT offset and cluster pointers updated
 25495                                  ;    Carry set
 25496                                  ;	CX = 0
 25497                                  ;	ES:DI point to SFT
 25498                                  ;	AX has error code
 25499                                  ;----------------------------------------------------------------------------
 25500                                  
 25501                                  ;hkn; called from disk.asm. DS already set up.
 25502                                  
 25503                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25504                                  ; DOSCODE:77D8h (MSDOS 5.0, MSDOS.SYS)
 25505                                  
 25506                                  DISKREAD:
 25507                                  	;mov	ax,[es:di+11h]
 25508 0000411D 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 25509                                  	;mov	bx,[es:di+13h]
 25510 00004121 268B5D13                	MOV	BX,[ES:DI+SF_ENTRY.sf_size+2]
 25511 00004125 2B06[CE05]              	SUB	AX,[BYTPOS]
 25512 00004129 1B1E[D005]              	SBB	BX,[BYTPOS+2]
 25513 0000412D 7226                    	JB	short RDERR		;Read starts past EOF
 25514 0000412F 750A                    	JNZ	short ENUF		;More than 64k to EOF
 25515 00004131 09C0                    	OR	AX,AX
 25516 00004133 7420                    	JZ	short RDERR		;Read starts at EOF
 25517 00004135 39C8                    	CMP	AX,CX
 25518 00004137 7302                    	JAE	short ENUF		;I/O fits
 25519 00004139 89C1                    	MOV	CX,AX			;Limit read to up til EOF
 25520                                  ENUF:
 25521                                  	; MSDOS 3.3
 25522                                  	;test	byte [es:di+4],8
 25523                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 25524                                  	;jnz	short SET_ACC_ERR
 25525                                  	;call	LOCK_CHECK
 25526                                  	;jnb	short _READ_OK
 25527                                  	;call	READ_LOCK_VIOLATION
 25528                                  	;jnb	short ENUF
 25529                                  	;retn
 25530                                  
 25531                                  	; MSDOS 6.0
 25532 0000413B E87CFE                  	call	CHECK_READ_LOCK		;IFS. check read lock	;AN000;
 25533 0000413E 7301                    	JNC	short _READ_OK 		; There are no locks
 25534 00004140 C3                      	retn
 25535                                  
 25536                                  _READ_OK:
 25537 00004141 C42E[8A05]              	LES	BP,[THISDPB]
 25538 00004145 E884FF                  	CALL	BREAKDOWN
 25539 00004148 8B0E[BC05]              	MOV	CX,[CLUSNUM]
 25540                                  
 25541 0000414C E8B214                  	call	FNDCLUS
 25542                                       	; MSDOS 6.0			;M022 conditional removed here
 25543 0000414F 720E                    	JC	short SET_ACC_ERR_DS	; fix to take care of I24 fail
 25544                                  					; migrated from 330a - HKN
 25545 00004151 09C9                    	OR	CX,CX
 25546 00004153 7413                    	JZ	short SKIPERR
 25547                                  RDERR:
 25548 00004155 B40E                    	MOV	AH,0EH			;MS. read/data/fail ;AN000;
 25549 00004157 E92102                  	jmp	WRTERR22
 25550                                  
 25551                                  ;RDLASTJ: 
 25552                                  	;JMP	RDLAST                  ;M039
 25553                                  
 25554                                  SETSFTJ2: 
 25555 0000415A E99600                  	JMP	SETSFT
 25556                                  
 25557                                  CANOT_READ:
 25558                                  	; MSDOS 3.3
 25559                                  	;POP	CX		;M039.
 25560                                  	; MSDOS 3.3 & MSDOS 6.0
 25561 0000415D 59                      	POP	CX              ;Clean stack.
 25562 0000415E 5B                      	POP	BX
 25563                                  
 25564                                  	;entry	SET_ACC_ERR_DS
 25565                                  SET_ACC_ERR_DS:
 25566                                  
 25567                                  ;hkn; SS is DOSDATA
 25568                                  	;Context DS
 25569 0000415F 16                      	push	ss
 25570 00004160 1F                      	pop	ds
 25571                                  
 25572                                  	;entry	SET_ACC_ERR
 25573                                  SET_ACC_ERR:
 25574 00004161 31C9                    	XOR	CX,CX
 25575                                  	;mov	ax,5
 25576 00004163 B80500                  	MOV	AX,error_access_denied
 25577 00004166 F9                      	STC
 25578 00004167 C3                      	retn
 25579                                  
 25580                                  SKIPERR:
 25581 00004168 8916[BA05]              	MOV	[LASTPOS],DX
 25582 0000416C 891E[BC05]              	MOV	[CLUSNUM],BX
 25583 00004170 833E[D205]00            	CMP	word [BYTCNT1],0
 25584 00004175 7405                    	JZ	short RDMID
 25585                                  
 25586 00004177 E8FD14                  	call	BUFRD
 25587 0000417A 72E3                    	JC	short SET_ACC_ERR_DS
 25588                                  
 25589                                  RDMID:
 25590 0000417C 833E[D605]00            	CMP	word [SECCNT],0
 25591                                  	;JZ	RDLAST ; 10/08/2018
 25592 00004181 7453                    	jz	short RDLAST
 25593                                  
 25594 00004183 E88615                  	call	NEXTSEC
 25595 00004186 72D2                    	JC	short SETSFTJ2
 25596                                  
 25597 00004188 C606[7405]01            	MOV	BYTE [TRANS],1		; A transfer is taking place
 25598                                  ONSEC:
 25599 0000418D 8A16[7305]              	MOV	DL,[SECCLUSPOS]	; (dx/DL = Extent start) ((dh = ?))
 25600 00004191 8B0E[D605]              	MOV	CX,[SECCNT]
 25601 00004195 8B1E[BC05]              	MOV	BX,[CLUSNUM]
 25602                                  RDLP:
 25603 00004199 E8A115                  	call	OPTIMIZE
 25604 0000419C 72C1                    	JC	short SET_ACC_ERR_DS
 25605                                  
 25606 0000419E 57                      	PUSH	DI                      ;DI = Next physical cluster.
 25607 0000419F 50                      	PUSH	AX                      ;AX = # of sectors remaining.
 25608 000041A0 53                      	PUSH	BX			;[DMAADD+2]:BX = Transfer address.
 25609                                  	;mov	byte [ALLOWED],38h
 25610 000041A1 C606[4B03]38            	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 25611 000041A6 8E1E[2E03]              	MOV	DS,[DMAADD+2]
 25612                                  
 25613 000041AA 52                      	PUSH	DX                      ;[HIGH_SECTOR]:DX = phys. sector #.
 25614 000041AB 51                      	PUSH	CX                      ;CX = # of contiguous sectors to read.
 25615                                  
 25616                                  	; 04/05/2019 - Retro DOS v4.0
 25617                                  
 25618                                  	; MSDOS 6.0
 25619 000041AC E87223                  	call	SET_RQ_SC_PARMS		;LB. do this for SC ;AN000;
 25620                                  
 25621                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25622 000041AF E8CFFD                  	call	DREAD
 25623                                  
 25624                                  	; MSDOS 3.3 
 25625                                  	;pop	bx
 25626                                  	;pop	dx
 25627                                  	;jc	short CANOT_READ
 25628                                  	;add	bx,dx	; (bx = Extent end)
 25629                                  	;mov	al,[es:bp] ; mov al,[es:bp+0]
 25630                                  	;;mov	al,[ES:BP+DPB.DRIVE] 
 25631                                  	;call	SETVISIT
 25632                                  	; ->***
 25633                                  ;M039
 25634                                  	; MSDOS 6.0 
 25635 000041B2 59                      	pop	cx
 25636 000041B3 5A                      	pop	dx
 25637 000041B4 368F06[0C06]            	pop	WORD [ss:TEMP_VAR]
 25638 000041B9 72A2                    	jc	short CANOT_READ
 25639                                  
 25640 000041BB 368C1E[0E06]            	mov	[ss:TEMP_VAR2],ds
 25641                                  
 25642                                  ;       CX = # of contiguous sectors read. (These constitute a block of
 25643                                  ;            sectors, also termed an "Extent".)
 25644                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 25645                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 25646                                  ;       ES:BP -> Drive Parameter Block (DPB).
 25647                                  ;
 25648                                  ;	The Buffer Queue must now be scanned: the contents of any dirty
 25649                                  ;	buffers must be "read" into the transfer memory block, so that the
 25650                                  ;       transfer memory reflects the most recent data.
 25651                                  
 25652 000041C0 E85E00                  	call	DskRdBufScan
 25653                                  
 25654                                  	;Context DS
 25655 000041C3 16                      	push	ss
 25656 000041C4 1F                      	pop	ds
 25657                                          
 25658 000041C5 59                      	pop	cx
 25659 000041C6 5B                              pop	bx
 25660                                  
 25661                                  ;       CX = # of sector remaining.
 25662                                  ;       BX = Next physical cluster.
 25663                                  
 25664                                  ;M039
 25665                                  
 25666                                  ;;;;;;;;
 25667                                  ;	; 25/07/2018 - Retro DOS v3.0
 25668                                  ;	; ***->
 25669                                  ;	; MSDOS 3.3
 25670                                  ;	; IBMDOS.COM (1987) - Offset 42BDh
 25671                                  ;bufq:
 25672                                  ;;	DX = Extent start.
 25673                                  ;;	BX = Extent end.
 25674                                  ;;	 AL = Drive #.
 25675                                  ;;     DS:DI-> 1st buffer in queue.
 25676                                  ;
 25677                                  ;	;or	byte [di+5],20h
 25678                                  ;	or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 25679                                  ;	;cmp	al,[di+4]	
 25680                                  ;	cmp	al,[DI+BUFFINFO.buf_ID]
 25681                                  ;	jnz	short bufq3
 25682                                  ;	;cmp	[di+6],dx
 25683                                  ;	cmp	[DI+BUFFINFO.buf_sector],dx
 25684                                  ;	jb	short bufq3	; Jump if Extent start > buffer sector.
 25685                                  ;	;cmp	[di+6],bx
 25686                                  ;	cmp	[DI+BUFFINFO.buf_sector],bx
 25687                                  ;	jnb	short bufq3	; Jump if Extent end >= buffer sector.
 25688                                  ;	
 25689                                  ;	; Buffer sector is in the Extent (contiguous sectors to read)
 25690                                  ;
 25691                                  ;;      Buffer's sector is in Extent: if it is dirty, copy its contents to
 25692                                  ;;      transfer memory; otherwise, just re-position it in the buffer queue
 25693                                  ;;      as MRU (Most Recently Used).
 25694                                  ;
 25695                                  ;	;test	byte [di+5],40h
 25696                                  ;	test	byte [DI+BUFFINFO.buf_flags],buf_dirty ; Bit 6 = dirty flag
 25697                                  ;	jz	short bufq2	; clear buffer, check the next buff sec
 25698                                  ;	pop	ax ; transfer address
 25699                                  ;	push	ax
 25700                                  ;	push	di
 25701                                  ;	push	dx
 25702                                  ;	;sub	dx,[di+6]
 25703                                  ;	sub	dx,[DI+BUFFINFO.buf_sector]
 25704                                  ;	neg	dx
 25705                                  ;
 25706                                  ;;      DX = offset (in sectors) of buffer sector within Transfer memory
 25707                                  ;;           block.
 25708                                  ;
 25709                                  ;	mov	si,di
 25710                                  ;	mov	di,ax
 25711                                  ;	mov	ax,dx
 25712                                  ;	;mov	cx,[es:bp+6]	
 25713                                  ;	mov     cx,[ES:BP+DPB.SECTOR_SIZE] ; CX = sector size (in bytes).
 25714                                  ;	mul	cx
 25715                                  ;	add	di,ax
 25716                                  ;
 25717                                  ;	lea	si,[si+16]
 25718                                  ;	lea	si,[SI+BUFINSIZ] ;DS:SI -> buffer data.
 25719                                  ;	shr	cx,1
 25720                                  ;	push	es
 25721                                  ;	mov	es,[SS:DMAADD+2]
 25722                                  ;
 25723                                  ;;      CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
 25724                                  ;;      DS:SI-> Buffer sector data.
 25725                                  ;;      ES:DI-> Destination within Transfer memory block.
 25726                                  ;
 25727                                  ;	rep	movsw			;Copy buffer sector to Transfer memory
 25728                                  ;	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 25729                                  ;	;rep	movsb                   ;Copy last byte.
 25730                                  ;	jnc	short bufq1
 25731                                  ;	movsb
 25732                                  ;bufq1:
 25733                                  ;	pop	es
 25734                                  ;	pop	dx
 25735                                  ;	pop	di
 25736                                  ;	mov	al,[es:bp]  ; mov al,[es:bp+0]
 25737                                  ;	;mov	al,[ES:BP+DPB.DRIVE]
 25738                                  ;bufq2:
 25739                                  ;	call	SCANPLACE
 25740                                  ;bufq3:
 25741                                  ;	call	SKIPVISIT
 25742                                  ;	jnz	short bufq
 25743                                  ;	
 25744                                  ;	push	ss
 25745                                  ;	pop	ds
 25746                                  ;	pop	cx
 25747                                  ;	pop	cx
 25748                                  ;	pop	bx	
 25749                                  ;bufq4:
 25750                                  ;;;;;;;
 25751 000041C7 E30D                    	JCXZ	RDLAST
 25752                                  
 25753 000041C9 E80F1D                  	call	IsEOF			; test for eof on fat size
 25754 000041CC 7325                    	JAE	short SETSFT
 25755                                  
 25756 000041CE B200                    	MOV	DL,0
 25757 000041D0 FF06[BA05]              	INC	word [LASTPOS]		; We'll be using next cluster
 25758 000041D4 EBC3                    	JMP	short RDLP ; 19/05/2019
 25759                                  
 25760                                  RDLAST:
 25761 000041D6 A1[D405]                	MOV	AX,[BYTCNT2]
 25762 000041D9 09C0                    	OR	AX,AX
 25763 000041DB 7416                    	JZ	short SETSFT
 25764 000041DD A3[D205]                	MOV	[BYTCNT1],AX
 25765                                  
 25766 000041E0 E82915                  	call	NEXTSEC
 25767 000041E3 720E                    	JC	short SETSFT
 25768                                  
 25769 000041E5 C706[CC05]0000          	MOV	word [BYTSECPOS],0
 25770 000041EB E88914                  	call	BUFRD
 25771                                  	; 10/08/2018
 25772                                  
 25773 000041EE 7303                    	JNC	short SETSFT
 25774 000041F0 E96CFF                  	JMP	SET_ACC_ERR_DS
 25775                                  
 25776                                  ;------------------------------------------------------------------------------
 25777                                  ;
 25778                                  ; Procedure Name : SETSFT
 25779                                  ; Inputs:
 25780                                  ;	[NEXTADD],[CLUSNUM],[LASTPOS] set to determine transfer size
 25781                                  ;		and set cluster fields
 25782                                  ; Function:
 25783                                  ;	Update [THISSFT] based on the transfer
 25784                                  ; Outputs:
 25785                                  ;	sf_position, sf_lstclus, and sf_cluspos updated
 25786                                  ;	ES:DI points to [THISSFT]
 25787                                  ;	CX No. of bytes transferred
 25788                                  ;	Carry clear
 25789                                  ;
 25790                                  ;----------------------------------------------------------------------------
 25791                                  
 25792                                  	;entry	SETSFT
 25793                                  
 25794                                  ; 26/07/2018 - Retro DOS v3.0
 25795                                  SETSFT:
 25796 000041F3 C43E[9E05]              	LES	DI,[THISSFT]
 25797                                  
 25798                                  ; Same as SETSFT except ES:DI already points to SFT
 25799                                  	;entry	SETCLUS
 25800                                  SETCLUS:	
 25801 000041F7 8B0E[B805]              	MOV	CX,[NEXTADD]
 25802 000041FB 2B0E[2C03]              	SUB	CX,[DMAADD]		; Number of bytes transfered
 25803                                  	;;test	word [es:di+5],80h
 25804                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 25805                                  	;JNZ	short ADDREC		; don't set clusters if device
 25806                                  
 25807                                  	; 04/05/2019 - Retro DOS v4.0
 25808                                  	;test	byte [es:di+5],80h
 25809 000041FF 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 25810 00004204 750E                    	JNZ	short ADDREC		; don't set clusters if device
 25811                                  
 25812 00004206 A1[BC05]                	MOV	AX,[CLUSNUM]
 25813                                  	;;mov	[es:di+1Bh],ax ; MSDOS 3.3
 25814                                  	;mov	[es:di+35h],ax ; MSDOS 6.0 (& MSDOS 6.21)
 25815 00004209 26894535                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 25816 0000420D A1[BA05]                	MOV	AX,[LASTPOS]
 25817                                  	;mov	[es:di+19h],ax
 25818 00004210 26894519                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],AX
 25819                                  
 25820                                  ;----------------------------------------------------------------------------
 25821                                  ;
 25822                                  ; Procedure : AddRec
 25823                                  ; Inputs:
 25824                                  ;	ES:DI points to SFT
 25825                                  ;	CX is No. Bytes transferred
 25826                                  ; Function:
 25827                                  ;	Update the SFT offset based on the transfer
 25828                                  ; Outputs:
 25829                                  ;	sf_position updated to point to first byte after transfer
 25830                                  ;	ES:DI points to SFT
 25831                                  ;	CX No. of bytes transferred
 25832                                  ;	Carry clear
 25833                                  ;----------------------------------------------------------------------------
 25834                                  
 25835                                  	;entry	AddRec
 25836                                  ADDREC:
 25837 00004214 E309                    	JCXZ	RET28		; If no records read,  don't change position
 25838                                  	;add	[es:di+15h],cx
 25839 00004216 26014D15                	ADD	[ES:DI+SF_ENTRY.sf_position],CX  ; Update current position
 25840                                  	;adc	word [es:di+17h], 0
 25841 0000421A 2683551700              	ADC	WORD [ES:DI+SF_ENTRY.sf_position+2],0
 25842                                  RET28:	
 25843 0000421F F8                      	CLC
 25844 00004220 C3                      	retn
 25845                                  
 25846                                  ; 25/07/2018
 25847                                  ; MSDOS 6.0
 25848                                  ;Break   <DskRdBufScan -- Disk Read Buffer Scan>
 25849                                  ;----------------------------------------------------------------------------
 25850                                  ;
 25851                                  ; Procedure Name : DskRdBufScan
 25852                                  ;
 25853                                  ; Inputs:
 25854                                  ;       CX = # of contiguous sectors read. (These constitute a block of
 25855                                  ;            sectors, also termed an "Extent".)
 25856                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 25857                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 25858                                  ;       ES:BP -> Drive Parameter Block (DPB).
 25859                                  ;
 25860                                  ; Function:
 25861                                  ;	The Buffer Queue is scanned: the contents of any dirty buffers are
 25862                                  ;	"read" into the transfer memory block, so that the transfer memory
 25863                                  ;	reflects the most recent data.
 25864                                  ;
 25865                                  ; Outputs:
 25866                                  ;       Transfer memory updated as required.
 25867                                  ;
 25868                                  ; Uses:
 25869                                  ;       DS,AX,BX,CX,SI,DI destroyed.
 25870                                  ;       SS override for all global variables.
 25871                                  ;
 25872                                  ; Notes:
 25873                                  ;       FIRST_BUFF_ADDR is set-up to contain the LAST buffer to check, rather
 25874                                  ;	than the FIRST.
 25875                                  ;----------------------------------------------------------------------------
 25876                                  ;M039: Created
 25877                                  
 25878                                  ; 04/05/2019 - Retro DOS v4.0
 25879                                  ; DOSCODE:78F0h (MSDOS 6.21, MSDOS.SYS)
 25880                                  
 25881                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25882                                  ; DOSCODE:78DCh (MSDOS 5.0, MSDOS.SYS) 
 25883                                  
 25884                                  ;procedure DskRdBufScan,NEAR
 25885                                  ;
 25886                                  ;ASSUME  DS:NOTHING
 25887                                  
 25888                                  DskRdBufScan:
 25889 00004221 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0 ; Any dirty buffers?
 25890 00004227 743C                    	je	short bufx		     ; -no, skip all work.
 25891                                  
 25892 00004229 368B1E[0706]            	mov     bx,[ss:HIGH_SECTOR]
 25893 0000422E 89DE                    	mov     si,bx
 25894 00004230 01D1                    	add     cx,dx
 25895 00004232 83D600                  	adc     si,0
 25896                                  
 25897 00004235 E88120                  	call	GETCURHEAD		;DS:DI -> 1st buf in queue.
 25898                                  	;mov	ax,[di+2]
 25899 00004238 8B4502                  	mov     ax,[di+BUFFINFO.buf_prev]
 25900 0000423B 36A3[A512]              	mov     [ss:FIRST_BUFF_ADDR],ax
 25901                                  		
 25902                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25903                                  	;;mov	al,[es:bp+0]
 25904                                  	;mov	al,[es:bp+DPB.DRIVE]
 25905                                  	; 15/12/2022
 25906 0000423F 268A4600                	mov	al,[es:bp]
 25907                                  
 25908                                  ;       BX:DX = Extent start.
 25909                                  ;       SI:CX = Extent end + 1.
 25910                                  ;          AL = Drive #.
 25911                                  ;       DS:DI-> 1st buffer in queue.
 25912                                  ;[FIRST_BUFF_ADDR] = Address offset of last buffer in queue.
 25913                                  
 25914                                  bufq:	
 25915                                  	;cmp	al,[di+4]
 25916 00004243 3A4504                  	cmp     al,[di+BUFFINFO.buf_ID] ;Same drive?
 25917 00004246 7514                    	jne	short bufq1        	;  -no, jump.
 25918                                  
 25919                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 25920                                  ;       ja	short bufq1		;Jump if Extent start > buffer sector.
 25921                                  
 25922                                  	;cmp	bx,[di+8]
 25923 00004248 3B5D08                  	cmp	bx,[di+BUFFINFO.buf_sector+2]
 25924 0000424B 7503                    	jne	short bufq01
 25925                                  	;cmp	dx,[di+6]
 25926 0000424D 3B5506                  	cmp	dx,[di+BUFFINFO.buf_sector]
 25927                                  bufq01:
 25928 00004250 770A                    	ja	short bufq1
 25929                                  
 25930                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 25931                                  ;       ja	short bufq2		;Jump if Extent end >= buffer sector.
 25932                                  
 25933                                  	;cmp	si,[di+8]
 25934 00004252 3B7508                  	cmp	si,[di+BUFFINFO.buf_sector+2]
 25935 00004255 7503                    	jne	short bufq02
 25936                                  	;cmp	cx,[di+6]
 25937 00004257 3B4D06                  	cmp	cx,[di+BUFFINFO.buf_sector]
 25938                                  bufq02:
 25939 0000425A 770A                    	ja	short bufq2
 25940                                  bufq1:	
 25941 0000425C 363B3E[A512]            	cmp     di,[ss:FIRST_BUFF_ADDR]	;Scanned entire buffer queue?
 25942 00004261 8B3D                    	mov	di,[di]
 25943                                  	;mov	di,[di+BUFFINFO.buf_next] ; Set-up for next buffer.
 25944 00004263 75DE                    	jne	short bufq		; -no, do next buffer
 25945                                  bufx:
 25946 00004265 C3                      	retn				;Exit.
 25947                                  
 25948                                  ;       Buffer's sector is in Extent: if it is dirty, copy its contents to
 25949                                  ;	transfer memory; otherwise, just re-position it in the buffer queue
 25950                                  ;       as MRU (Most Recently Used).
 25951                                  
 25952                                  bufq2:	
 25953 00004266 50                      	push	ax
 25954                                  	;test	byte [di+5],40h
 25955 00004267 F6450540                	test	byte [di+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty?
 25956 0000426B 742D                    	jz	short bufq3                    ; -no, jump.
 25957                                  
 25958                                  ;       SaveReg <cx,dx,si,di,es>
 25959 0000426D 51                      	push	cx
 25960 0000426E 52                      	push	dx
 25961 0000426F 56                      	push	si
 25962 00004270 57                      	push	di
 25963 00004271 06                      	push	es
 25964                                  
 25965 00004272 89D0                    	mov     ax,dx
 25966                                  	;sub	ax,[di+6]
 25967 00004274 2B4506                  	sub	ax,[di+BUFFINFO.buf_sector]
 25968 00004277 F7D8                    	neg	ax
 25969                                  
 25970                                  ;       AX = offset (in sectors) of buffer sector within Transfer memory
 25971                                  ;            block. (Note: the upper word of the sector # may be ignored
 25972                                  ;	     since no more than 64k bytes will ever be read. This 64k limit
 25973                                  ;            is imposed by the input parameters of the disk read operation.)
 25974                                  
 25975                                  	;lea	si,[di+20]
 25976 00004279 8D7518                  	lea	si,[di+BUFINSIZ]	;DS:SI -> buffer data.
 25977                                  	;mov	cx,[es:bp+2]
 25978 0000427C 268B4E02                	mov     cx,[es:bp+DPB.SECTOR_SIZE] ;CX = sector size (in bytes).
 25979 00004280 F7E1                    	mul     cx			;AX = offset (in bytes) of buf. sector
 25980 00004282 368B3E[0C06]            	mov     di,[ss:TEMP_VAR]
 25981 00004287 01C7                    	add	di,ax
 25982 00004289 368E06[0E06]            	mov	es,[ss:TEMP_VAR2]
 25983 0000428E D1E9                    	shr	cx,1
 25984                                  
 25985                                  ;	   CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
 25986                                  ;       DS:SI-> Buffer sector data.
 25987                                  ;       ES:DI-> Destination within Transfer memory block.
 25988                                  
 25989 00004290 F3A5                    	rep	movsw			;Copy buffer sector to Transfer memory
 25990                                  	;; 04/05/2019
 25991                                  	;;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 25992                                  	;;rep	movsb                   ;Copy last byte.
 25993                                  	;jnc	short bufq03	
 25994                                  	;movsb
 25995                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25996                                  	;adc	cx,0
 25997                                  	;rep	movsb
 25998                                  	; 22/09/2023
 25999 00004292 7301                    	jnc	short bufq03
 26000 00004294 A4                      	movsb
 26001                                  bufq03:
 26002                                  	;RestoreReg <es,di,si,dx,cx>
 26003 00004295 07                      	pop	es
 26004 00004296 5F                      	pop	di
 26005 00004297 5E                      	pop	si
 26006 00004298 5A                      	pop	dx
 26007 00004299 59                      	pop	cx
 26008                                  
 26009                                  ;       DS:DI -> current buffer.
 26010                                  bufq3:	
 26011 0000429A 89F8                    	mov     ax,di			;DS:AX -> Current buffer.
 26012                                          ;invoke SCANPLACE
 26013 0000429C E82C20                  	call	SCANPLACE
 26014 0000429F 363B06[A512]            	cmp	ax,[ss:FIRST_BUFF_ADDR] ;Last buffer?
 26015 000042A4 58                      	pop	ax
 26016                                  	;jne	short bufq		; -no, jump.
 26017                                  	;;jmp	short bufx		; -yes, exit.
 26018                                  	;; 12/06/2019
 26019                                  	;retn
 26020                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compability)
 26021 000042A5 759C                    	jne	short bufq
 26022 000042A7 EBBC                    	jmp	short bufx
 26023                                  
 26024                                  ;EndProc DskRdBufScan
 26025                                  
 26026                                  ;============================================================================
 26027                                  ; DISK3.ASM, MSDOS 6.0, 1991
 26028                                  ;============================================================================
 26029                                  ; 04/05/2019 - Retro DOS v4.0
 26030                                  ; 24/07/2018 - Retro DOS v3.0
 26031                                  
 26032                                  ;Break   <DISKWRITE -- PERFORM USER DISK WRITE>
 26033                                  ;----------------------------------------------------------------------------
 26034                                  ;
 26035                                  ; Procedure Name : DISKWRITE
 26036                                  ;
 26037                                  ; Inputs:
 26038                                  ;       Outputs of SETUP
 26039                                  ; Function:
 26040                                  ;       Perform disk write
 26041                                  ; Outputs:
 26042                                  ;    Carry clear
 26043                                  ;       CX = No. of bytes written
 26044                                  ;       ES:DI point to SFT
 26045                                  ;       SFT offset and cluster pointers updated
 26046                                  ;    Carry set
 26047                                  ;       CX = 0
 26048                                  ;       ES:DI point to SFT
 26049                                  ;       AX has error code
 26050                                  ;----------------------------------------------------------------------------
 26051                                  
 26052                                  ;hkn; called by DOS_WRITE. DS already set up at this point.
 26053                                  
 26054                                  ; DOSCODE:797Ah (MSDOS 6.21, MSDOS.SYS)
 26055                                  
 26056                                  ; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26057                                  ; DOSCODE:7966h (MSDOS 5.0, MSDOS.SYS) 
 26058                                  
 26059                                  DISKWRITE:
 26060                                  	; MSDOS 3.3
 26061                                  	; IBMDOS.COM - Offset 436Dh
 26062                                  	;;test	byte [es:di+4],8
 26063                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 26064                                  	;jz	short write_cont
 26065                                  	;jmp	SET_ACC_ERR_DS
 26066                                  ;write_cont:
 26067                                  	;push	cx
 26068                                  	;or	cx,cx
 26069                                  	;jnz	short Not_Truncate
 26070                                  	;;mov	cx,-1
 26071                                  	;dec	cx
 26072                                  ;Not_Truncate:
 26073                                  	;call	LOCK_CHECK
 26074                                  	;pop	cx
 26075                                  	;jnb	short _WRITE_OK
 26076                                  	;call	WRITE_LOCK_VIOLATION
 26077                                  	;jnb	short DISKWRITE
 26078                                  	;retn
 26079                                  
 26080                                  	; MSDOS 6.0
 26081 000042A9 E8F0FC                  	call	CHECK_WRITE_LOCK	;IFS. check write lock	;AN000;
 26082                                  	; 19/08/2018
 26083 000042AC 7304                    	JNC	short _WRITE_OK		;IFS. lock check ok	;AN000;
 26084 000042AE C3                      	retn
 26085                                  
 26086                                  WRTEOFJ:
 26087 000042AF E9DC01                  	JMP     WRTEOF
 26088                                  
 26089                                  _WRITE_OK:
 26090                                   	; 27/07/2018
 26091                                  	; IBMDOS.COM - Offset 438Eh
 26092                                  	
 26093                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26094                                  	;and	word [es:di+5],0BFBFh
 26095 000042B2 26816505BFBF            	AND     word [ES:DI+SF_ENTRY.sf_flags],~(sf_close_nodate|devid_file_clean)
 26096                                  				; Mark file as dirty, clear no date on close
 26097                                  
 26098                                  	; 04/05/2019 - Retro DOS v4.0	
 26099                                  
 26100                                  	; MSDOS 6.0
 26101                                  	; mov 	ax,[es:di+11h]
 26102 000042B8 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]		;M039
 26103 000042BC A3[0C06]                        MOV	[TEMP_VAR],AX                           ;M039
 26104                                  	;mov	ax,[es:di+13h]
 26105 000042BF 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]		;M039
 26106 000042C3 A3[0E06]                        MOV	[TEMP_VAR2],AX                          ;M039
 26107                                  
 26108                                  ;	TEMP_VAR2:TEMP_VAR = Current file size (sf_size);M039
 26109                                  
 26110                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26111 000042C6 C42E[8A05]              	LES     BP,[THISDPB]
 26112                                  
 26113 000042CA E8FFFD                  	call	BREAKDOWN
 26114                                  
 26115 000042CD A1[CE05]                	MOV     AX,[BYTPOS]
 26116 000042D0 8B16[D005]              	MOV     DX,[BYTPOS+2]
 26117 000042D4 E3D9                    	JCXZ    WRTEOFJ                 ;Make the file length = sf_position
 26118 000042D6 01C8                    	ADD     AX,CX
 26119 000042D8 83D200                  	ADC     DX,0                    ;DX:AX = last byte to write + 1.
 26120                                  
 26121                                  	;mov	bx,[es:bp+2]
 26122 000042DB 268B5E02                	MOV     BX,[ES:BP+DPB.SECTOR_SIZE]
 26123                                  
 26124                                  	; MSDOS 3.3
 26125                                  	;cmp	dx,bx
 26126                                  	;jnb	short WRTERR33
 26127                                  	;div	bx
 26128                                  	;mov	bx,ax
 26129                                  	;OR	DX,DX
 26130                                  	;JNZ	short CALCLUS
 26131                                  	;dec	ax
 26132                                  ;CALCLUS:
 26133                                  	; MSDOS 3.3
 26134                                  	;mov	cl,[es:bp+5]
 26135                                  	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 26136                                  	;shr	ax,cl
 26137                                  	;push	ax
 26138                                  	;push	dx
 26139                                  	;push	es
 26140                                  	;les	di,[THISSFT]
 26141                                  	;;mov	ax,[es:di+11h]
 26142                                  	;;mov	dx,[es:di+13h]
 26143                                  	;mov	ax,[ES:DI+SF_ENTRY.sf_size]
 26144                                  	;mov	dx,[ES:DI+SF_ENTRY.sf_size+2]
 26145                                  	;pop	es
 26146                                  	;;DX:AX = current file size (in bytes).
 26147                                  	;;div	word [es:bp+2]
 26148                                  	;div	word [ES:BP+DPB.SECTOR_SIZE]
 26149                                  	;mov	cx,ax
 26150                                  	;or	dx,dx
 26151                                  	;jz	short NORND
 26152                                  	;inc	ax
 26153                                  ;NORND:
 26154                                  	; MSDOS 6.0
 26155 000042DF E8DC02                  	CALL	DIV32                   ;DX:AX/BX = CX:AX + DX (rem.).
 26156 000042E2 89C6                    	MOV	SI,AX
 26157 000042E4 890E[0706]                      MOV	[HIGH_SECTOR],CX
 26158                                  
 26159                                  ;       [HIGH_SECTOR]:SI = Last full sector to write.
 26160                                  
 26161 000042E8 09D2                    	OR	DX,DX
 26162 000042EA 52                      	PUSH	DX			;M039: Free DX for use by SHR32
 26163 000042EB 89CA                    	MOV	DX,CX			;M039
 26164 000042ED 7506                    	JNZ	short CALCLUS
 26165 000042EF 83E801                  	SUB	AX,1                    ;AX must be zero base indexed	;AC000;
 26166 000042F2 83DA00                  	SBB	DX,0			;M039 ;F.C. >32mb		;AN000;
 26167                                  
 26168                                  CALCLUS:
 26169                                  	; MSDOS 6.0
 26170 000042F5 E8ED02                  	CALL	SHR32                   ;F.C. >32mb			;AN000;
 26171 000042F8 5A                      	POP	DX
 26172                                  
 26173                                  ;       AX = Last cluster to write.
 26174                                  ;       DX = # of bytes in last sector to write (the "tail").
 26175                                  ;       BX = [ES:BP+DPB.SECTOR_SIZE]
 26176                                  
 26177 000042F9 50                      	PUSH	AX
 26178 000042FA 52                      	PUSH	DX
 26179                                  ;M039
 26180 000042FB 8B16[0E06]              	mov	dx,[TEMP_VAR2]
 26181 000042FF A1[0C06]                	mov	ax,[TEMP_VAR]           ;DX:AX = current file size (in bytes).
 26182 00004302 E8B902                  	call	DIV32           	;DX:AX/BX = CX:AX + DX (rem.)
 26183 00004305 890E[0E06]              	mov	[TEMP_VAR2],cx
 26184 00004309 890E[CA05]              	mov	[VALSEC+2],cx
 26185 0000430D 89C1                    	mov	cx,ax
 26186 0000430F 89F3                    	mov	bx,si
 26187                                  
 26188                                  ;       [HIGH_SECTOR]:BX = Last full sector to write.
 26189                                  ;          [VALSEC+2]:CX = Last full sector of current file.
 26190                                  ;         [TEMP_VAR2]:CX = Last full sector of current file.
 26191                                  ;                     DX = # of bytes in last sector of current file.
 26192                                  ;M039
 26193 00004311 09D2                    	OR	DX,DX
 26194 00004313 7407                    	JZ	short NORND
 26195                                  	;ADD	AX,1            	;Round up if any remainder	;AC000;
 26196                                  	;ADC	word [VALSEC+2],0
 26197                                  	; 22/09/2023
 26198 00004315 40                      	inc	ax  ; 0FFFFh -> 0
 26199 00004316 7504                    	jnz	short NORND
 26200 00004318 FF06[CA05]              	inc	word [VALSEC+2]
 26201                                  NORND:	
 26202                                  	; MSDOS 3.3 & MSDOS 6.0
 26203 0000431C A3[C805]                	MOV     [VALSEC],AX
 26204                                  
 26205                                  ;       [VALSEC] = Last sector of current file.
 26206                                  
 26207 0000431F 31C0                    	XOR     AX,AX
 26208 00004321 A3[DE05]                	MOV     [GROWCNT],AX
 26209 00004324 A3[E005]                	MOV     [GROWCNT+2],AX
 26210 00004327 58                      	POP     AX
 26211                                  
 26212                                  	; MSDOS 6.0
 26213 00004328 8B3E[0706]              	MOV	DI,[HIGH_SECTOR]        ;F.C. >32mb			;AN000;
 26214 0000432C 3B3E[0E06]              	CMP	DI,[TEMP_VAR2]		;M039; F.C. >32mb		;AN000;
 26215 00004330 7263                    	JB	short NOGROW		;F.C. >32mb                     ;AN000;
 26216 00004332 7408                    	JZ	short lowsec		;F.C. >32mb                     ;AN000;
 26217 00004334 29CB                    	SUB	BX,CX                   ;F.C. >32mb                     ;AN000;
 26218 00004336 1B3E[0E06]              	SBB	DI,[TEMP_VAR2]   	;M039; F.C. >32mb di:bx no. of sectors ;AN000;
 26219 0000433A EB08                    	JMP	short yesgrow           ;F.C. >32mb                     ;AN000;
 26220                                  lowsec:
 26221                                  	;MOV	DI,0			;F.C. >32mb
 26222                                  	; 22/09/2023
 26223 0000433C 31FF                    	xor	di,di
 26224                                  	; MSDOS 3.3 & MSDOS 6.0
 26225 0000433E 29CB                    	SUB	BX,CX			; Number of full sectors
 26226 00004340 7253                    	JB	short NOGROW
 26227 00004342 7444                    	JZ	short TESTTAIL
 26228                                  yesgrow:
 26229                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26230 00004344 89D1                    	MOV     CX,DX
 26231 00004346 93                      	XCHG    AX,BX
 26232                                  	;mul	word [es:bp+2]
 26233 00004347 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]  ; Bytes of full sector growth
 26234                                  	
 26235                                  	; MSDOS 6.0
 26236 0000434B 8916[0706]              	MOV	[HIGH_SECTOR],DX         ;F.C. >32mb save dx                    ;AN000;
 26237 0000434F A3[0E06]                	MOV	[TEMP_VAR2],AX    	 ;M039; F.C. >32mb save ax		;AN000;
 26238 00004352 89F8                    	MOV	AX,DI                    ;F.C. >32mb                            ;AN000;
 26239                                  	;mul	word [es:bp+2]
 26240 00004354 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE] ;F.C. >32mb do higher word multiply ;AN000;
 26241                                  	
 26242 00004358 0306[0706]              	ADD	AX,[HIGH_SECTOR]         ;F.C. >32mb add lower value            ;AN000;
 26243 0000435C 89C2                    	MOV	DX,AX                    ;F.C. >32mb DX:AX is the result of     ;AN000;
 26244 0000435E A1[0E06]                	MOV	AX,[TEMP_VAR2]    	 ;M039; F.C. >32mb a 32 bit multiply	;AN000;
 26245                                  
 26246                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26247 00004361 29C8                    	SUB     AX,CX			; Take off current "tail"
 26248 00004363 83DA00                  	SBB     DX,0			; 32-bit extension
 26249 00004366 01D8                    	ADD     AX,BX			; Add on new "tail"
 26250 00004368 83D200                  	ADC     DX,0			; ripple tim's head off
 26251 0000436B EB21                    	JMP     SHORT SETGRW
 26252                                  
 26253                                  HAVSTART:
 26254                                  	;int 3
 26255 0000436D 89C1                    	MOV     CX,AX
 26256 0000436F E8AF12                  	call	SKPCLP
 26257                                  	;JCXZ	DOWRTJ
 26258                                  	; 16/12/2022
 26259 00004372 E357                    	jcxz	DOWRT
 26260                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26261                                  	;jcxz	DOWRTJ
 26262                                  
 26263 00004374 E85114                  	call	ALLOCATE
 26264                                  	;JNC	short DOWRTJ
 26265                                  	; 16/12/2022
 26266 00004377 7352                    	jnc	short DOWRT
 26267                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26268                                  	;jnc	short DOWRTJ
 26269                                  
 26270                                  	;entry   WRTERR
 26271                                  WRTERR:
 26272 00004379 B40F                    	MOV     AH,0FH			;MS. write/data/fail/abort      ;AN000;
 26273                                  
 26274                                  	;entry WRTERR22
 26275                                  WRTERR22:
 26276 0000437B A0[7605]                	MOV     AL,[THISDRV]		;MS.                            ;AN000;
 26277                                  
 26278                                  	; 27/07/2018
 26279                                  WRTERR33:
 26280                                  	;MOV	CX,0			;No bytes transferred
 26281 0000437E 31C9                    	XOR     CX,CX
 26282                                  					
 26283 00004380 C43E[9E05]              	LES     DI,[THISSFT]
 26284                                  	;CLC ; 19/05/2019
 26285                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26286                                  	; 16/12/2022
 26287                                  	;clc
 26288 00004384 C3                      	retn
 26289                                  
 26290                                  	; 16/12/2022
 26291                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26292                                  ;DOWRTJ:
 26293                                  	;JMP	short DOWRT
 26294                                  
 26295                                  ACC_ERRWJ:
 26296                                  	; 10/08/2018
 26297                                  	;JMP	SET_ACC_ERRW
 26298                                  	; 16/12/2022
 26299 00004385 E9D7FD                  	jmp	SET_ACC_ERR_DS
 26300                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26301                                  	;jmp	SET_ACC_ERRW	
 26302                                  
 26303                                  TESTTAIL:
 26304 00004388 29D0                    	SUB     AX,DX
 26305 0000438A 7609                    	JBE	short NOGROW
 26306 0000438C 31D2                    	XOR     DX,DX
 26307                                  SETGRW:
 26308 0000438E A3[DE05]                	MOV	[GROWCNT],AX
 26309 00004391 8916[E005]              	MOV	[GROWCNT+2],DX
 26310                                  NOGROW:
 26311 00004395 58                      	POP     AX
 26312 00004396 8B0E[BC05]              	MOV     CX,[CLUSNUM]    ; First cluster accessed
 26313 0000439A E86412                  	call	FNDCLUS
 26314 0000439D 72E6                    	JC	short ACC_ERRWJ
 26315 0000439F 891E[BC05]              	MOV     [CLUSNUM],BX
 26316 000043A3 8916[BA05]              	MOV     [LASTPOS],DX
 26317                                  
 26318 000043A7 29D0                    	SUB     AX,DX           ; Last cluster minus current cluster
 26319 000043A9 7420                    	JZ	short DOWRT	; If we have last clus, we must have first
 26320 000043AB E3C0                    	JCXZ    HAVSTART        ; See if no more data
 26321 000043AD 51                      	PUSH    CX              ; No. of clusters short of first
 26322 000043AE 89C1                    	MOV     CX,AX
 26323 000043B0 E81514                  	call	ALLOCATE
 26324 000043B3 59                      	POP     CX
 26325 000043B4 72C3                    	JC	short WRTERR
 26326 000043B6 8B16[BA05]              	MOV     DX,[LASTPOS]
 26327 000043BA 42                      	INC     DX
 26328 000043BB 49                      	DEC     CX
 26329 000043BC 7405                    	JZ	short NOSKIP
 26330 000043BE E86012                  	call	SKPCLP
 26331 000043C1 72C2                    	JC	short ACC_ERRWJ
 26332                                  NOSKIP:
 26333 000043C3 891E[BC05]              	MOV     [CLUSNUM],BX
 26334 000043C7 8916[BA05]              	MOV     [LASTPOS],DX
 26335                                  DOWRT:
 26336 000043CB 833E[D205]00            	CMP     word [BYTCNT1],0
 26337 000043D0 7409                    	JZ	short WRTMID
 26338 000043D2 8B1E[BC05]              	MOV     BX,[CLUSNUM]
 26339 000043D6 E8D712                  	call	BUFWRT
 26340 000043D9 72AA                    	JC	short ACC_ERRWJ
 26341                                  WRTMID:
 26342 000043DB A1[D605]                	MOV     AX,[SECCNT]
 26343 000043DE 09C0                    	OR      AX,AX
 26344                                  	; 20/11/2022
 26345 000043E0 746F                    	JZ	short WRTLAST	; 24/07/2019	;M039
 26346 000043E2 0106[C405]              	ADD     [SECPOS],AX
 26347                                  	; 19/05/2019
 26348                                  	; MSDOS 6.0
 26349 000043E6 8316[C605]00            	ADC	WORD [SECPOS+2],0	;F.C. >32mb 	;AN000;
 26350 000043EB E81E13                  	call	NEXTSEC
 26351                                  	; 16/12/2022
 26352 000043EE 7295                    	JC	short ACC_ERRWJ
 26353                                  	;JC	short SET_ACC_ERRW	;M039
 26354 000043F0 C606[7405]01            	MOV     BYTE [TRANS],1		; A transfer is taking place
 26355 000043F5 8A16[7305]              	MOV     DL,[SECCLUSPOS] 	; (dx/DL = Extent start) ((dh = ?))
 26356 000043F9 8B1E[BC05]              	MOV     BX,[CLUSNUM]
 26357 000043FD 8B0E[D605]              	MOV     CX,[SECCNT]
 26358                                  WRTLP:
 26359 00004401 E83913                  	call	OPTIMIZE
 26360 00004404 7248                    	JC	short SET_ACC_ERRW
 26361                                  	; 16/12/2022
 26362                                  	;JC	short ACC_ERRWJ
 26363                                  
 26364                                  ;M039
 26365                                  ;       DI = Next physical cluster.
 26366                                  ;       AX = # sectors remaining.
 26367                                  ;       [DMAADD+2]:BX = transfer address (source data address).
 26368                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 26369                                  ;	     sectors, also termed an "Extent".)
 26370                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 26371                                  ;       ES:BP -> Drive Parameter Block (DPB).
 26372                                  ;
 26373                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 26374                                  ;	are in Extent; they are being over-written.
 26375                                  
 26376 00004406 57                      	push    di
 26377 00004407 50                      	push    ax
 26378                                  
 26379                                  	; MSDOS 3.3
 26380                                  	; IBMDOS.COM (1987) - Offset 4497h
 26381                                  	;push	dx
 26382                                  	;push	bx
 26383                                  	;mov	al,[es:bp]
 26384                                  	;;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 26385                                  	;mov	bx,cx
 26386                                  	;add	bx,dx	; (bx = Extent end)
 26387                                  
 26388                                  ;	DX = Extent start.
 26389                                  ;	BX = Extent end.
 26390                                  ;	AL = Drive #.
 26391                                  
 26392                                  	;call	SETVISIT
 26393                                  
 26394                                  ;wbufq1:
 26395                                  	;;or	byte [di+5],20h
 26396                                  	;or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 26397                                  	;;cmp	al,[di+4]	
 26398                                  	;cmp	al,[DI+BUFFINFO.buf_ID]
 26399                                  	;jnz	short wbufq2	; Jump if Extent start > buffer sector.
 26400                                  	;;cmp	[di+6],dx
 26401                                  	;cmp	[DI+BUFFINFO.buf_sector],dx
 26402                                  	;jb	short wbufq2
 26403                                  	;;cmp	[di+6],bx
 26404                                  	;cmp	[DI+BUFFINFO.buf_sector],bx
 26405                                  	;jnb	short wbufq2	; Jump if Extent end >= buffer sector.
 26406                                  
 26407                                  	;; Buffer sector is in the Extent
 26408                                  
 26409                                  	;;mov	word [di+4],20FFh
 26410                                  	;mov	word [DI+BUFFINFO.buf_ID],20FFh
 26411                                  	;				; .buf_ID,    AL = FFh (Free buffer)
 26412                                  	;				; .buf_flags, AH = 0, reset/clear
 26413                                  	;call	SCANPLACE
 26414                                  ;wbufq2:
 26415                                  	;call	SKIPVISIT
 26416                                  	;jnz	short wbufq1
 26417                                  	;pop	bx
 26418                                  	;pop	dx
 26419                                  
 26420                                          ; MSDOS 6.0
 26421 00004408 E82D01                  	call	DskWrtBufPurge		;DS trashed.
 26422                                  
 26423                                  ;ASSUME DS:NOTHING
 26424                                  ;M039
 26425                                  	; MSDOS 3.3 & MSDOS 6.0
 26426                                  ;hkn; SS override for DMAADD and ALLOWED
 26427 0000440B 368E1E[2E03]            	MOV     DS,[SS:DMAADD+2]
 26428                                  	;mov	byte [ss:ALLOWED],38h
 26429 00004410 36C606[4B03]38          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 26430                                  
 26431                                  ;	put logic from DWRITE in-line here so we can modify it
 26432                                  ;	for DISK FULL conditions.
 26433                                  
 26434                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26435                                  	; DOSCODE:7AD8h (MSDOS 5.0 MSDOS.SYS)
 26436                                  
 26437                                  	; 16/12/2022
 26438                                  	; MSDOS 3.3 (& MSDOS 5.0)
 26439                                  	;call	DWRITE
 26440                                  
 26441                                  ;DWRITE_OKAY:
 26442                                  
 26443                                  	; 16/12/2022
 26444                                  	; MSDOS 5.0 (& MSDOS 3.3)
 26445                                  	;pop     cx
 26446                                  	;pop     bx
 26447                                  	;push    ss
 26448                                  	;pop     ds
 26449                                  	;jc      short SET_ACC_ERRW
 26450                                  	;jcxz    WRTLAST
 26451                                  	;mov     dl, 0
 26452                                  	;inc     word [LASTPOS]
 26453                                  	;jmp     short WRTLP
 26454                                  
 26455                                  	; 16/12/2022
 26456                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26457                                  DWRITE_LUP:
 26458                                  	; 23/07/2019 - Retro DOS v3.2
 26459                                  
 26460                                  	; MSDOS 6.0
 26461 00004416 E8E1FB                  	call	DSKWRITE
 26462 00004419 7417                    	jz	short DWRITE_OKAY
 26463                                  
 26464                                  ;;	int	3
 26465                                  
 26466 0000441B 3C27                    	cmp	al,error_handle_Disk_Full	; compressed volume full?
 26467 0000441D 7423                    	jz	short DWRITE_DISK_FULL
 26468                                  
 26469                                  	; 16/12/2022
 26470                                  
 26471                                  ;;hkn; SS override
 26472 0000441F 36C606[7505]01          	MOV	BYTE [SS:READOP],1
 26473 00004425 E801FC                  	call	HARDERRRW
 26474 00004428 3C01                    	CMP	AL,1		; Check for retry
 26475 0000442A 74EA                    	JZ	short DWRITE_LUP
 26476                                  
 26477                                  	; 16/12/2022
 26478                                  	; 23/07/2019
 26479                                  	;POP	CX ; *4*
 26480                                  	;POP	BX ; *5*
 26481                                  	;
 26482                                  	;push	ss
 26483                                  	;pop	ds
 26484                                  	;
 26485                                  
 26486                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26487                                  
 26488                                  	; 16/12/2022
 26489 0000442C 3C03                    	CMP	AL,3		; Check for FAIL
 26490 0000442E F8                      	CLC
 26491 0000442F 7501                    	JNZ	short DWRITE_OKAY ; Ignore
 26492 00004431 F9                      	STC
 26493                                  
 26494                                  DWRITE_OKAY:
 26495                                  	; 16/12/2022
 26496                                  	; 23/07/2019
 26497                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26498 00004432 59                      	POP	CX ; *4*
 26499 00004433 5B                      	POP	BX ; *5*
 26500                                  
 26501                                  ;       CX = # sectors remaining.
 26502                                  ;       BX = Next physical cluster.
 26503                                  
 26504                                  ;hkn; SS override
 26505                                          ;Context DS
 26506                                  	; 16/12/2022
 26507                                  	;push	ss
 26508                                  	;pop	ds
 26509                                  
 26510                                  	; 16/12/2022
 26511 00004434 7218                    	jc	short SET_ACC_ERRW
 26512                                  
 26513                                  	; 16/12/2022
 26514 00004436 16                      	push	ss
 26515 00004437 1F                      	pop	ds
 26516                                  
 26517 00004438 E317                    	JCXZ    WRTLAST
 26518                                  
 26519                                  	;MOV	DL,0
 26520 0000443A 30D2                    	xor	dl,dl ; 23/07/2019
 26521 0000443C FF06[BA05]              	INC     word [LASTPOS]	; We'll be using next cluster
 26522 00004440 EBBF                    	JMP     short WRTLP
 26523                                  
 26524                                  	; 23/07/2019 - Retro DOS v3.2
 26525                                  	; 09/08/2018
 26526                                  	; MSDOS 6.0
 26527                                  DWRITE_DISK_FULL:
 26528                                  	;Context DS		;SQ 3-5-93 DS must be setup on return!
 26529                                  	; 16/12/2022
 26530 00004442 16                      	push	ss
 26531 00004443 1F                      	pop	ds
 26532 00004444 59                      	pop	cx		; unjunk stack
 26533 00004445 5B                      	pop	bx
 26534 00004446 C606[0B06]01            	mov	byte [DISK_FULL],1
 26535                                  	;stc
 26536 0000444B E92BFF                  	jmp	WRTERR ; 24/07/2019 ; go to disk full exit
 26537                                  
 26538                                  	; 16/12/2022
 26539                                  SET_ACC_ERRW:
 26540 0000444E E90EFD                  	jmp	SET_ACC_ERR_DS
 26541                                  
 26542                                  WRTLAST:
 26543 00004451 A1[D405]                	MOV     AX,[BYTCNT2]
 26544 00004454 09C0                    	OR      AX,AX
 26545 00004456 7413                    	JZ	short FINWRT
 26546 00004458 A3[D205]                	MOV     [BYTCNT1],AX
 26547 0000445B E8AE12                  	call	NEXTSEC
 26548 0000445E 72EE                    	JC	short SET_ACC_ERRW
 26549 00004460 C706[CC05]0000          	MOV     word [BYTSECPOS],0
 26550 00004466 E84712                  	call	BUFWRT
 26551 00004469 72E3                    	JC	short SET_ACC_ERRW
 26552                                  FINWRT:
 26553 0000446B C43E[9E05]              	LES     DI,[THISSFT]
 26554 0000446F A1[DE05]                	MOV     AX,[GROWCNT]
 26555 00004472 8B0E[E005]              	MOV     CX,[GROWCNT+2]
 26556 00004476 09C0                    	OR      AX,AX
 26557 00004478 7502                    	JNZ	short UPDATE_size
 26558 0000447A E30F                    	JCXZ    SAMSIZ
 26559                                  UPDATE_size:
 26560                                  	;add	[es:di+11h],ax
 26561 0000447C 26014511                	ADD     [ES:DI+SF_ENTRY.sf_size],AX
 26562                                  	;adc	[es:di+13h],cx
 26563 00004480 26114D13                	ADC     [ES:DI+SF_ENTRY.sf_size+2],CX
 26564                                  
 26565                                  ; Make sure that all other SFT's see this growth also.
 26566                                  
 26567 00004484 B80100                  	MOV     AX,1
 26568                                  ;if installed
 26569                                  	;Call	JShare + 14 * 4
 26570 00004487 FF1E[C800]              	call    far [JShare+(14*4)]	; 14 = ShSU
 26571                                  ;else
 26572                                  ;	Call    ShSU
 26573                                  ;endif
 26574                                  
 26575                                  SAMSIZ:
 26576 0000448B E969FD                  	jmp	SETCLUS	; ES:DI already points to SFT
 26577                                  
 26578                                  	; 16/12/2022
 26579                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26580                                  ;SET_ACC_ERRW:
 26581                                  	;jmp	SET_ACC_ERR_DS
 26582                                  
 26583                                  WRTEOF:
 26584 0000448E 89C1                    	MOV     CX,AX
 26585 00004490 09D1                    	OR      CX,DX
 26586 00004492 746C                    	JZ	short KILLFIL
 26587 00004494 83E801                  	SUB     AX,1
 26588 00004497 83DA00                  	SBB     DX,0
 26589                                  
 26590                                  	; MSDOS 3.3
 26591                                  	;;div	word [es:bp+2]
 26592                                  	;div	word [ES:BP+DPB.SECTOR_SIZE]
 26593                                  	;;mov	cl,[es:bp+5]
 26594                                  	;mov	cl,[ES:BP+DPB.CLUSTER_SHIFT] 
 26595                                  	;shr	ax,cl
 26596                                  
 26597                                  	; MSDOS 6.0
 26598 0000449A 53                      	PUSH	BX
 26599                                  	;mov	bx,[es:bp+2]
 26600 0000449B 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]    ;F.C. >32mb                       ;AN000;
 26601 0000449F E81C01                  	CALL	DIV32                         ;F.C. >32mb                       ;AN000;
 26602 000044A2 5B                      	POP	BX			      ;F.C. >32mb			;AN000;
 26603 000044A3 89CA                    	MOV	DX,CX			      ;M039
 26604 000044A5 890E[0706]                      MOV	[HIGH_SECTOR],CX              ;M039: Probably extraneous, but not sure.
 26605 000044A9 E83901                  	CALL	SHR32                         ;F.C. >32mb                       ;AN000;
 26606                                  
 26607 000044AC 89C1                    	MOV     CX,AX
 26608 000044AE E85011                  	call	FNDCLUS
 26609                                  SET_ACC_ERRWJ2:
 26610 000044B1 729B                    	JC	short SET_ACC_ERRW
 26611                                  
 26612 000044B3 E326                    	JCXZ    RELFILE
 26613 000044B5 E81013                  	call	ALLOCATE
 26614                                  	;JC	short WRTERRJ              ;;;;;;;;; disk full
 26615                                  	; 16/12/2022
 26616 000044B8 7303                    	jnc	short UPDATE
 26617 000044BA E9BCFE                  	JMP	WRTERR
 26618                                  UPDATE:
 26619 000044BD C43E[9E05]              	LES	DI,[THISSFT]
 26620 000044C1 A1[CE05]                	MOV	AX,[BYTPOS]
 26621                                  	;mov	[es:di+11h],ax
 26622 000044C4 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 26623 000044C8 A1[D005]                	MOV	AX,[BYTPOS+2]
 26624                                  	;mov	[es:di+13h],ax
 26625 000044CB 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 26626                                  ;
 26627                                  ; Make sure that all other SFT's see this growth also.
 26628                                  ;
 26629 000044CF B80200                  	MOV     AX,2
 26630                                  ;if installed
 26631                                  	;Call	JShare + 14 * 4
 26632 000044D2 FF1E[C800]              	call    far [JShare+(14*4)]	; 14 = ShSU
 26633                                  ;else
 26634                                  ;	Call    ShSU
 26635                                  ;endif
 26636 000044D6 31C9                    	XOR     CX,CX
 26637 000044D8 E939FD                  	jmp	ADDREC
 26638                                  
 26639                                  	; 16/12/2022
 26640                                  ;WRTERRJ: 
 26641                                  	;JMP	WRTERR
 26642                                  
 26643                                  ;;;;;;;;;;;;;;;; 7/18/86
 26644                                  ;;;;;;;;;;;;;;;;
 26645                                  
 26646                                  RELFILE:
 26647                                  	; MSDOS 6.0
 26648 000044DB 06                      	PUSH    ES                    ;AN002; BL Reset Lstclus and cluspos to
 26649 000044DC C43E[9E05]              	LES     DI,[THISSFT]          ;AN002; BL beginning of file if current
 26650                                  	;cmp	dx,[es:di+19h]
 26651 000044E0 263B5519                	CMP     DX,[ES:DI+SF_ENTRY.sf_cluspos]	;AN002; BL cluspos is past EOF.
 26652 000044E4 730E                    	JAE	short SKIPRESET	      		;AN002; BL
 26653                                  	;mov	[es:di+19h],0
 26654 000044E6 26C745190000            	MOV     word [ES:DI+SF_ENTRY.sf_cluspos],0 ;AN002; BL
 26655                                  	;mov	dx,[es:di+0Bh]
 26656 000044EC 268B550B                	MOV     DX,[ES:DI+SF_ENTRY.sf_firclus]	;AN002; BL
 26657                                  	;mov	[es:di+35h],dx
 26658 000044F0 26895535                	MOV     [ES:DI+SF_ENTRY.sf_lstclus],DX	;AN002; BL
 26659                                  SKIPRESET:                            		;AN002; BL
 26660 000044F4 07                      	POP     ES                    		;AN002; BL
 26661                                  ;
 26662 000044F5 BAFFFF                  	MOV     DX,0FFFFH
 26663 000044F8 E87B13                  	call	RELBLKS
 26664                                  	; 16/12/2022
 26665                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26666 000044FB 73C0                    	jnc	short UPDATE
 26667                                  SET_ACC_ERRWJ:
 26668                                  	;JC	short SET_ACC_ERRWJ2
 26669                                  	;JMP	SHORT UPDATE
 26670                                  	; 16/12/2022
 26671 000044FD E95FFC                  	jmp	SET_ACC_ERR_DS
 26672                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26673                                  	;JC	short SET_ACC_ERRWJ2
 26674                                  	;JMP	SHORT UPDATE
 26675                                  
 26676                                  KILLFIL:
 26677 00004500 31DB                    	XOR     BX,BX
 26678 00004502 06                      	PUSH    ES
 26679 00004503 C43E[9E05]              	LES     DI,[THISSFT]
 26680                                  	;mov	[es:di+19h],bx
 26681 00004507 26895D19                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],BX
 26682                                  	;mov	[es:di+35h],bx ; 04/05/2019
 26683 0000450B 26895D35                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],BX
 26684                                  	;xchg	bx,[es:di+0Bh]
 26685 0000450F 26875D0B                	XCHG    BX,[ES:DI+SF_ENTRY.sf_firclus]
 26686 00004513 07                      	POP	ES
 26687                                  
 26688 00004514 09DB                    	OR	BX,BX
 26689                                  	;JZ	short UPDATEJ
 26690                                  	; 16/12/2022
 26691 00004516 74A5                    	jz	short UPDATE
 26692                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26693                                  	;jz	short UPDATEJ
 26694                                  
 26695                                  ;; 10/23/86 FastOpen update
 26696 00004518 06                      	PUSH	ES              ; since first cluster # is 0
 26697 00004519 55                      	PUSH	BP              ; we must delete the old cache entry
 26698 0000451A 50                      	PUSH	AX
 26699 0000451B 51                      	PUSH	CX
 26700 0000451C 52                      	PUSH	DX
 26701 0000451D C42E[8A05]              	LES	BP,[THISDPB]             ; get current DPB
 26702                                  	; 15/12/2022
 26703 00004521 268A5600                	mov	dl,[ES:BP] ; mov dl,[es:bp+0]
 26704                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26705                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; get current drive
 26706 00004525 89D9                    	MOV	CX,BX                    ; first cluster #
 26707 00004527 B402                    	MOV	AH,2                     ; delete cache entry by drive:firclus
 26708 00004529 E860E8                  	call	FastOpen_Update          ; call fastopen
 26709 0000452C 5A                      	POP	DX
 26710 0000452D 59                      	POP	CX
 26711 0000452E 58                      	POP	AX
 26712 0000452F 5D                      	POP	BP
 26713 00004530 07                      	POP	ES
 26714                                  ;; 10/23/86 FastOpen update
 26715                                  
 26716 00004531 E84013                  	call	RELEASE
 26717 00004534 72C7                    	JC	short SET_ACC_ERRWJ
 26718                                  UPDATEJ:
 26719                                  	; 20/11/2022
 26720 00004536 EB85                    	JMP	short UPDATE ; 10/08/2018
 26721                                  
 26722                                  ;Break   <DskWrtBufPurge -- Disk Write Buffer Purge>
 26723                                  ;----------------------------------------------------------------------------
 26724                                  ;
 26725                                  ; Procedure Name : DskWrtBufPurge
 26726                                  ;
 26727                                  ; Inputs:
 26728                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 26729                                  ;	     sectors, also termed an "Extent".)
 26730                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 26731                                  ;       ES:BP -> Drive Parameter Block (DPB).
 26732                                  ;
 26733                                  ; Function:
 26734                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 26735                                  ;	are in Extent; they are being over-written.
 26736                                  ;
 26737                                  ; Outputs:
 26738                                  ;       (Same as Input.)
 26739                                  ; Uses:
 26740                                  ;       All registers except DS,AX,SI,DI preserved.
 26741                                  ;       SS override for all global variables.
 26742                                  ;----------------------------------------------------------------------------
 26743                                  ;M039: Created
 26744                                  
 26745                                  ;procedure   DskWrtBufPurge,NEAR
 26746                                  ;
 26747                                  ;ASSUME  DS:NOTHING
 26748                                  
 26749                                  ; 04/05/2019 - Retro DOS v4.0
 26750                                  ; DOSCODE:7C0Eh (MSDOS 6.21, MSDOS.SYS)
 26751                                  
 26752                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26753                                  ; DOSCODE:7BD4h (MSDOS 5.0, MSDOS.SYS) 
 26754                                  
 26755                                  DskWrtBufPurge:
 26756                                  	;SaveReg <bx,cx>
 26757 00004538 53                      	push	bx
 26758 00004539 51                      	push	cx
 26759                                  
 26760 0000453A 368B1E[0706]            	mov	bx,[ss:HIGH_SECTOR]	;BX:DX = Extent start (sector #).
 26761 0000453F 89DE                    	mov	si,bx
 26762 00004541 01D1                    	add	cx,dx
 26763 00004543 83D600                  	adc	si,0                    ;SI:CX = Extent end + 1.
 26764                                  
 26765                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26766                                  	;;mov	al,[es:bp+0]
 26767                                  	;mov	al,[es:bp+DPB.DRIVE]
 26768                                  	; 15/12/2022
 26769 00004546 268A4600                	mov	al,[es:bp]
 26770                                  
 26771                                  ;	BX:DX = Extent start.
 26772                                  ;	SI:CX = Extent end + 1.
 26773                                  ;	AL = Drive #
 26774                                  
 26775 0000454A 36833E[7700]00          	cmp	word [ss:SC_CACHE_COUNT],0 ;Secondary cache in-use?
 26776 00004550 7431                    	je	short nosc		; -no, jump.
 26777                                  
 26778                                  ;	If any of the sectors to be written are in the secondary cache (SC),
 26779                                  ;	invalidate the entire SC. (This is an optimization; we really only
 26780                                  ;	need to invalidate those sectors which intersect, but that's slower.)
 26781                                  
 26782 00004552 363A06[9C12]            	cmp	al,[ss:CurSC_DRIVE]	;Same drive?
 26783 00004557 752A                    	jne	short nosc		; -no, jump.
 26784                                  
 26785 00004559 50                      	push    ax
 26786 0000455A 36A1[010E]              	mov     ax,[ss:CurSC_SECTOR]
 26787 0000455E 368B3E[030E]            	mov     di,[ss:CurSC_SECTOR+2]	;DI:AX = SC start.
 26788                                  
 26789                                  	;Cmp32	si,cx,di,ax		;Extent end < SC start?
 26790                                  	;jbe	short sc5		; -yes, jump.
 26791                                  
 26792 00004563 39FE                    	cmp	si,di
 26793 00004565 7502                    	jne	short sc01
 26794 00004567 39C1                    	cmp	cx,ax
 26795                                  sc01: 
 26796 00004569 7617                    	jbe	short sc5	
 26797                                  
 26798 0000456B 360306[7700]            	add	ax,[ss:SC_CACHE_COUNT]
 26799 00004570 83D700                  	adc	di,0                    ;DI:AX = SC end + 1.
 26800                                  	
 26801                                  	;Cmp32	bx,dx,di,ax             ;Extent start > SC end?
 26802                                  	;jae	short sc5		; -yes, jump.
 26803                                  
 26804 00004573 39FB                    	cmp	bx,di
 26805 00004575 7502                    	jne	short sc02
 26806 00004577 39C2                    	cmp	dx,ax
 26807                                  sc02:
 26808 00004579 7307                    	jnb	short sc5
 26809                                  
 26810 0000457B 36C706[050E]0000        	mov	word [ss:SC_STATUS],0	;Extent intersects SC: invalidate SC.
 26811                                  sc5:	
 26812 00004582 58                      	pop     ax
 26813                                  
 26814                                  ;	Free any buffered sectors which are in Extent; they are being over-
 26815                                  ;	written.
 26816                                  
 26817                                  nosc:	
 26818 00004583 E8331D                  	call	GETCURHEAD		;DS:DI -> first buffer in queue.
 26819                                  
 26820                                  _bufq:	
 26821                                  	;cmpo	al,[di+4]
 26822 00004586 3A4504                  	cmp     al,[di+BUFFINFO.buf_ID] ;Same drive?
 26823 00004589 7527                    	jne	short bufq5		; -no, jump.
 26824                                  
 26825                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 26826                                  ;       ja	short bufq5		;Jump if Extent start > buffer sector.
 26827                                  
 26828                                  	;cmp	bx,[di+8]
 26829 0000458B 3B5D08                  	cmp	bx,[di+BUFFINFO.buf_sector+2]
 26830 0000458E 7503                    	jne	short bufq04
 26831                                  	;cmp	dx,[di+6]
 26832 00004590 3B5506                  	cmp	dx,[di+BUFFINFO.buf_sector]
 26833                                  bufq04:
 26834 00004593 771D                    	ja	short bufq5
 26835                                  
 26836                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 26837                                  ;       jbe	short bufq5		;Jump if Extent end < buffer sector.
 26838                                  
 26839                                  	;cmp	si,[di+8]
 26840 00004595 3B7508                  	cmp	si,[di+BUFFINFO.buf_sector+2]
 26841 00004598 7503                    	jne	short bufq05
 26842                                  	;cmp	cx,[di+6]
 26843 0000459A 3B4D06                  	cmp	cx,[di+BUFFINFO.buf_sector]
 26844                                  bufq05:
 26845 0000459D 7613                    	jbe	short bufq5
 26846                                  
 26847                                  ;	Buffer's sector is in Extent, so free it; it is being over-written.
 26848                                  
 26849                                  	;test	byte [di+5],40h
 26850 0000459F F6450540                	test	byte [di+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty?
 26851 000045A3 7403                    	jz	short bufq4		; -no, jump.
 26852 000045A5 E89E1F                  	call	DEC_DIRTY_COUNT		; -yes, decrement dirty count.
 26853                                  bufq4:
 26854                                  	;mov	word [di+4],20FFh
 26855 000045A8 C74504FF20              	mov     word [di+BUFFINFO.buf_ID],((buf_visit<<8)|0FFh)
 26856                                  
 26857 000045AD E81B1D                  	call	SCANPLACE
 26858 000045B0 EB02                    	jmp     short bufq6
 26859                                  bufq5: 
 26860 000045B2 8B3D                    	mov     di,[di]
 26861                                  	;mov	di,[di+BUFFINFO.buf_next]
 26862                                  bufq6: 
 26863 000045B4 363B3E[A512]            	cmp	di,[ss:FIRST_BUFF_ADDR]	;Scanned entire buffer queue?
 26864 000045B9 75CB                    	jne	short _bufq		; --no, go do next buffer.
 26865                                  	
 26866                                  	;RestoreReg <cx,bx>
 26867 000045BB 59                      	pop	cx
 26868 000045BC 5B                      	pop	bx
 26869 000045BD C3                      	retn
 26870                                  
 26871                                  ;EndProc DskWrtBufPurge
 26872                                  
 26873                                  ;Break   <DIV32 -- PERFORM 32 BIT DIVIDE>
 26874                                  ;----------------------------------------------------------------------------
 26875                                  ;
 26876                                  ; Procedure Name : DIV32
 26877                                  ;
 26878                                  ; Inputs:
 26879                                  ;       DX:AX = 32 bit dividend   BX= divisor
 26880                                  ; Function:
 26881                                  ;       Perform 32 bit division:  DX:AX/BX = CX:AX + DX (rem.)
 26882                                  ; Outputs:
 26883                                  ;       CX:AX = quotient , DX= remainder
 26884                                  ; Uses:
 26885                                  ;       All registers except AX,CX,DX preserved.
 26886                                  ;----------------------------------------------------------------------------
 26887                                  ;M039: DIV32 optimized for divisor of 512 (common sector size).
 26888                                  
 26889                                  ; 04/05/2019 - Retro DOS v4.0
 26890                                  ; DOSCODE:7C94h (MSDOS 6.21, MSDOS.SYS)
 26891                                  
 26892                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26893                                  ; DOSCODE:7C5Ah (MSDOS 5.0, MSDOS.SYS) 
 26894                                  
 26895                                  DIV32:
 26896 000045BE 81FB0002                	cmp	bx,512
 26897 000045C2 7515                    	jne	short div5
 26898                                  
 26899 000045C4 89D1                    	mov	cx,dx
 26900 000045C6 89C2                    	mov	dx,ax           ; CX:AX = Dividend
 26901 000045C8 81E2FF01                	and	dx,(512-1)      ; DX = Remainder
 26902 000045CC 88E0                    	mov	al,ah
 26903 000045CE 88CC                    	mov	ah,cl
 26904 000045D0 88E9                    	mov	cl,ch
 26905 000045D2 30ED                    	xor	ch,ch
 26906 000045D4 D1E9                    	shr	cx,1
 26907 000045D6 D1D8                    	rcr	ax,1
 26908 000045D8 C3                      	retn
 26909                                  div5:	
 26910 000045D9 89C1                    	mov	cx,ax
 26911 000045DB 89D0                    	mov	ax,dx
 26912 000045DD 31D2                    	xor	dx,dx
 26913 000045DF F7F3                    	div	bx              ; 0:AX/BX
 26914 000045E1 91                      	xchg	cx,ax
 26915 000045E2 F7F3                    	div	bx              ; DX:AX/BX
 26916 000045E4 C3                      	retn
 26917                                  
 26918                                  ;Break   <SHR32 -- PERFORM 32 BIT SHIFT RIGHT>
 26919                                  ;----------------------------------------------------------------------------
 26920                                  ;
 26921                                  ; Procedure Name : SHR32
 26922                                  ;
 26923                                  ; Inputs:
 26924                                  ;	DX:AX = 32 bit sector number
 26925                                  ; Function:
 26926                                  ;       Perform 32 bit shift right
 26927                                  ; Outputs:
 26928                                  ;	AX = cluster number
 26929                                  ;	ZF = 1 if no error
 26930                                  ;	   = 0 if error (cluster number > 64k)
 26931                                  ; Uses:
 26932                                  ;       DX,CX
 26933                                  ;---------------------------------------------------------------------------
 26934                                  ; M017	- SHR32 rewritten for better performance
 26935                                  ; M039	- Additional optimization
 26936                                  
 26937                                  ; 04/05/2019 - Retro DOS v4.0
 26938                                  ; DOSCODE:7CBBh (MSDOS 6.21, MSDOS.SYS)
 26939                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26940                                  ; DOSCODE:7C81h (MSDOS 5.0, MSDOS.SYS) 
 26941                                  
 26942                                  SHR32:
 26943                                  	;mov	cl,[es:bp+5]
 26944 000045E5 268A4E05                	mov	cl,[ES:BP+DPB.CLUSTER_SHIFT]
 26945 000045E9 30ED                    	xor	ch,ch	    ;ZF=1
 26946 000045EB E306                    	jcxz	norota
 26947                                  
 26948                                  rotashft2:
 26949 000045ED D1EA                    	shr	dx,1	    ;ZF reflects state of DX.
 26950 000045EF D1D8                    	rcr	ax,1	    ;ZF not affected.
 26951 000045F1 E2FA                    	loop	rotashft2
 26952                                  norota:
 26953 000045F3 C3                      	retn
 26954                                  
 26955                                  ;============================================================================
 26956                                  ; DIR.ASM, MSDOS 6.0, 1991
 26957                                  ;============================================================================
 26958                                  ; 27/07/2018 - Retro DOS v3.0
 26959                                  ; 19/05/2019 - Retro DOS v4.0 
 26960                                  
 26961                                  ;	TITLE	DIR - Directory and path cracking
 26962                                  ;	NAME	Dir
 26963                                  
 26964                                  ;Break	<FINDENTRY -- LOOK FOR AN ENTRY>
 26965                                  ;---------------------------------------------------------------------------
 26966                                  ;
 26967                                  ; Procedure Name : FINDENTRY,SEARCH
 26968                                  ;
 26969                                  ; Inputs:
 26970                                  ;	[THISDPB] set
 26971                                  ;	[SECCLUSPOS] = 0
 26972                                  ;	[DIRSEC] = Starting directory sector number
 26973                                  ;	[CLUSNUM] = Next cluster of directory
 26974                                  ;	[CLUSFAC] = Sectors/Cluster
 26975                                  ;	[NAME1] = Name to look for
 26976                                  ; Function:
 26977                                  ;	Find file name in disk directory.
 26978                                  ;	"?" matches any character.
 26979                                  ; Outputs:
 26980                                  ;	Carry set if name not found
 26981                                  ;	ELSE
 26982                                  ;	Zero set if attributes match (always except when creating)
 26983                                  ;	AH = Device ID (bit 7 set if not disk)
 26984                                  ;	[THISDPB] = Base of drive parameters
 26985                                  ;	DS = DOSGROUP
 26986                                  ;	ES = DOSGROUP
 26987                                  ;	[CURBUF+2]:BX = Pointer into directory buffer
 26988                                  ;	[CURBUF+2]:SI = Pointer to First Cluster field in directory entry
 26989                                  ;	[CURBUF] has directory record with match
 26990                                  ;	[NAME1] has file name
 26991                                  ;	[LASTENT] is entry number of the entry
 26992                                  ; All other registers destroyed.
 26993                                  ;----------------------------------------------------------------------------
 26994                                  
 26995                                  ;hkn; called from rename.asm and dir2.asm. DS must be already set up at
 26996                                  ;hkn; this point.
 26997                                  
 26998                                  SEARCH:
 26999                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27000                                  	; DOSCODE:7C90h (MSDOS 5.0, MSDOS.SYS) 
 27001                                  
 27002                                  	; 19/05/2019 - Retro DOS v4.0
 27003                                  	; DOSCODE:7CCA (MSDOS 6.21, MSDOS.SYS)
 27004                                  
 27005                                  	; 27/07/2018 - Retro DOS v3.0
 27006                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 45B3h 
 27007                                  	; 15/03/2018 - Retro DOS v2.0
 27008                                  
 27009                                  	; 24/01/2024
 27010                                  
 27011                                  	;entry	FindEntry
 27012                                  FINDENTRY:
 27013 000045F4 E87005                  	call	STARTSRCH
 27014 000045F7 A0[6B05]                	MOV	AL,[ATTRIB]
 27015                                  	;and	al,9Eh
 27016 000045FA 24DE                    	AND	AL,~attr_ignore		; Ignore useless bits
 27017                                  	;cmp	al,8
 27018 000045FC 3C08                    	CMP	AL,attr_volume_id	; Looking for vol ID only ?
 27019 000045FE 7503                    	JNZ	short NOTVOLSRCH	; No
 27020 00004600 E8EB01                  	CALL	SETROOTSRCH		; Yes force search of root
 27021                                  NOTVOLSRCH:
 27022 00004603 E8FA00                  	CALL	GETENTRY
 27023                                  	;JNC	short SRCH
 27024                                  	;JMP	SETESRET
 27025                                  	; 24/01/2024
 27026 00004606 723F                    	jc	short SETESRET
 27027                                  
 27028                                  	;entry	Srch
 27029                                  SRCH:
 27030 00004608 1E                      	PUSH	DS
 27031 00004609 8E1E[E405]              	MOV	DS,[CURBUF+2]
 27032                                  
 27033                                  ;	(DS:BX) = directory entry address
 27034                                  
 27035 0000460D 8A27                    	mov	ah,[BX]
 27036                                  	;MOV	AH,[BX+dir_entry.dir_name] ; mov ah,[bx+0]
 27037 0000460F 08E4                    	OR	AH,AH			; End of directory?
 27038 00004611 7437                    	JZ	short FREE
 27039                                  
 27040                                  ;hkn; SS override
 27041 00004613 363A26[7F05]            	CMP	AH,[SS:DELALL]		; Free entry?
 27042 00004618 7430                    	JZ	short FREE
 27043                                  	;test	byte [bx+0Bh],8
 27044 0000461A F6470B08                	TEST	byte [BX+dir_entry.dir_attr],attr_volume_id
 27045                                  					; Volume ID file?
 27046 0000461E 7405                    	JZ	short CHKFNAM 		; NO
 27047                                  
 27048                                  ;hkn; SS override
 27049 00004620 36FE06[7B05]            	INC	BYTE [SS:VOLID]
 27050                                  CHKFNAM:
 27051                                  ;	Context ES
 27052 00004625 8CD6                    	MOV	SI,SS
 27053 00004627 8EC6                    	MOV	ES,SI
 27054 00004629 89DE                    	MOV	SI,BX
 27055                                  
 27056                                  ;hkn; NAME1 is in DOSDATA
 27057 0000462B BF[4B05]                	MOV	DI,NAME1
 27058                                  ;;;;; 7/29/86
 27059                                  
 27060                                  ;hkn; SS override for NAME1
 27061                                  	;CMP	BYTE [SS:NAME1],0E5H	; special char check
 27062                                  	;JNZ	short NO_E5
 27063                                  	;MOV	BYTE [SS:NAME1],05H
 27064                                  	; 22/09/2023
 27065 0000462E 26803DE5                	cmp	byte [es:di],0E5h
 27066 00004632 7504                    	jnz	short NO_E5
 27067 00004634 26C60505                	mov	byte [es:di],05h
 27068                                  NO_E5:
 27069                                  ;;;;; 7/29/86
 27070 00004638 E86100                  	CALL	MetaCompare
 27071 0000463B 7429                    	JZ	short FOUND
 27072 0000463D 1F                      	POP	DS
 27073                                  
 27074                                  	;entry	NEXTENT
 27075                                  NEXTENT:
 27076 0000463E C42E[8A05]              	LES	BP,[THISDPB]
 27077 00004642 E86600                  	CALL	NEXTENTRY
 27078 00004645 73C1                    	JNC	short SRCH
 27079                                  	;JMP	SHORT SETESRET
 27080                                  	; 24/01/2024
 27081                                  SETESRET:
 27082 00004647 16                      	PUSH	SS
 27083 00004648 07                      	POP	ES
 27084 00004649 C3                      	retn
 27085                                  FREE:
 27086 0000464A 1F                      	POP	DS
 27087 0000464B 8B0E[4803]              	MOV	CX,[LASTENT]
 27088 0000464F 3B0E[D805]              	CMP	CX,[ENTFREE]
 27089 00004653 7304                    	JAE	short TSTALL
 27090 00004655 890E[D805]              	MOV	[ENTFREE],CX
 27091                                  TSTALL:
 27092 00004659 3A26[7F05]              	CMP	AH,[DELALL]		; At end of directory?
 27093                                  NEXTENTJ:
 27094 0000465D 74DF                    	je	short NEXTENT 		; No - continue search
 27095 0000465F 890E[DA05]              	MOV	[ENTLAST],CX
 27096 00004663 F9                      	STC
 27097 00004664 EBE1                    	JMP	SHORT SETESRET
 27098                                  
 27099                                  FOUND:
 27100                                  ; We have a file with a matching name. We must now consider the attributes:
 27101                                  ; ATTRIB	Action
 27102                                  ; ------	------
 27103                                  ; Volume_ID	Is Volume_ID in test?
 27104                                  ; Otherwise	If no create then Is ATTRIB+extra superset of test?
 27105                                  ;		If create then Is ATTRIB equal to test?
 27106                                  
 27107 00004666 8A2C                    	MOV	CH,[SI] 		; Attributes of file
 27108 00004668 1F                      	POP	DS
 27109 00004669 8A26[6B05]              	MOV	AH,[ATTRIB]		; Attributes of search
 27110                                  	;and	ah,9Eh
 27111 0000466D 80E4DE                  	AND	AH,~attr_ignore
 27112                                  	;lea	si,[si+15]
 27113 00004670 8D740F                  	LEA	SI,[SI+dir_entry.dir_first-dir_entry.dir_attr]
 27114                                  					; point to first cluster field
 27115                                  	;test	ch,8
 27116 00004673 F6C508                  	TEST	CH,attr_volume_id	; Volume ID file?
 27117 00004676 7409                    	JZ	short check_one_volume_id ; Nope check other attributes
 27118                                  	;test	ah,8
 27119 00004678 F6C408                  	TEST	AH,attr_volume_id	; Can we find Volume ID?
 27120                                  	;JZ	short NEXTENTJ		; Nope, (not even $FCB_CREATE)
 27121                                  	; 16/12/2022
 27122 0000467B 74C1                    	jz	short NEXTENT ; 19/05/2019
 27123                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27124                                  	;JZ	short NEXTENTJ
 27125 0000467D 30E4                    	XOR	AH,AH			; Set zero flag for $FCB_CREATE
 27126 0000467F EB11                    	JMP	SHORT RETFF		; Found Volume ID
 27127                                  check_one_volume_id:
 27128                                  	;CMP	ah,8
 27129 00004681 80FC08                  	CMP	AH,attr_volume_id	; Looking only for Volume ID?
 27130                                  	;JZ	short NEXTENTJ		; Yes, continue search
 27131                                  	; 16/12/2022
 27132 00004684 74B8                    	je	short NEXTENT ; 19/05/2019
 27133                                  	;JZ	short NEXTENTJ
 27134 00004686 E8F204                  	CALL	MatchAttributes
 27135 00004689 7407                    	JZ	SHORT RETFF
 27136 0000468B F606[7E05]FF            	TEST	BYTE [CREATING],-1	; Pass back mismatch if creating
 27137                                  	; 16/12/2022
 27138                                  	;JZ	short NEXTENTJ		; Otherwise continue searching
 27139 00004690 74AC                    	jz	short NEXTENT ; 19/05/2019
 27140                                  RETFF:
 27141 00004692 C42E[8A05]              	LES	BP,[THISDPB]
 27142                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27143                                  	;MOV	AH,[ES:BP+DPB.DRIVE]  ; mov ah,[es:bp+0]
 27144                                  	; 15/12/2022
 27145 00004696 268A6600                	MOV	AH,[ES:BP]
 27146                                  ;SETESRET:
 27147                                  	;PUSH	SS
 27148                                  	;POP	ES
 27149                                  	;retn
 27150                                  	; 24/01/2024
 27151 0000469A EBAB                    	jmp	short SETESRET
 27152                                  
 27153                                  ;----------------------------------------------------------------------------
 27154                                  ;
 27155                                  ; Procedure Name : MetaCompare
 27156                                  ;
 27157                                  ; Inputs:
 27158                                  ;	DS:SI -> 11 character FCB style name NO '?'
 27159                                  ;	    Typically this is a directory entry. It MUST be in upper case
 27160                                  ;	ES:DI -> 11 character FCB style name with possible '?'
 27161                                  ;	    Typically this is a FCB or SFT. It MUST be in upper case
 27162                                  ; Function:
 27163                                  ;	Compare FCB style names allowing for ? match to any char
 27164                                  ; Outputs:
 27165                                  ;	Zero if match else NZ
 27166                                  ; Destroys CX,SI,DI all others preserved
 27167                                  ;----------------------------------------------------------------------------
 27168                                  
 27169                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27170                                  	; DOSCODE:7D3Fh (MSDOS 5.0, MSDOS.SYS) 
 27171                                  
 27172                                  MetaCompare:
 27173 0000469C B90B00                  	MOV	CX,11
 27174                                  WILDCRD:
 27175 0000469F F3A6                    	REPE	CMPSB
 27176 000046A1 7407                    	JZ	short MetaRet 		; most of the time we will fail.
 27177                                  CHECK_META:
 27178 000046A3 26807DFF3F              	CMP	BYTE [ES:DI-1],"?"
 27179 000046A8 74F5                    	JZ	short WILDCRD
 27180                                  MetaRet:
 27181 000046AA C3                       	retn				; Zero set, Match
 27182                                  
 27183                                  ;Break	<NEXTENTRY -- STEP THROUGH DIRECTORY>
 27184                                  ;----------------------------------------------------------------------------
 27185                                  ;
 27186                                  ; Procedure Name : NEXTENTRY
 27187                                  ;
 27188                                  ; Inputs:
 27189                                  ;	Same as outputs of GETENTRY, above
 27190                                  ; Function:
 27191                                  ;	Update BX, and [LASTENT] for next directory entry.
 27192                                  ;	Carry set if no more.
 27193                                  ;----------------------------------------------------------------------------
 27194                                  
 27195                                  NEXTENTRY:
 27196                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27197                                  	; DOSCODE:7D4Eh (MSDOS 5.0, MSDOS.SYS) 
 27198                                  
 27199                                  	; 19/05/2019 - Retro DOS v4.0
 27200                                  	; DOSCODE:7D88h (MSDOS 6.21, MSDOS.SYS)
 27201                                  
 27202                                  	; 27/07/2018 - Retro DOS v3.0
 27203                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 4671h 
 27204                                  	; 15/03/2018 - Retro DOS v2.0
 27205                                  
 27206 000046AB A1[4803]                	MOV	AX,[LASTENT]
 27207 000046AE 3B06[DA05]              	CMP	AX,[ENTLAST]
 27208 000046B2 7422                    	JZ	short NONE
 27209 000046B4 40                      	INC	AX
 27210                                  	;ADD	BX,32
 27211 000046B5 8D5F20                  	LEA	BX,[BX+32]
 27212 000046B8 39D3                    	CMP	BX,DX
 27213                                  	; 21/11/2022 - MSDOS 5.0 MSDOS.SYS (DOSCODE:7D5Dh)
 27214                                  	;JB	short HAVIT ; MSDOS 6.0 src (dir.asm)
 27215                                  	; 16/12/2022
 27216 000046BA 751C                    	jne	short HAVIT ; MSDOS 6.21 (DOSCODE:7D97h)
 27217 000046BC 8A1E[7305]              	MOV	BL,[SECCLUSPOS]
 27218 000046C0 FEC3                    	INC	BL
 27219 000046C2 3A1E[7705]              	CMP	BL,[CLUSFAC]
 27220 000046C6 7215                    	JB	short SAMECLUS
 27221 000046C8 8B1E[DC05]              	MOV	BX,[NXTCLUSNUM]
 27222 000046CC E80C18                  	call	IsEOF
 27223 000046CF 7305                    	JAE	short NONE
 27224                                  	; 23/07/2019
 27225 000046D1 83FB02                  	CMP	BX,2
 27226                                  	;JB	short NONE
 27227                                  	;JMP	short GETENT
 27228                                  	; 16/12/2022
 27229 000046D4 732D                    	jnb	short GETENT
 27230                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27231                                  	;JB	short NONE
 27232                                  	;JMP	short GETENT
 27233                                  NONE:
 27234 000046D6 F9                      	STC
 27235 000046D7 C3                      	retn
 27236                                  HAVIT:
 27237 000046D8 A3[4803]                	MOV	[LASTENT],AX
 27238 000046DB F8                      	CLC
 27239                                  nextentry_retn:
 27240 000046DC C3                      	retn
 27241                                  SAMECLUS:
 27242 000046DD 881E[7305]              	MOV	[SECCLUSPOS],BL
 27243 000046E1 A3[4803]                	MOV	[LASTENT],AX
 27244 000046E4 1E                      	PUSH	DS
 27245 000046E5 C53E[E205]              	LDS	DI,[CURBUF]
 27246                                  	; 19/05/2019
 27247                                  	; MSDOS 6.0
 27248                                  	;;mov	dx,[di+8]
 27249                                  	; 23/09/2023
 27250                                  	;MOV	DX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 27251                                  ;hkn; SS override
 27252                                  	;MOV	[SS:HIGH_SECTOR],DX 		;AN000; >32mb
 27253                                  	; 23/09/2023
 27254 000046E9 8B7508                  	mov	si,[di+BUFFINFO.buf_sector+2]	
 27255                                  	
 27256                                  	;mov	dx,[di+6]
 27257 000046EC 8B5506                  	MOV	DX,[DI+BUFFINFO.buf_sector]	;AN000; >32mb
 27258                                  	;inc	dx ; MSDOS 3.3
 27259                                  	; MSDOS 6.0
 27260                                  	;ADD	DX,1				;AN000; >32mb
 27261                                  	;ADC	word [SS:HIGH_SECTOR],0 	;AN000; >32mb
 27262                                  	; 23/09/2023
 27263 000046EF 42                      	inc	dx
 27264 000046F0 7501                    	jnz	short nextexntry_fc
 27265 000046F2 46                      	inc	si
 27266                                  	;inc	word [SS:HIGH_SECTOR]
 27267                                  nextexntry_fc:
 27268                                  	; 23/09/2023
 27269 000046F3 368936[0706]            	mov	[SS:HIGH_SECTOR],si
 27270                                  	; MSDOS 3.3 & MSDOS 6.0
 27271 000046F8 1F                      	POP	DS
 27272 000046F9 E847F8                  	call	FIRSTCLUSTER
 27273 000046FC 31DB                    	XOR	BX,BX
 27274 000046FE EB23                    	JMP	short SETENTRY
 27275                                  
 27276                                  ;----------------------------------------------------------------------------
 27277                                  ;
 27278                                  ; Procedure Name : GETENTRY
 27279                                  ;
 27280                                  ; Inputs:
 27281                                  ;	[LASTENT] has directory entry
 27282                                  ;	ES:BP points to drive parameters
 27283                                  ;	[DIRSEC],[CLUSNUM],[CLUSFAC],[ENTLAST] set for DIR involved
 27284                                  ; Function:
 27285                                  ;	Locates directory entry in preparation for search
 27286                                  ;	GETENT provides entry for passing desired entry in AX
 27287                                  ; Outputs:
 27288                                  ;	[CURBUF+2]:BX = Pointer to next directory entry in CURBUF
 27289                                  ;	[CURBUF+2]:DX = Pointer to first byte after end of CURBUF
 27290                                  ;	[LASTENT] = New directory entry number
 27291                                  ;	[NXTCLUSNUM],[SECCLUSPOS] set via DIRREAD
 27292                                  ;	Carry set if error (currently user FAILed to I 24)
 27293                                  ;----------------------------------------------------------------------------
 27294                                  
 27295                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27296                                  GETENTRY:
 27297                                  	; 27/07/2018 - Retro DOS v3.0
 27298 00004700 A1[4803]                	MOV	AX,[LASTENT]
 27299                                  
 27300                                  	;entry	GETENT
 27301                                  GETENT:
 27302 00004703 A3[4803]                	MOV	[LASTENT],AX
 27303                                  ;
 27304                                  ; Convert the entry number in AX into a byte offset from the beginning of the
 27305                                  ; directory.
 27306                                  ;
 27307 00004706 B105                    	mov	cl,5			; shift left by 5 = mult by 32
 27308 00004708 D3C0                    	rol	ax,cl			; keep hight order bits
 27309 0000470A 89C2                    	mov	dx,ax
 27310                                  	; 19/05/2019 - Retro DOS v4.0
 27311                                  	;and	ax,0FFE0h
 27312                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27313                                  	;and	ax,~(32-1)		; mask off high order bits
 27314                                  	; 16/12/2022
 27315 0000470C 24E0                    	and	al,0E0h ; ~31
 27316 0000470E 83E21F                  	and	dx,1Fh
 27317                                  	;and	dx,32-1			; mask off low order bits
 27318                                  ;
 27319                                  ; DX:AX contain the byte offset of the required directory entry from the
 27320                                  ; beginning of the directory. Convert this to a sector number. Round the
 27321                                  ; sector size down to a multiple of 32.
 27322                                  ;
 27323                                  	;mov	bx,[es:bp+2]
 27324 00004711 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 27325 00004715 80E3E0                  	and	bl,0E0h
 27326                                  	;AND	BL,255-31		; Must be multiple of 32
 27327 00004718 F7F3                    	DIV	BX
 27328 0000471A 89D3                    	MOV	BX,DX			; Position within sector
 27329 0000471C 53                      	PUSH	BX
 27330 0000471D E8CFF7                  	call	DIRREAD
 27331 00004720 5B                      	POP	BX
 27332                                  	;retc
 27333 00004721 72B9                    	jc	short nextentry_retn	
 27334                                  SETENTRY:
 27335 00004723 8B16[E205]              	MOV	DX,[CURBUF]
 27336                                  	;add	dx,16 ; MSDOS 3.3
 27337                                  	;add	dx,20 ; MSDOS 6.0 
 27338 00004727 83C218                  	ADD	DX,BUFINSIZ
 27339 0000472A 01D3                    	ADD	BX,DX
 27340                                  	;add	dx,[es:bp+2]
 27341 0000472C 26035602                	ADD	DX,[ES:BP+DPB.SECTOR_SIZE]  ; Always clears carry
 27342                                  	; 29/12/2022
 27343                                  	; MSDOS 6.21 MSDOS.SYS contains a 'CLC' here, at DOSCODE:7E15h
 27344 00004730 F8                      	clc
 27345 00004731 C3                      	retn
 27346                                  
 27347                                  ;----------------------------------------------------------------------------
 27348                                  
 27349                                  ; 23/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 27350                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:8933h
 27351                                  
 27352                                  sft_fcb_table:
 27353 00004732 00<rep 14h>             	times 20 db 0
 27354                                  sftfcb.cluster:
 27355 00004746 00000000                	dd	0
 27356                                  sftfcb.direntry:
 27357 0000474A 0000                    	dw	0
 27358                                  sftfcb_entry_size equ $ - sftfcb.cluster ; = 6
 27359                                  
 27360 0000474C 00<rep 72h>             	times 114 db 0	; 6*20 = 120 ; entry size = 6 bytes 
 27361                                  
 27362                                  SRCH_CLUSTER:
 27363 000047BE 0000                    	dw	0
 27364                                  SRCH_CLUSTER_HW:
 27365 000047C0 0000                    	dw	0
 27366                                  
 27367                                  ;----------------------------------------------------------------------------
 27368                                  
 27369                                  ;Break	<SETDIRSRCH SETROOTSRCH -- Set Search environments>
 27370                                  ;----------------------------------------------------------------------------
 27371                                  ;
 27372                                  ; Procedure Name : SETDIRSRCH,SETROOTSRCH
 27373                                  ;
 27374                                  ; Inputs:
 27375                                  ;	BX cluster number of start of directory
 27376                                  ;	ES:BP Points to DPB
 27377                                  ;	DI next cluster number from fastopen extended info. DOS 3.3 only
 27378                                  ; Function:
 27379                                  ;	Set up a directory search
 27380                                  ; Outputs:
 27381                                  ;	[DIRSTART] = BX
 27382                                  ;	[CLUSFAC],[CLUSNUM],[SECCLUSPOS],[DIRSEC] set
 27383                                  ;	Carry set if error (currently user FAILed to I 24)
 27384                                  ; destroys AX,DX,BX
 27385                                  ;----------------------------------------------------------------------------
 27386                                  
 27387                                  ; 23/01/2024 - Retro DOS v5.0
 27388                                  %if 0
 27389                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27390                                  SETDIRSRCH:
 27391                                  	OR	BX,BX
 27392                                  	JZ	short SETROOTSRCH
 27393                                  	MOV	[DIRSTART],BX
 27394                                  	;mov	al,[es:bp+4]
 27395                                  	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
 27396                                  	INC	AL
 27397                                  	MOV	[CLUSFAC],AL
 27398                                  
 27399                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 27400                                  	;SAVE	<SI>
 27401                                  	push	si
 27402                                  	;test	byte [FastOpenFlg],2
 27403                                  	TEST	byte [FastOpenFlg],Lookup_Success
 27404                                  	JNZ	short UNP_OK
 27405                                  
 27406                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 27407                                  	;invoke	UNPACK
 27408                                  	call	UNPACK
 27409                                  	JNC	short UNP_OK
 27410                                  	;RESTORE <SI>
 27411                                  	pop	si
 27412                                  	;return
 27413                                  	retn
 27414                                  
 27415                                  UNP_OK:
 27416                                  	MOV	[CLUSNUM],DI
 27417                                  	MOV	DX,BX
 27418                                  	XOR	BL,BL
 27419                                  	MOV	[SECCLUSPOS],BL
 27420                                  	;invoke	FIGREC
 27421                                  	call	FIGREC
 27422                                  	;RESTORE <SI>
 27423                                  	pop	si
 27424                                  	
 27425                                  	; 19/05/2019 - Retro DOS v4.0
 27426                                  
 27427                                  	; MSDOS 6.0
 27428                                  	;PUSH	DX			   ;AN000; >32mb
 27429                                  	;MOV	DX,[HIGH_SECTOR]	   ;AN000; >32mb
 27430                                  	;MOV	[DIRSEC+2],DX		   ;AN000; >32mb
 27431                                  	;POP	DX			   ;AN000; >32mb
 27432                                  
 27433                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27434                                  	;push	dx
 27435                                  	;mov	dx,[HIGH_SECTOR]
 27436                                  	;mov	[DIRSEC+2],dx
 27437                                  	;pop	dx
 27438                                  	;MOV	[DIRSEC],dx
 27439                                  	; 16/12/2022
 27440                                  	mov	ax,[HIGH_SECTOR]
 27441                                  	mov	[DIRSEC+2],AX
 27442                                  	MOV	[DIRSEC],DX
 27443                                  
 27444                                  	; 16/12/2022
 27445                                  	; cf=0 (at the return of FIGREC)
 27446                                  	;CLC
 27447                                  	retn
 27448                                  
 27449                                  	;entry	SETROOTSRCH
 27450                                  SETROOTSRCH:
 27451                                  	XOR	AX,AX
 27452                                  	MOV	[DIRSTART],AX
 27453                                  	; 22/09/2023
 27454                                  	mov	[DIRSEC+2],ax ; 0
 27455                                  	MOV	[SECCLUSPOS],AL
 27456                                  	DEC	AX
 27457                                  	MOV	[CLUSNUM],AX
 27458                                  	;mov	ax,[es:bp+0Bh]
 27459                                  	MOV	AX,[ES:BP+DPB.FIRST_SECTOR]
 27460                                  	; 19/05/2019
 27461                                  	;;mov	dx,[es:bp+10h] ; MSDOS 3.3
 27462                                  	;mov	dx,[es:bp+11h] ; MSDOS 6.0
 27463                                  	MOV	DX,[ES:BP+DPB.DIR_SECTOR]
 27464                                  	SUB	AX,DX
 27465                                  	MOV	[CLUSFAC],AL
 27466                                  	MOV	[DIRSEC],DX		      ;F.C. >32mb
 27467                                  	; 22/09/2023
 27468                                  	; MSDOS 6.0
 27469                                  	;MOV	WORD [DIRSEC+2],0	      ;F.C. >32mb
 27470                                  	CLC
 27471                                  	retn
 27472                                  %else
 27473                                  	;;;
 27474                                  	; 23/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 27475                                  	; PCDOS 7.1 IBMDOS.COM - 8A27h
 27476                                  	;;;
 27477                                  SETDIRSRCH:
 27478 000047C2 A1[F50A]                	mov	ax,[ROOTCLUST_HW]
 27479                                  	;cmp	word [ROOTCLUST_HW],0
 27480 000047C5 21C0                    	and	ax,ax	
 27481 000047C7 7504                    	jnz	short SETDIRSRCH_FAT32
 27482                                  	
 27483 000047C9 09DB                    	or	bx,bx
 27484                                  	;jz	short SETROOTSRCH
 27485 000047CB 7423                    	jz	short SETROOTSRCH2 ; ax = 0
 27486                                  SETDIRSRCH_FAT32:
 27487                                  	;mov	ax,[ROOTCLUST_HW]
 27488 000047CD A3[E30A]                	mov	[DIRSTART_HW],ax
 27489 000047D0 A3[EF0A]                	mov	[CLUSTNUM_HW],ax
 27490                                  
 27491 000047D3 891E[C205]              	mov	[DIRSTART],bx
 27492                                  	;mov	al,[es:bp+4]
 27493 000047D7 268A4604                	mov	al,[es:bp+DPB.CLUSTER_MASK]
 27494                                  	;inc	al
 27495 000047DB 40                      	inc	ax
 27496 000047DC A2[7705]                	mov	[CLUSFAC],al
 27497                                  
 27498 000047DF 56                      	push	si
 27499                                  	;test	byte [FastOpenFlg],2
 27500 000047E0 F606[6D12]02            	test	byte [FastOpenFlg],Lookup_Success
 27501 000047E5 7538                    	jnz	short UNP_OK
 27502                                  
 27503 000047E7 E80817                  	call	UNPACK
 27504 000047EA 7333                    	jnc	short UNP_OK
 27505                                  
 27506 000047EC 5E                      	pop	si
 27507 000047ED C3                      	retn
 27508                                  
 27509                                  SETROOTSRCH:
 27510 000047EE 31C0                    	xor	ax,ax ; 0
 27511                                  SETROOTSRCH2:
 27512 000047F0 A3[F50A]                	mov	[ROOTCLUST_HW],ax ;0
 27513                                  	;cmp	word [es:bp+0Fh],0
 27514 000047F3 2639460F                	cmp	[es:bp+DPB.FAT_SIZE],ax ; 0
 27515 000047F7 755A                    	jnz	short SETROOTSRCH_FAT ; not FAT32
 27516                                  SETROOTSRCH_FAT32:
 27517                                  	;mov	bx,[es:bp+37h]
 27518 000047F9 268B5E37                	mov	bx,[es:bp+DPB.ROOT_CLUSTER+2]
 27519 000047FD 891E[F50A]              	mov	[ROOTCLUST_HW],bx
 27520                                  	;cmp	bx,[es:bp+2Fh]
 27521 00004801 263B5E2F                	cmp	bx,[es:bp+DPB.LAST_CLUSTER+2]
 27522                                  	;mov	bx,[es:bp+35h]
 27523 00004805 268B5E35                	mov	bx,[es:bp+DPB.ROOT_CLUSTER]
 27524 00004809 7504                    	jne	short sdsrch_fat32_1
 27525                                  	;cmp	bx,[es:bp+2Dh]
 27526 0000480B 263B5E2D                	cmp	bx,[es:bp+DPB.LAST_CLUSTER]
 27527                                  sdsrch_fat32_1:
 27528 0000480F 770C                    	ja	short sdsrch_fat32_3 ; **
 27529 00004811 833E[F50A]00            	cmp	word [ROOTCLUST_HW],0
 27530                                  	;jnz	short sdsrtch_fat32_2
 27531 00004816 75B5                    	jnz	short SETDIRSRCH_FAT32
 27532 00004818 83FB02                  	cmp	bx,2
 27533                                  	;jb	short sdsrch_fat32_3
 27534                                  sdsrch_fat32_2:
 27535                                  	;jmp	SETDIRSRCH_FAT32
 27536 0000481B 73B0                    	jnb	short SETDIRSRCH_FAT32
 27537                                  
 27538                                  sdsrch_fat32_3:
 27539 0000481D F9                      	stc	; **
 27540                                  	;jmp	short setdirsrch_retn
 27541 0000481E C3                      	retn
 27542                                  
 27543                                  UNP_OK:
 27544                                  	; CCONTENT_HW:DI = Contents of FAT for given cluster
 27545                                  	;			(from UNPACK)
 27546 0000481F 893E[BC05]              	mov	[CLUSNUM],di
 27547 00004823 8B16[F30A]              	mov	dx,[CCONTENT_HW]
 27548 00004827 8916[E50A]              	mov	[CLUSNUM_HW],dx
 27549 0000482B 2E891E[BE47]            	mov	[cs:SRCH_CLUSTER],bx ; Directory start cluster number
 27550                                  				; for searching/locating (directory entry)
 27551 00004830 8B16[EF0A]              	mov	dx,[CLUSTNUM_HW]
 27552 00004834 2E8916[C047]            	mov	[cs:SRCH_CLUSTER_HW],dx
 27553                                  
 27554 00004839 89DA                    	mov	dx,bx
 27555 0000483B 30DB                    	xor	bl,bl
 27556 0000483D 881E[7305]              	mov	[SECCLUSPOS],bl
 27557                                  
 27558                                  	;CLUSTNUM_HW:DX = Physical cluster number (to FIGREC)
 27559                                  
 27560 00004841 E8570F                  	call	FIGREC
 27561                                  
 27562 00004844 8B36[0706]              	mov	si,[HIGH_SECTOR]
 27563 00004848 8936[C005]              	mov	[DIRSEC+2],si
 27564 0000484C 5E                      	pop	si
 27565                                  SETROOTSRCH3:
 27566 0000484D 8916[BE05]              	mov	[DIRSEC],dx ; *
 27567                                  	
 27568                                  	;pop	si
 27569 00004851 F8                      	clc	; (this may not be needed,
 27570                                  		; FIGREC clears cf except an abnormal sector calc overflow)
 27571 00004852 C3                      	retn
 27572                                  
 27573                                  SETROOTSRCH_FAT:
 27574                                  	;xor	ax,ax
 27575 00004853 A3[C005]                	mov	[DIRSEC+2],ax ; 0
 27576 00004856 A3[C205]                	mov	[DIRSTART],ax ; 0
 27577 00004859 A3[E30A]                	mov	[DIRSTART_HW],ax ; 0
 27578 0000485C 2EA3[C047]              	mov	[cs:SRCH_CLUSTER_HW],ax ; 0
 27579 00004860 40                      	inc	ax		; search start dir cluster num = 1
 27580                                  				; (root directory)
 27581 00004861 2EA3[BE47]              	mov	[cs:SRCH_CLUSTER],ax ; 1 ; FAT root directory (<2)
 27582 00004865 48                      	dec	ax ; 0
 27583 00004866 A2[7305]                	mov	[SECCLUSPOS],al
 27584 00004869 48                      	dec	ax ; -1
 27585 0000486A A3[BC05]                	mov	[CLUSNUM],ax ; 0FFFFh
 27586 0000486D A3[E50A]                	mov	[CLUSNUM_HW],ax ; 0FFFFh
 27587                                  
 27588                                  	;mov	ax,[es:bp+0Bh]
 27589 00004870 268B460B                	mov	ax,[es:bp+DPB.FIRST_SECTOR]
 27590                                  	;mov	dx,[es:bp+11h]
 27591 00004874 268B5611                	mov	dx,[es:bp+DPB.DIR_SECTOR]
 27592 00004878 29D0                    	sub	ax,dx
 27593 0000487A A2[7705]                	mov	[CLUSFAC],al
 27594                                  	;mov	[DIRSEC],dx ; *
 27595                                  	;clc
 27596                                  ;setdirsrch_retn:
 27597                                  	;retn
 27598 0000487D EBCE                    	jmp	short SETROOTSRCH3
 27599                                  	;;;
 27600                                  %endif
 27601                                  
 27602                                  ;----------------------------------------------------------------------------
 27603                                  
 27604                                  ; 23/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 27605                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:8A90h
 27606                                  
 27607                                  ; set SFT number and entry in the new internal table (only for FCB calls)
 27608                                  
 27609                                  set_sftfcb_entry:
 27610 0000487F 50                      	push	ax
 27611 00004880 51                      	push	cx
 27612 00004881 52                      	push	dx
 27613 00004882 53                      	push	bx
 27614                                  
 27615                                  	;push	bp
 27616                                  	;push	si
 27617                                  	;push	di              ; ES:DI = SFT entry
 27618                                  
 27619 00004883 E84B00                  	call	find_sft_entry_number
 27620                                  				; ax = SFT entry index number
 27621                                  				;      of the last SFT entry
 27622 00004886 31DB                    	xor	bx,bx
 27623 00004888 B91400                  	mov	cx,20		; find empty entry (slot) in the table
 27624                                  	; Retro DOS v5.0
 27625 0000488B 31D2                    	xor	dx,dx ; *
 27626                                  set_sftfcbe_1:
 27627                                  	;;cmp	cs:(sftfcb_cluster+2)[bx],0
 27628                                  	;cmp	word [cs:bx+sftfcb.cluster+2],0
 27629                                  				; directory (search) starting cluster, hw
 27630 0000488D 2E3997[4847]            	cmp	[cs:bx+sftfcb.cluster+2],dx ; 0
 27631 00004892 7505                    	jnz	short set_sftfcbe_2
 27632                                  	;;cmp	cs:sftfcb_cluster[bx], 
 27633                                  	;cmp	word [cs:bx+sftfcb.cluster],0
 27634                                  				; directory (search) starting cluster, lw
 27635 00004894 2E3997[4647]            	cmp	[cs:bx+sftfcb.cluster],dx ; 0
 27636                                  set_sftfcbe_2:
 27637 00004899 752C                    	jnz	short set_sftfcbe_3
 27638                                  				; not empty (sfcb table) entry
 27639                                  	; Retro DOS v5.0
 27640                                  	;push	cx
 27641                                  
 27642 0000489B 2E8B0E[BE47]            	mov	cx,[cs:SRCH_CLUSTER]
 27643                                  				; search start dir cluster number
 27644                                  	;mov	cs:sftfcb_cluster[bx],cx
 27645 000048A0 2E898F[4647]            	mov	[cs:bx+sftfcb.cluster],cx
 27646                                  				; directory start cluster
 27647 000048A5 2E8B0E[C047]            	mov     cx,[cs:SRCH_CLUSTER_HW]
 27648                                  	
 27649                                  	; PCDOS 7.1 BUG! (This would be '[cs:bx:sftfcb.cluster+2],cx')
 27650                                  	; Erdogan Tan - 23/01/2024
 27651                                  	;mov	cs:sftfcb_cluster[bx]
 27652                                  	;mov	[cs:bx:sftfcb.cluster],cx ; PCDOS 7.1 IBMDOS.COM - DOSCODE:8ABFh
 27653                                  	; Retro DOS v5.0
 27654 000048AA 2E898F[4847]            	mov	[cs:bx+sftfcb.cluster+2],cx
 27655                                  
 27656                                  	;pop	cx
 27657                                  
 27658                                  	;mov	dx,[ss:LASTENT]	; LAST (found) entry in the directory
 27659                                  	;;mov	cs:sftfcb_direntry[bx],dx
 27660                                  	;mov	[cs:bx+sftfcb.direntry],dx
 27661                                  				; directory entry number
 27662 000048AF 368B0E[4803]            	mov	cx,[ss:LASTENT]
 27663 000048B4 2E898F[4A47]            	mov	[cs:bx+sftfcb.direntry],cx	
 27664                                  
 27665 000048B9 93                      	xchg	ax,bx
 27666                                  	;xor	dx,dx ; *
 27667                                  	; dx = 0
 27668 000048BA B90600                  	mov	cx,6		; sftfcb table has 6 byte entries
 27669 000048BD F7F1                    	div	cx
 27670 000048BF 93                      	xchg	ax,bx
 27671 000048C0 2E8887[3247]            	mov	[cs:bx+sft_fcb_table], al
 27672                                  				; put SFT entry number in SFT-FCB
 27673                                  				; table (offset is FCB index number 0 to 19)
 27674 000048C5 EB05                    	jmp     short set_setfcbe_4
 27675                                  set_sftfcbe_3:
 27676                                  	;add	bx,6
 27677 000048C7 83C306                  	add	bx,sftfcb_entry_size ; 6
 27678 000048CA E2C1                    	loop	set_sftfcbe_1
 27679                                  
 27680                                  set_setfcbe_4:
 27681                                  	;pop	di
 27682                                  	;pop	si
 27683                                  	;pop	bp
 27684                                  	
 27685 000048CC 5B                      	pop	bx
 27686 000048CD 5A                      	pop	dx
 27687 000048CE 59                      	pop	cx
 27688 000048CF 58                      	pop	ax
 27689 000048D0 C3                      	retn
 27690                                  
 27691                                  ;----------------------------------------------------------------------------
 27692                                  
 27693                                  ; 24/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 27694                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:8AECh
 27695                                  
 27696                                  find_sft_entry_number:
 27697 000048D1 C3                      	retn
 27698                                  
 27699                                  ;----------------------------------------------------------------------------
 27700                                  
 27701                                  ; 24/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 27702                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:8B22h
 27703                                  
 27704                                  int_2Fh_1230h:
 27705 000048D2 C3                      	retn
 27706                                  
 27707                                  ;----------------------------------------------------------------------------
 27708                                  
 27709                                  ; 24/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 27710                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:8B6Dh
 27711                                  
 27712                                  SFT_FREE:
 27713 000048D3 C3                      	retn
 27714                                  
 27715                                  ;----------------------------------------------------------------------------
 27716                                  
 27717                                  ;============================================================================
 27718                                  ; DIR2.ASM, MSDOS 6.0, 1991
 27719                                  ;============================================================================
 27720                                  ; 27/07/2018 - Retro DOS v3.0
 27721                                  ; 19/05/2019 - Retro DOS v4.0 
 27722                                  
 27723                                  ;	TITLE	DIR2 - Directory and path cracking
 27724                                  ;	NAME	Dir2
 27725                                  
 27726                                  ;Break	<GETPATH -- PARSE A WFP>
 27727                                  ;----------------------------------------------------------------------------
 27728                                  ;
 27729                                  ; Procedure Name : GETPATH
 27730                                  ;
 27731                                  ; Inputs:
 27732                                  ;	[WFP_START] Points to WFP string ("d:\" must be first 3 chars, NUL
 27733                                  ;		terminated; d:/ (note forward slash) indicates a real device).
 27734                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 27735                                  ;		( = -1 if current dir not involved, else
 27736                                  ;		 Points to first char after last "/" of current dir part)
 27737                                  ;	[THISCDS] Points to CDS being used
 27738                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 27739                                  ;	[NoSetDir] set
 27740                                  ;	[THISDPB] set to DPB if disk otherwise garbage.
 27741                                  ; Function:
 27742                                  ;	Crack the path
 27743                                  ; Outputs:
 27744                                  ;	Sets EXTERR_LOCUS = errLOC_Disk if disk file
 27745                                  ;	Sets EXTERR_LOCUS = errLOC_Unk if char device
 27746                                  ;	ID1 field of [THISCDS] updated appropriately
 27747                                  ;	[ATTRIB] = [SATTRIB]
 27748                                  ;	ES:BP Points to DPB
 27749                                  ;	Carry set if bad path
 27750                                  ;	   SI Points to path element causing failure
 27751                                  ;	   Zero set
 27752                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 27753                                  ;	      start a search on the last directory
 27754                                  ;	      CL is zero if there is a bad name in the path
 27755                                  ;	      CL is non-zero if the name was simply not found
 27756                                  ;		 [ENTFREE] may have free spot in directory
 27757                                  ;		 [NAME1] is the name.
 27758                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 27759                                  ;	   Zero reset
 27760                                  ;	      File in middle of path or bad name in path or attribute mismatch
 27761                                  ;		or path too long or malformed path
 27762                                  ;	ELSE
 27763                                  ;	   [CurBuf] = -1 if root directory
 27764                                  ;	   [CURBUF] contains directory record with match
 27765                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 27766                                  ;	   [CURBUF+2]:SI Points into [CURBUF] to dir_first field for entry
 27767                                  ;	   AH = device ID
 27768                                  ;	      bit 7 of AH set if device SI and BX
 27769                                  ;	      will point DOSGROUP relative The firclus
 27770                                  ;	      field of the device entry contains the device pointer
 27771                                  ;	   [NAME1] Has name looked for
 27772                                  ;	   If last element is a directory zero is set and:
 27773                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 27774                                  ;	      are set up to start a search on it.
 27775                                  ;	      unless [NoSetDir] is non zero in which case the return is
 27776                                  ;	      like that for a file (except for zero flag)
 27777                                  ;	   If last element is a file zero is reset
 27778                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 27779                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 27780                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 27781                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 27782                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 27783                                  ; DS preserved, Others destroyed
 27784                                  ;---------------------------------------------------------------------------
 27785                                  
 27786                                  ;hkn; called from delete.asm, finfo.asm, mknode.asm and rename.asm.
 27787                                  ;hkn; DS already set up at this point.
 27788                                  
 27789                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27790                                  GETPATH:
 27791                                  	;mov	word [CREATING],0E500h
 27792 000048D4 C706[7E05]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Not Creating, not DEL *.*
 27793                                  
 27794                                  ; Same as GetPath only CREATING and DELALL already set
 27795                                  
 27796                                  	;entry	GetPathNoSet
 27797                                  GetPathNoSet:
 27798                                  	;mov	byte [EXTERR_LOCUS],2	
 27799 000048DA C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 27800 000048DF C706[E205]FFFF          	MOV	word [CURBUF],-1	; initial setting
 27801                                  
 27802                                  ; See if the input indicates a device that has already been detected. If so,
 27803                                  ; go build the guy quickly. Otherwise, let findpath find the device.
 27804                                  
 27805 000048E5 8B3E[B205]              	MOV	DI,[WFP_START]		; point to the beginning of the name
 27806                                  	;cmp	word [DI+1],5C3Ah
 27807                                  	;CMP	WORD [DI+1],'\' << 8 + ':'
 27808 000048E9 817D013A5C              	cmp	word [DI+1],':\'
 27809 000048EE 7438                    	JZ	short CrackIt
 27810                                  
 27811                                  ; Let ChkDev find it in the device list
 27812                                  
 27813 000048F0 83C703                  	ADD	DI,3
 27814                                  	; 18/08/2018
 27815                                  	;MOV	SI,DI			; let CHKDEV see the original name
 27816                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27817                                  	; 16/12/2022
 27818                                  	;mov	si,di ; not required ! (it is written in CHKDEV proc already!)
 27819 000048F3 E8AB00                  	CALL	CHKDEV
 27820 000048F6 722E                    	JC	short InternalError
 27821                                  
 27822                                  Build_devJ:
 27823 000048F8 A0[6D05]                	MOV	AL,[SATTRIB]
 27824 000048FB A2[6B05]                	MOV	[ATTRIB],AL
 27825                                  	;mov	byte [EXTERR_LOCUS],1
 27826 000048FE C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; In the particular case of
 27827                                  					; "finding" a char device
 27828                                  					; set LOCUS to Unknown. This makes
 27829                                  					; certain idiotic problems reported
 27830                                  					; by a certain 3 letter OEM go away.
 27831                                  
 27832                                  ; Take name in name1 and pack it back into where wfp_start points. This
 27833                                  ; guarantees wfp_start pointing to a canonical representation of a device.
 27834                                  ; We are allowed to do this as GetPath is *ALWAYS* called before entering a
 27835                                  ; wfp into the share set.
 27836                                  ;
 27837                                  ; We copy chars from name1 to wfp_start remembering the position of the last
 27838                                  ; non-space seen +1.  This position is kept in DX.
 27839                                  
 27840                                  ;hkn; SS is DOSDATA
 27841 00004903 16                      	push	ss
 27842 00004904 07                      	pop	es
 27843                                  
 27844                                  ;hkn; NAME1 is in DOSDATA
 27845 00004905 BE[4B05]                	mov	si,NAME1
 27846 00004908 8B3E[B205]              	mov	di,[WFP_START]
 27847 0000490C 89FA                    	mov	dx,di
 27848 0000490E B90800                  	mov	cx,8			; 8 chars in device name
 27849                                  MoveLoop:
 27850 00004911 AC                      	lodsb
 27851 00004912 AA                      	stosb
 27852 00004913 3C20                    	cmp	al," "
 27853 00004915 7402                    	jz	short NoSave
 27854                                  
 27855 00004917 89FA                    	mov	dx,di
 27856                                  NoSave:
 27857 00004919 E2F6                    	loop	MoveLoop
 27858                                  
 27859                                  ; DX is the position of the last seen non-space + 1. We terminate the name
 27860                                  ; at this point.
 27861                                  
 27862 0000491B 89D7                    	mov	di,dx
 27863 0000491D C60500                  	mov	byte [di],0		; end of string
 27864 00004920 E8C402                  	call	Build_device_ent	; Clears carry sets zero
 27865 00004923 FEC0                    	INC	AL			; reset zero
 27866 00004925 C3                      	retn
 27867                                  
 27868                                  InternalError:
 27869                                  InternalError_loop:
 27870 00004926 EBFE                    	JMP	short InternalError_loop	; freeze
 27871                                  
 27872                                  ; Start off at the correct spot. Optimize if the current dir part is valid.
 27873                                  
 27874                                  CrackIt:
 27875 00004928 8B36[B605]              	MOV	SI,[CURR_DIR_END]	; get current directory pointer
 27876 0000492C 83FEFF                  	CMP	SI,-1			; valid?
 27877 0000492F 7503                    	JNZ	short LOOK_SING		; Yes, use it.
 27878 00004931 8D7503                  	LEA	SI,[DI+3]		; skip D:\.
 27879                                  LOOK_SING:
 27880                                  	;mov	byte [ATTRIB],16h
 27881 00004934 C606[6B05]16            	MOV	byte [ATTRIB],attr_directory+attr_system+attr_hidden
 27882                                  					; Attributes to search through Dirs
 27883 00004939 C43E[A205]              	LES	DI,[THISCDS]
 27884 0000493D B8FFFF                  	MOV	AX,-1
 27885                                  	;mov	bx,[es:di+73]
 27886 00004940 268B5D49                	MOV	BX,[ES:DI+curdir.ID]
 27887 00004944 8B36[B605]              	MOV	SI,[CURR_DIR_END]
 27888                                  
 27889                                  ; AX = -1
 27890                                  ; BX = cluster number of current directory. THis number is -1 if the media
 27891                                  ;      has been uncertainly changed.
 27892                                  ; SI = offset in DOSGroup into path to end of current directory text. This
 27893                                  ;      may be -1 if no current directory part has been used.
 27894                                  
 27895 00004948 39C6                    	CMP	SI,AX			; if Current directory is not part
 27896 0000494A 743B                    	JZ	short NO_CURR_D		; then we must crack from root
 27897 0000494C 39C3                    	CMP	BX,AX			; is the current directory cluster valid
 27898                                  
 27899                                  ; DOS 3.3  6/25/86
 27900 0000494E 7437                    	JZ	short NO_CURR_D		; no, crack form the root
 27901                                  	;test	byte [FastOpenFlg],1
 27902 00004950 F606[6D12]01            	TEST	byte [FastOpenFlg],FastOpen_Set ; for fastopen ?
 27903 00004955 743D                    	JZ	short GOT_SEARCH_CLUSTER	; no
 27904 00004957 06                      	PUSH	ES			; save registers
 27905 00004958 57                      	PUSH	DI
 27906 00004959 51                      	PUSH	CX
 27907 0000495A FF74FF                  	PUSH	word [SI-1]		; save \ and 1st char of next element
 27908 0000495D 56                      	PUSH	SI
 27909 0000495E 53                      	PUSH	BX
 27910                                  
 27911 0000495F C644FF00                	MOV	BYTE [SI-1],0		; call fastopen to look up cur dir info
 27912 00004963 8B36[B205]              	MOV	SI,[WFP_START]
 27913                                  
 27914                                  ;hkn; FastOpenTable, Dir_Info_Buff & FastOpen_Ext_Info are in DOSDATA
 27915 00004967 BB[6312]                	MOV	BX,FastOpenTable
 27916 0000496A BF[970D]                	MOV	DI,Dir_Info_Buff
 27917 0000496D B9[8C0D]                	MOV	CX,FastOpen_Ext_Info
 27918                                  	;mov	al,1
 27919 00004970 B001                    	MOV	AL,FONC_Look_up
 27920 00004972 1E                      	PUSH	DS
 27921 00004973 07                      	POP	ES
 27922                                  	;call	far [BX+2]
 27923 00004974 FF5F02                  	CALL	far [BX+fastopen_entry.name_caching]
 27924 00004977 7203                    	JC	short GO_Chk_end1 	;fastopen not installed, or wrong drive.
 27925                                  					; Go to Got_Srch_cluster
 27926                                  	; 29/12/2022
 27927                                  	;CMP	BYTE [SI],0		;fastopen has current dir info?
 27928                                  	;JE	short GO_Chk_end	;yes. Go to got_search_cluster
 27929                                  	;stc
 27930                                  	;jmp	short GO_Chk_end	;Go to No_Curr_D
 27931                                  
 27932 00004979 803C01                  	cmp	byte [si],1
 27933                                  GO_Chk_end1:	; 29/12/2022
 27934 0000497C F5                      	cmc 
 27935                                  	; [si] = 0 -> cf = 0
 27936                                  	; [si] > 0 -> cf = 1
 27937                                  
 27938                                  ;GO_Chk_end1:
 27939                                  	; 29/12/2022
 27940                                  	;clc
 27941                                  
 27942                                  GO_Chk_end:				; restore registers
 27943 0000497D 5B                      	POP	BX
 27944 0000497E 5E                      	POP	SI
 27945 0000497F 8F44FF                  	POP	word [SI-1]
 27946 00004982 59                      	POP	CX
 27947 00004983 5F                      	POP	DI
 27948 00004984 07                      	POP	ES
 27949 00004985 730D                    	JNC	short GOT_SEARCH_CLUSTER ; crack based on cur dir
 27950                                  
 27951                                  ; DOS 3.3  6/25/86
 27952                                  ;
 27953                                  ; We must cract the path beginning at the root. Advance pointer to beginning
 27954                                  ; of path and go crack from root.
 27955                                  
 27956                                  NO_CURR_D:
 27957 00004987 8B36[B205]              	MOV	SI,[WFP_START]
 27958 0000498B 8D7403                  	LEA	SI,[SI+3]		; Skip "d:/"
 27959 0000498E C42E[8A05]              	LES	BP,[THISDPB]		; Get ES:BP
 27960 00004992 EB3B                    	JMP	short ROOTPATH
 27961                                  
 27962                                  ; We are able to crack from the current directory part. Go set up for search
 27963                                  ; of specified cluster.
 27964                                  
 27965                                  GOT_SEARCH_CLUSTER:
 27966 00004994 C42E[8A05]              	LES	BP,[THISDPB]		; Get ES:BP
 27967 00004998 E827FE                  	call	SETDIRSRCH
 27968                                  	;JC	short SETFERR
 27969                                  	;JMP	short FINDPATH
 27970                                  	; 16/12/2022
 27971 0000499B 7342                    	jnc	short FINDPATH ; 17/08/2018
 27972                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27973                                  	;JC	short SETFERR
 27974                                  	;JMP	short FINDPATH
 27975                                  SETFERR:
 27976 0000499D 30C9                    	XOR	CL,CL			; set zero
 27977 0000499F F9                      	STC
 27978 000049A0 C3                      	retn
 27979                                  
 27980                                  ;---------------------------------------------------------------------------
 27981                                  ;
 27982                                  ; Procedure Name : ChkDev
 27983                                  ;
 27984                                  ; Check to see if the name at DS:DI is a device. Returns carry set if not a
 27985                                  ;   device.
 27986                                  ; Blasts CX,SI,DI,AX,BX
 27987                                  ;---------------------------------------------------------------------------
 27988                                  
 27989                                  CHKDEV:
 27990 000049A1 89FE                    	MOV	SI,DI
 27991 000049A3 8CD7                    	MOV	DI,SS
 27992 000049A5 8EC7                    	MOV	ES,DI
 27993                                  
 27994 000049A7 BF[4B05]                	MOV	DI,NAME1
 27995 000049AA B90900                  	MOV	CX,9
 27996                                  TESTLOOP:
 27997 000049AD E84910                  	call	GETLET
 27998                                  
 27999 000049B0 3C2E                    	CMP	AL,'.'
 28000 000049B2 740E                    	JZ	short TESTDEVICE
 28001 000049B4 E89810                  	call	PATHCHRCMP
 28002 000049B7 7407                    	JZ	short NOTDEV
 28003 000049B9 08C0                    	OR	AL,AL
 28004 000049BB 7405                    	JZ	short TESTDEVICE
 28005                                  
 28006 000049BD AA                      	STOSB
 28007 000049BE E2ED                    	LOOP	TESTLOOP
 28008                                  NOTDEV:
 28009 000049C0 F9                      	STC
 28010 000049C1 C3                      	retn
 28011                                  
 28012                                  TESTDEVICE:
 28013                                  	;ADD	CX,2
 28014                                  	; 24/09/2023
 28015 000049C2 41                      	inc	cx
 28016 000049C3 41                      	inc	cx
 28017 000049C4 B020                    	MOV	AL,' '
 28018 000049C6 F3AA                    	REP	STOSB
 28019 000049C8 8CD0                    	MOV	AX,SS
 28020 000049CA 8ED8                    	MOV	DS,AX
 28021                                  	;call	DEVNAME
 28022                                  	;retn
 28023                                  	; 18/12/2022
 28024 000049CC E9B901                  	jmp	DEVNAME
 28025                                  
 28026                                  ;Break	<ROOTPATH, FINDPATH -- PARSE A PATH>
 28027                                  ;----------------------------------------------------------------------------
 28028                                  ;
 28029                                  ; Procedure Name : ROOTPATH,FINDPATH
 28030                                  ;
 28031                                  ; Inputs:
 28032                                  ;	Same as FINDPATH but,
 28033                                  ;	SI Points to asciz string of path which is assumed to start at
 28034                                  ;		the root (no leading '/').
 28035                                  ; Function:
 28036                                  ;	Search from root for path
 28037                                  ; Outputs:
 28038                                  ;	Same as FINDPATH but:
 28039                                  ;	If root directory specified, [CURBUF] and [NAME1] are NOT set, and
 28040                                  ;	[NoSetDir] is ignored.
 28041                                  ;----------------------------------------------------------------------------
 28042                                  
 28043                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28044                                  	; DOSCODE:7F47h (MSDOS 5.0, MSDOS.SYS)
 28045                                  
 28046                                  ROOTPATH:
 28047 000049CF E81CFE                  	call	SETROOTSRCH
 28048                                  	; 24/09/2023
 28049 000049D2 30E4                    	xor	ah,ah
 28050                                  	;CMP	BYTE [SI],0
 28051 000049D4 3824                    	cmp	[si],ah ; 0
 28052 000049D6 7507                    	JNZ	short FINDPATH
 28053                                  
 28054                                  ; Root dir specified
 28055 000049D8 A0[6D05]                	MOV	AL,[SATTRIB]
 28056 000049DB A2[6B05]                	MOV	[ATTRIB],AL
 28057                                  	; 24/09/2023
 28058                                  	;XOR	AH,AH			; Sets "device ID" byte, sets zero
 28059                                  					; (dir), clears carry.
 28060 000049DE C3                      	retn
 28061                                  
 28062                                  ; Inputs:
 28063                                  ;	[ATTRIB] Set to get through directories
 28064                                  ;	[SATTRIB] Set to find last element
 28065                                  ;	ES:BP Points to DPB
 28066                                  ;	SI Points to asciz string of path (no leading '/').
 28067                                  ;	[SECCLUSPOS] = 0
 28068                                  ;	[DIRSEC] = Phys sec # of first sector of directory
 28069                                  ;	[CLUSNUM] = Cluster # of next cluster
 28070                                  ;	[CLUSFAC] = Sectors per cluster
 28071                                  ;	[NoSetDir] set
 28072                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 28073                                  ;		( = -1 if current dir not involved, else
 28074                                  ;		 Points to first char after last "/" of current dir part)
 28075                                  ;	[THISCDS] Points to CDS being used
 28076                                  ;	[CREATING] and [DELALL] set
 28077                                  ; Function:
 28078                                  ;	Parse path name
 28079                                  ; Outputs:
 28080                                  ;	ID1 field of [THISCDS] updated appropriately
 28081                                  ;	[ATTRIB] = [SATTRIB]
 28082                                  ;	ES:BP Points to DPB
 28083                                  ;	[THISDPB] = ES:BP
 28084                                  ;	Carry set if bad path
 28085                                  ;	   SI Points to path element causing failure
 28086                                  ;	   Zero set
 28087                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 28088                                  ;	      start a search on the last directory
 28089                                  ;	      CL is zero if there is a bad name in the path
 28090                                  ;	      CL is non-zero if the name was simply not found
 28091                                  ;		 [ENTFREE] may have free spot in directory
 28092                                  ;		 [NAME1] is the name.
 28093                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 28094                                  ;	   Zero reset
 28095                                  ;	      File in middle of path or bad name in path
 28096                                  ;		or path too long or malformed path
 28097                                  ;	ELSE
 28098                                  ;	   [CURBUF] contains directory record with match
 28099                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 28100                                  ;	   [CURBUF+2]:SI Points to fcb_FIRCLUS field for entry
 28101                                  ;	   [NAME1] Has name looked for
 28102                                  ;	   AH = device ID
 28103                                  ;	      bit 7 of AH set if device SI and BX
 28104                                  ;	      will point DOSGROUP relative The firclus
 28105                                  ;	      field of the device entry contains the device pointer
 28106                                  ;	   If last element is a directory zero is set and:
 28107                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 28108                                  ;	      are set up to start a search on it,
 28109                                  ;	      unless [NoSetDir] is non zero in which case the return is
 28110                                  ;	      like that for a file (except for zero flag)
 28111                                  ;	   If last element is a file zero is reset
 28112                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 28113                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 28114                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 28115                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 28116                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 28117                                  ; Destroys all other registers
 28118                                  
 28119                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28120                                  	; DOSCODE:7F58h (MSDOS 5.0, MSDOS.SYS)
 28121                                  
 28122                                      	;entry	FINDPATH
 28123                                  FINDPATH:
 28124 000049DF 06                      	PUSH	ES			; Save ES:BP
 28125 000049E0 56                      	PUSH	SI
 28126 000049E1 89F7                    	MOV	DI,SI
 28127 000049E3 8B0E[C205]              	MOV	CX,[DIRSTART]		; Get start clus of dir being searched
 28128 000049E7 833E[B605]FF            	CMP	word [CURR_DIR_END],-1
 28129 000049EC 740E                    	JZ	short NOIDS		; No current dir part
 28130 000049EE 3B3E[B605]              	CMP	DI,[CURR_DIR_END]
 28131 000049F2 7508                    	JNZ	short NOIDS		; Not to current dir end yet
 28132 000049F4 C43E[A205]              	LES	DI,[THISCDS]
 28133                                  	;mov	[es:di+73],cx
 28134 000049F8 26894D49                	MOV	[ES:DI+curdir.ID],CX	; Set current directory currency
 28135                                  NOIDS:
 28136                                  
 28137                                  ; Parse the name off of DS:SI into NAME1. AL = 1 if there was a meta
 28138                                  ; character in the string. CX,DI may be destroyed.
 28139                                  ;
 28140                                  ;	invoke	NAMETRANS
 28141                                  ;	MOV	CL,AL
 28142                                  ;
 28143                                  ; The above is the slow method. The name has *already* been munged by
 28144                                  ; TransPath so no special casing needs to be done. All we do is try to copy
 28145                                  ; the name until ., \ or 0 is hit.
 28146                                  
 28147 000049FC 8CD0                    	MOV	AX,SS
 28148 000049FE 8EC0                    	MOV	ES,AX
 28149                                  
 28150                                  ;hkn; Name1 is in DOSDATA
 28151 00004A00 BF[4B05]                	MOV	DI,NAME1
 28152 00004A03 B82020                  	MOV	AX,'  ' ; 2020h
 28153 00004A06 AA                      	STOSB
 28154 00004A07 AB                      	STOSW
 28155 00004A08 AB                      	STOSW
 28156 00004A09 AB                      	STOSW
 28157 00004A0A AB                      	STOSW
 28158 00004A0B AB                      	STOSW
 28159                                  
 28160                                  ;hkn; Name1 is in DOSDATA
 28161 00004A0C BF[4B05]                	MOV	DI,NAME1
 28162 00004A0F 30E4                    	XOR	AH,AH			; bits for CL
 28163                                  GetNam:
 28164                                  	; 19/05/2019 - Retro DOS v4.0
 28165                                  	;INC	CL ; ?*! ; MSDOS 6.0	;AN000; KK increment volid count
 28166                                  
 28167                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28168                                  	; 16/12/2022
 28169                                  	;inc	cl ; not required !	
 28170                                  	
 28171 00004A11 AC                      	LODSB
 28172 00004A12 3C2E                    	CMP	AL,'.'	; 2Eh
 28173 00004A14 7412                    	JZ	short _SetExt
 28174 00004A16 08C0                    	OR	AL,AL
 28175 00004A18 7424                    	JZ	short _GetDone
 28176 00004A1A 3C5C                    	CMP	AL,'\'	; 5Ch
 28177 00004A1C 7420                    	JZ	short _GetDone
 28178 00004A1E 3C3F                    	CMP	AL,'?'	; 3Fh
 28179 00004A20 7503                    	JNZ	short StoNam
 28180 00004A22 80CC01                  	OR	AH,1
 28181                                  StoNam: 
 28182 00004A25 AA                      	STOSB
 28183 00004A26 EBE9                    	JMP	short GetNam
 28184                                  _SetExt:
 28185 00004A28 BF[5305]                	MOV	DI,NAME1+8
 28186                                  GetExt:
 28187 00004A2B AC                      	LODSB
 28188 00004A2C 08C0                    	OR	AL,AL
 28189 00004A2E 740E                    	JZ	short _GetDone
 28190 00004A30 3C5C                    	CMP	AL,'\'
 28191 00004A32 740A                    	JZ	short _GetDone
 28192 00004A34 3C3F                    	CMP	AL,'?'
 28193 00004A36 7503                    	JNZ	short StoExt
 28194 00004A38 80CC01                  	OR	AH,1
 28195                                  StoExt: 
 28196 00004A3B AA                      	STOSB
 28197 00004A3C EBED                    	JMP	short GetExt
 28198                                  _GetDone:
 28199 00004A3E 4E                      	DEC	SI
 28200 00004A3F 88E1                    	MOV	CL,AH  ; 0 or 1 ; 29/12/2022
 28201 00004A41 80C980                  	OR	CL,80H
 28202 00004A44 5F                      	POP	DI			; Start of this element
 28203 00004A45 07                      	POP	ES			; Restore ES:BP
 28204 00004A46 39FE                    	CMP	SI,DI
 28205 00004A48 7503                    	JNZ	short check_device
 28206 00004A4A E9E200                  	JMP	_BADPATH		; NUL parse (two delims most likely)
 28207                                  check_device:
 28208 00004A4D 56                      	PUSH	SI			; Start of next element
 28209                                  	;MOV	AL,[SI]
 28210                                  	;OR	AL,AL
 28211                                  	; 23/09/2023
 28212 00004A4E 803C00                  	cmp	byte [si],0
 28213 00004A51 7508                    	JNZ	short NOT_LAST
 28214                                  
 28215                                  ; for last element of the path switch to the correct search attributes
 28216                                  
 28217 00004A53 8A3E[6D05]              	MOV	BH,[SATTRIB]
 28218 00004A57 883E[6B05]              	MOV	[ATTRIB],BH
 28219                                  
 28220                                  NOT_LAST:
 28221                                  
 28222                                  ; check name1 to see if we have a device...
 28223                                  
 28224 00004A5B 06                      	PUSH	ES			; Save ES:BP
 28225                                  
 28226                                  ;hkn; SS is DOSDATA
 28227                                  	;context ES
 28228 00004A5C 16                      	push	ss
 28229 00004A5D 07                      	pop	es
 28230 00004A5E E82701                  	call	DEVNAME 		; blast BX
 28231 00004A61 07                      	POP	ES			; Restore ES:BP
 28232 00004A62 720B                    	JC	short FindFile		; Not a device
 28233 00004A64 08C0                    	OR	AL,AL			; Test next char again
 28234 00004A66 7403                    	JZ	short GO_BDEV
 28235 00004A68 E9C800                  	JMP	FILEINPATH		; Device name in middle of path
 28236                                  
 28237                                  GO_BDEV:
 28238 00004A6B 5E                      	POP	SI			; Points to NUL at end of path
 28239 00004A6C E989FE                  	JMP	Build_devJ
 28240                                  
 28241                                  FindFile:
 28242                                  ;;;; 7/28/86
 28243 00004A6F 803E[4B05]E5            	CMP	BYTE [NAME1],0E5H	; if 1st char = E5
 28244 00004A74 7505                    	JNZ	short NOE5		; no
 28245 00004A76 C606[4B05]05            	MOV	BYTE [NAME1],05H	; change it to 05
 28246                                  NOE5:
 28247                                  ;;;; 7/28/86
 28248 00004A7B 57                      	PUSH	DI			; Start of this element
 28249 00004A7C 06                      	PUSH	ES			; Save ES:BP
 28250 00004A7D 51                      	PUSH	CX			; CL return from NameTrans
 28251                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 28252                                  
 28253 00004A7E E89502                  	CALL	LookupPath		; call fastopen to get dir entry
 28254 00004A81 7303                    	JNC	short DIR_FOUND		; found dir entry
 28255                                  
 28256                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 28257 00004A83 E86EFB                  	call	FINDENTRY
 28258                                  DIR_FOUND:
 28259 00004A86 59                      	POP	CX
 28260 00004A87 07                      	POP	ES
 28261 00004A88 5F                      	POP	DI
 28262 00004A89 7303                    	JNC	short LOAD_BUF
 28263 00004A8B E9CA00                  	JMP	BADPATHPOP
 28264                                  
 28265                                  LOAD_BUF:
 28266 00004A8E C53E[E205]              	LDS	DI,[CURBUF]
 28267                                  	;test	byte [bx+0Bh],10h
 28268 00004A92 F6470B10                	TEST	BYTE [BX+dir_entry.dir_attr],attr_directory
 28269 00004A96 7503                    	JNZ	short GO_NEXT 		; DOS 3.3
 28270 00004A98 E99800                  	JMP	FILEINPATH		; Error or end of path
 28271                                  
 28272                                  ; if we are not setting the directory, then check for end of string
 28273                                  
 28274                                  GO_NEXT:
 28275                                  ;hkn; SS override
 28276 00004A9B 36803E[4C03]00          	CMP	BYTE [SS:NoSetDir],0
 28277 00004AA1 7423                    	JZ	short SetDir
 28278 00004AA3 89FA                    	MOV	DX,DI			; Save pointer to entry
 28279 00004AA5 8CD9                    	MOV	CX,DS
 28280                                  
 28281                                  ;hkn; SS is DOSDATA
 28282                                  	;context DS
 28283 00004AA7 16                      	push	ss
 28284 00004AA8 1F                      	pop	ds
 28285 00004AA9 5F                      	POP	DI			; Start of next element
 28286                                  	; 19/05/2019 - Retro DOS v4.0
 28287                                  	; MSDOS 6.0
 28288 00004AAA F606[6D12]01            	TEST	byte [FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 28289 00004AAF 740B                    	JZ	short _nofast			; the FastOpen
 28290 00004AB1 F606[6D12]02            	TEST	byte [FastOpenFlg],Lookup_Success ; Lookup just happened
 28291 00004AB6 7404                    	JZ	short _nofast			; no
 28292 00004AB8 8B3E[B70D]              	MOV	DI,[Next_Element_Start]	; no need to insert it again
 28293                                  _nofast:
 28294 00004ABC 803D00                  	CMP	BYTE [DI],0
 28295                                  	;;JNZ	short NEXT_ONE		; DOS 3.3
 28296                                  	;;JMP	_SETRET  ; retn		; Got it
 28297                                  	;retn	; 05/09/2018
 28298                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28299                                  	;jmp	_SETRET
 28300                                  	; 16/12/2022
 28301 00004ABF 7421                    	jz	short _SETRET
 28302                                  
 28303                                  NEXT_ONE:
 28304 00004AC1 57                      	PUSH	DI			; Put start of next element back on stack
 28305 00004AC2 89D7                    	MOV	DI,DX
 28306 00004AC4 8ED9                    	MOV	DS,CX			; Get back pointer to entry
 28307                                  SetDir:
 28308 00004AC6 8B14                    	MOV	DX,[SI] 		; Dir_first
 28309                                  
 28310                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 28311 00004AC8 1E                      	PUSH	DS		      ; save [curbuf+2]
 28312                                  ;hkn; SS is DOSDATA
 28313 00004AC9 16                      	push	ss
 28314 00004ACA 1F                      	pop	ds		      ; set DS Dosgroup
 28315                                  	;test	byte [FastOpenFlg],2
 28316 00004ACB F606[6D12]02            	TEST	byte [FastOpenFlg],Lookup_Success
 28317 00004AD0 7411                    	JZ	short DO_NORMAL	      ; fastopen not in memory or path not
 28318 00004AD2 89D3                    	MOV	BX,DX		      ; not found
 28319 00004AD4 8B3E[BC05]              	MOV	DI,[CLUSNUM]	      ; clusnum was set in LookupPath
 28320 00004AD8 50                      	PUSH	AX		      ; save device id (AH)
 28321 00004AD9 E8E6FC                  	call	SETDIRSRCH
 28322 00004ADC 58                      	POP	AX		      ; restore device id (AH)
 28323 00004ADD 83C402                  	ADD	SP,2		      ; pop ds in stack
 28324 00004AE0 EB37                    	JMP	short FAST_OPEN_SKIP
 28325                                  
 28326                                  	; 16/12/2022
 28327                                  _SETRET:
 28328 00004AE2 C3                      	retn
 28329                                  
 28330                                  DO_NORMAL:
 28331 00004AE3 1F                      	POP	DS			; DS = [curbuf + 2]
 28332                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 28333                                  
 28334 00004AE4 29FB                    	SUB	BX,DI			; Offset into sector of start of entry
 28335 00004AE6 29FE                    	SUB	SI,DI			; Offset into sector of dir_first
 28336 00004AE8 53                      	PUSH	BX
 28337 00004AE9 50                      	PUSH	AX
 28338 00004AEA 56                      	PUSH	SI
 28339 00004AEB 51                      	PUSH	CX
 28340                                  	;push	word [di+6]
 28341 00004AEC FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector]	;AN000;>32mb
 28342                                  	; 19/05/2019
 28343                                  	; MSDOS 6.0
 28344                                  	;push	word [di+8]
 28345 00004AEF FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;AN000;>32mb
 28346 00004AF2 89D3                    	MOV	BX,DX
 28347                                  
 28348                                  ;hkn; SS is DOSDATA
 28349                                  	;context DS
 28350 00004AF4 16                      	push	ss
 28351 00004AF5 1F                      	pop	ds
 28352                                  	;invoke	SETDIRSRCH		; This uses UNPACK which might blow
 28353 00004AF6 E8C9FC                  	call	SETDIRSRCH		; the entry sector buffer
 28354                                  	; 19/05/2019
 28355                                  	; MSDOS 6.0
 28356 00004AF9 8F06[0706]              	POP	word [HIGH_SECTOR]
 28357 00004AFD 5A                      	POP	DX
 28358 00004AFE 7203                    	JC	short SKIP_GETB
 28359                                  	; 22/09/2023
 28360                                  	;;mov	byte [ALLOWED],18h
 28361                                  	;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 28362                                  	;XOR	AL,AL ; *
 28363                                  	;;invoke GETBUFFR		; Get the entry buffer back
 28364                                  	;call	GETBUFFR
 28365 00004B00 E82818                  	call	GETBUFFER ; * ; pre-read
 28366                                  SKIP_GETB:
 28367 00004B03 59                      	POP	CX
 28368 00004B04 5E                      	POP	SI
 28369 00004B05 58                      	POP	AX
 28370 00004B06 5B                      	POP	BX
 28371 00004B07 7305                    	JNC	short SET_THE_BUF
 28372 00004B09 5F                      	POP	DI			; Start of next element
 28373 00004B0A 89FE                    	MOV	SI,DI			; Point with SI
 28374 00004B0C EB21                    	JMP	SHORT _BADPATH
 28375                                  
 28376                                  SET_THE_BUF:
 28377 00004B0E E837F4                  	call	SET_BUF_AS_DIR
 28378 00004B11 8B3E[E205]              	MOV	DI,[CURBUF]
 28379 00004B15 01FE                    	ADD	SI,DI			; Get the offsets back
 28380 00004B17 01FB                    	ADD	BX,DI
 28381                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 28382                                  FAST_OPEN_SKIP:
 28383 00004B19 5F                      	POP	DI			; Start of next element
 28384 00004B1A E89D02                  	CALL	InsertPath		; insert dir entry info
 28385                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 28386 00004B1D 8A05                    	MOV	AL,[DI]
 28387 00004B1F 08C0                    	OR	AL,AL
 28388 00004B21 74BF                    	JZ	short _SETRET		; At end
 28389 00004B23 47                      	INC	DI			; Skip over "/"
 28390 00004B24 89FE                    	MOV	SI,DI			; Point with SI
 28391 00004B26 E8260F                  	call	PATHCHRCMP
 28392 00004B29 7503                    	JNZ	short find_bad_name	; oops
 28393 00004B2B E9B1FE                  	JMP	FINDPATH		; Next element
 28394                                  
 28395                                  find_bad_name:
 28396 00004B2E 4E                      	DEC	SI			; Undo above INC to get failure point
 28397                                  _BADPATH:
 28398 00004B2F 30C9                    	XOR	CL,CL			; Set zero
 28399 00004B31 EB2C                    	JMP	SHORT BADPRET
 28400                                  
 28401                                  FILEINPATH:
 28402 00004B33 5F                      	POP	DI			; Start of next element
 28403                                  
 28404                                  ;hkn; SS is DOSDATA
 28405                                  	;context DS			; Got to from one place with DS gone
 28406 00004B34 16                      	push	ss
 28407 00004B35 1F                      	pop	ds
 28408                                  
 28409                                  ; DOS 3.3 FastOpen
 28410                                  	;test	byte [FastOpenFlg],1
 28411 00004B36 F606[6D12]01            	TEST	byte [FastOpenFlg],FastOpen_Set  ; do this here is we don't want to
 28412 00004B3B 740B                    	JZ	short NO_FAST		; device info to fastopen
 28413                                  	;test	byte [FastOpenFlg],2
 28414 00004B3D F606[6D12]02            	TEST	byte [FastOpenFlg],Lookup_Success
 28415 00004B42 7404                    	JZ	short NO_FAST
 28416 00004B44 8B3E[B70D]              	MOV	DI,[Next_Element_Start]  ; This takes care of one time lookup
 28417                                  					 ; success
 28418                                  NO_FAST:
 28419                                  ; DOS 3.3 FastOpen
 28420 00004B48 8A05                    	MOV	AL,[DI]
 28421 00004B4A 08C0                    	OR	AL,AL
 28422 00004B4C 7404                    	JZ	short INCRET
 28423 00004B4E 89FE                    	MOV	SI,DI			; Path too long
 28424 00004B50 EB0D                    	JMP	SHORT BADPRET
 28425                                  
 28426                                  INCRET:
 28427                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 28428                                  
 28429 00004B52 E86502                  	CALL   InsertPath		; insert dir entry info
 28430                                  
 28431                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 28432 00004B55 FEC0                    	INC	AL			; Reset zero
 28433                                  	; 16/12/2022	
 28434                                  ;_SETRET:
 28435 00004B57 C3                      	retn
 28436                                  
 28437                                  BADPATHPOP:
 28438 00004B58 5E                      	POP	SI			; Start of next element
 28439 00004B59 8A04                    	MOV	AL,[SI]
 28440 00004B5B 89FE                    	MOV	SI,DI			; Start of bad element
 28441 00004B5D 08C0                    	OR	AL,AL			; zero if bad element is last, non-zero if path too long
 28442                                  BADPRET:
 28443 00004B5F A0[6D05]                	MOV	AL,[SATTRIB]
 28444 00004B62 A2[6B05]                	MOV	[ATTRIB],AL		; Make sure return correct
 28445 00004B65 F9                      	STC
 28446 00004B66 C3                      	retn
 28447                                  
 28448                                  ;Break	<STARTSRCH -- INITIATE DIRECTORY SEARCH>
 28449                                  ;---------------------------------------------------------------------------
 28450                                  ;
 28451                                  ; Procedure Name : STARTSRCH
 28452                                  ;
 28453                                  ; Inputs:
 28454                                  ;	[THISDPB] Set
 28455                                  ; Function:
 28456                                  ;	Set up a search for GETENTRY and NEXTENTRY
 28457                                  ; Outputs:
 28458                                  ;	ES:BP = Drive parameters
 28459                                  ;	Sets up LASTENT, ENTFREE=ENTLAST=-1, VOLID=0
 28460                                  ; Destroys ES,BP,AX
 28461                                  ;--------------------------------------------------------------------------
 28462                                  
 28463                                  STARTSRCH:
 28464 00004B67 C42E[8A05]              	LES	BP,[THISDPB]
 28465 00004B6B 31C0                    	XOR	AX,AX
 28466 00004B6D A3[4803]                	MOV	[LASTENT],AX
 28467 00004B70 A2[7B05]                	MOV	[VOLID],AL		; No volume ID found
 28468 00004B73 48                      	DEC	AX
 28469 00004B74 A3[D805]                	MOV	[ENTFREE],AX
 28470 00004B77 A3[DA05]                	MOV	[ENTLAST],AX
 28471 00004B7A C3                      	retn
 28472                                  
 28473                                  ;BREAK <MatchAttributes - the final check for attribute matching>
 28474                                  ;----------------------------------------------------------------------------
 28475                                  ; Procedure Name : MatchAttributes
 28476                                  ;
 28477                                  ; Input:    [Attrib] = attribute to search for
 28478                                  ;	    CH = found attribute
 28479                                  ; Output:   JZ <match>
 28480                                  ;	    JNZ <nomatch>
 28481                                  ; Registers modified: noneski
 28482                                  ;----------------------------------------------------------------------------
 28483                                  
 28484                                  MatchAttributes:
 28485 00004B7B 50                      	PUSH	AX
 28486                                  
 28487                                  ;hkn; SS override
 28488 00004B7C 36A0[6B05]              	MOV	AL,[ss:ATTRIB]		; AL <- SearchSet
 28489 00004B80 F6D0                    	NOT	AL			; AL <- SearchSet'
 28490 00004B82 20E8                    	AND	AL,CH			; AL <- SearchSet' and FoundSet
 28491                                  	;and	al,16h
 28492 00004B84 2416                    	AND	AL,attr_all	; AL <- SearchSet' and FoundSet and Important
 28493                                  ;
 28494                                  ; the result is non-zero if an attribute is not in the search set
 28495                                  ; and in the found set and in the important set. This means that we do not
 28496                                  ; have a match. Do a JNZ <nomatch> or JZ <match>
 28497                                  ;
 28498 00004B86 58                      	POP	AX
 28499 00004B87 C3                      	retn
 28500                                  
 28501                                  ; 19/05/2019 - Retro DOS v4.0
 28502                                  ; DOSCODE:8148h (MSDOS 6.21, MSDOS.SYS)
 28503                                  
 28504                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28505                                  ; DOSCODE:810Dh (MSDOS 5.0, MSDOS.SYS)
 28506                                  
 28507                                  ;Break <DevName - Look for name of device>
 28508                                  ;---------------------------------------------------------------------------
 28509                                  ;
 28510                                  ; Procedure Name : DevName
 28511                                  ;
 28512                                  ; Inputs:
 28513                                  ;	DS,ES:DOSDATA
 28514                                  ;	Filename in NAME1
 28515                                  ;	ATTRIB set so that we can error out if looking for Volume IDs
 28516                                  ; Function:
 28517                                  ;	Determine if file is in list of I/O drivers
 28518                                  ; Outputs:
 28519                                  ;	Carry set if not a device
 28520                                  ;	ELSE
 28521                                  ;	Zero flag set
 28522                                  ;	BH = Bit 7,6 = 1, bit 5 = 0 (cooked mode)
 28523                                  ;	     bits 0-4 set from low byte of attribute word
 28524                                  ;	DEVPT = DWORD pointer to Device header of device
 28525                                  ; BX destroyed, others preserved
 28526                                  ;---------------------------------------------------------------------------
 28527                                  
 28528                                  DEVNAME:
 28529                                  	; 28/07/2018 - Retro DOS v3.0
 28530                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 49FBh
 28531                                  
 28532 00004B88 56                      	PUSH	SI
 28533 00004B89 57                      	PUSH	DI
 28534 00004B8A 51                      	PUSH	CX
 28535 00004B8B 50                      	PUSH	AX
 28536                                  
 28537                                  ; E5 special code
 28538 00004B8C FF36[4B05]              	PUSH	WORD [NAME1]
 28539 00004B90 803E[4B05]05            	CMP	byte [NAME1],5
 28540 00004B95 7505                    	JNZ	short NOKTR
 28541 00004B97 C606[4B05]E5            	MOV	byte [NAME1],0E5h
 28542                                  NOKTR:
 28543                                  	;test	byte [ATTRIB],8
 28544 00004B9C F606[6B05]08            	TEST	byte [ATTRIB],attr_volume_id
 28545                                  					; If looking for VOL id don't find devs
 28546 00004BA1 7521                    	JNZ	short RET31
 28547                                  
 28548                                  ;hkn; NULDEV is in DOSDATA
 28549 00004BA3 BE[4800]                	MOV	SI,NULDEV
 28550                                  LOOKIO:
 28551                                  	; 21/11/2022
 28552                                  	;test	byte [SI+SYSDEV.ATT+1],80h
 28553                                  	; 17/12/2022
 28554                                  	;test	byte [si+5],80h
 28555 00004BA6 F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8)
 28556                                  	;;test	word [si+4],8000h
 28557                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP
 28558 00004BAA 7411                    	JZ	short SKIPDEV 		; Skip block devices (NET and LOCAL)
 28559 00004BAC 89F0                    	MOV	AX,SI
 28560                                  	;add	si,10
 28561 00004BAE 83C60A                  	ADD	SI,SYSDEV.NAME
 28562                                  
 28563                                  ;hkn; NAME1 is in DOSDATA
 28564 00004BB1 BF[4B05]                	MOV	DI,NAME1
 28565 00004BB4 B90400                  	MOV	CX,4			; All devices are 8 letters
 28566 00004BB7 F3A7                    	REPE	CMPSW			; Check for name in list
 28567 00004BB9 89C6                    	MOV	SI,AX
 28568 00004BBB 7415                    	JZ	short IOCHK		; Found it?
 28569                                  SKIPDEV:
 28570 00004BBD C534                    	LDS	SI,[SI]			; Get address of next device
 28571 00004BBF 83FEFF                  	CMP	SI,-1			; At end of list?
 28572 00004BC2 75E2                    	JNZ	short LOOKIO
 28573                                  RET31:	
 28574 00004BC4 F9                      	STC				; Not found
 28575                                  RETNV:	
 28576 00004BC5 8CD1                    	MOV	CX,SS
 28577 00004BC7 8ED9                    	MOV	DS,CX
 28578                                  
 28579 00004BC9 8F06[4B05]              	POP	WORD [NAME1]
 28580 00004BCD 58                      	POP	AX
 28581 00004BCE 59                      	POP	CX
 28582 00004BCF 5F                      	POP	DI
 28583 00004BD0 5E                      	POP	SI
 28584 00004BD1 C3                      	RETN
 28585                                  
 28586                                  IOCHK:
 28587                                  ;hkn; SS override for DEVPT
 28588 00004BD2 368C1E[9C05]            	MOV	[SS:DEVPT+2],DS		; Save pointer to device
 28589                                  	;mov	bh,[si+4]
 28590 00004BD7 8A7C04                  	MOV	BH,[SI+SYSDEV.ATT]
 28591 00004BDA 80CFC0                  	OR	BH,0C0h
 28592 00004BDD 80E7DF                  	and	bh,0DFh
 28593                                  	;AND	BH,~(020h)		; Clears Carry
 28594 00004BE0 368936[9A05]            	MOV	[SS:DEVPT],SI
 28595 00004BE5 EBDE                    	JMP	short RETNV
 28596                                  
 28597                                  ;BREAK <Build_device_ent - Make a Directory entry>
 28598                                  ;---------------------------------------------------------------------------
 28599                                  ; Procedure Name : Build_device_ent
 28600                                  ;
 28601                                  ; Inputs:
 28602                                  ;	[NAME1] has name
 28603                                  ;	BH is attribute field (supplied by DEVNAME)
 28604                                  ;	[DEVPT] points to device header (supplied by DEVNAME)
 28605                                  ; Function:
 28606                                  ;	Build a directory entry for a device at DEVFCB
 28607                                  ; Outputs:
 28608                                  ;	BX points to DEVFCB
 28609                                  ;	SI points to dir_first field
 28610                                  ;	AH = input BH
 28611                                  ;	AL = 0
 28612                                  ;	dir_first = DEVPT
 28613                                  ;	Zero Set, Carry Clear
 28614                                  ; DS,ES,BP preserved, others destroyed
 28615                                  ;--------------------------------------------------------------------------
 28616                                  
 28617                                  Build_device_ent:
 28618 00004BE7 B82020                  	MOV	AX,"  " ; 2020h
 28619                                  
 28620                                  ;hkn; DEVFCB is in DOSDATA
 28621 00004BEA BF[5305]                	MOV	DI,DEVFCB+8		; Point to extent field
 28622                                  
 28623                                  ;	Fill dir_ext  BUGBUG - use ERRNZs for this stuff!
 28624                                  
 28625 00004BED AB                      	STOSW
 28626 00004BEE AA                      	STOSB				; Blank out extent field
 28627                                  	;mov	al,40h
 28628 00004BEF B040                    	MOV	AL,attr_device
 28629                                  
 28630                                  ;	Fill Dir_attr
 28631                                  
 28632 00004BF1 AA                      	STOSB				; Set attribute field
 28633 00004BF2 31C0                    	XOR	AX,AX
 28634 00004BF4 B90A00                  	MOV	CX,10
 28635                                  
 28636                                  ; Fill dir_pad
 28637                                  
 28638 00004BF7 F3AB                    	REP	STOSW			; Fill rest with zeros
 28639 00004BF9 E870BF                  	call	DATE16
 28640                                  
 28641                                  ;hkn; DEVFCB is in DOSDATA
 28642 00004BFC BF[6105]                	MOV	DI,DEVFCB+dir_entry.dir_time ; 09/08/2018
 28643 00004BFF 92                      	XCHG	AX,DX
 28644                                  
 28645                                  ; Fill dir_time
 28646                                  
 28647 00004C00 AB                      	STOSW
 28648 00004C01 92                      	XCHG	AX,DX
 28649                                  
 28650                                  ; Fill dir_date
 28651                                  
 28652 00004C02 AB                      	STOSW
 28653 00004C03 89FE                    	MOV	SI,DI			; SI points to dir_first field
 28654 00004C05 A1[9A05]                	MOV	AX,[DEVPT]
 28655                                  
 28656                                  ; Fill dir_first
 28657                                  
 28658 00004C08 AB                      	STOSW				; Dir_first points to device
 28659 00004C09 A1[9C05]                	MOV	AX,[DEVPT+2]
 28660                                  ;
 28661                                  ; Fill dir_size_l
 28662                                  ;
 28663 00004C0C AB                      	STOSW
 28664 00004C0D 88FC                    	MOV	AH,BH			; Put device atts in AH
 28665                                  
 28666                                  ;hkn; DEVFCB is in DOSDATA
 28667 00004C0F BB[4B05]                	MOV	BX,DEVFCB
 28668 00004C12 30C0                    	XOR	AL,AL			; Set zero, clear carry
 28669 00004C14 C3                      	retn
 28670                                  
 28671                                  ;Break	<ValidateCDS - given a CDS, validate the media and the current directory>
 28672                                  ;----------------------------------------------------------------------------
 28673                                  ;
 28674                                  ;   ValidateCDS - Get current CDS. Splice it. Call FatReadCDS to check
 28675                                  ;   media. If media has been changed, do DOS_Chdir to validate path.
 28676                                  ;   If invalid, reset original CDS to root.
 28677                                  ;
 28678                                  ;   Inputs:	ThisCDS points to CDS of interest
 28679                                  ;		SS:DI points to temp buffer
 28680                                  ;   Outputs:	The current directory string is validated on the appropriate
 28681                                  ;		    drive
 28682                                  ;		ThisDPB changed
 28683                                  ;		ES:DI point to CDS
 28684                                  ;		Carry set if error (currently user FAILed to I 24)
 28685                                  ;   Registers modified: all
 28686                                  ;----------------------------------------------------------------------------
 28687                                  
 28688                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28689                                  	; DOSCODE:819Bh (MSDOS 5.0, MSDOS.SYS)
 28690                                  
 28691                                  ValidateCDS:
 28692                                  	; 19/05/2019 - Retro DOS v4.0
 28693                                  	; 28/07/2018 - Retro DOS v3.0
 28694                                  
 28695                                     %define  Temp	[bp-2]	; word
 28696                                     %define  SaveCDS	[bp-6]	; dword
 28697                                     %define  SaveCDSL	[bp-6]	; word
 28698                                     %define  SaveCDSH	[bp-4]	; word
 28699                                  
 28700                                  	;Enter
 28701 00004C15 55                      	push	bp
 28702 00004C16 89E5                    	mov	bp,sp
 28703 00004C18 83EC06                  	sub	sp,6
 28704                                  
 28705 00004C1B 897EFE                  	MOV	Temp,DI
 28706                                  
 28707                                  ;hkn; SS override
 28708 00004C1E 36C536[A205]            	LDS	SI,[SS:THISCDS]
 28709 00004C23 8976FA                  	MOV	SaveCDSL,SI
 28710 00004C26 8C5EFC                  	MOV	SaveCDSH,DS
 28711                                  	;EnterCrit critDisk
 28712 00004C29 E8D7CC                  	call	ECritDisk
 28713                                  	; 21/11/2022
 28714                                  	;test	byte [SI+curdir.flags+1],80h
 28715                                  	;test	word [si+67],8000h
 28716                                  	; 17/12/2022
 28717                                  	;test	byte [SI+68],80h
 28718 00004C2C F6444480                	test	byte [SI+curdir.flags+1],(curdir_isnet>>8)
 28719                                  	;TEST	word [SI+curdir.flags],curdir_isnet	; Clears carry
 28720 00004C30 7403                    	JZ	short _DoSplice
 28721 00004C32 E99200                  	JMP	FatFail
 28722                                  _DoSplice:
 28723 00004C35 30D2                    	XOR	DL,DL
 28724 00004C37 368616[4C03]            	XCHG	DL,[SS:NoSetDir]
 28725                                  
 28726                                  ;hkn; SS is DOSDATA
 28727                                  	;Context ES
 28728 00004C3C 16                      	push	ss
 28729 00004C3D 07                      	pop	es
 28730                                  	;Invoke	FStrcpy
 28731 00004C3E E897CB                  	call	FStrCpy
 28732 00004C41 8B76FE                  	MOV	SI,Temp
 28733                                  
 28734                                  ;hkn; SS is DOSDATA
 28735                                  	;Context DS
 28736 00004C44 16                      	push	ss
 28737 00004C45 1F                      	pop	ds	
 28738                                  	;Invoke	Splice
 28739 00004C46 E8972B                  	call	Splice
 28740                                  
 28741                                   ;hkn; SS is DOSDATA
 28742                                  	;Context DS			;   FatReadCDS (ThisCDS);
 28743 00004C49 16                      	push	ss
 28744 00004C4A 1F                      	pop	ds
 28745 00004C4B 8816[4C03]              	MOV	[NoSetDir],DL
 28746 00004C4F C43E[A205]              	LES	DI,[THISCDS]
 28747                                  	;SAVE	<BP>
 28748 00004C53 55                      	push	bp
 28749                                  	;Invoke	FATREAD_CDS
 28750 00004C54 E83214                  	call	FATREAD_CDS	
 28751                                  	;RESTORE <BP>
 28752 00004C57 5D                      	pop	bp
 28753 00004C58 726D                    	JC	short FatFail
 28754                                  
 28755 00004C5A C536[A205]              	LDS	SI,[THISCDS]		;   if (ThisCDS->ID == -1) {
 28756                                  	;cmp	word [si+73],-1
 28757 00004C5E 837C49FF                	CMP	word [SI+curdir.ID],-1
 28758 00004C62 7555                    	JNZ	short RestoreCDS
 28759                                  
 28760                                  ;hkn; SS is DOSDATA
 28761                                  	;Context ES
 28762 00004C64 16                      	push	ss
 28763 00004C65 07                      	pop	es
 28764                                  
 28765                                  ;hkn; SS override
 28766                                  	;SAVE	<wfp_Start>		;	t = wfp_Start;
 28767 00004C66 36FF36[B205]            	push	word [SS:WFP_START]
 28768                                  	;cmp	si,[bp-6]
 28769 00004C6B 3B76FA                  	CMP	SI,SaveCDSL		; if not spliced
 28770 00004C6E 750B                    	JNZ	short DoChdir
 28771                                  	;mov	di,[bp-2]
 28772 00004C70 8B7EFE                  	MOV	DI,Temp
 28773                                  
 28774                                  ;hkn; SS override
 28775 00004C73 36893E[B205]            	MOV	[SS:WFP_START],DI	;	wfp_start = d;
 28776                                  	;Invoke	FStrCpy 		;	strcpy (d, ThisCDS->Text);
 28777 00004C78 E85DCB                  	call	FStrCpy
 28778                                  DoChdir:
 28779                                  ;hkn; SS is DOSDATA
 28780                                  	;Context DS
 28781 00004C7B 16                      	push	ss
 28782 00004C7C 1F                      	pop	ds
 28783                                  	;SAVE	<<WORD PTR SAttrib>,BP> ;	c = DOSChDir ();
 28784 00004C7D FF36[6D05]              	push	word [SATTRIB]
 28785 00004C81 55                      	push	bp
 28786                                  	;Invoke	DOS_ChDir
 28787 00004C82 E8AEED                  	call	DOS_CHDIR
 28788                                  	;RESTORE <BP,BX,wfp_start>	;	wfp_Start = t;
 28789 00004C85 5D                      	pop	bp
 28790 00004C86 5B                      	pop	bx
 28791 00004C87 8F06[B205]              	pop	word [WFP_START]
 28792 00004C8B 881E[6D05]              	MOV	[SATTRIB],BL
 28793 00004C8F C576FA                  	LDS	SI,SaveCDS
 28794 00004C92 730F                    	JNC	short SetCluster	;	if (c == -1) {
 28795                                  
 28796                                  ;hkn; SS override for THISCDS
 28797 00004C94 368936[A205]            	MOV	[SS:THISCDS],SI		;	    ThisCDS = TmpCDS;
 28798 00004C99 368C1E[A405]            	MOV	[SS:THISCDS+2],DS
 28799 00004C9E 31C9                    	XOR	CX,CX			;	    TmpCDS->text[3] = c = 0;
 28800 00004CA0 884C03                  	MOV	[SI+3],CL		;	    }
 28801                                  SetCluster:
 28802                                  	;mov	word [si+73],0FFFFh
 28803 00004CA3 C74449FFFF              	MOV	word [SI+curdir.ID],-1	;	TmpCDS->ID = -1;
 28804 00004CA8 36C536[A205]            	LDS	SI,[SS:THISCDS]		;	ThisCDS->ID = c;
 28805                                  	; 21/11/2022
 28806                                  	;test	byte [si+curdir.flags+1],20h
 28807                                  	; 19/05/2019
 28808                                  	; MSDOS 6.0
 28809                                  	; 17/12/2022
 28810                                  	;test	byte [si+68],20h
 28811 00004CAD F6444420                	test	byte [SI+curdir.flags+1],(curdir_splice>>8)	
 28812                                  	;;test	word [si+67],2000h
 28813                                  	;TEST	word [SI+curdir.flags],curdir_splice ;AN000;;MS. for Join and Subst
 28814 00004CB1 7403                    	JZ	short _setdirclus		     ;AN000;;MS.
 28815 00004CB3 B9FFFF                  	MOV	CX,-1				     ;AN000;;MS.
 28816                                  _setdirclus:
 28817                                  	;mov	[si+73],cx
 28818 00004CB6 894C49                  	MOV	[SI+curdir.ID],CX	;	}
 28819                                  RestoreCDS:
 28820 00004CB9 C47EFA                  	LES	DI,SaveCDS
 28821 00004CBC 36893E[A205]            	MOV	[SS:THISCDS],DI
 28822 00004CC1 368C06[A405]            	MOV	[SS:THISCDS+2],ES
 28823 00004CC6 F8                      	CLC
 28824                                  FatFail:
 28825                                  	;LeaveCrit critDisk
 28826 00004CC7 E866CC                  	call	LCritDisk
 28827                                  
 28828                                  	;les	di,[bp-6]
 28829 00004CCA C47EFA                  	LES	DI,SaveCDS
 28830                                  	;Leave
 28831 00004CCD 89EC                    	mov	sp,bp
 28832 00004CCF 5D                      	pop	bp
 28833 00004CD0 C3                      	retn
 28834                                  
 28835                                  ; 28/07/2018 - Retro DOS v3.0
 28836                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - offset 43BDh
 28837                                  
 28838                                  ;Break	<CheckThisDevice - Check for being a device>
 28839                                  ;---------------------------------------------------------------------------
 28840                                  ;
 28841                                  ;   CheckThisDevice - Examine the area at DS:SI to see if there is a valid
 28842                                  ;   device specified. We will return carry if there is a device present. 
 28843                                  ;   The forms of devices we will recognize are:
 28844                                  ;
 28845                                  ;	[path]device
 28846                                  ;
 28847                                  ;   Note that the drive letter has *already* been removed. All other forms
 28848                                  ;   are not considered to be devices. If such a device is found we change
 28849                                  ;   the source pointer to point to the device component.
 28850                                  ;
 28851                                  ;   Inputs:	ES is DOSDATA
 28852                                  ;		DS:SI contains name
 28853                                  ;   Outputs:	ES is DOSDATA
 28854                                  ;		DS:SI point to name or device
 28855                                  ;		Carry flag set if device was found
 28856                                  ;		Carry flag reset otherwise
 28857                                  ;   Registers Modified: all except ES:DI, DS
 28858                                  ;----------------------------------------------------------------------------
 28859                                  
 28860                                  CheckThisDevice:
 28861 00004CD1 57                      	push	di
 28862 00004CD2 56                      	push	si
 28863 00004CD3 89F7                    	MOV	DI,SI
 28864                                  
 28865                                  ; Check for presence of \dev\ (Dam multiplan!)
 28866                                  
 28867 00004CD5 8A04                    	MOV	AL,[SI]
 28868 00004CD7 E8750D                  	call	PATHCHRCMP		; is it a path char?
 28869 00004CDA 7517                    	JNZ	short ParseDev		; no, go attempt to parse device
 28870 00004CDC 46                      	INC	SI			; simulate LODSB
 28871                                  
 28872                                  ; We have the leading path separator. Look for DEV part.
 28873                                  
 28874 00004CDD AD                      	LODSW
 28875 00004CDE 0D2020                  	OR	AX,2020h
 28876 00004CE1 3D6465                  	cmp	ax,"de"
 28877                                  	;CMP	AX,"e"<< 8 + "d"
 28878 00004CE4 752D                    	JNZ	short NotDevice		; not "de", assume not device
 28879 00004CE6 AC                      	LODSB
 28880 00004CE7 0C20                    	OR	AL,20h
 28881 00004CE9 3C76                    	CMP	AL,"v"                  ; Not "v", assume not device
 28882 00004CEB 7526                    	JNZ	short NotDevice
 28883 00004CED AC                      	LODSB
 28884 00004CEE E85E0D                  	call	PATHCHRCMP		; do we have the last path separator?
 28885 00004CF1 7520                    	JNZ	short NotDevice		; no. go for it.
 28886                                  
 28887                                  ; DS:SI now points to a potential drive. Preserve them as NameTrans advances
 28888                                  ; SI and DevName may destroy DS.
 28889                                  
 28890                                  ParseDev:
 28891 00004CF3 1E                      	push	ds
 28892 00004CF4 56                      	push	si			; preserve the source pointer
 28893 00004CF5 E8950C                  	call	NameTrans		; advance DS:SI
 28894 00004CF8 803C00                  	CMP	BYTE [SI],0		; parse entire string?
 28895 00004CFB F9                      	STC				; simulate a Carry return from DevName
 28896 00004CFC 750B                    	JNZ	short SkipSearch	; no parse. simulate a file return.
 28897                                  
 28898                                  ;hkn; SS is DOSDATA
 28899 00004CFE 16                      	push	ss
 28900 00004CFF 1F                      	pop	ds
 28901                                  
 28902                                  ; M026 - start - fix ported from ROMDOS2 for bug # 2849
 28903                                  ;
 28904                                  ; SR;
 28905                                  ; We have to set Attrib before invoking DevName. Otherwise, the value from
 28906                                  ; a previous DOS call is used and DevName thinks it is not a device if the
 28907                                  ; old call set the volume attribute bit.
 28908                                  
 28909 00004D00 A0[6D05]                	mov	al,[SATTRIB]
 28910 00004D03 A2[6B05]                	mov	[ATTRIB],al		;set Attrib for DevName
 28911                                  
 28912                                  ; M026 - end
 28913                                  
 28914 00004D06 E87FFE                  	call	DEVNAME
 28915                                  
 28916                                  SkipSearch:
 28917 00004D09 5E                      	pop	si
 28918 00004D0A 1F                      	pop	ds
 28919                                  
 28920                                  ; SI points to the beginning of the potential device. If we have a device
 28921                                  ; then we do not change SI. If we have a file, then we reset SI back to the
 28922                                  ; original value. At this point Carry set indicates FILE.
 28923                                  
 28924                                  CheckReturn:
 28925 00004D0B 5F                      	pop	di			; get original SI
 28926 00004D0C 7302                    	JNC	short Check_Done	; if device then do not reset pointer
 28927 00004D0E 89FE                    	MOV	SI,DI
 28928                                  Check_Done:
 28929 00004D10 5F                      	pop	di
 28930 00004D11 F5                      	CMC				; invert carry. Carry => device
 28931 00004D12 C3                      	retn
 28932                                  NotDevice:
 28933 00004D13 F9                      	STC
 28934 00004D14 EBF5                    	JMP	short CheckReturn
 28935                                  
 28936                                  ;BREAK <LookupPath - call fastopen to get dir entry info>
 28937                                  ;-----------------------------------------------------------------------------
 28938                                  ;
 28939                                  ; Procedure Name : LookupPath
 28940                                  ;
 28941                                  ; Output  DS:SI -> path name,
 28942                                  ;	  ES:DI -> dir entry info buffer
 28943                                  ;	  ES:CX -> extended dir info buffer
 28944                                  ;
 28945                                  ;	  carry flag clear : tables pointed by ES:DI and ES:CX are filled by
 28946                                  ;			     FastOpen, DS:SI points to char just one after
 28947                                  ;			     the last char of path name which is fully or
 28948                                  ;			     partially found in FastOPen
 28949                                  ;	  carry flag set : FastOpen not in memory or path name not found
 28950                                  ;
 28951                                  ;----------------------------------------------------------------------------
 28952                                  
 28953                                  LookupPath:
 28954                                  ;	PUSH	AX
 28955                                  
 28956                                  ;hkn; SS override
 28957                                  	;test	byte [ss:FastOpenFlg],1
 28958 00004D16 36F606[6D12]01          	TEST	byte [ss:FastOpenFlg],FastOpen_Set  ; flg is set in DOSOPEN
 28959 00004D1C 7503                    	JNZ	short FASTINST			    ; and this routine is
 28960                                  NOLOOK:
 28961 00004D1E E99700                  	JMP	NOLOOKUP			    ; executed once
 28962                                  
 28963                                  FASTINST:
 28964                                  ;hkn; SS override
 28965                                  	;test	byte [ss:FastOpenFlg],8
 28966 00004D21 36F606[6D12]08          	TEST	byte [ss:FastOpenFlg],No_Lookup	    ; no more lookup?
 28967 00004D27 75F5                    	JNZ	short NOLOOK			    ; yes
 28968                                  
 28969 00004D29 BB[6312]                	MOV	BX,FastOpenTable		    ; get fastopen related tab
 28970                                  
 28971                                  ;hkn; SS override
 28972 00004D2C 368B36[B205]            	MOV	SI,[SS:WFP_START]		    ; si points to path name
 28973 00004D31 BF[970D]                	MOV	DI,Dir_Info_Buff
 28974 00004D34 B9[8C0D]                	MOV	CX,FastOpen_Ext_Info
 28975 00004D37 B001                    	MOV	AL,FONC_Look_up 		    ; al = 1
 28976 00004D39 1E                      	PUSH	DS
 28977 00004D3A 07                      	POP	ES
 28978                                  
 28979                                  ;hkn; SS override
 28980                                  	;call	far [bx+2]
 28981 00004D3B FF5F02                  	CALL	far [BX+fastopen_entry.name_caching] ;call fastopen
 28982 00004D3E 7267                    	JC	short NOTFOUND			    ; fastopen not in memory
 28983                                  
 28984 00004D40 8D5CFE                  	LEA	BX,[SI-2]
 28985                                  
 28986                                  ;hkn; SS override
 28987 00004D43 363B1E[B205]            	CMP	BX,[SS:WFP_START]		    ; path found ?
 28988 00004D48 745D                    	JZ	short NOTFOUND			    ; no
 28989                                  
 28990                                  	; 19/05/2019 - Retro DOS v4.0
 28991                                  
 28992                                  	; MSDOS 6.0				    ; fully or partially found
 28993 00004D4A 803C00                  	CMP	BYTE [SI],0			    ;AN000;FO.
 28994 00004D4D 751A                    	JNZ	short parfnd			    ;AN000;FO.; partiallyfound
 28995 00004D4F 51                      	PUSH	CX				    ;AN000;FO.; is attribute matched ?
 28996                                  
 28997                                  ;hkn; SS override for attrib/sattrib
 28998 00004D50 368A0E[6B05]            	MOV	CL,[ss:ATTRIB]			    ;AN000;FO.;
 28999 00004D55 368A2E[6D05]            	MOV	CH,[ss:SATTRIB]			    ;AN000;FO.; attrib=sattrib
 29000 00004D5A 36882E[6B05]            	MOV	[ss:ATTRIB],CH			    ;AN000;FO.;
 29001                                  	;mov	ch,[es:di+0Bh]
 29002 00004D5F 268A6D0B                	MOV	CH,[ES:DI+dir_entry.dir_attr]	    ;AN000;FO.;
 29003 00004D63 E815FE                  	call	MatchAttributes 		    ;AN000;FO.;
 29004                                  ;;;	MOV	[ss:ATTRIB],CL			    ;AN001;FO.; restore attrib
 29005 00004D66 59                      	POP	CX				    ;AN000;FO.;
 29006 00004D67 754F                    	JNZ	short NOLOOKUP			    ;AN000;FO.; not matched
 29007                                  parfnd:
 29008                                  
 29009                                  ;hkn; SS override
 29010 00004D69 368936[B70D]            	MOV	[SS:Next_Element_Start],SI	    ; save si
 29011 00004D6E 89CB                    	MOV	BX,CX
 29012                                  	; MSDOS 6.0
 29013                                  	;mov	ax,[bx+7]
 29014 00004D70 8B4707                  	MOV	AX,[BX+FEI.lastent]		    ;AN000;;FO. restore lastentry
 29015                                  ;hkn; SS override for LASTENT, DIRSTART, CLUSNUM
 29016 00004D73 36A3[4803]              	MOV	[SS:LASTENT],AX			    ;AN000;;FO.
 29017 00004D77 8B4709                  	MOV	AX,[BX+FEI.dirstart]		    ;AN001;;FO. restore dirstart
 29018 00004D7A 36A3[C205]              	MOV	[SS:DIRSTART],AX		    ;AN001;;FO.
 29019                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29020                                  	;;mov	ax,[bx+3] ; MSDOS 3.3
 29021                                  	;mov	ax,[bx+5] ; MSDOS 6.0
 29022 00004D7E 8B4705                  	MOV	AX,[BX+FEI.clusnum]		    ; restore next cluster num
 29023 00004D81 36A3[BC05]              	MOV	[SS:CLUSNUM],AX			    ;
 29024                                  
 29025 00004D85 06                      	PUSH	ES				    ; save ES
 29026                                  ;hkn; SS override
 29027 00004D86 36C41E[8A05]            	LES	BX,[SS:THISDPB]			    ; put drive id
 29028 00004D8B 268A27                  	mov	ah,[ES:BX] ; 15/08/2018
 29029                                  	;MOV	AH,[ES:BX+DPB.DRIVE]		    ; in AH for DOOPEN
 29030 00004D8E 07                      	POP	ES				    ; pop ES
 29031                                  ;SR;
 29032                                  ; We cannot have a root dir if we have come here. So, we zero out CurBuf to
 29033                                  ;indicate it is not a root dir
 29034                                  
 29035 00004D8F 36C706[E205]0000        	mov	word [SS:CURBUF],0		    ; indicate not root dir
 29036 00004D96 368C06[E405]            	MOV	WORD [SS:CURBUF+2],ES		    ; [curbuf+2].bx points to
 29037 00004D9B 89FB                    	MOV	BX,DI				    ; start of entry
 29038                                  	;lea	si,[di+1Ah]
 29039 00004D9D 8D751A                  	LEA	SI,[DI+dir_entry.dir_first]	    ; [curbuf+2]:si points to
 29040                                  						    ; dir_first field in the
 29041                                  						    ; dir entry
 29042                                  ;hkn; SS override for FastOpenFlg
 29043                                  	;or	byte [ss:FastOpenFlg],12h ; 29/12/2022
 29044 00004DA0 36800E[6D12]12          	OR	byte [SS:FastOpenFlg],Lookup_Success+Set_For_Search
 29045                                  ;	POP	AX
 29046 00004DA6 C3                      	RETN
 29047                                  NOTFOUND:
 29048 00004DA7 83F8FF                  	CMP	AX,-1				    ; not in memory ?
 29049 00004DAA 7506                    	JNZ	short Partial_Success 		    ; yes, in memory
 29050 00004DAC 36C606[6D12]00          	MOV	byte [SS:FastOpenFlg],0		    ; no more fastopen
 29051                                  Partial_Success:
 29052                                  	;and	byte [SS:FastOpenFlg],0FBh
 29053 00004DB2 368026[6D12]FB          	AND	byte [SS:FastOpenFlg],Special_Fill_Reset
 29054                                  NOLOOKUP:
 29055                                  ;	POP	AX
 29056 00004DB8 F9                      	STC
 29057 00004DB9 C3                      	RETN
 29058                                  
 29059                                  ;BREAK <InsertPath - call fastopen to insert dir entry info>
 29060                                  ;-----------------------------------------------------------------------------
 29061                                  ;
 29062                                  ; Procedure Name : InsertPath
 29063                                  ; Input:  FastOpen_Set flag set when from DOSOPEN otherwise 0
 29064                                  ;	  Lookup_Success flag set when got dir entry info from FASTOPEN
 29065                                  ;	  DS = DOSDATA
 29066                                  ; Output: FastOPen_Ext_Info is set and path dir info is inserted
 29067                                  ;
 29068                                  ;-----------------------------------------------------------------------------
 29069                                  
 29070                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29071                                  
 29072                                  InsertPath:
 29073 00004DBA 9C                      	PUSHF
 29074                                  ;hkn; SS override for FastOpenFlag
 29075                                  	;test	byte [SS:FastOpenFlg], 1
 29076 00004DBB 36F606[6D12]01          	TEST	byte [SS:FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 29077 00004DC1 7479                    	JZ	short GET_NEXT_ELEMENT		; the FastOpen
 29078                                  	;test	byte [ss:FastOpenFlg],2
 29079 00004DC3 36F606[6D12]02          	TEST	byte [SS:FastOpenFlg],Lookup_Success ; Lookup just happened
 29080 00004DC9 740D                    	JZ	short INSERT_DIR_INFO		; no
 29081                                  	;and	byte [ss:FastOpenFlg],0FDh
 29082 00004DCB 368026[6D12]FD          	AND	byte [SS:FastOpenFlg],Lookup_Reset  ; we got dir info from fastopen so
 29083 00004DD1 368B3E[B70D]            	MOV	DI,[SS:Next_Element_Start]	; no need to insert it again
 29084 00004DD6 EB5E                    	JMP	short GET_NEXT2
 29085                                  INSERT_DIR_INFO:				; save registers
 29086 00004DD8 1E                      	PUSH	DS
 29087 00004DD9 06                      	PUSH	ES
 29088 00004DDA 53                      	PUSH	BX
 29089 00004DDB 56                      	PUSH	SI
 29090 00004DDC 57                      	PUSH	DI
 29091 00004DDD 51                      	PUSH	CX
 29092 00004DDE 50                      	PUSH	AX
 29093                                  
 29094                                  ;hkn; SS override
 29095 00004DDF 36C53E[E205]            	LDS	DI,[SS:CURBUF]			; DS:DI -> buffer header
 29096 00004DE4 BE[8C0D]                	MOV	SI,FastOpen_Ext_Info
 29097                                  	;mov	ax,[di+6]
 29098 00004DE7 8B4506                  	MOV	AX,[DI+BUFFINFO.buf_sector]	; get directory sector
 29099                                  	; MSDOS 6.0
 29100                                  	;mov	[ss:si+1],ax
 29101 00004DEA 36894401                	MOV	[SS:SI+FEI.dirsec],AX 		;AN000; >32mb save dir sector
 29102                                  	; 19/05/2019 - Retro DOS v4.0
 29103 00004DEE 8B4508                  	MOV	AX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 29104                                  
 29105                                  ;hkn; SS is DOSDATA
 29106 00004DF1 16                      	push	ss
 29107 00004DF2 1F                      	pop	ds
 29108                                  	; MSDOS 3.3	
 29109                                  	;;mov	[si+1],ax	
 29110                                  	;MOV	[SI+FEI.dirsec],AX
 29111                                  	; MSDOS 6.0
 29112                                  	;mov	[si+3],ax
 29113 00004DF3 894403                  	MOV	[SI+FEI.dirsec+2],AX		;AN000;>32mb save high dir sector
 29114                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29115 00004DF6 A1[BC05]                	MOV	AX,[CLUSNUM]		; save next cluster number
 29116                                  	;;mov	[si+5],ax ; MSDOS 6.0
 29117                                  	;mov	[si+3],ax ; MSDOS 3.3
 29118 00004DF9 894405                  	MOV	[SI+FEI.clusnum],AX
 29119                                  	; MSDOS 6.0
 29120 00004DFC A1[4803]                	MOV	AX,[LASTENT]		;AN000;FO. save lastentry for search first
 29121                                  	;mov	[si+7],ax
 29122 00004DFF 894407                  	MOV	[SI+FEI.lastent],AX	;AN000;FO.
 29123 00004E02 A1[C205]                	MOV	AX,[DIRSTART]		;AN001;FO. save  for search first
 29124                                  	;mov	[si+9],ax
 29125 00004E05 894409                  	MOV	[SI+FEI.dirstart],AX	;AN001;FO.
 29126                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29127 00004E08 89D8                    	MOV	AX,BX
 29128                                  	;;add	di,16  ; MSDOS 3.3
 29129                                  	;add	di,20  ; MSDOS 6.0
 29130 00004E0A 83C718                  	ADD	DI,BUFINSIZ		; DS:DI -> start of data in buffer
 29131 00004E0D 29F8                    	SUB	AX,DI			; AX=BX relative to start of sector
 29132                                  	;mov	cl,32
 29133 00004E0F B120                    	MOV	CL,dir_entry.size
 29134 00004E11 F6F1                    	DIV	CL
 29135                                  	;MOV	[SI+FEI.dirpos],AL	; save directory entry # in buffer
 29136 00004E13 8804                    	mov	[si],al
 29137                                  
 29138 00004E15 1E                      	PUSH	DS
 29139 00004E16 07                      	POP	ES
 29140                                  
 29141 00004E17 8E1E[E405]              	MOV	DS,[CURBUF+2]
 29142 00004E1B 89DF                    	MOV	DI,BX			; DS:DI -> dir entry info
 29143                                  	;cmp	word [di+1Ah],0
 29144 00004E1D 837D1A00                	CMP	word [DI+dir_entry.dir_first],0 
 29145                                  					; never insert info when file is empty
 29146 00004E21 740C                    	JZ	short SKIP_INSERT	; e.g. newly created file
 29147                                  
 29148 00004E23 56                      	PUSH	SI			; ES:BX -> extended info
 29149 00004E24 5B                      	POP	BX
 29150                                  
 29151                                  	;mov	al,2
 29152 00004E25 B002                    	MOV	AL,FONC_insert		; call fastopen insert operation
 29153 00004E27 BE[6312]                	MOV	SI,FastOpenTable
 29154                                  	;call	far [es:si+2]	 ; call dword ptr es:[si+2] ; 29/12/2022
 29155                                  	; 07/12/2022
 29156 00004E2A 26FF5C02                	CALL	far [ES:SI+fastopen_entry.name_caching]
 29157                                  
 29158 00004E2E F8                      	CLC
 29159                                  SKIP_INSERT:
 29160 00004E2F 58                      	POP	AX
 29161 00004E30 59                      	POP	CX			; restore registers
 29162 00004E31 5F                      	POP	DI
 29163 00004E32 5E                      	POP	SI
 29164 00004E33 5B                      	POP	BX
 29165 00004E34 07                      	POP	ES
 29166 00004E35 1F                      	POP	DS
 29167                                  GET_NEXT2:
 29168                                  	;or	[ss:FastOpenFlg],8
 29169 00004E36 36800E[6D12]08          	OR	byte [SS:FastOpenFlg],No_Lookup
 29170                                  					; we got dir info from fastopen so
 29171                                  GET_NEXT_ELEMENT:
 29172 00004E3C 9D                      	POPF
 29173 00004E3D C3                      	RETN
 29174                                  
 29175                                  ;============================================================================
 29176                                  ; DEV.ASM (MSDOS 6.0, 1991)
 29177                                  ;============================================================================
 29178                                  ; 17/07/2018 - Retro DOS v3.0
 29179                                  ; 30/04/2019 - Retro DOS v4.0
 29180                                  
 29181                                  ;**	Misc Routines to do 1-12 low level I/O and call devices
 29182                                  
 29183                                  ; Offset 12B8h of IBMDOS.COM (MSDOS 3.3), 1987
 29184                                  
 29185                                  ;DOSCODE:8401h (MSDOS 6.21, MSDOS.SYS)
 29186                                  
 29187                                  ;Public DEV001S, DEV001E 		; Pathgen labels
 29188                                  ;DEV001s:
 29189                                  ;		length of packets
 29190 00004E3E 160E160D0F0E            LenTab:	 DB	DRDWRHL, DRDNDHL, DRDWRHL, DSTATHL, DFLSHL, DRDNDHL
 29191                                  ;LenTab: db	22,14,22,13,15,14
 29192                                  
 29193                                  ;	Error Function
 29194                                  
 29195                                  CmdTab:
 29196 00004E44 8604                    	DB	86h, DEVRD	; 0 input
 29197 00004E46 8605                    	DB	86h, DEVRDND	; 1 input status
 29198 00004E48 8708                    	DB	87h, DEVWRT	; 2 output
 29199 00004E4A 870A                    	DB	87h, DEVOST	; 3 output status
 29200 00004E4C 8607                    	DB	86h, DEVIFL	; 4 input flush
 29201 00004E4E 8605                    	DB	86h, DEVRDND	; 5 input status with system WAIT
 29202                                  
 29203                                  ; Offset 12BEh of IBMDOS.COM (MSDOS 3.3), 1987
 29204                                  
 29205                                  ;CmdTab:
 29206                                  ;	db	86h, 4
 29207                                  ;	db	86h, 5
 29208                                  ;	db	87h, 8
 29209                                  ;	db	87h, 10
 29210                                  ;	db	86h, 7
 29211                                  ;	db	86h, 5
 29212                                  
 29213                                  ;DEV001E:
 29214                                  
 29215                                  ; 30/04/2019 - Retro DOS v4.0
 29216                                  ; DOSCODE:8413h (MSDOS 6.21, MSDOS.SYS)
 29217                                  
 29218                                  ;Break	<IOFUNC -- DO FUNCTION 1-12 I/O>
 29219                                  ;----------------------------------------------------------------------------
 29220                                  ;
 29221                                  ; Procedure Name : IOFUNC
 29222                                  ;
 29223                                  ; Inputs:
 29224                                  ;	DS:SI Points to SFT
 29225                                  ;	AH is function code
 29226                                  ;		= 0 Input
 29227                                  ;		= 1 Input Status
 29228                                  ;		= 2 Output
 29229                                  ;		= 3 Output Status
 29230                                  ;		= 4 Flush
 29231                                  ;		= 5 Input Status - System WAIT invoked for K09 if no char
 29232                                  ;				   present.
 29233                                  ;	AL = character if output
 29234                                  ; Function:
 29235                                  ;	Perform indicated I/O to device or file
 29236                                  ; Outputs:
 29237                                  ;	AL is character if input
 29238                                  ;	If a status call
 29239                                  ;		zero set if not ready
 29240                                  ;		zero reset if ready (character in AL for input status)
 29241                                  ; For regular files:
 29242                                  ;	Input Status
 29243                                  ;		Gets character but restores position
 29244                                  ;		Zero set on EOF
 29245                                  ;	Input
 29246                                  ;		Gets character advances position
 29247                                  ;		Returns ^Z on EOF
 29248                                  ;	Output Status
 29249                                  ;		Always ready
 29250                                  ; AX altered, all other registers preserved
 29251                                  ;----------------------------------------------------------------------------
 29252                                  
 29253                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29254                                  ; DOSCODE:83D8h (MSDOS 5.0, MSDOS.SYS)
 29255                                  
 29256                                  IOFUNC:
 29257 00004E50 368C16[8C03]            	MOV	[SS:IOXAD+2],SS		; SS override for IOXAD, IOSCNT, 
 29258                                  					; DEVIOBUF
 29259 00004E55 36C706[8A03][BC03]      	MOV	WORD [SS:IOXAD],DEVIOBUF
 29260 00004E5C 36C706[8E03]0100        	MOV	WORD [SS:IOSCNT],1
 29261 00004E63 36A3[BC03]              	MOV	WORD [SS:DEVIOBUF],AX
 29262                                  	;test	byte [si+6],80h
 29263                                  	;TEST	word [SI+SF_ENTRY.sf_flags],sf_isnet ; 8000h
 29264 00004E67 F6440680                	test	byte [SI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 29265 00004E6B 7403                    	JZ	short IOTO22		;AN000;
 29266 00004E6D E9A500                  	JMP	IOTOFILE		;AN000;
 29267                                  IOTO22:
 29268                                  	;test	word [si+5],80h
 29269                                  	;TEST	word [SI+SF_ENTRY.sf_flags],devid_device 
 29270 00004E70 F6440580                	test	byte [SI+SF_ENTRY.sf_flags],devid_device	
 29271 00004E74 7503                    	JNZ	short IOTO33		;AN000;
 29272 00004E76 E99C00                  	JMP	IOTOFILE		;AN000;
 29273                                  IOTO33:
 29274 00004E79 06                      	push	es ; * (MSDOS 6.21)
 29275 00004E7A E8DBB5                  	call	save_world
 29276 00004E7D 8CDA                    	MOV	DX,DS
 29277 00004E7F 8CD3                    	MOV	BX,SS
 29278 00004E81 8EDB                    	MOV	DS,BX
 29279 00004E83 8EC3                    	MOV	ES,BX
 29280 00004E85 31DB                    	XOR	BX,BX
 29281 00004E87 80FC05                  	cmp	ah,5		    ; system wait enabled?
 29282 00004E8A 7503                    	jnz	short _no_sys_wait
 29283                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29284                                  	; 16/12/2022
 29285 00004E8C 80CF04                  	or	bh,04h
 29286                                  	;or	bx,0400H	    ; Set bit 10 in status word for driver
 29287                                  				    ; It is up to device driver to carry out
 29288                                  				    ; appropriate action.
 29289                                  _no_sys_wait:
 29290 00004E8F 891E[7F03]              	MOV	[IOCALL_REQSTAT],BX
 29291 00004E93 31DB                    	XOR	BX,BX
 29292 00004E95 881E[8903]              	MOV	[IOMED],BL
 29293                                  
 29294 00004E99 88E3                    	MOV	BL,AH		 	; get function
 29295 00004E9B 2E8AA7[3E4E]            	MOV	AH,[cs:BX+LenTab]
 29296 00004EA0 D1E3                    	SHL	BX,1
 29297 00004EA2 2E8B8F[444E]            	MOV	CX,[cs:BX+CmdTab]
 29298 00004EA7 BB[7C03]                	MOV	BX,IOCALL ; DOSDATA:037Ch
 29299 00004EAA 8826[7C03]              	MOV	[IOCALL_REQLEN],AH
 29300 00004EAE 882E[7E03]              	MOV	[IOCALL_REQFUNC],CH
 29301                                  
 29302 00004EB2 8EDA                    	MOV	DS,DX
 29303 00004EB4 E86B01                  	CALL	DEVIOCALL
 29304 00004EB7 368B3E[7F03]            	MOV	DI,[SS:IOCALL_REQSTAT]	; SS override
 29305 00004EBC 21FF                    	and	di,di
 29306 00004EBE 7834                    	js	short DevErr
 29307                                  OKDevIO:
 29308 00004EC0 8CD0                    	MOV	AX,SS
 29309 00004EC2 8ED8                    	MOV	DS,AX
 29310                                  
 29311                                  	;cmp	ch,5
 29312 00004EC4 80FD05                  	CMP	CH,DEVRDND
 29313 00004EC7 7506                    	JNZ	short DNODRD
 29314 00004EC9 A0[8903]                	MOV	AL,[IORCHR]
 29315 00004ECC A2[BC03]                	MOV	[DEVIOBUF],AL
 29316                                  
 29317                                  DNODRD: 
 29318 00004ECF 8A26[8003]              	MOV	AH,[IOCALL_REQSTAT+1]
 29319 00004ED3 F6D4                    	NOT	AH			; Zero = busy, not zero = ready
 29320                                  	;and	ah,2
 29321 00004ED5 80E402                  	AND	AH,STBUI>>8
 29322                                  
 29323                                  QuickReturn:				;AN000; 2/13/KK
 29324 00004ED8 E866B5                  	call	restore_world
 29325 00004EDB 07                      	pop	es ; * (MSDOS 6.21)
 29326                                  
 29327                                  	; SR;
 29328                                  	; We return ax = -1 if the user failed on I24. This is the case if 
 29329                                  	; IoStatFail = -1 (set after return from the I24)
 29330                                  
 29331                                  	; MSDOS 6.0
 29332 00004EDC 9C                      	pushf
 29333 00004EDD 36A0[8300]              	mov	al,[ss:IoStatFail]	;assume fail error
 29334 00004EE1 98                      	cbw				;sign extend to word
 29335 00004EE2 83F8FF                  	cmp	ax,-1
 29336 00004EE5 7507                    	jne	short not_fail_ret
 29337 00004EE7 36FE06[8300]            	inc	byte [ss:IoStatFail]
 29338 00004EEC 9D                      	popf
 29339 00004EED C3                      	retn
 29340                                  
 29341                                  not_fail_ret:
 29342 00004EEE 36A1[BC03]              	mov	ax,[ss:DEVIOBUF]	;ss override
 29343 00004EF2 9D                      	popf
 29344 00004EF3 C3                      	retn
 29345                                  
 29346                                  DevErr:
 29347 00004EF4 88CC                    	MOV	AH,CL
 29348 00004EF6 E88E0D                  	call	CHARHARD
 29349 00004EF9 3C01                    	CMP	AL,1
 29350 00004EFB 7507                    	JNZ	short NO_RETRY
 29351 00004EFD E841B5                  	call	restore_world
 29352                                  	; 12/05/2019
 29353 00004F00 07                      	pop	es ; * (MSDOS 6.21)		
 29354 00004F01 E94CFF                  	JMP	IOFUNC	; 10/08/2018
 29355                                  
 29356                                  NO_RETRY:
 29357                                  	; Know user must have wanted Ignore OR Fail. Make sure device shows ready
 29358                                  	; ready so that DOS doesn't get caught in a status loop when user 
 29359                                  	; simply wants to ignore the error.
 29360                                  	;
 29361                                  	; SR; If fail wanted by user set ax to special value (ax = -1). This 
 29362                                  	; should be checked by the caller on return
 29363                                  
 29364                                  					; SS override
 29365 00004F04 368026[8003]FD          	and	byte [SS:IOCALL_REQSTAT+1],0FDh
 29366                                  	;AND	BYTE [SS:IOCALL_REQSTAT+1],~(STBUI>>8)
 29367                                  
 29368                                  	; SR;
 29369                                  	; Check if user failed
 29370                                  
 29371                                  	; MSDOS 6.0
 29372 00004F0A 3C03                    	cmp	al,3
 29373 00004F0C 7505                    	jnz	short not_fail
 29374 00004F0E 36FE0E[8300]            	dec	byte [ss:IoStatFail]	;set flag indicating fail on I24
 29375                                  not_fail:
 29376 00004F13 EBAB                    	JMP	short OKDevIO
 29377                                  
 29378                                  IOTOFILE:
 29379 00004F15 08E4                    	OR	AH,AH
 29380 00004F17 7421                    	JZ	short IOIN
 29381 00004F19 FECC                    	DEC	AH
 29382 00004F1B 7405                    	JZ	short IOIST
 29383 00004F1D FECC                    	DEC	AH
 29384 00004F1F 7411                    	JZ	short IOUT
 29385                                  IOUT_retn:	; 18/12/2022
 29386 00004F21 C3                      	retn				; NON ZERO FLAG FOR OUTPUT STATUS
 29387                                  IOIST:
 29388                                  	;push	word [si+15h]
 29389 00004F22 FF7415                  	PUSH	WORD [SI+SF_ENTRY.sf_position]   ; Save position
 29390                                  	;push	word [si+17h]
 29391 00004F25 FF7417                  	PUSH	WORD [SI+SF_ENTRY.sf_position+2]
 29392 00004F28 E80F00                  	CALL	IOIN
 29393                                  	;pop	word [si+17h]
 29394 00004F2B 8F4417                  	POP	WORD [SI+SF_ENTRY.sf_position+2] ; Restore position
 29395                                  	;pop	word [si+15h]
 29396 00004F2E 8F4415                  	POP	WORD [SI+SF_ENTRY.sf_position]
 29397 00004F31 C3                      	retn
 29398                                  IOUT:
 29399 00004F32 E82500                  	CALL	SETXADDR
 29400 00004F35 E83EEE                  	call	DOS_WRITE
 29401                                  	;CALL	RESTXADDR	; If you change this into a jmp don't
 29402                                  	; 18/12/2022
 29403 00004F38 EB52                    	jmp	RESTXADDR
 29404                                  ;IOUT_retn:
 29405                                  	;retn			; come crying to me when things don't
 29406                                  				; work ARR
 29407                                  IOIN:
 29408 00004F3A E81D00                  	CALL	SETXADDR
 29409                                  					; SS override for DOS34_FLAG
 29410                                  	;OR	word [SS:DOS34_FLAG],Disable_EOF_I24	;AN000;
 29411                                  	;or	word [ss:DOS34_FLAG],40h
 29412                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29413                                  	; 16/12/2022
 29414 00004F3D 36800E[1106]40          	or	byte [ss:DOS34_FLAG],40h 
 29415 00004F43 E807EC                  	CALL	DOS_READ
 29416                                  	;AND	word [SS:DOS34_FLAG],NO_Disable_EOF_I24 ;AN000;
 29417                                  	;and	word [SS:DOS34_FLAG],0FFBFh
 29418                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29419                                  	; 16/12/2022
 29420 00004F46 368026[1106]BF          	and	byte [SS:DOS34_FLAG],0BFh ; 07/12/2022
 29421 00004F4C 09C9                    	OR	CX,CX			; Check EOF
 29422 00004F4E E83B00                  	CALL	RESTXADDR
 29423                                  					; SS override
 29424 00004F51 36A0[BC03]              	MOV	AL,[SS:DEVIOBUF]	; Get byte from trans addr
 29425 00004F55 75CA                    	jnz	short IOUT_retn	
 29426 00004F57 B01A                    	MOV	AL,1AH			; ^Z if no bytes
 29427 00004F59 C3                      	retn
 29428                                  
 29429                                  SETXADDR:
 29430                                  					; SS override
 29431 00004F5A 368F06[6C03]            	POP	WORD [SS:CALLSCNT]	; Return address
 29432                                  
 29433 00004F5F 06                      	push	es ; * (MSDOS 6.21)
 29434                                  
 29435 00004F60 E8F5B4                  	call	save_world
 29436                                  					; SS override for DMAADD and THISSFT
 29437                                  	; 24/09/2023
 29438                                  	;PUSH	WORD [SS:DMAADD]	; Save Disk trans addr
 29439                                  	;PUSH	WORD [SS:DMAADD+2]
 29440 00004F63 368C1E[A005]            	MOV	[SS:THISSFT+2],DS
 29441                                  
 29442 00004F68 16                      	push	ss
 29443 00004F69 1F                      	pop	ds
 29444                                  
 29445                                  	; 24/09/2023
 29446 00004F6A FF36[2C03]              	push	word [DMAADD]
 29447 00004F6E FF36[2E03]              	push	word [DMAADD+2]
 29448                                  
 29449 00004F72 8936[9E05]              	MOV	[THISSFT],SI		; Finish setting SFT pointer
 29450 00004F76 8B0E[8C03]              	MOV	CX,[IOXAD+2]
 29451 00004F7A 890E[2E03]              	MOV	[DMAADD+2],CX
 29452 00004F7E 8B0E[8A03]              	MOV	CX,[IOXAD]
 29453 00004F82 890E[2C03]              	MOV	[DMAADD],CX		; Set byte trans addr
 29454 00004F86 8B0E[8E03]              	MOV	CX,[IOSCNT]		; ioscnt specifies length of buffer
 29455 00004F8A EB10                    	JMP	SHORT RESTRET		; RETURN ADDRESS
 29456                                  
 29457                                  RESTXADDR:
 29458 00004F8C 8F06[6C03]              	POP	WORD [CALLSCNT]		; Return address
 29459 00004F90 8F06[2E03]              	POP	WORD [DMAADD+2]		; Restore Disk trans addr
 29460 00004F94 8F06[2C03]              	POP	WORD [DMAADD]
 29461                                  
 29462 00004F98 E8A6B4                  	call	restore_world
 29463                                  
 29464 00004F9B 07                      	pop	es ; * (MSDOS 6.21)
 29465                                  					; SS override
 29466                                  RESTRET:
 29467 00004F9C 36FF26[6C03]            	JMP	WORD [SS:CALLSCNT]	; Return address
 29468                                  
 29469                                  ; DOSCODE:8569h (MSDOS 6.21, MSDOS.SYS)
 29470                                  ; 21/11/2022
 29471                                  ; DOSCODE:852Eh (MSDOS 5.0, MSDOS.SYS)
 29472                                  
 29473                                  ;Break <DEV_OPEN_SFT, DEV_CLOSE_SFT - OPEN or CLOSE A DEVICE>
 29474                                  
 29475                                  ;----------------------------------------------------------------------------
 29476                                  ;**	Dev_Open_SFT - Open the Device for an SFT
 29477                                  ;
 29478                                  ;	Dev_Open_SFT issues an open call to the device associated with
 29479                                  ;	the SFT.
 29480                                  ;
 29481                                  ;	ENTRY	(ES:DI) = SFT
 29482                                  ;	EXIT	none
 29483                                  ;	USES	all
 29484                                  ;----------------------------------------------------------------------------
 29485                                  
 29486                                  DEV_OPEN_SFT:
 29487 00004FA1 06                      	push	es ; * (MSDOS 6.21)
 29488 00004FA2 E8B3B4                  	call	save_world
 29489                                  	;mov	al,0Dh	
 29490 00004FA5 B00D                    	MOV	AL,DEVOPN
 29491 00004FA7 EB06                    	JMP	SHORT DO_OPCLS
 29492                                  
 29493                                  ;----------------------------------------------------------------------------
 29494                                  ; Procedure Name : DEV_CLOSE_SFT
 29495                                  ;
 29496                                  ; Inputs:
 29497                                  ;	ES:DI Points to SFT
 29498                                  ; Function:
 29499                                  ;	Issue a CLOSE call to the correct device
 29500                                  ; Outputs:
 29501                                  ;	None
 29502                                  ; ALL preserved
 29503                                  ;----------------------------------------------------------------------------
 29504                                  
 29505                                  DEV_CLOSE_SFT:
 29506 00004FA9 06                      	push	es ; * (MSDOS 6.21)
 29507 00004FAA E8ABB4                  	call	save_world
 29508                                  	;mov	al,0Eh	
 29509 00004FAD B00E                    	MOV	AL,DEVCLS
 29510                                  
 29511                                  	; Main entry for device open and close. AL contains the function 
 29512                                  	; requested. Subtlety: if Sharing is NOT loaded then we do NOT issue 
 29513                                  	; open/close to block devices. This allows networks to function but 
 29514                                  	; does NOT hang up with bogus change-line code.
 29515                                  
 29516                                  	;entry	DO_OPCLS
 29517                                  DO_OPCLS:
 29518                                  	; Is the SFT for the net? If so, no action necessary.
 29519                                  
 29520                                  	; MSDOS 6.0
 29521                                  	;test	word [es:di+5],8000h
 29522                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 29523 00004FAF 26F6450680              	test	byte [es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 29524 00004FB4 7567                    	jnz	short OPCLS_DONE	; NOP on net SFTs
 29525 00004FB6 30E4                    	XOR	AH,AH			; Unit
 29526                                  	;test	byte [es:di+5],80h
 29527 00004FB8 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 29528                                  	;les	di,[es:di+7]
 29529 00004FBD 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get DPB or device
 29530 00004FC1 7513                    	JNZ	short GOT_DEV_ADDR
 29531                                  
 29532                                  	; We are about to call device open/close on a block driver. If no 
 29533                                  	; sharing then just short circuit to done.
 29534                                  	
 29535                                  	; MSDOS 6.0
 29536                                  					; SS override
 29537 00004FC3 36803E[0303]01          	CMP	byte [ss:fShare],1	;AN010; /NC or no SHARE
 29538 00004FC9 7652                    	JBE	short OPCLS_DONE	;AN010; yes
 29539                                  
 29540                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29541                                  	;mov	ah,[es:di+1]
 29542 00004FCB 268A6501                	MOV	AH,[ES:DI+DPB.UNIT]	; (ah) = unit
 29543 00004FCF 268A0D                  	mov	cl,[es:di]
 29544                                  	;MOV	CL,[ES:DI+DPB.DRIVE]	; (cl) = drive
 29545                                  	;;les	di,[es:di+12h] ; MSDOS 3.3
 29546                                  	;les	di,[es:di+13h] ; MSDOS 6.0
 29547 00004FD2 26C47D13                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Get device
 29548                                  GOT_DEV_ADDR:				; ES:DI -> device
 29549                                  	;test	word [es:di+4],800h
 29550                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL
 29551 00004FD6 26F6450508              	test	byte [ES:DI+SYSDEV.ATT+1],(DEVOPCL>>8)
 29552 00004FDB 7440                    	JZ	short OPCLS_DONE	; Device can't
 29553 00004FDD 06                      	PUSH	ES
 29554 00004FDE 1F                      	POP	DS
 29555 00004FDF 89FE                    	MOV	SI,DI			; DS:SI -> device
 29556                                  
 29557                                  OPCLS_RETRY:
 29558                                  	;Context ES
 29559 00004FE1 16                      	push	ss
 29560 00004FE2 07                      	pop	es
 29561                                  					; DEVCALL is in DOSDATA
 29562 00004FE3 BF[5A03]                	MOV	DI,DEVCALL
 29563                                  
 29564 00004FE6 89FB                    	MOV	BX,DI
 29565 00004FE8 50                      	PUSH	AX
 29566                                  	;mov	al,13
 29567 00004FE9 B00D                    	MOV	AL,DOPCLHL
 29568 00004FEB AA                      	STOSB				; Length
 29569 00004FEC 58                      	POP	AX
 29570 00004FED 86E0                    	XCHG	AH,AL
 29571 00004FEF AA                      	STOSB				; Unit
 29572 00004FF0 86E0                    	XCHG	AH,AL
 29573 00004FF2 AA                      	STOSB				; Command
 29574 00004FF3 26C7050000              	MOV	WORD [ES:DI],0		; Status
 29575 00004FF8 50                      	PUSH	AX			; Save Unit,Command
 29576                                  	;invoke	DEVIOCALL2
 29577 00004FF9 E82900                  	call	DEVIOCALL2
 29578                                  
 29579                                  	;mov	di,[es:bx+3]
 29580 00004FFC 268B7F03                	MOV	DI,[ES:BX+SRHEAD.REQSTAT]
 29581                                  	;test	di,8000h
 29582                                  	;jz	short OPCLS_DONEP	
 29583 00005000 21FF                    	and	di,di
 29584 00005002 7918                    	jns	short OPCLS_DONEP	; No error
 29585                                  	; 21/11/2022
 29586                                  	;test	word [si+4],8000h
 29587                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP
 29588                                  	;test	word [si+5],80h
 29589 00005004 F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8)
 29590 00005008 7404                    	JZ	short BLKDEV
 29591 0000500A B486                    	MOV	AH,86H			; Read error in data, Char dev
 29592 0000500C EB04                    	JMP	SHORT HRDERR
 29593                                  BLKDEV:
 29594 0000500E 88C8                    	MOV	AL,CL			; Drive # in AL
 29595 00005010 B406                    	MOV	AH,6			; Read error in data, Blk dev
 29596                                  HRDERR:
 29597                                  	;invoke	CHARHARD
 29598 00005012 E8720C                  	call	CHARHARD
 29599 00005015 3C01                    	cmp	al,1
 29600 00005017 7503                    	jne	short OPCLS_DONEP	; IGNORE or FAIL
 29601                                  					;  Note that FAIL is essentually IGNORED
 29602 00005019 58                      	POP	AX			; Get back Unit, Command
 29603 0000501A EBC5                    	JMP	short OPCLS_RETRY
 29604                                  OPCLS_DONEP:
 29605 0000501C 58                      	POP	AX			; Clean stack
 29606                                  OPCLS_DONE:
 29607 0000501D E821B4                  	call	restore_world
 29608 00005020 07                      	pop	es ; * (MSDOS 6.21)
 29609 00005021 C3                      	retn
 29610                                  
 29611                                  ; 30/04/2019 - Retro DOS v4.0
 29612                                  ; DOSCODE:85EAh (MSDOS 6.21, MSDOS.SYS)
 29613                                  
 29614                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29615                                  ; DOSCODE:85AFh (MSDOS 5.0, MSDOS.SYS)
 29616                                  
 29617                                  ;Break	<DEVIOCALL, DEVIOCALL2 - CALL A DEVICE>
 29618                                  ;----------------------------------------------------------------------------
 29619                                  ;**	DevIoCall  - Call Device
 29620                                  ;
 29621                                  ;	ENTRY	DS:SI Points to device SFT
 29622                                  ;		ES:BX Points to request data
 29623                                  ;	EXIT	DS:SI -> Device driver
 29624                                  ;	USES	DS:SI,AX
 29625                                  ;----------------------------------------------------------------------------
 29626                                  ;**	DevIoCall2 - Call Device
 29627                                  ;
 29628                                  ;	ENTRY	DS:SI Points to DPB
 29629                                  ;		ES:BX Points to request data
 29630                                  ;	EXIT	DS:SI -> Device driver
 29631                                  ;	USES	DS:SI,AX
 29632                                  ;----------------------------------------------------------------------------
 29633                                  
 29634                                  DEVIOCALL:
 29635                                  					; SS override for CALLSSEC, 
 29636                                  	;lds	si,[si+7]		; CALLNEWSC, HIGH_SECTOR & CALLDEVAD
 29637 00005022 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 29638                                  
 29639                                  	;entry	DEVIOCALL2
 29640                                  DEVIOCALL2:
 29641                                  	;EnterCrit critDevice
 29642 00005025 E819C9                  	call	ECritDevice
 29643                                  
 29644                                  	; MSDOS 6.0
 29645                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP ;AN000; >32mb block device ?
 29646                                  	;test	byte [si+5],80h
 29647 00005028 F6440580                	test	byte [si+SYSDEV.ATT+1],(DEVTYP>>8)
 29648 0000502C 7548                    	jnz	short chardev2		;AN000; >32mb no
 29649                                  
 29650                                  	; 16/12/2022
 29651                                  	; 22/11/2022
 29652 0000502E 268A4702                	mov	al,[ES:BX+SRHEAD.REQFUNC] ; [es:bx+2]
 29653 00005032 3C04                    	cmp	al,DEVRD	; 4
 29654 00005034 7408                    	je	short chkext	
 29655 00005036 3C08                    	cmp	al,DEVWRT	; 8
 29656 00005038 7404                    	je	short chkext
 29657 0000503A 3C09                    	cmp	al,DEVWRTV	; 9
 29658 0000503C 7538                    	jne	short chardev2
 29659                                  
 29660                                  	; 16/12/2022
 29661                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29662                                  	;;cmp	byte [es:bx+2],4
 29663                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVRD  ;AN000; >32mb read ?
 29664                                  	;JZ	short chkext		;AN000; >32mb   yes
 29665                                  	;;cmp	byte [es:bx+2],8
 29666                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRT ;AN000; >32mb write ?
 29667                                  	;JZ	short chkext		;AN000; >32mb   yes
 29668                                  	;;cmp	byte [es:bx+2],9
 29669                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRTV
 29670                                  	;				;AN000; >32mb write/verify ?
 29671                                  	;JNZ	short chardev2		;AN000; >32mb no
 29672                                  chkext:
 29673 0000503E E89900                  	CALL	RW_SC			;AN000;LB. use secondary cache if there
 29674 00005041 7255                    	JC	short dev_exit		;AN000;LB. done
 29675                                  
 29676                                  	;test	byte [si+4],2
 29677 00005043 F6440402                	TEST	byte [SI+SYSDEV.ATT],EXTDRVR ;AN000;>32mb extended driver?
 29678 00005047 741D                    	JZ	short chksector		;AN000;>32mb   no
 29679 00005049 26800708                	ADD	BYTE [ES:BX],8		;AN000;>32mb   make length to 30
 29680 0000504D 36A1[6E03]              	MOV	AX,[SS:CALLSSEC]	;AN000;>32mb
 29681 00005051 36C706[6E03]FFFF        	MOV	word [SS:CALLSSEC],-1	;AN000;>32mb   old sector  =-1
 29682 00005058 36A3[7403]              	MOV	[SS:CALLNEWSC],AX	;AN000;>32mb   new sector  =
 29683 0000505C 36A1[0706]              	MOV	AX,[SS:HIGH_SECTOR]	;AN000; >32mb  low sector,high sector
 29684 00005060 36A3[7603]              	MOV	[SS:CALLNEWSC+2],AX	;AN000; >32mb
 29685 00005064 EB10                    	JMP	short chardev2		;AN000; >32mb
 29686                                  chksector:				;AN000; >32mb
 29687 00005066 36833E[0706]00          	CMP	word [SS:HIGH_SECTOR],0	;AN000; >32mb   if >32mb
 29688 0000506C 7408                    	JZ	short chardev2		;AN000; >32mb   then fake error
 29689                                  	;mov	word [es:bx+3],8107h
 29690 0000506E 26C747030781            	MOV	word [ES:BX+SRHEAD.REQSTAT],STERR+STDON+error_I24_not_DOS_disk 
 29691                                  					;AN000; >32mb
 29692 00005074 EB22                    	JMP	SHORT dev_exit		;AN000; >32mb
 29693                                  
 29694                                  chardev2:				;AN000;
 29695                                  	; As above only DS:SI points to device header on entry, and DS:SI is 
 29696                                  	; preserved
 29697                                  
 29698                                  	;mov	ax,[si+6]
 29699 00005076 8B4406                  	MOV	AX,[SI+SYSDEV.STRAT]
 29700 00005079 36A3[7803]              	MOV	[SS:CALLDEVAD],AX
 29701 0000507D 368C1E[7A03]            	MOV	[SS:CALLDEVAD+2],DS
 29702 00005082 36FF1E[7803]            	CALL	far [SS:CALLDEVAD]
 29703                                  
 29704                                  	;mov	ax,[si+8]
 29705 00005087 8B4408                  	MOV	AX,[SI+SYSDEV.INT]
 29706 0000508A 36A3[7803]              	MOV	[SS:CALLDEVAD],AX
 29707 0000508E 36FF1E[7803]            	CALL	far [SS:CALLDEVAD]
 29708                                  
 29709                                  	; MSDOS 6.0
 29710 00005093 E83A01                  	CALL	VIRREAD 		;AN000;LB. move data from SC to buffer
 29711 00005096 72DE                    	JC	short chardev2		;AN000;LB. bad sector or exceeds max sec
 29712                                  
 29713                                  dev_exit:
 29714                                  	;LeaveCrit critDevice
 29715                                  	;call	LCritDevice
 29716                                  	;retn
 29717                                  	; 18/12/2022
 29718 00005098 E9B7C8                  	jmp	LCritDevice
 29719                                  
 29720                                  ; DOSCODE:8669h (MSDOS 6.21, MSDOS.SYS)
 29721                                  ; 22/11/2022
 29722                                  ; DOSCODE:862Eh (MSDOS 5.0, MSDOS.SYS)
 29723                                  
 29724                                  ;Break	<SETREAD, SETWRITE -- SET UP HEADER BLOCK>
 29725                                  ;---------------------------------------------------------------------------
 29726                                  ;
 29727                                  ; Procedure Name : SETREAD, SETWRITE
 29728                                  ;
 29729                                  ; Inputs:
 29730                                  ;	DS:BX = Transfer Address
 29731                                  ;	CX = Record Count
 29732                                  ;	DX = Starting Record
 29733                                  ;	AH = Media Byte
 29734                                  ;	AL = Unit Code
 29735                                  ; Function:
 29736                                  ;	Set up the device call header at DEVCALL
 29737                                  ; Output:
 29738                                  ;	ES:BX Points to DEVCALL
 29739                                  ; No other registers effected
 29740                                  ;
 29741                                  ;---------------------------------------------------------------------------
 29742                                  
 29743                                  SETREAD:
 29744 0000509B 57                      	PUSH	DI
 29745 0000509C 51                      	PUSH	CX
 29746 0000509D 50                      	PUSH	AX
 29747 0000509E B104                    	MOV	CL,DEVRD ; mov cl,4
 29748                                  SETCALLHEAD:
 29749 000050A0 B016                    	MOV	AL,DRDWRHL ; mov al,16h
 29750 000050A2 16                      	PUSH	SS
 29751 000050A3 07                      	POP	ES
 29752                                  					; DEVCALL is in DOSDATA
 29753 000050A4 BF[5A03]                	MOV	DI,DEVCALL
 29754                                  
 29755 000050A7 AA                      	STOSB				; length
 29756 000050A8 58                      	POP	AX			; 
 29757 000050A9 AA                      	STOSB				; Unit
 29758 000050AA 50                      	PUSH	AX
 29759 000050AB 88C8                    	MOV	AL,CL
 29760 000050AD AA                      	STOSB				; Command code
 29761 000050AE 31C0                    	XOR	AX,AX
 29762 000050B0 AB                      	STOSW				; Status
 29763 000050B1 83C708                  	ADD	DI,8			; Skip link fields
 29764 000050B4 58                      	POP	AX
 29765 000050B5 86E0                    	XCHG	AH,AL
 29766 000050B7 AA                      	STOSB				; Media byte
 29767 000050B8 86C4                    	XCHG	AL,AH
 29768 000050BA 50                      	PUSH	AX
 29769 000050BB 89D8                    	MOV	AX,BX
 29770 000050BD AB                      	STOSW
 29771                                  
 29772 000050BE 8CD8                    	MOV	AX,DS
 29773 000050C0 AB                      	STOSW				; Transfer addr
 29774                                  
 29775 000050C1 59                      	POP	CX			; Real AX
 29776 000050C2 58                      	POP	AX			; Real CX
 29777 000050C3 AB                      	STOSW				; Count
 29778                                  
 29779 000050C4 92                      	XCHG	AX,DX			; AX=Real DX, DX=real CX, CX=real AX
 29780 000050C5 AB                      	STOSW				; Start
 29781 000050C6 91                      	XCHG	AX,CX
 29782 000050C7 87D1                    	XCHG	DX,CX
 29783 000050C9 5F                      	POP	DI
 29784                                  					; DEVCALL is in DOSDATA
 29785 000050CA BB[5A03]                	MOV	BX,DEVCALL
 29786 000050CD C3                      	retn
 29787                                  
 29788                                  	;entry	SETWRITE
 29789                                  SETWRITE:
 29790                                  
 29791                                  ; Inputs:
 29792                                  ;	DS:BX = Transfer Address
 29793                                  ;	CX = Record Count
 29794                                  ;	DX = Starting Record
 29795                                  ;	AH = Media Byte
 29796                                  ;	AL = Unit Code
 29797                                  ; Function:
 29798                                  ;	Set up the device call header at DEVCALL
 29799                                  ; Output:
 29800                                  ;	ES:BX Points to DEVCALL
 29801                                  ; No other registers effected
 29802                                  
 29803 000050CE 57                      	PUSH	DI
 29804 000050CF 51                      	PUSH	CX
 29805 000050D0 50                      	PUSH	AX
 29806 000050D1 B108                    	MOV	CL,DEVWRT ; mov cl,8
 29807 000050D3 36020E[FF02]            	ADD	CL,[SS:VERFLG]		; SS override
 29808 000050D8 EBC6                    	JMP	SHORT SETCALLHEAD
 29809                                  
 29810                                  ; 30/04/2019 - Retro DOS v4.0
 29811                                  ; DOSCODE:86A8h (MSDOS 6.21, MSDOS.SYS)
 29812                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29813                                  ; DOSCODE:866Dh (MSDOS 5.0, MSDOS.SYS)
 29814                                  
 29815                                  ;Break	<RW_SC -- Read Write Secondary Cache>
 29816                                  ;---------------------------------------------------------------------------
 29817                                  ;
 29818                                  ; Procedure Name : RW_SC
 29819                                  ;
 29820                                  ; Inputs:
 29821                                  ;	 [SC_CACHE_COUNT]= secondary cache count
 29822                                  ;	 [SC_STATUS]= SC validity status
 29823                                  ;	 [SEQ_SECTOR]= last sector read
 29824                                  ; Function:
 29825                                  ;	Read from or write through secondary cache
 29826                                  ; Output:
 29827                                  ;	ES:BX Points to DEVCALL
 29828                                  ;	carry clear, I/O is not done
 29829                                  ;		     [SC_FLAG]=1 if continuos sectors will be read
 29830                                  ;	carry set, I/O is done
 29831                                  ;
 29832                                  ;----------------------------------------------------------------------------
 29833                                  
 29834                                  RW_SC:
 29835                                  	; SS override for all variables used.
 29836                                  	
 29837 000050DA 36833E[7700]00          	CMP	word [ss:SC_CACHE_COUNT],0  ;AN000;LB. secondary cache exists?
 29838 000050E0 7421                    	JZ	short scexit4		    ;AN000;LB. no, do nothing
 29839 000050E2 36833E[6C03]01          	CMP	word [ss:CALLSCNT],1	    ;AN000;LB. sector count = 1 (buffer I/O)
 29840 000050E8 7519                    	JNZ	short scexit4 		    ;AN000;LB. no, do nothing
 29841 000050EA 51                      	PUSH	CX			    ;AN000;LB.
 29842 000050EB 52                      	PUSH	DX			    ;AN000;LB. yes
 29843 000050EC 1E                      	PUSH	DS			    ;AN000;LB. save registers
 29844 000050ED 56                      	PUSH	SI			    ;AN000;LB.
 29845 000050EE 06                      	PUSH	ES			    ;AN000;LB.
 29846 000050EF 57                      	PUSH	DI			    ;AN000;LB.
 29847                                  
 29848 000050F0 368B16[6E03]            	MOV	DX,[ss:CALLSSEC]	    ;AN000;LB. starting sector
 29849 000050F5 36803E[5C03]04          	CMP	BYTE [ss:DEVCALL_REQFUNC],DEVRD ;AN000;LB. read ?
 29850 000050FB 7408                    	JZ	short doread		    ;AN000;LB. yes
 29851 000050FD E8BE00                  	CALL	INVALIDATE_SC		    ;AN000;LB. invalidate SC
 29852 00005100 E98B00                  	JMP	scexit2 		    ;AN000;LB. back to normal
 29853                                  scexit4:				    ;AN000;
 29854 00005103 F8                      	CLC				    ;AN000;LB. I/O not done yet
 29855 00005104 C3                      	retn				    ;AN000;LB.
 29856                                  doread: 				    ;AN000;
 29857 00005105 E82001                  	CALL	SC2BUF			    ;AN000;LB. check if in SC
 29858 00005108 720A                    	JC	short readSC		    ;AN000;LB.
 29859 0000510A 36C706[5D03]0001        	MOV	word [ss:DEVCALL_REQSTAT],STDON ;AN000;LB. fake done and ok
 29860 00005111 F9                      	STC				    ;AN000;LB. set carry
 29861 00005112 EB68                    	JMP	short saveseq 		    ;AN000;LB. save seq. sector #
 29862                                  readSC: 				    ;AN000;
 29863 00005114 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]   	    ;AN000;LB. subtract sector num from
 29864 00005118 368B0E[6E03]            	MOV	CX,[ss:CALLSSEC]	    ;AN000;LB. saved sequential sector
 29865 0000511D 362B0E[FA0D]            	SUB	CX,[ss:SEQ_SECTOR]    	    ;AN000;LB. number
 29866 00005122 361B06[FC0D]            	SBB	AX,[ss:SEQ_SECTOR+2]  	    ;AN000;LB.
 29867                                  	; 24/09/2023
 29868                                  	;CMP	AX,0			    ;AN000;LB. greater than 64K
 29869 00005127 7552                    	JNZ	short saveseq2		    ;AN000;LB. yes,save seq. sector #
 29870                                  chklow: 						
 29871 00005129 83F901                  	CMP	CX,1			    ;AN000;LB. <= 1
 29872 0000512C 774D                    	JA	short saveseq2		    ;AN000;LB. no, not sequential
 29873 0000512E 36C706[050E]FFFF        	MOV	word [ss:SC_STATUS],-1	    ;AN000;LB. presume all SC valid
 29874 00005135 36A1[7700]              	MOV	AX,[ss:SC_CACHE_COUNT]	    ;AN000;LB. yes, sequential
 29875 00005139 36A3[6C03]              	MOV	[ss:CALLSCNT],AX	    ;AN000;LB. read continuous sectors
 29876                                  readsr:
 29877 0000513D 36A1[6A03]              	MOV	AX,[ss:CALLXAD+2]	    ;AN000;LB. save buffer addr
 29878 00005141 36A3[0E06]              	MOV	[ss:TEMP_VAR2],AX	    ;AN000;LB. in temp vars
 29879 00005145 36A1[6803]              	MOV	AX,[ss:CALLXAD]	    	    ;AN000;LB.
 29880 00005149 36A3[0C06]              	MOV	[ss:TEMP_VAR],AX	    ;AN000;LB.
 29881                                  
 29882 0000514D 36A1[7300]              	MOV	AX,[ss:SC_CACHE_PTR]	    ;AN000;LB. use SC cache addr as
 29883 00005151 36A3[6803]              	MOV	[ss:CALLXAD],AX		    ;AN000;LB. transfer addr
 29884 00005155 36A1[7500]              	MOV	AX,[ss:SC_CACHE_PTR+2]	    ;AN000;LB.
 29885 00005159 36A3[6A03]              	MOV	[ss:CALLXAD+2],AX	    ;AN000;LB.
 29886 0000515D 36C606[070E]01          	MOV	byte [ss:SC_FLAG],1	    ;AN000;LB. flag it for later;
 29887 00005163 36A0[000E]              	MOV	AL,[ss:SC_DRIVE]	    ;AN000;LB. current drive
 29888 00005167 36A2[9C12]              	MOV	[ss:CurSC_DRIVE],AL	    ;AN000;LB. set current drive
 29889 0000516B 36A1[6E03]              	MOV	AX,[ss:CALLSSEC]	    ;AN000;LB. current sector
 29890 0000516F 36A3[010E]              	MOV	[ss:CurSC_SECTOR],AX	    ;AN000;LB. set current sector
 29891 00005173 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;LB.
 29892 00005177 36A3[030E]              	MOV	[ss:CurSC_SECTOR+2],AX	    ;AN000;LB.
 29893                                  saveseq2:				    ;AN000;
 29894 0000517B F8                      	CLC				    ;AN000;LB. clear carry
 29895                                  saveseq:				    ;AN000;	
 29896 0000517C 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;LB. save current sector #
 29897 00005180 36A3[FC0D]              	MOV	[ss:SEQ_SECTOR+2],AX	    ;AN000;LB. for access mode ref.
 29898 00005184 36A1[6E03]              	MOV	AX,[ss:CALLSSEC]	    ;AN000;LB.	
 29899 00005188 36A3[FA0D]              	MOV	[ss:SEQ_SECTOR],AX 	    ;AN000;LB.	
 29900 0000518C EB01                    	JMP	short scexit 		    ;AN000;LB.	
 29901                                  scexit2:				    ;AN000;LB.
 29902 0000518E F8                      	CLC				    ;AN000;LB.	clear carry
 29903                                  scexit: 				    ;AN000;		
 29904 0000518F 5F                      	POP	DI			    ;AN000;LB.
 29905 00005190 07                      	POP	ES			    ;AN000;LB. restore registers
 29906 00005191 5E                      	POP	SI			    ;AN000;LB.
 29907 00005192 1F                      	POP	DS			    ;AN000;LB.
 29908 00005193 5A                      	POP	DX			    ;AN000;LB.
 29909 00005194 59                      	POP	CX			    ;AN000;LB.
 29910 00005195 C3                      	retn				    ;AN000;LB.
 29911                                  
 29912                                  ;Break	<IN_SC -- check if in secondary cache>
 29913                                  ;--------------------------------------------------------------------------
 29914                                  ;
 29915                                  ; Procedure Name : IN_SC
 29916                                  ;
 29917                                  ; Inputs:  [SC_DRIVE]= requesting drive
 29918                                  ;	   [CURSC_DRIVE]= current SC drive
 29919                                  ;	   [CURSC_SECTOR]= starting scetor # of SC
 29920                                  ;	   [SC_CACHE_COUNT]= SC count
 29921                                  ;	   [HIGH_SECTOR]:DX= sector number
 29922                                  ; Function:
 29923                                  ;	Check if the sector is in secondary cache
 29924                                  ; Output:
 29925                                  ;	carry clear, in SC
 29926                                  ;	   CX= the index in the secondary cache
 29927                                  ;	carry set, not in SC
 29928                                  ;
 29929                                  ;---------------------------------------------------------------------------
 29930                                  
 29931                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29932                                  IN_SC:
 29933                                  	; SS override for all variables used
 29934 00005196 36A0[000E]              	MOV	AL,[ss:SC_DRIVE]	    ;AN000;;LB. current drive
 29935 0000519A 363A06[9C12]            	CMP	AL,[ss:CurSC_DRIVE]	    ;AN000;;LB. same as SC drive
 29936 0000519F 751B                    	JNZ	short outrange2		    ;AN000;;LB. no
 29937 000051A1 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;;LB. subtract sector num from
 29938 000051A5 89D1                    	MOV	CX,DX			    ;AN000;;LB. secondary starting sector
 29939 000051A7 362B0E[010E]            	SUB	CX,[ss:CurSC_SECTOR]        ;AN000;;LB. number
 29940 000051AC 361B06[030E]            	SBB	AX,[ss:CurSC_SECTOR+2]      ;AN000;;LB.
 29941                                  	; 24/09/2023
 29942                                  	;CMP	AX,0			    ;AN000;;LB. greater than 64K
 29943 000051B1 7509                    	JNZ	short outrange2		    ;AN000;;LB. yes
 29944 000051B3 363B0E[7700]            	CMP	CX,[ss:SC_CACHE_COUNT]	    ;AN000;;LB. greater than SC count
 29945 000051B8 7302                    	JAE	short outrange2		    ;AN000;;LB. yes
 29946 000051BA F8                      	CLC				    ;AN000;;LB. clear carry
 29947                                  	;JMP	short inexit		    ;AN000;;LB. in SC
 29948                                  	; 16/12/2022
 29949 000051BB C3                      	retn	; 30/04/2019
 29950                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29951                                  	;jmp	short inexit
 29952                                  
 29953                                  outrange2:				    ;AN000;;LB. set carry
 29954 000051BC F9                      	STC				    ;AN000;;LB.
 29955                                  inexit: 				    ;AN000;;LB.
 29956 000051BD C3                      	retn				    ;AN000;;LB.
 29957                                  
 29958                                  ;Break	<INVALIDATE_SC - invalide secondary cache>
 29959                                  ;---------------------------------------------------------------------------
 29960                                  ;
 29961                                  ; Procedure Name : Invalidate_Sc
 29962                                  ;
 29963                                  ; Inputs:  [SC_DRIVE]= requesting drive
 29964                                  ;	   [CURSC_DRIVE]= current SC drive
 29965                                  ;	   [CURSC_SECTOR]= starting scetor # of SC
 29966                                  ;	   [SC_CACHE_COUNT]= SC count
 29967                                  ;	   [SC_STATUS]= SC status word
 29968                                  ;	   [HIGH_SECTOR]:DX= sector number
 29969                                  ;
 29970                                  ; Function:
 29971                                  ;	invalidate secondary cache if in there
 29972                                  ; Output:
 29973                                  ;	[SC_STATUS] is updated
 29974                                  ;---------------------------------------------------------------------------
 29975                                  
 29976                                  INVALIDATE_SC:
 29977                                  	; SS override for all variables used
 29978                                  
 29979 000051BE E8D5FF                  	CALL	IN_SC			    ;AN000;;LB. in secondary cache
 29980 000051C1 720C                    	JC	short outrange		    ;AN000;;LB. no
 29981 000051C3 B80100                  	MOV	AX,1			    ;AN000;;LB. invalidate the sector
 29982 000051C6 D3E0                    	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
 29983 000051C8 F7D0                    	NOT	AX			    ;AN000;;LB.
 29984 000051CA 362106[050E]            	AND	[ss:SC_STATUS],AX	    ;AN000;;LB. save the status
 29985                                  outrange:				    ;AN000;;LB.
 29986 000051CF C3                      	retn				    ;AN000;;LB.
 29987                                  
 29988                                  ; DOSCODE:87A5h (MSDOS 6.21, MSDOS.SYS)
 29989                                  ; 22/11/2022
 29990                                  ; DOSCODE:876Ah (MSDOS 5.0, MSDOS.SYS)
 29991                                  
 29992                                  ;Break	<VIRREAD- virtually read data into buffer>
 29993                                  ;--------------------------------------------------------------------------
 29994                                  ;
 29995                                  ; Procedure Name : SC_FLAG
 29996                                  ;
 29997                                  ; Inputs:  SC_FLAG = 0, no sectors were read into SC
 29998                                  ;		     1, continuous sectors were read into SC
 29999                                  ; Function:
 30000                                  ;	   Move data from SC to buffer
 30001                                  ; Output:
 30002                                  ;	 carry clear, data is moved to buffer
 30003                                  ;	 carry set, bad sector or exceeds maximum sector
 30004                                  ;	   SC_FLAG =0
 30005                                  ;	   CALLSCNT=1
 30006                                  ;	   SC_STATUS= -1 if succeeded
 30007                                  ;     
 30008                                  ;		       0 if failed
 30009                                  ;--------------------------------------------------------------------------
 30010                                  
 30011                                  VIRREAD:
 30012                                  	; SS override for all variables used
 30013                                  
 30014 000051D0 36803E[070E]00          	CMP	byte [ss:SC_FLAG],0	    ;AN000;;LB. from SC fill
 30015 000051D6 744E                    	JZ	short sc2end		    ;AN000;;LB. no
 30016 000051D8 36A1[0E06]              	MOV	AX,[ss:TEMP_VAR2]	    ;AN000;;LB. restore buffer addr
 30017 000051DC 36A3[6A03]              	MOV	[ss:CALLXAD+2],AX	    ;AN000;;LB.
 30018 000051E0 36A1[0C06]              	MOV	AX,[ss:TEMP_VAR]	    ;AN000;;LB.
 30019 000051E4 36A3[6803]              	MOV	[ss:CALLXAD],AX		    ;AN000;;LB.
 30020 000051E8 36C606[070E]00          	MOV	byte [ss:SC_FLAG],0	    ;AN000;;LB. reset sc_flag
 30021 000051EE 36C706[6C03]0100        	MOV	word [ss:CALLSCNT],1	    ;AN000;;LB. one sector transferred
 30022                                  
 30023                                  	;TEST	word [SS:DEVCALL_REQSTAT],STERR ;AN000;;LB. error?
 30024 000051F5 36F606[5E03]80          	test	byte [ss:DEVCALL_REQSTAT+1],(STERR>>8) ; 80h
 30025 000051FB 7513                    	JNZ	short scerror 		    ;AN000;;LB. yes
 30026 000051FD 1E                      	PUSH	DS			    ;AN000;;LB.
 30027 000051FE 56                      	PUSH	SI			    ;AN000;;LB.
 30028 000051FF 06                      	PUSH	ES			    ;AN000;;LB.
 30029 00005200 57                      	PUSH	DI			    ;AN000;;LB.
 30030 00005201 52                      	PUSH	DX			    ;AN000;;LB.
 30031 00005202 51                      	PUSH	CX			    ;AN000;;LB.
 30032 00005203 31C9                    	XOR	CX,CX			    ;AN000;;LB. we want first sector in SC
 30033 00005205 E83100                  	CALL	SC2BUF2 		    ;AN000;;LB. move data from SC to buf
 30034 00005208 59                      	POP	CX
 30035 00005209 5A                      	POP	DX			    ;AN000;;LB.
 30036 0000520A 5F                      	POP	DI			    ;AN000;;LB.
 30037 0000520B 07                      	POP	ES			    ;AN000;;LB.
 30038 0000520C 5E                      	POP	SI			    ;AN000;;LB.
 30039 0000520D 1F                      	POP	DS			    ;AN000;;LB.
 30040 0000520E EB16                    	JMP	SHORT sc2end		    ;AN000;;LB. return
 30041                                  scerror:				    ;AN000;
 30042 00005210 36C706[6C03]0100        	MOV	word [ss:CALLSCNT],1	    ;AN000;;LB. reset sector count to 1
 30043 00005217 36C706[050E]0000        	MOV	word [ss:SC_STATUS],0	    ;AN000;;LB. invalidate all SC sectors
 30044 0000521E 36C606[9C12]FF          	MOV	byte [ss:CurSC_DRIVE],-1    ;AN000;;LB. invalidate drive
 30045 00005224 F9                      	STC				    ;AN000;;LB. carry set
 30046 00005225 C3                      	retn				    ;AN000;;LB.
 30047                                  sc2end: 				    ;AN000;
 30048 00005226 F8                      	CLC				    ;AN000;;LB. carry clear
 30049 00005227 C3                      	retn				    ;AN000;;LB.
 30050                                  
 30051                                  ; 30/04/2019 - Retro  DOS v4.0
 30052                                  ; DOSCODE:87FDh (MSDOS 6.21, MSDOS.SYS)
 30053                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30054                                  ; DOSCODE:87C2h (MSDOS 5.0, MSDOS.SYS)
 30055                                  
 30056                                  ;Break	<SC2BUF- move data from SC to buffer>
 30057                                  ;----------------------------------------------------------------------------
 30058                                  ;
 30059                                  ; Procedure Name : SC2BUF
 30060                                  ;
 30061                                  ; Inputs:  [SC_STATUS] = SC validity status
 30062                                  ;	   [SC_SECTOR_SIZE] = request sector size
 30063                                  ;	   [SC_CACHE_PTR] = pointer to SC
 30064                                  ; Function:
 30065                                  ;	   Move data from SC to buffer
 30066                                  ; Output:
 30067                                  ;	   carry clear, in SC  and data is moved
 30068                                  ;	   carry set, not in SC and data is not moved
 30069                                  ;---------------------------------------------------------------------------
 30070                                  
 30071                                  SC2BUF:
 30072                                  	; SS override for all variables used
 30073 00005228 E86BFF                  	CALL	IN_SC			    ;AN000;LB. in secondary cache
 30074                                  	;JC	short noSC		    ;AN000;LB. no
 30075                                  	; 24/09/2023
 30076 0000522B 723D                    	jc	short sexit
 30077 0000522D B80100                  	MOV	AX,1			    ;AN000;LB. check if valid sector
 30078 00005230 D3E0                    	SHL	AX,CL			    ;AN000;LB. in the secondary cache
 30079 00005232 368506[050E]            	TEST	[ss:SC_STATUS],AX	    ;AN000;LB.
 30080 00005237 7430                    	JZ	short noSC		    ;AN000;LB. invalid
 30081                                  ;entry SC2BUF2
 30082                                  SC2BUF2:				    ;AN000;
 30083                                  	;MOV	AX,CX			    ;AN000;LB. times index with
 30084                                  	;MUL	word [ss:SC_SECTOR_SIZE]    ;AN000;LB. sector size
 30085                                  	; 24/09/2023
 30086 00005239 36A1[FE0D]              	mov	ax,[ss:SC_SECTOR_SIZE]
 30087 0000523D 91                      	xchg	ax,cx ; cx = [ss:SC_SECTOR_SIZE]
 30088 0000523E F7E1                    	mul	cx
 30089 00005240 360306[7300]            	ADD	AX,[ss:SC_CACHE_PTR]	    ;AN000;LB. add SC starting addr
 30090 00005245 361316[7500]            	ADC	DX,[ss:SC_CACHE_PTR+2]	    ;AN000;LB.
 30091 0000524A 8EDA                    	MOV	DS,DX			    ;AN000;LB. DS:SI-> SC sector addr
 30092 0000524C 89C6                    	MOV	SI,AX			    ;AN000;LB.
 30093 0000524E 368E06[6A03]            	MOV	ES,[ss:CALLXAD+2]		    ;AN000;LB. ES:DI-> buffer addr
 30094 00005253 368B3E[6803]            	MOV	DI,[ss:CALLXAD]		    ;AN000;LB.
 30095                                  	; 24/09/2023
 30096                                  	;MOV	CX,[ss:SC_SECTOR_SIZE]	    ;AN000;LB. count= sector size
 30097 00005258 D1E9                    	SHR	CX,1			    ;AN000;LB. may use DWORD move for 386
 30098                                  ;entry MOVWORDS
 30099                                  MOVWORDS:				    ;AN000;
 30100 0000525A 36803E[6A00]00          	CMP	byte [ss:DDMOVE],0	    ;AN000;LB. 386 ?
 30101 00005260 7403                    	JZ	short nodd		    ;AN000;LB. no
 30102 00005262 D1E9                    	SHR	CX,1			    ;AN000;LB. words/2
 30103 00005264 66                      	DB	66H			    ;AN000;LB. use double word move
 30104                                  nodd:
 30105 00005265 F3A5                    	REP	MOVSW			    ;AN000;LB. move to buffer
 30106 00005267 F8                      	CLC				    ;AN000;LB. clear carry
 30107 00005268 C3                      	retn				    ;AN000;LB. exit
 30108                                  noSC:					    ;AN000;
 30109 00005269 F9                      	STC				    ;AN000;LB. set carry
 30110                                  sexit:					    ;AN000;
 30111 0000526A C3                      	retn				    ;AN000;LB.
 30112                                  
 30113                                  ;============================================================================
 30114                                  ; MKNODE.ASM, MSDOS 6.0, 1991
 30115                                  ;============================================================================
 30116                                  ; 29/07/2018 - Retro DOS v3.0
 30117                                  ; 19/05/2019 - Retro DOS v4.0
 30118                                  
 30119                                  ;	TITLE	MKNODE - Node maker
 30120                                  ;	NAME	MKNODE
 30121                                  
 30122                                  ;**	MKNODE.ASM
 30123                                  ;----------------------------------------------------------------------------
 30124                                  ;	Low level routines for making a new local file system node
 30125                                  ;	and filling in an SFT from a directory entry
 30126                                  ;
 30127                                  ;	BUILDDIR
 30128                                  ;	SETDOTENT
 30129                                  ;	MakeNode
 30130                                  ;	NEWENTRY
 30131                                  ;	FREEENT
 30132                                  ;	NEWDIR
 30133                                  ;	DOOPEN
 30134                                  ;	RENAME_MAKE
 30135                                  ;	CHECK_VIRT_OPEN
 30136                                  ;
 30137                                  ;	Revision history:
 30138                                  ;
 30139                                  ;	 AN000	version 4.0  Jan. 1988
 30140                                  ;	 A004	PTM 3680  --- Make SFT NAME field offset same as 3.30
 30141                                  
 30142                                  ;Break   <BUILDDIR,NEWDIR -- ALLOCATE DIRECTORIES>
 30143                                  ;----------------------------------------------------------------------------
 30144                                  ;
 30145                                  ; Procedure Name : BUILDDIR,NEWDIR
 30146                                  ;
 30147                                  ; Inputs:
 30148                                  ;       ES:BP Points to DPB
 30149                                  ;       [THISSFT] Set if using NEWDIR entry point
 30150                                  ;               (used by ALLOCATE)
 30151                                  ;       [LASTENT] current last valid entry number in directory if no free
 30152                                  ;               entries
 30153                                  ;       [DIRSTART] Points to first cluster of dir (0 means root)
 30154                                  ; Function:
 30155                                  ;       Grow directory if no free entries and not root
 30156                                  ; Outputs:
 30157                                  ;       CARRY SET IF FAILURE
 30158                                  ;       ELSE
 30159                                  ;          AX entry number of new entry
 30160                                  ;          If a new dir [DIRSTART],[CLUSFAC],[CLUSNUM],[DIRSEC] set
 30161                                  ;               AX = first entry of new dir
 30162                                  ;       GETENT should be called to set [LASTENT]
 30163                                  ;
 30164                                  ;----------------------------------------------------------------------------
 30165                                  
 30166                                  ; 19/05/2019 - Retro DOS v4.0
 30167                                  ; DOSCODE:8845h (MSDOS 6.21, MSDOS.SYS)
 30168                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30169                                  ; DOSCODE:880Ah (MSDOS 6.21, MSDOS.SYS)
 30170                                  
 30171                                  ; 24/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 MSDOS.SYS)
 30172                                  ; DOSCODE:8845h (MSDOS 6.22, MSDOS.SYS)
 30173                                  
 30174                                  BUILDDIR:
 30175                                  	; 29/07/2018 - Retro DOS v3.0
 30176                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 4E66h
 30177                                  
 30178 0000526B A1[D805]                        MOV     AX,[ENTFREE]
 30179 0000526E 83F8FF                          CMP     AX,-1 ; 0FFFFh
 30180                                  	;JZ	short CHECK_IF_ROOT
 30181                                          ;CLC
 30182                                          ;retn
 30183                                  	; 24/09/2023
 30184 00005271 7507                    	jne	short builddir_cmc_retn  ; cf=1 (will be 0)
 30185                                  
 30186                                  CHECK_IF_ROOT:
 30187 00005273 833E[C205]00                    CMP     word [DIRSTART],0
 30188 00005278 7502                            JNZ	short NEWDIR
 30189                                          ;STC
 30190                                  	; 24/09/2023
 30191                                  	; [DIRSTART]=0, cf=0, zf=1 (cf will be 1 after cmc instruction)
 30192                                  builddir_cmc_retn:
 30193                                  	; 24/09/2023
 30194 0000527A F5                      	cmc	; cf=1 <-> cf=0
 30195                                  builddir_retn:
 30196 0000527B C3                              retn				; Can't grow root
 30197                                  
 30198                                  	;entry   NEWDIR
 30199                                  NEWDIR: 
 30200 0000527C 8B1E[C205]              	MOV     BX,[DIRSTART]
 30201 00005280 09DB                            OR      BX,BX
 30202 00005282 7405                            JZ	short NULLDIR
 30203 00005284 E82806                  	call	GETEOF
 30204 00005287 72F2                            jc	short builddir_retn	; Screw up
 30205                                  NULLDIR:
 30206 00005289 B90100                          MOV     CX,1
 30207 0000528C E83905                  	call	ALLOCATE
 30208 0000528F 72EA                            jc	short  builddir_retn
 30209 00005291 8B16[C205]                      MOV     DX,[DIRSTART]
 30210 00005295 09D2                            OR      DX,DX
 30211 00005297 750D                            JNZ	short ADDINGDIR
 30212 00005299 E826F5                  	call	SETDIRSRCH
 30213 0000529C 72DD                            jc	short  builddir_retn
 30214 0000529E C706[4803]FFFF                  MOV     word [LASTENT],-1
 30215 000052A4 EB29                            JMP     SHORT GOTDIRREC
 30216                                  ADDINGDIR:
 30217 000052A6 53                              PUSH    BX
 30218 000052A7 8B1E[BC05]                      MOV     BX,[CLUSNUM]
 30219 000052AB E82D0C                          call	IsEOF
 30220 000052AE 5B                              POP     BX
 30221 000052AF 7217                            JB	short NOTFIRSTGROW
 30222                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 30223 000052B1 891E[BC05]                      MOV     [CLUSNUM],BX
 30224                                  	; 24/09/2023
 30225                                  	;PUSH	CX ; (not necessary)
 30226 000052B5 50                      	PUSH	AX
 30227 000052B6 55                      	PUSH	BP
 30228 000052B7 B401                            MOV     AH,1			; CLUSNUM update
 30229                                  	; 15/12/2022
 30230 000052B9 268A5600                	mov	dl,[ES:BP] ; 09/09/2018
 30231                                          ; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30232                                  	;;mov	dl,[es:bp+0]
 30233                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; drive #
 30234 000052BD 8B0E[C205]                      MOV     CX,[DIRSTART]		; first cluster #
 30235 000052C1 89DD                            MOV     BP,BX 			; CLUSNUM
 30236 000052C3 E8C6DA                  	call	FastOpen_Update
 30237 000052C6 5D                              POP     BP
 30238 000052C7 58                              POP     AX
 30239                                  	; 24/09/2023
 30240                                          ;POP	CX
 30241                                  
 30242                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 30243                                  NOTFIRSTGROW:
 30244 000052C8 89DA                            MOV     DX,BX
 30245 000052CA 30DB                            XOR     BL,BL
 30246 000052CC E8CC04                  	call	FIGREC
 30247                                  GOTDIRREC:
 30248                                  	;mov	cl,[es:bp+4]
 30249 000052CF 268A4E04                        MOV     CL,[ES:BP+DPB.CLUSTER_MASK]
 30250 000052D3 FEC1                            INC     CL
 30251 000052D5 30ED                            XOR     CH,CH
 30252                                  ZERODIR:
 30253 000052D7 51                              PUSH    CX
 30254                                  	; 22/09/2023
 30255                                  	;;mov	byte [ALLOWED],18h
 30256                                          ;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 30257 000052D8 B0FF                            MOV     AL,0FFH
 30258                                          ;call	GETBUFFR
 30259 000052DA E85010                          call	GETBUFFRD ; *
 30260 000052DD 7302                    	JNC	short GET_SSIZE
 30261 000052DF 59                              POP     CX
 30262 000052E0 C3                              retn
 30263                                  
 30264                                  GET_SSIZE:
 30265                                  	;mov	cx,[es:bp+2]
 30266 000052E1 268B4E02                        MOV     CX,[ES:BP+DPB.SECTOR_SIZE]
 30267 000052E5 06                              PUSH    ES
 30268 000052E6 C43E[E205]                      LES     DI,[CURBUF]
 30269                                  	;or	byte [es:di+5],4
 30270 000052EA 26804D0504                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 30271 000052EF 57                              PUSH    DI
 30272                                  	;;add	di,16	; MSDOS 3.3
 30273                                  	;add	di,20	; MSDOS 6.0	
 30274 000052F0 83C718                          ADD     DI,BUFINSIZ
 30275 000052F3 31C0                            XOR     AX,AX
 30276 000052F5 D1E9                            SHR     CX,1
 30277 000052F7 F3AB                            REP     STOSW
 30278 000052F9 7301                            JNC	short EVENZ
 30279 000052FB AA                              STOSB
 30280                                  EVENZ:
 30281 000052FC 5F                              POP     DI
 30282                                  
 30283                                  	; MSDOS 6.0
 30284 000052FD 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 30285                                  					;LB. if already dirty		  ;AN000;
 30286 00005302 7508                            JNZ	short yesdirty7		;LB.  don't increment dirty count ;AN000;
 30287 00005304 E83912                          call	INC_DIRTY_COUNT		;LB. 				  ;AN000;
 30288                                          
 30289                                  	;or	byte [es:di+5],40h
 30290 00005307 26804D0540              	OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 30291                                  yesdirty7:
 30292 0000530C 07                              POP	ES
 30293 0000530D 59                              POP	CX
 30294                                  
 30295                                  	; 19/05/2019 - Retro DOS v4.0
 30296                                  
 30297                                  	; MSDOS 3.3
 30298                                  	;INC	DX
 30299                                  
 30300                                  	; MSDOS 6.0
 30301                                  	; 24/09/2023
 30302                                  	;add	dx,1
 30303                                  	;;adc	word [HIGH_SECTOR],0
 30304                                  	;; 24/09/2023
 30305                                  	;; ax=0
 30306                                  	;adc	[HIGH_SECTOR],ax ; 0
 30307                                  	; 24/09/2023
 30308 0000530E 42                      	inc	dx
 30309 0000530F 7504                    	jnz	short loop_zerodir
 30310 00005311 FF06[0706]              	inc	word [HIGH_SECTOR]
 30311                                  loop_zerodir:
 30312 00005315 E2C0                            LOOP    ZERODIR
 30313                                  
 30314 00005317 A1[4803]                        MOV     AX,[LASTENT]
 30315 0000531A 40                              INC     AX
 30316                                  	; 24/09/2023
 30317                                  	; cf=0
 30318                                  	;CLC
 30319 0000531B C3                              retn
 30320                                  
 30321                                  ;--------------------------------------------------------------------------
 30322                                  ;
 30323                                  ; Procedure Name : SETDOTENT
 30324                                  ;
 30325                                  ; set up a . or .. directory entry for a directory.
 30326                                  ;
 30327                                  ;   Inputs:     ES:DI point to the beginning of a directory entry.
 30328                                  ;               AX contains ". " or ".."
 30329                                  ;               DX contains first cluster of entry
 30330                                  ;
 30331                                  ;----------------------------------------------------------------------------
 30332                                  
 30333                                  SETDOTENT:
 30334                                  ;	Fill in name field
 30335 0000531C AB                              STOSW
 30336 0000531D B90400                          MOV     CX,4
 30337 00005320 B82020                          MOV     AX,"  " ; 2020h
 30338 00005323 F3AB                            REP     STOSW
 30339 00005325 AA                              STOSB
 30340                                  
 30341                                  ;	Set up attribute
 30342                                  	;mov	al, 10h
 30343 00005326 B010                            MOV     AL,attr_directory
 30344 00005328 AA                              STOSB
 30345                                  
 30346                                  ;	Initialize time and date of creation
 30347 00005329 83C70A                          ADD     DI,10
 30348 0000532C 8B36[9E05]                      MOV     SI,[THISSFT]
 30349                                  	;mov	ax,[si+0Dh]
 30350 00005330 8B440D                          MOV     AX,[SI+SF_ENTRY.sf_time]
 30351 00005333 AB                              STOSW
 30352                                  	;mov	ax,[si+0Fh]
 30353 00005334 8B440F                          MOV     AX,[SI+SF_ENTRY.sf_date]
 30354 00005337 AB                      	STOSW
 30355                                  
 30356                                  ;	Set up first cluster field
 30357 00005338 89D0                            MOV     AX,DX
 30358 0000533A AB                              STOSW
 30359                                  
 30360                                  ;	0 file size
 30361 0000533B 31C0                            XOR     AX,AX
 30362 0000533D AB                              STOSW
 30363 0000533E AB                              STOSW
 30364 0000533F C3                              retn
 30365                                  
 30366                                  ;Break   <MAKENODE -- CREATE A NEW NODE>
 30367                                  ;---------------------------------------------------------------------------
 30368                                  ;
 30369                                  ; Procedure Name : MakeNode
 30370                                  ;
 30371                                  ; Inputs:
 30372                                  ;       AL - attribute to create
 30373                                  ;       AH = 0 if it is ok to truncate a file already by this name
 30374                                  ;	AH != 0 if truncation not allowed (prexisting file is an error)
 30375                                  ;               (AH ignored on dirs and devices)
 30376                                  ;
 30377                                  ;        NOTE: When making a DIR or volume ID, AH need not be set since
 30378                                  ;               a name already existant is ALWAYS an error in these cases.
 30379                                  ;
 30380                                  ;       [WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 30381                                  ;               terminated)
 30382                                  ;       [CURR_DIR_END] Points to end of Current dir part of string
 30383                                  ;               ( = -1 if current dir not involved, else
 30384                                  ;                Points to first char after last "/" of current dir part)
 30385                                  ;       [THISCDS] Points to CDS being used
 30386                                  ;       [THISSFT] Points to an empty SFT. EXCEPT sf_mode filled in.
 30387                                  ; Function:
 30388                                  ;       Make a new node
 30389                                  ; Outputs:
 30390                                  ;       Sets EXTERR_LOCUS = errLOC_Disk or errLOC_Unk via GetPathNoset
 30391                                  ;       CARRY SET IF ERROR
 30392                                  ;          AX = 1 A node by this name exists and is a directory
 30393                                  ;          AX = 2 A new node could not be created
 30394                                  ;          AX = 3 A node by this name exists and is a disk file
 30395                                  ;               (AH was NZ on input)
 30396                                  ;          AX = 4 Bad Path
 30397                                  ;               SI return from GetPath maintained
 30398                                  ;          AX = 5 Attribute mismatch
 30399                                  ;          AX = 6 Sharing Violation
 30400                                  ;               (INT 24 generated ALWAYS since create is always compat mode
 30401                                  ;          AX = 7 file not found for Extended Open (not exists and fails)
 30402                                  ;       ELSE
 30403                                  ;          AX = 0 Disk Node
 30404                                  ;          AX = 3 Device Node (error in some cases)
 30405                                  ;          [DIRSTART],[DIRSEC],[CLUSFAC],[CLUSNUM] set to directory
 30406                                  ;               containing new node.
 30407                                  ;          [CURBUF+2]:BX Points to entry
 30408                                  ;          [CURBUF+2]:SI Points to entry.dir_first
 30409                                  ;          [THISSFT] is filled in
 30410                                  ;               sf_mode = unchanged.
 30411                                  ;          Attribute byte in entry is input AL
 30412                                  ; DS preserved, others destroyed
 30413                                  ;
 30414                                  ;-------------------------------------------------------------------------
 30415                                  
 30416                                  ; 19/05/2019 - Retro DOS v4.0
 30417                                  ; DOSCODE:8925h (MSDOS 6.21, MSDOS.SYS)
 30418                                  
 30419                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30420                                  ; DOSCODE:88EAh (MSDOS 5.0, MSDOS.SYS)
 30421                                  
 30422                                  MakeNode:
 30423                                  	;mov	word [CREATING],0E5FFh
 30424 00005340 C706[7E05]FFE5          	MOV	WORD [CREATING],DIRFREE*256 + 0FFh ; Creating, not DEL *.*
 30425 00005346 50                              PUSH    AX              ; Save AH value
 30426 00005347 C606[4C03]00            	MOV	byte [NoSetDir],0
 30427 0000534C A2[6D05]                	MOV	[SATTRIB],AL
 30428 0000534F E888F5                  	call	GetPathNoSet
 30429 00005352 88CA                            MOV     DL,CL           ; Save CL info
 30430 00005354 89C1                            MOV     CX,AX           ; Device ID to CH
 30431 00005356 58                              POP     AX              ; Get back AH
 30432 00005357 732E                            JNC	short make_exists ; File existed
 30433 00005359 7505                            JNZ	short make_err_4 ; Path bad
 30434 0000535B 80FA80                          CMP     DL,80h          ; Check "CL" return from GETPATH
 30435 0000535E 7406                            JZ	short make_type	; Name simply not found, and no metas
 30436                                  make_err_4:
 30437 00005360 B004                            MOV     AL,4            ; case 1 bad path
 30438                                  make_err_ret:
 30439 00005362 30E4                            XOR     AH,AH
 30440 00005364 F9                              STC
 30441                                  ;make_retn:	; 22/11/2022
 30442 00005365 C3                              retn
 30443                                  
 30444                                          ;entry	RENAME_MAKE     ; Used by DOS_RENAME to "copy" a node
 30445                                  RENAME_MAKE:
 30446                                  make_type:
 30447                                  ;Extended Open hooks
 30448                                  	; MSDOS 6.0
 30449                                  	;TESTB	EXTOPEN_ON,EXT_OPEN_ON	;FT. from extended open		;AN000;
 30450 00005366 F606[F605]01            	test	byte [EXTOPEN_ON],EXT_OPEN_ON ; 1
 30451 0000536B 7411                    	JZ	short make_type2	;FT. no				;AN000;
 30452 0000536D 800E[F605]04            	OR	byte [EXTOPEN_ON],EXT_FILE_NOT_EXISTS ; 4
 30453                                  					;FT. set for extended open ;AN000;
 30454                                  	;TESTB	EXTOPEN_FLAG,0F0H	;FT. not exists and fails	;AN000;
 30455 00005372 F606[F405]F0            	test	byte [EXTOPEN_FLAG],0F0h
 30456 00005377 7505                    	JNZ	short make_type2	;FT. no				;AN000;
 30457 00005379 F9                      	STC				;FT. set carry			;AN000;
 30458 0000537A B80700                  	MOV    AX,7			;FT. file not found		;AN000;
 30459                                  	; 22/11/2022
 30460                                  make_retn:
 30461                                  	;return
 30462 0000537D C3                      	retn				;FT.				;AN000;
 30463                                  
 30464                                  ;	Extended Open hooks
 30465                                  
 30466                                  make_type2:
 30467 0000537E C43E[9E05]                      LES     DI,[THISSFT]
 30468 00005382 31C0                            XOR     AX,AX           ; nothing exists Disk Node
 30469 00005384 F9                              STC                     ; Not found
 30470 00005385 EB5A                            JMP     short make_new
 30471                                  
 30472                                  ; The node exists. It may be either a device, directory or file:
 30473                                  ;   Zero set => directory
 30474                                  ;   High bit of CH on => device
 30475                                  ;   else => file
 30476                                  
 30477                                  make_exists:
 30478 00005387 7448                            JZ	short make_exists_dir
 30479 00005389 B003                            MOV     AL,3            ; file exists type 3  (error or device node)
 30480                                  	;test	byte [ATTRIB],18h
 30481 0000538B F606[6B05]18            	TEST	byte [ATTRIB],attr_volume_id+attr_directory
 30482 00005390 753B                            JNZ	short make_err_ret_5
 30483                                  				; Cannot already exist as Disk or Device Node
 30484                                                                  ;       if making DIR or Volume ID
 30485 00005392 08ED                            OR      CH,CH
 30486 00005394 781A                            JS	short make_share ; No further checks on attributes if device
 30487 00005396 08E4                            OR      AH,AH
 30488 00005398 75C8                            JNZ	short make_err_ret ; truncating NOT OK (AL = 3)
 30489 0000539A 51                              PUSH    CX              ; Save device ID
 30490 0000539B 8E06[E405]                      MOV     ES,[CURBUF+2]
 30491                                  	;mov	ch,[es:bx+0Bh]
 30492 0000539F 268A6F0B                        MOV     CH,[ES:BX+dir_entry.dir_attr] ; Get file attributes
 30493                                  	;test	ch,1
 30494 000053A3 F6C501                  	test	CH,attr_read_only
 30495 000053A6 7524                            JNZ	short make_err_ret_5P ; Cannot create on read only files
 30496 000053A8 E8D0F7                  	call	MatchAttributes
 30497 000053AB 59                              POP     CX              ; Devid back in CH
 30498 000053AC 751F                            JNZ	short make_err_ret_5 ; Attributes not ok
 30499 000053AE 30C0                            XOR     AL,AL           ; AL = 0, Disk Node
 30500                                  make_share:
 30501 000053B0 30E4                            XOR     AH,AH
 30502 000053B2 50                              PUSH    AX              ; Save Disk or Device node
 30503 000053B3 51                              PUSH    CX              ; Save Device ID
 30504 000053B4 88EC                            MOV     AH,CH           ; Device ID to AH
 30505 000053B6 E84501                          CALL    DOOPEN          ; Fill in SFT for share check
 30506 000053B9 C43E[9E05]                      LES     DI,[THISSFT]
 30507 000053BD 56                      	push	si
 30508 000053BE 53                      	push	bx		; Save CURBUF pointers
 30509 000053BF E8A129                  	call	ShareEnter
 30510 000053C2 735A                            jnc	short MakeEndShare
 30511                                  
 30512                                  ; User failed request.
 30513 000053C4 5B                      	pop	bx
 30514 000053C5 5E                      	pop	si
 30515 000053C6 59                      	pop	cx
 30516 000053C7 58                      	pop	ax
 30517                                  
 30518                                  Make_Share_ret:
 30519 000053C8 B006                            MOV     AL,6
 30520 000053CA EB96                            JMP	short make_err_ret
 30521                                  
 30522                                  make_err_ret_5P:
 30523 000053CC 59                              POP     CX              ; Get back device ID
 30524                                  make_err_ret_5:
 30525 000053CD B005                            MOV     AL,5            ; Attribute mismatch
 30526                                          ; 22/11/2022
 30527 000053CF EB91                    	JMP     short make_err_ret
 30528                                  
 30529                                  make_exists_dir:
 30530 000053D1 B001                            MOV     AL,1            ; exists as directory, always an error
 30531                                  	; 22/11/2022
 30532 000053D3 EB8D                    	JMP     short make_err_ret
 30533                                  
 30534                                  make_save:
 30535 000053D5 50                              PUSH    AX              ; Save whether Disk or File
 30536 000053D6 89C8                            MOV     AX,CX           ; Device ID to AH
 30537 000053D8 E87400                          CALL    NEWENTRY
 30538 000053DB 58                              POP     AX              ; 0 if Disk, 3 if File
 30539 000053DC 739F                            jnc	short make_retn
 30540 000053DE B002                            MOV     AL,2            ; create failed case 2
 30541                                  make_save_retn:
 30542 000053E0 C3                              retn
 30543                                  
 30544                                  make_new:
 30545 000053E1 E8F1FF                          call    make_save
 30546 000053E4 72FA                            jc	short make_save_retn	; case 2 fail
 30547                                  	;test	byte [ATTRIB],10h
 30548 000053E6 F606[6B05]10            	test	BYTE [ATTRIB],attr_directory
 30549 000053EB 75F3                            jnz	short make_save_retn	; Don't "open" directories,
 30550                                  					; so don't tell the sharer about them
 30551 000053ED 50                      	push	ax
 30552 000053EE 53                      	push	bx
 30553 000053EF 56                      	push	si		
 30554 000053F0 E87029                          call	ShareEnter
 30555 000053F3 5E                      	pop	si
 30556 000053F4 5B                      	pop	bx
 30557 000053F5 58                      	pop	ax
 30558 000053F6 73E8                    	jnc	short make_save_retn
 30559                                  
 30560                                  ; We get here by having the user FAIL a share problem. Typically a failure of
 30561                                  ; this nature is an out-of-space or an internal error. We clean up as best as
 30562                                  ; possible: delete the newly created directory entry and return share_error.
 30563                                  
 30564 000053F8 50                              PUSH    AX
 30565 000053F9 C43E[E205]                      LES     DI,[CURBUF]
 30566                                  	;mov	byte [es:bx],0E5h
 30567 000053FD 26C607E5                	MOV	BYTE [ES:BX],DIRFREE	; nuke newly created entry.
 30568                                  	
 30569                                  	; MSDOS 6.0
 30570                                  	;test	byte [es:di+5],40h
 30571 00005401 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 30572                                  					;LB. if already dirty		  ;AN000;
 30573 00005406 7508                            JNZ	short yesdirty8		;LB.  don't increment dirty count ;AN000;
 30574                                  	; 22/11/2022
 30575 00005408 E83511                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 30576                                  	;or	byte [es:di+5],40h
 30577 0000540B 26804D0540                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty ; flag buffer as dirty
 30578                                  yesdirty8:
 30579 00005410 C42E[8A05]                      LES     BP,[THISDPB]
 30580                                  	; 15/12/2022
 30581 00005414 268A4600                        mov	al,[ES:BP]
 30582                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30583                                  	;;mov	al,[es:bp+0]
 30584                                  	;MOV	AL,[ES:BP+DPB.DRIVE]	; get drive for flush
 30585 00005418 E81410                          call	FLUSHBUF		; write out buffer.
 30586 0000541B 58                              POP     AX
 30587 0000541C EBAA                            jmp	short Make_Share_ret
 30588                                  
 30589                                  ; We have found an existing file. We have also entered it into the share set.
 30590                                  ; At this point we need to call newentry to correctly address the problem of
 30591                                  ; getting rid of old data (create an existing file) or creating a new
 30592                                  ; directory entry (create a new file). Unfortunately, this operation may
 30593                                  ; result in an INT 24 that the user doesn't return from, thus locking the file
 30594                                  ; irretrievably into the share set. The correct solution is for us to LEAVE
 30595                                  ; the share set now, do the operation and then reassert the share access.
 30596                                  ;
 30597                                  ; We are allowed to do this! There is no window! After all, we are in
 30598                                  ; critDisk here and for someone else to get in, they must enter critDisk also.
 30599                                  
 30600                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30601                                  	; DOSCODE:89C8h (MSDOS 5.0, MSDOS.SYS)
 30602                                  
 30603                                  MakeEndShare:
 30604 0000541E C43E[9E05]                      LES     DI,[THISSFT]		; grab SFT
 30605 00005422 31C0                            XOR     AX,AX
 30606 00005424 E8DCC4                  	call	ECritSFT
 30607 00005427 268705                  	xchg	AX,[ES:DI]
 30608                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 30609 0000542A 50                      	push	ax
 30610 0000542B 57                      	push	di
 30611 0000542C 06                      	push	es
 30612 0000542D 9C                              PUSHF
 30613 0000542E E82D29                          call	ShareEnd                ; remove sharing
 30614 00005431 9D                              POPF
 30615 00005432 07                      	pop	es
 30616 00005433 5F                      	pop	di
 30617 00005434 268F05                          pop	word [ES:DI]	
 30618                                  	;pop	word [ES:DI+SF_ENTRY.sf_ref_count]
 30619 00005437 E8F6C4                  	call	LCritSFT
 30620                                  	; 22/11/2022
 30621                                  	; DOSCODE:89E4h (MSDOS 5.0, MSDOS.SYS)
 30622 0000543A 5B                      	pop	bx
 30623 0000543B 5E                      	pop	si
 30624 0000543C 59                      	pop	cx
 30625 0000543D 58                      	pop	ax
 30626 0000543E E894FF                          CALL    make_save
 30627                                  
 30628                                  ; If the user failed, we do not reenter into the sharing set.
 30629                                  
 30630 00005441 729D                            jc	short make_save_retn	; bye if error
 30631 00005443 50                      	push	ax
 30632 00005444 53                      	push	bx
 30633 00005445 56                      	push	si
 30634 00005446 9C                              PUSHF
 30635 00005447 E81929                          call	ShareEnter
 30636 0000544A 9D                              POPF
 30637 0000544B 5E                      	pop	si
 30638 0000544C 5B                      	pop	bx
 30639 0000544D 58                      	pop	ax
 30640                                  
 30641                                  ; If Share_check fails, then we have an internal ERROR!!!!!
 30642                                  
 30643                                  makeendshare_retn:
 30644 0000544E C3                              retn
 30645                                  
 30646                                  ;---------------------------------------------------------------------------
 30647                                  ;
 30648                                  ; Procedure Name : NEWENTRY
 30649                                  ;
 30650                                  ; Inputs:
 30651                                  ;       [THISSFT] set
 30652                                  ;       [THISDPB] set
 30653                                  ;       [LASTENT] current last valid entry number in directory if no free
 30654                                  ;               entries
 30655                                  ;       [VOLID] set if a volume ID was found during search
 30656                                  ;	Attrib Contains attributes for new file
 30657                                  ;       [DIRSTART] Points to first cluster of dir (0 means root)
 30658                                  ;       CARRY FLAG INDICATES STATUS OF SEARCH FOR FILE
 30659                                  ;               NC means file existed (device)
 30660                                  ;               C  means file did not exist
 30661                                  ;       AH = Device ID byte
 30662                                  ;       If FILE
 30663                                  ;           [CURBUF+2]:BX points to start of directory entry
 30664                                  ;           [CURBUF+2]:SI points to dir_first of directory entry
 30665                                  ;       If device
 30666                                  ;           DS:BX points to start of "fake" directory entry
 30667                                  ;           DS:SI points to dir_first of "fake" directory entry
 30668                                  ;               (has DWORD pointer to device header)
 30669                                  ; Function:
 30670                                  ;       Make a new directory entry
 30671                                  ;       If an old one existed it is truncated first
 30672                                  ; Outputs:
 30673                                  ;       Carry set if error
 30674                                  ;               Can't grow dir, atts didn't match, attempt to make 2nd
 30675                                  ;               vol ID, user FAILed to I 24
 30676                                  ;       else
 30677                                  ;               outputs of DOOPEN
 30678                                  ; DS, BX, SI preserved (meaning on SI BX, not value), others destroyed
 30679                                  ;
 30680                                  ;----------------------------------------------------------------------------
 30681                                  
 30682                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30683                                  	; DOSCODE:89F9h (MSDOS 5.0, MSDOS.SYS)
 30684                                  
 30685                                  NEWENTRY:
 30686 0000544F C42E[8A05]                      LES     BP,[THISDPB]
 30687 00005453 7315                            JNC	short EXISTENT	
 30688 00005455 803E[4A03]00                    CMP     byte [FAILERR],0
 30689                                  	;STC
 30690                                          ;jnz	short makeendshare_retn	; User FAILed, node might exist
 30691                                          ; 24/09/2023
 30692 0000545A 750C                    	jnz	short ERRRET3
 30693 0000545C E80CFE                  	CALL    BUILDDIR        ; Try to build dir
 30694 0000545F 72ED                            jc	short makeendshare_retn	; Failed
 30695 00005461 E89FF2                          call	GETENT          ; Point at that free entry
 30696 00005464 72E8                            jc	short makeendshare_retn	; Failed
 30697 00005466 EB0E                            JMP     SHORT FREESPOT
 30698                                  
 30699                                  ERRRET3:
 30700 00005468 F9                              STC
 30701                                  newentry_retn:
 30702 00005469 C3                              retn
 30703                                  
 30704                                  EXISTENT:
 30705 0000546A 08E4                            OR      AH,AH           ; Check if file is I/O device
 30706 0000546C 7903                            JNS	short NOT_DEV1
 30707 0000546E E98D00                          JMP     DOOPEN          ; If so, proceed with open
 30708                                  
 30709                                  NOT_DEV1:
 30710 00005471 E82901                          call	FREEENT		; Free cluster chain
 30711 00005474 72F3                            jc	short newentry_retn ; Failed
 30712                                  FREESPOT:
 30713                                  	;test	byte [ATTRIB],8
 30714 00005476 F606[6B05]08            	test	BYTE [ATTRIB],attr_volume_id
 30715 0000547B 7407                            JZ	short NOTVOLID
 30716 0000547D 803E[7B05]00                    CMP     BYTE [VOLID],0
 30717 00005482 75E4                            JNZ	short ERRRET3	; Can't create a second volume ID
 30718                                  NOTVOLID:
 30719 00005484 8E06[E405]                      MOV     ES,[CURBUF+2]
 30720 00005488 89DF                            MOV     DI,BX
 30721                                  
 30722 0000548A BE[4B05]                        MOV     SI,NAME1
 30723                                  
 30724 0000548D B90500                          MOV     CX,5
 30725 00005490 F3A5                            REP     MOVSW
 30726 00005492 A4                              MOVSB                   ; Move name into dir entry
 30727 00005493 A0[6B05]                	MOV	AL,[ATTRIB]
 30728 00005496 AA                      	STOSB                   ; Attributes
 30729                                  
 30730                                  ;; File Tagging for Create DOS 4.00
 30731 00005497 B105                            MOV     CL,5            ;FT. assume normal FBUGBUG	;AN000;
 30732                                  ;; File Tagging for Create DOS 4.00
 30733                                  
 30734 00005499 31C0                            XOR     AX,AX
 30735 0000549B F3AB                            REP     STOSW           ; Zero pad
 30736 0000549D E8CCB6                          call	DATE16
 30737 000054A0 92                              XCHG    AX,DX
 30738 000054A1 AB                              STOSW                   ; dir_time
 30739 000054A2 92                              XCHG    AX,DX
 30740 000054A3 AB                              STOSW                   ; dir_date
 30741 000054A4 31C0                            XOR     AX,AX
 30742 000054A6 57                              PUSH    DI              ; Correct SI input value
 30743                                  				; 	(recomputed for new buffer)
 30744 000054A7 AB                              STOSW                   ; Zero dir_first and size
 30745 000054A8 AB                              STOSW
 30746 000054A9 AB                              STOSW
 30747                                  updnxt:
 30748 000054AA 8B36[E205]              	MOV	SI,[CURBUF]
 30749                                  
 30750                                  	; 19/05/2019 - Retro DOS v4.0
 30751                                  
 30752                                  	; MSDOS 6.0
 30753 000054AE 26F6440540              	TEST	byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 30754                                  				;LB. if already dirty		  ;AN000;
 30755 000054B3 7508                            JNZ	short yesdirty9	;LB.  don't increment dirty count ;AN000;
 30756 000054B5 E88810                          call	INC_DIRTY_COUNT	;LB.				  ;AN000;
 30757                                          
 30758                                  	;or	byte [es:si+5],40h
 30759 000054B8 26804C0540              	OR      byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 30760                                  yesdirty9:
 30761 000054BD C42E[8A05]                      LES     BP,[THISDPB]
 30762                                  	; 15/12/2022
 30763 000054C1 268A4600                	MOV	AL,[ES:BP]
 30764                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30765                                  	;;mov	al,[es:bp+0]
 30766                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; Sets AH value again (in AL)
 30767 000054C5 50                              PUSH    AX
 30768 000054C6 53                              PUSH    BX
 30769                                  
 30770                                  ; If we have a file, we need to increment the open ref. count so that
 30771                                  ; we have some protection against invalid media changes if an Int 24
 30772                                  ; error occurs.
 30773                                  ; Do nothing for a device.
 30774                                  
 30775 000054C7 06                      	push	es
 30776 000054C8 57                      	push	di
 30777 000054C9 C43E[9E05]                      LES     DI,[THISSFT]
 30778                                  	;test	word [es:di+5],80h
 30779                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 30780 000054CD 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 30781 000054D2 751A                            jnz	short GotADevice
 30782 000054D4 1E                      	push	ds
 30783 000054D5 53                      	push	bx
 30784 000054D6 C51E[8A05]                      LDS     BX,[THISDPB]
 30785                                  	;mov	[es:di+7],bx
 30786 000054DA 26895D07                        MOV     [ES:DI+SF_ENTRY.sf_devptr],BX
 30787 000054DE 8CDB                            MOV     BX,DS
 30788                                  	;mov	[es:di+9],bx
 30789 000054E0 26895D09                        MOV     [ES:DI+SF_ENTRY.sf_devptr+2],BX
 30790 000054E4 5B                      	pop	bx
 30791 000054E5 1F                      	pop	ds ; need to use DS for segment later on
 30792 000054E6 E8B8FA                  	call	DEV_OPEN_SFT    ; increment ref. count
 30793 000054E9 C606[A20A]01                    mov	byte [VIRTUAL_OPEN],1; set flag
 30794                                  GotADevice:
 30795 000054EE 5F                      	pop	di
 30796 000054EF 07                      	pop	es
 30797                                  
 30798 000054F0 E83C0F                          call	FLUSHBUF
 30799 000054F3 E8EF00                          Call    CHECK_VIRT_OPEN ; decrement ref. count            ;AN000;
 30800 000054F6 5B                              POP     BX
 30801 000054F7 58                              POP     AX
 30802 000054F8 5E                              POP     SI              ; Get SI input back
 30803 000054F9 88C4                            MOV     AH,AL           ; Get I/O driver number back
 30804 000054FB 7301                    	jnc	short DOOPEN    ; Failed
 30805 000054FD C3                      	retn
 30806                                  	
 30807                                  ;NOTE FALL THROUGH
 30808                                  
 30809                                  ; DOSCODE:8AE4h (MSDOS 6.21, MSDOS.SYS)
 30810                                  
 30811                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30812                                  ; DOSCODE:8AA9h (MSDOS 5.0, MSDOS.SYS)
 30813                                  
 30814                                  ; DOOPEN
 30815                                  ;----------------------------------------------------------------------------
 30816                                  ;
 30817                                  ; Inputs:
 30818                                  ;       [THISDPB] points to DPB if file
 30819                                  ;       [THISSFT] points to SFT being used
 30820                                  ;       AH = Device ID byte
 30821                                  ;       If FILE
 30822                                  ;           [CURBUF+2]:BX points to start of directory entry
 30823                                  ;           [CURBUF+2]:SI points to dir_first of directory entry
 30824                                  ;       If device
 30825                                  ;           DS:BX points to start of "fake" directory entry
 30826                                  ;           DS:SI points to dir_first of "fake" directory entry
 30827                                  ;               (has DWORD pointer to device header)
 30828                                  ; Function:
 30829                                  ;       Fill in SFT from dir entry
 30830                                  ; Outputs:
 30831                                  ;       CARRY CLEAR
 30832                                  ;       sf_ref_count and sf_mode fields not altered
 30833                                  ;       sf_flags high byte = 0
 30834                                  ;       sf_flags low byte = AH except
 30835                                  ;       sf_flags Bit 6 set (not dirty or not EOF)
 30836                                  ;       sf_attr sf_date sf_time sf_name set from entry
 30837                                  ;       sf_position = 0
 30838                                  ;       If device
 30839                                  ;           sf_devptr = dword at dir_first (pointer to device header)
 30840                                  ;           sf_size = 0
 30841                                  ;       If file
 30842                                  ;           sf_firclus sf_size set from entry
 30843                                  ;           sf_devptr = [THISDPB]
 30844                                  ;           sf_cluspos = 0
 30845                                  ;           sf_lstclus = sf_firclus
 30846                                  ;           sf_dirsec sf_dirpos set
 30847                                  ; DS,SI,BX preserved, others destroyed
 30848                                  ;
 30849                                  ;----------------------------------------------------------------------------
 30850                                  
 30851                                  	;entry	DOOPEN
 30852                                  DOOPEN:
 30853                                  ;	Generate and store attribute
 30854                                  
 30855 000054FE 88E6                            MOV     DH,AH           ; AH to different place
 30856 00005500 C43E[9E05]                      LES     DI,[THISSFT]
 30857                                  	;add	di,4
 30858 00005504 83C704                          ADD     DI,SF_ENTRY.sf_attr ; Skip ref_count and mode fields
 30859                                  	; 24/09/2023
 30860 00005507 31C0                    	xor	ax,ax
 30861                                  	;XOR	AL,AL		; Assume it's a device, devices have an
 30862                                  				;   attribute of 0 (for R/O testing etc).
 30863 00005509 08F6                            OR      DH,DH           ; See if our assumption good.
 30864 0000550B 7807                            JS	short DEV_SFT1	; If device DS=DOSGROUP
 30865 0000550D 8E1E[E405]                      MOV     DS,[CURBUF+2]
 30866                                  	;mov	al,[BX+0Bh]
 30867 00005511 8A470B                          MOV     AL,[BX+dir_entry.dir_attr]
 30868                                  				; If file, get attrib from dir entry
 30869                                  DEV_SFT1:
 30870 00005514 AA                              STOSB                   ; sf_attr, ES:DI -> sf_flags
 30871                                  
 30872                                  ;	Generate and store flags word
 30873                                  
 30874                                  	; 24/09/2023
 30875                                  	;XOR	AX,AX
 30876                                          ; ah=0
 30877 00005515 88F0                    	MOV     AL,DH
 30878                                  	;or	al,40h
 30879 00005517 0C40                            OR      AL,devid_file_clean
 30880 00005519 AB                              STOSW                   ; sf_flags, ES:DI -> sf_devptr
 30881                                  
 30882                                  ;	Generate and store device pointer
 30883                                  
 30884 0000551A 1E                              PUSH    DS
 30885                                  	;lds	ax,[bx+1Ah]
 30886 0000551B C5471A                          LDS     AX,[BX+dir_entry.dir_first] ; Assume device
 30887 0000551E 08F6                            OR      DH,DH
 30888 00005520 7805                            JS	short DEV_SFT2
 30889                                  
 30890                                  ;hkn; SS override
 30891 00005522 36C506[8A05]                    LDS     AX,[SS:THISDPB]	; Was file
 30892                                  DEV_SFT2:
 30893 00005527 AB                              STOSW 			; store offset
 30894 00005528 8CD8                            MOV     AX,DS
 30895 0000552A 1F                              POP     DS
 30896 0000552B AB                      	STOSW			; store segment
 30897                                  				; ES:DI -> sf_firclus
 30898                                  
 30899                                  ;	Generate pointer to, generate and store first cluster 
 30900                                  ;	(irrelevant for devices)
 30901                                  
 30902 0000552C 56                              PUSH    SI              ; Save pointer to dir_first
 30903 0000552D A5                              MOVSW                   ; dir_first -> sf_firclus
 30904                                                                  ; DS:SI -> dir_size_l, ES:DI -> sf_time
 30905                                  
 30906                                  ;	Copy time/date of last modification
 30907                                  
 30908                                  	;sub	si,6
 30909 0000552E 83EE06                          SUB     SI,dir_entry.dir_size_l - dir_entry.dir_time 
 30910                                  				; DS:SI->dir_time
 30911 00005531 A5                              MOVSW                   ; dir_time -> sf_time
 30912                                                                  ; DS:SI -> dir_date, ES:DI -> sf_date
 30913 00005532 A5                              MOVSW                   ; dir_date -> sf_date
 30914                                                                  ; DS:SI -> dir_first, ES:DI -> sf_size
 30915                                  
 30916                                  ;	Generate and store file size (0 for devices)
 30917                                  
 30918 00005533 AD                              LODSW                   ; skip dir_first, DS:SI -> dir_size_l
 30919 00005534 AD                              LODSW                   ; dir_size_l in AX , DS:SI -> dir_size_h
 30920 00005535 89C1                            MOV     CX,AX           ; dir_size_l in CX
 30921 00005537 AD                              LODSW                   ; dir_size_h (size AX:CX), DS:SI -> ????
 30922 00005538 08F6                            OR      DH,DH
 30923 0000553A 7904                            JNS	short FILE_SFT1
 30924 0000553C 31C0                            XOR     AX,AX
 30925 0000553E 89C1                            MOV     CX,AX           ; Devices are open ended
 30926                                  FILE_SFT1:
 30927 00005540 91                              XCHG    AX,CX
 30928 00005541 AB                              STOSW                   ; Low word of sf_size
 30929 00005542 91                              XCHG    AX,CX
 30930 00005543 AB                              STOSW                   ; High word of sf_size
 30931                                                                  ; ES:DI -> sf_position
 30932                                  ; Initialize position to 0
 30933                                  
 30934 00005544 31C0                            XOR     AX,AX
 30935 00005546 AB                              STOSW
 30936 00005547 AB                              STOSW                   ; sf_position
 30937                                                                  ; ES:DI -> sf_cluspos
 30938                                  
 30939                                  ; Generate cluster optimizations for files
 30940                                  
 30941 00005548 08F6                            OR      DH,DH
 30942 0000554A 7843                            JS	short DEV_SFT3
 30943 0000554C AB                              STOSW                   ; sf_cluspos ; 19h
 30944                                  	;mov	ax,[bx+1Ah]
 30945 0000554D 8B471A                          MOV     AX,[BX+dir_entry.dir_first]
 30946                                  	; 19/05/2019
 30947                                  	; MSDOS 3.3
 30948                                  	;STOSW 			; sf_lstclus ; 1Bh
 30949                                  	; MSDOS 6.0
 30950 00005550 57                              PUSH	DI              ;AN004; save dirsec offset
 30951                                  	;sub	di,1Bh
 30952 00005551 83EF1B                          SUB	DI,SF_ENTRY.sf_dirsec	;AN004; es:di -> SFT
 30953                                  	;mov	[es:di+35h],ax
 30954 00005554 26894535                        MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX	;AN004; save it
 30955 00005558 5F                              POP	DI              ;AN004; restore dirsec offset
 30956                                  
 30957                                  ; DOS 3.3  FastOpen  6/13/86
 30958                                  
 30959 00005559 1E                      	PUSH	DS
 30960                                  
 30961                                  ;hkn; SS is DOSDATA
 30962 0000555A 16                      	push	ss
 30963 0000555B 1F                      	pop	ds
 30964                                  	;test	byte [FastOpenFlg],4
 30965 0000555C F606[6D12]04            	TEST	byte [FastOpenFlg],Special_Fill_Set
 30966 00005561 7411                    	JZ	short Not_FastOpen
 30967                                  
 30968                                  ;hkn; FastOpen_Ext_Info is in DOSDATA
 30969 00005563 BE[8C0D]                        MOV     SI,FastOpen_Ext_Info
 30970                                  
 30971                                  	;mov	ax,[si+1]
 30972 00005566 8B4401                          MOV     AX,[SI+FEI.dirsec]
 30973 00005569 AB                              STOSW                   ; sf_dirsec
 30974                                  	; MSDOS 6.0
 30975                                  	;mov	ax,[si+3]
 30976 0000556A 8B4403                          MOV	AX,[SI+FEI.dirsec+2]
 30977                                  				;;; changed for >32mb
 30978 0000556D AB                              STOSW                   ; sf_dirsec
 30979                                  	; 19/08//2018
 30980 0000556E 8A04                    	mov	al,[SI]
 30981                                          ;MOV	AL,[SI+FEI.dirpos] ; mov al,[SI+0]
 30982 00005570 AA                              STOSB                   ; sf_dirpos
 30983 00005571 1F                              POP	DS
 30984                                          ;JMP	short Next_Name
 30985                                  	; 24/09/2023
 30986 00005572 EB1E                    	jmp	short FILE_SFT2  ; cf=0 (after 'test' instruction)
 30987                                  
 30988                                  ; DOS 3.3  FastOpen  6/13/86
 30989                                  
 30990                                  Not_FastOpen:
 30991                                          ;POP     DS		; normal path
 30992                                  
 30993                                  ;hkn; SS override
 30994                                  	;MOV	SI,[SS:CURBUF]	; DS:SI->buffer header
 30995                                  	; 16/12/2022
 30996                                  	; 28/07/2019
 30997 00005574 8B36[E205]              	mov	si,[CURBUF]
 30998 00005578 1F                      	pop	ds
 30999                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31000                                  	;pop	ds
 31001                                  	;mov	si,[ss:CURBUF]
 31002                                  	
 31003                                  	;mov	ax,[si+6]
 31004 00005579 8B4406                          MOV     AX,[SI+BUFFINFO.buf_sector]     ;F.C. >32mb ;AN000;
 31005 0000557C AB                              STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
 31006                                  	; 19/05/2019        
 31007                                  	; MSDOS 6.0
 31008                                  	;mov	ax,[si+8]
 31009 0000557D 8B4408                  	MOV	AX,[SI+BUFFINFO.buf_sector+2]	;F.C. >32mb ;AN000;
 31010 00005580 AB                              STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
 31011                                          
 31012 00005581 89D8                    	MOV     AX,BX
 31013                                  	;;add	si,16	; MSDOS 3.3	
 31014                                  	;add	si,20	; MSDOS 6.0
 31015 00005583 83C618                          ADD     SI,BUFINSIZ     ; DS:SI-> start of data in buffer
 31016 00005586 29F0                            SUB     AX,SI           ; AX = BX relative to start of sector
 31017                                          ;mov	cl,32
 31018 00005588 B120                    	MOV     CL,dir_entry.size
 31019 0000558A F6F1                            DIV     CL
 31020 0000558C AA                              STOSB                   ; sf_dirpos
 31021                                  Next_Name:
 31022 0000558D EB03                            JMP     SHORT FILE_SFT2
 31023                                  
 31024                                  	; 24/09/2023
 31025                                  	; cf=0 (after 'or' instruction)
 31026                                  DEV_SFT3:
 31027                                  	;add	di,7
 31028 0000558F 83C707                          ADD     DI,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
 31029                                  FILE_SFT2:
 31030                                  
 31031                                  ; Copy in the object's name
 31032                                  
 31033 00005592 89DE                            MOV     SI,BX           ; DS:SI points to dir_name
 31034 00005594 B90B00                          MOV     CX,11
 31035 00005597 F3A4                            REP     MOVSB           ; sf_name
 31036 00005599 5E                              POP     SI              ; recover DS:SI -> dir_first
 31037                                  
 31038                                  ;hkn; SS is DOSDATA
 31039 0000559A 16                              push	ss
 31040 0000559B 1F                      	pop	ds
 31041                                  	; 24/09/2023
 31042                                  	; cf=0
 31043                                          ;CLC
 31044 0000559C C3                              retn
 31045                                  
 31046                                  ;---------------------------------------------------------------------------
 31047                                  ;
 31048                                  ; Procedure Name : FREEENT
 31049                                  ;
 31050                                  ; Inputs:
 31051                                  ;       ES:BP -> DPB
 31052                                  ;       [CURBUF] Set
 31053                                  ;       [CURBUF+2]:BX points to directory entry
 31054                                  ;       [CURBUF+2]:SI points to above dir_first
 31055                                  ; Function:
 31056                                  ;       Free the cluster chain for the entry if present
 31057                                  ; Outputs:
 31058                                  ;       Carry set if error (currently user FAILed to I 24)
 31059                                  ;       (NOTE dir_firclus and dir_size_l/h are wrong)
 31060                                  ; DS BX SI ES BP preserved (BX,SI in meaning, not value) others destroyed
 31061                                  ;---------------------------------------------------------------------------
 31062                                  
 31063                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31064                                  FREEENT:
 31065 0000559D 1E                              PUSH    DS
 31066 0000559E C53E[E205]                      LDS     DI,[CURBUF]
 31067 000055A2 8B0C                            MOV     CX,[SI]         ; Get pointer to clusters
 31068                                  	; 19/05/2019 - Retro DOS v4.0
 31069                                  	; MSDOS 6.0
 31070 000055A4 8B5508                  	MOV	DX,[DI+BUFFINFO.buf_sector+2]  ;F.C. >32mb	;AN000;
 31071                                  ;hkn; SS override
 31072 000055A7 368916[0706]                    MOV	[SS:HIGH_SECTOR],DX		;F.C. >32mb	;AN000;
 31073 000055AC 8B5506                          MOV     DX,[DI+BUFFINFO.buf_sector]
 31074 000055AF 1F                              POP     DS
 31075 000055B0 83F902                  	CMP	CX,2
 31076 000055B3 722E                            JB	short RET1	; Was 0 length file (or mucked Firclus if CX=1)
 31077                                  	;cmp	cx,[es:bp+0Dh]
 31078 000055B5 263B4E0D                        CMP     CX,[ES:BP+DPB.MAX_CLUSTER]
 31079 000055B9 7728                            JA	short RET1	; Treat like zero length file (firclus mucked)
 31080 000055BB 29FB                            SUB     BX,DI
 31081 000055BD 53                              PUSH    BX              ; Save offset
 31082 000055BE FF36[0706]              	PUSH	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 31083 000055C2 52                              PUSH    DX              ; Save sector number
 31084 000055C3 89CB                            MOV     BX,CX
 31085 000055C5 E8AC02                          call	RELEASE         ; Free any data allocated
 31086 000055C8 5A                              POP     DX
 31087 000055C9 8F06[0706]                      POP	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 31088 000055CD 7302                            JNC	short GET_BUF_BACK
 31089 000055CF 5B                              POP     BX
 31090                                  freeent_retn:
 31091 000055D0 C3                              retn			; Screw up
 31092                                  
 31093                                  GET_BUF_BACK:
 31094                                  	; 22/09/2023
 31095                                  	;;mov	byte [ALLOWED],18h
 31096                                          ;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 31097                                          ;XOR	AL,AL ; *
 31098                                  	;call	GETBUFFR        ; Get sector back
 31099 000055D1 E8570D                  	call	GETBUFFER ; * ; pre read      
 31100                                  
 31101 000055D4 5B                      	POP     BX              ; Get offset back
 31102 000055D5 72F9                            jc	short freeent_retn
 31103 000055D7 E86EE9                  	call	SET_BUF_AS_DIR
 31104 000055DA 031E[E205]                      ADD     BX,[CURBUF]	; Correct it for new buffer
 31105 000055DE 89DE                            MOV     SI,BX
 31106                                  	;add	si,1Ah
 31107 000055E0 83C61A                          ADD     SI,dir_entry.dir_first	; Get corrected SI
 31108                                  RET1:
 31109 000055E3 F8                              CLC
 31110 000055E4 C3                              retn
 31111                                  
 31112                                  ;---------------------------------------------------------------------------
 31113                                  ;
 31114                                  ; Procedure Name : CHECK_VIRT_OPEN
 31115                                  ;
 31116                                  ; CHECK_VIRT_OPEN checks to see if we had performed a "virtual open" (by
 31117                                  ; examining the flag [VIRTUAL_OPEN] to see if it is 1). If we did, then
 31118                                  ; it calls Dev_Close_SFT to decrement the ref. count. It also resets the
 31119                                  ; flag [VIRTUAL_OPEN].
 31120                                  ; No registers affected (including flags).
 31121                                  ; On input, [THISSFT] points to current SFT.
 31122                                  ;
 31123                                  ;---------------------------------------------------------------------------
 31124                                  
 31125                                  CHECK_VIRT_OPEN:
 31126 000055E5 50                      	PUSH    AX
 31127 000055E6 9F                              lahf                    ; preserve flags
 31128 000055E7 803E[A20A]00                    CMP     byte [VIRTUAL_OPEN],0
 31129 000055EC 7410                            JZ	short ALL_CLOSED
 31130 000055EE C606[A20A]00                    mov     byte [VIRTUAL_OPEN],0	; reset flag
 31131 000055F3 06                      	push	es
 31132 000055F4 57                      	push	di
 31133 000055F5 C43E[9E05]                      LES     DI,[THISSFT]
 31134 000055F9 E8ADF9                          call	DEV_CLOSE_SFT
 31135 000055FC 5F                      	pop	di
 31136 000055FD 07                      	pop	es
 31137                                  
 31138                                  ALL_CLOSED:
 31139 000055FE 9E                              sahf                    ; restore flags
 31140 000055FF 58                              POP     AX
 31141 00005600 C3                              retn
 31142                                  
 31143                                  ;============================================================================
 31144                                  ; ROM.ASM, MSDOS 6.0, 1991
 31145                                  ;============================================================================
 31146                                  ; 29/07/2018 - Retro DOS v3.0
 31147                                  ; 20/05/2019 - Retro DOS v4.0
 31148                                  
 31149                                  ;	TITLE	ROM - Miscellaneous routines
 31150                                  ;	NAME	ROM
 31151                                  
 31152                                  ;**	Misc Low level routines for doing simple FCB computations, Cache
 31153                                  ;       reads and writes, I/O optimization, and FAT allocation/deallocation
 31154                                  ;
 31155                                  ;	SKPCLP
 31156                                  ;	FNDCLUS
 31157                                  ;	BUFSEC
 31158                                  ;	BUFRD
 31159                                  ;	BUFWRT
 31160                                  ;	NEXTSEC
 31161                                  ;	OPTIMIZE
 31162                                  ;	FIGREC
 31163                                  ;	ALLOCATE
 31164                                  ;	RESTFATBYT
 31165                                  ;	RELEASE
 31166                                  ;	RELBLKS
 31167                                  ;	GETEOF
 31168                                  ;
 31169                                  ;	Modification history:
 31170                                  ;
 31171                                  ;		Created: ARR 30 March 1983
 31172                                  ;               M039: DB 10/25/90 - Disk read/write optimization.
 31173                                  
 31174                                  ;Break   <FNDCLUS -- Skip over allocation units>
 31175                                  ;--------------------------------------------------------------------------
 31176                                  ;
 31177                                  ; Procedure Name : FNDCLUS
 31178                                  ;
 31179                                  ; Inputs:
 31180                                  ;       CX = No. of clusters to skip
 31181                                  ;       ES:BP = Base of drive parameters
 31182                                  ;       [THISSFT] point to SFT
 31183                                  ; Outputs:
 31184                                  ;       BX = Last cluster skipped to
 31185                                  ;       CX = No. of clusters remaining (0 unless EOF)
 31186                                  ;       DX = Position of last cluster
 31187                                  ;       Carry set if error (currently user FAILed to I 24)
 31188                                  ; DI destroyed. No other registers affected.
 31189                                  ;--------------------------------------------------------------------------
 31190                                  
 31191                                  ; 20/05/2019 - Retro DOS v4.0
 31192                                  ; DOSCODE:8BF2h (MSDOS 6.21, MSDOS.SYS)
 31193                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31194                                  ; DOSCODE:8BB7h (MSDOS 5.0, MSDOS.SYS)
 31195                                  
 31196                                  FNDCLUS:
 31197 00005601 06                      	PUSH	ES
 31198 00005602 C43E[9E05]                      LES     DI,[THISSFT]		; setup addressability to SFT
 31199                                  	;;mov	bx,[es:di+1Bh] ; MSDOS 3.3
 31200                                  	;mov	bx,[es:di+35h] ; MSDOS 6.0
 31201 00005606 268B5D35                	MOV	BX,[ES:DI+SF_ENTRY.sf_lstclus]
 31202                                  	;mov	dx,[es:di+19h]
 31203 0000560A 268B5519                        MOV     DX,[ES:DI+SF_ENTRY.sf_cluspos]
 31204 0000560E 09DB                    	OR	BX,BX
 31205 00005610 7424                    	JZ	short NOCLUS
 31206                                  
 31207 00005612 29D1                            SUB     CX,DX
 31208 00005614 7308                            JNB	short FINDIT
 31209                                  
 31210 00005616 01D1                            ADD     CX,DX
 31211 00005618 31D2                            XOR     DX,DX
 31212                                  	;mov	bx,[es:di+0Bh]
 31213 0000561A 268B5D0B                        MOV     BX,[ES:DI+SF_ENTRY.sf_firclus]
 31214                                  FINDIT:
 31215 0000561E 07                              POP	ES
 31216 0000561F E313                    	JCXZ	RET9
 31217                                  
 31218                                  	;entry	SKPCLP
 31219                                  SKPCLP:
 31220 00005621 E8CE08                  	call	UNPACK
 31221 00005624 7214                            jc	short fndclus_retn	; retc
 31222                                  
 31223                                  	; 09/09/2018
 31224                                  
 31225                                  	; MSDOS 3.3
 31226                                  	;push	bx
 31227                                  	;mov	bx,di
 31228                                  	;call	IsEOF
 31229                                  	;pop	bx	
 31230                                  	;jae	short RET9
 31231                                  
 31232                                  	; 20/05/2019 - Retro DOS v4.0
 31233                                  
 31234                                  	; MSDOS 6.0
 31235 00005626 87DF                    	xchg	bx,di
 31236 00005628 E8B008                  	call	IsEOF
 31237 0000562B 87DF                    	xchg	bx,di
 31238 0000562D 7305                    	jae	short RET9
 31239                                  
 31240 0000562F 87DF                            XCHG    BX,DI
 31241 00005631 42                              INC     DX
 31242                                  
 31243 00005632 E2ED                    	LOOP	SKPCLP			; RMFS
 31244                                  RET9:	
 31245 00005634 F8                      	CLC
 31246 00005635 C3                              retn
 31247                                  NOCLUS:
 31248 00005636 07                              POP	ES
 31249 00005637 41                              INC	CX
 31250 00005638 4A                              DEC	DX
 31251 00005639 F8                              CLC
 31252                                  
 31253                                  fndclus_retn:
 31254 0000563A C3                              retn
 31255                                  
 31256                                  ;Break  <BUFSEC -- BUFFER A SECTOR AND SET UP A TRANSFER>
 31257                                  ;--------------------------------------------------------------------------
 31258                                  ;
 31259                                  ; Procedure Name : BUFSEC
 31260                                  ;
 31261                                  ; Inputs:
 31262                                  ;       AH = priority of buffer
 31263                                  ;       AL = 0 if buffer must be read, 1 if no pre-read needed
 31264                                  ;       ES:BP = Base of drive parameters
 31265                                  ;       [CLUSNUM] = Physical cluster number
 31266                                  ;       [SECCLUSPOS] = Sector position of transfer within cluster
 31267                                  ;       [BYTCNT1] = Size of transfer
 31268                                  ; Function:
 31269                                  ;       Insure specified sector is in buffer, flushing buffer before
 31270                                  ;       read if necessary.
 31271                                  ; Outputs:
 31272                                  ;       ES:DI = Pointer to buffer
 31273                                  ;       SI = Pointer to transfer address
 31274                                  ;       CX = Number of bytes
 31275                                  ;       [NEXTADD] updated
 31276                                  ;       [TRANS] set to indicate a transfer will occur
 31277                                  ;       Carry set if error (user FAILed to I 24)
 31278                                  ;--------------------------------------------------------------------------
 31279                                  
 31280                                  BUFSEC:
 31281 0000563B 8B16[BC05]                      MOV     DX,[CLUSNUM]
 31282 0000563F 8A1E[7305]                      MOV     BL,[SECCLUSPOS]
 31283                                  	;mov	byte [ALLOWED],38h
 31284 00005643 C606[4B03]38                    MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY+Allowed_IGNORE
 31285 00005648 E85001                          CALL    FIGREC
 31286 0000564B E8E40C                  	call	GETBUFFR
 31287 0000564E 72EA                            jc	short fndclus_retn
 31288                                  
 31289 00005650 C606[7405]01                    MOV     BYTE [TRANS],1	; A transfer is taking place
 31290 00005655 8B36[B805]                      MOV     SI,[NEXTADD]
 31291 00005659 89F7                            MOV     DI,SI
 31292 0000565B 8B0E[D205]                      MOV     CX,[BYTCNT1]
 31293 0000565F 01CF                            ADD     DI,CX
 31294 00005661 893E[B805]                      MOV     [NEXTADD],DI
 31295 00005665 C43E[E205]                      LES     DI,[CURBUF]
 31296                                  	;or	byte [es:di+5],8
 31297 00005669 26804D0508                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDATA
 31298                                  	;;lea	di,[di+16] ; MSDOS 3.3 
 31299                                  	;lea	di,[di+20] ; MSDOS 6.0
 31300 0000566E 8D7D18                          LEA     DI,[DI+BUFINSIZ]        ; Point to buffer
 31301 00005671 033E[CC05]                      ADD     DI,[BYTSECPOS]
 31302 00005675 F8                              CLC
 31303 00005676 C3                              retn
 31304                                  
 31305                                  ;Break   <BUFRD, BUFWRT -- PERFORM BUFFERED READ AND WRITE>
 31306                                  
 31307                                  ;---------------------------------------------------------------------------
 31308                                  ;
 31309                                  ; Procedure Name : BUFRD
 31310                                  ;
 31311                                  ; Do a partial sector read via one of the system buffers
 31312                                  ; ES:BP Points to DPB
 31313                                  ; Carry set if error (currently user FAILed to I 24)
 31314                                  ;
 31315                                  ; DS - set to DOSDATA
 31316                                  ;
 31317                                  ;----------------------------------------------------------------------------
 31318                                  
 31319                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31320                                  	; 20/05/2019 - Retro DOS v4.0
 31321                                  BUFRD:
 31322 00005677 06                              PUSH	ES
 31323 00005678 31C0                            xor	ax, ax			; pre-read sector
 31324 0000567A E8BEFF                          CALL    BUFSEC
 31325 0000567D 7303                            JNC	short BUF_OK
 31326                                  
 31327                                  BUF_IO_FAIL:				; this label used by BUFWRT also
 31328 0000567F 07                              POP	ES
 31329 00005680 EB2B                            JMP     SHORT RBUFPLACED
 31330                                  
 31331                                  BUF_OK:
 31332 00005682 8CC3                            MOV     BX,ES
 31333 00005684 8E06[2E03]                      MOV     ES,[DMAADD+2]
 31334 00005688 8EDB                            MOV     DS,BX
 31335 0000568A 87FE                    	XCHG    DI,SI
 31336 0000568C D1E9                            SHR     CX,1
 31337                                  ;M039
 31338                                  	; MSDOS 3.3
 31339                                  	;JNC	short EVENRD
 31340                                  	;MOVSB
 31341                                  ;EVENRD:
 31342                                  	;REP     MOVSW
 31343                                  
 31344                                  ;	CX = # of whole WORDs ; CF=1 if odd # of bytes.
 31345                                  ;       DS:SI-> Source within Buffer.
 31346                                  ;       ES:DI-> Destination within Transfer memory block.
 31347                                  
 31348                                  	; MSDOS 6.0
 31349 0000568E F3A5                    	rep	movsw			;Copy Buffer to Transfer memory.
 31350                                  	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 31351                                  	;rep	movsb                   ;Copy last byte.
 31352                                  	; 16/12/2022
 31353 00005690 7301                    	jnc	short EVENRD ; **** 20/05/2019
 31354 00005692 A4                      	movsb ; ****
 31355                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31356                                  	;adc	cx,0
 31357                                  	;rep	movsb
 31358                                  ;M039
 31359                                  EVENRD: ; ****
 31360 00005693 07                              POP	ES
 31361                                  ;hkn; SS override
 31362 00005694 36C53E[E205]                    LDS     DI,[SS:CURBUF]
 31363                                  	;;lea	bx,[di+16]
 31364                                  	;lea	bx,[di+20] ; MSDOS 6.0
 31365 00005699 8D5D18                  	LEA     BX,[DI+BUFINSIZ]
 31366 0000569C 29DE                            SUB     SI,BX                   ; Position in buffer
 31367 0000569E E8310C                          call	PLACEBUF
 31368                                  	;cmp	si,[es:bp+2]
 31369 000056A1 263B7602                	CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Read Last byte?
 31370 000056A5 7205                            JB	short RBUFPLACEDC	; No, leave buf where it is
 31371                                  ;M039
 31372                                  	; MSDOS 3.3
 31373                                  	;call	PLACEHEAD               ; Make it prime candidate for chucking
 31374                                                                          ;  even though it is MRU.
 31375                                          ; MSDOS 6.0
 31376 000056A7 36893E[6D00]            	MOV	[ss:BufferQueue],DI	; Make it prime candidate for
 31377                                  ;M039					; chucking even though it is MRU.
 31378                                  
 31379                                  RBUFPLACEDC:
 31380 000056AC F8                              CLC
 31381                                  RBUFPLACED:
 31382 000056AD 16                      	push	ss
 31383 000056AE 1F                      	pop	ds
 31384 000056AF C3                              retn
 31385                                  
 31386                                  ;----------------------------------------------------------------------------
 31387                                  ;
 31388                                  ; Procedure : BUFWRT
 31389                                  ;
 31390                                  ; Do a partial sector write via one of the system buffers
 31391                                  ; ES:BP Points to DPB
 31392                                  ; Carry set if error (currently user FAILed to I 24)
 31393                                  ;
 31394                                  ; DS - set to DOSDATA
 31395                                  ;
 31396                                  ;----------------------------------------------------------------------------
 31397                                  
 31398                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31399                                  	; 20/05/2019 - Retro DOS v4.0
 31400                                  BUFWRT:
 31401                                          ;MOV     AX,[SECPOS]
 31402                                          ; MSDOS 6.0
 31403                                  	;ADD	AX,1            	; Set for next sector
 31404                                          ;MOV	[SECPOS],AX 		;F.C. >32mb	;AN000;
 31405                                          ;ADC	word [SECPOS+2],0	;F.C. >32mb	;AN000;
 31406                                          ; 24/09/2023
 31407 000056B0 FF06[C405]              	inc	word [SECPOS]
 31408 000056B4 7504                    	jnz	short bufw_secpos
 31409 000056B6 FF06[C605]              	inc	word [SECPOS+2]
 31410                                  bufw_secpos:
 31411 000056BA A1[C605]                	MOV	AX,[SECPOS+2]		;F.C. >32mb	;AN000;
 31412 000056BD 3B06[CA05]                      CMP	AX,[VALSEC+2]		;F.C. >32mb	;AN000;
 31413 000056C1 B001                            MOV	AL,1			;F.C. >32mb	;AN000;
 31414 000056C3 770F                            JA	short NOREAD		;F.C. >32mb	;AN000;
 31415 000056C5 720B                            JB	short _doread		;F.C. >32mb	;AN000;
 31416 000056C7 A1[C405]                        MOV	AX,[SECPOS]		;F.C. >32mb	;AN000;
 31417                                  
 31418                                  	; MSDOS 3.3
 31419                                  	;INC	AX
 31420                                  	;MOV	[SECPOS],AX ; 09/09/2018
 31421                                  
 31422                                  	; 20/05/2019
 31423                                  	; MSDOS 3.3 & MSDOS 6.0
 31424 000056CA 3B06[C805]                      CMP     AX,[VALSEC]		; Has sector been written before?
 31425 000056CE B001                            MOV     AL,1
 31426 000056D0 7702                            JA	short NOREAD		; Skip preread if SECPOS>VALSEC
 31427                                  _doread:
 31428 000056D2 30C0                            XOR     AL,AL
 31429                                  NOREAD:
 31430 000056D4 06                              PUSH	ES
 31431 000056D5 E863FF                          CALL    BUFSEC
 31432 000056D8 72A5                    	JC	short BUF_IO_FAIL
 31433 000056DA 8E1E[2E03]                      MOV     DS,[DMAADD+2]
 31434 000056DE D1E9                            SHR     CX,1
 31435                                  ;M039
 31436                                  	; MSDOS 3.3
 31437                                  	;JNC	short EVENWRT ; 09/09/2018
 31438                                  	;MOVSB
 31439                                  ;EVENWRT:
 31440                                  	;REP	MOVSW
 31441                                  
 31442                                  ;	CX = # of whole WORDs; CF=1 if odd # of bytes.
 31443                                  ;       DS:SI-> Source within Transfer memory block.
 31444                                  ;       ES:DI-> Destination within Buffer.
 31445                                  
 31446                                  	; MSDOS 6.0
 31447 000056E0 F3A5                    	rep	movsw			;Copy Transfer memory to Buffer.
 31448                                  	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 31449                                  	;rep	movsb                   ;Copy last byte.
 31450                                  	; 16/12/2022
 31451 000056E2 7301                    	jnc	short EVENWRT ; **** 20/05/2019
 31452 000056E4 A4                      	movsb ; ****
 31453                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31454                                  	;adc	cx,0
 31455                                  	;rep	movsb
 31456                                  ;M039
 31457                                  EVENWRT: ; ****
 31458 000056E5 07                              POP	ES
 31459                                  
 31460                                  ;hkn; SS override
 31461 000056E6 36C51E[E205]                    LDS     BX,[SS:CURBUF]
 31462                                  
 31463                                  	; MSDOS 6.0
 31464 000056EB F6470540                        TEST	byte [BX+BUFFINFO.buf_flags],buf_dirty
 31465                                  					;LB. if already dirty		  ;AN000;
 31466 000056EF 7507                            JNZ	short yesdirty10	;LB.  don't increment dirty count ;AN000;
 31467 000056F1 E84C0E                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 31468                                  	
 31469                                  	;or	byte [bx+5],40h
 31470 000056F4 804F0540                        OR	byte [BX+BUFFINFO.buf_flags],buf_dirty
 31471                                  yesdirty10:
 31472                                  	;;lea	si,[bx+16]
 31473                                  	;lea	si,[bx+20] ; MSDOS 6.0
 31474 000056F8 8D7718                          LEA     SI,[BX+BUFINSIZ]
 31475 000056FB 29F7                            SUB     DI,SI                   ; Position in buffer
 31476                                  ;M039
 31477                                  	; MSDOS 3.3
 31478                                  	;MOV	SI,DI
 31479                                  	;MOV	DI,BX
 31480                                  	;call	PLACEBUF
 31481                                  	;;cmp	si,[es:bp+2]
 31482                                  	;CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 31483                                  	;JB	short WBUFPLACED	; No, leave buf where it is
 31484                                  	;call	PLACEHEAD               ; Make it prime candidate for chucking
 31485                                                                          ;  even though it is MRU.
 31486                                  	; MSDOS 6.0
 31487                                  	;cmp	di,[es:bp+2]
 31488 000056FD 263B7E02                	CMP	di,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 31489 00005701 7205                            JB	short WBUFPLACED	; No, leave buf where it is
 31490 00005703 36891E[6D00]                    MOV	[ss:BufferQueue],BX	; Make it prime candidate for
 31491                                  					; chucking even though it is MRU.
 31492                                  ;M039
 31493                                  
 31494                                  WBUFPLACED:
 31495 00005708 F8                              CLC
 31496 00005709 16                      	push	ss
 31497 0000570A 1F                      	pop	ds
 31498 0000570B C3                              retn
 31499                                  
 31500                                  ;Break   <NEXTSEC -- Compute next sector to read or write>
 31501                                  ;---------------------------------------------------------------------------
 31502                                  ;
 31503                                  ; Procedure Name : NEXTSEC
 31504                                  ;
 31505                                  ; Compute the next sector to read or write
 31506                                  ; ES:BP Points to DPB
 31507                                  ;
 31508                                  ;---------------------------------------------------------------------------
 31509                                  
 31510                                  NEXTSEC:
 31511 0000570C F606[7405]FF            	test	byte [TRANS],0FFh ; -1 
 31512 00005711 7426                            JZ	short CLRET
 31513                                  
 31514 00005713 A0[7305]                        MOV     AL,[SECCLUSPOS]
 31515 00005716 FEC0                            INC     AL
 31516                                  	;cmp	al,[es:bp+4]
 31517 00005718 263A4604                        CMP     AL,[ES:BP+DPB.CLUSTER_MASK]
 31518 0000571C 7618                            JBE	short SAVPOS
 31519                                  
 31520 0000571E 8B1E[BC05]                      MOV     BX,[CLUSNUM]
 31521 00005722 E8B607                          call	IsEOF
 31522 00005725 7314                            JAE	short NONEXT
 31523                                  
 31524 00005727 E8C807                          call	UNPACK
 31525 0000572A 720F                            JC	short NONEXT
 31526                                  clusgot:
 31527 0000572C 893E[BC05]                      MOV     [CLUSNUM],DI
 31528 00005730 FF06[BA05]                      INC     word [LASTPOS]
 31529 00005734 B000                            MOV     AL,0
 31530                                  SAVPOS:
 31531 00005736 A2[7305]                        MOV     [SECCLUSPOS],AL
 31532                                  CLRET:
 31533 00005739 F8                              CLC
 31534 0000573A C3                              retn
 31535                                  NONEXT:
 31536 0000573B F9                              STC
 31537 0000573C C3                              retn
 31538                                  
 31539                                  ;Break	<OPTIMIZE -- DO A USER DISK REQUEST WELL>
 31540                                  ;----------------------------------------------------------------------------
 31541                                  ;
 31542                                  ; Procedure Name : OPTIMIZE
 31543                                  ;
 31544                                  ; Inputs:
 31545                                  ;       BX = Physical cluster
 31546                                  ;       CX = No. of records
 31547                                  ;       DL = sector within cluster
 31548                                  ;       ES:BP = Base of drive parameters
 31549                                  ;       [NEXTADD] = transfer address
 31550                                  ; Outputs:
 31551                                  ;       AX = No. of records remaining
 31552                                  ;       BX = Transfer address
 31553                                  ;       CX = No. or records to be transferred
 31554                                  ;       DX = Physical sector address            (LOW)
 31555                                  ;       [HIGH_SECTOR] = Physical sector address (HIGH)
 31556                                  ;       DI = Next cluster
 31557                                  ;       [CLUSNUM] = Last cluster accessed
 31558                                  ;       [NEXTADD] updated
 31559                                  ;       Carry set if error (currently user FAILed to I 24)
 31560                                  ; ES:BP unchanged. Note that segment of transfer not set.
 31561                                  ;
 31562                                  ;---------------------------------------------------------------------------
 31563                                  
 31564                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31565                                  OPTIMIZE:
 31566 0000573D 52                      	PUSH    DX
 31567 0000573E 53                              PUSH    BX
 31568                                  	;mov	al,[es:bp+4]
 31569 0000573F 268A4604                        MOV     AL,[ES:BP+DPB.CLUSTER_MASK]
 31570 00005743 FEC0                            INC     AL              ; Number of sectors per cluster
 31571 00005745 88C4                            MOV     AH,AL
 31572 00005747 28D0                            SUB     AL,DL           ; AL = Number of sectors left in first cluster
 31573 00005749 89CA                            MOV     DX,CX
 31574                                  	;MOV	CX,0
 31575                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31576                                  	; 16/12/2022
 31577 0000574B 31C9                    	xor	cx,cx	; sub cx,cx
 31578                                  OPTCLUS:
 31579                                  ; AL has number of sectors available in current cluster
 31580                                  ; AH has number of sectors available in next cluster
 31581                                  ; BX has current physical cluster
 31582                                  ; CX has number of sequential sectors found so far
 31583                                  ; DX has number of sectors left to transfer
 31584                                  ; ES:BP Points to DPB
 31585                                  ; ES:SI has FAT pointer
 31586                                  
 31587                                  do_norm3:
 31588 0000574D E8A207                          call	UNPACK
 31589 00005750 7236                            JC	short OP_ERR
 31590                                  clusgot2:
 31591 00005752 00C1                    	ADD	CL,AL
 31592 00005754 80D500                          ADC     CH,0
 31593 00005757 39D1                            CMP     CX,DX
 31594 00005759 7332                            JAE	short BLKDON
 31595 0000575B 88E0                            MOV     AL,AH
 31596 0000575D 43                              INC     BX
 31597 0000575E 39DF                            CMP     DI,BX
 31598 00005760 74EB                            JZ	short OPTCLUS
 31599 00005762 4B                              DEC     BX
 31600                                  FINCLUS:
 31601 00005763 891E[BC05]                      MOV     [CLUSNUM],BX    ; Last cluster accessed
 31602 00005767 29CA                            SUB     DX,CX           ; Number of sectors still needed
 31603 00005769 52                              PUSH    DX
 31604 0000576A 89C8                            MOV     AX,CX
 31605                                  	;mul	word[ES:BP+2]
 31606 0000576C 26F76602                        MUL	word [ES:BP+DPB.SECTOR_SIZE] 
 31607                                  				; Number of sectors times sector size
 31608 00005770 8B36[B805]                      MOV     SI,[NEXTADD]
 31609 00005774 01F0                            ADD     AX,SI           ; Adjust by size of transfer
 31610 00005776 A3[B805]                        MOV     [NEXTADD],AX
 31611 00005779 58                              POP     AX              ; Number of sectors still needed
 31612 0000577A 5A                              POP     DX              ; Starting cluster
 31613 0000577B 29D3                            SUB     BX,DX           ; Number of new clusters accessed
 31614 0000577D 011E[BA05]                      ADD     [LASTPOS],BX
 31615 00005781 5B                              POP     BX              ; BL = sector position within cluster
 31616 00005782 E81600                  	call	FIGREC
 31617 00005785 89F3                            MOV     BX,SI
 31618                                  	; 24/09/2023
 31619                                  	; cf=0 (at the return of FIGREC)
 31620                                  	;CLC
 31621 00005787 C3                              retn
 31622                                  OP_ERR:
 31623 00005788 83C404                          ADD     SP,4
 31624 0000578B F9                      	STC
 31625 0000578C C3                              retn
 31626                                  BLKDON:
 31627 0000578D 29D1                            SUB     CX,DX           ; Number of sectors in cluster we don't want
 31628 0000578F 28CC                            SUB     AH,CL           ; Number of sectors in cluster we accepted
 31629 00005791 FECC                            DEC     AH              ; Adjust to mean position within cluster
 31630 00005793 8826[7305]                      MOV     [SECCLUSPOS],AH
 31631 00005797 89D1                            MOV     CX,DX           ; Anyway, make the total equal to the request
 31632 00005799 EBC8                            JMP     SHORT FINCLUS
 31633                                  
 31634                                  ;Break	<FIGREC -- Figure sector in allocation unit>
 31635                                  ;---------------------------------------------------------------------------
 31636                                  ;
 31637                                  ; Procedure Name : FIGREC
 31638                                  ;
 31639                                  ; Inputs:
 31640                                  ;       DX = Physical cluster number
 31641                                  ;       BL = Sector position within cluster
 31642                                  ;       ES:BP = Base of drive parameters
 31643                                  ; Outputs:
 31644                                  ;       DX = physical sector number           (LOW)
 31645                                  ;       [HIGH_SECTOR] Physical sector address (HIGH)
 31646                                  ; No other registers affected.
 31647                                  ;
 31648                                  ;---------------------------------------------------------------------------
 31649                                  
 31650                                  	; 10/06/2019
 31651                                  	; 20/05/2019 - Retro DOS v4.0
 31652                                  	; DOSCODE:8D96h (MSDOS 6.21, MSDOS.SYS)
 31653                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31654                                  	; DOSCODE:8D5Bh (MSDOS 5.0, MSDOS.SYS)	
 31655                                  FIGREC:
 31656 0000579B 51                              PUSH    CX
 31657                                  	;mov	cl,[es:bp+5]
 31658 0000579C 268A4E05                        MOV     CL,[ES:BP+DPB.CLUSTER_SHIFT]
 31659 000057A0 4A                              DEC     DX
 31660 000057A1 4A                              DEC     DX
 31661                                  
 31662                                  	; MSDOS 3.3
 31663                                  	;SHL	DX,CL
 31664                                  
 31665                                  ;hkn; SS override HIGH_SECTOR
 31666                                  	; MSDOS 6.0
 31667 000057A2 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0		;F.C. >32mb
 31668                                  	; 24/09/2023
 31669 000057A9 30ED                    	xor	ch,ch				;F.C. >32mb
 31670 000057AB 08C9                    	OR	CL,CL				;F.C. >32mb
 31671 000057AD 740C                    	JZ	short noshift			;F.C. >32mb
 31672 000057AF 30ED                    	XOR	CH,CH				;F.C. >32mb
 31673                                  rotleft:					;F.C. >32mb
 31674 000057B1 F8                      	CLC					;F.C. >32mb
 31675 000057B2 D1D2                    	RCL	DX,1				;F.C. >32mb
 31676                                  	; 10/06/2019
 31677 000057B4 36D116[0706]            	RCL	word [ss:HIGH_SECTOR],1		;F.C. >32mb
 31678 000057B9 E2F6                    	LOOP	rotleft				;F.C. >32mb
 31679                                  noshift:
 31680                                  	; MSDOS 3.3 & MSDOS 6.0
 31681 000057BB 08DA                            OR      DL,BL
 31682                                  	;add	dx,[es:bp+0Bh]
 31683 000057BD 2603560B                        ADD     DX,[ES:BP+DPB.FIRST_SECTOR]
 31684                                  	; MSDOS 6.0
 31685                                  	; 10/06/2019
 31686                                  	;ADC	word [ss:HIGH_SECTOR],0		;F.C. >32mb
 31687                                  	; 24/09/2023
 31688                                  	; cx=0
 31689 000057C1 36110E[0706]            	ADC	word [ss:HIGH_SECTOR],cx ; 0
 31690                                  
 31691                                  	; MSDOS 3.3 & MSDOS 6.0
 31692 000057C6 59                      	POP     CX
 31693                                  figrec_retn:
 31694 000057C7 C3                              retn
 31695                                  
 31696                                  ; 20/05/2019 - Retro DOS v4.0
 31697                                  ; DOSCODE:8DC2h (MSDOS 6.21, MSDOS.SYS)
 31698                                  
 31699                                  ; 30/07/2018 - Retro DOS v3.0
 31700                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 
 31701                                  
 31702                                  ;Break   <ALLOCATE -- Assign disk space>
 31703                                  ;---------------------------------------------------------------------------
 31704                                  ;
 31705                                  ; Procedure Name : ALLOCATE - Allocate Disk Space
 31706                                  ;
 31707                                  ;   ALLOCATE is called to allocate disk clusters. The new clusters are
 31708                                  ;   FAT-chained onto the end of the existing file.
 31709                                  ;
 31710                                  ;   The DPB contains the cluster # of the last free cluster allocated
 31711                                  ;   (dpb_next_free). We start at this cluster and scan towards higher
 31712                                  ;   numbered clusters, looking for the necessary free blocks.
 31713                                  ;
 31714                                  ;   Once again, fancy terminology gets in the way of correct coding. When
 31715                                  ;   using next_free, start scanning AT THAT POINT and not the one following it.
 31716                                  ;   This fixes the boundary condition bug when only free = next_free = 2.
 31717                                  ;
 31718                                  ;       If we get to the end of the disk without satisfaction:
 31719                                  ;
 31720                                  ;           if (dpb_next_free == 2) then we've scanned the whole disk.
 31721                                  ;               return (insufficient_disk_space)
 31722                                  ;           ELSE
 31723                                  ;               dpb_next_free = 2; start scan over from the beginning.
 31724                                  ;
 31725                                  ;   Note that there is no multitasking interlock. There is no race when
 31726                                  ;   examining the entrys in an in-core FAT block since there will be no
 31727                                  ;   context switch. When UNPACK context switches while waiting for a FAT read
 31728                                  ;   we are done with any in-core FAT blocks, so again there is no race. The
 31729                                  ;   only special concern is that V2 and V3 MSDOS left the last allocated
 31730                                  ;   cluster as "00"; marking it EOF only when the entire alloc request was
 31731                                  ;   satisfied. We can't allow another activation to think this cluster is
 31732                                  ;   free, so we give it a special temporary mark to show that it is, indeed,
 31733                                  ;   allocated.
 31734                                  ;
 31735                                  ;   Note that when we run out of space this algorithem will scan from
 31736                                  ;   dpb_next_free to the end, then scan from cluster 2 through the end,
 31737                                  ;   redundantly scanning the later part of the disk. This only happens when
 31738                                  ;   we run out of space, so sue me.
 31739                                  ;
 31740                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 31741                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 31742                                  ;                                                                          ;
 31743                                  ;   The use of FATBYT and RESTFATBYT is somewhat mysterious. Here is the
 31744                                  ;   explanation:
 31745                                  ;
 31746                                  ;   In the NUL file case (sf_firclus currently 0) ALLOCATE is called with
 31747                                  ;   entry BX = 0. What needs to be done in this case is to stuff the cluster
 31748                                  ;   number of the first cluster allocated in sf_firclus when the ALLOCATE is
 31749                                  ;   complete. THIS VALUE IS SAVED TEMPORARILY IN CLUSTER 0, HENCE THE CURRENT
 31750                                  ;   VALUE IN CLUSTER 0 MUST BE SAVED AND RESTORED. This is a side effect of
 31751                                  ;   the fact that PACK and UNPACK don't treat requests for clusters 0 and 1 as
 31752                                  ;   errors. This "stuff" is done by the call to PACK which is right before
 31753                                  ;   the
 31754                                  ;           LOOP   findfre         ; alloc more if needed
 31755                                  ;   instruction when the first cluster is allocated to the nul file. The
 31756                                  ;   value is recalled from cluster 0 and stored at sf_firclus at ads4:
 31757                                  ;
 31758                                  ;   This method is obviously useless (because it is non-reentrant) for
 31759                                  ;   multitasking, and will have to be changed. Storing the required value on
 31760                                  ;   the stack is recommended. Setting sf_firclus at the PACK of cluster 0
 31761                                  ;   (instead of actually doing the PACK) is BAD because it doesn't handle
 31762                                  ;   problems with INT 24 well.
 31763                                  ;
 31764                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 31765                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 31766                                  ;                                                                          ;
 31767                                  ;       ENTRY   BX = Last cluster of file (0 if null file)
 31768                                  ;               CX = No. of clusters to allocate
 31769                                  ;               ES:BP = Base of drive parameters
 31770                                  ;               [THISSFT] = Points to SFT
 31771                                  ;
 31772                                  ;       EXIT    'C' set if insufficient space
 31773                                  ;                 [FAILERR] can be tested to see the reason for failure
 31774                                  ;                 CX = max. no. of clusters that could be added to file
 31775                                  ;               'C' clear if space allocated
 31776                                  ;                 BX = First cluster allocated
 31777                                  ;                 FAT is fully updated
 31778                                  ;                 sf_FIRCLUS field of SFT set if file was null
 31779                                  ;
 31780                                  ;       USES    ALL but SI, BP
 31781                                  
 31782                                  ;callmagic  proc near
 31783                                  ;       push    ds                             ;push segment of routine 
 31784                                  ;       push    Offset MagicPatch              ;push offset for routine
 31785                                  ;       retf                                   ;simulate jmp far
 31786                                  ;                                              ;far return address is on
 31787                                  ;                                              ;stack, so far return from
 31788                                  ;                                              ;call will return this routine
 31789                                  ;callmagic  endp
 31790                                  
 31791                                  
 31792                                  ; 25/09/2023
 31793                                  %if 0
 31794                                  callmagic:
 31795                                  	push	ds
 31796                                  	push	MagicPatch
 31797                                  	retf	
 31798                                  %endif
 31799                                  
 31800                                  ALLOCATE:
 31801                                  	; 10/09/2018
 31802                                  ;BEGIN MAGICDRV MODIFICATIONS
 31803                                  ;
 31804                                  ;7/5/92 scottq
 31805                                  ;
 31806                                  ;This is the disk compression patch location which allows
 31807                                  ;the disk compression software to fail allocations if the
 31808                                  ;FAT would allows allocation, but the free space for compressed
 31809                                  ;data would not.
 31810                                  ;        
 31811                                  ;;;	call    far ptr MAGICPATCH
 31812                                  ;;; We cannot do a far call since we cannot have fix-ups[romdos,hidos],
 31813                                  ;;; but we do know the segment and offset of the routine
 31814                                  ;;; so simulate a far call to dosdata:magicpatch
 31815                                  ;;; note dosassume above, so DS -> dosdata
 31816                                  
 31817                                  	; MSDOS 6.0
 31818                                          ;clc				;clear carry so we fall through
 31819                                  	;				;if no patch is present
 31820                                  	;push	cs			;push segment for far return
 31821                                          ;call	callmagic		;this is a near call
 31822                                          ;jnc	short Regular_Allocate_Path
 31823                                  	;jmp	Disk_Full_Return
 31824                                  
 31825                                  ; 25/09/2023
 31826                                  %if 0
 31827                                  	clc
 31828                                  	push	cs
 31829                                  	call	callmagic
 31830                                  	jnc	short Regular_Allocate_Path
 31831                                  	jmp	Disk_Full_Return
 31832                                  Regular_Allocate_Path:
 31833                                  %endif
 31834                                  
 31835                                  	; 20/05/2019 - Retro DOS v4.0
 31836                                  ;END MAGICDRV MODIFICATIONS
 31837                                  
 31838                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31839                                  	; DOSCODE:8D87h (MSDOS 5.0, MSDOS.SYS)
 31840                                  
 31841 000057C8 53                              PUSH    BX                      ; save (bx)
 31842 000057C9 31DB                            XOR     BX,BX
 31843 000057CB E82407                  	call	UNPACK
 31844 000057CE 893E[9605]                      MOV     [FATBYT],DI             ; save correct cluster 0 value
 31845 000057D2 5B                              POP     BX
 31846 000057D3 72F2                            jc	short figrec_retn	; abort if error   [INTERR?]
 31847                                  
 31848 000057D5 51                              PUSH    CX
 31849 000057D6 53                              PUSH    BX
 31850                                  
 31851 000057D7 89DA                            MOV     DX,BX
 31852                                  	;;mov	bx,[es:bp+1Ch]  ; MSDOS 3.3
 31853                                  	;mov	bx,[es:bp+1Dh]	; MSDOS 6.0
 31854 000057D9 268B5E1D                        mov     bx,[ES:BP+DPB.NEXT_FREE]
 31855 000057DD 83FB02                          cmp     bx,2
 31856 000057E0 7709                            ja	short FINDFRE
 31857                                  
 31858                                  ;   couldn't find enough free space beyond dpb_next_free, or dpb_next_free is
 31859                                  ;   <2 or >dpb_max_clus. Reset it and restart the scan
 31860                                  
 31861                                  ads1:
 31862                                  	;;mov	word [es:bp+1Ch],2 ; MSDOS 3.3
 31863                                  	;mov	word [es:bp+1Dh],2 ; MSDOS 6.0
 31864 000057E2 26C7461D0200                    mov     word [ES:BP+DPB.NEXT_FREE],2
 31865 000057E8 BB0100                          mov     bx,1                    ; Counter next instruction so first
 31866                                                                          ;       cluster examined is 2
 31867                                  
 31868                                  ;   Scanning both forwards and backwards for a free cluster
 31869                                  ;
 31870                                  ;       (BX) = forwards scan pointer
 31871                                  ;       (CX) = clusters remaining to be allocated
 31872                                  ;       (DX) = current last cluster in file
 31873                                  ;       (TOS) = last cluster of file
 31874                                  
 31875                                  FINDFRE:
 31876 000057EB 43                              INC     BX
 31877                                  	;cmp	bx,[es:bp+0Dh]
 31878 000057EC 263B5E0D                        CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 31879 000057F0 7757                    	ja	short ads7	; at end of disk
 31880 000057F2 E8FD06                          call	UNPACK          ; check out this cluster
 31881 000057F5 722F                            jc	short ads4	; FAT error             [INTERR?]
 31882 000057F7 75F2                            jnz	short FINDFRE	; not free, keep on truckin
 31883                                  
 31884                                  ;   Have found a free cluster. Chain it to the file
 31885                                  ;
 31886                                  ;       (BX) = found free cluster #
 31887                                  ;       (DX) = current last cluster in file
 31888                                  
 31889                                  	;;mov	[es:bp+1Ch],bx
 31890                                  	;mov	[es:bp+1Dh],bx ; MSDOS 6.0
 31891 000057F9 26895E1D                        mov	[ES:BP+DPB.NEXT_FREE],bx ; next time start search here
 31892 000057FD 92                              xchg    ax,dx           ; save (dx) in ax
 31893 000057FE BA0100                          mov     dx,1            ; mark this free guy as "1"
 31894 00005801 E84207                  	call	PACK            ; set special "temporary" mark
 31895 00005804 7220                            jc	short ads4	; FAT error             [INTERR?]
 31896                                  	;;cmp	word [es:bp+1Eh],-1
 31897                                          ;cmp	word [es:bp+1Fh],-1 ; MSDOS 6.0
 31898 00005806 26837E1FFF              	CMP	word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 31899 0000580B 7404                            JZ	short NO_ALLOC	; No
 31900                                  	;;dec	word [es:bp+1Eh]
 31901                                          ;dec	word [es:bp+1Fh] ; MSDOS 6.0
 31902 0000580D 26FF4E1F                        DEC     word [ES:BP+DPB.FREE_CNT] ; Reduce free count by 1
 31903                                  NO_ALLOC:
 31904 00005811 92                              xchg    ax,dx           ; (dx) = current last cluster in file
 31905 00005812 87DA                            XCHG    BX,DX
 31906 00005814 89D0                            MOV     AX,DX
 31907 00005816 E82D07                  	call	PACK            ; link free cluster onto file
 31908                                                                  ;  CAVEAT.. On Nul file, first pass stuffs
 31909                                                                  ;    cluster 0 with FIRCLUS value.
 31910 00005819 720B                            jc	short ads4	; FAT error [INTERR?]
 31911 0000581B 93                              xchg    BX,AX           ; (BX) = last one we looked at
 31912 0000581C 89DA                            mov     dx,bx           ; (dx) = current end of file
 31913 0000581E E2CB                            LOOP    FINDFRE         ; alloc more if needed
 31914                                  
 31915                                  ;   We've successfully extended the file. Clean up and exit
 31916                                  ;
 31917                                  ;       (BX) = last cluster in file
 31918                                  
 31919 00005820 BAFFFF                          MOV     DX,0FFFFH
 31920 00005823 E82007                  	call	PACK            ; mark last cluster EOF
 31921                                  
 31922                                  ;   Note that FAT errors jump here to clean the stack and exit. This saves us
 31923                                  ;   2 whole bytes. Hope its worth it...
 31924                                  ;
 31925                                  ;       'C' set if error
 31926                                  ;       calling (BX) and (CX) pushed on stack
 31927                                  
 31928                                  ads4:   
 31929 00005826 5B                      	POP     BX
 31930 00005827 59                              POP     CX              ; Don't need this stuff since we're successful
 31931 00005828 729D                            jc	short figrec_retn
 31932 0000582A E8C506                          call	UNPACK          ; Get first cluster allocated for return
 31933                                                                  ; CAVEAT... In nul file case, UNPACKs cluster 0.
 31934 0000582D 7298                            jc	short figrec_retn
 31935 0000582F E83200                  	call	RESTFATBYT      ; Restore correct cluster 0 value
 31936 00005832 7293                            jc	short figrec_retn
 31937 00005834 87DF                            XCHG    BX,DI           ; (DI) = last cluster in file upon our entry
 31938 00005836 09FF                            OR      DI,DI           ; clear 'C'
 31939 00005838 758D                    	jnz	short figrec_retn ; we were extending an existing file
 31940                                  
 31941                                  ;   We were doing the first allocation for a new file. Update the SFT cluster
 31942                                  ;   info
 31943                                  dofastk:
 31944                                  	; 20/05/2019
 31945                                  	; MSDOS 6.0
 31946                                  	;push	dx ; * MSDOS 6.0
 31947                                  	;;mov	dl,[es:bp+0]
 31948                                  	;;MOV	DL,[ES:BP+DPB.DRIVE]	; get drive #
 31949                                  	;mov	dl,[es:bp]
 31950                                  
 31951                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31952                                  	; DOSCODE:8DF9h (MSDOS 5.0, MSDOS.SYS)
 31953                                  	
 31954                                  	; 16/12/2022
 31955                                  	;push	dx ; *
 31956                                  	;mov	dl,[ES:BP+DPB.DRIVE] 
 31957                                  	; 15/12/2022
 31958                                  	;mov	dl,[es:bp]
 31959                                  	
 31960                                  	; MSDOS 3.3 & MSDOS 6.0
 31961 0000583A 06                      	PUSH	ES
 31962 0000583B C43E[9E05]              	LES     DI,[THISSFT]
 31963                                  	;mov	[es:di+0Bh],bx
 31964 0000583F 26895D0B                	MOV     [ES:DI+SF_ENTRY.sf_firclus],BX
 31965                                  	;;mov	[es:di+1Bh],bx ; MSDOS 3.3
 31966                                  	;mov	[es:di+35h],bx ; MSDOS 6.0
 31967 00005843 26895D35                	MOV     [ES:DI+SF_ENTRY.sf_lstclus],BX
 31968 00005847 07                      	POP	ES
 31969                                  	;retn
 31970                                  
 31971                                  	;pop	dx ; * MSDOS 6.0
 31972                                  
 31973                                  	; 16/12/2022
 31974                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31975                                  	;pop	dx ; *
 31976                                  
 31977 00005848 C3                      	retn	
 31978                                  
 31979                                  ;** we're at the end of the disk, and not satisfied. See if we've scanned ALL
 31980                                  ;   of the disk...
 31981                                  
 31982                                  ads7:   
 31983 00005849 26837E1D02              	cmp	word [ES:BP+DPB.NEXT_FREE],2
 31984 0000584E 7592                    	jnz	short ads1	; start scan from front of disk
 31985                                  
 31986                                  ;   Sorry, we've gone over the whole disk, with insufficient luck. Lets give
 31987                                  ;   the space back to the free list and tell the caller how much he could have
 31988                                  ;   had.  We have to make sure we remove the "special mark" we put on the last
 31989                                  ;   cluster we were able to allocate, so it doesn't become orphaned.
 31990                                  ;
 31991                                  ;       (CX) = clusters remaining to be allocated
 31992                                  ;       (TOS) = last cluster of file (before call to ALLOCATE)
 31993                                  ;       (TOS+1) = # of clusters wanted to allocate
 31994                                  
 31995 00005850 5B                              POP     BX              ; (BX) = last cluster of file
 31996 00005851 BAFFFF                          MOV     DX,0FFFFH
 31997 00005854 E81F00                  	call	RELBLKS         ; give back any clusters just alloced
 31998 00005857 58                              POP     AX              ; No. of clusters requested
 31999                                                                  ; Don't "retc". We are setting Carry anyway,
 32000                                                                  ;   Alloc failed, so proceed with return CX
 32001                                                                  ;   setup.
 32002 00005858 29C8                            SUB     AX,CX           ; AX=No. of clusters allocated
 32003 0000585A E80700                  	call	RESTFATBYT      ; Don't "retc". We are setting Carry anyway,
 32004                                                                  ;   Alloc failed.
 32005                                  Disk_Full_Return:               ;label added for magic patch 8-6-92 scottq
 32006                                          ; MSDOS 6.0
 32007 0000585D C606[0B06]01            	MOV	byte [DISK_FULL],1 ;MS. indicating disk full
 32008 00005862 F9                              STC
 32009 00005863 C3                              retn
 32010                                  
 32011                                  ;-----------------------------------------------------------------------
 32012                                  ;
 32013                                  ; Procedure Name : RESTFATBYT
 32014                                  ;
 32015                                  ; SEE ALLOCATE CAVEAT
 32016                                  ;       Carry set if error (currently user FAILed to I 24)
 32017                                  ;-----------------------------------------------------------------------
 32018                                  
 32019                                  RESTFATBYT:
 32020 00005864 53                              PUSH    BX
 32021 00005865 52                              PUSH    DX
 32022 00005866 57                              PUSH    DI
 32023 00005867 31DB                            XOR     BX,BX
 32024 00005869 8B16[9605]                      MOV     DX,[FATBYT]
 32025 0000586D E8D606                  	call	PACK
 32026 00005870 5F                              POP     DI
 32027 00005871 5A                              POP     DX
 32028 00005872 5B                              POP     BX
 32029                                  ; 16/12/2022
 32030                                  ; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 32031                                  ;RELEASE_flush:
 32032 00005873 C3                      	retn
 32033                                  
 32034                                  ;Break	<RELEASE -- DEASSIGN DISK SPACE>
 32035                                  ;---------------------------------------------------------------------------
 32036                                  ;
 32037                                  ; Procedure Name : RELEASE
 32038                                  ;
 32039                                  ; Inputs:
 32040                                  ;       BX = Cluster in file
 32041                                  ;       ES:BP = Base of drive parameters
 32042                                  ; Function:
 32043                                  ;       Frees cluster chain starting with [BX]
 32044                                  ;       Carry set if error (currently user FAILed to I 24)
 32045                                  ; AX,BX,DX,DI all destroyed. Other registers unchanged.
 32046                                  ;
 32047                                  ;-----------------------------------------------------------------------------
 32048                                  
 32049                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32050                                  	; 20/05/2019 - Retro DOS v4.0
 32051                                  RELEASE:
 32052 00005874 31D2                            XOR     DX,DX
 32053                                  
 32054                                  	;entry	RELBLKS
 32055                                  RELBLKS:
 32056                                  
 32057                                  ;   Enter here with DX=0FFFFH to put an end-of-file mark in the first cluster
 32058                                  ;   and free the rest in the chain.
 32059                                  
 32060 00005876 E87906                  	call	UNPACK
 32061 00005879 7224                    	jc	short RELEASE_flush
 32062 0000587B 7422                    	jz	short RELEASE_flush
 32063 0000587D 89F8                            MOV     AX,DI
 32064 0000587F 52                              PUSH    DX
 32065 00005880 E8C306                  	call	PACK
 32066 00005883 5A                              POP     DX
 32067 00005884 7219                    	jc	short RELEASE_flush
 32068 00005886 09D2                            OR      DX,DX
 32069 00005888 750B                            JNZ	short NO_DEALLOC	; Was putting EOF mark
 32070                                  	;;cmp	word [es:bp+1Eh],-1 ; MSDOS 3.3
 32071                                  	;cmp	word [es:bp+1Fh],-1 ; MSDOS 6.0
 32072 0000588A 26837E1FFF              	CMP     word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 32073 0000588F 7404                            JZ	short NO_DEALLOC	; No
 32074 00005891 26FF461F                        INC	word [ES:BP+DPB.FREE_CNT] ; Increase free count by 1
 32075                                  NO_DEALLOC:
 32076 00005895 89C3                            MOV     BX,AX
 32077 00005897 48                              dec     ax              ; check for "1"
 32078 00005898 7405                    	jz	short RELEASE_flush	; is last cluster of incomplete chain
 32079 0000589A E83E06                  	call	IsEOF
 32080 0000589D 72D5                            JB	short RELEASE	; Carry clear if JMP not taken
 32081                                  
 32082                                  	; 16/12/2022
 32083                                  ; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 32084                                  ;%if 0
 32085                                  RELEASE_flush:
 32086                                  	; MSDOS 6.0
 32087 0000589F 268A4600                	mov	al,[es:bp]
 32088                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 32089 000058A3 56                      	push	si		; FLUSHBUF may trash these and we guarantee
 32090 000058A4 51                      	push	cx		;  them to be preserved.
 32091 000058A5 06                      	push	es
 32092 000058A6 55                      	push	bp
 32093 000058A7 E8850B                  	call	FLUSHBUF	; commit buffers for this drive
 32094 000058AA 5D                      	pop	bp
 32095 000058AB 07                      	pop	es
 32096 000058AC 59                      	pop	cx
 32097 000058AD 5E                      	pop	si
 32098                                  ;%endif
 32099                                  RET12:
 32100 000058AE C3                      	retn
 32101                                  
 32102                                  ;Break	<GETEOF -- Find the end of a file>
 32103                                  ;------------------------------------------------------------------------
 32104                                  ;
 32105                                  ; Procedure Name : GETEOF
 32106                                  ;
 32107                                  ; Inputs:
 32108                                  ;       ES:BP Points to DPB
 32109                                  ;       BX = Cluster in a file
 32110                                  ;       DS = CS
 32111                                  ; Outputs:
 32112                                  ;       BX = Last cluster in the file
 32113                                  ;       Carry set if error (currently user FAILed to I 24)
 32114                                  ; DI destroyed. No other registers affected.
 32115                                  ;
 32116                                  ;--------------------------------------------------------------------------
 32117                                  
 32118                                  GETEOF:
 32119 000058AF E84006                  	call	UNPACK
 32120 000058B2 72FA                            jc	short RET12
 32121 000058B4 53                              PUSH    BX
 32122 000058B5 89FB                            MOV     BX,DI
 32123 000058B7 E82106                  	call	IsEOF
 32124 000058BA 5B                              POP     BX
 32125 000058BB 73F1                            JAE     short RET12
 32126 000058BD 89FB                            MOV     BX,DI
 32127 000058BF EBEE                            JMP     short GETEOF
 32128                                  
 32129                                  ;============================================================================
 32130                                  ; FCB.ASM, MSDOS 6.0, 1991
 32131                                  ;============================================================================
 32132                                  ; 30/07/2018 - Retro DOS v3.0
 32133                                  ; 20/05/2019 - Retro DOS v4.0
 32134                                  
 32135                                  ;	TITLE	FCB - FCB parse calls for MSDOS
 32136                                  ;	NAME	FCB
 32137                                  
 32138                                  ;**	FCB.ASM - Low level routines for parsing names into FCBs and analyzing
 32139                                  ;		  filename characters
 32140                                  ;
 32141                                  ;	MakeFcb
 32142                                  ;	NameTrans
 32143                                  ;	PATHCHRCMP
 32144                                  ;	GetLet
 32145                                  ;	UCase
 32146                                  ;	GetLet3
 32147                                  ;	GetCharType
 32148                                  ;	TESTKANJ
 32149                                  ;	NORMSCAN
 32150                                  ;	DELIM
 32151                                  ;
 32152                                  ;	Revision history:
 32153                                  ;
 32154                                  ;		A000  version 4.00  Jan. 1988
 32155                                  ;	
 32156                                  ;	M048 - access FILE_UCASE_TAB using DS rather than SS.
 32157                                  
 32158                                  TableLook	EQU	-1
 32159                                  
 32160                                  SCANSEPARATOR	EQU	1
 32161                                  DRVBIT		EQU	2
 32162                                  NAMBIT		EQU	4
 32163                                  EXTBIT		EQU	8
 32164                                  
 32165                                  ;----------------------------------------------------------------------------
 32166                                  ;
 32167                                  ; Procedure : MakeFcb
 32168                                  ;
 32169                                  ;----------------------------------------------------------------------------
 32170                                  
 32171                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32172                                  	; DOSCODE:8E77h (MSDOS 5.0, MSDOS.SYS)
 32173                                  MAKEFCB:
 32174                                  ;hkn; SS override
 32175 000058C1 36C606[4E03]00          	MOV	BYTE [SS:SpaceFlag],0
 32176 000058C7 30D2                    	XOR	DL,DL		; Flag--not ambiguous file name
 32177                                  	;test	al,2
 32178 000058C9 A802                    	test	AL,DRVBIT	; Use current drive field if default?
 32179 000058CB 7504                    	JNZ	short DEFDRV
 32180 000058CD 26C60500                	MOV	BYTE [ES:DI],0	; No - use default drive
 32181                                  DEFDRV:
 32182 000058D1 47                      	INC	DI
 32183 000058D2 B90800                  	MOV	CX,8
 32184                                  	;test	al,4
 32185 000058D5 A804                    	test	AL,NAMBIT	; Use current name fields as default?
 32186 000058D7 93                      	XCHG	AX,BX		; Save bits in BX
 32187 000058D8 B020                    	MOV	AL," "
 32188 000058DA 7404                    	JZ	short FILLB	; If not, go fill with blanks
 32189 000058DC 01CF                    	ADD	DI,CX
 32190 000058DE 31C9                    	XOR	CX,CX		; Don't fill any
 32191                                  FILLB:
 32192 000058E0 F3AA                    	REP	STOSB
 32193 000058E2 B103                    	MOV	CL,3
 32194 000058E4 F6C308                  	test	BL,EXTBIT	; Use current extension as default
 32195 000058E7 7404                    	JZ	short FILLB2
 32196 000058E9 01CF                    	ADD	DI,CX
 32197 000058EB 31C9                    	XOR	CX,CX
 32198                                  FILLB2:
 32199 000058ED F3AA                    	REP	STOSB
 32200 000058EF 91                      	XCHG	AX,CX		; Put zero in AX
 32201 000058F0 AB                      	STOSW
 32202 000058F1 AB                      	STOSW			; Initialize two words after to zero
 32203 000058F2 83EF10                  	SUB	DI,16		; Point back at start
 32204                                  	;test	bl,1
 32205 000058F5 F6C301                  	test	BL,SCANSEPARATOR; Scan off separators if not zero
 32206 000058F8 7409                    	JZ	short SKPSPC
 32207 000058FA E88800                  	CALL	SCANB		; Peel off blanks and tabs
 32208 000058FD E82201                  	CALL	DELIM		; Is it a one-time-only delimiter?
 32209 00005900 7504                    	JNZ	short NOSCAN
 32210 00005902 46                      	INC	SI		; Skip over the delimiter
 32211                                  SKPSPC:
 32212 00005903 E87F00                  	CALL	SCANB		; Always kill preceding blanks and tabs
 32213                                  NOSCAN:
 32214 00005906 E8F000                  	CALL	GETLET
 32215 00005909 761E                    	JBE	short NODRV	; Quit if termination character
 32216 0000590B 803C3A                  	CMP	BYTE [SI],":"	; Check for potential drive specifier
 32217 0000590E 7519                    	JNZ	short NODRV
 32218 00005910 46                      	INC	SI		; Skip over colon
 32219 00005911 2C40                    	SUB	AL,"@"          ; Convert drive letter to drive number (A=1)
 32220 00005913 760F                    	JBE	short BADDRV	; Drive letter out of range
 32221                                  
 32222 00005915 50                      	PUSH	AX
 32223 00005916 E8501B                  	call	GetVisDrv
 32224 00005919 58                      	POP	AX
 32225 0000591A 730A                    	JNC	short HAVDRV
 32226                                  
 32227                                  	; 20/05/2019 - Retro DOS v4.0
 32228                                  	; MSDOS 6.0
 32229                                  ;hkn; SS override
 32230 0000591C 36803E[1006]1A          	CMP	byte [SS:DrvErr],error_not_DOS_disk ; 1Ah
 32231                                  					; if not FAT drive ;AN000;
 32232 00005922 7402                    	JZ	short HAVDRV		; assume ok	   ;AN000;
 32233                                  BADDRV:
 32234 00005924 B2FF                    	MOV	DL,-1
 32235                                  HAVDRV:
 32236 00005926 AA                      	STOSB			; Put drive specifier in first byte
 32237 00005927 46                      	INC	SI
 32238 00005928 4F                      	DEC	DI		; Counteract next two instructions
 32239                                  NODRV:
 32240 00005929 4E                      	DEC	SI		; Back up
 32241 0000592A 47                      	INC	DI		; Skip drive byte
 32242                                  
 32243                                  	;entry	NORMSCAN
 32244                                  NORMSCAN:
 32245 0000592B B90800                  	MOV	CX,8
 32246 0000592E E82200                  	CALL	GETWORD 	; Get 8-letter file name
 32247 00005931 803C2E                  	CMP	BYTE [SI],"."
 32248 00005934 7510                    	JNZ	short NODOT
 32249 00005936 46                      	INC	SI		; Skip over dot if present
 32250                                  
 32251                                  	; 24/09/2023
 32252                                  	;mov	cx,3
 32253 00005937 B103                    	mov	cl,3	; ch=0
 32254                                  
 32255                                  	; MSDOS 6.0
 32256                                  ;hkn; SS override
 32257                                  	;TEST	word [SS:DOS34_FLAG],DBCS_VOLID2 ; 100h ;AN000;
 32258                                  	; 10/06/2019
 32259 00005939 36F606[1206]01          	test	byte [SS:DOS34_FLAG+1],(DBCS_VOLID2>>8) ; 1
 32260 0000593F 7402                    	JZ	short VOLOK				;AN000;
 32261 00005941 A4                      	MOVSB			; 2nd byte of DBCS	;AN000;
 32262                                  	; 24/09/2023
 32263                                  	;MOV	CX,2					;AN000;
 32264 00005942 49                      	dec	cx  ; cx=2
 32265                                  	;JMP	SHORT contvol				;AN000;
 32266                                  VOLOK:
 32267                                  	;MOV	CX,3		; Get 3-letter extension
 32268                                  contvol:
 32269 00005943 E81300                  	CALL	MUSTGETWORD
 32270                                  NODOT:
 32271 00005946 88D0                    	MOV	AL,DL
 32272                                  
 32273                                  	; MSDOS 6.0
 32274                                  	;and	word [ss:DOS34_FLAG],0FEFFh
 32275                                  	; 18/12/2022
 32276 00005948 368026[1206]FE          	and	byte [ss:DOS34_FLAG+1],0FEh ; (~DBCS_VOLID2)>>8
 32277                                  	;and	word [ss:DOS34_FLAG],~DBCS_VOLID2 ; ### BUG FIX ###
 32278                                  
 32279 0000594E C3                      	retn
 32280                                  
 32281                                  NONAM:
 32282 0000594F 01CF                    	ADD	DI,CX
 32283 00005951 4E                      	DEC	SI
 32284 00005952 C3                      	retn
 32285                                  
 32286                                  GETWORD:
 32287 00005953 E8A300                  	CALL	GETLET		
 32288 00005956 76F7                    	JBE	short NONAM	; Exit if invalid character
 32289 00005958 4E                      	DEC	SI
 32290                                  
 32291                                  ;	UGH!!! Horrible bug here that should be fixed at some point:
 32292                                  ;	If the name we are scanning is longer than CX, we keep on reading!
 32293                                  
 32294                                  MUSTGETWORD:
 32295 00005959 E89D00                  	CALL	GETLET
 32296                                  
 32297                                  ;	If spaceFlag is set then we allow spaces in a pathname
 32298                                  
 32299                                  ;IF NOT TABLELOOK
 32300                                  ;	JB	short FILLNAM  ; MSDOS 3.3
 32301                                  ;ENDIF
 32302 0000595C 750C                    	JNZ	short MustCheckCX
 32303                                  
 32304                                  ;hkn; SS override
 32305 0000595E 36F606[4E03]FF          	test	BYTE [SS:SpaceFlag],0FFh
 32306 00005964 7419                    	JZ	short FILLNAM
 32307 00005966 3C20                    	CMP	AL," "
 32308 00005968 7515                    	JNZ	short FILLNAM
 32309                                  
 32310                                  MustCheckCX:
 32311 0000596A E3ED                    	JCXZ	MUSTGETWORD
 32312 0000596C 49                      	DEC	CX
 32313 0000596D 3C2A                    	CMP	AL,"*"          ; Check for ambiguous file specifier
 32314 0000596F 7504                    	JNZ	short NOSTAR
 32315 00005971 B03F                    	MOV	AL,"?"
 32316 00005973 F3AA                    	REP	STOSB
 32317                                  NOSTAR:
 32318 00005975 AA                      	STOSB
 32319 00005976 3C3F                    	CMP	AL,"?"
 32320 00005978 75DF                    	JNZ	short MUSTGETWORD
 32321 0000597A 80CA01                  	OR	DL,1		; Flag ambiguous file name
 32322 0000597D EBDA                    	JMP	short MUSTGETWORD
 32323                                  FILLNAM:
 32324 0000597F B020                    	MOV	AL," "
 32325 00005981 F3AA                    	REP	STOSB
 32326 00005983 4E                      	DEC	SI
 32327 00005984 C3                      	retn
 32328                                  
 32329                                  SCANB:
 32330 00005985 AC                      	LODSB
 32331 00005986 E8A100                  	CALL	SPCHK
 32332 00005989 74FA                    	JZ	short SCANB
 32333 0000598B 4E                      	DEC	SI
 32334                                  scanb_retn:
 32335 0000598C C3                      	retn
 32336                                  
 32337                                  ;----------------------------------------------------------------------------
 32338                                  ;
 32339                                  ; Procedure Name : NameTrans
 32340                                  ;
 32341                                  ; NameTrans is used by FindPath to scan off an element of a path. We must
 32342                                  ; allow spaces in pathnames
 32343                                  ;
 32344                                  ;   Inputs:	DS:SI points to start of path element
 32345                                  ;   Outputs:	Name1 has unpacked name, uppercased
 32346                                  ;		ES = DOSGroup
 32347                                  ;		DS:SI advanced after name
 32348                                  ;   Registers modified: DI,AX,DX,CX
 32349                                  ;
 32350                                  ;----------------------------------------------------------------------------
 32351                                  
 32352                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32353                                  	; 20/05/2019 - Retro DOS v4.0
 32354                                  NameTrans:
 32355                                  ;hkn; SS override
 32356 0000598D 36C606[4E03]01          	MOV	BYTE [SS:SpaceFlag],1
 32357 00005993 16                      	push	ss
 32358 00005994 07                      	pop	es
 32359                                  
 32360                                  ;hkn; NAME1 is in DOSDATA
 32361 00005995 BF[4B05]                	MOV	DI,NAME1
 32362 00005998 57                      	PUSH	DI
 32363 00005999 B82020                  	MOV	AX,'  '
 32364 0000599C B90500                  	MOV	CX,5
 32365 0000599F AA                      	STOSB
 32366 000059A0 F3AB                    	REP	STOSW		; Fill "FCB" at NAME1 with spaces
 32367 000059A2 30C0                    	XOR	AL,AL		; Set stuff for NORMSCAN
 32368 000059A4 88C2                    	MOV	DL,AL
 32369 000059A6 AA                      	STOSB
 32370 000059A7 5F                      	POP	DI
 32371                                  
 32372 000059A8 E880FF                  	CALL	NORMSCAN
 32373                                  
 32374                                  ;hkn; SS override for NAME1
 32375 000059AB 36803E[4B05]E5          	CMP	byte [SS:NAME1],0E5H
 32376 000059B1 75D9                    	jnz	short scanb_retn
 32377 000059B3 36C606[4B05]05          	MOV	byte [SS:NAME1],5 ; Magic name translation
 32378 000059B9 C3                      	retn
 32379                                  
 32380                                  ;Break	<GETLET, DELIM -- CHECK CHARACTERS AND CONVERT>
 32381                                  ;============================================================================
 32382                                  
 32383                                  ; 20/05/2019 - Retro DOS v4.0
 32384                                  ; DOSCODE:8FD2h (MSDOS 6.21, MSDOS.SYS)
 32385                                  
 32386                                  ;If TableLook
 32387                                  
 32388                                  ;hkn; Table	SEGMENT
 32389                                  ;	PUBLIC	CharType
 32390                                  ;----------------------------------------------------------------------------
 32391                                  
 32392                                  ; Character type table for file name scanning
 32393                                  ; Table provides a mapping of characters to validity bits.
 32394                                  ; Four bits are provided for each character. Values 7Dh and above
 32395                                  ; have all bits set, so that part of the table is chopped off, and
 32396                                  ; the translation routine is responsible for screening these values.
 32397                                  ; The bit values are defined in DOSSYM.INC
 32398                                  
 32399                                  ;	      ; ^A and NUL
 32400                                  ;CharType:
 32401                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32402                                  ;	      ; ^C and ^B
 32403                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32404                                  ;	      ; ^E and ^D
 32405                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32406                                  ;	      ; ^G and ^F
 32407                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32408                                  ;	      ; TAB and BS
 32409                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM+FSPCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32410                                  ;	      ; ^K and ^J
 32411                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32412                                  ;	      ; ^M and ^L
 32413                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32414                                  ;	      ; ^O and ^N
 32415                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32416                                  ;	      ; ^Q and ^P
 32417                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32418                                  ;	      ; ^S and ^R
 32419                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32420                                  ;	      ; ^U and ^T
 32421                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32422                                  ;	      ; ^W and ^V
 32423                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32424                                  ;	      ; ^Y and ^X
 32425                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32426                                  ;	      ; ESC and ^Z
 32427                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32428                                  ;	      ; ^] and ^;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32430                                  ;	      ; ^_ and ^^
 32431                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32432                                  ;	      ; ! and SPACE
 32433                                  ;	 db   LOW (NOT FCHK+FDELIM+FSPCHK)
 32434                                  ;	      ; # and "
 32435                                  ;	 db   LOW (NOT FFCB+FCHK)
 32436                                  ;	      ; $ - )
 32437                                  ;	 db   3 dup (0FFh)
 32438                                  ;	      ; + and *
 32439                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR 0Fh
 32440                                  ;	      ; - and '
 32441                                  ;	 db   NOT (FFCB+FCHK+FDELIM)
 32442                                  ;	      ; / and .
 32443                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FCHK) AND 0Fh
 32444                                  ;	      ; 0 - 9
 32445                                  ;	 db   5 dup (0FFh)
 32446                                  ;	      ; ; and :
 32447                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
 32448                                  ;	      ; = and <
 32449                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
 32450                                  ;	      ; ? and >
 32451                                  ;	 db   NOT FFCB+FCHK+FDELIM
 32452                                  ;	      ; A - Z
 32453                                  ;	 db   13 dup (0FFh)
 32454                                  ;	      ; \ and [
 32455                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR 0Fh
 32456                                  ;	      ; ^ and ]
 32457                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32458                                  ;	      ; _ - {
 32459                                  ;	 db   15 dup (0FFh)
 32460                                  ;	      ; } and |
 32461                                  ;	 db   NOT FFCB+FCHK+FDELIM
 32462                                  
 32463                                  ;CharType_last equ ($ - CharType) * 2	; This is the value of the last
 32464                                  ;					; character in the table
 32465                                  
 32466                                  ;FCHK	equ 1		; normal name char, no chks needed
 32467                                  ;FDELIM	equ 2		; is a delimiter
 32468                                  ;FSPCHK	equ 4		; set if character is not a space or equivalent
 32469                                  ;FFCB	equ 8		; is valid in an FCB
 32470                                  
 32471                                  ; DOSCODE:8FD2h (MSDOS 6.21, MSDOS.SYS)
 32472                                  ;----------------------------------------------------------------------------
 32473                                  ; DOSCODE:8F76h (MSDOS 5.0, MSDOS.SYS)
 32474                                  
 32475                                  CharType: ; 63 bytes
 32476 000059BA 6666666606666666                db  66h, 66h, 66h, 66h, 06h, 66h, 66h, 66h ; 0-7
 32477 000059C2 6666666666666666        	db  66h, 66h, 66h, 66h, 66h, 66h, 66h, 66h ; 8-15
 32478 000059CA F8F6FFFFFF4FF46E        	db 0F8h,0F6h,0FFh,0FFh,0FFh, 4Fh,0F4h, 6Eh ; 16-23
 32479 000059D2 FFFFFFFFFF4444F4        	db 0FFh,0FFh,0FFh,0FFh,0FFh, 44h, 44h,0F4h ; 24-31
 32480 000059DA FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh ; 32-39
 32481 000059E2 FFFFFFFFFF6F66FF        	db 0FFh,0FFh,0FFh,0FFh,0FFh, 6Fh, 66h,0FFh ; 40-47
 32482 000059EA FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh ; 48-55
 32483 000059F2 FFFFFFFFFFFFF4          	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0F4h	   ; 56-62
 32484                                  
 32485                                  CharType_last equ ($ - CharType) * 2
 32486                                  
 32487                                  ; Offset 12CAh of IBMDOS.COM (MSDOS 3.3), 1987
 32488                                  ;----------------------------------------------------------------------------
 32489                                  ;CharType:
 32490                                  ;       db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 32491                                  ;	db 0F6h,0F0h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 32492                                  ;	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 32493                                  ;	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 32494                                  ;	db 0F8h,0FFh,0F6h,0FFh,0FFh,0FFh,0FFh,0FFh
 32495                                  ;	db 0FFh,0FFh,0FFh,0F4h,0F4h,0FFh,0FEh,0F6h
 32496                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32497                                  ;	db 0FFh,0FFh,0F4h,0F4h,0F4h,0F4h,0F4h,0FFh
 32498                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32499                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32500                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32501                                  ;	db 0FFh,0FFh,0FFh,0F6h,0F6h,0F6h,0FFh,0FFh
 32502                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32503                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32504                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32505                                  ;	db 0FFh,0FFh,0FFh,0FFh,0F4h,0FFh,0FFh,0FFh
 32506                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32507                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32508                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32509                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32510                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32511                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32512                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32513                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32514                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32515                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32516                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32517                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32518                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32519                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32520                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32521                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32522                                  
 32523                                  ;hkn; Table	ENDS
 32524                                  
 32525                                  ;ENDIF
 32526                                  
 32527                                  ; 20/05/2019 - Retro DOS v4.0
 32528                                  ; DOSCODE:9011h (MSDOS 6.21, MSDOS.SYS)
 32529                                  
 32530                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32531                                  ; DOSCODE:8FB5h (MSDOS 5.0, MSDOS.SYS)
 32532                                  
 32533                                  ;----------------------------------------------------------------------------
 32534                                  ;
 32535                                  ; Procedure Names : GetLet, UCase, GetLet3
 32536                                  ;
 32537                                  ; These routines take a character, convert it to upper case, and check
 32538                                  ; for delimiters.  Three different entry points:
 32539                                  ;	GetLet -  DS:[SI] = character to convert
 32540                                  ;	UCase  -  AL = character to convert
 32541                                  ;	GetLet3 - AL = character
 32542                                  ;		  [BX] = translation table to use
 32543                                  ;
 32544                                  ;	Exit (in all cases) : AL = upper case character
 32545                                  ;			      CY set if char is control char other than TAB
 32546                                  ;			      ZF set if char is a delimiter
 32547                                  ;	Uses : AX, flags
 32548                                  ;
 32549                                  ; NOTE: This routine exists in a fast table lookup version, and a slow
 32550                                  ; inline version.  Return with carry set is only possible in the inline
 32551                                  ; version. The table lookup version is the one in use.
 32552                                  ;
 32553                                  ;----------------------------------------------------------------------------
 32554                                  
 32555                                  ; This entry point has character at [SI]
 32556                                  
 32557                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5517h
 32558                                  GETLET:	
 32559 000059F9 AC                      	LODSB
 32560                                  
 32561                                  ; This entry point has character in AL
 32562                                  
 32563                                  	;entry	UCase
 32564                                  UCase:	
 32565                                  	; 09/08/2018
 32566                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5518h
 32567                                  _UCase:
 32568 000059FA 53                      	PUSH	BX
 32569 000059FB BB[850B]                	MOV	BX,FILE_UCASE_TAB+2
 32570                                  
 32571                                  ; Convert the character in AL to upper case
 32572                                  
 32573                                  gl_0:
 32574 000059FE 3C61                    	CMP	AL,"a"
 32575 00005A00 7214                    	JB	short gl_2	; Already upper case, go check type
 32576 00005A02 3C7A                    	CMP	AL,"z"
 32577 00005A04 7702                    	JA	short gl_1
 32578 00005A06 2C20                    	SUB	AL,20H		; Convert to upper case
 32579                                  
 32580                                  ; Map European character to upper case
 32581                                  
 32582                                  gl_1:
 32583 00005A08 3C80                    	CMP	AL,80H
 32584 00005A0A 720A                    	JB	short gl_2	; Not EuroChar, go check type
 32585 00005A0C 2C80                    	SUB	AL,80H		; translate to upper case with this index
 32586                                  
 32587                                  	; M048 - Start 
 32588                                  	; Lantastic call Ucase thru int 2f without setting SS to DOSDATA.
 32589                                  	; So we shall set up DS and to access FILE_UCASE_TAB in BX and also 
 32590                                  	; preserve it.
 32591                                  
 32592                                  	; 09/08/2018 - Retro DOS v3.0
 32593                                  	; MSDOS 3.3
 32594                                  	;;XLAT	BYTE [CS:BX]	; ds as file_ucase_tab is in DOSDATA
 32595                                  	;CS	XLAT
 32596                                  
 32597                                  	; 20/05/2019 - Retro DOS v4.0
 32598                                  
 32599                                  	; MSDOS 6.0
 32600 00005A0E 1E                      	push	ds
 32601                                  	;getdseg <ds>
 32602 00005A0F 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 32603 00005A14 D7                      	XLAT			; ds as file_ucase_tab is in DOSDATA
 32604 00005A15 1F                      	pop	ds
 32605                                  
 32606                                  	; M048 - End
 32607                                  
 32608                                  ; Now check the type
 32609                                  
 32610                                  ;If TableLook
 32611                                  gl_2:
 32612                                  	; 20/05/2019 - Retro DOS v4.0
 32613 00005A16 50                      	PUSH	AX
 32614                                  
 32615                                  	; MSDOS 3.3
 32616                                  	;mov	bx,CharType
 32617                                  	;; 09/08/2018
 32618                                  	;;xlat	byte [cs:bx]
 32619                                  	;cs	xlat	
 32620                                  	
 32621                                  	; MSDOS 6.0
 32622 00005A17 E81800                  	CALL	GetCharType	; returns type flags in AL
 32623                                  	
 32624                                  	;test	al,1	
 32625 00005A1A A801                    	TEST	AL,FCHK 	; test for normal character
 32626 00005A1C 58                      	POP	AX
 32627                                  
 32628 00005A1D 5B                      	POP	BX
 32629 00005A1E C3                      	RETN
 32630                                  
 32631                                  ; This entry has character in AL and lookup table in BX
 32632                                  
 32633                                  	; MSDOS 6.0
 32634                                  ;	;entry GetLet3
 32635                                  GETLET3: ; 10/08/2018
 32636 00005A1F 53                      	PUSH	BX
 32637 00005A20 EBDC                    	JMP	short gl_0
 32638                                  ;ELSE
 32639                                  ;
 32640                                  ;gl_2:
 32641                                  ;	POP	BX
 32642                                  ;	CMP	AL,"."
 32643                                  ;	retz
 32644                                  ;	CMP	AL,'"'
 32645                                  ;	retz
 32646                                  ;	CALL	PATHCHRCMP
 32647                                  ;	retz
 32648                                  ;	CMP	AL,"["
 32649                                  ;	retz
 32650                                  ;	CMP	AL,"]"
 32651                                  ;	retz
 32652                                  ;ENDIF
 32653                                  
 32654                                  ;---------------------------------------------------------------------
 32655                                  ;
 32656                                  ; DELIM - check if character is a delimiter
 32657                                  ;	Entry : AX = character to check
 32658                                  ;	Exit  : ZF set if character is not a delimiter
 32659                                  ;	Uses  : Flags
 32660                                  ;
 32661                                  ;--------------------------------------------------------------------
 32662                                  
 32663                                  	;entry	DELIM
 32664                                  DELIM:
 32665                                  ;IF TableLook
 32666                                  	; 20/05/2019 - Retro DOS v4.0
 32667 00005A22 50                      	PUSH	AX
 32668                                  
 32669                                  	; MSDOS 3.3
 32670                                  	;push	bx
 32671                                  	;mov	bx,CharType
 32672                                  	;;09/08/2018
 32673                                  	;;xlat	byte [cs:bx]
 32674                                  	;cs	xlat
 32675                                  	;pop	bx
 32676                                  
 32677                                  	; MSDOS 6.0
 32678 00005A23 E80C00                  	CALL	GetCharType
 32679                                  	
 32680                                  	;test	al,2
 32681 00005A26 A802                    	TEST	AL,FDELIM
 32682 00005A28 58                      	POP	AX
 32683 00005A29 C3                      	RETN
 32684                                  ;ELSE
 32685                                  ;	CMP	AL,":"
 32686                                  ;	retz
 32687                                  ;
 32688                                  ;	CMP	AL,"<"
 32689                                  ;	retz
 32690                                  ;	CMP	AL,"|"
 32691                                  ;	retz
 32692                                  ;	CMP	AL,">"
 32693                                  ;	retz
 32694                                  ;
 32695                                  ;	CMP	AL,"+"
 32696                                  ;	retz
 32697                                  ;	CMP	AL,"="
 32698                                  ;	retz
 32699                                  ;	CMP	AL,";"
 32700                                  ;	retz
 32701                                  ;	CMP	AL,","
 32702                                  ;	retz
 32703                                  ;ENDIF
 32704                                  
 32705                                  ;-------------------------------------------------------------------------
 32706                                  ;
 32707                                  ;  SPCHK - checks to see if a character is a space or equivalent
 32708                                  ;	Entry : AL = character to check
 32709                                  ;	Exit  : ZF set if character is a space
 32710                                  ;	Uses  : flags
 32711                                  ;
 32712                                  ;-------------------------------------------------------------------------
 32713                                  
 32714                                  	;entry SPCHK
 32715                                  SPCHK:
 32716                                  ;IF TableLook
 32717                                  	; 20/05/2019 - Retro DOS v4.0
 32718 00005A2A 50                      	PUSH	AX
 32719                                  
 32720                                  	; MSDOS 3.3
 32721                                  	;push	bx
 32722                                  	;mov	bx,CharType
 32723                                  	;; 09/08/2018
 32724                                  	;;xlat	byte [cs:bx]
 32725                                  	;cs	xlat
 32726                                  	;pop	bx
 32727                                  
 32728                                  	; MSDOS 6.0
 32729 00005A2B E80400                  	CALL	GetCharType
 32730                                  	
 32731                                  	;test	al,4
 32732 00005A2E A804                    	TEST	AL,FSPCHK
 32733 00005A30 58                      	POP	AX
 32734 00005A31 C3                      	RETN
 32735                                  ;ELSE
 32736                                  ;	CMP	AL,9		; Filter out tabs too
 32737                                  ;	retz
 32738                                  ;; WARNING! " " MUST be the last compare
 32739                                  ;	CMP	AL," "
 32740                                  ;	return
 32741                                  ;ENDIF
 32742                                  
 32743                                  ;-------------------------------------------------------------------------
 32744                                  ;
 32745                                  ;  GetCharType - return flag bits indicating character type
 32746                                  ;	Bits are defined in DOSSYM.INC. Uses lookup table
 32747                                  ;	defined above at label CharType.
 32748                                  ;
 32749                                  ;	Entry : AL = character to return type flags for
 32750                                  ;	Exit  : AL = type flags
 32751                                  ;	Uses  : AL, flags
 32752                                  ;
 32753                                  ;-------------------------------------------------------------------------
 32754                                  
 32755                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32756                                  
 32757                                  	; 20/05/2019 - Retro DOS v4.0
 32758                                  	; MSDOS 6.0
 32759                                  GetCharType:
 32760                                  	;cmp	al,7Eh
 32761 00005A32 3C7E                    	cmp	al,CharType_last 	; beyond end of table?
 32762 00005A34 7316                    	jae	short gct_90		; return standard value
 32763                                  
 32764 00005A36 53                      	push	bx
 32765 00005A37 BB[BA59]                	mov	bx,CharType		; load lookup table
 32766 00005A3A D0E8                    	shr	al,1			; adjust for half-byte table entry size
 32767                                  	;xlat	cs:[bx] 		; get flags
 32768 00005A3C 2ED7                    	cs	xlat	
 32769 00005A3E 5B                      	pop	bx
 32770                                  
 32771                                  ; carry clear from previous shift means we want the low nibble.  Otherwise
 32772                                  ; we have to shift the flags down to the low nibble
 32773                                  
 32774 00005A3F 7308                    	jnc	short gct_80		; carry clear, no shift needed
 32775                                  
 32776 00005A41 D0E8                    	shr	al,1			; we want high nibble, shift it down
 32777 00005A43 D0E8                    	shr	al,1
 32778 00005A45 D0E8                    	shr	al,1
 32779 00005A47 D0E8                    	shr	al,1
 32780                                  gct_80:
 32781 00005A49 240F                    	and	al,0Fh			; clear the unused nibble
 32782 00005A4B C3                      	retn
 32783                                  gct_90:
 32784 00005A4C B00F                    	mov	al,0Fh			; set all flags
 32785 00005A4E C3                      	retn
 32786                                  
 32787                                  ;----------------------------------------------------------------------------
 32788                                  ;
 32789                                  ; Procedure : PATHCHRCMP
 32790                                  ;
 32791                                  ;----------------------------------------------------------------------------
 32792                                  
 32793                                  PATHCHRCMP:
 32794 00005A4F 3C2F                    	CMP	AL,'/'
 32795 00005A51 7606                    	JBE	short PathRet
 32796 00005A53 3C5C                    	CMP	AL,'\'
 32797 00005A55 C3                      	retn
 32798                                  GotFor:
 32799 00005A56 B05C                    	MOV	AL,'\'
 32800 00005A58 C3                      	retn
 32801                                  PathRet:
 32802 00005A59 74FB                    	JZ	short GotFor
 32803 00005A5B C3                      	retn
 32804                                  
 32805                                  ;============================================================================
 32806                                  ; MSCRTLC.ASM, MSDOS 6.0, 1991
 32807                                  ;============================================================================
 32808                                  ; 30/07/2018 - Retro DOS v3.0
 32809                                  ; 29/04/2019 - Retro DOS v4.0
 32810                                  
 32811                                  ; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11, CTRLC.ASM, 1983)
 32812                                  
 32813                                  ;**	MSCTRLC.ASM - ^C and error handler for MSDOS
 32814                                  
 32815                                  ;	TITLE	Control C detection, Hard error and EXIT routines
 32816                                  ;	NAME	IBMCTRLC
 32817                                  
 32818                                  ;**	Low level routines for detecting special characters on CON input,
 32819                                  ;	the ^C exit/int code, the Hard error INT 24 code, the
 32820                                  ;	process termination code, and the INT 0 divide overflow handler.
 32821                                  ;
 32822                                  ;	FATAL
 32823                                  ;	FATAL1
 32824                                  ;	reset_environment
 32825                                  ;	DSKSTATCHK
 32826                                  ;	SPOOLINT
 32827                                  ;	STATCHK
 32828                                  ;	CNTCHAND
 32829                                  ;	DIVOV
 32830                                  ;	CHARHARD
 32831                                  ;	HardErr
 32832                                  ;
 32833                                  ;	Revision history:
 32834                                  ;
 32835                                  ;	    AN000	version 4.0   Jan 1988
 32836                                  ;	    A002	PTM    -- dir >lpt3 hangs
 32837                                  ;	    A003	PTM 3957- fake version for IBMCAHE.COM
 32838                                  ;
 32839                                  ; 	M011: NEC's 8086 clone chip uses Intel's undocumented bit number in
 32840                                  ;	      flags register. In order to return to user normally DOS used to
 32841                                  ;	      move F202 into flags, which sets bit number 1 in flags uncondit-
 32842                                  ;	      ionally. Now it is modified to maintain the state of bit 1.
 32843                                  ;
 32844                                  ; 	M024: suppressed fail and ignore options if not in the middle of int 
 32845                                  ;	      24 and if Ctrl P or ctrl printscrn is pressed in routine 
 32846                                  ;	      charhard.
 32847                                  
 32848                                  ; 29/04/2019 - Retro DOS v4.0
 32849                                  	; MSDOS 6.0
 32850                                  ;		public	LowInt23Addr		
 32851                                  LowInt23Addr: ;	LABEL	DWORD
 32852 00005A5C [3111]0000              	DW	LowInt23, 0
 32853                                  
 32854                                  ;		public	LowInt24Addr
 32855                                  LowInt24Addr: ;	LABEL	DWORD
 32856 00005A60 [4511]0000              	DW	LowInt24, 0
 32857                                  
 32858                                  ;		public	LowInt28Addr
 32859                                  LowInt28Addr: ;	LABEL	DWORD
 32860 00005A64 [5911]0000              	DW	LowInt28, 0
 32861                                  
 32862                                  ;Break	<Checks for ^C in CON I/O>
 32863                                  
 32864                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32865                                  ; 05/05/2019 - Retro DOS v4.0
 32866                                  
 32867                                  ;---------------------------------------------------------------------------
 32868                                  ;
 32869                                  ; Procedure Name : DSKSTATCHK
 32870                                  ;
 32871                                  ; Check for ^C if only one level in
 32872                                  ;
 32873                                  ;---------------------------------------------------------------------------
 32874                                  
 32875                                          ;procedure DSKSTATCHK,NEAR ; Check for ^C if only one level in
 32876                                  
 32877                                  DSKSTATCHK:        
 32878                                  	;CMP	BYTE [INDOS],1
 32879 00005A68 36803E[2103]01                  CMP     BYTE [SS:INDOS],1 ; 15/03/2018
 32880                                  	;retnz			; Do NOTHING
 32881                                  	; 16/12/2022
 32882 00005A6E 7534                    	JNZ	SHORT _RET37 ; Retro DOS v2.0 - 04/03/2018         
 32883                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 32884                                  	;jz	short _RET37 ; dskstatchk1
 32885                                  	;retn
 32886                                  ;_RET37:
 32887                                  ;dskstatchk1:
 32888 00005A70 51                      	PUSH    CX
 32889 00005A71 06                              PUSH    ES
 32890 00005A72 53                              PUSH    BX
 32891 00005A73 1E                              PUSH    DS
 32892 00005A74 56                              PUSH    SI
 32893                                          
 32894                                  	;PUSH	CS
 32895                                          ;POP	ES
 32896                                          ;PUSH	CS
 32897                                          ;POP	DS
 32898                                  
 32899 00005A75 8CD3                    	MOV	BX,SS		; SS is DOSDATA. ES:BX must be set up
 32900 00005A77 8EC3                    	MOV	ES,BX		; for deviocall2
 32901 00005A79 8EDB                    	MOV	DS,BX
 32902                                  
 32903                                  	; 16/12/2022
 32904                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 32905                                  
 32906                                  	; 05/05/2019
 32907                                  	;MOV	BYTE [ss:DSKSTCOM],DEVRDND
 32908                                          ;MOV	BYTE [ss:DSKSTCALL],DRDNDHL
 32909                                  	;mov	word [ss:DSKSTST],0
 32910                                  
 32911                                  	; 16/12/2022
 32912                                  	; 25/06/2019
 32913 00005A7B C606[9403]05            	MOV	BYTE [DSKSTCOM],DEVRDND	 ; 5
 32914 00005A80 C606[9203]0E                    MOV	BYTE [DSKSTCALL],DRDNDHL ; 14
 32915 00005A85 C706[9503]0000          	mov	word [DSKSTST],0
 32916                                  
 32917 00005A8B BB[9203]                        MOV     BX,DSKSTCALL
 32918                                  
 32919                                  	;LDS	SI,[ss:BCON]
 32920                                          ; 25/062019
 32921 00005A8E C536[3200]              	lds	si,[BCON]
 32922                                  
 32923                                  ; 16/12/2022
 32924                                  ;	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 32925                                  ;	mov	byte [ss:DSKSTCOM],DEVRDND  ; 5
 32926                                  ;       mov	byte [ss:DSKSTCALL],DRDNDHL ; 14
 32927                                  ;	mov	word [ss:DSKSTST],0
 32928                                  ;	mov	bx,DSKSTCALL
 32929                                  ;	lds	si,[ss:BCON]
 32930                                  
 32931 00005A92 E890F5                  	CALL	DEVIOCALL2
 32932                                   	; 15/03/2018
 32933                                  	;;test	word [ss:DSKSTST],200h
 32934                                          ;TEST	WORD [SS:DSKSTST],STBUI
 32935                                  	; 05/05/2019
 32936 00005A95 36F606[9603]02          	test	byte [ss:DSKSTST+1],(STBUI>>8) ; 2
 32937 00005A9B 7408                    	jz	short _GotCh		; No characters available
 32938                                  
 32939 00005A9D 30C0                            XOR     AL,AL                   ; Set zero
 32940                                  RET36:
 32941 00005A9F 5E                              POP     SI
 32942 00005AA0 1F                              POP     DS
 32943 00005AA1 5B                              POP     BX
 32944 00005AA2 07                              POP     ES
 32945 00005AA3 59                              POP     CX
 32946                                  	; 16/12/2022
 32947                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 32948                                  _RET37:
 32949 00005AA4 C3                              RETN
 32950                                  
 32951                                  _GotCh:
 32952 00005AA5 36A0[9F03]                      MOV     AL,[SS:DSKCHRET]	; SS override
 32953                                  
 32954 00005AA9 3C03                            CMP     AL,"C"-"@" ; cmp al,3
 32955 00005AAB 75F2                            JNZ     SHORT RET36
 32956 00005AAD 36C606[9403]04                  MOV     BYTE [SS:DSKSTCOM],DEVRD
 32957 00005AB3 36C606[9203]16                  MOV     BYTE [SS:DSKSTCALL],DRDWRHL
 32958 00005AB9 36880E[9F03]                    MOV     [SS:DSKCHRET],CL
 32959                                  	; 09/09/2018
 32960 00005ABE 36C706[9503]0000        	MOV	word [SS:DSKSTST],0
 32961 00005AC5 36C706[A403]0100        	MOV	word [SS:DSKSTCNT],1
 32962 00005ACC E856F5                  	CALL	DEVIOCALL2              ; Eat the ^C
 32963 00005ACF 5E                              POP     SI
 32964 00005AD0 1F                              POP     DS
 32965 00005AD1 5B                              POP     BX                      ; Clean stack
 32966 00005AD2 07                              POP     ES
 32967 00005AD3 59                              POP     CX
 32968 00005AD4 E9CF00                          JMP	CNTCHAND ; 10/08/2018
 32969                                  
 32970                                  	; 05/05/2019
 32971                                  NOSTOP:
 32972                                  	; MSDOS 6.0
 32973 00005AD7 3C10                    	CMP	AL,"P"-"@"
 32974 00005AD9 7509                    	JNZ	short check_next
 32975                                  				    	; SS override
 32976 00005ADB 36803E[E10D]00          	CMP	BYTE [SS:SCAN_FLAG],0	; ALT_Q ?
 32977 00005AE1 7405                    	JZ	short INCHKJ		; no
 32978                                  check_end:	; 24/09/2023
 32979 00005AE3 C3                      	retn
 32980                                  check_next:
 32981                                  	;IF	NOT TOGLPRN
 32982                                  	;CMP	AL,"N"-"@"
 32983                                  	;JZ	short INCHKJ
 32984                                  	;ENDIF
 32985                                  
 32986 00005AE4 3C03                    	CMP	AL,"C"-"@"
 32987                                  	; 24/09/2023
 32988                                  	;JZ	short INCHKJ
 32989                                  ;check_end:
 32990                                  	;retn
 32991 00005AE6 75FB                    	jnz	short check_end
 32992                                  
 32993                                  	; 24/09/2023
 32994                                  	; 08/09/2018
 32995                                  INCHKJ:	; 10/08/2018
 32996 00005AE8 E9A500                  	jmp	INCHK
 32997                                  
 32998                                  	; MSDOS 3.3
 32999                                          ;CMP     AL,"P"-"@"  ; cmp al,16
 33000                                          ;JZ	short INCHKJ
 33001                                  
 33002                                  	; 15/04/2018
 33003                                          ;;IF	NOT TOGLPRN
 33004                                          ;CMP	AL,"N"-"@"
 33005                                          ;JZ	SHORT INCHKJ
 33006                                          ;;ENDIF
 33007                                  	
 33008                                  	;CMP     AL,"C"-"@"  ; cmp al,3
 33009                                          ;JZ	short INCHKJ
 33010                                  	;RETN
 33011                                  
 33012                                  ;	; 08/09/2018
 33013                                  ;INCHKJ:; 10/08/2018
 33014                                  ;	JMP	INCHK
 33015                                  
 33016                                  ;----------------------------------------------------------------------------
 33017                                  ;
 33018                                  ; Procedure Name : SpoolInt
 33019                                  ;
 33020                                  ; SpoolInt - signal processes that the DOS is truly idle. We are allowed to
 33021                                  ; do this ONLY if we are working on a 1-12 system call AND if we are not in
 33022                                  ; the middle of an INT 24.
 33023                                  ;
 33024                                  ;----------------------------------------------------------------------------
 33025                                  
 33026                                  SPOOLINT:
 33027 00005AEB 9C                              PUSHF
 33028                                  	; 15/03/2018
 33029 00005AEC 36803E[5803]00                  CMP     BYTE [SS:IDLEINT],0	; SS override
 33030 00005AF2 7423                            JZ      SHORT POPFRET
 33031 00005AF4 36803E[2003]00                  CMP     BYTE [SS:ERRORMODE],0
 33032 00005AFA 751B                            JNZ     SHORT POPFRET		;No spool ints in error mode
 33033                                  
 33034                                  	; 30/07/2018
 33035                                  
 33036                                  	; Note that we are going to allow an external program to issue system 
 33037                                  	; calls at this time. We MUST preserve IdleInt across this.
 33038                                  
 33039 00005AFC 36FF36[5803]            	PUSH	WORD [SS:IDLEINT]
 33040                                  
 33041                                  	; 05/05/2019 - Retro DOS v4.0
 33042                                   
 33043                                  	; MSDOS 6.0
 33044 00005B01 36803E[870D]00          	cmp	byte [SS:DosHasHMA],0	; Q: is dos running in HMA (M021)
 33045 00005B07 7504                    	jne	short do_low_int28	; Y: the int must be done from low mem
 33046 00005B09 CD28                    	INT	int_spooler  ; int 28h 	; N: Execute user int 28 handler
 33047 00005B0B EB05                    	jmp	short spool_ret_addr
 33048                                  
 33049                                  do_low_int28:
 33050                                  	;call	far [ss:LowInt28Addr]
 33051 00005B0D 2EFF1E[645A]            	call	far [cs:LowInt28Addr]	; 05/05/2019
 33052                                  
 33053                                  spool_ret_addr:
 33054                                  	;INT	int_spooler		; INT 28h
 33055                                  
 33056 00005B12 368F06[5803]            	POP	WORD [SS:IDLEINT]
 33057                                  POPFRET:
 33058 00005B17 9D                              POPF
 33059                                  _RET18:  
 33060 00005B18 C3                      	RETN
 33061                                  
 33062                                  ; 05/05/2019 - Retro DOS v4.0
 33063                                  ; DOSCODE:9137h (MSDOS 6.21, MSDOS.SYS)
 33064                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33065                                  ; DOSCODE:90DBh (MSDOS 5.0, MSDOS.SYS)
 33066                                  
 33067                                  ;----------------------------------------------------------------------------
 33068                                  ;
 33069                                  ; Procedure Name : STATCHK
 33070                                  ;
 33071                                  ;----------------------------------------------------------------------------
 33072                                  
 33073                                  STATCHK:
 33074 00005B19 E84CFF                          CALL	DSKSTATCHK              ; Allows ^C to be detected under
 33075                                                                          ; input redirection
 33076 00005B1C 53                              PUSH    BX
 33077 00005B1D 31DB                            XOR     BX,BX
 33078 00005B1F E8A7E3                          CALL	GET_IO_SFT
 33079 00005B22 5B                              POP     BX
 33080 00005B23 72F3                            JC      SHORT _RET18
 33081                                  
 33082 00005B25 B401                            MOV     AH,1
 33083 00005B27 E826F3                          CALL	IOFUNC
 33084 00005B2A 74BF                            JZ      SHORT SPOOLINT
 33085 00005B2C 3C13                            CMP     AL,'S'-'@'
 33086 00005B2E 75A7                            JNZ     SHORT NOSTOP
 33087                                  
 33088                                  	; 05/05/2019
 33089                                  	; MSDOS 6.0			; SS override
 33090 00005B30 36803E[E10D]00          	CMP	BYTE [SS:SCAN_FLAG],0	; AN000; ALT_R ?
 33091 00005B36 75AB                    	JNZ	short check_end		; AN000; yes
 33092                                  
 33093 00005B38 30E4                            XOR     AH,AH
 33094 00005B3A E813F3                          CALL	IOFUNC                  ; Eat Cntrl-S
 33095 00005B3D EB4A                            JMP     SHORT PAUSOSTRT
 33096                                  PRINTOFF:
 33097                                  PRINTON:
 33098 00005B3F 36F616[FE02]            	NOT	BYTE [SS:PFLAG] ; 14/03/2018
 33099                                  
 33100                                  	; 30/07/2018 - Retro DOS v3.0
 33101 00005B44 53                      	PUSH	BX
 33102 00005B45 BB0400                  	MOV	BX,4
 33103 00005B48 E87EE3                  	call	GET_IO_SFT
 33104 00005B4B 5B                      	POP	BX
 33105 00005B4C 72CA                    	jc	short _RET18
 33106 00005B4E 06                      	PUSH	ES
 33107 00005B4F 57                      	PUSH	DI
 33108 00005B50 1E                      	PUSH	DS
 33109 00005B51 07                      	POP	ES
 33110 00005B52 89F7                    	MOV	DI,SI			; ES:DI -> SFT
 33111                                  	;test	word [es:di+5],800h
 33112                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_net_spool
 33113                                  	; 05/05/2019
 33114 00005B54 26F6450608              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8)
 33115 00005B59 7418                    	JZ	short NORM_PR 		; Not redirected, echo is OK
 33116                                  
 33117                                  	;Callinstall NetSpoolEchoCheck,MultNet,38,<AX>,<AX> 
 33118                                  					; See if allowed
 33119 00005B5B 50                      	push	ax
 33120 00005B5C B82611                  	mov	ax,1126h
 33121 00005B5F CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 33122                                  			; Return: CF set on error, AX = error code
 33123                                  			; STACK unchanged
 33124 00005B61 58                      	pop	ax
 33125                                  
 33126 00005B62 730F                    	JNC	short NORM_PR 		; Echo is OK
 33127                                  
 33128                                  					; SS override
 33129 00005B64 36C606[FE02]00          	MOV	BYTE [SS:PFLAG],0	; If not allowed, disable echo
 33130                                  
 33131                                  	;Callinstall NetSpoolClose,MultNet,36,<AX>,<AX> ; and close
 33132                                  
 33133 00005B6A 50                      	push    ax
 33134 00005B6B B82411                  	mov     ax,1124h
 33135 00005B6E CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 33136                                  			; ES:DI -> SFT, SS = DOS CS
 33137 00005B70 58                      	pop     ax
 33138                                  
 33139 00005B71 EB10                    	JMP	SHORT RETP6
 33140                                  NORM_PR:
 33141 00005B73 36803E[FE02]00          	CMP	BYTE [SS:PFLAG],0	; SS override
 33142 00005B79 7505                    	JNZ	short PRNOPN
 33143 00005B7B E82BF4                  	call	DEV_CLOSE_SFT
 33144 00005B7E EB03                    	JMP	SHORT RETP6
 33145                                  PRNOPN:
 33146 00005B80 E81EF4                  	call	DEV_OPEN_SFT
 33147                                  RETP6:
 33148 00005B83 5F                      	POP	DI
 33149 00005B84 07                      	POP	ES
 33150                                  STATCHK_RETN:
 33151 00005B85 C3                              RETN
 33152                                  PAUSOLP:
 33153 00005B86 E862FF                          CALL    SPOOLINT
 33154                                  PAUSOSTRT:
 33155 00005B89 B401                            MOV     AH,1
 33156 00005B8B E8C2F2                          CALL	IOFUNC
 33157 00005B8E 74F6                            JZ      SHORT PAUSOLP
 33158                                  INCHK:
 33159 00005B90 53                              PUSH    BX
 33160 00005B91 31DB                            XOR     BX,BX
 33161 00005B93 E833E3                          CALL	GET_IO_SFT
 33162 00005B96 5B                              POP     BX
 33163 00005B97 72EC                            JC      SHORT STATCHK_RETN ; 30/07/2018
 33164 00005B99 30E4                            XOR     AH,AH
 33165 00005B9B E8B2F2                          CALL	IOFUNC
 33166                                  	; 30/07/2018
 33167                                  	; MSDOS 3.3
 33168                                          ;CMP	AL,'P'-'@' ;cmp al,16
 33169                                          ;JNZ	SHORT NOPRINT
 33170                                  
 33171                                  	;cmp	byte [SS:SCAN_FLAG],0
 33172                                  	;JZ	SHORT PRINTON	
 33173                                  	;mov	byte [ss:SCAN_FLAG],0
 33174                                  
 33175                                  	; 05/05/2019
 33176                                  	; MSDOS 6.0
 33177 00005B9E 3C10                    	CMP	AL,"P"-"@"
 33178                                  	;;;;  7/14/86	ALT_Q key fix
 33179 00005BA0 749D                    	JZ	short PRINTON		; no! must be CTRL_P
 33180                                  ;NOPRINT:	
 33181                                  	;IF	NOT TOGLPRN
 33182                                  	;CMP	AL,"N"-"@"
 33183                                  	;JZ	short PRINTOFF
 33184                                  	;ENDIF
 33185 00005BA2 3C03                    	CMP	AL,"C"-"@" ; cmp al,3 
 33186                                  	;retnz
 33187 00005BA4 75DF                    	jnz	short STATCHK_RETN
 33188                                  
 33189                                  	; !! NOTE: FALL THROUGH !!
 33190                                  
 33191                                  ;---------------------------------------------------------------------------
 33192                                  ;
 33193                                  ; Procedure Name : CNTHAND ( CTRLC_C HANDLER )
 33194                                  ;
 33195                                  ; "^C" and CR/LF is printed. Then the user registers are restored and the
 33196                                  ; user CTRL-C handler is executed. At this point the top of the stack has 1)
 33197                                  ; the interrupt return address should the user CTRL-C handler wish to allow
 33198                                  ; processing to continue; 2) the original interrupt return address to the code
 33199                                  ; that performed the function call in the first place. If the user CTRL-C
 33200                                  ; handler wishes to continue, it must leave all registers unchanged and RET
 33201                                  ; (not IRET) with carry CLEAR. If carry is SET then an terminate system call
 33202                                  ; is simulated.
 33203                                  ;
 33204                                  ;---------------------------------------------------------------------------
 33205                                  
 33206                                  CNTCHAND:
 33207                                  	; MSDOS 6.0			; SS override
 33208                                  					; AN002; from RAWOUT
 33209                                  	;TEST	word [SS:DOS34_FLAG],CTRL_BREAK_FLAG  
 33210                                  	;JNZ	short around_deadlock 	; AN002;
 33211                                  
 33212                                  	; 05/05/2019 - Retro DOS v4.0
 33213                                  	; (MSDOS 6.21 MSDOS.SYS DOSCODE:91C4h, 29/12/2022)
 33214 00005BA6 36F606[1206]02          	TEST	byte [SS:DOS34_FLAG+1],(CTRL_BREAK_FLAG>>8)  ; 2 
 33215 00005BAC 7508                    	JNZ	short around_deadlock 	; AN002;
 33216                                  
 33217 00005BAE B003                            MOV     AL,3			; Display "^C"
 33218 00005BB0 E82EC1                          CALL	BUFOUT
 33219 00005BB3 E8C9BF                          CALL	CRLF
 33220                                  around_deadlock:
 33221 00005BB6 16                              PUSH    SS
 33222 00005BB7 1F                              POP     DS
 33223 00005BB8 803E[5703]00                    CMP     BYTE [CONSWAP],0
 33224 00005BBD 7403                            JZ      SHORT NOSWAP
 33225 00005BBF E871DF                          CALL	SWAPBACK
 33226                                  NOSWAP:
 33227 00005BC2 FA                      	CLI				; Prepare to play with stack
 33228 00005BC3 8E16[8605]              	MOV	SS,[USER_SS]		; User stack now restored
 33229 00005BC7 8B26[8405]              	MOV	SP,[USER_SP]
 33230 00005BCB E873A8                          CALL	restore_world       ; User registers now restored
 33231                                  
 33232                                  	; 30/07/2018 - Retro DOS v3.0 
 33233                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56ACh)
 33234                                          ; 14/03/2018 - Retro DOS v2.0
 33235                                  	;MOV	BYTE [CS:INDOS],0	
 33236                                          ;MOV	BYTE [CS:ERRORMODE],0
 33237                                          ;MOV	[CS:ConC_Spsave],SP
 33238                                  	;clc	;30/07/2018
 33239                                          ;INT	int_ctrl_c ; 23h    ; Execute user Ctrl-C handler
 33240                                  	;;int	23h	; DOS - CONTROL "C" EXIT ADDRESS
 33241                                  			; Return: return via RETF 2 with CF set
 33242                                  			; DOS will abort program with errorlevel 0
 33243                                  			; else
 33244                                  			; interrupted DOS call continues
 33245                                  
 33246                                  	; 05/05/2019 - Retro DOS v4.0
 33247                                  	; MSDOS 6.0 (MSDOS 6.21, MSDOS.SYS,91ECh) 
 33248                                  
 33249                                  	; CS was used to address these variables. We have to use DOSDATA
 33250                                  	
 33251 00005BCE 07                      	pop	es ; *	; MSDOS 6.21 (MSDOS.SYS, DOSCODE:91ECh)
 33252                                  			; (pop es, after 'call restore_world')	
 33253 00005BCF 1E                      	push	ds
 33254                                  	;getdseg <ds>			; ds -> dosdata
 33255 00005BD0 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 33256 00005BD5 C606[2103]00            	mov	byte [INDOS],0		; Go to known state
 33257 00005BDA C606[2003]00            	mov	byte [ERRORMODE],0
 33258 00005BDF 8926[3203]              	mov	[ConC_Spsave],SP	; save his SP
 33259                                  	; User SP has changed because of push. Adjust for it
 33260 00005BE3 8306[3203]02            	add	word [ConC_Spsave],2
 33261                                  
 33262 00005BE8 803E[870D]00            	cmp	byte [DosHasHMA],0	; Q: is dos running in HMA (M021)
 33263 00005BED 1F                       	pop	ds	; restore ds
 33264 00005BEE 7505                    	jne	short do_low_int23	; Y: the int must be done from low mem
 33265 00005BF0 F8                      	CLC				
 33266 00005BF1 CD23                    	INT	int_ctrl_c  ; int 23h	; N: Execute user Ctrl-C handler
 33267 00005BF3 EB06                    	jmp	short ctrlc_ret_addr
 33268                                  
 33269                                  	; 05/05/2019
 33270                                  do_low_int23:
 33271 00005BF5 F8                      	clc
 33272 00005BF6 2EFF1E[5C5A]            	call	far [cs:LowInt23Addr]	
 33273                                  
 33274                                  	; 30/07/2018 
 33275                                  
 33276                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56C0h)
 33277                                  
 33278                                  ; The user has returned to us. The circumstances we allow are:
 33279                                  ;
 33280                                  ;   IRET	We retry the operation by redispatching the system call
 33281                                  ;   CLC/RETF	POP the stack and retry
 33282                                  ;   ... 	Exit the current process with ^C exit
 33283                                  ;
 33284                                  ; User's may RETURN to us and leave interrupts on. 
 33285                                  ; Turn 'em off just to be sure
 33286                                  
 33287                                  ctrlc_ret_addr: ; 05/05/2019
 33288                                  
 33289 00005BFB FA                      	CLI
 33290                                  
 33291                                  	; MSDOS 3.3 
 33292                                  	;MOV	[CS:USER_IN_AX],ax	; save the AX
 33293                                  	;PUSHF				; and the flags (maybe new call)
 33294                                  	;POP	AX
 33295                                  
 33296                                  	; 05/05/2019
 33297                                  	; MSDOS 6.0
 33298                                  
 33299                                  	; We have to use DOSDATA for these variables. Previously CS was used 
 33300                                  
 33301 00005BFC 50                      	push	ax
 33302 00005BFD 8CD8                    	mov	ax,ds
 33303                                  	;getdseg <ds>			; ds -> dosdata
 33304 00005BFF 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 33305 00005C04 A3[840D]                	mov	[TEMPSEG],ax
 33306 00005C07 58                      	pop	ax
 33307 00005C08 A3[3A03]                	MOV	[USER_IN_AX],ax		; save the AX
 33308 00005C0B 9C                      	pushf				; and the flags (maybe new call)
 33309 00005C0C 58                      	pop	ax
 33310                                  
 33311                                  ; See if the input stack is identical to the output stack
 33312                                  
 33313                                  	; MSDOS 3.3
 33314                                  	;CMP	SP,[CS:ConC_Spsave]
 33315                                  	;JNZ     SHORT ctrlc_try_new ; current SP not the same as saved SP
 33316                                  
 33317                                  	; MSDOS 6.0
 33318 00005C0D 3B26[3203]              	CMP	SP,[ConC_Spsave]
 33319 00005C11 750A                    	JNZ     SHORT ctrlc_try_new ; current SP not the same as saved SP
 33320                                  
 33321                                  ; Repeat the operation by redispatching the system call.
 33322                                  
 33323                                  ctrlc_repeat:
 33324                                  	; MSDOS 3.3
 33325                                  	;MOV	AX,[CS:USER_IN_AX]
 33326                                  	; 05/05/2019
 33327                                  	; MSDOS 6.0
 33328 00005C13 A1[3A03]                	mov	ax,[USER_IN_AX]
 33329 00005C16 8E1E[840D]              	mov	ds,[TEMPSEG]		; restore ds and original sp
 33330                                  	; MSDOS 3.3 & MSDOS 6.0 
 33331                                  	;transfer COMMAND
 33332                                  COMMANDJ:
 33333 00005C1A E9D4A6                  	JMP	COMMAND
 33334                                  
 33335                                  ; The current SP is NOT the same as the input SP. Presume that he 
 33336                                  ; RETF'd leaving some flags on the stack and examine the input
 33337                                  
 33338                                  ctrlc_try_new:
 33339 00005C1D 83C402                  	ADD	SP,2			; pop those flags
 33340                                  	;;test	ax,1
 33341                                  	;TEST	AX,f_Carry		; did he return with carry?
 33342 00005C20 A801                    	test	al,f_Carry ; test al,1
 33343 00005C22 74EF                    	JZ	short ctrlc_repeat	; no carry set, just retry
 33344                                  
 33345                                  	; MSDOS 6.0
 33346 00005C24 8E1E[840D]              	mov	ds,[TEMPSEG]		; restore ds
 33347                                  
 33348                                  	; Well...  time to abort the user.  
 33349                                  	; Signal a ^C exit and use the EXIT system call..
 33350                                  
 33351                                  ctrlc_abort:
 33352                                  	; MSDOS 3.3
 33353                                          ;;MOV	AX,(EXIT SHL 8) + 0
 33354                                          ;MOV	AX, (EXIT*256) + 0  ; 4C00h
 33355                                  	;mov	byte [CS:DidCTRLC],0FFh ; 14/03/2018
 33356                                          ;transfer COMMAND	    ; give up by faking $EXIT
 33357                                  	;;JMP	SHORT COMMANDJ
 33358                                  	;JMP	COMMAND
 33359                                  
 33360                                  	; 05/05/2019 - Retro DOS v4.0
 33361                                  	; MSDOS 6.0
 33362 00005C28 B8004C                  	MOV	AX,(EXIT<<8)+0  ; 4C00h
 33363 00005C2B 1E                      	push	ds
 33364                                  	;getdseg <ds>			; ds -> dosdata
 33365 00005C2C 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]	
 33366 00005C31 C606[4D03]FF            	MOV	byte [DidCTRLC],-1 ; 0FFh
 33367 00005C36 1F                      	pop	ds
 33368                                  	;transfer COMMAND		; give up by faking $EXIT
 33369 00005C37 EBE1                    	JMP	SHORT COMMANDJ
 33370                                  	;JMP	COMMAND
 33371                                  
 33372                                  ;Break	<DIVISION OVERFLOW INTERRUPT>
 33373                                  ;----------------------------------------------------------------------------
 33374                                  ;
 33375                                  ; Procedure Name : DIVOV
 33376                                  ;
 33377                                  ; Default handler for division overflow trap
 33378                                  ;
 33379                                  ;----------------------------------------------------------------------------
 33380                                  
 33381                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33382                                  DIVOV: 
 33383                                  	; 05/05/2019 - Retro DOS v4.0
 33384                                  	; 30/07/2018
 33385                                  	; 07/07/2018 - Retro DOS v3.0
 33386 00005C39 BE[1D0A]                	mov	si,DIVMES
 33387 00005C3C 2E8B1E[300A]            	mov	bx,[cs:DivMesLen]
 33388                                  	;mov	ax,cs
 33389                                  	;mov	ss,ax
 33390                                  	; 05/05/2019
 33391                                  	;getdseg <ss>		; we are in an ISR, flag is CLI
 33392 00005C41 2E8E16[0700]            	mov	ss,[cs:DosDSeg]
 33393 00005C46 BC[A007]                	mov     sp,AUXSTACK
 33394                                  	;call	RealDivOv ; MSDOS 3.3
 33395 00005C49 E80200                  	call	_OUTMES ; MSDOS 6.0
 33396 00005C4C EBDA                    	jmp	short ctrlc_abort  ; Use Ctrl-C abort on divide overflow
 33397                                  
 33398                                  ; 30/07/2018
 33399                                  
 33400                                  ; MSDOS 6.0
 33401                                  ;---------------------------------------------------------------------------
 33402                                  ;
 33403                                  ; Procedure Name : OutMes
 33404                                  ;
 33405                                  ;
 33406                                  ; OutMes: perform message output
 33407                                  ; Inputs:   SS:SI points to message
 33408                                  ;	    BX has message length
 33409                                  ; Outputs:  message to BCON
 33410                                  ;
 33411                                  ;Actually, cs:si points to the message now. The segment address is filled in
 33412                                  ;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
 33413                                  ;NB. This procedure is called only from DIVOV. -SR
 33414                                  ;
 33415                                  ;---------------------------------------------------------------------------
 33416                                  
 33417                                  ;MSDOS 3.3
 33418                                  ;---------------------------------------------------------------------------
 33419                                  ; RealDivOv: perform actual divide overflow stuff.
 33420                                  ; Inputs:   none
 33421                                  ; Outputs:  message to BCON
 33422                                  ;---------------------------------------------------------------------------
 33423                                  
 33424                                  	; 05/05/2019 - Retro DOS v4.0
 33425                                  	; DOSCODE:926Ch (MSDOS 6.21, MSDOS.SYS)
 33426                                  
 33427                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33428                                  	; DOSCODE:9210h (MSDOS 5.0, MSDOS.SYS)
 33429                                  
 33430                                  ;---------------------------------------------------------------------------
 33431                                  ;
 33432                                  ; Procedure Name : OutMes
 33433                                  ;
 33434                                  ; OutMes: perform message output
 33435                                  ; Inputs:   SS:SI points to message
 33436                                  ;	    BX has message length
 33437                                  ; Outputs:  message to BCON
 33438                                  ;
 33439                                  ;Actually, cs:si points to the message now. The segment address is filled in
 33440                                  ;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
 33441                                  ;NB. This procedure is called only from DIVOV. -SR
 33442                                  ;
 33443                                  ;---------------------------------------------------------------------------
 33444                                  
 33445                                  	; 30/07/2018
 33446                                  	; MSDOS 6.0
 33447                                  _OUTMES:
 33448                                  	; MSDOS 3.3
 33449                                  ;RealDivOv:
 33450                                  	; 07/07/2018 - Retro DOS v3.0
 33451                                          ;Context ES
 33452 00005C4E 16                      	push	ss ; 05/05/2019
 33453                                  	;PUSH	CS ; 30/07/2018		; get ES addressability
 33454 00005C4F 07                      	POP	ES
 33455                                          ;Context DS
 33456 00005C50 16                      	push	ss ; 05/05/2019	
 33457                                  	;PUSH	CS ; 30/07/2018		; get DS addressability
 33458 00005C51 1F                      	POP	DS
 33459 00005C52 C606[9403]08                    MOV     BYTE [DSKSTCOM],DEVWRT
 33460 00005C57 C606[9203]16                    MOV     BYTE [DSKSTCALL],DRDWRHL
 33461 00005C5C C706[9503]0000                  MOV     WORD [DSKSTST],0
 33462                                  	; BX = [DivMesLen] = 19
 33463 00005C62 891E[A403]                      MOV     [DSKSTCNT],BX
 33464 00005C66 BB[9203]                        MOV     BX,DSKSTCALL
 33465 00005C69 8936[A003]                      MOV     [DSKCHRET+1],SI		; transfer address (need an EQU)
 33466                                  	; 08/09/2018
 33467                                  	;mov	[DEVIOBUF_PTR],si
 33468                                  	; MSDOS 6.0
 33469                                  					; CS is used for string, fill in 
 33470                                  					; segment address 
 33471 00005C6D 8C0E[A203]              	MOV	[DSKCHRET+3],CS
 33472                                  
 33473 00005C71 C536[3200]                      LDS     SI,[BCON]
 33474 00005C75 E8ADF3                          CALL	DEVIOCALL2
 33475                                  
 33476                                  	;; 14/03/2018
 33477                                          ;;MOV	WORD [CS:DSKCHRET+1],DEVIOBUF
 33478                                  	;; 08/09/2018
 33479                                  	;mov	word [CS:DEVIOBUF_PTR],DEVIOBUF
 33480                                          ;MOV	WORD [CS:DSKSTCNT],1
 33481                                          
 33482                                  	; 05/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 33483                                  
 33484                                  	; ES still points to DOSDATA. ES is
 33485                                  					; not destroyed by deviocall2. So use
 33486                                  					; ES override.
 33487                                  
 33488 00005C78 26C706[A003][BC03]      	MOV	WORD [ES:DSKCHRET+1],DEVIOBUF
 33489 00005C7F 26C706[A403]0100        	MOV	WORD [ES:DSKSTCNT],1
 33490                                  
 33491 00005C86 C3                      	RETN
 33492                                  
 33493                                  ;Break	<CHARHRD,HARDERR,ERROR -- HANDLE DISK ERRORS AND RETURN TO USER>
 33494                                  ;---------------------------------------------------------------------------
 33495                                  ;
 33496                                  ; Procedure Name : CHARHARD
 33497                                  ;
 33498                                  ;
 33499                                  ; Character device error handler
 33500                                  ; Same function as HARDERR
 33501                                  ;
 33502                                  ;---------------------------------------------------------------------------
 33503                                  
 33504                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33505                                  CHARHARD:
 33506                                  	; 05/05/2019 - Retro DOS v4.0
 33507                                  	; 30/07/2018
 33508                                  	; 08/07/2018 - Retro DOS v3.0
 33509                                  
 33510                                  	; MSDOS 6.0
 33511                                  		   			; M024 - start
 33512 00005C87 36803E[2003]00          	cmp	byte [SS:ERRORMODE], 0	; Q: are we in the middle of int 24
 33513                                  	;jne	short @f		; Y: allow fail
 33514 00005C8D 750B                    	jne	short chard1
 33515                                  
 33516 00005C8F 80CC10                  	OR	AH,Allowed_RETRY ; 10h	; assume ctrl p
 33517                                  
 33518 00005C92 36F606[FE02]FF          	test	byte [ss:PFLAG],-1	; Q: has ctrl p been pressed
 33519 00005C98 7503                    	jnz	short ctrlp		; Y: 
 33520                                  ;@@:
 33521                                  chard1:					; M024 - end
 33522                                  	; MSDOS 6.0 & MSDOS 3.3
 33523                                  
 33524                                  ; Character device error handler
 33525                                  ; Same function as HARDERR
 33526                                  
 33527                                  	;or	ah,38h
 33528 00005C9A 80CC38                  	or	ah,Allowed_IGNORE+Allowed_RETRY+Allowed_FAIL
 33529                                  ctrlp:			; SS override for Allowed and EXITHOLD
 33530 00005C9D 368826[4B03]            	mov	[SS:ALLOWED],ah
 33531                                  
 33532                                  	; 15/03/2018
 33533 00005CA2 368C06[8205]                    MOV     [SS:EXITHOLD+2],ES
 33534 00005CA7 36892E[8005]                    MOV     [SS:EXITHOLD],BP
 33535 00005CAC 56                              PUSH    SI
 33536                                  	;and	di,0FFh
 33537 00005CAD 81E7FF00                        AND     DI,STECODE
 33538 00005CB1 8CDD                            MOV     BP,DS                   ;Device pointer is BP:SI
 33539 00005CB3 E86400                          CALL    FATALC
 33540 00005CB6 5E                              POP     SI
 33541                                  	;return
 33542 00005CB7 C3                              RETN
 33543                                  
 33544                                  ;---------------------------------------------------------------------------
 33545                                  ;
 33546                                  ; Procedure Name : HardErr
 33547                                  ;
 33548                                  ; Hard disk error handler. Entry conditions:
 33549                                  ;	DS:BX = Original disk transfer address
 33550                                  ;	DX = Original logical sector number
 33551                                  ;	CX = Number of sectors to go (first one gave the error)
 33552                                  ;	AX = Hardware error code
 33553                                  ;	DI = Original sector transfer count	
 33554                                  ;	ES:BP = Base of drive parameters
 33555                                  ;	[READOP] = 0 for read, 1 for write
 33556                                  ;	Allowed Set with allowed responses to this error (other bits MUST BE 0)
 33557                                  ; Output:
 33558                                  ;	[FAILERR] will be set if user responded FAIL
 33559                                  ;
 33560                                  ;--------------------------------------------------------------------------
 33561                                  
 33562                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33563                                  HARDERR:
 33564                                  	; 05/05/2019 - Retro DOS v4.0
 33565                                  	; 30/07/2018
 33566                                  	; 08/07/2018 - Retro DOS v3.0
 33567 00005CB8 97                      	XCHG    AX,DI                   ; Error code in DI, count in AX
 33568                                          ;and	di,0FFh
 33569 00005CB9 81E7FF00                	AND     DI,STECODE              ; And off status bits
 33570                                          ;CMP	DI,WRECODE		; Write Protect Error?
 33571                                  	;cmp	di,0
 33572 00005CBD 83FF00                  	cmp	DI,error_I24_write_protect ; Write Protect Error?
 33573 00005CC0 750A                            JNZ     short NOSETWRPERR
 33574 00005CC2 50                              PUSH    AX
 33575                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 33576                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 33577                                          ;;MOV	AL,[ES:BP+0]
 33578                                  	; 15/12/2022
 33579 00005CC3 268A4600                	mov	al,[ES:BP]
 33580                                          	; 15/03/2018
 33581 00005CC7 36A2[2203]                      MOV     [SS:WPERR],AL		; Flag drive with WP error
 33582 00005CCB 58                              POP     AX
 33583                                  NOSETWRPERR:
 33584 00005CCC 29C8                            SUB     AX,CX                   ; Number of sectors successfully transferred
 33585 00005CCE 01C2                            ADD     DX,AX                   ; First sector number to retry
 33586 00005CD0 52                              PUSH    DX
 33587                                  	; 08/07/2018
 33588                                          ;MUL	word [ES:BP+2] 		; Number of bytes transferred
 33589 00005CD1 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]
 33590 00005CD5 5A                              POP     DX
 33591 00005CD6 01C3                            ADD     BX,AX                   ; First address for retry
 33592 00005CD8 30E4                            XOR     AH,AH                   ; Flag disk section in error
 33593                                          ;CMP	DX,[ES:BP+6] 		; In reserved area?
 33594 00005CDA 263B5606                	CMP	DX,[ES:BP+DPB.FIRST_FAT]
 33595 00005CDE 721A                            JB      SHORT ERRINT
 33596 00005CE0 FEC4                            INC     AH                      ; Flag for FAT
 33597                                          ;CMP	DX,[ES:BP+10H] ; MSDOS 3.3
 33598                                  	;cmp	dx,[ES:BP+11h] ; MSDOS 6.0 - 05/05/2019 	
 33599 00005CE2 263B5611                	CMP	DX,[ES:BP+DPB.DIR_SECTOR]  ; In FAT?  
 33600 00005CE6 7308                    	JAE	short TESTDIR 		; No
 33601                                  		 ; Err in FAT must force recomp of freespace
 33602                                  	;mov	word [ES:BP+1Eh],-1 ; MSDOS 3.3
 33603                                  	;mov	word [ES:BP+1Fh],-1 ; MSDOS 6.0 - 05/05/2019 
 33604 00005CE8 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1
 33605 00005CEE EB0A                    	JMP	SHORT ERRINT
 33606                                  TESTDIR:
 33607 00005CF0 FEC4                            INC     AH
 33608                                          ;CMP	DX,[ES:BP+0BH]		; In directory?
 33609 00005CF2 263B560B                	CMP	DX,[ES:BP+DPB.FIRST_SECTOR] 
 33610 00005CF6 7202                            JB      SHORT ERRINT
 33611 00005CF8 FEC4                            INC     AH                      ; Must be in data area
 33612                                  ERRINT:
 33613 00005CFA D0E4                            SHL     AH,1                    ; Make room for read/write bit
 33614 00005CFC 360A26[7505]                    OR      AH,[SS:READOP] ; 15/03/2018
 33615                                  
 33616                                  	; 15/08/2018
 33617                                  					; SS override for allowed and EXITHOLD
 33618 00005D01 360A26[4B03]            	OR	AH,[SS:ALLOWED]		; Set the allowed_ bits
 33619                                  
 33620                                          ;entry   FATAL
 33621                                  FATAL:
 33622                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 33623                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 33624                                          ;;MOV	AL,[ES:BP+0]		; Get drive number
 33625                                  	; 15/12/2022
 33626 00005D06 268A4600                	MOV	AL,[ES:BP]        
 33627                                  
 33628                                  	;entry   FATAL1
 33629                                  FATAL1:  
 33630                                  	; 15/03/2018      
 33631 00005D0A 368C06[8205]            	MOV     [SS:EXITHOLD+2],ES
 33632 00005D0F 36892E[8005]                    MOV     [SS:EXITHOLD],BP	; The only things we preserve	
 33633                                  	;LES	SI,[ES:BP+12H] ; MSDOS 3.3
 33634                                  	;LES	SI,[ES:BP+13H] ; MSDOS 6.0 - 05/05/2019
 33635 00005D14 26C47613                	LES	SI,[ES:BP+DPB.DRIVER_ADDR]
 33636 00005D18 8CC5                            MOV     BP,ES                   ; BP:SI points to the device involved
 33637                                  
 33638                                  	; DI has the INT-24-style extended error. We now map the error code 
 33639                                  	; for this into the normalized get extended error set by using the 
 33640                                  	; ErrMap24 table as a translate table. Note that we translate ONLY 
 33641                                  	; the device returned codes and leave all others beyond the look up 
 33642                                  	; table alone.
 33643                                  
 33644                                  	; 08/07/2018 - Retro DOS v3.0
 33645                                  FATALC:
 33646 00005D1A E89701                  	call	SET_I24_EXTENDED_ERROR
 33647                                  	;cmp	di,0Ch
 33648 00005D1D 83FF0C                  	CMP	DI,error_I24_gen_failure
 33649 00005D20 7603                    	JBE	short GOT_RIGHT_CODE	; Error codes above gen_failure get
 33650 00005D22 BF0C00                  	MOV	DI,error_I24_gen_failure; mapped to gen_failure. Real codes
 33651                                  					;  Only come via GetExtendedError
 33652                                  ;** ----------------------------------------------------------------
 33653                                  ;
 33654                                  ; Entry point used by REDIRector on Network I 24 errors.
 33655                                  ;
 33656                                  ;	ASSUME	DS:NOTHING,ES:NOTHING,SS:DOSDATA
 33657                                  ;
 33658                                  ; ALL I 24 regs set up. ALL Extended error info SET. ALLOWED Set.
 33659                                  ;     EXITHOLD set for restore of ES:BP.
 33660                                  ; ------------------------------------------------------------------
 33661                                  	;entry	NET_I24_ENTRY
 33662                                  NET_I24_ENTRY:
 33663                                  GOT_RIGHT_CODE:
 33664 00005D25 36803E[2003]00          	CMP     BYTE [SS:ERRORMODE],0	; No INT 24s if already INT 24
 33665 00005D2B 7404                            JZ	SHORT NoSetFail
 33666 00005D2D B003                    	MOV	AL,3
 33667 00005D2F EB6C                    	JMP	short FailRet
 33668                                  NoSetFail:
 33669 00005D31 368926[8805]                    MOV     [SS:CONTSTK],SP		; SS override
 33670 00005D36 16                              PUSH	SS
 33671 00005D37 07                              POP	ES
 33672                                      
 33673                                  	; Wango!!! We may need to free some user state info... In 
 33674                                  	; particular, we may have locked down a JFN for a user and he may 
 33675                                  	; NEVER return to us. Thus,we need to free it here and then 
 33676                                  	; reallocate it when we come back.
 33677                                  
 33678 00005D38 36833E[AA05]FF          	CMP	word [SS:SFN],-1 ; 0FFFFh
 33679 00005D3E 740C                    	JZ	short _NoFree
 33680 00005D40 1E                      	push	ds
 33681 00005D41 56                      	push	si
 33682 00005D42 36C536[AE05]            	LDS	SI,[SS:PJFN]
 33683 00005D47 C604FF                  	MOV	BYTE [SI],0FFH
 33684 00005D4A 5E                      	pop	si
 33685 00005D4B 1F                      	pop	ds
 33686                                  
 33687                                  _NoFree:
 33688 00005D4C FA                      	CLI
 33689                                  					; Prepare to play with stack
 33690 00005D4D 36FE06[2003]                    INC     BYTE [SS:ERRORMODE]	; Flag INT 24 in progress
 33691 00005D52 36FE0E[2103]                    DEC     BYTE [SS:INDOS]		; INT 24 handler might not return
 33692                                  
 33693                                  	; 05/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 33694                                  
 33695                                  	;; Extended Open hooks
 33696                                  					; AN000;IFS.I24 error disabled
 33697                                  	;test	byte [ss:EXTOPEN_ON],2
 33698 00005D57 36F606[F605]02          	TEST	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF 
 33699 00005D5D 7404                    	JZ	short i24yes		; AN000;IFS.no
 33700                                  faili24:				; AN000;
 33701 00005D5F B003                    	MOV	AL,3			; AN000;IFS.fake fail
 33702 00005D61 EB29                    	JMP	short passi24 		; AN000;IFS.exit
 33703                                  i24yes: 				; AN000;
 33704                                  	;; Extended Open hooks
 33705                                  
 33706 00005D63 368E16[8605]                    MOV     SS,[SS:USER_SS]
 33707 00005D68 268B26[8405]                    MOV     SP,[ES:USER_SP]         ; User stack pointer restored
 33708                                  
 33709                                  	;;int	24h	
 33710                                          ;IN	int_fatal_abort		; Fatal error interrupt vector,
 33711                                  					; must preserve ES
 33712                                  	; 05/05/2019
 33713 00005D6D 26803E[870D]00          	cmp	byte [es:DosHasHMA], 0	; Q: is dos running in HMA (M021)
 33714 00005D73 7504                    	jne	short do_low_int24	; Y: the int must be done from low mem
 33715 00005D75 CD24                    	INT	int_fatal_abort 	; Fatal error interrupt vector, 
 33716                                  					; must preserve ES
 33717 00005D77 EB05                    	jmp	short criterr_ret_addr
 33718                                  
 33719                                  do_low_int24:
 33720                                  	; 05/05/2019
 33721                                  	; MSDOS 6.0
 33722 00005D79 2EFF1E[605A]            	call    far [cs:LowInt24Addr]
 33723                                  criterr_ret_addr:
 33724 00005D7E 268926[8405]                    MOV     [ES:USER_SP],SP         ; restore our stack
 33725 00005D83 268C16[8605]                    MOV     [ES:USER_SS],SS
 33726 00005D88 8CC5                            MOV     BP,ES
 33727 00005D8A 8ED5                            MOV     SS,BP
 33728                                  passi24:
 33729 00005D8C 368B26[8805]                    MOV     SP,[SS:CONTSTK]
 33730 00005D91 36FE06[2103]                    INC     BYTE [SS:INDOS]		; Back in the DOS
 33731 00005D96 36C606[2003]00                  MOV     BYTE [SS:ERRORMODE],0	; Back from INT 24
 33732 00005D9C FB                              STI
 33733                                  FailRet:
 33734 00005D9D 36C42E[8005]                    LES     BP,[SS:EXITHOLD]
 33735                                  	
 33736                                  	; 08/07/2018
 33737                                  
 33738                                  	; Triage the user's reply.
 33739                                  
 33740 00005DA2 3C01                    	CMP	AL,1
 33741 00005DA4 723D                    	JB	short CheckIgnore	; 0 => ignore
 33742 00005DA6 7445                    	JZ	short CheckRetry	; 1 => retry
 33743 00005DA8 3C03                    	CMP	AL,3			; 3 => fail
 33744 00005DAA 754B                    	JNZ	short DoAbort 		; 2, invalid => abort
 33745                                  
 33746                                  	; The reply was fail. See if we are allowed to fail.
 33747                                  
 33748                                  				; SS override for ALLOWED, EXTOPEN_ON, 
 33749                                  				; ALLOWED, FAILERR, WPERR, SFN, pJFN
 33750                                  	;test	byte [ss:ALLOWED],8
 33751 00005DAC 36F606[4B03]08          	test	byte [ss:ALLOWED],Allowed_FAIL ; Can we?
 33752 00005DB2 7443                    	jz	short DoAbort	; No, do abort
 33753                                  DoFail:
 33754 00005DB4 B003                    	MOV	AL,3		; just in case...
 33755                                  				; AN000;EO. I24 error disabled
 33756                                  	; 05/05/2019
 33757                                  	;(MSDOS 6.0, MSCTRLC.ASM, 1991)
 33758 00005DB6 36F606[F605]02          	test	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF ; 2
 33759 00005DBC 7505                    	jnz	short CleanUp 		; AN000;EO. no
 33760                                  	
 33761 00005DBE 36FE06[4A03]            	inc	byte [SS:FAILERR]	; Tell everybody
 33762                                  CleanUp:
 33763 00005DC3 36C606[2203]FF          	MOV	byte [SS:WPERR],-1
 33764 00005DC9 36833E[AA05]FF          	CMP	word [SS:SFN],-1
 33765                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 33766                                  	;jnz	short CleanUp2
 33767                                  	;retn
 33768                                  	; 17/12/2022
 33769 00005DCF 7411                    	jz	short Cleanup_retn ; 08/07/2018 - Retro DOS v3.0
 33770                                  CleanUp2:
 33771 00005DD1 1E                      	push	ds
 33772 00005DD2 56                      	push	si
 33773 00005DD3 50                      	push	ax
 33774 00005DD4 36A1[AA05]              	MOV	AX,[ss:SFN]
 33775 00005DD8 36C536[AE05]            	LDS	SI,[ss:PJFN]
 33776 00005DDD 8804                    	MOV	[SI],AL
 33777 00005DDF 58                      	pop	ax
 33778 00005DE0 5E                      	pop	si
 33779 00005DE1 1F                      	pop	ds
 33780                                  Cleanup_retn:
 33781 00005DE2 C3                      	retn
 33782                                  
 33783                                  	; The reply was IGNORE. See if we are allowed to ignore.
 33784                                  
 33785                                  CheckIgnore:
 33786                                  	;test	byte [ss:ALLOWED],20h
 33787 00005DE3 36F606[4B03]20          	test	byte [ss:ALLOWED],Allowed_IGNORE ; Can we?
 33788 00005DE9 74C9                    	jz	short DoFail			 ; No, do fail
 33789 00005DEB EBD6                    	jmp	short CleanUp
 33790                                  
 33791                                  	; The reply was RETRY. See if we are allowed to retry.
 33792                                  
 33793                                  CheckRetry:
 33794                                  	;test	byte [ss:ALLOWED],10h
 33795 00005DED 36F606[4B03]10          	test	byte [ss:ALLOWED],Allowed_RETRY	; Can we?
 33796 00005DF3 74BF                    	jz	short DoFail			; No, do fail
 33797 00005DF5 EBCC                    	JMP	short CleanUp
 33798                                  
 33799                                  	; The reply was ABORT.
 33800                                  DoAbort:
 33801 00005DF7 16                      	push	ss
 33802 00005DF8 1F                      	pop	ds
 33803                                  
 33804 00005DF9 803E[5703]00            	CMP	byte [CONSWAP],0
 33805 00005DFE 7403                    	JZ	short NOSWAP2
 33806 00005E00 E830DD                  	call	SWAPBACK
 33807                                  NOSWAP2:
 33808                                  	; See if we are to truly abort. If we are in the process of aborting, 
 33809                                  	; turn this abort into a fail.
 33810                                  
 33811                                  	;test	[fAborting],0FFh
 33812                                  	;jnz	short DoFail
 33813                                  
 33814 00005E03 803E[5903]00            	cmp	byte [fAborting],0
 33815 00005E08 75AA                    	JNZ	short DoFail
 33816                                  
 33817                                  	; Set return code
 33818                                  
 33819 00005E0A C606[7C05]02            	MOV	BYTE [EXIT_TYPE],EXIT_HARD_ERROR ; 2
 33820 00005E0F 30C0                    	XOR	AL,AL
 33821                                  
 33822                                  	; we are truly aborting the process. Go restore information from 
 33823                                  	; the PDB as necessary.
 33824                                  
 33825 00005E11 E9BF0D                  	jmp	exit_inner
 33826                                  
 33827                                  ;** --------------------------------------------------------------------------
 33828                                  ;
 33829                                  ; reset_environment checks the DS value against the CurrentPDB. If they are
 33830                                  ; different, then an old-style return is performed. If they are the same,
 33831                                  ; then we release jfns and restore to parent. We still use the PDB at DS:0 as
 33832                                  ; the source of the terminate addresses.
 33833                                  ;
 33834                                  ; Some subtlety: We are about to issue a bunch of calls that *may* generate
 33835                                  ; INT 24s. We *cannot* allow the user to restart the abort process; we may
 33836                                  ; end up aborting the wrong process or turn a terminate/stay/resident into a
 33837                                  ; normal abort and leave interrupt handlers around. What we do is to set a
 33838                                  ; flag that will indicate that if any abort code is seen, we just continue the
 33839                                  ; operation. In essence, we dis-allow the abort response.
 33840                                  ;
 33841                                  ; output:   none.
 33842                                  ; ----------------------------------------------------------------------------
 33843                                  
 33844                                  	;entry	reset_environment
 33845                                  	
 33846                                  reset_environment:
 33847                                  	; 30/07/2018 - Retro DOS v3.0
 33848                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 588Ah 
 33849                                  
 33850                                  ;***	invoke	Reset_Version		; AN007 ;MS. reset version number
 33851                                  
 33852 00005E14 1E                      	PUSH	DS			; save PDB of process
 33853                                  
 33854                                  	; There are no critical sections in force. Although we may enter 
 33855                                  	; here with critical sections locked down, they are no longer 
 33856                                  	; relevant. We may safely free all allocated resources.
 33857                                  
 33858 00005E15 B482                    	MOV	AH,82h
 33859                                  		; Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7
 33860                                  	;int	2Ah 	
 33861 00005E17 CD2A                    	INT	int_IBM
 33862                                  
 33863                                  					; SS override
 33864 00005E19 36C606[5903]FF          	MOV	byte [SS:fAborting],-1	; signal abort in progress
 33865                                  
 33866                                  					; DOS 4.00 doesn't need it
 33867                                  	;CallInstall NetResetEnvironment, MultNET, 34  
 33868                                  					; Allow REDIR to clear some stuff
 33869                                  					; On process exit.
 33870 00005E1F B82211                  	mov     ax, 1122h
 33871 00005E22 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
 33872                                  			; SS = DOS CS
 33873                                  	;mov	al,22h	
 33874 00005E24 B022                    	MOV	AL,int_terminate
 33875 00005E26 E858B1                  	call	_$GET_INTERRUPT_VECTOR	; and who to go to
 33876                                  
 33877 00005E29 59                      	POP	CX			; get ThisPDB
 33878 00005E2A 06                      	push	es
 33879 00005E2B 53                      	push	bx			; save return address
 33880                                  
 33881 00005E2C 368B1E[3003]            	MOV	BX,[SS:CurrentPDB] 	; get currentPDB
 33882 00005E31 8EDB                    	MOV	DS,BX
 33883 00005E33 A11600                  	MOV	AX,[PDB.PARENT_PID]	; get parentPDB
 33884                                  
 33885                                  	; AX = parentPDB, BX = CurrentPDB, CX = ThisPDB
 33886                                  	; Only free handles if AX <> BX and BX = CX and [exit_code].upper 
 33887                                  	; is not Exit_keep_process
 33888                                  	
 33889 00005E36 39D8                    	CMP	AX,BX
 33890 00005E38 7418                    	JZ	short reset_return	; parentPDB = CurrentPDB
 33891 00005E3A 39CB                    	CMP	BX,CX
 33892 00005E3C 7514                    	JNZ	short reset_return	; CurrentPDB <> ThisPDB
 33893 00005E3E 50                      	PUSH	AX			; save parent
 33894                                  
 33895                                  					; SS override
 33896                                  	;cmp	byte [SS:EXIT_TYPE],3
 33897 00005E3F 36803E[7C05]03          	CMP	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS ; 15/08/2018
 33898 00005E45 7406                    	JZ	short reset_to_parent 	; keeping this process
 33899                                  
 33900                                  	; We are truly removing a process. Free all allocation blocks 
 33901                                  	; belonging to this PDB
 33902                                  
 33903                                  	;invoke	arena_free_process
 33904 00005E47 E8C10D                  	call	arena_free_process
 33905                                  
 33906                                  	; Kill off remainder of this process. Close file handles and signal 
 33907                                  	; to relevant network folks that this process is dead. Remember that 
 33908                                  	; CurrentPDB is STILL the current process!
 33909                                  
 33910                                  	;invoke	DOS_ABORT
 33911 00005E4A E889D8                  	call	DOS_ABORT
 33912                                  
 33913                                  reset_to_parent:
 33914                                  					; SS override
 33915 00005E4D 368F06[3003]            	POP	word [SS:CurrentPDB]	; set up process as parent
 33916                                  
 33917                                  reset_return:				; come here for normal return
 33918                                  	;Context DS			; DS is used to refer to DOSDATA  
 33919 00005E52 16                      	push	ss
 33920 00005E53 1F                      	pop	ds	
 33921                                  
 33922 00005E54 B0FF                    	MOV	AL,-1
 33923                                  
 33924                                  	; make sure that everything is clean In this case ignore any errors, 
 33925                                  	; we cannot "FAIL" the abort, the program being aborted is dead.
 33926                                  
 33927                                  	;EnterCrit critDisk
 33928 00005E56 E8AABA                  	call	ECritDisk
 33929                                  	;invoke	FLUSHBUF
 33930 00005E59 E8D305                  	call	FLUSHBUF
 33931                                  	;LeaveCrit critDisk
 33932 00005E5C E8D1BA                  	call	LCritDisk
 33933                                  
 33934                                  	; Decrement open ref. count if we had done a virtual open earlier.
 33935                                  
 33936 00005E5F E883F7                  	call	CHECK_VIRT_OPEN
 33937 00005E62 FA                      	CLI
 33938 00005E63 C606[2103]00            	MOV	BYTE [INDOS],0		; Go to known state
 33939 00005E68 C606[2203]FF            	MOV	BYTE [WPERR],-1		; Forget about WP error
 33940 00005E6D C606[5903]00            	MOV	byte [fAborting],0	; let aborts occur
 33941 00005E72 8F06[8005]              	POP	WORD [EXITHOLD]
 33942 00005E76 8F06[8205]              	POP	WORD [EXITHOLD+2]
 33943                                  
 33944                                  	; Snake into multitasking... Get stack from CurrentPDB person
 33945                                  
 33946 00005E7A 8E1E[3003]              	MOV	DS,[CurrentPDB]
 33947 00005E7E 8E163000                	MOV	SS,[PDB.USER_STACK+2]
 33948 00005E82 8B262E00                	MOV	SP,[PDB.USER_STACK]
 33949                                  
 33950 00005E86 E8B8A5                  	call	restore_world
 33951                                  
 33952                                  	; 05/05/2019
 33953 00005E89 07                      	pop	es ; * ; MSDOS 6.21 (DOSCODE:94A8h, MSDOS.SYS)
 33954                                  
 33955                                  	; MSDOS 6.0
 33956 00005E8A 50                      	push	ax			; set up ds, but save ds in TEMPSEG 
 33957 00005E8B 8CD8                    	mov	ax,ds			; and not on stack.
 33958                                  	;getdseg <ds>			; ds -> dosdata
 33959 00005E8D 2E8E1E[0700]            	mov	ds,[cs:DosDSeg] 
 33960 00005E92 A3[840D]                	mov	[TEMPSEG],ax
 33961 00005E95 58                      	pop	ax
 33962                                  					; set up ds to DOSDATA
 33963                                  	;MOV	[CS:USER_SP],AX ; MSDOS 3.3
 33964 00005E96 A3[8405]                	mov	[USER_SP],ax
 33965                                  
 33966 00005E99 58                      	POP	AX			; suck off CS:IP of interrupt...
 33967 00005E9A 58                      	POP	AX
 33968 00005E9B 58                      	POP	AX
 33969                                  
 33970                                  ; M011 : BEGIN
 33971                                  
 33972                                  	; MSDOS 3.3
 33973                                  ;	MOV	AX,0F202h	; STI
 33974                                  
 33975                                  	; MSDOS 6.0
 33976 00005E9C 9F                      	LAHF
 33977 00005E9D 86E0                    	XCHG	AH,AL
 33978 00005E9F 2402                    	AND	AL,2
 33979 00005EA1 B4F2                    	MOV	AH,0F2h
 33980                                  
 33981                                  ; M011 : END
 33982                                  
 33983                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33984 00005EA3 50                      	PUSH	AX
 33985                                   
 33986                                  	;PUSH	word [CS:EXITHOLD+2]
 33987                                  	;PUSH	word [CS:EXITHOLD]
 33988                                  	
 33989                                  	; MSDOS 6.0
 33990 00005EA4 FF36[8205]              	PUSH	word [EXITHOLD+2]
 33991 00005EA8 FF36[8005]              	PUSH	word [EXITHOLD]
 33992                                  
 33993                                  	;MOV	AX,[CS:USER_SP]
 33994                                  
 33995                                  	; MSDOS 6.0
 33996 00005EAC A1[8405]                	MOV	AX,[USER_SP]
 33997 00005EAF 8E1E[840D]              	mov	ds,[TEMPSEG]	; restore ds
 33998                                  
 33999 00005EB3 CF                      	IRET			; Long return back to user terminate address
 34000                                  
 34001                                  ;---------------------------------------------------------------------------
 34002                                  ;
 34003                                  ; Procedure Name : SET_I24_EXTENDED_ERROR
 34004                                  ;
 34005                                  ; This routine handles extended error codes.
 34006                                  ; Input : DI = error code from device
 34007                                  ; Output: All EXTERR fields are set
 34008                                  ;
 34009                                  ;--------------------------------------------------------------------------
 34010                                  
 34011                                  SET_I24_EXTENDED_ERROR:
 34012 00005EB4 50                      	PUSH	AX
 34013                                  					; ErrMap24End is in DOSDATA
 34014 00005EB5 B8[020F]                	MOV	AX,ErrMap24End
 34015 00005EB8 2D[F20E]                	SUB	AX,ErrMap24
 34016                                  					; Change to dosdata to access 
 34017                                  					; ErrMap24 and EXTERR -SR
 34018                                  	; 05/05/2019 - Retro DOS v4.0
 34019                                  	
 34020                                  	; MSDOS 6.0
 34021 00005EBB 1E                      	push	ds
 34022                                  	;getdseg <ds>			; ds ->dosdata
 34023 00005EBC 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 34024                                  
 34025                                  	; AX is the index of the first unavailable error. Do not translate 
 34026                                  	; if greater or equal to AX.
 34027                                  
 34028 00005EC1 39C7                    	CMP	DI,AX
 34029 00005EC3 89F8                    	MOV	AX,DI
 34030 00005EC5 7306                    	JAE	short NoTrans
 34031                                  
 34032                                  	;MOV	AL,[CS:DI+ErrMap24]  ; MSDOS 3.3
 34033 00005EC7 8A85[F20E]              	mov	al,[ErrMap24+di] ; MSDOS 6.0
 34034 00005ECB 30E4                    	XOR	AH,AH
 34035                                  NoTrans:
 34036                                  	;MOV	[CS:EXTERR],AX
 34037 00005ECD A3[2403]                	mov	[EXTERR],AX
 34038 00005ED0 1F                      	pop	ds
 34039                                  	;assume	ds:nothing
 34040 00005ED1 58                      	POP	AX
 34041                                  
 34042                                  	; Now Extended error is set correctly. Translate it to get correct 
 34043                                  	; error locus class and recommended action.
 34044                                  
 34045 00005ED2 56                      	PUSH	SI
 34046                                  					; ERR_TABLE_24 is in DOSCODE 
 34047 00005ED3 BE[A20E]                	MOV	SI,ERR_TABLE_24
 34048 00005ED6 E8DAA7                  	call	CAL_LK			; Set other extended error fields
 34049 00005ED9 5E                      	POP	SI
 34050 00005EDA C3                      	retn
 34051                                  
 34052                                  ;============================================================================
 34053                                  ; FAT.ASM, MSDOS 6.0, 1991
 34054                                  ;============================================================================
 34055                                  ; 30/07/2018 - Retro DOS v3.0
 34056                                  ; 20/05/2019 - Retro DOS v4.0
 34057                                  
 34058                                  ;	TITLE	FAT - FAT maintenance routines
 34059                                  ;	NAME	FAT
 34060                                  
 34061                                  ;**	FAT.ASM
 34062                                  ;----------------------------------------------------------------------------
 34063                                  ;	Low level local device routines for performing disk change sequence,
 34064                                  ;	setting cluster validity, and manipulating the FAT
 34065                                  ;
 34066                                  ;	IsEof
 34067                                  ;	UNPACK
 34068                                  ;	PACK
 34069                                  ;	MAPCLUSTER
 34070                                  ;	FATREAD_SFT
 34071                                  ;	FATREAD_CDS
 34072                                  ;	FAT_operation
 34073                                  ;
 34074                                  ;	Revision history:
 34075                                  ;
 34076                                  ;	  AN000  version Jan. 1988
 34077                                  ;	   A001  PTM	      -- disk changed for look ahead buffers
 34078                                  ;
 34079                                  ;	M014 - if a request for pack\unpack cluster 0 is made we write\read
 34080                                  ;	       from CL0FATENTRY rather than disk.
 34081                                  
 34082                                  ; DOSCODE:94FAh (MSDOS 6.21, MSDOS.SYS)
 34083                                  
 34084                                  ;Break <IsEOF - check the quantity in BX for EOF>
 34085                                  ;----------------------------------------------------------------------------
 34086                                  ;
 34087                                  ; Procedure Name : IsEOF
 34088                                  ;
 34089                                  ; IsEOF - check the fat value in BX for eof.
 34090                                  ;
 34091                                  ;   Inputs:	ES:BP point to DPB
 34092                                  ;		BX has fat value
 34093                                  ;   Outputs:	JAE eof
 34094                                  ;   Registers modified: none
 34095                                  ;
 34096                                  ;---------------------------------------------------------------------------
 34097                                  
 34098                                  IsEOF:
 34099                                  	;cmp	word [es:bp+0Dh],0FF6h
 34100 00005EDB 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; is this 16 bit fat?
 34101 00005EE1 730B                    	JAE	short EOF16			; yes, check for eof there
 34102                                  
 34103                                  ;J.K. 8/27/86
 34104                                  ;Modified to accept 0FF0h as an eof. This is to handle the diskfull case
 34105                                  ;of any media that has "F0"(Other) as a MediaByte.
 34106                                  ;Hopely, this does not create any side effect for those who may use any value
 34107                                  ;other than "FF8-FFF" as an EOF for their own file.
 34108                                  
 34109 00005EE3 81FBF00F                	cmp	bx,0FF0h
 34110 00005EE7 7404                    	je	short IsEOF_other
 34111                                  
 34112 00005EE9 81FBF80F                	CMP	BX,0FF8h		; do the 12 bit compare
 34113                                  IsEOF_other:
 34114 00005EED C3                      	retn
 34115                                  EOF16:
 34116 00005EEE 83FBF8                  	CMP	BX,0FFF8h		; 16 bit compare
 34117 00005EF1 C3                      	retn
 34118                                  
 34119                                  ; DOSCODE:9511h (MSDOS 6.21, MSDOS.SYS)
 34120                                  
 34121                                  ;Break	<UNPACK -- UNPACK FAT ENTRIES>
 34122                                  ;---------------------------------------------------------------------------
 34123                                  ;
 34124                                  ; Procedur Name : UNPACK
 34125                                  ;
 34126                                  ; Inputs:
 34127                                  ;	BX = Cluster number (may be full 16-bit quantity)
 34128                                  ;	ES:BP = Base of drive parameters
 34129                                  ; Outputs:
 34130                                  ;	DI = Contents of FAT for given cluster (may be full 16-bit quantity)
 34131                                  ;	Zero set means DI=0 (free cluster)
 34132                                  ;	Carry set means error (currently user FAILed to I 24)
 34133                                  ; SI Destroyed, No other registers affected. Fatal error if cluster too big.
 34134                                  ;
 34135                                  ; NOTE: if BX = 0 then DI = contents of CL0FATENTRY
 34136                                  ;
 34137                                  ;----------------------------------------------------------------------------
 34138                                  	
 34139                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34140                                  	; DOSCODE:94B5h (MSDOS 5.0, MSDOS.SYS)
 34141                                  
 34142                                  	; 20/05/2019 - Retro DOS v4.0
 34143                                  UNPACK:
 34144                                  	; MSDOS 6.0			; M014 - Start
 34145 00005EF2 09DB                    	or	bx, bx			; Q: are we unpacking cluster 0
 34146 00005EF4 7507                    	jnz	short up_cont		; N: proceed with normal unpack
 34147 00005EF6 8B3E[8100]              	mov	di,[CL0FATENTRY]	; Y: return value in CL0FATENTRY
 34148 00005EFA 09FF                    	or	di,di 			; return z if di=0
 34149 00005EFC C3                      	retn				; done
 34150                                  up_cont:				; M014 - End
 34151                                  	; MSDOS 3.3 & MSDOS 6.0
 34152                                  	;cmp	bx,[es:bp+0Dh]
 34153 00005EFD 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 34154 00005F01 7726                    	JA	short HURTFAT
 34155 00005F03 E8D600                  	CALL	MAPCLUSTER
 34156 00005F06 721E                    	jc	short _DoContext
 34157 00005F08 8B3D                    	MOV	DI,[DI]
 34158 00005F0A 750E                    	JNZ	short High12		; MZ if high 12 bits, go get 'em
 34159 00005F0C 268B760D                	MOV	SI,[ES:BP+DPB.MAX_CLUSTER] ; MZ is this 16-bit fat?
 34160 00005F10 81FEF60F                	CMP	SI,4096-10
 34161 00005F14 720C                    	JB	short Unpack12		; MZ No, go 'AND' off bits
 34162 00005F16 09FF                    	OR	DI,DI			; MZ set zero condition code, clears carry
 34163 00005F18 EB0C                    	JMP	SHORT _DoContext 	; MZ go do context
 34164                                  High12:
 34165 00005F1A D1EF                    	SHR	DI,1
 34166 00005F1C D1EF                    	SHR	DI,1
 34167 00005F1E D1EF                    	SHR	DI,1
 34168 00005F20 D1EF                    	SHR	DI,1
 34169                                  Unpack12:
 34170 00005F22 81E7FF0F                	AND	DI,0FFFh		; Clears carry
 34171                                  _DoContext:
 34172 00005F26 16                      	PUSH	SS
 34173 00005F27 1F                      	POP	DS
 34174 00005F28 C3                      	retn
 34175                                  HURTFAT:
 34176                                  	;;mov	word [es:bp+1Eh],0FFFFh
 34177                                  	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
 34178 00005F29 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; Err in FAT must force recomp of freespace
 34179 00005F2F 50                      	PUSH	AX
 34180 00005F30 B488                    	MOV	AH,Allowed_FAIL+80h ; 88h
 34181                                  
 34182                                  ;hkn; SS override
 34183 00005F32 36C606[4B03]08          	MOV	byte [SS:ALLOWED],Allowed_FAIL ; 8
 34184                                  ;
 34185                                  ; Signal Bad FAT to INT int_fatal_abort handler. We have an invalid cluster.
 34186                                  ;
 34187 00005F38 BFFF0F                  	MOV	DI,0FFFh		; In case INT int_fatal_abort returns (it shouldn't)
 34188 00005F3B E8C8FD                  	call	FATAL
 34189 00005F3E 3C03                    	CMP	AL,3
 34190 00005F40 F8                      	CLC
 34191 00005F41 7501                    	JNZ	short OKU_RET 		; Try to ignore bad FAT
 34192 00005F43 F9                      	STC				; User said FAIL
 34193                                  OKU_RET:
 34194 00005F44 58                      	POP	AX
 34195                                  hurtfat_retn:
 34196 00005F45 C3                      	retn
 34197                                  
 34198                                  ; DOSCODE:9565h (MSDOS 6.21, MSDOS.SYS)
 34199                                  
 34200                                  ;Break	<PACK -- PACK FAT ENTRIES>
 34201                                  ;----------------------------------------------------------------------------
 34202                                  ;
 34203                                  ; Procedure Name : PACK
 34204                                  ;
 34205                                  ; Inputs:
 34206                                  ;	BX = Cluster number
 34207                                  ;	DX = Data
 34208                                  ;	ES:BP = Pointer to drive DPB
 34209                                  ; Outputs:
 34210                                  ;	The data is stored in the FAT at the given cluster.
 34211                                  ;	SI,DX,DI all destroyed
 34212                                  ;	Carry set means error (currently user FAILed to I 24)
 34213                                  ;	No other registers affected
 34214                                  ;
 34215                                  ; NOTE: if BX = 0 then data in DX is stored in CL0FATENTRY.
 34216                                  ;
 34217                                  ;---------------------------------------------------------------------------
 34218                                  
 34219                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34220                                  	; 20/05/2019 - Retro DOS v4.0
 34221                                  PACK:
 34222                                  	; MSDOS 6.0			; M014 - start
 34223 00005F46 09DB                    	or	bx,bx			; Q: are we packing cluster 0
 34224 00005F48 7505                    	jnz	short p_cont		; N: proceed with normal pack
 34225 00005F4A 8916[8100]              	mov	[CL0FATENTRY],dx	; Y: place value in CL0FATENTRY
 34226 00005F4E C3                      	retn				; done
 34227                                  p_cont:					; M014 - end
 34228                                  	; MSDOS 3.3 & MSDOS 6.0
 34229 00005F4F E88A00                  	CALL	MAPCLUSTER
 34230 00005F52 72D2                    	JC	short _DoContext
 34231 00005F54 8B35                    	MOV	SI,[DI]
 34232 00005F56 740B                    	JZ	short ALIGNED 		; byte (not nibble) aligned
 34233 00005F58 51                      	PUSH	CX			; move data to upper 12 bits
 34234 00005F59 B104                    	MOV	CL,4
 34235 00005F5B D3E2                    	SHL	DX,CL
 34236 00005F5D 59                      	POP	CX
 34237 00005F5E 83E60F                  	AND	SI,0FH			; leave in original low 4 bits
 34238 00005F61 EB14                    	JMP	SHORT PACKIN
 34239                                  ALIGNED:
 34240                                  	;cmp	word [es:bp+0Dh],0FF6h
 34241 00005F63 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ 16 bit fats?
 34242 00005F69 730A                    	JAE	short Pack16		; MZ yes, go clobber original data
 34243 00005F6B 81E600F0                	AND	SI,0F000h		; MZ leave in upper 4 bits of original
 34244 00005F6F 81E2FF0F                	AND	DX,0FFFh		; MZ store only 12 bits
 34245 00005F73 EB02                    	JMP	SHORT PACKIN		; MZ go store
 34246                                  Pack16:
 34247 00005F75 31F6                    	XOR	SI,SI			; MZ no original data
 34248                                  PACKIN:
 34249 00005F77 09D6                    	OR	SI,DX
 34250 00005F79 8935                    	MOV	[DI],SI
 34251                                  
 34252                                  ;hkn; SS override
 34253 00005F7B 36C536[E205]            	LDS	SI,[SS:CURBUF]
 34254                                  	; MSDOS 6.0
 34255 00005F80 F6440540                	TEST	byte [SI+BUFFINFO.buf_flags],buf_dirty
 34256                                  					;LB. if already dirty		  ;AN000;
 34257 00005F84 7507                    	JNZ	short yesdirty11	;LB.  don't increment dirty count ;AN000;
 34258                                  	; 10/06/2019
 34259 00005F86 E8B705                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 34260                                  	
 34261                                  	;or	byte [si+5],40h
 34262 00005F89 804C0540                	OR	byte [SI+BUFFINFO.buf_flags],buf_dirty
 34263                                  yesdirty11:				;LB.				;AN000;
 34264                                  ;hkn; SS override
 34265 00005F8D 36803E[7805]00          	CMP	BYTE [SS:CLUSSPLIT],0	; 15/08/2018
 34266                                  ;hkn; SS is DOSDATA
 34267 00005F93 16                      	push	ss
 34268 00005F94 1F                      	pop	ds
 34269 00005F95 74AE                    	jz	short hurtfat_retn	; Carry clear
 34270 00005F97 50                      	PUSH	AX
 34271 00005F98 53                      	PUSH	BX
 34272 00005F99 51                      	PUSH	CX
 34273 00005F9A A1[8E05]                	MOV	AX,[CLUSSAVE]
 34274 00005F9D 8E1E[E405]              	MOV	DS,[CURBUF+2]
 34275                                  	;;;add	si,16 ; MSDOS 3.3
 34276                                  	;;add	si,20 ; MSDOS 6.0
 34277                                  	; 02/01/2024
 34278                                  	;add	si,24 ; PCDOS 7.1 
 34279 00005FA1 83C618                  	ADD	SI,BUFINSIZ
 34280 00005FA4 8824                    	MOV	[SI],AH
 34281                                  ;hkn; SS is DOSDATA
 34282                                  	;Context DS
 34283 00005FA6 16                      	push	ss
 34284 00005FA7 1F                      	pop	ds
 34285                                  	
 34286 00005FA8 50                      	PUSH	AX
 34287                                  	
 34288                                  	; MSDOS 6.0
 34289 00005FA9 8B16[9205]              	MOV	DX,[CLUSSEC+2]		;F.C. >32mb			;AN000;
 34290 00005FAD 8916[0706]              	MOV	[HIGH_SECTOR],DX	;F.C. >32mb			;AN000;
 34291                                  
 34292                                  	; MSDOS 3.3 & MSDOS 6.0
 34293 00005FB1 8B16[9005]              	MOV	DX,[CLUSSEC]
 34294                                  
 34295                                  	;MOV	SI,1	  ; *
 34296                                  	;XOR	AL,AL     ; *
 34297                                  	;call	GETBUFFRB ; *
 34298                                  	; 22/09/2023
 34299 00005FB5 E86C03                  	call	GETBUFFRA ; *
 34300                                  
 34301 00005FB8 58                      	POP	AX
 34302 00005FB9 721B                    	JC	short POPP_RET
 34303 00005FBB C53E[E205]              	LDS	DI,[CURBUF]
 34304                                  	
 34305                                  	; MSDOS 6.0
 34306 00005FBF F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 34307                                  					;LB. if already dirty		  ;AN000;
 34308 00005FC3 7507                    	JNZ	short yesdirty12	;LB.  don't increment dirty count ;AN000;
 34309 00005FC5 E87805                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 34310                                  	
 34311                                  	;or	byte [di+5],40h
 34312 00005FC8 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty 
 34313                                  yesdirty12:
 34314                                  	;;;add	di,16
 34315                                  	;;add	di,20 ; MSDOS 6.0
 34316                                  	;ADD	DI,BUFINSIZ
 34317                                  	;DEC	DI
 34318                                  	; 02/01/2024 - Retro DOS v5.0
 34319                                  	;add	di,23 ; PCDOS 7.1
 34320 00005FCC 83C717                  	add	di,BUFINSIZ-1 ; 23 ; PCDOS 7.1 IBMDOS.COM
 34321                                  	
 34322                                  	;add	di,[es:bp+2]
 34323 00005FCF 26037E02                	ADD	DI,[ES:BP+DPB.SECTOR_SIZE]
 34324 00005FD3 8805                    	MOV	[DI],AL
 34325 00005FD5 F8                      	CLC
 34326                                  POPP_RET:
 34327 00005FD6 16                      	PUSH	SS
 34328 00005FD7 1F                      	POP	DS
 34329 00005FD8 59                      	POP	CX
 34330 00005FD9 5B                      	POP	BX
 34331 00005FDA 58                      	POP	AX
 34332 00005FDB C3                      	retn
 34333                                  
 34334                                  ; 31/07/2018 - Retro DOS v3.0
 34335                                  
 34336                                  ;Break	<MAPCLUSTER - BUFFER A FAT SECTOR>
 34337                                  ;---------------------------------------------------------------------------
 34338                                  ;
 34339                                  ; Procedure Name : MAPCLUSTER
 34340                                  ;
 34341                                  ; Inputs:
 34342                                  ;	ES:BP Points to DPB
 34343                                  ;	BX Is cluster number
 34344                                  ; Function:
 34345                                  ;	Get a pointer to the cluster
 34346                                  ; Outputs:
 34347                                  ;	DS:DI Points to contents of FAT for given cluster
 34348                                  ;	DS:SI Points to start of buffer
 34349                                  ;	Zero Not set if cluster data is in high 12 bits of word
 34350                                  ;	Zero set if cluster data is in low 12 or 16 bits
 34351                                  ;	Carry set if failed.
 34352                                  ; SI is destroyed.
 34353                                  ;
 34354                                  ;---------------------------------------------------------------------------
 34355                                  
 34356                                  	; 20/05/2019 - Retro DOS v4.0
 34357                                  	; DOSCODE:9601h (MSDOS 6.21, MSDOS.SYS)
 34358                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34359                                  	; DOSCODE:95A5h (MSDOS 5.0, MSDOS.SYS)
 34360                                  
 34361                                  MAPCLUSTER:
 34362                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5A15h
 34363 00005FDC C606[7805]00            	MOV	BYTE [CLUSSPLIT],0
 34364                                  	;SAVE	<AX,BX,CX,DX>
 34365 00005FE1 50                      	push	ax
 34366 00005FE2 53                      	push	bx
 34367 00005FE3 51                      	push	cx
 34368 00005FE4 52                      	push	dx
 34369 00005FE5 89D8                    	MOV	AX,BX			; AX = BX
 34370 00005FE7 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10  ; MZ 16 bit fat?
 34371 00005FED 7302                    	JAE	short Map16		; MZ yes, do 16 bit algorithm
 34372 00005FEF D1E8                    	SHR	AX,1			; AX = BX/2
 34373                                  Map16:	
 34374                                  	; MSDOS 6.0			; MZ skip prev => AX=2*BX
 34375 00005FF1 31FF                    	XOR	DI,DI ; *		; >32mb fat ;AN000;
 34376                                  	; MSDOS 3.3 (& MSDOS 6.0)
 34377 00005FF3 01D8                    	ADD	AX,BX			; AX = 1.5*fat = byte offset in fat
 34378 00005FF5 11FF                    	ADC	DI,DI ; * MSDOS 6.0	; >32mb fat ;DI is zero before op;AN000;
 34379 00005FF7 268B4E02                	MOV	CX,[ES:BP+DPB.SECTOR_SIZE]
 34380                                  
 34381                                  ;IF FastDiv
 34382                                  ;
 34383                                  ; Gross hack: 99% of all disks have 512 bytes per sector. We test for this
 34384                                  ; case and apply a really fast algorithm to get the desired results
 34385                                  ;
 34386                                  ; Divide method takes 157+4*4=173 (MOV and DIV)
 34387                                  ; Fast method takes 39+20*4=119
 34388                                  ;
 34389                                  ; This saves a bunch.
 34390                                  
 34391 00005FFB 81F90002                	CMP	CX,512			; 4  Is this 512 byte sector?
 34392 00005FFF 7510                    	jne	short _DoDiv		; 4  for no jump
 34393 00006001 89C2                    	MOV	DX,AX			; 2  get set for remainder
 34394 00006003 81E2FF01                	AND	DX,512-1		; 4  Form remainder
 34395 00006007 88E0                    	MOV	AL,AH			; 2  Quotient in formation in AL
 34396                                  	; MDOS 3.3
 34397                                  	;shr	al,1	
 34398                                  	; MDOS 6.0
 34399 00006009 D1EF                    	shr	di,1			; 2
 34400 0000600B D0D8                    	rcr	al,1			; 2
 34401                                  	; MDOS 3.3 (& MSDOS 6.0)
 34402 0000600D 30E4                    	xor	ah,ah			; 3
 34403 0000600F EB04                    	jmp	short DivDone		; 16
 34404                                  _DoDiv:
 34405                                  ;ENDIF
 34406                                  	; MSDOS 3.3
 34407                                  	;xor	dx,dx
 34408                                  	; MSDOS 6.0
 34409 00006011 89FA                    	mov	dx,di			; 2
 34410                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 34411 00006013 F7F1                    	DIV	CX			; 155 AX is FAT sector # DX is sector index
 34412                                  ;IF FastDiv
 34413                                  DivDone:
 34414                                  ;ENDIF
 34415                                  	;add	ax,[es:bp+6]
 34416 00006015 26034606                	ADD	AX,[ES:BP+DPB.FIRST_FAT]
 34417 00006019 49                      	DEC	CX			; CX is sector size - 1
 34418                                  	;SAVE	<AX,DX,CX>
 34419 0000601A 50                      	push	ax
 34420 0000601B 52                      	push	dx
 34421 0000601C 51                      	push	cx
 34422 0000601D 89C2                    	MOV	DX,AX
 34423                                  
 34424                                  	; MSDOS 6.0
 34425                                  	; 22/09/2023
 34426                                  	;MOV	word [HIGH_SECTOR],0 ; *! ;F.C. >32mb  low sector #
 34427                                  	;
 34428                                  	; MDOS 3.3 (& MSDOS 6.0)
 34429                                  	;XOR	AL,AL	   ; *
 34430                                  	;MOV	SI,1	   ; *
 34431                                  	;;invoke GETBUFFRB ; *
 34432                                  	;call	GETBUFFRB  ; *
 34433                                  	; 22/09/2023
 34434 0000601F E8FC02                  	call	GETBUFFRC  ; *!
 34435                                  
 34436                                  	;RESTORE <CX,AX,DX>		; CX is sec siz-1, AX is offset in sec
 34437 00006022 59                      	pop	cx
 34438 00006023 58                      	pop	ax
 34439 00006024 5A                      	pop	dx
 34440 00006025 724C                    	JC	short MAP_POP
 34441                                  
 34442 00006027 C536[E205]              	LDS	SI,[CURBUF]
 34443                                  	;;lea	di,[si+16]
 34444                                  	;lea	di,[si+20] ; MSDOS 6.0
 34445 0000602B 8D7C18                  	LEA	DI,[SI+BUFINSIZ]
 34446 0000602E 01C7                    	ADD	DI,AX
 34447 00006030 39C8                    	CMP	AX,CX
 34448 00006032 752C                    	JNZ	short MAPRET
 34449 00006034 8A05                    	MOV	AL,[DI]
 34450                                  	;Context DS		 	;hkn; SS is DOSDATA
 34451 00006036 16                      	push	ss
 34452 00006037 1F                      	pop	ds	
 34453 00006038 FE06[7805]              	INC	BYTE [CLUSSPLIT]
 34454 0000603C A2[8E05]                	MOV	[CLUSSAVE],AL
 34455 0000603F 8916[9005]              	MOV	[CLUSSEC],DX
 34456                                  	; MSDOS 6.0
 34457 00006043 C706[9205]0000          	MOV	WORD [CLUSSEC+2],0      ;F.C. >32mb	;AN000;
 34458 00006049 42                      	INC	DX
 34459                                  
 34460                                  	; 22/09/2023
 34461                                  	;MOV	word [HIGH_SECTOR],0 ; *! ;F.C. >32mb FAT sector <32mb ;AN000;
 34462                                  	;
 34463                                  	; MDOS 3.3 (& MSDOS 6.0)
 34464                                  	;XOR	AL,AL	   ; *
 34465                                  	;MOV	SI,1	   ; *
 34466                                  	;;invoke GETBUFFRB ; *
 34467                                  	;call	GETBUFFRB  ; *
 34468                                  	; 22/09/2023
 34469 0000604A E8D102                  	call	GETBUFFRC  ; *!
 34470 0000604D 7224                    	JC	short MAP_POP
 34471                                  
 34472 0000604F C536[E205]              	LDS	SI,[CURBUF]
 34473 00006053 8D7C18                  	LEA	DI,[SI+BUFINSIZ]
 34474 00006056 8A05                    	MOV	AL,[DI]
 34475                                  	;Context DS			;hkn; SS is DOSDATA
 34476 00006058 16                      	push	ss
 34477 00006059 1F                      	pop	ds
 34478 0000605A A2[8F05]                	MOV	[CLUSSAVE+1],AL
 34479                                  
 34480                                  ;hkn; CLUSSAVE is in DOSDATA
 34481 0000605D BF[8E05]                	MOV	DI,CLUSSAVE
 34482                                  MAPRET:
 34483                                  	;RESTORE <DX,CX,BX>
 34484 00006060 5A                      	pop	dx
 34485 00006061 59                      	pop	cx
 34486 00006062 5B                      	pop	bx
 34487 00006063 31C0                    	XOR	AX,AX			; MZ allow shift to clear carry
 34488 00006065 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ is this 16-bit fat?
 34489 0000606B 7302                    	JAE	short MapSet		; MZ no, set flags
 34490 0000606D 89D8                    	MOV	AX,BX
 34491                                  MapSet:
 34492 0000606F A801                    	TEST	AL,1			; set zero flag if not on boundary
 34493                                  	;RESTORE <AX>
 34494 00006071 58                      	pop	ax
 34495 00006072 C3                      	retn
 34496                                  
 34497                                  MAP_POP:
 34498                                  	;RESTORE <DX,CX,BX,AX>
 34499 00006073 5A                      	pop	dx
 34500 00006074 59                      	pop	cx
 34501 00006075 5B                      	pop	bx
 34502 00006076 58                      	pop	ax
 34503                                  fatread_sft_retn: ; 17/12/2022
 34504 00006077 C3                      	retn
 34505                                  
 34506                                  ; 20/05/2019 - Retro DOS v4.0
 34507                                  ; DOSCODE:96B3h (MSDOS 6.21, MSDOS.SYS)
 34508                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34509                                  ; DOSCODE:9657h (MSDOS 5.0, MSDOS.SYS)
 34510                                  
 34511                                  ;Break	<FATREAD_SFT/FATREAD_CDS -- CHECK DRIVE GET FAT>
 34512                                  ;----------------------------------------------------------------------------
 34513                                  ;
 34514                                  ; Procedure Name : FATREAD_SFT
 34515                                  ;
 34516                                  ; Inputs:
 34517                                  ;	ES:DI points to an SFT for the drive of interest (local only,
 34518                                  ;		giving a NET SFT will produce system crashing results).
 34519                                  ;	DS DOSDATA
 34520                                  ; Function:
 34521                                  ;	Can be used by an SFT routine (like CLOSE) to invalidate buffers
 34522                                  ;	if disk changed.
 34523                                  ;	In other respects, same as FATREAD_CDS.
 34524                                  ;	(note ES:DI destroyed!)
 34525                                  ; Outputs:
 34526                                  ;	Carry set if error (currently user FAILed to I 24)
 34527                                  ; NOTE: This routine may cause FATREAD_CDS to "miss" a disk change
 34528                                  ;	as far as invalidating curdir_ID is concerned.
 34529                                  ;	Since getting a true disk changed on this call is a screw up
 34530                                  ;	anyway, that's the way it goes.
 34531                                  ;
 34532                                  ;---------------------------------------------------------------------------
 34533                                  
 34534                                  FATREAD_SFT:
 34535 00006078 26C46D07                	LES	BP,[ES:DI+SF_ENTRY.sf_devptr]
 34536                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34537                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 34538                                  	; 15/12/2022
 34539 0000607C 268A4600                	mov	AL,[ES:BP]
 34540 00006080 A2[7605]                	MOV	[THISDRV],AL
 34541 00006083 E8E1A5                  	call	GOTDPB			; Set THISDPB
 34542                                  	;CALL	FAT_GOT_DPB
 34543                                  	; 17/12/2022
 34544 00006086 E99F00                  	jmp	FAT_GOT_DPB
 34545                                  ;fatread_sft_retn:
 34546                                  	;retn
 34547                                  
 34548                                  ;----------------------------------------------------------------------------
 34549                                  ;
 34550                                  ; Procedure Name : FATREAD_CDS
 34551                                  ;
 34552                                  ; Inputs:
 34553                                  ;	DS:DOSDATA
 34554                                  ;	ES:DI points to an CDS for the drive of interest (local only,
 34555                                  ;		giving a NET or NUL CDS will produce system crashing results).
 34556                                  ; Function:
 34557                                  ;	If disk may have been changed, media is determined and buffers are
 34558                                  ;	flagged invalid. If not, no action is taken.
 34559                                  ; Outputs:
 34560                                  ;	ES:BP = Drive parameter block
 34561                                  ;	THISDPB = ES:BP
 34562                                  ;	THISDRV set
 34563                                  ;	Carry set if error (currently user FAILed to I 24)
 34564                                  ; DS preserved , all other registers destroyed
 34565                                  ;
 34566                                  ;---------------------------------------------------------------------------
 34567                                  
 34568                                  	; 20/05/2019 - Retro DOS v4.0
 34569                                  	; DOSCODE:96C5h (MSDOS 6.21, MSDOS.SYS)
 34570                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34571                                  	; DOSCODE:9669h (MSDOS 5.0, MSDOS.SYS)
 34572                                  
 34573                                  FATREAD_CDS:
 34574 00006089 06                      	PUSH	ES
 34575 0000608A 57                      	PUSH	DI
 34576                                  	;les	bp,[es:di+45h]
 34577 0000608B 26C46D45                	LES	BP,[ES:DI+curdir.devptr]
 34578                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34579                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 34580                                  	; 15/12/2022
 34581 0000608F 268A4600                	mov	AL,[ES:BP]
 34582 00006093 A2[7605]                	MOV	[THISDRV],AL
 34583 00006096 E8CEA5                  	call	GOTDPB			;Set THISDPB
 34584 00006099 E88C00                  	CALL	FAT_GOT_DPB
 34585 0000609C 5F                      	POP	DI			;Get back CDS pointer
 34586 0000609D 07                      	POP	ES
 34587 0000609E 72D7                    	jc	short fatread_sft_retn
 34588 000060A0 7538                    	JNZ	short NO_CHANGE		;Media NOT changed
 34589                                  
 34590                                  ;	Media changed. We now need to find all CDS structures which use this
 34591                                  ;	DPB and invalidate their ID pointers.
 34592                                  
 34593                                  MED_CHANGE:
 34594 000060A2 31C0                    	XOR	AX,AX
 34595 000060A4 48                      	DEC	AX			; AX = -1
 34596 000060A5 1E                      	PUSH	DS
 34597 000060A6 8A0E[4700]              	MOV	CL,[CDSCOUNT]
 34598 000060AA 30ED                    	XOR	CH,CH			; CX is number of structures
 34599                                  	;lds	si,[es:di+45h]
 34600 000060AC 26C57545                	LDS	SI,[ES:DI+curdir.devptr] ; Find all CDS with this devptr
 34601                                  
 34602                                  ;hkn; SS override
 34603                                  
 34604                                  ;	Find all CDSs with this DevPtr
 34605                                  ;
 34606                                  ;	(ax) = -1
 34607                                  ;	(ds:si) = DevPtr
 34608                                  
 34609 000060B0 36C43E[3C00]            	LES	DI,[SS:CDSADDR]		; (es:di) = CDS pointer
 34610                                  frcd20: 
 34611                                  	;;test	word [es:di+43h],8000h
 34612                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 34613 000060B5 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 34614 000060BA 7518                    	JNZ	short frcd25		; Leave NET guys alone!!
 34615                                  
 34616                                  	; MSDOS 3.3
 34617                                  	;push	es
 34618                                  	;push	di
 34619                                  	;les	di,[es:di+45h]
 34620                                  	;;les	di,[ES:DI+curdir.devptr]
 34621                                  	;call	POINTCOMP
 34622                                  	;pop	di
 34623                                  	;pop	es
 34624                                  	;jnz	short frcd25
 34625                                  
 34626                                  	; MSDOS 6.0
 34627 000060BC 263B7545                	cmp	si,[ES:DI+curdir.devptr]
 34628 000060C0 7512                    	jne	short frcd25		; no match
 34629 000060C2 8CDB                    	mov	bx,ds
 34630 000060C4 263B5D47                	cmp	bx,[ES:DI+curdir.devptr+2]
 34631 000060C8 750A                    	jne	short frcd25		; CDS not for this drive
 34632                                  
 34633                                  	; MSDOS 3.3 (& MSDOS 6.0)
 34634                                  	;test	[es:di+49h],ax
 34635 000060CA 26854549                	test	[ES:DI+curdir.ID],AX
 34636 000060CE 7404                    	JZ	short frcd25		; If root (0), leave root
 34637                                  	;mov	[es:di+49h],ax
 34638 000060D0 26894549                	MOV	[ES:DI+curdir.ID],AX	; else invalid
 34639                                  frcd25:	
 34640                                  	;;add	di,81  ; MSDOS 3.3
 34641                                  	;add	di,88  ; MSDOS 6.0	 
 34642 000060D4 83C758                  	ADD	DI,curdir.size		; Point to next CDS
 34643 000060D7 E2DC                    	LOOP	frcd20
 34644 000060D9 1F                      	POP	DS
 34645                                  NO_CHANGE:
 34646 000060DA C42E[8A05]              	LES	BP,[THISDPB]
 34647 000060DE F8                      	CLC
 34648 000060DF C3                      	retn
 34649                                  
 34650                                  ;----------------------------------------------------------------------------
 34651                                  ; 05/01/2024 - Retro DOS 5.0
 34652                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:0A7Fh
 34653                                  ;;;
 34654                                  chk_set_first_access:
 34655 000060E0 26837E0F00              	cmp	word [es:bp+0Fh],0	; DPB.FATSIZE
 34656 000060E5 750D                    	jnz	short chk_set_fa_1	; FAT (FAT12 or FAT16)
 34657                                  					; FAT32
 34658 000060E7 26837E21FF              	cmp	word [es:bp+21h],0FFFFh	; DPB.FREE_CNT_HW
 34659 000060EC 26C74621FFFF            	mov	word [es:bp+21h],0FFFFh	; High word of free cluster count
 34660 000060F2 7505                    	jne	short chk_set_fa_2
 34661                                  chk_set_fa_1:
 34662 000060F4 26837E1FFF              	cmp	word [es:bp+1Fh],0FFFFh	; DPB.FREE_CNT
 34663                                  chk_set_fa_2:
 34664 000060F9 26C7461FFFFF            	mov	word [es:bp+1Fh],0FFFFh	; Count of free clusters, -1 if unknown
 34665 000060FF 7405                    	je	short chk_set_fa_3
 34666 00006101 26804E1801              	or	byte [es:bp+18h],1	; DPB.FIRST_ACCESS
 34667                                  chk_set_fa_3:
 34668 00006106 C3                      	retn
 34669                                  ;;;
 34670                                  ;----------------------------------------------------------------------------
 34671                                  
 34672                                  
 34673                                  ;Break	<Fat_Operation - miscellaneous fat stuff>
 34674                                  ;----------------------------------------------------------------------------
 34675                                  ;
 34676                                  ; Procedure Name : FAT_operation
 34677                                  ;
 34678                                  ;----------------------------------------------------------------------------
 34679                                  
 34680                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34681                                  
 34682                                  FAT_operation:
 34683                                  	; 31/07/2018 - Retro DOS v3.0
 34684                                  FATERR:
 34685                                  	;mov	word [es:bp+1Eh],-1
 34686                                  	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
 34687 00006107 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 
 34688                                  					; Err in FAT must force recomp of freespace
 34689                                  	;and	di,0FFh
 34690 0000610D 81E7FF00                	AND	DI,STECODE		; Put error code in DI
 34691                                  	;mov	byte [ALLOWED],18h
 34692 00006111 C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 34693                                  	;mov	ah,1Ah
 34694 00006116 B41A                    	MOV	AH,2+Allowed_FAIL+Allowed_RETRY ; While trying to read FAT
 34695 00006118 A0[7605]                	MOV	AL,[THISDRV]		; Tell which drive
 34696 0000611B E8ECFB                  	call	FATAL1
 34697 0000611E C42E[8A05]              	LES	BP,[THISDPB]
 34698 00006122 3C03                    	CMP	AL,3
 34699 00006124 7502                    	JNZ	short FAT_GOT_DPB	; User said retry
 34700 00006126 F9                      	STC				; User said FAIL
 34701 00006127 C3                      	retn
 34702                                  
 34703                                  FAT_GOT_DPB:
 34704                                  	;Context DS			;hkn; SS is DOSDATA
 34705 00006128 16                      	push	ss
 34706 00006129 1F                      	pop	ds
 34707                                  	;mov	al,0Fh
 34708 0000612A B00F                    	MOV	AL,DMEDHL
 34709                                  	;mov	ah,[es:bp+1]
 34710 0000612C 268A6601                	MOV	AH,[ES:BP+DPB.UNIT]
 34711 00006130 A3[5A03]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018 
 34712 00006133 C606[5C03]01            	MOV	BYTE [DEVCALL_REQFUNC],DEVMDCH
 34713 00006138 C706[5D03]0000          	MOV	word [DEVCALL_REQSTAT],0
 34714                                  	;;mov	al,[es:bp+16h]
 34715                                  	;mov	al,[es:bp+17h] ; MSDOS 6.0
 34716 0000613E 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 34717 00006142 A2[6703]                	MOV	[CALLMED],AL
 34718 00006145 06                      	PUSH	ES
 34719 00006146 1E                      	PUSH	DS
 34720                                  
 34721                                  ;hkn; DEVCALL is in DOSDATA
 34722 00006147 BB[5A03]                	MOV	BX,DEVCALL
 34723                                  	;;lds	si,[es:bp+12h]
 34724                                  	;lds	si,[es:bp+13h] ; MSDOS 6.0
 34725 0000614A 26C57613                	LDS	SI,[ES:BP+DPB.DRIVER_ADDR] ; DS:SI Points to device header
 34726 0000614E 07                      	POP	ES			; ES:BX Points to call header
 34727 0000614F E8D3EE                  	call	DEVIOCALL2
 34728                                  	;Context DS		 	;hkn; SS is DOSDATA
 34729 00006152 16                      	push	ss
 34730 00006153 1F                      	pop	ds
 34731 00006154 07                      	POP	ES			; Restore ES:BP
 34732 00006155 8B3E[5D03]              	MOV	DI,[DEVCALL_REQSTAT]
 34733                                  	;test	di,8000h
 34734                                  	;jnz	short FATERR
 34735 00006159 09FF                    	or	di,di
 34736 0000615B 78AA                    	js	short FATERR		; have error
 34737 0000615D 30E4                    	XOR	AH,AH
 34738                                  	;xchg	ah,[es:bp+17h] ; MSDOS 3.3
 34739                                  	;xchg	ah,[es:bp+18h] ; MSDOS 6.0
 34740 0000615F 26866618                	XCHG	AH,[ES:BP+DPB.FIRST_ACCESS] ; Reset dpb_first_access
 34741 00006163 A0[7605]                	MOV	AL,[THISDRV]		; Use physical unit number
 34742                                  ; See if we had changed volume id by creating one on the diskette
 34743 00006166 3806[A10A]              	cmp	[VOLCHNG_FLAG],AL
 34744 0000616A 7508                    	jnz	short CHECK_BYT
 34745 0000616C C606[A10A]FF            	mov	byte [VOLCHNG_FLAG],-1
 34746 00006171 E9A500                  	jmp	GOGETBPB		; Need to get device driver to read in
 34747                                  					; new volume label.
 34748                                  CHECK_BYT:
 34749 00006174 0A26[6803]              	OR	AH,[CALLRBYT]
 34750                                  	;JNS	short CHECK_ZR		; ns = 0 or 1
 34751                                  	;JMP	short NEWDSK
 34752                                  	; 17/12/2022
 34753 00006178 7863                    	js	short NEWDSK
 34754                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34755                                  	;JNS	short CHECK_ZR		; ns = 0 or 1
 34756                                  	;JMP	short NEWDSK
 34757                                  
 34758                                  CHECK_ZR:
 34759 0000617A 743B                    	JZ	short CHKBUFFDIRT	; jump if I don't know
 34760                                  	; 24/09/2023
 34761                                  	; cf=0 (after 'or' instruction)
 34762                                  	;CLC
 34763 0000617C C3                      	retn				; If Media not changed (NZ)
 34764                                  
 34765                                  DISK_CHNG_ERR:
 34766 0000617D 06                      	PUSH	ES
 34767 0000617E 55                      	PUSH	BP
 34768                                  	;;les	bp,[es:bp+12h]
 34769                                  	;les	bp,[es:bp+13h] ; MSDOS 6.0
 34770 0000617F 26C46E13                	LES	BP,[ES:BP+DPB.DRIVER_ADDR] ; Get device pointer
 34771                                  	;;test	word [es:bp+4],800h
 34772                                  	;TEST	word [ES:BP+SYSDEV.ATT],DEVOPCL ; Did it set vol id?
 34773 00006183 26F6460508              	test	byte [es:bp+SYSDEV.ATT+1],(DEVOPCL>>8)
 34774 00006188 5D                      	POP	BP
 34775 00006189 07                      	POP	ES
 34776 0000618A 7426                    	JZ	short FAIL_OPJ2		; Nope, FAIL
 34777 0000618C 1E                      	PUSH	DS			; Save buffer pointer for ignore
 34778 0000618D 57                      	PUSH	DI
 34779 0000618E 16                      	push	ss			;hkn; SS is DOSDATA
 34780 0000618F 1F                      	pop	ds
 34781                                  	;mov	byte [ALLOWED],18h
 34782 00006190 C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 34783 00006195 06                      	PUSH	ES
 34784 00006196 C43E[6903]              	LES	DI,[CALLVIDM]		; Get volume ID pointer
 34785 0000619A 8C06[2A03]              	MOV	[EXTERRPT+2],ES
 34786 0000619E 07                      	POP	ES
 34787 0000619F 893E[2803]              	MOV	[EXTERRPT],DI
 34788                                  	;mov	ax,0Fh
 34789 000061A3 B80F00                  	MOV	AX,error_I24_wrong_disk
 34790 000061A6 C606[7505]01            	MOV	byte [READOP],1		; Write
 34791                                  	;invoke	HARDERR
 34792 000061AB E80AFB                  	call	HARDERR
 34793 000061AE 5F                      	POP	DI			; Get back buffer for ignore
 34794 000061AF 1F                      	POP	DS
 34795 000061B0 3C03                    	CMP	AL,3
 34796                                  FAIL_OPJ2:
 34797 000061B2 741C                    	JZ	short FAIL_OP
 34798 000061B4 E971FF                  	JMP	FAT_GOT_DPB		; Retry
 34799                                  
 34800                                  CHKBUFFDIRT:
 34801                                  	; 20/05/2019 - Retro DOS v4.0
 34802                                  
 34803                                  	; MSDOS 3.3
 34804                                  	;lds	di,[BUFFHEAD]
 34805                                  
 34806                                  	; MSDOS 6.0
 34807 000061B7 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0	; any dirty buffers ? ;hkn;
 34808 000061BD 741E                    	je	short NEWDSK			; no, skip the check
 34809 000061BF E8F700                  	call	GETCURHEAD			; get pointer to first buffer
 34810                                  nbuffer:
 34811                                  	;cmp	al,[di+4]
 34812 000061C2 384504                  	cmp	[di+BUFFINFO.buf_ID],al	; Unit OK ?
 34813 000061C5 750D                    	jne	short lfnxt			; no, go for next buffer
 34814                                  	;test   byte [di+5],40h
 34815 000061C7 F6450540                	TEST	byte [di+BUFFINFO.buf_flags],buf_dirty	; is the buffer dirty ?
 34816 000061CB 7407                    	jz	short lfnxt			; no, go for next buffer
 34817                                  	;Context DS
 34818 000061CD 16                      	push	ss
 34819 000061CE 1F                      	pop	ds
 34820                                  	; 24/09/2023
 34821                                  	; cf=0 (after 'test' instruction)
 34822                                  	;clc
 34823 000061CF C3                      	retn
 34824                                  
 34825                                  FAIL_OP:					; This label & code is here
 34826                                  	;Context DS				;  for reachability
 34827 000061D0 16                      	push	ss
 34828 000061D1 1F                      	pop	ds
 34829 000061D2 F9                      	STC
 34830 000061D3 C3                      	retn
 34831                                  
 34832                                  lfnxt:
 34833                                  	; 15/08/2018 - Retro DOS v3.0
 34834                                  	; MSDOS 3.3
 34835                                  	;lds	di,[di]
 34836                                  
 34837                                  	; 20/05/2019 - Retro DOS v4.0
 34838 000061D4 8B3D                    	mov	di,[di]
 34839                                  	;;mov	di,[di+BUFFINFO.buf_next]	; get next buffer
 34840                                  	
 34841                                  	; MSDOS 3.3
 34842                                  	;cmp	di,-1
 34843                                  	;jne	short nbuffer
 34844                                  	
 34845                                  	; MSDOS 6.0
 34846 000061D6 36393E[A512]            	cmp	[ss:FIRST_BUFF_ADDR],di		; is this where we started ?;hkn;
 34847 000061DB 75E5                    	jne	short nbuffer			; no, check this guy also
 34848                                  
 34849                                  ; If no dirty buffers, assume Media changed
 34850                                  NEWDSK:
 34851                                  	;;mov	word [es:bp+1Eh],0FFFFh  ; MSDOS 3.3
 34852                                  	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
 34853 000061DD 26C7461FFFFF            	mov	word [ES:BP+DPB.FREE_CNT],-1	; Media changed, must
 34854                                  						;  recompute
 34855                                  	; MSDOS 3.3
 34856                                  	;call	SETVISIT
 34857                                  	; MSDOS 6.0
 34858 000061E3 E8D300                  	call	 GETCURHEAD
 34859                                  nxbuffer:
 34860                                  	; MSDOS 3.3
 34861                                  	;or 	byte [di+5],20h
 34862                                  	; MSDOS 3.3 & MSDOS 6.0
 34863                                  	;cmp	[di+4],al
 34864 000061E6 384504                  	cmp	[DI+BUFFINFO.buf_ID],al		; This drive ?
 34865 000061E9 7510                    	jne	short lfnxt2
 34866                                  	;test	byte [di+5],40h
 34867 000061EB F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 34868 000061EF 758C                    	jnz	short DISK_CHNG_ERR
 34869                                  	;mov	word [di+4],20FFh
 34870 000061F1 C74504FF20              	mov	word [DI+BUFFINFO.buf_ID],(buf_visit*256)+0FFh ; free up
 34871 000061F6 E8D200                  	call	SCANPLACE
 34872                                  	; MSDOS 6.0
 34873 000061F9 EB02                    	jmp	short skpbuff
 34874                                  lfnxt2:
 34875 000061FB 8B3D                    	mov	di,[di]
 34876                                  	;mov	di,[di+BUFFINFO.buf_next]
 34877                                  skpbuff:
 34878                                  	; MSDOS 6.0
 34879 000061FD 363B3E[A512]            	cmp	di,[ss:FIRST_BUFF_ADDR]					;hkn;
 34880 00006202 75E2                    	jne	short nxbuffer
 34881                                  
 34882 00006204 36833E[7700]00          	CMP	word [ss:SC_CACHE_COUNT],0 ;LB.  look ahead buffers ?	;AN001;
 34883 0000620A 740D                    	JZ	short GOGETBPB		;LB.  no			;AN001;
 34884 0000620C 363A06[9C12]            	CMP	AL,[ss:CurSC_DRIVE]	;LB.  same as changed drive	;AN001;
 34885 00006211 7506                    	JNZ	short GOGETBPB		;LB.  no			;AN001;
 34886 00006213 36C606[9C12]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ;LB.  invalidate look ahead buffers ;AN000;
 34887                                  ;lfnxt2:
 34888                                  	; MSDOS 3.3
 34889                                  	;call	SKIPVISIT
 34890                                  	;jnz	short nxbuffer
 34891                                  GOGETBPB:
 34892                                  	; MSDOS 3.3 & MSDOS 6.0
 34893                                  	;;lds	di,[es:bp+12h]
 34894                                  	;lds	di,[es:bp+13h] ; MSDOS 6.0	
 34895 00006219 26C57E13                	LDS	DI,[ES:BP+DPB.DRIVER_ADDR]
 34896                                  	; 20/05/2019
 34897                                  	;test	word [di+4],2000h
 34898                                  	;TEST	word [DI+SYSDEV.ATT],ISFATBYDEV
 34899 0000621D F6450520                	TEST	byte [DI+SYSDEV.ATT+1],(ISFATBYDEV>>8)
 34900 00006221 7510                    	JNZ	short GETFREEBUF
 34901                                  	;context DS	    		;hkn; SS is DOSDATA
 34902 00006223 16                      	push	ss
 34903 00006224 1F                      	pop	ds
 34904 00006225 BB0200                  	MOV	BX,2
 34905 00006228 E8C7FC                  	CALL	UNPACK			; Read the first FAT sector into CURBUF
 34906                                  FAIL_OPJ:
 34907 0000622B 72A3                    	JC	short FAIL_OP
 34908 0000622D C53E[E205]              	LDS	DI,[CURBUF]
 34909 00006231 EB13                    	JMP	SHORT GOTGETBUF
 34910                                  
 34911                                  GETFREEBUF:
 34912 00006233 06                      	PUSH	ES			; Get a free buffer for BIOS to use
 34913 00006234 55                      	PUSH	BP
 34914                                  	; MSDOS 3.3
 34915                                  	;LDS	DI,[SS:BUFFHEAD] ; 15/08/2018
 34916                                  	; MSDOS 6.0
 34917 00006235 31D2                    	XOR	DX,DX			;LB.  fake to get 1st	  ;AN000;
 34918                                  ;hkn; SS override
 34919 00006237 368916[0706]            	MOV	[SS:HIGH_SECTOR],DX ; 0	;LB.  buffer addr	  ;AN000;
 34920 0000623C E87A00                  	call	GETCURHEAD		;LB.			  ;AN000;
 34921                                  	; MSDOS 3.3 & MSDOS 6.0
 34922 0000623F E85502                  	call	BUFWRITE
 34923 00006242 5D                      	POP	BP
 34924 00006243 07                      	POP	ES
 34925                                  	;JC	short FAIL_OPJ
 34926 00006244 728A                    	jc	short FAIL_OP
 34927                                  GOTGETBUF:
 34928                                  	;;add	di,16
 34929                                  	;add	di,20 ; MSDOS 6.0
 34930 00006246 83C718                  	ADD	DI,BUFINSIZ
 34931                                  
 34932                                  ;hkn; SS override
 34933 00006249 368C1E[6A03]            	MOV	[SS:CALLXAD+2],DS
 34934                                  	;Context DS			;hkn; SS is DOSDATA
 34935 0000624E 16                      	push	ss
 34936 0000624F 1F                      	pop	ds
 34937 00006250 893E[6803]              	MOV	[CALLXAD],DI
 34938                                  	;mov	al,16h
 34939 00006254 B016                    	MOV	AL,DBPBHL
 34940                                  	;mov	ah,[es:bp+1]
 34941 00006256 268A6601                	MOV	AH,[ES:BP+DPB.UNIT]
 34942 0000625A A3[5A03]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018
 34943 0000625D C606[5C03]02            	MOV	BYTE [DEVCALL_REQFUNC],DEVBPB
 34944 00006262 C706[5D03]0000          	MOV	word [DEVCALL_REQSTAT],0
 34945                                  	;;mov	al,[es:bp+16h]
 34946                                  	;mov	al,[es:bp+17h]
 34947 00006268 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 34948 0000626C A2[6703]                	MOV	[CALLMED],AL
 34949 0000626F 06                      	PUSH	ES
 34950 00006270 1E                      	PUSH	DS
 34951                                  	;;push	word [es:bp+14h]
 34952                                  	;push	word [es:bp+15h] ; MSDOS 6.0
 34953 00006271 26FF7615                	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR+2]
 34954                                  	;;push	word [es:bp+12h]
 34955                                  	;push	word [es:bp+13h] ; MSDOS 6.0
 34956 00006275 26FF7613                	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR]
 34957                                  
 34958                                  ;hkn; DEVCALL is in DOSDATA
 34959 00006279 BB[5A03]                	MOV	BX,DEVCALL
 34960 0000627C 5E                      	POP	SI
 34961 0000627D 1F                      	POP	DS			; DS:SI Points to device header
 34962 0000627E 07                      	POP	ES			; ES:BX Points to call header
 34963                                  	;invoke	DEVIOCALL2
 34964 0000627F E8A3ED                  	call	DEVIOCALL2
 34965 00006282 07                      	POP	ES			; Restore ES:BP
 34966                                  	;Context DS
 34967 00006283 16                      	push	ss		 	;hkn; SS is DOSDATA
 34968 00006284 1F                      	pop	ds
 34969 00006285 8B3E[5D03]              	MOV	DI,[DEVCALL_REQSTAT]
 34970                                  	; MSDOS 3.3
 34971                                  	;test	di,8000h
 34972                                  	;jnz	short FATERRJ
 34973                                  	; MSDOS 6.0
 34974 00006289 09FF                    	or	di,di
 34975 0000628B 7829                    	js	short FATERRJ 		; have error
 34976                                  	;;mov	al,[es:bp+16h]
 34977                                  	;mov	al,[es:bp+17h]  ; MSDOS 6.0
 34978 0000628D 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 34979 00006291 C536[6C03]              	LDS	SI,[CALLBPB]
 34980                                  	;;mov	word [es:bp+1Ch],0
 34981                                  	;mov	word [es:bp+1Dh],0 ; MSDOS 6.0
 34982 00006295 26C7461D0000            	MOV	word [ES:BP+DPB.NEXT_FREE],0 ; recycle scanning pointer
 34983                                  	;invoke	$SETDPB
 34984 0000629B E8DDB1                  	call	_$SETDPB
 34985                                  
 34986                                  ;hkn; SS override
 34987 0000629E 36C53E[6803]            	LDS	DI,[SS:CALLXAD]		; Get back buffer pointer
 34988                                  	;mov	al,[es:bp+8]
 34989 000062A3 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]
 34990                                  
 34991                                  	; MSDOS 3.3
 34992                                  	;;mov	ah,[es:bp+0Fh]
 34993                                  	;MOV	AH,[ES:BP+DPB.FAT_SIZE]
 34994                                  	;;mov	[DI-8],ax
 34995                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AX
 34996                                  
 34997                                  	; MSDOS 6.0
 34998                                  	;mov	[di-0Ah],al
 34999 000062A7 8845F2                  	MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AL 
 35000                                  						;>32mb		  ;AN000;
 35001                                  	;mov	ax,[es:bp+0Fh]
 35002 000062AA 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE]		;>32mb
 35003                                  	;mov	[di-9h],ax			  ;AC000;
 35004 000062AE 8945F3                  	MOV	[DI+BUFFINFO.buf_wrtcntinc-BUFINSIZ],AX 
 35005                                  					;>32mb Correct buffer info ;AC000;
 35006                                  	;Context DS			;hkn; SS is DOSDATA
 35007 000062B1 16                      	push	ss
 35008 000062B2 1F                      	pop	ds
 35009 000062B3 30C0                    	XOR	AL,AL			;Media changed (Z), Carry clear
 35010 000062B5 C3                      	retn
 35011                                  
 35012                                  FATERRJ: 
 35013 000062B6 E94EFE                  	JMP	FATERR
 35014                                  
 35015                                  ;============================================================================
 35016                                  ; STDBUF.ASM
 35017                                  ;============================================================================
 35018                                  ; Retro DOS v2.0 - 12/03/2018
 35019                                  
 35020                                  ;
 35021                                  ; Standard buffer management for MSDOS
 35022                                  ;
 35023                                  
 35024                                  ;.xlist
 35025                                  ;.xcref
 35026                                  ;INCLUDE STDSW.ASM
 35027                                  ;.cref
 35028                                  ;.list
 35029                                  
 35030                                  ;TITLE	STDBUF - MSDOS buffer management
 35031                                  ;NAME	STDBUF
 35032                                  
 35033                                  ;INCLUDE BUF.ASM
 35034                                  
 35035                                  ;============================================================================
 35036                                  ; BUF.ASM
 35037                                  ;============================================================================
 35038                                  ; 31/07/2018 - Retro DOS v3.0
 35039                                  ; Retro DOS v2.0 - 12/03/2018
 35040                                  ;
 35041                                  ; buffer management for MSDOS
 35042                                  ;
 35043                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 35044                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 35045                                  ;
 35046                                  ;SUBTTL SETVISIT,SKIPVISIT -- MANAGE BUFFER SCANS
 35047                                  ;
 35048                                  ;SETVISIT:
 35049                                  ;	; 31/07/2018 - Retro DOS v3.0
 35050                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CAFh
 35051                                  ;; Inputs:
 35052                                  ;;      None
 35053                                  ;; Function:
 35054                                  ;;      Set up a scan of I/O buffers
 35055                                  ;; Outputs:
 35056                                  ;;      All visit flags = 0
 35057                                  ;;              NOTE: This pre-scan is needed because a hard disk error
 35058                                  ;;                    may cause a scan to stop in the middle leaving some
 35059                                  ;;                    visit flags set, and some not set.
 35060                                  ;;      DS:DI Points to [BUFFHEAD]
 35061                                  ;; No other registers altered
 35062                                  ;
 35063                                  ;       LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 35064                                  ;	PUSH    AX
 35065                                  ;       ;;XOR	AX,AX	  ;; MSDOS 2.11
 35066                                  ;	;mov	al,0DFh
 35067                                  ;	mov	al,~buf_visit
 35068                                  ;SETLOOP:
 35069                                  ;       ;;MOV	[DI+7],AL ;; MSDOS 2.11
 35070                                  ;	;and	[DI+5],al
 35071                                  ;	AND	[DI+BUFFINFO.buf_flags],AL
 35072                                  ;       LDS     DI,[DI]
 35073                                  ;       CMP     DI,-1
 35074                                  ;       JNZ     SHORT SETLOOP
 35075                                  ;       POP     AX ; 09/09/2018
 35076                                  ;	LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 35077                                  ;SVISIT_RETN:
 35078                                  ;       RETN
 35079                                  ;
 35080                                  ;SKIPVISIT:
 35081                                  ;	; 31/07/2018 - Retro DOS v3.0
 35082                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CC8h
 35083                                  ;
 35084                                  ;; Inputs:
 35085                                  ;;      DS:DI Points to a buffer
 35086                                  ;; Function:
 35087                                  ;;      Skip visited buffers
 35088                                  ;; Outputs:
 35089                                  ;;      DS:DI Points to next unvisited buffer
 35090                                  ;;      Zero is set if skip to LAST buffer
 35091                                  ;; No other registers altered
 35092                                  ;
 35093                                  ;       CMP     DI,-1
 35094                                  ;       ;retz
 35095                                  ;       JZ	SHORT SVISIT_RETN
 35096                                  ;
 35097                                  ;	;;CMP	BYTE [DI+7],1 ;; MSDOS 2.11
 35098                                  ;       ;;;retnz
 35099                                  ;       ;;JNZ	SHORT SVISIT_RETN
 35100                                  ;
 35101                                  ;	;test	byte [di+5],20h
 35102                                  ;	TEST	byte [DI+BUFFINFO.buf_flags],buf_visit	
 35103                                  ;	JNZ	short SKIPLOOP
 35104                                  ;	
 35105                                  ;	push	ax
 35106                                  ;	or	al,1
 35107                                  ;	pop	ax
 35108                                  ;	retn	
 35109                                  ;
 35110                                  ;SKIPLOOP:
 35111                                  ;	LDS     DI,[DI]
 35112                                  ;       JMP     SHORT SKIPVISIT
 35113                                  
 35114                                  ;============================================================================
 35115                                  ; BUF.ASM, MSDOS 6.0, 1991
 35116                                  ;============================================================================
 35117                                  ; 31/07/2018 - Retro DOS v3.0
 35118                                  ; 04/05/2019 - Retro DOS v4.0
 35119                                  
 35120                                  ;	TITLE	BUF - MSDOS buffer management
 35121                                  ;	NAME	BUF
 35122                                  
 35123                                  ;**	BUF.ASM - Low level routines for buffer cache management
 35124                                  ;
 35125                                  ;	GETCURHEAD
 35126                                  ;	ScanPlace
 35127                                  ;	PLACEBUF
 35128                                  ;	PLACEHEAD
 35129                                  ;	PointComp
 35130                                  ;	GETBUFFR
 35131                                  ;	GETBUFFRB
 35132                                  ;	FlushBuf
 35133                                  ;	BufWrite
 35134                                  ;	SET_RQ_SC_PARMS
 35135                                  ;
 35136                                  ;	Revision history:
 35137                                  ;
 35138                                  ;		AN000  version 4.00  Jan. 1988
 35139                                  ;		A004   PTM 3765 -- Disk reset failed
 35140                                  ;		M039 DB 10/17/90 - Disk write optimization
 35141                                  ;		I001   5.0 PTR 722211 - Preserve CY when in buffer in HMA
 35142                                  
 35143                                  ;Break	<GETCURHEAD -- Get current buffer header>
 35144                                  ;----------------------------------------------------------------------------
 35145                                  ; Procedure Name : GetCurHead
 35146                                  ; Inputs:
 35147                                  ;	 No Inputs
 35148                                  ; Function:
 35149                                  ;	Returns the pointer to the first buffer in Queue
 35150                                  ;	and updates FIRST_BUFF_ADDR
 35151                                  ;       and invalidates LASTBUFFER (recency pointer)
 35152                                  ; Outputs:
 35153                                  ;	DS:DI = pointer to the first buffer in Queue
 35154                                  ;	FIRST_BUFF_ADDR = offset ( DI ) of First buffer in Queue
 35155                                  ;       LASTBUFFER = -1
 35156                                  ; No other registers altered
 35157                                  ;----------------------------------------------------------------------------
 35158                                  
 35159                                  ; 04/05/2019 - Retro DOS v4.0
 35160                                  ; DOSCODE:98D2h (MSDOS 6.21, MSDOS.SYS)
 35161                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35162                                  ; DOSCODE:9876h (MSDOS 5.0, MSDOS.SYS)
 35163                                  
 35164                                  GETCURHEAD:
 35165 000062B9 36C53E[6D00]            	lds	di,[ss:BufferQueue]	; Pointer to the first buffer
 35166 000062BE 36C706[1E00]FFFF        	mov	word [ss:LastBuffer],-1	; invalidate last buffer
 35167 000062C5 36893E[A512]            	mov	[ss:FIRST_BUFF_ADDR],di	; save first buffer address
 35168 000062CA C3                      	retn
 35169                                  
 35170                                  ;Break	<SCANPLACE, PLACEBUF -- PUT A BUFFER BACK IN THE POOL>
 35171                                  ;----------------------------------------------------------------------------
 35172                                  ; Procedure Name : ScanPlace
 35173                                  ; Inputs:
 35174                                  ;	Same as PLACEBUF
 35175                                  ; Function:
 35176                                  ;	Save scan location and call PLACEBUF
 35177                                  ; Outputs:
 35178                                  ;	DS:DI Points to saved scan location
 35179                                  ; All registers, except DS:DI, preserved.
 35180                                  ;----------------------------------------------------------------------------
 35181                                  ;M039: Rewritten to preserve registers.
 35182                                  
 35183                                  ;SCANPLACE:
 35184                                  ;	; 31/07/2018 - Retro DOS v3.0
 35185                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 35186                                  ;	push	es
 35187                                  ;	les	si,[di]
 35188                                  ;	;les	si,[DI+BUFFINFO.buf_link]
 35189                                  ;	call	PLACEBUF
 35190                                  ;	push	es
 35191                                  ;	pop	ds
 35192                                  ;	mov	di,si
 35193                                  ;	pop	es
 35194                                  ;scanplace_retn:
 35195                                  ;	retn	
 35196                                  	
 35197                                  	; MSDOS 6.0
 35198                                  SCANPLACE:
 35199 000062CB FF35                    	push	word [di]
 35200                                  	;push	word [di+BUFFINFO.buf_next] ;Save scan location
 35201 000062CD E80200                  	call	PLACEBUF
 35202 000062D0 5F                      	pop	di
 35203 000062D1 C3                      	retn
 35204                                  
 35205                                  ;----------------------------------------------------------------------------
 35206                                  ; Procedure Name : PlaceBuf
 35207                                  ; Input:
 35208                                  ;	DS:DI points to buffer (DS->BUFFINFO array, DI=offset in array)
 35209                                  ; Function:
 35210                                  ;	Remove buffer from queue and re-insert it in proper place.
 35211                                  ; NO registers altered
 35212                                  ;----------------------------------------------------------------------------
 35213                                  
 35214                                  ;procedure PLACEBUF,NEAR
 35215                                  
 35216                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35217                                  	; 20/05/2019 - Retro DOS v4.0
 35218                                  PLACEBUF:
 35219                                  	; 31/07/2018 - Retro DOS v3.0
 35220                                  
 35221                                  	; MSDOS 6.0
 35222 000062D2 50                      	push	AX			;Save only regs we modify	;AN000;
 35223 000062D3 53                      	push	BX							;AN000;
 35224                                  	; 23/09/2023
 35225                                  	;push	SI							;AN000;
 35226                                  	
 35227 000062D4 8B05                    	mov	ax,[di]
 35228                                  	;mov	ax,[di+BUFFINFO.buf_next]
 35229 000062D6 368B1E[6D00]            	mov	bx,[ss:BufferQueue]	; bx = offset of head of list;smr;SS Override
 35230                                  	
 35231 000062DB 39D8                    	cmp	ax,bx				;Buf = last?		;AN000;
 35232 000062DD 7422                    	je	short nret			;Yes, special case	;AN000;
 35233 000062DF 39DF                    	cmp	di,bx				;Buf = first?		;AN000;
 35234 000062E1 7506                    	jne	short not_first 		;Yes, special case	;AN000;
 35235 000062E3 36A3[6D00]              	mov	[ss:BufferQueue],ax		;smr;SS Override
 35236 000062E7 EB18                    	jmp	short nret 			;Continue with repositioning;AN000;
 35237                                  not_first:
 35238                                  	; 23/09/2023
 35239 000062E9 56                      	push	si
 35240                                  	;mov	si,[di+2]
 35241 000062EA 8B7502                  	mov	SI,[DI+BUFFINFO.buf_prev]	;No, SI = prior Buf	;AN000;
 35242 000062ED 8904                    	mov	[si],ax
 35243                                  	;mov	[SI+BUFFINFO.buf_next],AX	; ax has di->buf_next	;AN000;
 35244 000062EF 96                      	xchg	si,ax
 35245                                  	;mov	[si+2],ax
 35246 000062F0 894402                  	mov	[SI+BUFFINFO.buf_prev],AX	;			;AN000;
 35247                                  	
 35248 000062F3 8B7702                  	mov	SI,[BX+BUFFINFO.buf_prev]	;SI-> last buffer	;AN000;
 35249 000062F6 893C                    	mov	[si],di
 35250                                  	;mov	[SI+BUFFINFO.buf_next],DI	;Add Buf to end of list ;AN000;
 35251 000062F8 897F02                  	mov	[BX+BUFFINFO.buf_prev],DI				;AN000;
 35252 000062FB 897502                  	mov	[DI+BUFFINFO.buf_prev],SI	;Update link in Buf too	;AN000;
 35253 000062FE 891D                    	mov	[di],bx
 35254                                  	;mov	[DI+BUFFINFO.buf_next],BX				;AN000;
 35255                                  	; 23/09/2023
 35256 00006300 5E                      	pop	si
 35257                                  nret:	
 35258                                  	; 23/09/2023							;AN000;
 35259                                  	;pop	SI							;AN000;
 35260 00006301 5B                      	pop	BX							;AN000;
 35261 00006302 58                      	pop	AX							;AN000;
 35262                                  									;AN000;
 35263                                  	;cmp	byte [di+4],0FFh
 35264 00006303 807D04FF                	cmp	byte [di+BUFFINFO.buf_ID],-1	; Buffer FREE?		;AN000;
 35265 00006307 7505                            jne	short pbx			; M039: -no, jump.
 35266 00006309 36893E[6D00]            	mov	[ss:BufferQueue],di		; M039: -yes, make it LRU.
 35267                                  pbx:	
 35268 0000630E C3                      	retn								;AN000;
 35269                                  
 35270                                  	; 31/07/2018 - Retro DOS v3.0
 35271                                  
 35272                                  	; MSDOS 3.3
 35273                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 35274                                  
 35275                                  ;PLACEBUF:
 35276                                  ;	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 35277                                  ;	
 35278                                  ;       CALL	save_world
 35279                                  ;       LES     CX,[DI]
 35280                                  ;       CMP     CX,-1           	; Buf is LAST?
 35281                                  ;       JZ      SHORT NRET		; Buffer already last
 35282                                  ;       MOV     BP,ES           	; Pointsave = Buf.nextbuf
 35283                                  ;       PUSH    DS
 35284                                  ;       POP     ES              	; Buf is ES:DI
 35285                                  ;	; 15/03/2018
 35286                                  ;       LDS     SI,[SS:BUFFHEAD] 	; Curbuf = HEAD
 35287                                  ;       CALL    POINTCOMP       	; Buf == HEAD?
 35288                                  ;       JNZ     SHORT BUFLOOP
 35289                                  ;       MOV     [SS:BUFFHEAD],CX
 35290                                  ;       MOV     [SS:BUFFHEAD+2],BP	; HEAD = Pointsave
 35291                                  ;       JMP     SHORT LOOKEND
 35292                                  ;BUFLOOP:
 35293                                  ;	; 31/07/2018
 35294                                  ;	mov	ax,ds
 35295                                  ;	mov	bx,si
 35296                                  ;	;lds	si,[SI+BUFFINFO.buf_link]
 35297                                  ;       LDS     SI,[SI]
 35298                                  ;       CALL    POINTCOMP
 35299                                  ;       jnz	short BUFLOOP
 35300                                  ;	;
 35301                                  ;	mov	ds,ax
 35302                                  ;	mov	si,bx
 35303                                  ;	mov	[SI],cx
 35304                                  ;	;mov	[SI+BUFFINFO.buf_link],cx   ; If Curbuf.nextbuf == buf
 35305                                  ;	mov	[SI+2],bp
 35306                                  ;	;mov	[BX+BUFFINFO.buf_link+2],bp ; Curbuf.nextbuf = Pointsave
 35307                                  ;LOOKEND:
 35308                                  ;	mov	ax,ds
 35309                                  ;	mov	bx,si
 35310                                  ;       LDS     SI,[SI]
 35311                                  ;       CMP     SI,-1
 35312                                  ;       jnz     short LOOKEND
 35313                                  ;GOTHEEND:
 35314                                  ;       mov	ds,ax
 35315                                  ;	mov	[BX],di
 35316                                  ;	MOV     [BX+2],ES 		; Curbuf.nextbuf = Buf
 35317                                  ;       MOV     WORD [ES:DI],-1
 35318                                  ;	;mov	word [ES:DI+BUFFINFO.buf_link],-1
 35319                                  ;       MOV     WORD [ES:DI+2],-1 	; Buf is LAST
 35320                                  ;	;mov	word [ES:DI+BUFFINFO.buf_link+2],-1
 35321                                  ;NRET:
 35322                                  ;       CALL	restore_world
 35323                                  ;	
 35324                                  ;	;cmp	byte [di+4],-1
 35325                                  ;	cmp	byte [DI+BUFFINFO.buf_ID],-1  ; Free buffer ?
 35326                                  ;	jnz     short scanplace_retn
 35327                                  ;	call    PLACEHEAD
 35328                                  ;	retn
 35329                                  
 35330                                  ;EndProc PLACEBUF
 35331                                  
 35332                                  ;M039 - Removed PLACEHEAD.
 35333                                  ;----------------------------------------------------------------------------
 35334                                  ; places buffer at head
 35335                                  ;  NOTE:::::: ASSUMES THAT BUFFER IS CURRENTLY THE LAST
 35336                                  ;	ONE IN THE LIST!!!!!!!
 35337                                  ; BUGBUG ---- this routine can be removed because it has only
 35338                                  ; BUGBUG ---- one instruction. This routine is called from
 35339                                  ; BUGBUG ---- 3 places. ( Size = 3*3+6 = 15 bytes )
 35340                                  ; BUGBUG ---- if coded in line = 3 * 5 = 15 bytes
 35341                                  ; BUGBUG ---- But kept as it is for modularity
 35342                                  ;----------------------------------------------------------------------------
 35343                                  ;procedure   PLACEHEAD,NEAR
 35344                                  ;	mov	word ptr [BufferQueue], di
 35345                                  ;	ret
 35346                                  ;EndProc PLACEHEAD
 35347                                  ;M039
 35348                                  
 35349                                  ;----------------------------------------------------------------------------
 35350                                  ; Procedure Name : PLACEHEAD
 35351                                  ;
 35352                                  ; SAME AS PLACEBUF except places buffer at head
 35353                                  ;----------------------------------------------------------------------------
 35354                                  
 35355                                  	; MSDOS 3.3 (Retro DOS v3.0)
 35356                                  	; 05/09/2018
 35357                                  	; MSDOS 2.11 (Retro DOS v2.0)
 35358                                  ;PLACEHEAD:
 35359                                  ;	; 31/07/2018 - Retro DOS v3.0
 35360                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D4Ah
 35361                                  ;
 35362                                  ;       CALL	save_world
 35363                                  ;       PUSH	DS
 35364                                  ;       POP	ES
 35365                                  ;	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 35366                                  ;       LDS     SI,[SS:BUFFHEAD]
 35367                                  ;	; 31/07/2018 - Retro DOS v3.0 (MSDOS 3.3)
 35368                                  ;	CALL    POINTCOMP
 35369                                  ;       JZ      SHORT GOTHEEND2
 35370                                  ;	MOV	[ES:DI],SI
 35371                                  ;	;mov	[ES:DI+BUFFINFO.buf_link],si
 35372                                  ;       MOV	[ES:DI+2],DS
 35373                                  ;	;mov	[ES:DI+BUFFINFO.buf_link+2],ds
 35374                                  ;       MOV	[SS:BUFFHEAD],DI
 35375                                  ;       MOV	[SS:BUFFHEAD+2],ES
 35376                                  ;LOOKEND2:
 35377                                  ;       mov	ax,ds
 35378                                  ;	mov	bx,si
 35379                                  ;	;lds	si,[SI+BUFFINFO.buf_link]
 35380                                  ;       LDS     SI,[SI]
 35381                                  ;       CALL    POINTCOMP
 35382                                  ;       JNZ	SHORT LOOKEND2 ; 05/09/2018
 35383                                  ;       mov	ds,ax
 35384                                  ;	mov	word [bx],-1
 35385                                  ;	;mov	word [BX+BUFFINFO.buf_link],-1
 35386                                  ;	mov	word [bx+2],-1
 35387                                  ;	;mov	word [BX+BUFFINFO.buf_link+2],-1
 35388                                  ;GOTHEEND2:
 35389                                  ;      	call	restore_world
 35390                                  ;placehead_retn:
 35391                                  ;	retn
 35392                                  
 35393                                  ; 20/05/2019 - Retro DOS v4.0
 35394                                  ; DOSCODE:9928h (MSDOS 6.21, MSDOS.SYS)
 35395                                  
 35396                                  ;Break	<POINTCOMP -- 20 BIT POINTER COMPARE>
 35397                                  ;----------------------------------------------------------------------------
 35398                                  ;
 35399                                  ; Procedure Name : PointComp
 35400                                  ; Inputs:
 35401                                  ;         DS:SI & ES:DI
 35402                                  ; Function:
 35403                                  ;          Checks for ((SI==DI) && (ES==DS))
 35404                                  ;	   Assumes that pointers are normalized for the
 35405                                  ;	   same segment
 35406                                  ;
 35407                                  ; Compare DS:SI to ES:DI (or DS:DI to ES:SI) for equality
 35408                                  ; DO NOT USE FOR < or >
 35409                                  ; No Registers altered
 35410                                  ;
 35411                                  ;----------------------------------------------------------------------------
 35412                                  
 35413                                  POINTCOMP:
 35414                                  	; 31/07/2018 - Retro DOS v3.0
 35415                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D84h
 35416 0000630F 39FE                    	CMP	SI,DI
 35417 00006311 750A                    	jnz	short _ret_label	; return if nz
 35418                                  	;jnz	short placehead_retn 
 35419 00006313 51                      	PUSH	CX
 35420 00006314 52                      	PUSH	DX
 35421 00006315 8CD9                    	MOV	CX,DS
 35422 00006317 8CC2                    	MOV	DX,ES
 35423 00006319 39D1                    	CMP	CX,DX
 35424 0000631B 5A                      	POP	DX
 35425 0000631C 59                      	POP	CX
 35426                                  _ret_label:
 35427 0000631D C3                      	retn
 35428                                  
 35429                                  ; 01/08/2018 - Retro DOS v3.0
 35430                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D93h 
 35431                                  
 35432                                  ;Break	<GETBUFFR, GETBUFFRB -- GET A SECTOR INTO A BUFFER>
 35433                                  
 35434                                  ;**	GetBuffr - Get a non-FAT Sector into a Buffer
 35435                                  ;----------------------------------------------------------------------------
 35436                                  ;	GetBuffr does normal ( non-FAT ) sector buffering
 35437                                  ;	It gets the specified local sector into one of the I/O buffers
 35438                                  ;	and shuffles the queue
 35439                                  ; 
 35440                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 35441                                  ;		       ELSE no pre-read
 35442                                  ;		(DX) = Desired physical sector number	      (LOW)
 35443                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 35444                                  ;		(ES:BP) = Pointer to drive parameters
 35445                                  ;		ALLOWED set in case of INT 24
 35446                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 35447                                  ;		'C' clear if OK
 35448                                  ;		CURBUF Points to the Buffer for the sector
 35449                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 35450                                  ;	USES	AX, BX, CX, SI, DI, Flags
 35451                                  ;----------------------------------------------------------------------------
 35452                                  
 35453                                  ;**	GetBuffrb - Get a FAT Sector into a Buffer
 35454                                  ;----------------------------------------------------------------------------
 35455                                  ;	GetBuffrb reads a sector from the FAT file system's FAT table.
 35456                                  ;	It gets the specified sector into one of the I/O buffers
 35457                                  ;	and shuffles the queue. We need a special entry point so that
 35458                                  ;	we can read the alternate FAT sector if the first read fails, also
 35459                                  ;	so we can mark the buffer as a FAT sector.
 35460                                  ; 
 35461                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 35462                                  ;		       ELSE no pre-read
 35463                                  ;		(DX) = Desired physical sector number	     (LOW)
 35464                                  ;		(SI) != 0
 35465                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 35466                                  ;		(ES:BP) = Pointer to drive parameters
 35467                                  ;		ALLOWED set in case of INT 24
 35468                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 35469                                  ;		'C' clear if OK
 35470                                  ;		CUR ddBUF Points to the Buffer for the sector
 35471                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 35472                                  ;	USES	AX, BX, CX, SI, DI, Flags
 35473                                  ;----------------------------------------------------------------------------
 35474                                  
 35475                                  	; 22/09/2023 - RetroDOS v4.2 MSDOS.SYS (optimization)
 35476                                  GETBUFFRC:
 35477 0000631E C706[0706]0000          	mov	word [HIGH_SECTOR],0
 35478                                  GETBUFFRA:
 35479 00006324 30C0                    	xor	al,al
 35480 00006326 BE0100                  	mov	si,1
 35481 00006329 EB09                    	jmp	short GETBUFFRB
 35482                                  
 35483                                  	; 22/09/2023
 35484                                  GETBUFFER:
 35485 0000632B 30C0                    	xor	al,al
 35486                                  GETBUFFRD:
 35487                                  	;mov	byte [ALLOWED],18h
 35488 0000632D C606[4B03]18            	mov	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 35489                                  
 35490                                  	; 20/05/2019 - Retro DOS v4.0
 35491                                  	; DOSCODE:9937h (MSDOS 6.21, MSDOS.SYS)
 35492                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35493                                  	; DOSCODE:98DBh (MSDOS 5.0, MSDOS.SYS)
 35494                                  GETBUFFR:
 35495 00006332 31F6                    	XOR	SI,SI
 35496                                  
 35497                                  ;	This entry point is called for FAT buffering with SI != 0
 35498                                  
 35499                                  GETBUFFRB:
 35500 00006334 A3[9405]                	MOV	[PREREAD],AX			; save pre-read flag
 35501                                  	; 15/12/2022
 35502 00006337 268A4600                	mov	al,[ES:BP]
 35503                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 35504                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 35505 0000633B C53E[1E00]              	LDS	DI,[LastBuffer]			; Get the recency pointer
 35506                                  	; MSDOS 6.0
 35507                                  ;hkn; SS override
 35508 0000633F 368B0E[0706]            	MOV	CX,[SS:HIGH_SECTOR]		; F.C. >32mb	;AN000;
 35509                                  
 35510                                  ;	See if this is the buffer that was most recently returned.
 35511                                  ;	A big performance win if it is.
 35512                                  
 35513 00006344 83FFFF                  	CMP	DI,-1				; Recency pointer valid?
 35514 00006347 7412                    	je	short getb5			; No
 35515                                  	;cmp	dx,[di+6]
 35516 00006349 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 35517 0000634C 750D                    	JNZ	short getb5			; Wrong sector
 35518                                  	
 35519                                  	; MSDOS 6.0
 35520                                  	;cmp	cx,[di+8]
 35521 0000634E 3B4D08                  	CMP	CX,[DI+BUFFINFO.buf_sector+2]	; F.C. >32mb	;AN000;
 35522 00006351 7508                    	JNZ	short getb5			; F.C. >32mb	;AN000;
 35523                                  	
 35524                                  	;cmp	al,[di+4]
 35525 00006353 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 35526                                  	;JZ	getb35				; Just asked for same buffer
 35527 00006356 7503                    	jnz	short getb5
 35528                                  	;jmp	getb35
 35529                                  	; 17/12/2022
 35530                                  	; 28/07/2019
 35531 00006358 E9C700                  	jmp	getb35x
 35532                                  	; 07/12/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 35533                                  	;jmp	getb35
 35534                                  
 35535                                  ;	It's not the buffer most recently returned. See if it's in the
 35536                                  ;	cache.
 35537                                  ;
 35538                                  ;	(cx:dx) = sector #
 35539                                  ;	(al) = drive #
 35540                                  ;	(si) = 0 iff non fat sector, != 0 if FAT sector read
 35541                                  ;	??? list may be incomplete ???
 35542                                  
 35543                                  getb5:	
 35544                                  	; MSDOS 3.3
 35545                                  	;lds	di,[SS:BUFFHEAD]
 35546                                  	; MSDOS 6.0
 35547 0000635B E85BFF                  	CALL	GETCURHEAD			; get Q Head
 35548                                  getb10:	
 35549                                  	;cmp	dx,[di+6]
 35550 0000635E 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 35551 00006361 750D                    	jne	short getb12			; wrong sector lo
 35552                                  	
 35553                                  	; MSDOS 6.0
 35554                                  	;cmp	cx,[di+8]
 35555 00006363 3B4D08                  	CMP	CX,[DI+BUFFINFO.buf_sector+2]
 35556 00006366 7508                    	jne	short getb12			; wrong sector hi
 35557                                  	
 35558                                  	;cmp	al,[di+4]
 35559 00006368 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 35560                                  	;je	short getb25 ; 05/09/2018	; Found the requested sector
 35561 0000636B 7503                    	jne	short getb12
 35562 0000636D E98C00                  	jmp	getb25
 35563                                  getb12:	
 35564                                  	; MSDOS 3.3
 35565                                  	;;mov	di,[DI]
 35566                                  	;;;mov	di,[DI+BUFFINFO.buf_link]
 35567                                  	;
 35568                                  	; 15/08/2018
 35569                                  	;lds	di,[di]
 35570                                  
 35571                                  	;cmp	di,-1 ; 0FFFFh
 35572                                  	;jne	short getb10
 35573                                  	;lds	di,[SS:BUFFHEAD]
 35574                                  
 35575                                  	; MSDOS 6.0
 35576 00006370 8B3D                    	mov	di,[di]
 35577                                  	;mov	DI,[DI+BUFFINFO.BUF_NEXT]
 35578 00006372 363B3E[A512]            	cmp	DI,[SS:FIRST_BUFF_ADDR]		; back at the front again?
 35579 00006377 75E5                    	jne	short getb10			; no, continue looking
 35580                                  
 35581                                  ;	The requested sector is not available in the buffers. DS:DI now points
 35582                                  ;	to the first buffer in the Queue. Flush the first buffer & read in the
 35583                                  ;	new sector into it.
 35584                                  ;
 35585                                  ;	BUGBUG - what goes on here? Isn't the first guy the most recently
 35586                                  ;	used guy? Shuld be for fast lookup. If he is, we shouldn't take
 35587                                  ;	him, we should take LRU. And the above lookup shouldn't be
 35588                                  ;	down a chain, but should be hashed.
 35589                                  ;
 35590                                  ;	(DS:DI) = first buffer in the queue
 35591                                  ;	(CX:DX) = sector # we want
 35592                                  ;	(si) = 0 iff non fat sector, != 0 if FAT sector read
 35593                                  
 35594                                  	; MSDOS 3.3 & MSDOS 6.0
 35595                                  ;hkn; SS override
 35596 00006379 51                      	PUSH	CX  ; MSDOS 6.0
 35597 0000637A 56                      	push	si
 35598 0000637B 52                      	push	dx
 35599 0000637C 55                      	push	bp
 35600 0000637D 06                      	push	es
 35601 0000637E E81601                  	CALL	BUFWRITE			; Write out the dirty buffer
 35602 00006381 07                      	pop	es
 35603 00006382 5D                      	pop	bp
 35604 00006383 5A                      	pop	dx
 35605 00006384 5E                      	pop	si
 35606 00006385 368F06[0706]            	POP	word [SS:HIGH_SECTOR]  ; MSDOS 6.0
 35607                                  	;jc	short getbx			; if got hard error
 35608 0000638A 7303                    	jnc	short getb13
 35609 0000638C E99D00                  	jmp	getbx
 35610                                  
 35611                                  getb13:
 35612                                  	; MSDOS 6.0
 35613 0000638F E88F01                  	CALL	SET_RQ_SC_PARMS 		; set parms for secondary cache
 35614                                  
 35615                                  ;	We're ready to read in the buffer, if need be. If the caller
 35616                                  ;	wanted to just *write* the buffer then we'll skip reading it in.
 35617                                  
 35618 00006392 30E4                    	XOR	AH,AH				; initial flags
 35619                                  ;hkn; SS override
 35620                                  	;test	byte [ss:PREREAD],0FFh
 35621                                  	;jnz	short getb20
 35622 00006394 363826[9405]            	CMP	[SS:PREREAD],ah ; 0		; am to Read in the new sector?
 35623 00006399 7549                    	JNZ	short getb20			; no, we're done
 35624                                  	;;lea	bx,[di+16] ; MSDOS 3.3
 35625                                  	;lea	bx,[di+20] ; MSDOS 6.0
 35626 0000639B 8D5D18                  	LEA	BX,[DI+BUFINSIZ] 		; (ds:bx) = data address
 35627                                  	;MOV	CX,1
 35628                                  	; 22/09/2023
 35629 0000639E 29C9                    	sub	cx,cx ; 0
 35630 000063A0 56                      	push	si
 35631 000063A1 57                      	push	di
 35632 000063A2 52                      	push	dx
 35633                                  	; MSDOS 6.0
 35634 000063A3 06                      	push	es ; ***
 35635                                  
 35636                                  ; Note: As far as I can tell, all disk reads into buffers go through
 35637                                  ;	this point. -mrw 10/88
 35638                                  	
 35639                                  	;cmp	byte [ss:BuffInHMA],0	; is buffers in HMA?
 35640                                  	; 22/09/2023
 35641 000063A4 36380E[7900]            	cmp	[ss:BuffInHMA],cl ; 0
 35642 000063A9 7407                    	jz	short getb14
 35643 000063AB 1E                      	push	ds ; **
 35644 000063AC 53                      	push	bx ; *
 35645 000063AD 36C51E[7A00]            	lds	bx,[ss:LoMemBuff]	; Then let's read it into scratch buff
 35646                                  getb14:
 35647                                  ;M039: Eliminated redundant HMA code.
 35648                                  
 35649                                  	; 22/09/2023
 35650 000063B2 41                      	inc	cx ; cx = 1
 35651                                  
 35652                                  	; MSDOS 3.3 (& MSDOS 6.0)
 35653 000063B3 09F6                    	OR	SI,SI			; FAT sector ?
 35654 000063B5 7407                    	JZ	short getb15		
 35655                                  
 35656 000063B7 E89BDB                  	call	FATSECRD
 35657                                  	;mov	ah,2
 35658 000063BA B402                    	MOV	AH,buf_isFAT		; Set buf_flags
 35659                                  
 35660 000063BC EB05                    	JMP	SHORT getb17		; Buffer is marked free if read barfs
 35661                                  
 35662                                  getb15:
 35663 000063BE E8C0DB                  	call	DREAD			; Buffer is marked free if read barfs
 35664 000063C1 B400                    	MOV	AH,0			; Set buf_flags to no type, DO NOT XOR!
 35665                                  getb17:
 35666                                  	; 17/12/2022	
 35667                                  ; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 35668                                  ;%if 0
 35669                                  	; MSDOS 6.0							  ;I001
 35670 000063C3 9C                      	pushf								  ;I001
 35671 000063C4 36803E[7900]00          	cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ? ;I001
 35672 000063CA 7411                    	jz	short not_in_hma	; no				  ;I001
 35673                                  	;mov	cx,[es:bp+2]
 35674 000063CC 268B4E02                	mov	cx,[ES:BP+DPB.SECTOR_SIZE]				  ;I001
 35675 000063D0 D1E9                    	shr	cx,1							  ;I001
 35676 000063D2 9D                      	popf				; Retrieve possible CY from DREAD ;I001
 35677 000063D3 89DE                    	mov	si,bx							  ;I001
 35678 000063D5 5F                      	pop	di ; *							  ;I001
 35679 000063D6 07                      	pop	es ; **							  ;I001
 35680 000063D7 FC                      	cld								  ;I001
 35681 000063D8 9C                      	pushf				; Preserve possible CY from DREAD ;I001
 35682 000063D9 F3A5                    	rep	movsw			; move the contents of scratch buf;I001
 35683 000063DB 06                      	push	es							  ;I001
 35684 000063DC 1F                      	pop	ds							  ;I001
 35685                                  ;%endif
 35686                                  
 35687                                  ; 17/12/2022
 35688                                  %if 0
 35689                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 35690                                  	; MSDOS 5.0
 35691                                  	pushf
 35692                                  	cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ?
 35693                                  	jz	short not_in_hma	; no
 35694                                  	popf
 35695                                  	mov	cx,[ES:BP+DPB.SECTOR_SIZE]
 35696                                  	shr	cx,1
 35697                                  	mov	si,bx
 35698                                  	pop	di ; *
 35699                                  	pop	es ; **
 35700                                  	cld
 35701                                  	rep	movsw
 35702                                  	push	es
 35703                                  	pop	ds
 35704                                  	jmp	short getb19 ; 27/11/2022
 35705                                  %endif
 35706                                  
 35707                                  not_in_hma:								  ;I001
 35708 000063DD 9D                      	popf							 	  ;I001
 35709                                  getb19:
 35710 000063DE 07                      	pop	es ; ***
 35711 000063DF 5A                      	pop	dx
 35712 000063E0 5F                      	pop	di
 35713 000063E1 5E                      	pop	si
 35714 000063E2 7248                    	JC	short getbx
 35715                                  
 35716                                  ;	The buffer has the data setup in it (if we were to read)
 35717                                  ;	Setup the various buffer fields
 35718                                  ;
 35719                                  ;	(ds:di) = buffer address
 35720                                  ;	(es:bp) = DPB address
 35721                                  ;	(HIGH_SECTOR:DX) = sector #
 35722                                  ;	(ah) = BUF_FLAGS value
 35723                                  ;	(si) = 0 if non fat sector, != 0 if FAT sector read
 35724                                  
 35725                                  ;hkn; SS override
 35726                                  getb20:	; MSDOS 6.0
 35727 000063E4 368B0E[0706]            	MOV	CX,[SS:HIGH_SECTOR]
 35728                                  	;mov	[di+8],cx
 35729 000063E9 894D08                  	MOV	[DI+BUFFINFO.buf_sector+2],CX
 35730                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 35731                                   	;mov	[di+6],dx
 35732 000063EC 895506                  	MOV	[DI+BUFFINFO.buf_sector],DX
 35733                                  	;;mov	[di+0Ah],bp  ; MSDOS 3.3
 35734                                  	;mov	[di+0Dh],bp  ; MSDOS 6.0
 35735 000063EF 896D0F                  	MOV	[DI+BUFFINFO.buf_DPB],BP
 35736                                  	;;mov	[di+0Ch],es
 35737                                  	;mov	[di+0Fh],es  ; MSDOS 6.0
 35738 000063F2 8C4511                  	MOV	[DI+BUFFINFO.buf_DPB+2],ES
 35739                                  	; 15/12/2022
 35740 000063F5 268A4600                	mov	al,[es:bp]
 35741                                  	;mov	al,[es:bp+0]
 35742                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35743                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 35744                                  	;mov	[di+4],ax
 35745 000063F9 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX		; Set ID and Flags
 35746                                  getb25:	
 35747                                  	; MSDOS 3.3
 35748                                  	;mov     ax,1
 35749                                  
 35750                                  	; MSDOS 6.0
 35751                                  	;mov	byte [di+0Ah],1
 35752 000063FC C6450A01                	MOV	byte [DI+BUFFINFO.buf_wrtcnt],1	; Default to not a FAT sector ;AC000;
 35753 00006400 31C0                    	XOR	AX,AX
 35754                                  
 35755                                  	; MSDOS 3.3 (& MSDOS 6.0)
 35756 00006402 09F6                    	OR	SI,SI				; FAT sector ?
 35757 00006404 740B                    	JZ	short getb30
 35758                                  
 35759                                  	;mov	al,[es:bp+8]
 35760 00006406 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]	; update number of copies of
 35761                                  	
 35762                                  	; MSDOS 6.0
 35763 0000640A 88450A                  	MOV	[DI+BUFFINFO.buf_wrtcnt],AL	;  this sector present on disk
 35764                                  	;mov	ax,[es:bp+0Fh]
 35765 0000640D 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE]		; offset of identical FAT
 35766                                  						;  sectors
 35767                                  	; MSDOS 3.3
 35768                                  	;;mov	ah,[es:bp+0Fh]
 35769                                  	;MOV	AH,[ES:BP+DPB.FAT_SIZE]
 35770                                  
 35771                                  ;	BUGBUG - dos 6 can clean this up by not setting wrtcntinc unless wrtcnt
 35772                                  ;		is set
 35773                                  
 35774                                  getb30:	
 35775                                  	; MSDOS 6.0
 35776                                  	;mov	[di+0Bh],ax
 35777 00006411 89450B                  	MOV	[DI+BUFFINFO.buf_wrtcntinc],AX
 35778                                  
 35779                                  	; MSDOS 3.3
 35780                                  	;;mov	[di+8],ax ; 15/08/2018	
 35781                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt],AX
 35782                                  
 35783 00006414 E8BBFE                  	CALL	PLACEBUF
 35784                                  
 35785                                  ;hkn; SS override for next 4
 35786                                  getb35: 
 35787                                  	; 17/12/2022
 35788                                  	; 07/12/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 35789                                  	; MSDOS 3.3 & MSDOS 5.0 & MSDOS 6.0
 35790                                  	;MOV	[SS:CURBUF+2],DS
 35791                                  	;MOV	[SS:LastBuffer+2],DS
 35792                                  	;MOV	[SS:CURBUF],DI
 35793                                  	;MOV	[SS:LastBuffer],DI
 35794                                  	;CLC
 35795                                  
 35796                                  	; 17/12/2022
 35797                                  	; 07/12/2022
 35798                                  	; Retro DOS v4.0
 35799 00006417 368C1E[2000]            	mov	[ss:LastBuffer+2],ds
 35800 0000641C 36893E[1E00]            	mov	[ss:LastBuffer],di
 35801 00006421 F8                      	clc
 35802                                  getb35x: ; 28/07/2019
 35803 00006422 368C1E[E405]            	MOV	[ss:CURBUF+2],ds
 35804 00006427 36893E[E205]            	MOV	[ss:CURBUF],di
 35805                                  
 35806                                  ;	Return with 'C' set appropriately
 35807                                  ;	(dx) = caller's original value
 35808                                  
 35809                                  getbx:	
 35810 0000642C 16                      	push	ss
 35811 0000642D 1F                      	pop	ds
 35812                                  	;retn
 35813                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 35814                                  getbuffrb_retn:
 35815                                  ;flushbuf_retn:	; 17/12/2022
 35816 0000642E C3                      	retn
 35817                                  
 35818                                  ;Break	<FLUSHBUF -- WRITE OUT DIRTY BUFFERS>
 35819                                  ;----------------------------------------------------------------------------
 35820                                  ; Input:
 35821                                  ;	DS = DOSGROUP
 35822                                  ;	AL = Physical unit number local buffers only
 35823                                  ;	   = -1 for all units and all remote buffers
 35824                                  ; Function:
 35825                                  ;	Write out all dirty buffers for unit, and flag them as clean
 35826                                  ;	Carry set if error (user FAILed to I 24)
 35827                                  ;	    Flush operation completed.
 35828                                  ; DS Preserved, all others destroyed (ES too)
 35829                                  ;----------------------------------------------------------------------------
 35830                                  
 35831                                  	; 20/05/2019 - Retro DOS v4.0
 35832                                  	; DOSCODE:9A35h (MSDOS 6.21, MSDOS.SYS)
 35833                                  
 35834                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35835                                  	; DOSCODE:99DAh (MSDOS 5.0, MSDOS.SYS)
 35836                                  FLUSHBUF:
 35837                                  	; MSDOS 3.3
 35838                                  	;;mov	ah,-1 ; 01/08/2018 - Retro DOS v3.0
 35839                                  	;lds	di,[BUFFHEAD]
 35840                                  
 35841                                  	; MSDOS 6.0
 35842 0000642F E887FE                  	call	GETCURHEAD
 35843                                  	;TEST	word [ss:DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 35844 00006432 36F606[1106]04          	TEST	byte [ss:DOS34_FLAG],FROM_DISK_RESET ; 4
 35845 00006438 7508                    	jnz	short scan_buf_queue
 35846 0000643A 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0			;hkn;
 35847 00006440 7423                    	je	short end_scan
 35848                                  	
 35849                                  scan_buf_queue:
 35850 00006442 E82900                  	call	CHECKFLUSH
 35851                                  	;push	ax  ; MSDOS 3.3
 35852                                  	; MSDOS 6.0
 35853                                  	;mov	ah,[di+4]
 35854 00006445 8A6504                  	mov	ah,[DI+BUFFINFO.buf_ID]
 35855 00006448 363826[2203]            	cmp	[SS:WPERR],ah					;hkn;
 35856 0000644D 7408                    	je	short free_the_buf
 35857                                  	;TEST	word [ss:DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 35858 0000644F 36F606[1106]04          	TEST	byte [ss:DOS34_FLAG],FROM_DISK_RESET ; 4
 35859 00006455 7405                    	jz	short dont_free_the_buf
 35860                                  	; MSDOS 3.3
 35861                                  	;;mov	al,[di+4]
 35862                                  	;mov	al,[DI+BUFFINFO.buf_ID]
 35863                                  	;cmp	[SS:WPERR],al					;hkn;
 35864                                  	; 15/08/2018
 35865                                  	;jne	short dont_free_the_buf	
 35866                                  free_the_buf:
 35867                                  	; MSDOS 6.0 (& MSDOS 3.3)
 35868 00006457 C74504FF00              	mov	word [DI+BUFFINFO.buf_ID],00FFh
 35869                                  dont_free_the_buf:
 35870                                  	;pop	ax  ; MSDOS 3.3 	   	
 35871                                  
 35872                                  	; MSDOS 3.3
 35873                                  	;mov	di,[DI]
 35874                                  	;;mov	di,[DI+BUFFINFO.buf_link] ; .buf_next
 35875                                  	;
 35876                                  	; 15/08/2018
 35877                                  	;lds	di,[di]
 35878                                  	;
 35879                                  	;cmp	di,-1 ; 0FFFFh
 35880                                  	;jnz	short scan_buf_queue 
 35881                                  	
 35882                                  	; MSDOS 6.0
 35883 0000645C 8B3D                    	mov	di,[di]
 35884                                  	;mov	di,[DI+BUFFINFO.buf_next] ; .buf_link
 35885 0000645E 363B3E[A512]            	cmp	di,[SS:FIRST_BUFF_ADDR]				;hkn;
 35886 00006463 75DD                    	jne	short scan_buf_queue
 35887                                  
 35888                                  end_scan:
 35889 00006465 16                      	push	ss
 35890 00006466 1F                      	pop	ds
 35891                                  	; 01/08/2018 - Retro DOS v3.0
 35892                                  	;cmp	byte [FAILERR],0
 35893                                  	;jne	short bad_flush
 35894                                  	;retn
 35895                                  ;bad_flush:
 35896                                  	;stc
 35897                                  	;retn
 35898                                  
 35899                                  	; 17/12/2022
 35900                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 35901                                  	; 01/08/2018 - Retro DOS v3.0
 35902 00006467 803E[4A03]01            	cmp	byte [FAILERR],1
 35903 0000646C F5                      	cmc
 35904                                  flushbuf_retn:
 35905 0000646D C3                      	retn
 35906                                  	
 35907                                  	; 17/12/2022
 35908                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 35909                                  	;cmp	byte [FAILERR],0
 35910                                  	;jne	short bad_flush
 35911                                  	;retn
 35912                                  ;bad_flush:
 35913                                  	;stc
 35914                                  	;retn
 35915                                  
 35916                                  ;----------------------------------------------------------------------------
 35917                                  ;
 35918                                  ; Procedure Name : CHECKFLUSH
 35919                                  ;
 35920                                  ; Inputs : AL - Drive number, -1 means do not check for drive
 35921                                  ;	   DS:DI - pointer to buffer
 35922                                  ;
 35923                                  ; Function : Write out a buffer if it is dirty
 35924                                  ;
 35925                                  ; Carry set if problem (currently user FAILed to I 24)
 35926                                  ;
 35927                                  ;----------------------------------------------------------------------------
 35928                                  
 35929                                  CHECKFLUSH:
 35930                                  	; MSDOS 6.0
 35931 0000646E B4FF                    	mov	ah,-1	; 01/08/2018 Retro DOS v3.0
 35932                                  	;cmp	[di+4],ah
 35933 00006470 386504                  	CMP	[DI+BUFFINFO.buf_ID],AH
 35934 00006473 74F8                    	jz	short flushbuf_retn	; Skip free buffer, carry clear
 35935 00006475 38C4                    	CMP	AH,AL			; 
 35936 00006477 7406                    	JZ	short DOBUFFER		; do this buffer
 35937                                  	;cmp	al,[di+4]
 35938 00006479 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 35939 0000647C F8                      	CLC
 35940 0000647D 75EE                    	jnz	short flushbuf_retn	; Buffer not for this unit or SFT
 35941                                  DOBUFFER:
 35942                                  	;test	byte [di+5],40h
 35943 0000647F F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 35944 00006483 74E8                    	jz	short flushbuf_retn	; Buffer not dirty, carry clear by TEST
 35945 00006485 50                      	PUSH	AX
 35946                                  	;push	word [di+4]
 35947 00006486 FF7504                  	PUSH	WORD [DI+BUFFINFO.buf_ID]
 35948 00006489 E80B00                  	CALL	BUFWRITE
 35949 0000648C 58                      	POP	AX
 35950 0000648D 7206                    	JC	short LEAVE_BUF		; Leave buffer marked free (lost).
 35951                                  	;and	ah,0BFh
 35952 0000648F 80E4BF                  	AND	AH,~buf_dirty		; Buffer is clean, clears carry
 35953                                  	;mov	[di+4],ax
 35954 00006492 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX
 35955                                  LEAVE_BUF:
 35956 00006495 58                      	POP	AX			; Search info
 35957                                  checkflush_retn:
 35958 00006496 C3                      	retn
 35959                                  
 35960                                  ;Break	<BUFWRITE -- WRITE OUT A BUFFER IF DIRTY>
 35961                                  ;----------------------------------------------------------------------------
 35962                                  ;
 35963                                  ;	BufWrite writes a buffer to the disk, if it's dirty.
 35964                                  ;
 35965                                  ;	ENTRY	DS:DI Points to the buffer
 35966                                  ;
 35967                                  ;	EXIT	Buffer marked free
 35968                                  ;		Carry set if error (currently user FAILed to I 24)
 35969                                  ;
 35970                                  ;	USES	All buf DS:DI
 35971                                  ;		HIGH_SECTOR
 35972                                  ;----------------------------------------------------------------------------
 35973                                  
 35974                                  	; 20/05/2019 - Retro DOS v4.0
 35975                                  	; DOSCODE:9AA0h (MSDOS 6.21, MSDOS.SYS)
 35976                                  
 35977                                  
 35978                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35979                                  	; DOSCODE:9A45h (MSDOS 5.0, MSDOS.SYS)
 35980                                  
 35981                                  BUFWRITE:
 35982                                  	; 10/09/2018
 35983                                  	; 01/08/2018 - Retro DOS v3.0
 35984                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E94h
 35985 00006497 B8FF00                  	MOV	AX,00FFH
 35986                                  	;xchg	ax,[di+4]
 35987 0000649A 874504                  	XCHG	AX,[DI+BUFFINFO.buf_ID]	; Free, in case write barfs
 35988 0000649D 3CFF                    	CMP	AL,0FFH
 35989 0000649F 74F5                    	jz      short checkflush_retn	; Buffer is free, carry clear.
 35990                                  	;test	ah,40h
 35991 000064A1 F6C440                  	test	AH,buf_dirty
 35992 000064A4 74F0                    	jz      short checkflush_retn	; Buffer is clean, carry clear.
 35993                                  	; MSDOS 6.0
 35994 000064A6 E89D00                  	call	DEC_DIRTY_COUNT 	; LB. decrement dirty count
 35995                                  
 35996                                  ;hkn; SS override
 35997 000064A9 363A06[2203]            	CMP	AL,[SS:WPERR]
 35998 000064AE 74E6                    	jz      short checkflush_retn	; If in WP error zap buffer
 35999                                  
 36000                                  ;hkn; SS override
 36001                                  	; MSDOS 6.0
 36002 000064B0 36A2[000E]              	MOV	[SS:SC_DRIVE],AL	;LB. set it for invalidation ;AN000;
 36003                                  	
 36004                                  	;;les	bp,[di+10] ; MSDOS 3.3
 36005                                  	;les	bp,[di+13] ; MSDOS 6.0
 36006 000064B4 C46D0F                  	LES	BP,[DI+BUFFINFO.buf_DPB]
 36007                                  	;;lea	bx,[di+16]
 36008                                  	;lea	bx,[di+20] ; MSDOS 6.0
 36009 000064B7 8D5D18                  	LEA	BX,[DI+BUFINSIZ]	; Point at buffer
 36010                                  	;mov	dx,[di+6]
 36011 000064BA 8B5506                  	MOV	DX,[DI+BUFFINFO.buf_sector] ;F.C. >32mb		;AN000;
 36012                                  	
 36013                                  	; MSDOS 6.0
 36014                                  	;mov	cx,[di+8]
 36015 000064BD 8B4D08                  	MOV	CX,[DI+BUFFINFO.buf_sector+2] ;F.C. >32mb	;AN000;
 36016                                  
 36017                                  ;hkn; SS override
 36018 000064C0 36890E[0706]            	MOV	[SS:HIGH_SECTOR],CX	;F.C. >32mb		;AN000;
 36019 000064C5 8A4D0A                  	MOV	CL,[DI+BUFFINFO.buf_wrtcnt] ;>32mb		;AC000;
 36020                                  	; MSDOS 3.3
 36021                                  	;; mov	cx,[DI+8]
 36022                                  	;mov	cx,[DI+BUFFINFO.buf_wrtcnt]
 36023                                  	;MOV	AL,CH			; [DI+BUFFINFO.buf_wrtcntinc]
 36024 000064C8 30ED                    	XOR	CH,CH
 36025                                  	;;mov	ah,ch ; MSDOS 3.3
 36026                                  
 36027                                  ;hkn; SS override for ALLOWED
 36028                                  	;mov	byte [SS:ALLOWED],18h
 36029 000064CA 36C606[4B03]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 36030                                  	;test	byte [di+5],8
 36031                                  	; MSDOS 6.0 (& Retro DOS 3.0)
 36032                                  	;test	ah,8
 36033 000064D0 F6C408                  	test	AH,buf_isDATA
 36034 000064D3 7406                    	JZ	short NO_IGNORE
 36035                                  	;or	byte [SS:ALLOWED],20h
 36036 000064D5 36800E[4B03]20          	OR	byte [SS:ALLOWED],Allowed_IGNORE
 36037                                  NO_IGNORE:
 36038                                  	;xor	ah,ah ; 10/09/2018 (MSDOS 3.3, Retro DOS v3.0)
 36039                                  	; MSDOS 6.0
 36040                                  	;mov	ax,[di+11]
 36041 000064DB 8B450B                  	MOV	AX,[DI+BUFFINFO.buf_wrtcntinc]	;>32mb		;AC000;
 36042                                  
 36043 000064DE 57                      	PUSH	DI		; Save buffer pointer
 36044 000064DF 31FF                    	XOR	DI,DI		; Indicate failure
 36045                                  
 36046 000064E1 1E                      	push	ds ; *
 36047 000064E2 53                      	push	bx ; **
 36048                                  WRTAGAIN:
 36049 000064E3 57                      	push	di ; ***
 36050 000064E4 51                      	push	cx ; ****
 36051 000064E5 50                      	push	ax ; *****
 36052                                  	;MOV	CX,1
 36053                                  	; 17/12/2022
 36054                                  	; ch = 0
 36055 000064E6 B101                    	mov	cl,1 ; 24/07/2019
 36056                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 36057                                  	;mov	cx,1
 36058 000064E8 53                      	push	bx ; ******
 36059 000064E9 52                      	push	dx ; *******
 36060 000064EA 1E                      	push	ds ; ********
 36061                                  
 36062                                  ; Note: As far as I can tell, all disk reads into buffers go through this point. -mrw 10/88
 36063                                  
 36064                                  	; MSDOS 6.0
 36065                                  	;cmp	byte [ss:BuffInHMA],0 ; 10/06/2019
 36066                                  	; 22/09/2023
 36067 000064EB 36382E[7900]            	cmp	[ss:BuffInHMA],ch ; 0
 36068 000064F0 7418                    	jz	short NBUFFINHMA
 36069 000064F2 51                      	push	cx
 36070 000064F3 06                      	push	es
 36071 000064F4 89DE                    	mov	si,bx
 36072 000064F6 268B4E02                	mov	cx,[es:bp+DPB.SECTOR_SIZE]
 36073 000064FA D1E9                    	shr	cx,1
 36074 000064FC 36C43E[7A00]            	les	di,[ss:LoMemBuff] ; 10/06/2019
 36075 00006501 89FB                    	mov	bx,di
 36076 00006503 FC                      	cld
 36077 00006504 F3A5                    	rep	movsw
 36078 00006506 06                      	push	es
 36079 00006507 1F                      	pop	ds
 36080 00006508 07                      	pop	es
 36081 00006509 59                      	pop	cx
 36082                                  NBUFFINHMA:
 36083 0000650A E8D4DA                  	call	DWRITE		; Write out the dirty buffer
 36084 0000650D 1F                      	pop	ds ; ********
 36085 0000650E 5A                      	pop	dx ; *******
 36086 0000650F 5B                      	pop	bx ; ******
 36087 00006510 58                      	pop	ax ; *****
 36088 00006511 59                      	pop	cx ; ****
 36089 00006512 5F                      	pop	di ; ***
 36090 00006513 7201                    	JC	short NOSET
 36091 00006515 47                      	INC	DI		; If at least ONE write succeedes, the operation
 36092                                  NOSET:				;	succeedes.
 36093 00006516 01C2                    	ADD	DX,AX
 36094 00006518 E2C9                    	LOOP	WRTAGAIN
 36095 0000651A 5B                      	pop	bx ; **
 36096 0000651B 1F                      	pop	ds ; *
 36097                                  	;OR	DI,DI		; Clears carry
 36098                                  	;JNZ	short BWROK	; At least one write worked
 36099                                  	;STC			; DI never got INCed, all writes failed.
 36100                                  	; 22/09/2023
 36101 0000651C 83FF01                  	cmp	di,1
 36102                                  BWROK:	
 36103 0000651F 5F                      	POP	DI
 36104 00006520 C3                      	retn
 36105                                  
 36106                                  ;**	Set_RQ_SC_Parms - Set Secondary Cache Parameters
 36107                                  ;----------------------------------------------------------------------------
 36108                                  ;	Set_RQ_SC_Parms sets the sector size and drive number value
 36109                                  ;	for the secondary cache. This updates SC_SECTOR_SIZE &
 36110                                  ;	SC_DRIVE even if SC is disabled to save the testing
 36111                                  ;	code and time
 36112                                  ;
 36113                                  ;	ENTRY	ES:BP = drive parameter block
 36114                                  ;
 36115                                  ;	EXIT	[SC_SECTOR_SIZE]= drive sector size
 36116                                  ;		[SC_DRIVE]= drive #
 36117                                  ;
 36118                                  ;	USES	Flags
 36119                                  ;----------------------------------------------------------------------------
 36120                                  
 36121                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36122                                  ; 04/05/2019 - Retro DOS v4.0
 36123                                  
 36124                                  SET_RQ_SC_PARMS:
 36125                                  ;hkn; SS override for all variables used in this procedure.
 36126 00006521 50                      	push	ax
 36127                                  	;mov	ax,[es:bp+2]
 36128 00006522 268B4602                	MOV	ax,[ES:BP+DPB.SECTOR_SIZE]	; save sector size
 36129 00006526 36A3[FE0D]              	MOV	[ss:SC_SECTOR_SIZE],ax
 36130                                  	;;mov	al,[es:bp+0]
 36131                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 36132                                  	;MOV	al,[ES:BP+DPB.DRIVE]		; save drive #
 36133                                  	; 15/12/2022
 36134 0000652A 268A4600                	mov	al,[ES:BP]
 36135 0000652E 36A2[000E]              	MOV	[ss:SC_DRIVE],al
 36136 00006532 58                      	pop	ax
 36137                                  srspx:	
 36138 00006533 C3                      	retn					;LB. return
 36139                                  
 36140                                  ; 01/02/2024 - Retro DOS v5.0
 36141                                  ;----------------------------------------------------------------------------
 36142                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:AD58h
 36143                                  
 36144                                  SET_BUF_DIRTY:                          ; ...
 36145                                  	;test	byte [es:di+5],40h
 36146 00006534 26F6450540              	test	byte [es:di+BUFFINFO.buf_flags],buf_dirty
 36147 00006539 750A                    	jnz	short yesdirty2
 36148                                  	;or	byte [es:di+5],40h
 36149 0000653B 26804D0540              	or	byte [es:di+BUFFINFO.buf_flags],buf_dirty
 36150                                  
 36151                                  ;INC_DIRTY_COUNT:
 36152                                  ;	inc     word [ss:DirtyBufferCount]
 36153                                  ;yesdirty2:
 36154                                  ;	retn
 36155                                  
 36156                                  ;Break	<INC_DIRTY_COUNT-increment dirty count>
 36157                                  ;----------------------------------------------------------------------------
 36158                                  ; Input:
 36159                                  ;	none
 36160                                  ; Function:
 36161                                  ;	increment dirty buffers count
 36162                                  ; Output:
 36163                                  ;	dirty buffers count is incremented
 36164                                  ;
 36165                                  ; All registers preserved
 36166                                  ;----------------------------------------------------------------------------
 36167                                  
 36168                                  INC_DIRTY_COUNT:
 36169                                  ;; BUGBUG  ---- remove this routine
 36170                                  ;; BUGBUG ---- only one instruction is needed (speed win, space loose)
 36171 00006540 36FF06[7100]            	inc	word [ss:DirtyBufferCount]	;hkn;
 36172                                  yesdirty2:	; 01/02/2024
 36173 00006545 C3                      	retn
 36174                                  
 36175                                  ;Break	<DEC_DIRTY_COUNT-decrement dirty count>
 36176                                  ;----------------------------------------------------------------------------
 36177                                  ; Input:
 36178                                  ;	none
 36179                                  ; Function:
 36180                                  ;	decrement dirty buffers count
 36181                                  ; Output:
 36182                                  ;	dirty buffers count is decremented
 36183                                  ;
 36184                                  ; All registers preserved
 36185                                  ;----------------------------------------------------------------------------
 36186                                  
 36187                                  DEC_DIRTY_COUNT:
 36188 00006546 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0 ;hkn;
 36189 0000654C 7405                    	jz	short ddcx		; BUGBUG - shouldn't it be an
 36190 0000654E 36FF0E[7100]            	dec	word [ss:DirtyBufferCount] 
 36191                                  					; error condition to underflow here? ;hkn;
 36192                                  ddcx:	
 36193 00006553 C3                      	retn
 36194                                  
 36195                                  ;============================================================================
 36196                                  ; MSPROC.ASM, MSDOS 6.0, 1992
 36197                                  ;============================================================================
 36198                                  ; 02/08/2018 - Retro DOS v3.0
 36199                                  ; 29/04/2019 - Retro DOS v4.0
 36200                                  
 36201                                  ; (15/04/2018 - RetrO DOS v2.0, MSDOS 2.11 - PROC.ASM - 1983)
 36202                                  
 36203                                  ; Pseudo EXEC system call for DOS
 36204                                  
 36205                                  ;	TITLE	MSPROC - process maintenance
 36206                                  ;	NAME	MSPROC
 36207                                  
 36208                                  ; =========================================================================
 36209                                  ;**	Process related system calls and low level routines for DOS 2.X.
 36210                                  ;	I/O specs are defined in DISPATCH.
 36211                                  ;
 36212                                  ;	$WAIT
 36213                                  ;	$EXEC
 36214                                  ;	$Keep_process
 36215                                  ;	Stay_resident
 36216                                  ;	$EXIT
 36217                                  ;	$ABORT
 36218                                  ;	abort_inner
 36219                                  ;
 36220                                  ;	Modification history:
 36221                                  ;
 36222                                  ;		Created: ARR 30 March 1983
 36223                                  ;		AN000	version 4.0 jan. 1988
 36224                                  ;		A007	PTM 3957 - fake vesrion for IBMCACHE.COM
 36225                                  ;		A008	PTM 4070 - fake version for MS WINDOWS
 36226                                  ;
 36227                                  ;		M000	added support for loading programs into UMBs 7/9/90
 36228                                  ;
 36229                                  ;		M004 - MS PASCAL 3.2 support. Please see under tag M003 in 
 36230                                  ;		       dossym.inc. 7/30/90
 36231                                  ;		M005 - Support for EXE programs with out STACK segment and 
 36232                                  ;		       with resident size < 64K - 256 bytes. A 256 byte 
 36233                                  ;		       stack is provided at the end of the program. Note that
 36234                                  ;		       only SP is changed.
 36235                                  ;		M020 - Fix for Rational bug for details see exepatch.asm
 36236                                  ;
 36237                                  ;		M028 - 4b04 implementation
 36238                                  ;
 36239                                  ;		M029 - Support for EXEs without stack rewritten. If EXE is
 36240                                  ;			in memory block >= 64K, sp = 0. If memory block
 36241                                  ;			obtained is <64K, point sp at the end of the memory
 36242                                  ;			block. For EXEs smaller than 64K, 256 bytes are still
 36243                                  ;			added for a stack segment which may be needed if it
 36244                                  ;			is loaded in low memory situations.
 36245                                  ;
 36246                                  ;		M030 - Fixing bug in EXEPACPATCH & changing 4b04 to 4b05
 36247                                  ;
 36248                                  ;		M040 - Bug #3052. The environment sizing code would flag a
 36249                                  ;			a bad environment if it reached 32767 bytes. Changed
 36250                                  ;			to allow 32768 bytes of environment.
 36251                                  ;
 36252                                  ;		M047 - Release the allocated UMB when we failed to load a 
 36253                                  ;		       COM file high. Also ensure that if the biggest block
 36254                                  ;		       into which we load the com file is less than 64K then
 36255                                  ;		       we provide atleast 256 bytes of stack to the user.
 36256                                  ;
 36257                                  ;		M050 - Made Lie table search CASE insensitive
 36258                                  ;
 36259                                  ;		M060 - Removed special version table from the kernal and
 36260                                  ;                      put it in a device drive which puts the address
 36261                                  ;                      in the DOS DATA area location UU_IFS_DOS_CALL
 36262                                  ;		       as a DWORD.
 36263                                  ;
 36264                                  ;		M063 - Modified UMB support. If the HIGH_ONLY bit is set on
 36265                                  ;		       entry do not try to load low if there is no space in
 36266                                  ;		       UMBs.
 36267                                  ;
 36268                                  ;		M068 - Support for copy protect apps. Call ChkCopyProt to 
 36269                                  ;		       set a20off_count. Set bit EXECA20BIT in DOS_FLAG. Also
 36270                                  ;		       change return address to LeaveDos if AL=5.
 36271                                  ;
 36272                                  ;               20-Jul-1992 bens  Added ifdef RESTRICTED_BUILD code that
 36273                                  ;                      controls building a version of MSDOS.SYS that only
 36274                                  ;                      runs programs from a fixed list (defined in the
 36275                                  ;                      file RESTRICT.INC).  Search for "RESTRICTED_BUILD"
 36276                                  ;                      for details.  This feature is used to build a
 36277                                  ;                      "special" version of DOS that can be handed out to
 36278                                  ;                      OEM/ISV customers as part of a "service" disk.
 36279                                  ;
 36280                                  ; =========================================================================
 36281                                  
 36282                                  ;SAVEXIT  EQU  10
 36283                                  
 36284                                  ;BREAK	<$WAIT - return previous process error code>
 36285                                  ; =========================================================================
 36286                                  ;	$WAIT - Return previous process error code.
 36287                                  ;
 36288                                  ;	Assembler usage:
 36289                                  ;
 36290                                  ;	    MOV     AH, WaitProcess
 36291                                  ;	    INT     int_command
 36292                                  ;
 36293                                  ;	ENTRY	none
 36294                                  ;	EXIT	(ax) = exit code
 36295                                  ;	USES	all
 36296                                  ; =========================================================================
 36297                                  
 36298                                  	; 20/05/2019 - Retro DOS v4.0
 36299                                  	; DOSCODE:9B55h (MSDOS 6.21, MSDOS.SYS)
 36300                                  
 36301                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36302                                  	; DOSCODE:9A5Ah (MSDOS 5.0, MSDOS.SYS)	
 36303                                  _$WAIT:
 36304                                  	; 02/08/2018 - Retro DOS v3.0
 36305                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E1h
 36306                                  
 36307 00006554 31C0                    	xor	AX,AX
 36308 00006556 368706[3403]            	xchg	AX,[ss:exit_code]
 36309 0000655B E912A1                  	jmp	SYS_RET_OK
 36310                                  
 36311                                  ; =========================================================================
 36312                                  ;BREAK <$exec - load/go a program>
 36313                                  ;	EXEC.ASM - EXEC System Call
 36314                                  ;
 36315                                  ;
 36316                                  ; Assembler usage:
 36317                                  ;	    lds     DX, Name
 36318                                  ;	    les     BX, Blk
 36319                                  ;	    mov     AH, Exec
 36320                                  ;	    mov     AL, FUNC
 36321                                  ;	    int     INT_COMMAND
 36322                                  ;
 36323                                  ;	AL  Function
 36324                                  ;	--  --------
 36325                                  ;	 0  Load and execute the program.
 36326                                  ;	 1  Load, create the program header but do not
 36327                                  ;	    begin execution.
 36328                                  ;	 3  Load overlay. No header created.
 36329                                  ;
 36330                                  ;	    AL = 0 -> load/execute program
 36331                                  ;
 36332                                  ;	    +---------------------------+
 36333                                  ;	    | WORD segment address of	|
 36334                                  ;	    | environment.		|
 36335                                  ;	    +---------------------------+
 36336                                  ;	    | DWORD pointer to ASCIZ	|
 36337                                  ;	    | command line at 80h	|
 36338                                  ;	    +---------------------------+
 36339                                  ;	    | DWORD pointer to default	|
 36340                                  ;	    | FCB to be passed at 5Ch	|
 36341                                  ;	    +---------------------------+
 36342                                  ;	    | DWORD pointer to default	|
 36343                                  ;	    | FCB to be passed at 6Ch	|
 36344                                  ;	    +---------------------------+
 36345                                  ;
 36346                                  ;	    AL = 1 -> load program
 36347                                  ;
 36348                                  ;	    +---------------------------+
 36349                                  ;	    | WORD segment address of	|
 36350                                  ;	    | environment.		|
 36351                                  ;	    +---------------------------+
 36352                                  ;	    | DWORD pointer to ASCIZ	|
 36353                                  ;	    | command line at 80h	|
 36354                                  ;	    +---------------------------+
 36355                                  ;	    | DWORD pointer to default	|
 36356                                  ;	    | FCB to be passed at 5Ch	|
 36357                                  ;	    +---------------------------+
 36358                                  ;	    | DWORD pointer to default	|
 36359                                  ;	    | FCB to be passed at 6Ch	|
 36360                                  ;	    +---------------------------+
 36361                                  ;	    | DWORD returned value of	|
 36362                                  ;	    | CS:IP			|
 36363                                  ;	    +---------------------------+
 36364                                  ;	    | DWORD returned value of	|
 36365                                  ;	    | SS:IP			|
 36366                                  ;	    +---------------------------+
 36367                                  ;
 36368                                  ;	    AL = 3 -> load overlay
 36369                                  ;
 36370                                  ;	    +---------------------------+
 36371                                  ;	    | WORD segment address where|
 36372                                  ;	    | file will be loaded.	|
 36373                                  ;	    +---------------------------+
 36374                                  ;	    | WORD relocation factor to |
 36375                                  ;	    | be applied to the image.	|
 36376                                  ;	    +---------------------------+
 36377                                  ;
 36378                                  ; Returns:
 36379                                  ;	    AX = error_invalid_function
 36380                                  ;	       = error_bad_format
 36381                                  ;	       = error_bad_environment
 36382                                  ;	       = error_not_enough_memory
 36383                                  ;	       = error_file_not_found
 36384                                  ; =========================================================================
 36385                                  ;
 36386                                  ;   Revision history:
 36387                                  ;
 36388                                  ;	 A000	version 4.00  Jan. 1988
 36389                                  ;
 36390                                  ; =========================================================================
 36391                                  
 36392                                  Exec_Internal_Buffer		EQU	OPENBUF
 36393                                  Exec_Internal_Buffer_Size	EQU	(128+128+53+curdirLen)
 36394                                  
 36395                                  ; =========================================================================
 36396                                  
 36397                                  ;IF1		; warning message on buffers
 36398                                  ;%out	Please make sure that the following are contiguous and of the
 36399                                  ;%out	following sizes:
 36400                                  ;%out
 36401                                  ;%out	OpenBuf     128
 36402                                  ;%out	RenBuf	    128
 36403                                  ;%out	SearchBuf    53
 36404                                  ;%out	DummyCDS    curdirLen
 36405                                  ;ENDIF
 36406                                  
 36407                                  ; =========================================================================
 36408                                  
 36409                                  ; =========================================================================
 36410                                  ;
 36411                                  ; =========================================================================
 36412                                  
 36413                                  	; 20/05/2019 - Retro DOS v4.0
 36414                                  	; DOSCODE:9B5Fh (MSDOS 6.21, MSDOS.SYS)
 36415                                  
 36416                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36417                                  	; DOSCODE:9B04h (MSDOS 5.0, MSDOS.SYS)
 36418                                  	
 36419                                  _$EXEC:
 36420                                  	; 02/08/2018 - Retro DOS v3.0
 36421                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5EF1h
 36422                                  
 36423                                  EXEC001S:
 36424                                  	;LocalVar    Exec_Blk		,DWORD
 36425                                  	;LocalVar    Exec_Func		,BYTE
 36426                                  	;LocalVar    Exec_Load_High	,BYTE
 36427                                  	;LocalVar    Exec_FH		,WORD
 36428                                  	;LocalVar    Exec_Rel_Fac	,WORD
 36429                                  	;LocalVar    Exec_Res_Len_Para	,WORD
 36430                                  	;LocalVar    Exec_Environ	,WORD
 36431                                  	;LocalVar    Exec_Size		,WORD
 36432                                  	;LocalVar    Exec_Load_Block	,WORD
 36433                                  	;LocalVar    Exec_DMA		,WORD
 36434                                  	;LocalVar    ExecNameLen 	,WORD
 36435                                  	;LocalVar    ExecName		,DWORD
 36436                                  	;
 36437                                  	;LocalVar    Exec_DMA_Save	,WORD
 36438                                  	;LocalVar    Exec_NoStack	,BYTE
 36439                                  
 36440                                  	; MSDOS 3.3 (& MSDOS 6.0)
 36441                                  	;%define	Exec_Blk	dword [bp-4]
 36442                                  	%define		Exec_Blk	[bp-4] ; 09/08/2018
 36443                                  	%define		Exec_BlkL	word [bp-4]	
 36444                                  	%define		Exec_BlkH	word [bp-2]
 36445                                  	%define		Exec_Func	byte [bp-5]
 36446                                  	%define		Exec_Load_High	byte [bp-6]
 36447                                  	%define		Exec_FH		word [bp-8]
 36448                                  	%define		Exec_Rel_Fac	word [bp-10]
 36449                                  	%define		Exec_Res_Len_Para word [bp-12]
 36450                                  	%define		Exec_Environ	word [bp-14]
 36451                                  	%define		Exec_Size	word [bp-16]
 36452                                  	%define		Exec_Load_Block	word [bp-18]
 36453                                  	%define		Exec_DMA	word [bp-20]
 36454                                  	%define		ExecNameLen	word [bp-22]
 36455                                  	;%define	ExecName	dword [bp-26]
 36456                                  	%define		ExecName	[bp-26] ; 09/08/2018
 36457                                  	%define		ExecNameL	word [bp-26]	
 36458                                  	%define		ExecNameH	word [bp-24]
 36459                                  	; MSDOS 6.0
 36460                                  	%define		Exec_DMA_Save	word [bp-28]
 36461                                  	%define		Exec_NoStack	byte [bp-29]
 36462                                  	
 36463                                  	; ==================================================================
 36464                                  	; validate function
 36465                                  	; ==================================================================
 36466                                  		      	
 36467                                  	; M068 - Start
 36468                                  	;
 36469                                  	; Reset the A20OFF_COUNT to 0. This is done as there is a 
 36470                                  	; possibility that the count may not be decremented all the way to
 36471                                  	; 0. A typical case is if the program for which we intended to keep 
 36472                                  	; the A20  off for a sufficiently long time (A20OFF_COUNT int 21 
 36473                                  	; calls), exits pre-maturely due to error conditions.
 36474                                  
 36475                                  	; MSDOS 6.0
 36476 0000655E 36C606[8500]00          	mov	byte [SS:A20OFF_COUNT], 0
 36477                                  
 36478                                  	; If al=5 (ExecReady) we'll change the return address on the stack	
 36479                                  	; to be LeaveDos in msdisp.asm. This ensures that the EXECA20OFF
 36480                                  	; bit set in DOS_FLAG by ExceReady is not cleared in msdisp.asm
 36481                                  
 36482 00006564 3C05                    	cmp	al,5			; Q: is this ExecReady call
 36483                                  	;jne	short @f
 36484 00006566 7505                    	jne	short Exec_@f		; N: continue
 36485                                  					; Y: change ret addr. to LeaveDos.
 36486 00006568 59                      	pop	cx			; Note CX is not input to ExecReady
 36487 00006569 B9[F603]                	mov	cx,LeaveDOS
 36488 0000656C 51                      	push	cx
 36489                                  ;@@:
 36490                                  Exec_@f:
 36491                                  	; M068 - End
 36492                                  	
 36493                                  	;Enter
 36494                                  
 36495 0000656D 55                      	push	bp
 36496 0000656E 89E5                    	mov	bp,sp
 36497                                  	;;sub	sp,26	; MSDOS 3.3
 36498                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)	
 36499                                  	;sub	sp,29	; MSDOS 6.0 (& MSDOS 6.21)
 36500                                  	; 17/12/2022
 36501                                  	; 20/05/2019
 36502 00006570 83EC1E                  	sub	sp,30	; Retro DOS v4.0	
 36503                                  
 36504                                  	; MSDOS 6.0
 36505 00006573 3C05                    	cmp	AL,5			; only 0, 1, 3 or 5 are allowed ;M028
 36506                                  					; M030
 36507 00006575 7614                    	jna	short Exec_Check_2
 36508                                  
 36509                                  	; MSDOS 3.3
 36510                                  	;cmp	AL,3
 36511                                  	;jna	short Exec_Check_2
 36512                                  
 36513                                  Exec_Bad_Fun:
 36514 00006577 36C606[2303]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; 1
 36515                                  					; Extended Error Locus	;smr;SS Override
 36516                                  	;mov	al,1
 36517 0000657D B001                    	mov	al,error_invalid_function
 36518                                  
 36519                                  Exec_Ret_Err:
 36520                                  	;Leave
 36521 0000657F 89EC                    	mov	sp,bp
 36522 00006581 5D                      	pop	bp
 36523                                  	;transfer SYS_RET_ERR
 36524 00006582 E9F5A0                  	jmp	SYS_RET_ERR
 36525                                  
 36526                                  	; MSDOS 6.0
 36527                                  ExecReadyJ:
 36528 00006585 E8FD17                  	call	ExecReady		; M028
 36529 00006588 E90504                  	jmp	norm_ovl		; do a Leave & xfer sysret_OK ; M028
 36530                                  
 36531                                  Exec_Check_2:
 36532 0000658B 3C02                    	cmp	AL,2			
 36533 0000658D 74E8                    	je	short Exec_Bad_Fun
 36534                                  
 36535                                  	; MSDOS 6.0
 36536 0000658F 3C04                    	cmp	al,4			; 2 & 4 are not allowed
 36537 00006591 74E4                    	je	short Exec_Bad_Fun
 36538                                  	
 36539 00006593 3C05                    	cmp	al,5			; M028 ; M030
 36540 00006595 74EE                    	je	short ExecReadyJ	; M028
 36541                                  
 36542                                  	;mov	[bp-4],bx
 36543 00006597 895EFC                  	mov	Exec_BlkL,BX		; stash args
 36544                                  	;mov	[bp-2],es
 36545 0000659A 8C46FE                  	mov	Exec_BlkH,ES
 36546                                  	;mov	[bp-5],al
 36547 0000659D 8846FB                  	mov	Exec_Func,AL
 36548                                  	;mov	byte [bp-6],0
 36549 000065A0 C646FA00                	mov	Exec_Load_High,0
 36550                                  
 36551                                  	;mov	[bp-26],dx
 36552 000065A4 8956E6                  	mov	ExecNameL,DX		; set up length of exec name
 36553                                  	;mov	[bp-24],ds
 36554 000065A7 8C5EE8                  	mov	ExecNameH,DS
 36555 000065AA 89D6                    	mov	SI,DX			; move pointer to convenient place
 36556                                  	;invoke	DStrLen
 36557 000065AC E840B2                  	call	DStrLen
 36558                                  	;mov	[bp-22],cx
 36559 000065AF 894EEA                  	mov	ExecNameLen,CX		; save length
 36560                                  
 36561                                  	; MSDOS 6.0
 36562 000065B2 36A0[0203]              	mov	al,[ss:AllocMethod]	; M063: save alloc method in 
 36563 000065B6 36A2[8400]              	mov	[ss:ALLOCMSAVE],al	; M063: AllocMsave
 36564                                  
 36565 000065BA 30C0                    	xor	AL,AL			; open for reading
 36566 000065BC 55                      	push	BP
 36567                                  
 36568                                  	; MSDOS 6.0
 36569                                  	;or	byte [ss:DOS_FLAG],1
 36570 000065BD 36800E[8600]01          	or	byte [ss:DOS_FLAG],EXECOPEN ; this flag is set to indicate to 
 36571                                  					; the redir that this open call is
 36572                                  					; due to an exec.
 36573                                  
 36574                                  	;invoke	$OPEN			; is the file there?
 36575 000065C3 E80513                  	call	_$OPEN
 36576                                  
 36577                                  	; MSDOS 6.0
 36578 000065C6 9C                      	pushf
 36579                                  	; 02/06/2019
 36580                                  	;and	byte [ss:DOS_FLAG],0FEh
 36581 000065C7 368026[8600]FE          	and	byte [ss:DOS_FLAG],~EXECOPEN ; reset flag
 36582 000065CD 9D                      	popf
 36583                                  
 36584 000065CE 5D                      	pop	BP
 36585                                  
 36586                                  	; MSDOS 3.3 & MSDOS 6.0
 36587 000065CF 72AE                    	jc	short Exec_Ret_Err
 36588                                  
 36589                                  	;mov	[bp-8],ax
 36590 000065D1 8946F8                  	mov	Exec_FH,AX
 36591 000065D4 89C3                    	mov	BX,AX
 36592 000065D6 30C0                    	xor	AL,AL
 36593                                  	;invoke	$Ioctl
 36594 000065D8 E8D3C2                  	call	_$IOCTL
 36595 000065DB 7207                    	jc	short Exec_BombJ
 36596                                  
 36597                                  	;test	dl,80h
 36598 000065DD F6C280                  	test	DL,devid_ISDEV
 36599 000065E0 740A                    	jz	short Exec_Check_Environ
 36600                                  
 36601                                  	;mov	al,2
 36602 000065E2 B002                    	mov	AL,error_file_not_found
 36603                                  Exec_BombJ:
 36604 000065E4 E9CA00                  	jmp	Exec_Bomb
 36605                                  
 36606                                  BadEnv:
 36607                                  	;mov	al,0Ah
 36608 000065E7 B00A                    	mov	AL,error_bad_environment
 36609 000065E9 E9C500                  	jmp	Exec_Bomb
 36610                                  
 36611                                  Exec_Check_Environ:
 36612                                  	;mov	word [bp-18],0
 36613 000065EC C746EE0000              	mov	Exec_Load_Block,0
 36614                                  	;mov	word [bp-14],0
 36615 000065F1 C746F20000              	mov	Exec_Environ,0
 36616                                  					; overlays... no environment
 36617                                  	;test	byte [bp-5],2
 36618 000065F6 F646FB02                	test	Exec_Func,exec_func_overlay
 36619 000065FA 7552                    	jnz	short Exec_Read_Header
 36620                                  
 36621                                  	;lds	si,[bp-4]
 36622 000065FC C576FC                  	lds	SI,Exec_Blk		; get block
 36623 000065FF 8B04                    	mov	ax,[SI]
 36624                                  	;mov	AX,[SI+EXEC1.ENVIRON]	; address of environ
 36625 00006601 09C0                    	or	AX,AX
 36626 00006603 750C                    	jnz	short Exec_Scan_Env
 36627                                  
 36628 00006605 368E1E[3003]            	mov	DS,[SS:CurrentPDB]	;smr;SS Override
 36629                                  	;mov	ax,[44]
 36630 0000660A A12C00                  	mov	AX,[PDB.ENVIRON]
 36631                                  
 36632                                  ; MSDOS 6.0
 36633                                  ;---------------------------------------------BUG 92 4/30/90-----------------
 36634                                  ;
 36635                                  ; Exec_environ is being correctly initialized after the environment has been
 36636                                  ; allocated and copied form the parent's env. It must not be initialized here.
 36637                                  ; Because if the call to $alloc below fails Exec_dealloc will deallocate the
 36638                                  ; parent's environment.
 36639                                  ;	mov	Exec_Environ,AX
 36640                                  ;
 36641                                  ;----------------------------------------------------------------------------
 36642                                  
 36643                                  	;mov	[bp-14],ax
 36644                                  	;mov	Exec_Environ,ax
 36645                                  
 36646 0000660D 09C0                    	or	AX,AX
 36647 0000660F 743D                    	jz	short Exec_Read_Header
 36648                                  
 36649                                  Exec_Scan_Env:
 36650 00006611 8EC0                    	mov	ES,AX
 36651 00006613 31FF                    	xor	DI,DI
 36652                                  	;mov	cx,7FFFh ; MSDOS 3.3
 36653 00006615 B90080                  	mov	CX,8000h ; MSDOS 6.0	; at most 32k of environment ;M040
 36654 00006618 30C0                    	xor	AL,AL
 36655                                  
 36656                                  Exec_Get_Environ_Len:
 36657 0000661A F2AE                    	repnz	scasb			; find that nul byte
 36658 0000661C 75C9                    	jnz	short BadEnv
 36659                                  
 36660 0000661E 49                      	dec	CX			; Dec CX for the next nul byte test
 36661 0000661F 78C6                    	js	short BadEnv		; gone beyond the end of the environment
 36662                                  
 36663 00006621 AE                      	scasb				; is there another nul byte?
 36664 00006622 75F6                    	jnz	short Exec_Get_Environ_Len ; no, scan some more
 36665                                  
 36666 00006624 57                      	push	DI
 36667                                  	;lea	bx,[DI+11h]
 36668 00006625 8D5D11                  	lea	BX,[DI+0Fh+2]
 36669                                  	;add	bx,[bp-22]
 36670 00006628 035EEA                  	add	BX,ExecNameLen		; BX <- length of environment
 36671                                  					; remember argv[0] length
 36672                                  					; round up and remember argc
 36673 0000662B B104                    	mov	CL,4
 36674 0000662D D3EB                    	shr	BX,CL			; number of paragraphs needed
 36675 0000662F 06                      	push	ES
 36676                                  	;invoke	$Alloc			; can we get the space?
 36677 00006630 E84406                  	call	_$ALLOC
 36678 00006633 1F                      	pop	DS
 36679 00006634 59                      	pop	CX
 36680                                  
 36681                                  	;jnc	short Exec_Save_Environ
 36682                                  	;jmp	SHORT Exec_No_Mem	; nope... cry and sob
 36683                                  	; 17/12/2022
 36684 00006635 7274                    	jc	short Exec_No_Mem ; 02/06/2019
 36685                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 36686                                  	;jnc	short Exec_Save_Environ
 36687                                  	;jmp	SHORT Exec_No_Mem
 36688                                  
 36689                                  Exec_Save_Environ:
 36690 00006637 8EC0                    	mov	ES,AX
 36691                                  	;mov	[bp-14],ax
 36692 00006639 8946F2                  	mov	Exec_Environ,AX 	; save him for a rainy day
 36693 0000663C 31F6                    	xor	SI,SI
 36694 0000663E 89F7                    	mov	DI,SI
 36695 00006640 F3A4                    	rep	movsb			; copy the environment
 36696 00006642 B80100                  	mov	AX,1
 36697 00006645 AB                      	stosw
 36698                                  	;lds	si,[bp-26]
 36699 00006646 C576E6                  	lds	SI,ExecName
 36700                                  	;mov	cx,[bp-22]
 36701 00006649 8B4EEA                  	mov	CX,ExecNameLen
 36702 0000664C F3A4                    	rep	movsb
 36703                                  
 36704                                  Exec_Read_Header:
 36705                                  	; We read in the program header into the above data area and
 36706                                  	; determine where in this memory the image will be located.
 36707                                  
 36708                                  	;Context DS
 36709 0000664E 16                      	push	ss
 36710 0000664F 1F                      	pop	ds
 36711                                  	;mov	cx,26
 36712 00006650 B91A00                  	mov	CX,exec_header_len	; header size
 36713 00006653 BA[0D10]                	mov	DX,exec_signature
 36714 00006656 06                      	push	ES
 36715 00006657 1E                      	push	DS
 36716 00006658 E88304                  	call	ExecRead
 36717 0000665B 1F                      	pop	DS
 36718 0000665C 07                      	pop	ES
 36719 0000665D 7250                    	jc	short Exec_Bad_File
 36720                                  
 36721 0000665F 09C0                    	or	AX,AX
 36722 00006661 744C                    	jz	short Exec_Bad_File
 36723                                  	;cmp	ax,26
 36724 00006663 83F81A                  	cmp	AX,exec_header_len	; did we read the right number?
 36725 00006666 7519                    	jnz	short Exec_Com_Filej	; yep... continue
 36726                                  
 36727 00006668 F706[1910]FFFF          	test	word [exec_max_BSS],-1 	; indicate load high?
 36728 0000666E 7504                    	jnz	short Exec_Check_Sig
 36729                                  
 36730                                  	;mov	byte [bp-6],0FFh
 36731 00006670 C646FAFF                	mov	Exec_Load_High,-1
 36732                                  
 36733                                  Exec_Check_Sig:
 36734 00006674 A1[0D10]                	mov	AX,[exec_signature]	; rms;NSS
 36735                                  	;cmp	ax,5A4Dh ; 'MZ'
 36736 00006677 3D4D5A                  	cmp	AX,exe_valid_signature	; zibo arises!
 36737 0000667A 7408                    	jz	short Exec_Save_Start 	; assume com file if no signature
 36738                                  
 36739                                  	;cmp	ax,4D5Ah ; 'ZM'
 36740 0000667C 3D5A4D                  	cmp	AX,exe_valid_old_signature ; zibo arises!
 36741 0000667F 7403                    	jz	short Exec_Save_Start 	; assume com file if no signature
 36742                                  
 36743                                  Exec_Com_Filej:
 36744 00006681 E9E901                  	jmp	Exec_Com_File
 36745                                  
 36746                                  	; We have the program header... determine memory requirements
 36747                                  
 36748                                  Exec_Save_Start:
 36749 00006684 A1[1110]                	mov	AX,[exec_pages]		; get 512-byte pages	;rms;NSS
 36750 00006687 B105                    	mov	CL,5			; convert to paragraphs
 36751 00006689 D3E0                    	shl	AX,CL
 36752 0000668B 2B06[1510]              	sub	AX,[exec_par_dir] 	; AX = size in paragraphs ;rms;NSS
 36753                                  	;mov	[bp-12],ax
 36754 0000668F 8946F4                  	mov	Exec_Res_Len_Para,AX
 36755                                  
 36756                                  		; Do we need to allocate memory?
 36757                                  		; Yes if function is not load-overlay
 36758                                  
 36759                                  	;test	byte [bp-5],2
 36760 00006692 F646FB02                	test	Exec_Func,exec_func_overlay
 36761 00006696 7445                    	jz	short Exec_Allocate	; allocation of space
 36762                                  
 36763                                  		; get load address from block
 36764                                  
 36765                                  	;les	di,[bp-4]
 36766 00006698 C47EFC                  	les	DI,Exec_Blk
 36767 0000669B 268B05                  	mov	ax,[es:di]
 36768                                  	;mov	AX,[ES:DI+EXEC3.load_addr]
 36769                                  	;mov	[bp-20],ax
 36770 0000669E 8946EC                  	mov	Exec_DMA,AX
 36771                                  
 36772                                  	; 17/12/2022
 36773                                  	;;mov	ax,[es:di+2]
 36774                                  	;mov	AX,[ES:DI+EXEC3.reloc_fac]
 36775                                  	;;mov	[bp-10],ax
 36776                                  	;mov	Exec_Rel_Fac,AX
 36777                                  
 36778                                  	; 17/12/2022
 36779                                  	; 30/11/2022 (!most proper code!)
 36780                                  	;mov	dx,[es:di+2]
 36781 000066A1 268B5502                	mov	dx,[ES:DI+EXEC3.reloc_fac]
 36782                                  	;mov	[bp-10],dx
 36783 000066A5 8956F6                  	mov	Exec_Rel_Fac,dx
 36784                                  	; ax = Exec_DMA
 36785 000066A8 E9DE00                  	jmp	Exec_Find_Res
 36786                                  
 36787                                  ; 17/12/2022
 36788                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 36789                                  ; 27/09/2023
 36790                                  %if 0
 36791                                  	; 02/06/2019 - Retro DOS v4.0
 36792                                  	;mov	ax,[bp-20]  ; *+*
 36793                                  	mov	AX,Exec_DMA ; *+*
 36794                                  	; 10/08/2018
 36795                                  	jmp	Exec_Find_Res		; M000
 36796                                  %endif
 36797                                  
 36798                                  Exec_No_Mem:
 36799                                  	;mov	al,8
 36800 000066AB B008                    	mov	AL,error_not_enough_memory
 36801 000066AD EB02                    	jmp	short Exec_Bomb
 36802                                  
 36803                                  Exec_Bad_File:
 36804                                  	;mov	al,0Bh
 36805 000066AF B00B                    	mov	AL,error_bad_format
 36806                                  
 36807                                  Exec_Bomb:
 36808                                  	;mov	bx,[bp-8]
 36809 000066B1 8B5EF8                  	mov	BX,Exec_FH
 36810 000066B4 E84004                  	call	Exec_Dealloc
 36811                                  	;LeaveCrit CritMem
 36812 000066B7 E876B2                  	call	LCritMEM
 36813                                  	;save	<AX,BP>
 36814 000066BA 50                      	push	ax
 36815 000066BB 55                      	push	bp
 36816                                  	;invoke	$CLOSE
 36817 000066BC E83D0A                  	call	_$CLOSE
 36818                                  	;restore <BP,AX>
 36819 000066BF 5D                      	pop	bp
 36820 000066C0 58                      	pop	ax
 36821 000066C1 E9BBFE                  	jmp	Exec_Ret_Err
 36822                                  
 36823                                  Exec_Chk_Mem: 
 36824                                  
 36825                                  	; 24/09/2023
 36826                                  	; ds = DOSDATA
 36827                                  ; 17/12/2022
 36828                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 36829                                  ;%if 0
 36830                                  	; MSDOS 6.0    			; M063 - Start
 36831                                  	;mov	al,[ss:AllocMethod]	; save current alloc method in ax
 36832                                  	; 10/06/2019
 36833 000066C4 A0[0203]                	mov	al,[AllocMethod]
 36834                                  	;mov	bl,[ss:ALLOCMSAVE]
 36835 000066C7 8A1E[8400]              	mov	bl,[ALLOCMSAVE]
 36836                                  	;mov	[ss:AllocMethod],bl	; restore original allocmethod
 36837 000066CB 881E[0203]              	mov	[AllocMethod],bl
 36838                                  	
 36839 000066CF F6C340                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 36840 000066D2 75D7                    	jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
 36841                                  	;				; N: continue
 36842                                  	;
 36843 000066D4 A840                    	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 36844 000066D6 74D3                    	jz	short Exec_No_Mem	; N: no memory 
 36845                                  	; 02/06/2019
 36846                                  	;mov	ax,[ss:SAVE_AX]		; Y: restore ax and
 36847 000066D8 A1[8A00]                	mov	ax,[SAVE_AX]
 36848                                  	;jmp	short Exec_Norm_Alloc	;    Try again
 36849                                  					; M063 - End
 36850 000066DB EB2B                    	jmp	short Exec_Norm_Alloc1
 36851                                  ;%endif
 36852                                  
 36853                                  ; 17/12/2022
 36854                                  %if 0
 36855                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 36856                                  	; MSDOS 6.0    			; M063 - Start
 36857                                  	mov	al,[ss:AllocMethod]	; save current alloc method in ax
 36858                                  	mov	bl,[ss:ALLOCMSAVE]
 36859                                  	mov	[ss:AllocMethod],bl	; restore original allocmethod
 36860                                  
 36861                                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 36862                                  	jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
 36863                                  	;				; N: continue
 36864                                  	;
 36865                                  	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 36866                                  	jz	short Exec_No_Mem	; N: no memory 
 36867                                  
 36868                                  	mov	ax,[ss:SAVE_AX]		; Y: restore ax and
 36869                                  	jmp	short Exec_Norm_Alloc	;    Try again
 36870                                  					; M063 - End
 36871                                  %endif
 36872                                  
 36873                                  Exec_Allocate:
 36874                                  	; 09/09/2018
 36875                                  
 36876                                  	; M005 - START
 36877                                  	; If there is no STACK segment for this exe file and if this
 36878                                  	; not an overlay and the resident size is less than 64K - 
 36879                                  	; 256 bytes we shall add 256 bytes to the programs 
 36880                                  	; resident memory requirement and set Exec_SP to this value.
 36881                                  	
 36882                                  	; 17/12/2022
 36883 000066DD 29DB                    	sub	bx,bx ; 0	
 36884                                  
 36885                                  	; MSDOS 6.0
 36886                                  	;;mov	byte [bp-29],0
 36887                                  	;mov	Exec_NoStack,0
 36888                                  	; 17/12/2022
 36889 000066DF 885EE3                  	mov	Exec_NoStack,bl ; 0
 36890 000066E2 391E[1B10]              	cmp	[exec_SS],bx ; 0
 36891                                  	;cmp	word [exec_SS],0	; Q: is there a stack seg
 36892 000066E6 7511                    	jne	short ea1		; Y: continue normal processing
 36893 000066E8 391E[1D10]              	cmp	[exec_SP],bx ; 0
 36894                                  	;cmp	word [exec_SP],0	; Q: is there a stack ptr
 36895 000066EC 750B                    	jne	short ea1		; Y: continue normal processing
 36896                                  
 36897                                  	;inc	byte [bp-29]
 36898 000066EE FE46E3                  	inc	Exec_NoStack
 36899 000066F1 3DF00F                  	cmp	ax,1000h-10h		; Q: is this >= 64K-256 bytes
 36900 000066F4 7303                    	jae	short ea1		; Y: don't set Exec_SP
 36901                                  
 36902 000066F6 83C010                  	add	ax,10h			; add 10h paras to mem requirement
 36903                                  ea1:
 36904                                  	; M005 - END
 36905                                  
 36906                                  	; MSDOS 6.0			; M000 - start
 36907                                  	; 20/05/2019
 36908                                  	; (ds = ss = DOSDATA)
 36909 000066F9 F606[0203]80            	test	byte [AllocMethod],HIGH_FIRST ; 80h
 36910                                  					; Q: is the alloc strat high_first
 36911 000066FE 7405                    	jz	short Exec_Norm_Alloc	; N: normal allocate
 36912                                  					; Y: set high_only bit
 36913 00006700 800E[0203]40            	or	byte [AllocMethod],HIGH_ONLY ; 40h
 36914                                  					; M000 - end
 36915                                  Exec_Norm_Alloc:
 36916 00006705 A3[8A00]                	mov	[SAVE_AX],ax		; M000: save ax for possible 2nd  
 36917                                  Exec_Norm_Alloc1:	; 02/06/2019
 36918                                  					; M000: attempt at allocating memory
 36919                                  	; MSDOS 3.3
 36920                                  	;push	ax			; M000
 36921                                  
 36922 00006708 BBFFFF                  	mov	BX,0FFFFh		; see how much room in arena
 36923 0000670B 1E                      	push	DS
 36924                                  	;invoke	$Alloc			; should have carry set and BX has max
 36925 0000670C E86805                  	call	_$ALLOC
 36926 0000670F 1F                      	pop	DS
 36927                                  
 36928                                  	; MSDOS 6.0
 36929 00006710 A1[8A00]                	mov	AX,[SAVE_AX]		; M000
 36930                                  	; MSDOS 3.3
 36931                                  	;pop	ax			; M000
 36932                                  
 36933 00006713 83C010                  	add	AX,10h			; room for header
 36934 00006716 83FB11                  	cmp	BX,11h			; enough room for a header
 36935                                  	; MSDOS 6.0
 36936 00006719 72A9                    	jb	short Exec_Chk_Mem	; M000
 36937                                  	; MSDOS 3.3	
 36938                                  	;jb	short Exec_No_Mem
 36939                                  
 36940 0000671B 39D8                    	cmp	AX,BX			; is there enough for bare image?
 36941                                  	; MSDOS 6.0
 36942 0000671D 77A5                    	ja	short Exec_Chk_Mem	; M000
 36943                                  	; MSDOS 3.3
 36944                                  	;ja	short Exec_No_Mem
 36945                                  
 36946                                  	;test	byte [bp-6],0FFh
 36947 0000671F F646FAFF                	test	Exec_Load_High,-1	; if load high, use max
 36948 00006723 7518                    	jnz	short Exec_BX_Max	; use max
 36949                                  
 36950                                  	; 09/09/2018
 36951                                  
 36952 00006725 0306[1710]              	add	AX,[exec_min_BSS] 	; go for min allocation;rms;NSS
 36953                                  	; MSDOS 6.0
 36954 00006729 7299                    	jc	short Exec_Chk_Mem		; M000
 36955                                  	; MSDOS 3.3
 36956                                  	;jc	short Exec_No_Mem
 36957                                  
 36958 0000672B 39D8                    	cmp	AX,BX			; enough space?
 36959                                  	; MSDOS 6.0
 36960 0000672D 7795                    	ja	short Exec_Chk_Mem	; M000: nope...	
 36961                                  	; MSDOS 3.3
 36962                                  	;ja	short Exec_No_Mem
 36963                                  
 36964 0000672F 2B06[1710]              	sub	AX,[exec_min_BSS] 	; rms;NSS
 36965 00006733 0306[1910]              	add	AX,[exec_max_BSS] 	; go for the MAX
 36966 00006737 7204                    	jc	short Exec_BX_Max
 36967                                  
 36968 00006739 39D8                    	cmp	AX,BX
 36969 0000673B 7602                    	jbe	short Exec_Got_Block
 36970                                  
 36971                                  Exec_BX_Max:
 36972 0000673D 89D8                    	mov	AX,BX
 36973                                  
 36974                                  Exec_Got_Block:
 36975                                  	; 03/08/2018 - Retro DOS v3.0
 36976                                  
 36977 0000673F 1E                      	push	DS
 36978 00006740 89C3                    	mov	BX,AX
 36979                                  	;mov	[bp-16],bx
 36980 00006742 895EF0                  	mov	Exec_Size,BX
 36981                                  	;invoke	$Alloc			; get the space
 36982 00006745 E82F05                  	call	_$ALLOC
 36983 00006748 1F                      	pop	DS
 36984                                  	; MSDOS 6.0
 36985                                  	;jc	short Exec_Chk_Mem	; M000
 36986                                  	; MSDOS 3.3
 36987                                  	;;jc	short Exec_No_Mem
 36988                                  	; 20/05/2019
 36989 00006749 7303                    	jnc	short ea0
 36990 0000674B E976FF                  	jmp	Exec_Chk_Mem
 36991                                  ea0:
 36992                                  	; MSDOS 6.0
 36993 0000674E 8A0E[8400]              	mov	cl,[ALLOCMSAVE]		; M063: 
 36994 00006752 880E[0203]              	mov	[AllocMethod],cl	; M063: restore allocmethod
 36995                                  
 36996                                  ;M029; Begin changes
 36997                                  ; This code does special handling for programs with no stack segment. If so,
 36998                                  ;check if the current block is larger than 64K. If so, we do not modify
 36999                                  ;Exec_SP. If smaller than 64K, we make Exec_SP = top of block. In either
 37000                                  ;case Exec_SS is not changed.
 37001                                  
 37002                                  	; MSDOS 6.0
 37003                                  	;cmp	byte [bp-29],0
 37004 00006756 807EE300                	cmp	Exec_NoStack,0
 37005                                  	;je	@f
 37006 0000675A 7412                    	je	short ea2
 37007                                  
 37008 0000675C 81FB0010                	cmp	bx,1000h		; Q: >= 64K memory block
 37009                                  	;jae	@f			; Y: Exec_SP = 0
 37010 00006760 730C                    	jae	short ea2
 37011                                  
 37012                                  ;Make Exec_SP point at the top of the memory block
 37013                                  
 37014 00006762 B104                    	mov	cl,4
 37015 00006764 D3E3                    	shl	bx,cl			; get byte offset
 37016 00006766 81EB0001                	sub	bx,100h			; take care of PSP
 37017 0000676A 891E[1D10]              	mov	[exec_SP],bx		; Exec_SP = top of block
 37018                                  ea2:
 37019                                  ;@@:
 37020                                  ;M029; end changes
 37021                                  
 37022                                  	;mov	[bp-18],ax
 37023 0000676E 8946EE                  	mov	Exec_Load_Block,AX
 37024 00006771 83C010                  	add	AX,10h
 37025                                  	;test	byte [bp-6],0FFh
 37026 00006774 F646FAFF                	test	Exec_Load_High,-1
 37027 00006778 7409                    	jz	short Exec_Use_AX	; use ax for load info
 37028                                  
 37029                                  	;add	ax,[bp-16]
 37030 0000677A 0346F0                  	add	AX,Exec_Size		; go to end
 37031                                  	;sub	ax,[bp-12]
 37032 0000677D 2B46F4                  	sub	AX,Exec_Res_Len_Para	; drop off header
 37033 00006780 83E810                  	sub	AX,10h			; drop off pdb
 37034                                  
 37035                                  Exec_Use_AX:
 37036                                  	;mov	[bp-10],ax
 37037 00006783 8946F6                  	mov	Exec_Rel_Fac,AX 	; new segment
 37038                                  	;mov	[bp-20],ax
 37039 00006786 8946EC                  	mov	Exec_DMA,AX ; *+*	; beginning of dma
 37040                                  
 37041                                  	; Determine the location in the file of the beginning of
 37042                                  	; the resident
 37043                                  
 37044                                  ; 17/12/2022
 37045                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 37046                                  ;%if 0
 37047                                  
 37048                                  Exec_Find_Res:
 37049                                  	; MSDOS 6.0
 37050                                  	;;mov	dx,[bp-20]
 37051                                  	;mov	DX,Exec_DMA ; *+*
 37052                                  	;;mov	[bp-28],dx
 37053                                  	;mov	Exec_DMA_Save,DX
 37054                                  
 37055                                  	; 17/12/2022
 37056                                  	; AX = Exec_DMA
 37057                                  
 37058                                  	; 02/06/2019 - Retro DOS v4.0
 37059                                  	;mov	[bp-28],ax ; *+*
 37060 00006789 8946E4                  	mov	Exec_DMA_Save,AX ; *+*
 37061                                  
 37062                                  ;%endif
 37063                                  
 37064                                  ; 17/12/2022
 37065                                  %if 0
 37066                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 37067                                  Exec_Find_Res:
 37068                                  	;mov	dx,[bp-20]
 37069                                  	mov	DX,Exec_DMA ; *+*
 37070                                  	;mov	[bp-28],dx
 37071                                  	mov	Exec_DMA_Save,DX
 37072                                  %endif
 37073                                  
 37074                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37075 0000678C 8B16[1510]              	mov	DX,[exec_par_dir]
 37076 00006790 52                      	push	DX
 37077 00006791 B104                    	mov	CL,4
 37078 00006793 D3E2                    	shl	DX,CL			; low word of location
 37079 00006795 58                      	pop	AX
 37080 00006796 B10C                    	mov	CL,12
 37081 00006798 D3E8                    	shr	AX,CL			; high word of location
 37082 0000679A 89C1                    	mov	CX,AX			; CX <- high
 37083                                  
 37084                                  		; Read in the resident image (first, seek to it)
 37085                                  	;mov	bx,[bp-8]
 37086 0000679C 8B5EF8                  	mov	BX,Exec_FH
 37087 0000679F 1E                      	push	DS
 37088 000067A0 30C0                    	xor	AL,AL
 37089                                  	;invoke	$Lseek			; Seek to resident
 37090 000067A2 E8D30A                  	call	_$LSEEK
 37091 000067A5 1F                      	pop	DS
 37092 000067A6 7303                    	jnc	short Exec_Big_Read
 37093                                  
 37094 000067A8 E906FF                  	jmp	Exec_Bomb
 37095                                  
 37096                                  Exec_Big_Read:				; Read resident into memory
 37097                                  	;mov	bx,[bp-12]
 37098 000067AB 8B5EF4                  	mov	BX,Exec_Res_Len_Para
 37099 000067AE 81FB0010                	cmp	BX,1000h		; Too many bytes to read?
 37100 000067B2 7203                    	jb	short Exec_Read_OK
 37101                                  
 37102 000067B4 BBE00F                  	mov	BX,0FE0h		; Max in one chunk FE00 bytes
 37103                                  
 37104                                  Exec_Read_OK:
 37105                                  	;sub	[bp-12],bx
 37106 000067B7 295EF4                  	sub	Exec_Res_Len_Para,BX	; We read (soon) this many
 37107 000067BA 53                      	push	BX
 37108 000067BB B104                    	mov	CL,4
 37109 000067BD D3E3                    	shl	BX,CL			; Get count in bytes from paras
 37110 000067BF 89D9                    	mov	CX,BX			; Count in correct register
 37111 000067C1 1E                      	push	DS
 37112                                  	;mov	ds,[bp-20]
 37113 000067C2 8E5EEC                  	mov	DS,Exec_DMA		; Set up read buffer
 37114                                  
 37115 000067C5 31D2                    	xor	DX,DX
 37116 000067C7 51                      	push	CX			; Save our count
 37117 000067C8 E81303                  	call	ExecRead
 37118 000067CB 59                      	pop	CX			; Get old count to verify
 37119 000067CC 1F                      	pop	DS
 37120 000067CD 7248                    	jc	short Exec_Bad_FileJ
 37121                                  
 37122 000067CF 39C1                    	cmp	CX,AX			; Did we read enough?
 37123 000067D1 5B                      	pop	BX			; Get paragraph count back
 37124 000067D2 7408                    	jz	short ExecCheckEnd	; and do reloc if no more to read
 37125                                  
 37126                                  	; The read did not match the request. If we are off by 512
 37127                                  	; bytes or more then the header lied and we have an error.
 37128                                  
 37129 000067D4 29C1                    	sub	CX,AX
 37130 000067D6 81F90002                	cmp	CX,512
 37131 000067DA 733B                    	jae	short Exec_Bad_FileJ
 37132                                  
 37133                                  	; We've read in CX bytes... bump DTA location
 37134                                  
 37135                                  ExecCheckEnd:
 37136                                  	;add	[bp-20],bx
 37137 000067DC 015EEC                  	add	Exec_DMA,BX		; Bump dma address
 37138                                  	;test	word [bp-12],0FFFFh
 37139 000067DF F746F4FFFF              	test	Exec_Res_Len_Para,-1
 37140 000067E4 75C5                    	jnz	short Exec_Big_Read
 37141                                  
 37142                                  	; The image has now been read in. We must perform relocation
 37143                                  	; to the current location.
 37144                                  
 37145                                  exec_do_reloc:
 37146                                  	;mov	cx,[bp-10]
 37147 000067E6 8B4EF6                  	mov	CX,Exec_Rel_Fac
 37148 000067E9 A1[1B10]                	mov	AX,[exec_SS]		; get initial SS ;rms;NSS
 37149 000067EC 01C8                    	add	AX,CX			; and relocate him
 37150 000067EE A3[0710]                	mov	[exec_init_SS],AX 	; rms;NSS
 37151                                  
 37152 000067F1 A1[1D10]                	mov	AX,[exec_SP]		; initial SP ;rms;NSS
 37153 000067F4 A3[0510]                	mov	[exec_init_SP],AX 	; rms;NSS
 37154                                  
 37155 000067F7 C406[2110]              	les	AX,[exec_IP]		; rms;NSS
 37156 000067FB A3[0910]                	mov	[exec_init_IP],AX 	; rms;NSS
 37157 000067FE 8CC0                    	mov	AX,ES			; rms;NSS
 37158 00006800 01C8                    	add	AX,CX			; relocated...
 37159 00006802 A3[0B10]                	mov	[exec_init_CS],AX 	; rms;NSS
 37160                                  
 37161 00006805 31C9                    	xor	CX,CX
 37162 00006807 8B16[2510]              	mov	DX,[exec_rle_table]	; rms;NSS
 37163                                  	;mov	bx,[bp-8]
 37164 0000680B 8B5EF8                  	mov	BX,Exec_FH
 37165 0000680E 1E                      	push	DS
 37166 0000680F 31C0                    	xor	AX,AX
 37167                                  	;invoke	$Lseek
 37168 00006811 E8640A                  	call	_$LSEEK
 37169 00006814 1F                      	pop	DS
 37170 00006815 7303                    	jnc	short exec_get_entries
 37171                                  
 37172                                  Exec_Bad_FileJ:
 37173 00006817 E995FE                  	jmp	Exec_Bad_File
 37174                                  
 37175                                  exec_get_entries:
 37176 0000681A 8B16[1310]              	mov	DX,[exec_rle_count]	; Number of entries left ;rms;NSS
 37177                                  
 37178                                  exec_read_reloc:
 37179 0000681E 52                      	push	DX
 37180                                  	;mov	dx,OPENBUF
 37181 0000681F BA[BE03]                	mov	DX,Exec_Internal_Buffer
 37182                                  	;;mov	cx,388 ; MSDOS 3.3 ; (390>>2)<<2
 37183                                  	;mov	cx,396 ; MSDOS 6.0
 37184 00006822 B98C01                  	mov	CX,((Exec_Internal_Buffer_Size)/4)*4 ; (397>>2)<<2
 37185 00006825 1E                      	push	DS
 37186 00006826 E8B502                  	call	ExecRead
 37187 00006829 07                      	pop	ES
 37188 0000682A 5A                      	pop	DX
 37189 0000682B 72EA                    	jc	short Exec_Bad_FileJ
 37190                                  
 37191                                  	;;mov	cx,97 ;  MSDOS 3.3 ; (390>>2)
 37192                                  	;mov	cx,99 ;  MSDOS 6.0
 37193 0000682D B96300                  	mov	CX,(Exec_Internal_Buffer_Size)/4 ; (397>>2)
 37194                                  					; Pointer to byte location in header
 37195                                  	;mov	di,OPENBUF
 37196 00006830 BF[BE03]                	mov	DI,Exec_Internal_Buffer
 37197                                  	;mov	si,[bp-10]
 37198 00006833 8B76F6                  	mov	SI,Exec_Rel_Fac 	; Relocate a single address
 37199                                  
 37200                                  exec_reloc_one:
 37201 00006836 09D2                    	or	DX,DX			; Any more entries?
 37202 00006838 7416                    	jz	short Exec_Set_PDBJ
 37203                                  
 37204                                  exec_get_addr:
 37205 0000683A 26C51D                  	lds	BX,[ES:DI]		; Get ra/sa of entry
 37206 0000683D 8CD8                    	mov	AX,DS			; Relocate address of item
 37207                                  
 37208                                  	; MSDOS 6.0
 37209                                  ;;;;;;	add	AX,SI  ; MSDOS 3.3
 37210                                  	;add	ax,[bp-28]
 37211 0000683F 0346E4                  	add	AX,Exec_DMA_Save
 37212                                  
 37213 00006842 8ED8                    	mov	DS,AX
 37214 00006844 0137                    	add	[BX],SI
 37215 00006846 83C704                  	add	DI,4
 37216 00006849 4A                      	dec	DX
 37217 0000684A E2EA                    	loop	exec_reloc_one		; End of internal buffer?
 37218                                  
 37219                                  	; We've exhausted a single buffer's worth. Read in the next
 37220                                  	; piece of the relocation table.
 37221                                  
 37222 0000684C 06                      	push	ES
 37223 0000684D 1F                      	pop	DS
 37224 0000684E EBCE                    	jmp	short exec_read_reloc
 37225                                  
 37226                                  Exec_Set_PDBJ:
 37227                                  	; MSDOS 6.0
 37228                                  	
 37229                                  	; We now determine if this is a buggy exe packed file and if 
 37230                                  	; so we patch in the right code. Note that fixexepatch will
 37231                                  	; point to a ret if dos loads low. The load segment as 
 37232                                  	; determined above will be in exec_dma_save
 37233                                  	
 37234 00006850 06                      	push	es
 37235 00006851 50                      	push	ax			; M030
 37236 00006852 51                      	push	cx			; M030
 37237                                  	;mov	es,[bp-28]
 37238 00006853 8E46E4                  	mov	es,Exec_DMA_Save
 37239 00006856 36A1[0B10]              	mov	ax,[ss:exec_init_CS]	; M030
 37240 0000685A 368B0E[0910]            	mov	cx,[ss:exec_init_IP]	; M030
 37241 0000685F 36FF16[880D]            	call	word [ss:FixExePatch]
 37242                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37243                                  	; (MSDOS 5.0 MSDOS.SYS does not contain 'Rational386Patch')
 37244                                  	;call	word [ss:Rational386PatchPtr]
 37245 00006864 59                      	pop	cx			; M030
 37246 00006865 58                      	pop	ax			; M030
 37247 00006866 07                      	pop	es
 37248                                  
 37249 00006867 E9DE00                  	jmp	Exec_Set_PDB
 37250                                  
 37251                                  Exec_No_Memj:
 37252 0000686A E93EFE                  	jmp	Exec_No_Mem
 37253                                  
 37254                                  	; we have a .COM file. First, determine if we are merely
 37255                                  	; loading an overlay.
 37256                                  
 37257                                  Exec_Com_File:
 37258                                  	;test	byte [bp-5],2
 37259 0000686D F646FB02                	test	Exec_Func,exec_func_overlay
 37260 00006871 742D                    	jz	short Exec_Alloc_Com_File
 37261                                  	;lds	si,[bp-4]
 37262 00006873 C576FC                  	lds	SI,Exec_Blk		; get arg block
 37263 00006876 AD                      	lodsw				; get load address
 37264                                  	;mov	[bp-20],ax
 37265 00006877 8946EC                  	mov	Exec_DMA,AX
 37266 0000687A B8FFFF                  	mov	AX,0FFFFh
 37267 0000687D EB63                    	jmp	short Exec_Read_Block	; read it all!
 37268                                  
 37269                                  Exec_Chk_Com_Mem:			
 37270                                  	; MSDOS 6.0	     		; M063 - Start
 37271 0000687F 36A0[0203]              	mov	al,[ss:AllocMethod]	; save current alloc method in ax
 37272 00006883 368A1E[8400]            	mov	bl,[ss:ALLOCMSAVE]
 37273 00006888 36881E[0203]            	mov	[ss:AllocMethod],bl	; restore original allocmethod
 37274 0000688D F6C340                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 37275 00006890 75D8                    	jnz	short Exec_No_Memj	; Y: no space in UMBs. Quit
 37276                                  					; N: continue
 37277                                  	
 37278 00006892 A840                    	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 37279 00006894 74D4                    	jz	short Exec_No_Memj	; N: no memory 
 37280                                  	
 37281                                  	;mov	ax,[bp-18]
 37282 00006896 8B46EE                  	mov	ax,Exec_Load_Block	; M047: ax = block we just allocated	
 37283 00006899 31DB                    	xor	bx,bx			; M047: bx => free arena
 37284 0000689B E87502                  	call	ChangeOwner		; M047: free this block
 37285                                  	
 37286 0000689E EB0E                    	jmp	short Exec_Norm_Com_Alloc
 37287                                  					; M063 - End
 37288                                  	
 37289                                  	; We must allocate the max possible size block (ick!)
 37290                                  	; and set up CS=DS=ES=SS=PDB pointer, IP=100, SP=max
 37291                                  	; size of block.
 37292                                  
 37293                                  Exec_Alloc_Com_File:
 37294                                  	; MSDOS 6.0			; M000 -start
 37295 000068A0 36F606[0203]80          	test	byte [ss:AllocMethod],HIGH_FIRST ; 80h
 37296                                  					; Q: is the alloc strat high_first
 37297 000068A6 7406                    	jz	short Exec_Norm_Com_Alloc ; N: normal allocate
 37298                                  					; Y: set high_only bit
 37299 000068A8 36800E[0203]40          	or	byte [ss:AllocMethod],HIGH_ONLY ; 40h
 37300                                  					; M000 - end
 37301                                  Exec_Norm_Com_Alloc:			; M000
 37302                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37303 000068AE BBFFFF                  	mov	BX,0FFFFh
 37304                                  	;invoke	$Alloc			; largest piece available as error
 37305 000068B1 E8C303                  	call	_$ALLOC
 37306 000068B4 09DB                    	or	BX,BX
 37307                                  	; MSDOS 6.0
 37308 000068B6 74C7                    	jz	short Exec_Chk_Com_Mem	; M000
 37309                                  	; MSDOS 3.3
 37310                                  	;jz	short Exec_No_Memj
 37311                                  
 37312                                  	;mov	[bp-16],bx
 37313 000068B8 895EF0                  	mov	Exec_Size,BX		; save size of allocation block
 37314 000068BB 53                      	push	BX
 37315                                  	;invoke	$ALLOC			; largest piece available
 37316 000068BC E8B803                  	call	_$ALLOC
 37317 000068BF 5B                      	pop	BX			; get size of block...
 37318                                  	;mov	[bp-18],ax
 37319 000068C0 8946EE                  	mov	Exec_Load_Block,AX
 37320                                  
 37321 000068C3 83C010                  	add	AX,10h			; increment for header
 37322                                  	;mov	[bp-20],ax
 37323 000068C6 8946EC                  	mov	Exec_DMA,AX
 37324                                  
 37325 000068C9 31C0                    	xor	AX,AX			; presume 64K read...
 37326 000068CB 81FB0010                	cmp	BX,1000h		; 64k or more in block?
 37327 000068CF 730E                    	jae	short Exec_Read_Com	; yes, read only 64k
 37328                                  
 37329 000068D1 89D8                    	mov	AX,BX			; convert size to bytes
 37330 000068D3 B104                    	mov	CL,4
 37331 000068D5 D3E0                    	shl	AX,CL
 37332                                  	; 17/12/2022
 37333                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37334                                  	;			(MSDOS 5.0, MSDOS.SYS compatibility)
 37335                                  	; MSDOS 5.0
 37336                                  	;cmp	AX,100h   
 37337                                  	; 02/06/2019 - Retro DOS v4.0
 37338                                  	; MSDOS 6.0
 37339                                          ; 17/12/2022
 37340 000068D7 3D0002                  	cmp	AX,200h                 ; enough memory for PSP and stack?
 37341 000068DA 76A3                    	jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 37342                                  	;;jbe	short Exec_No_Memj	; M000: jump if not
 37343                                  	;; Retro DOS v3.0 modification (on MSDOS 6.0 code) -03/08/2018-
 37344                                  	;;jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 37345                                  	;jbe	short Exec_No_Memj	; M000: jump if not
 37346                                  
 37347                                  					; M047: size of the block is < 64K
 37348 000068DC 2D0001                  	sub	ax,100h			; M047: reserve 256 bytes for stack
 37349                                  
 37350                                  Exec_Read_Com:
 37351                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37352 000068DF 2D0001                  	sub	AX,100h 		; remember size of psp
 37353                                  Exec_Read_Block:
 37354 000068E2 50                      	push	AX			; save number to read
 37355                                  	;mov	bx,[bp-8]
 37356 000068E3 8B5EF8                  	mov	BX,Exec_FH		; of com file
 37357 000068E6 31C9                    	xor	CX,CX			; but seek to 0:0
 37358 000068E8 89CA                    	mov	DX,CX
 37359 000068EA 31C0                    	xor	AX,AX			; seek relative to beginning
 37360                                  	;invoke	$Lseek			; back to beginning of file
 37361 000068EC E88909                  	call	_$LSEEK
 37362 000068EF 59                      	pop	CX			; number to read
 37363                                  	;mov	ds,[bp-20]
 37364 000068F0 8E5EEC                  	mov	DS,Exec_DMA
 37365 000068F3 31D2                    	xor	DX,DX
 37366 000068F5 51                      	push	CX
 37367 000068F6 E8E501                  	call	ExecRead
 37368 000068F9 5E                      	pop	SI			; get number of bytes to read
 37369 000068FA 7303                    	jnc	short OkRead
 37370 000068FC E9B0FD                  	jmp	Exec_Bad_File
 37371                                  
 37372                                  	; 10/09/2018
 37373                                  OkRead:
 37374 000068FF 39F0                    	cmp	AX,SI			; did we read them all?
 37375                                  	; MSDOS 6.0
 37376                                  	;jz	short Exec_Chk_Com_Mem	; M00: exactly the wrong number...no 
 37377                                  	; MSDOS 3.3
 37378                                  	;;jz	short Exec_No_Memj	; M00: exactly the wrong number...
 37379 00006901 7503                    	jne	short OkRead2
 37380 00006903 E979FF                  	jmp	Exec_Chk_Com_Mem
 37381                                  OkRead2:
 37382                                  	; MSDOS 6.0
 37383 00006906 368A1E[8400]            	mov	bl,[ss:ALLOCMSAVE]	; M063
 37384 0000690B 36881E[0203]            	mov	[ss:AllocMethod],bl	; M063: restore alloc method
 37385                                  
 37386                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37387                                  	;test	byte [bp-5],2
 37388 00006910 F646FB02                	test	Exec_Func,exec_func_overlay
 37389 00006914 7532                    	jnz	short Exec_Set_PDB	; no starto, chumo!
 37390                                  
 37391                                  	;mov	ax,[bp-20]
 37392 00006916 8B46EC                  	mov	AX,Exec_DMA
 37393 00006919 83E810                  	sub	AX,10h
 37394 0000691C 36A3[0B10]              	mov	[SS:exec_init_CS],AX
 37395 00006920 36C706[0910]0001        	mov	word [SS:exec_init_IP],100h ; initial IP is 100h
 37396                                  
 37397                                  	; SI is AT MOST FF00h. Add FE to account for PSP - word
 37398                                  	; of 0 on stack.
 37399                                  
 37400 00006927 81C6FE00                	add	SI,0FEh 		; make room for stack
 37401                                  
 37402                                  	; MSDOS 6.0
 37403 0000692B 83FEFE                  	cmp	si,0FFFEh		; M047: Q: was there >= 64K available
 37404 0000692E 7404                    	je	short Exec_St_Ok	; M047: Y: stack is fine
 37405 00006930 81C60001                	add	si,100h			; M047: N: add the xtra 100h for stack
 37406                                  
 37407                                  Exec_St_Ok:
 37408                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37409 00006934 368936[0510]            	mov	[SS:exec_init_SP],SI 	; max value for read is also SP!;smr;SS Override
 37410 00006939 36A3[0710]              	mov	[SS:exec_init_SS],AX 					;smr;SS Override
 37411 0000693D 8ED8                    	mov	DS,AX
 37412 0000693F C7040000                	mov	WORD [SI],0		; 0 for return
 37413                                  
 37414                                  	; MSDOS 6.0
 37415                                  
 37416                                  	; M068
 37417                                  	;
 37418                                  	; We now determine if this is a Copy Protected App. If so the 
 37419                                  	; A20OFF_COUNT is set to 6. Note that ChkCopyProt will point to a 
 37420                                  	; a ret if DOS is loaded low. Also DS contains the load segment.
 37421                                  
 37422 00006943 36FF16[6100]            	call	word [ss:ChkCopyProt]	
 37423                                  
 37424                                  Exec_Set_PDB:
 37425                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37426                                  	;mov	bx,[bp-8]
 37427 00006948 8B5EF8                  	mov	BX,Exec_FH		; we are finished with the file.
 37428 0000694B E8A901                  	call	Exec_Dealloc
 37429 0000694E 55                      	push	BP
 37430                                  	;invoke	$Close			; release the jfn
 37431 0000694F E8AA07                  	call	_$CLOSE
 37432 00006952 5D                      	pop	BP
 37433 00006953 E89301                  	call	Exec_Alloc
 37434                                  	;test	byte [bp-5],2
 37435 00006956 F646FB02                	test	Exec_Func,exec_func_overlay
 37436 0000695A 743A                    	jz	short Exec_Build_Header
 37437                                  
 37438                                  	; MSDOS 6.0
 37439 0000695C E8C201                  	call	Scan_Execname
 37440 0000695F E8D601                  	call	Scan_Special_Entries
 37441                                  ;SR;
 37442                                  ;The current lie strategy uses the PSP to store the lie version. However,
 37443                                  ;device drivers are loaded as overlays and have no PSP. To handle them, we
 37444                                  ;use the Sysinit flag provided by the BIOS as part of a structure pointed at
 37445                                  ;by BiosDataPtr. If this flag is set, the overlay call has been issued from
 37446                                  ;Sysinit and therefore must be a device driver load. We then get the lie 
 37447                                  ;version for this driver and put it into the Sysinit PSP. When the driver
 37448                                  ;issues the version check, it gets the lie version until the next overlay
 37449                                  ;call is issued.
 37450                                  
 37451 00006962 36803E[A210]00          	cmp	byte [ss:DriverLoad],0	;was Sysinit processing done?
 37452 00006968 7426                    	je	short norm_ovl		;yes, no special handling
 37453 0000696A 56                      	push	si
 37454 0000696B 06                      	push	es
 37455 0000696C 36C436[A310]            	les	si,[ss:BiosDataPtr]	;get ptr to BIOS data block
 37456                                  	 
 37457                                  	; (es:si points to 'SysinitPresent' address/flag in retrodos4.s) 
 37458 00006971 26803C00                	cmp	byte [es:si],0		;in Sysinit?
 37459 00006975 7411                    	je	short sysinit_done	;no, Sysinit is finished
 37460                                  	
 37461 00006977 368E06[3003]            	mov	es,[ss:CurrentPDB]	;es = current PSP (Sysinit PSP)
 37462 0000697C 36FF36[020F]            	push	word [ss:SPECIAL_VERSION]
 37463 00006981 268F064000              	pop	word [es:PDB.Version]	;store lie version in Sysinit PSP
 37464                                  		;;; PDB.VERSION
 37465 00006986 EB06                    	jmp	short setver_done
 37466                                  sysinit_done:
 37467 00006988 36C606[A210]00          	mov	byte [ss:DriverLoad],0	;Sysinit done,special handling off
 37468                                  setver_done:
 37469 0000698E 07                      	pop	es
 37470 0000698F 5E                      	pop	si
 37471                                  norm_ovl:
 37472                                  	;leave
 37473 00006990 89EC                    	mov	sp,bp		
 37474 00006992 5D                      	pop	bp
 37475                                  
 37476                                  	;transfer SYS_RET_OK		; overlay load -> done
 37477 00006993 E9DA9C                  	jmp	SYS_RET_OK
 37478                                  
 37479                                  Exec_Build_Header:
 37480                                  	;mov	dx,[bp-18]
 37481 00006996 8B56EE                  	mov	DX,Exec_Load_Block
 37482                                  					; assign the space to the process
 37483                                  	;mov	si,1
 37484 00006999 BE0100                  	mov	SI,ARENA.OWNER		; pointer to owner field
 37485                                  	;mov	ax,[bp-14]
 37486 0000699C 8B46F2                  	mov	AX,Exec_Environ 	; get environ pointer
 37487 0000699F 09C0                    	or	AX,AX
 37488 000069A1 7405                    	jz	short No_Owner		; no environment
 37489                                  
 37490 000069A3 48                      	dec	AX			; point to header
 37491 000069A4 8ED8                    	mov	DS,AX
 37492 000069A6 8914                    	mov	[SI],DX 		; assign ownership
 37493                                  No_Owner:
 37494                                  	;mov	ax,[bp-18]
 37495                                  	;mov	AX,Exec_Load_Block	; get load block pointer
 37496                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37497                                  	; 17/12/2022
 37498 000069A8 89D0                    	mov	ax,dx ; 06/06/2019
 37499                                  	;mov	ax,Exec_Load_Block	; get load block pointer
 37500                                  	
 37501 000069AA 48                      	dec	AX
 37502 000069AB 8ED8                    	mov	DS,AX			; point to header
 37503 000069AD 8914                    	mov	[SI],DX 		; assign ownership
 37504                                  
 37505                                  	; MSDOS 6.0
 37506 000069AF 1E                      	push	DS			;AN000;MS. make ES=DS
 37507 000069B0 07                      	pop	ES			;AN000;MS.
 37508                                  	;mov	di,8
 37509 000069B1 BF0800                  	mov	DI,ARENA.NAME		;AN000;MS. ES:DI points to destination
 37510 000069B4 E86A01                  	call	Scan_Execname		;AN007;MS. parse execname
 37511                                  					;	   ds:si->name, cx=name length
 37512 000069B7 51                      	push	CX			;AN007;;MS. save for fake version
 37513 000069B8 56                      	push	SI			;AN007;;MS. save for fake version
 37514                                  
 37515                                  MoveName:				;AN000;
 37516 000069B9 AC                      	lodsb				;AN000;;MS. get char
 37517 000069BA 3C2E                    	cmp	AL,'.'			;AN000;;MS. is '.' ,may be name.exe
 37518 000069BC 7408                    	jz	short Mem_Done		;AN000;;MS. no, move to header
 37519                                  					;AN000;
 37520 000069BE AA                      	stosb				;AN000;;MS. move char
 37521                                  					; MSKK bug fix - limit length copied
 37522 000069BF 83FF10                  	cmp	di,16 ; ARENAHEADERSIZE	; end of memory arena block?
 37523 000069C2 7302                    	jae	short Mem_Done		; jump if so
 37524                                  	;
 37525 000069C4 E2F3                    	loop	MoveName		;AN000;;MS. continue
 37526                                  Mem_Done:				;AN000;
 37527 000069C6 30C0                    	xor	AL,AL			;AN000;;MS. make ASCIIZ
 37528                                  	;cmp	di,16
 37529 000069C8 83FF10                  	cmp	DI,ARENAHEADERSIZE ; 16 ;AN000;MS. if not all filled
 37530 000069CB 7301                    	jae	short Fill8		;AN000;MS.
 37531                                  	
 37532 000069CD AA                      	stosb				;AN000;MS.
 37533                                  	
 37534                                  Fill8:					;AN000;
 37535 000069CE 5E                      	pop	SI			;AN007;MS. ds:si -> file name
 37536 000069CF 59                      	pop	CX			;AN007;MS.
 37537                                  	
 37538 000069D0 E86501                  	call	Scan_Special_Entries	;AN007;MS.
 37539                                  
 37540                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37541 000069D3 52                      	push	DX
 37542                                  	;mov	si,[bp-16]
 37543 000069D4 8B76F0                  	mov	SI,Exec_Size
 37544 000069D7 01D6                    	add	SI,DX
 37545                                  	;Invoke	$Dup_PDB		; ES is now PDB
 37546 000069D9 E87AAC                  	call	_$DUP_PDB
 37547 000069DC 5A                      	pop	DX
 37548                                  
 37549                                  	;push	word [bp-14]
 37550 000069DD FF76F2                  	push	Exec_Environ
 37551                                  	;pop	WORD [ES:2Ch]
 37552 000069E0 268F062C00              	pop	word [ES:PDB.ENVIRON]
 37553                                  
 37554                                  	; MSDOS 6.0			; *** Added for DOS 5.00
 37555                                  					; version number in PSP
 37556 000069E5 36FF36[020F]             	push	word [ss:SPECIAL_VERSION] ; Set the DOS version number to
 37557 000069EA 268F064000              	pop	word [ES:PDB.Version]	; to be used for this application
 37558                                  		; PDB.VERSION
 37559                                  
 37560                                  	; MSDOS 3.3 (& MSDOS 6.0)	; set up proper command line stuff
 37561                                  	;lds	si,[bp-4]
 37562 000069EF C576FC                  	lds	SI,Exec_Blk		; get the block
 37563 000069F2 1E                      	push	DS			; save its location
 37564 000069F3 56                      	push	SI
 37565                                  	;lds	si,[si+6]
 37566 000069F4 C57406                  	lds	SI,[SI+EXEC0.5C_FCB]	; get the 5c fcb
 37567                                  
 37568                                  	; DS points to user space 5C FCB
 37569                                  
 37570 000069F7 B90C00                  	mov	CX,12			; copy drive, name and ext
 37571 000069FA 51                      	push	CX
 37572 000069FB BF5C00                  	mov	DI,5Ch
 37573 000069FE 8A1C                    	mov	BL,[SI]
 37574 00006A00 F3A4                    	rep	movsb
 37575                                  
 37576                                  	; DI = 5Ch + 12 = 5Ch + 0Ch = 68h
 37577                                  
 37578 00006A02 31C0                    	xor	AX,AX			; zero extent, etc for CPM
 37579 00006A04 AB                      	stosw
 37580 00006A05 AB                      	stosw
 37581                                  
 37582                                  	; DI = 5Ch + 12 + 4 = 5Ch + 10h = 6Ch
 37583                                  
 37584 00006A06 59                      	pop	CX
 37585 00006A07 5E                      	pop	SI			; get block
 37586 00006A08 1F                      	pop	DS
 37587 00006A09 1E                      	push	DS			; save (again)
 37588 00006A0A 56                      	push	SI
 37589                                  	;lds	si,[si+0Ah]
 37590 00006A0B C5740A                  	lds	SI,[SI+EXEC0.6C_FCB]	; get 6C FCB
 37591                                  
 37592                                  	; DS points to user space 6C FCB
 37593                                  
 37594 00006A0E 8A3C                    	mov	BH,[SI] 		; do same as above
 37595 00006A10 F3A4                    	rep	movsb
 37596 00006A12 AB                      	stosw
 37597 00006A13 AB                      	stosw
 37598 00006A14 5E                      	pop	SI			; get block (last time)
 37599 00006A15 1F                      	pop	DS
 37600                                  	;ld	si,[si+2]
 37601 00006A16 C57402                  	lds	SI,[SI+EXEC0.COM_LINE]	; command line
 37602                                  
 37603                                  	; DS points to user space 80 command line
 37604                                  
 37605 00006A19 80C980                  	or	CL,80h
 37606 00006A1C 89CF                    	mov	DI,CX
 37607 00006A1E F3A4                    	rep	movsb			; Wham!
 37608                                  
 37609                                  	; Process BX into default AX (validity of drive specs on args).
 37610                                  	; We no longer care about DS:SI.
 37611                                  
 37612 00006A20 FEC9                    	dec	CL			; get 0FFh in CL
 37613 00006A22 88F8                    	mov	AL,BH
 37614 00006A24 30FF                    	xor	BH,BH
 37615                                  	;invoke	GetVisDrv
 37616 00006A26 E8400A                  	call	GetVisDrv
 37617 00006A29 7302                    	jnc	short Exec_BL
 37618                                  
 37619 00006A2B 88CF                    	mov	BH,CL
 37620                                  
 37621                                  Exec_BL:
 37622 00006A2D 88D8                    	mov	AL,BL
 37623 00006A2F 30DB                    	xor	BL,BL
 37624                                  	;invoke	GetVisDrv
 37625 00006A31 E8350A                  	call	GetVisDrv
 37626 00006A34 7302                    	jnc	short Exec_Set_Return
 37627                                  
 37628 00006A36 88CB                    	mov	BL,CL
 37629                                  
 37630                                  Exec_Set_Return:
 37631                                  	;invoke	Get_User_Stack			; get his return address
 37632 00006A38 E83C9A                  	call	Get_User_Stack
 37633                                  
 37634                                  	;push	word [si+14h]
 37635 00006A3B FF7414                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 37636                                  	;push	word [si+12h]
 37637 00006A3E FF7412                  	push	word [SI+user_env.user_IP]
 37638                                  	;push	word [si+14h]
 37639 00006A41 FF7414                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 37640                                  	;push	word [si+12h]
 37641 00006A44 FF7412                  	push	word [SI+user_env.user_IP]
 37642                                  	;pop	word [ES:0Ah]
 37643 00006A47 268F060A00              	pop	WORD [ES:PDB.EXIT]
 37644                                  	;pop	word [ES:0Ch]
 37645 00006A4C 268F060C00              	pop	WORD [ES:PDB.EXIT+2]
 37646                                  
 37647 00006A51 31C0                    	xor	AX,AX
 37648 00006A53 8ED8                    	mov	DS,AX
 37649                                  					; save them where we can get them
 37650                                  					; later when the child exits.
 37651                                  	;pop	word [88h]
 37652 00006A55 8F068800                	pop	word [addr_int_terminate] ; 22h*4
 37653                                  	;pop	word [90h]
 37654 00006A59 8F068A00                	pop	word [addr_int_terminate+2] ; (22h*4)+2
 37655                                  
 37656 00006A5D 36C706[2C03]8000        	mov	WORD [SS:DMAADD],80h	; SS Override
 37657 00006A64 368E1E[3003]            	mov	DS,[SS:CurrentPDB]	; SS Override
 37658 00006A69 368C1E[2E03]            	mov	[SS:DMAADD+2],DS	; SS Override
 37659                                  
 37660                                  	;test	byte [bp-5],1
 37661 00006A6E F646FB01                	test	Exec_Func,exec_func_no_execute
 37662 00006A72 7427                    	jz	short exec_go
 37663                                  
 37664 00006A74 36C536[0510]            	lds	SI,[SS:exec_init_SP]	; get stack SS Override
 37665                                  	;les	di,[bp-4]
 37666 00006A79 C47EFC                  	les	DI,Exec_Blk		; and block for return
 37667                                  	;mov	[es:di+10h],ds
 37668 00006A7C 268C5D10                	mov	[ES:DI+EXEC1.SS],DS	; return SS
 37669                                  
 37670 00006A80 4E                      	dec	SI			; 'push' default AX
 37671 00006A81 4E                      	dec	SI
 37672 00006A82 891C                    	mov	[SI],BX 		; save default AX reg
 37673                                  	;mov	[es:di+0Eh], si
 37674 00006A84 2689750E                	mov	[ES:DI+EXEC1.SP],SI	; return 'SP'
 37675                                  
 37676 00006A88 36C506[0910]            	lds	AX,[SS:exec_init_IP]	; SS Override
 37677                                  	;mov	[es:di+14h],ds
 37678 00006A8D 268C5D14                	mov	[ES:DI+EXEC1.CS],DS	; initial entry stuff
 37679                                  	;mov	[es:di+12h],ax
 37680 00006A91 26894512                	mov	[ES:DI+EXEC1.IP],AX
 37681                                  	
 37682                                  	;leave
 37683 00006A95 89EC                    	mov	sp,bp
 37684 00006A97 5D                      	pop	bp	
 37685                                  
 37686                                  	;transfer SYS_RET_OK
 37687 00006A98 E9D59B                  	jmp	SYS_RET_OK
 37688                                  
 37689                                  exec_go:
 37690 00006A9B 36C536[0910]            	lds	SI,[SS:exec_init_IP]	; get entry point SS Override
 37691 00006AA0 36C43E[0510]            	les	DI,[SS:exec_init_SP]	; new stack SS Override
 37692 00006AA5 8CC0                    	mov	AX,ES
 37693                                  
 37694                                  	; MSDOS 6.0
 37695 00006AA7 36803E[870D]00          	cmp	byte [SS:DosHasHMA],0	; Q: is dos in HMA (M021)
 37696 00006AAD 741A                    	je	short Xfer_To_User	; N: transfer control to user
 37697                                  
 37698 00006AAF 1E                      	push	ds			; Y: control must go to low mem stub
 37699                                  		
 37700 00006AB0 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]		;    where we disable a20 and Xfer 
 37701                                  					;    control to user 
 37702 00006AB5 800E[8600]04            	or	byte [DOS_FLAG],EXECA20OFF ; M068:
 37703                                  					; M004: Set bit to signal int 21
 37704                                  					; ah = 25 & ah= 49. See dossym.inc 
 37705                                  					; under TAG M003 & M009 for 
 37706                                  					; explanation
 37707 00006ABA 8916[6300]              	mov	[A20OFF_PSP],dx		; M068: set the PSP for which A20 is
 37708                                  					; M068: going to be turned OFF.
 37709                                  	
 37710 00006ABE 8CD8                    	mov	ax,ds			; ax = segment of low mem stub
 37711 00006AC0 1F                      	pop	ds
 37712                                  	
 37713 00006AC1 50                      	push	ax			; ret far into the low mem stub
 37714 00006AC2 B8[5F11]                	mov	ax,disa20_xfer
 37715 00006AC5 50                      	push	ax
 37716 00006AC6 8CC0                    	mov	AX,ES			; restore ax
 37717 00006AC8 CB                      	retf
 37718                                  
 37719                                  Xfer_To_User:
 37720                                  	; DS:SI points to entry point
 37721                                  	; AX:DI points to initial stack
 37722                                  	; DX has PDB pointer
 37723                                  	; BX has initial AX value
 37724                                  
 37725 00006AC9 FA                      	cli
 37726                                  	; 15/08/2018
 37727 00006ACA 36C606[2103]00          	mov	BYTE [SS:INDOS],0	; SS Override
 37728                                  
 37729 00006AD0 8ED0                    	mov	SS,AX			; set up user's stack
 37730 00006AD2 89FC                    	mov	SP,DI			; and SP
 37731 00006AD4 FB                      	sti
 37732                                  
 37733 00006AD5 1E                      	push	DS			; fake long call to entry
 37734 00006AD6 56                      	push	SI
 37735 00006AD7 8EC2                    	mov	ES,DX			; set up proper seg registers
 37736 00006AD9 8EDA                    	mov	DS,DX
 37737 00006ADB 89D8                    	mov	AX,BX			; set up proper AX
 37738                                  
 37739 00006ADD CB                      	retf
 37740                                  
 37741                                  ; 04/08/2018 - Retro DOS v3.0
 37742                                  
 37743                                  ;----------------------------------------------------------------------------
 37744                                  ;
 37745                                  ;----------------------------------------------------------------------------
 37746                                  
 37747                                  ExecRead:
 37748 00006ADE E81600                  	CALL	Exec_Dealloc
 37749                                  	;mov	bx,[bp-8]
 37750 00006AE1 8B5EF8                  	MOV	bx,Exec_FH
 37751                                  
 37752 00006AE4 55                      	PUSH	BP
 37753 00006AE5 E82507                  	call	_$READ
 37754 00006AE8 5D                      	POP	BP
 37755                                  
 37756                                  	;CALL	Exec_Alloc
 37757                                  	;retn
 37758                                  	; 18/12/2022
 37759                                  	;jmp	short Exec_Alloc
 37760                                  
 37761                                  ; 18/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS) 
 37762                                  
 37763                                  ;----------------------------------------------------------------------------
 37764                                  ;
 37765                                  ;----------------------------------------------------------------------------
 37766                                  
 37767                                  Exec_Alloc:
 37768 00006AE9 53                      	push	BX
 37769                                  	;mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
 37770                                  	; 20/05/2019 - Retro DOS v4.0
 37771                                  	; MSDOS 6.0
 37772 00006AEA 368B1E[3003]            	mov	bx,[SS:CurrentPDB]  ; SS Override
 37773 00006AEF E81000                  	call	ChangeOwners
 37774 00006AF2 E83BAE                  	call	LCritMEM
 37775 00006AF5 5B                      	pop	BX
 37776 00006AF6 C3                      	retn
 37777                                  
 37778                                  ;----------------------------------------------------------------------------
 37779                                  ;
 37780                                  ;----------------------------------------------------------------------------
 37781                                  
 37782                                  Exec_Dealloc:
 37783 00006AF7 53                      	push	BX
 37784                                  	;mov	bx,0
 37785 00006AF8 29DB                    	sub	BX,BX		; (bx) = ARENA_OWNER_SYSTEM
 37786 00006AFA E806AE                  	call	ECritMEM
 37787 00006AFD E80200                  	call	ChangeOwners
 37788 00006B00 5B                      	pop	BX
 37789 00006B01 C3                      	retn
 37790                                  
 37791                                  ; 18/12/2022
 37792                                  %if 0
 37793                                  ;----------------------------------------------------------------------------
 37794                                  ;
 37795                                  ;----------------------------------------------------------------------------
 37796                                  
 37797                                  Exec_Alloc:
 37798                                  	push	BX
 37799                                  	;mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
 37800                                  	; 20/05/2019 - Retro DOS v4.0
 37801                                  	; MSDOS 6.0
 37802                                  	mov	bx,[SS:CurrentPDB]  ; SS Override
 37803                                  	call	ChangeOwners
 37804                                  	call	LCritMEM
 37805                                  	pop	BX
 37806                                  	retn
 37807                                  
 37808                                  %endif
 37809                                  
 37810                                  ;----------------------------------------------------------------------------
 37811                                  ;
 37812                                  ;----------------------------------------------------------------------------
 37813                                  
 37814                                  ChangeOwners:
 37815 00006B02 9C                      	pushf
 37816 00006B03 50                      	push	AX
 37817                                  	;mov	ax,[bp-14]
 37818 00006B04 8B46F2                  	mov	AX,Exec_Environ
 37819 00006B07 E80900                  	call	ChangeOwner
 37820                                  	;mov	ax,[bp-18]
 37821 00006B0A 8B46EE                  	mov	AX,Exec_Load_Block
 37822 00006B0D E80300                  	call	ChangeOwner
 37823 00006B10 58                      	pop	AX
 37824 00006B11 9D                      	popf
 37825                                  chgown_retn:
 37826 00006B12 C3                      	retn
 37827                                  
 37828                                  ;----------------------------------------------------------------------------
 37829                                  ;
 37830                                  ;----------------------------------------------------------------------------
 37831                                  
 37832                                  ChangeOwner:
 37833 00006B13 09C0                    	or	AX,AX			; is area allocated?
 37834 00006B15 74FB                    	jz	short chgown_retn	; no, do nothing
 37835 00006B17 48                      	dec	AX
 37836 00006B18 1E                      	push	DS
 37837 00006B19 8ED8                    	mov	DS,AX
 37838 00006B1B 891E0100                	mov	[ARENA.OWNER],BX
 37839 00006B1F 1F                      	pop	DS
 37840 00006B20 C3                      	retn
 37841                                  
 37842                                  ;----------------------------------------------------------------------------
 37843                                  ;
 37844                                  ;----------------------------------------------------------------------------
 37845                                  
 37846                                  ; 20/05/2019 - Retro DOS v4.0
 37847                                  
 37848                                  	; MSDOS 6.0
 37849                                  Scan_Execname:
 37850 00006B21 C576E6                  	lds	SI,ExecName		; DS:SI points to name
 37851                                  Scan_Execname1:				; M028
 37852                                  Save_Begin:				;
 37853 00006B24 89F1                    	mov	CX,SI			; CX= starting addr
 37854                                  Scan0:					;
 37855 00006B26 AC                      	lodsb				; get char
 37856                                  
 37857 00006B27 3C3A                    	cmp	AL,':'			; is ':' , may be A:name
 37858 00006B29 74F9                    	jz	short Save_Begin	; yes, save si
 37859 00006B2B 3C5C                    	cmp	AL,'\'                  ; is '\', may be A:\name
 37860 00006B2D 74F5                    	jz	short Save_Begin	; yes, save si
 37861 00006B2F 3C00                    	cmp	AL,0			; is end of name
 37862 00006B31 75F3                    	jnz	short Scan0		; no, continue scanning
 37863 00006B33 29CE                    	sub	SI,CX			; get name's length
 37864 00006B35 87F1                    	xchg	SI,CX			; cx= length, si= starting addr
 37865                                  
 37866 00006B37 C3                      	retn
 37867                                  
 37868                                  ;----------------------------------------------------------------------------
 37869                                  ;
 37870                                  ;----------------------------------------------------------------------------
 37871                                  
 37872                                  ; 20/05/2019 - Retro DOS v4.0
 37873                                  
 37874                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37875                                  ; DOSCODE:A0EDh (MSDOS 5.0, MSDOS.SYS)
 37876                                  
 37877                                  	; MSDOS 6.0
 37878                                  
 37879                                  Scan_Special_Entries:
 37880                                  
 37881 00006B38 49                      	dec	CX			; cx= name length
 37882                                  ;M060	mov	DI,[Special_Entries]	; es:di -> addr of special entries
 37883                                  					;reset to current version
 37884                                  	;mov	word [ss:SPECIAL_VERSION],1406h 
 37885                                  				; (MSDOS 6.21, MSDOS.SYS, DOSCODE:A14Eh)
 37886                                  	;mov	word [ss:SPECIAL_VERSION],5
 37887                                  				; (MSDOS 5.0, MSDOS.SYS, DOSCODE:A0EEh)
 37888                                  
 37889                                  				; 5 for Retro DOS 4.0 (01/12/2022, MSDOS 5.0)
 37890 00006B39 36C706[020F]070A        	mov	word [ss:SPECIAL_VERSION],(MINOR_VERSION<<8)+MAJOR_VERSION
 37891                                  				; 0005h for Retro DOS v4.1 (MSDOS 5.0)
 37892                                  				; 24/09/2023
 37893                                  				; 1606h for Retro DOS v4.2 (MSDOS 6.22)
 37894                                  ;***	call	Reset_Version
 37895                                  
 37896                                  ;M060	push	SS
 37897                                  ;M060	pop	ES
 37898                                  
 37899 00006B40 36C43E[5D00]            	les	DI,[SS:UU_IFS_DOS_CALL]	;M060; ES:DI --> Table in SETVER.SYS
 37900 00006B45 8CC0                    	mov	AX,ES			;M060; First do a NULL ptr check to
 37901 00006B47 09F8                    	or	AX,DI			;M060; be sure the table exists
 37902 00006B49 7427                    	jz	short End_List		;M060; If ZR then no table
 37903                                  
 37904                                  GetEntries:
 37905 00006B4B 268A05                  	mov	AL,[ES:DI]		; end of list
 37906 00006B4E 08C0                    	or	AL,AL
 37907 00006B50 7420                    	jz	short End_List		; yes
 37908                                  
 37909 00006B52 36893E[0E06]            	mov	[ss:TEMP_VAR2],DI	; save di
 37910 00006B57 38C8                    	cmp	AL,CL			; same length ?
 37911 00006B59 751B                    	jnz	short SkipOne 		; no
 37912                                  
 37913 00006B5B 47                      	inc	DI			; es:di -> special name
 37914 00006B5C 51                      	push	CX			; save length and name addr
 37915 00006B5D 56                      	push	SI
 37916                                  
 37917                                  ; M050 - BEGIN
 37918                                  
 37919 00006B5E 50                      	push	ax			; save len
 37920                                  sse_next_char:
 37921 00006B5F AC                      	lodsb
 37922 00006B60 E897EE                  	call	UCase
 37923 00006B63 AE                      	scasb
 37924 00006B64 750D                    	jne	short Not_Matched
 37925 00006B66 E2F7                    	loop	sse_next_char
 37926                                  	
 37927                                  ;	repz	cmpsb			; same name ?
 37928                                  ;	jnz	short Not_Matched	; no
 37929                                  
 37930 00006B68 58                      	pop	ax			; take len off the stack
 37931                                  
 37932                                  ; M050 - END
 37933                                  
 37934 00006B69 268B05                  	mov	AX,[ES:DI]		; get special version
 37935 00006B6C 36A3[020F]              	mov	[ss:SPECIAL_VERSION],AX	; save it
 37936                                  
 37937                                  ;***	mov	AL,[ES:DI+2]		; get fake count
 37938                                  ;***	mov	[ss:FAKE_COUNT],AL 	; save it
 37939                                  
 37940 00006B70 5E                      	pop	SI
 37941 00006B71 59                      	pop	CX
 37942                                  	; 18/12/2022
 37943                                  	;jmp	SHORT End_List
 37944                                  
 37945                                  	; 18/12/2022
 37946                                  End_List:
 37947 00006B72 C3                      	retn
 37948                                  
 37949                                  Not_Matched:
 37950 00006B73 58                      	pop	ax			; get len from stack ; M050
 37951 00006B74 5E                      	pop	SI			; restore si,cx
 37952 00006B75 59                      	pop	CX
 37953                                  
 37954                                  SkipOne:
 37955 00006B76 368B3E[0E06]            	mov	DI,[ss:TEMP_VAR2]	; restore old di use SS Override
 37956 00006B7B 30E4                    	xor	AH,AH			; position to next entry
 37957 00006B7D 01C7                    	add	DI,AX
 37958                                  
 37959 00006B7F 83C703                  	add	DI,3			; DI -> next entry length
 37960                                  ;***	add	DI,4			; DI -> next entry length
 37961                                  
 37962 00006B82 EBC7                    	jmp	short GetEntries
 37963                                  
 37964                                  	; 18/12/2022
 37965                                  ;End_List:
 37966                                  	;retn
 37967                                  
 37968                                  ; 04/08/2018 - Retro DOS v3.0
 37969                                  ; IBMDOS.COm (MSDOS 3.3, 1987) - Offset 633Dh
 37970                                  
 37971                                  ;----------------------------------------------------------------------------
 37972                                  ;SUBTTL Terminate and stay resident handler
 37973                                  ;
 37974                                  ; Input:    DX is  an  offset  from  CurrentPDB  at which to
 37975                                  ;	    truncate the current block.
 37976                                  ;
 37977                                  ; output:   The current block is truncated (expanded) to be [DX+15]/16
 37978                                  ;	    paragraphs long.  An exit is simulated via resetting CurrentPDB
 37979                                  ;	    and restoring the vectors.
 37980                                  ;
 37981                                  ;----------------------------------------------------------------------------
 37982                                  
 37983                                  	; 20/05/2019 - Retro DOS v4.0
 37984                                  	; DOSCODE:A19Bh (MSDOS 6.21, MSDOS.SYS)
 37985                                  
 37986                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 37987                                  	; DOSCODE:A13Bh (MSDOS 5.0, MSDOS.SYS)
 37988                                  
 37989                                  _$KEEP_PROCESS:
 37990 00006B84 50                      	push	AX			; keep exit code around
 37991                                  	;mov	byte [SS:EXIT_TYPE],3
 37992 00006B85 36C606[7C05]03          	mov	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS
 37993 00006B8B 368E06[3003]            	mov	ES,[SS:CurrentPDB]
 37994 00006B90 83FA06                  	cmp	DX,6h			; keep enough space around for system
 37995 00006B93 7303                    	jae	short Keep_Shrink	; info
 37996                                  
 37997 00006B95 BA0600                  	mov	DX,6h
 37998                                  
 37999                                  Keep_Shrink:
 38000 00006B98 89D3                    	mov	BX,DX
 38001 00006B9A 53                      	push	BX
 38002 00006B9B 06                      	push	ES
 38003 00006B9C E82E02                  	call	_$SETBLOCK		; ignore return codes.
 38004 00006B9F 1F                      	pop	DS
 38005 00006BA0 5B                      	pop	BX
 38006 00006BA1 7207                    	jc	short Keep_Done		; failed on modification
 38007                                  
 38008 00006BA3 8CD8                    	mov	AX,DS
 38009 00006BA5 01D8                    	add	AX,BX
 38010                                  	;mov	[2],ax
 38011 00006BA7 A30200                  	mov	[PDB.BLOCK_LEN],AX	;PBUGBUG
 38012                                  
 38013                                  Keep_Done:
 38014 00006BAA 58                      	pop	AX
 38015 00006BAB EB26                    	jmp	SHORT exit_inner	; and let abort take care of the rest
 38016                                  
 38017                                  ;----------------------------------------------------------------------------
 38018                                  ;
 38019                                  ;----------------------------------------------------------------------------
 38020                                  
 38021                                  STAY_RESIDENT:
 38022                                  	;mov	ax,3100h
 38023 00006BAD B80031                  	mov	AX,(KEEP_PROCESS<<8)+0 ; Lower part is return code;PBUGBUG
 38024 00006BB0 83C20F                  	add	DX,15
 38025 00006BB3 D1DA                    	rcr	DX,1
 38026 00006BB5 B103                    	mov	CL,3
 38027 00006BB7 D3EA                    	shr	DX,CL
 38028                                  
 38029 00006BB9 E93597                  	jmp	COMMAND
 38030                                  
 38031                                  ;----------------------------------------------------------------------------
 38032                                  ;SUBTTL $EXIT - return to parent process
 38033                                  ;   Assembler usage:
 38034                                  ;	    MOV     AL, code
 38035                                  ;	    MOV     AH, Exit
 38036                                  ;	    INT     int_command
 38037                                  ;   Error return:
 38038                                  ;	    None.
 38039                                  ;
 38040                                  ;----------------------------------------------------------------------------
 38041                                  
 38042                                  	; 20/05/2019 - Retro DOS v4.0
 38043                                  	; DOSCODE:A1D3h (MSDOS 6.21, MSDOS.SYS)
 38044                                  
 38045                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 38046                                  	; DOSCODE:A173h (MSDOS 5.0, MSDOS.SYS)
 38047                                  _$EXIT:
 38048                                  	; 04/08/2018 - Retro DOS v3.0
 38049                                  	; IBMDOSDOS.COM (MSDOS 3.3, 1987) - Offset 6375h
 38050 00006BBC 30E4                    	xor	AH,AH
 38051 00006BBE 368626[4D03]            	xchg	AH,[SS:DidCTRLC]
 38052 00006BC3 08E4                    	or	AH,AH
 38053                                  	;mov	BYTE [SS:EXIT_TYPE],0
 38054 00006BC5 36C606[7C05]00          	mov	BYTE [SS:EXIT_TYPE],EXIT_TERMINATE
 38055 00006BCB 7406                    	jz	short exit_inner
 38056                                  	;mov	BYTE [SS:EXIT_TYPE],1
 38057 00006BCD 36C606[7C05]01          	mov	BYTE [SS:EXIT_TYPE],EXIT_CTRL_C
 38058                                  
 38059                                  	;entry	Exit_inner
 38060                                  exit_inner:
 38061 00006BD3 E8A198                  	call	Get_User_Stack		;PBUGBUG
 38062                                  
 38063 00006BD6 36FF36[3003]            	push	word [ss:CurrentPDB]
 38064                                  	;pop	word [si+14h]
 38065 00006BDB 8F4414                  	pop	word [SI+user_env.user_CS] ;PBUGBUG
 38066 00006BDE EB08                    	jmp	short abort_inner
 38067                                  
 38068                                  ;BREAK <$ABORT -- Terminate a process>
 38069                                  ;----------------------------------------------------------------------------
 38070                                  ; Inputs:
 38071                                  ;	user_CS:00 must point to valid program header block
 38072                                  ; Function:
 38073                                  ;	Restore terminate and Cntrl-C addresses, flush buffers and transfer
 38074                                  ;	to the terminate address
 38075                                  ; Returns:
 38076                                  ;	TO THE TERMINATE ADDRESS
 38077                                  ;----------------------------------------------------------------------------
 38078                                  
 38079                                  _$ABORT:
 38080 00006BE0 30C0                    	xor	AL,AL
 38081                                  	;mov	byte [SS:EXIT_TYPE],0
 38082                                  	;mov	byte [SS:EXIT_TYPE],AL ; = 0
 38083 00006BE2 36C606[7C05]00          	mov	byte [SS:EXIT_TYPE],EXIT_ABORT
 38084                                  
 38085                                  	; abort_inner must have AL set as the exit code! The exit type
 38086                                  	; is retrieved from exit_type. Also, the PDB at user_CS needs
 38087                                  	; to be correct as the one that is terminating.
 38088                                  
 38089                                  abort_inner:
 38090 00006BE8 368A26[7C05]            	mov	AH,[SS:EXIT_TYPE]
 38091 00006BED 36A3[3403]              	mov	[SS:exit_code],AX
 38092 00006BF1 E88398                  	call	Get_User_Stack
 38093                                  
 38094                                  	;mov	ds,[si+14h]
 38095 00006BF4 8E5C14                  	mov	DS,[SI+user_env.user_CS] ; set up old interrupts ;PBUGBUG
 38096 00006BF7 31C0                    	xor	AX,AX
 38097 00006BF9 8EC0                    	mov	ES,AX
 38098                                  	;mov	si,10
 38099 00006BFB BE0A00                  	mov	SI,SAVEXIT
 38100                                  	;mov	di,88h
 38101 00006BFE BF8800                  	mov	DI,addr_int_terminate
 38102 00006C01 A5                      	movsw
 38103 00006C02 A5                      	movsw
 38104 00006C03 A5                      	movsw
 38105 00006C04 A5                      	movsw
 38106 00006C05 A5                      	movsw
 38107 00006C06 A5                      	movsw
 38108 00006C07 E90AF2                  	jmp	reset_environment
 38109                                  
 38110                                  ;----------------------------------------------------------------------------
 38111                                  ;
 38112                                  ; fixexepatch will point to this is DOS loads low. 
 38113                                  ;
 38114                                  ;----------------------------------------------------------------------------
 38115                                  ; MSDOS 6.0
 38116                                  
 38117                                  ; 29/04/2019 - Retro DOS v4.0
 38118                                  ; DOSCODE:A221h (MSDOS 6.21, MSDOS.SYS)
 38119                                  
 38120                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 38121                                  ; DOSCODE:A1C1h (MSDOS 5.0, MSDOS.SYS)
 38122                                  
 38123                                  RetExePatch: ; proc near
 38124                                  	
 38125 00006C0A C3                      	retn
 38126                                  
 38127                                  ;============================================================================
 38128                                  ; ALLOC.ASM, MSDOS 6.0, 1991
 38129                                  ;============================================================================
 38130                                  ; 04/08/2018 - Retro DOS v3.0
 38131                                  ; 14/05/2019 - Retro DOS v4.0
 38132                                  
 38133                                  ;	TITLE ALLOC.ASM - memory arena manager	NAME Alloc
 38134                                  
 38135                                  ;**
 38136                                  ;	Microsoft Confidential
 38137                                  ;	Copyright (C) Microsoft Corporation 1991
 38138                                  ;	All Rights Reserved.
 38139                                  ;
 38140                                  ;	Memory related system calls and low level routines for MSDOS 2.X.
 38141                                  ;	I/O specs are defined in DISPATCH.
 38142                                  ;
 38143                                  ;	$ALLOC
 38144                                  ;	$SETBLOCK
 38145                                  ;	$DEALLOC
 38146                                  ;	$AllocOper
 38147                                  ;	arena_free_process
 38148                                  ;	arena_next
 38149                                  ;	check_signature
 38150                                  ;	Coalesce
 38151                                  ;
 38152                                  ;	Modification history:
 38153                                  ;
 38154                                  ;	    Created: ARR 30 March 1983
 38155                                  ;
 38156                                  ;	    Revision: M000 - added support for allocing UMBs. 7/9/90
 38157                                  ;		      M003 - added support for link/unlink UMBs from
 38158                                  ;			     DOS arena chain. 7/18/90
 38159                                  ;		      M009 - Added error returns invalid function and 
 38160                                  ;			     arena trashed in set link state call.
 38161                                  ;		      M010 - Release UMB arenas allocated to current PDB
 38162                                  ;			     if UMB_HEAD is initialized.
 38163                                  ;
 38164                                  ;		      M016 - MACE utilities mkeyrate.com version 1.0 
 38165                                  ;			     support. Please see under M009 in 
 38166                                  ;			     ..\inc\dossym.inc. 8/31/90.
 38167                                  ;
 38168                                  ;		      M061 - In GetLastArena, if linking in UMBs check to make
 38169                                  ;			     sure that umb_head arena is valid and also make
 38170                                  ;			     sure that the previous arena is pointing to 
 38171                                  ;			     umb_head.
 38172                                  ;
 38173                                  ;		      M064 - allow HIGH_ONLY bit to be set by a call to 
 38174                                  ;			     set allloc strategy.
 38175                                  ;			     use STRAT_MASK to mask out bits 6 & 7 of 
 38176                                  ;			     bx in AllocSetStrat.
 38177                                  ;
 38178                                  ;		      M068 - use a count value (A20OFF_COUNT) rather than
 38179                                  ;			     a bit to indicate to dos dispatcher to turn
 38180                                  ;			     a20 off before iret. See M016.
 38181                                  ;
 38182                                  
 38183                                  ;	BREAK	<memory allocation utility routines>
 38184                                  
 38185                                  
 38186                                  ; 15/04/2018 - Retro DOS v2.0
 38187                                  ;----------------------------------------------------------------------------
 38188                                  ; xenix memory calls for MSDOS
 38189                                  ;
 38190                                  ; CAUTION: The following routines rely on the fact that arena_signature and
 38191                                  ; arena_owner_system are all equal to zero and are contained in DI.
 38192                                  ;
 38193                                  ;INCLUDE DOSSEG.ASM
 38194                                  
 38195                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 38196                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 38197                                  
 38198                                  ;.xlist
 38199                                  ;.xcref
 38200                                  ;INCLUDE DOSSYM.ASM
 38201                                  ;INCLUDE DEVSYM.ASM
 38202                                  ;.cref
 38203                                  ;.list
 38204                                  
 38205                                  ;TITLE ALLOC.ASM - memory arena manager
 38206                                  ;NAME Alloc
 38207                                  
 38208                                  ;SUBTTL memory allocation utility routines
 38209                                  ;PAGE
 38210                                  ;
 38211                                  ; arena data
 38212                                  ;
 38213                                  ;       i_need  arena_head,WORD         ; seg address of start of arena
 38214                                  ;       i_need  CurrentPDB,WORD         ; current process data block addr
 38215                                  ;       i_need  FirstArena,WORD         ; first free block found
 38216                                  ;       i_need  BestArena,WORD          ; best free block found
 38217                                  ;       i_need  LastArena,WORD          ; last free block found
 38218                                  ;       i_need  AllocMethod,BYTE        ; how to alloc first(best)last
 38219                                  
 38220                                  ;**	Arena_Free_Process
 38221                                  ;----------------------------------------------------------------------------
 38222                                  ;	Free all arena blocks allocated to a prOcess
 38223                                  ;
 38224                                  ;	ENTRY	(bx) = PID of process
 38225                                  ;	EXIT	none
 38226                                  ;	USES	????? BUGBUG
 38227                                  ;----------------------------------------------------------------------------
 38228                                  
 38229                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 38230                                  	; DOSCODE:A1C2h (MSDOS 5.0, MSDOS.SYS)
 38231                                  
 38232                                  arena_free_process:
 38233                                  	; 14/05/2019 - Retro DOS v4.0
 38234                                  	; 04/08/2018 - Retro DOS v3.0
 38235 00006C0B 36A1[2400]                      MOV	AX,[SS:arena_head]
 38236                                  arena_free_process_start:
 38237 00006C0F BF0000                  	MOV     DI,ARENA.SIGNATURE ; 0
 38238                                  	;MOV	AX,[SS:arena_head] ; 15/04/2018  
 38239 00006C12 E83000                          CALL	check_signature         ; ES <- AX, check for valid block
 38240                                  
 38241                                  arena_free_process_loop:
 38242                                          ;retc
 38243 00006C15 723D                            JC	SHORT AFP_RETN	; Retro DOS v2.0 - 05/03/2018
 38244 00006C17 06                      	PUSH    ES
 38245 00006C18 1F                              POP     DS
 38246                                  	;cmp	[1],bx 
 38247 00006C19 391E0100                        CMP     [ARENA.OWNER],BX	; is block owned by pid?
 38248 00006C1D 7504                            JNZ     SHORT arena_free_next	; no, skip to next
 38249                                  	;mov	[1],di
 38250 00006C1F 893E0100                        MOV     [ARENA.OWNER],DI	; yes... free him
 38251                                  
 38252                                  arena_free_next:
 38253                                  	;cmp	byte [di],5Ah ;'Z'
 38254 00006C23 803D5A                          CMP     BYTE [DI],arena_signature_end
 38255                                                                          ; end of road, Jack?
 38256                                          ;retz				; never come back no more
 38257                                  	;JZ	SHORT AFP_RETN  ; MSDOS 3.3 (& MSDOS 2.11)
 38258                                  	; 14/05/2019
 38259                                  	; MSDOS 6.0
 38260 00006C26 7405                    	jz	short arena_chk_umbs
 38261                                          
 38262 00006C28 E81300                  	CALL    arena_next              ; next item in ES/AX carry set if trash
 38263 00006C2B EBE8                            JMP     SHORT arena_free_process_loop
 38264                                  
 38265                                  	; MSDOS 6.0
 38266                                  arena_chk_umbs:				; M010 - Start
 38267                                  	; 20/05/2019
 38268 00006C2D 36A1[8C00]              	mov	ax,[ss:UMB_HEAD]	; ax = umb_head
 38269 00006C31 83F8FF                  	cmp	ax,0FFFFh		; Q: is umb_head initialized
 38270 00006C34 741E                    	je	short ret_label		; N: we're done
 38271                                  	
 38272 00006C36 8CDF                    	mov	di,ds			; di = last arena
 38273 00006C38 39C7                    	cmp	di,ax			; Q: is last arena above umb_head
 38274 00006C3A 7318                    	jae	short ret_label		; Y: we've scanned umbs also. done.
 38275 00006C3C EBD1                    	jmp	short arena_free_process_start
 38276                                  					; M010 - End
 38277                                  ;AFP_RETN:
 38278                                  ;	RETN
 38279                                  
 38280                                  ;	BREAK	<Arena Helper Routines>
 38281                                  
 38282                                  ;**	Arena_Next - Find Next item in Arena
 38283                                  ;----------------------------------------------------------------------------
 38284                                  ;	ENTRY	DS - pointer to block head
 38285                                  ;		(di) = 0
 38286                                  ;	EXIT	AX,ES - pointers to next head
 38287                                  ;		'C' set iff arena damaged
 38288                                  ;----------------------------------------------------------------------------
 38289                                  
 38290                                  arena_next:
 38291 00006C3E 8CD8                            MOV     AX,DS                   ; AX <- current block
 38292 00006C40 03060300                        ADD     AX,[ARENA.SIZE]		; AX <- AX + current block length
 38293 00006C44 40                              INC     AX                      ; remember that header!
 38294                                  
 38295                                  ;       fall into check_signature and return
 38296                                  ;
 38297                                  ;       CALL    check_signature         ; ES <- AX, carry set if error
 38298                                  ;       RETN
 38299                                  
 38300                                  ;**	Check_Signature - Check Memory Block Signature
 38301                                  ;----------------------------------------------------------------------------
 38302                                  ;	ENTRY	(AX) = address of block header
 38303                                  ;		(di) = 0
 38304                                  ;	EXIT	 ES = AX
 38305                                  ;		'C' clear if signature good
 38306                                  ;		'C' set if signature bad
 38307                                  ;	USES	ES, Flags
 38308                                  ;----------------------------------------------------------------------------
 38309                                  
 38310                                  check_signature:        
 38311                                  
 38312 00006C45 8EC0                    	MOV     ES,AX                   ; ES <- AX
 38313                                  	;cmp	byte [es:di],4Dh ; 'M'
 38314 00006C47 26803D4D                        CMP     BYTE [ES:DI],arena_signature_normal
 38315                                                                          ; IF next signature = not_end THEN
 38316 00006C4B 7407                            JZ      SHORT check_signature_ok ;   GOTO ok
 38317                                  	;cmp 	byte [es:di],5Ah ; 'Z'
 38318 00006C4D 26803D5A                        CMP     BYTE [ES:DI],arena_signature_end
 38319                                                                          ; IF next signature = end then
 38320 00006C51 7401                            JZ      SHORT check_signature_ok ;   GOTO ok
 38321 00006C53 F9                              STC                             ; set error
 38322                                  ret_label: ; MSDOS 6.0
 38323                                  AFP_RETN:
 38324                                   	; Retro DOS v2.0 - 05/03/2018
 38325                                  check_signature_ok:
 38326                                  COALESCE_RETN:
 38327 00006C54 C3                      	RETN
 38328                                  
 38329                                  ;**	Coalesce - Combine free blocks ahead with current block
 38330                                  ;----------------------------------------------------------------------------
 38331                                  ;	Coalesce adds the block following the argument to the argument block,
 38332                                  ;	iff it's free.  Coalesce is usually used to join free blocks, but
 38333                                  ;	some callers (such as $setblock) use it to join a free block to it's
 38334                                  ;	preceeding allocated block.
 38335                                  ;
 38336                                  ;	ENTRY	(ds) = pointer to the head of a free block
 38337                                  ;		(di) = 0
 38338                                  ;	EXIT	'C' clear if OK
 38339                                  ;		  (ds) unchanged, this block updated
 38340                                  ;		  (ax) = address of next block, IFF not at end
 38341                                  ;		'C' set if arena trashed
 38342                                  ;	USES	(cx)
 38343                                  ;----------------------------------------------------------------------------
 38344                                          
 38345                                  Coalesce:
 38346                                  	;cmp	byte [di],5Ah ; 'Z'
 38347 00006C55 803D5A                  	CMP     BYTE [DI],arena_signature_end
 38348                                                                          ; IF current signature = END THEN
 38349                                          ;retz				;   GOTO ok
 38350 00006C58 74FA                            jz	short COALESCE_RETN
 38351 00006C5A E8E1FF                  	CALL    arena_next              ; ES, AX <- next block, Carry set if error
 38352                                          ;retc				; IF no error THEN GOTO check
 38353 00006C5D 72F5                    	jc	short COALESCE_RETN
 38354                                  
 38355                                  coalesce_check:
 38356                                  	;cmp	[es:1],di
 38357 00006C5F 26393E0100                      CMP     [ES:ARENA.OWNER],DI
 38358                                          ;retnz				; IF next block isnt free THEN return
 38359 00006C64 75EE                            JNZ	SHORT COALESCE_RETN
 38360                                  	;mov	cx,[ES:3]
 38361 00006C66 268B0E0300              	MOV     CX,[ES:ARENA.SIZE]	; CX <- next block size
 38362 00006C6B 41                              INC     CX                      ; CX <- CX + 1 (for header size)
 38363                                          ;ADD	[3],CX
 38364 00006C6C 010E0300                	ADD     [ARENA.SIZE],CX		; current size <- current size + CX
 38365 00006C70 268A0D                          MOV     CL,[ES:DI]              ; move up signature
 38366 00006C73 880D                            MOV     [DI],CL
 38367 00006C75 EBDE                            JMP     SHORT Coalesce		; try again
 38368                                  
 38369                                  ; 04/08/2018 - Retro DOS v3.0
 38370                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 641Fh
 38371                                  
 38372                                  ;	BREAK  <$Alloc - allocate space in memory>
 38373                                  
 38374                                  ; MSDOS 6.0
 38375                                  ;----------------------------------------------------------------------------
 38376                                  ;**	$Alloc - Allocate Memory Space
 38377                                  ;
 38378                                  ;	$Alloc services the INT21 that allocates memory space to a program.
 38379                                  ;	Alloc returns a pointer to a free block of memory that
 38380                                  ;	has the requested size in paragraphs.
 38381                                  ;
 38382                                  ;	If the allocation strategy is HIGH_FIRST or HIGH_ONLY memory is 
 38383                                  ;	scanned from umb_head if not from arena_head. If the strategy is
 38384                                  ; 	HIGH_FIRST the scan is continued from arena_head if a block of 
 38385                                  ;	appropriate size is not found in the UMBs. If the strategy is 
 38386                                  ;	HIGH_FIRST+HIGH_ONLY only the UMBs are scanned for memory.
 38387                                  ;
 38388                                  ;	In either case if bit 0 of UmbFlag is not initialized then the scan
 38389                                  ;	starts from arena_head.
 38390                                  ;
 38391                                  ;	Assembler usage:
 38392                                  ;           MOV     BX,size
 38393                                  ;           MOV     AH,Alloc
 38394                                  ;           INT     21h
 38395                                  ;
 38396                                  ;	BUGBUG - a lot can be done to improve performance. We can set marks
 38397                                  ;	so that we start searching the arena at it's first non-trivial free
 38398                                  ;	block, we can peephole the code, etc. (We can move some subr calls
 38399                                  ;	inline, etc.) I assume that this is called rarely and that the arena
 38400                                  ;	doesn't have too many memory objects in it beyond the first free one.
 38401                                  ;	verify that this is true; if so, this can stay as is
 38402                                  ;
 38403                                  ;	ENTRY	(bx) = requested size, in bytes
 38404                                  ;		(DS) = (ES) = DOSGROUP
 38405                                  ;	EXIT	'C' clear if memory allocated
 38406                                  ;		  (ax:0) = address of requested memory
 38407                                  ;		'C' set if request failed
 38408                                  ;		  (AX) = error_not_enough_memory
 38409                                  ;		    (bx) = max size we could have allocated
 38410                                  ;		  (ax) = error_arena_trashed
 38411                                  ;	USES	All
 38412                                  ;----------------------------------------------------------------------------
 38413                                  
 38414                                  ; MSDOS 2.11 (& MSDOS 3.3)
 38415                                  ;----------------------------------------------------------------------------
 38416                                  ;SUBTTL $Alloc - allocate space in memory
 38417                                  ;
 38418                                  ;   Assembler usage:
 38419                                  ;           MOV     BX,size
 38420                                  ;           MOV     AH,Alloc
 38421                                  ;           INT     21h
 38422                                  ;         AX:0 is pointer to allocated memory
 38423                                  ;         BX is max size if not enough memory
 38424                                  ;
 38425                                  ;   Description:
 38426                                  ;           Alloc returns  a  pointer  to  a  free  block of
 38427                                  ;       memory that has the requested  size  in  paragraphs.
 38428                                  ;
 38429                                  ;   Error return:
 38430                                  ;           AX = error_not_enough_memory
 38431                                  ;              = error_arena_trashed
 38432                                  ;----------------------------------------------------------------------------
 38433                                  
 38434                                  ; DOSCODE:A28Eh (MSDOS 6.21, MSDOS.SYS)
 38435                                  
 38436                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 38437                                  ; DOSCODE:A22Eh (MSDOS 5.0, MSDOS.SYS)
 38438                                  
 38439                                  _$ALLOC:
 38440                                  	; 25/05/2019 (Procedure has been checked and confirmed)
 38441                                  	; 14/05/2019 - Retro DOS v4.0
 38442                                  	; 04/08/2018 - Retro DOS v3.0
 38443                                  	;EnterCrit critMem
 38444 00006C77 E889AC                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 38445                                  
 38446                                  ; 17/12/2022
 38447                                  ; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38448                                  ;%if 0
 38449                                  	; 14/05/2019
 38450 00006C7A 16                      	push	ss
 38451 00006C7B 1F                      	pop	ds
 38452                                  
 38453                                  	; MSDOS 6.0
 38454                                  	;mov	ax,[ss:arena_head]
 38455                                  	;mov	[ss:START_ARENA],ax	; assume LOW_FIRST
 38456                                  
 38457 00006C7C A1[2400]                	mov	ax,[arena_head]
 38458 00006C7F A3[8E00]                	mov	[START_ARENA],ax			
 38459                                  	
 38460                                  	;test	byte [ss:AllocMethod],HIGH_FIRST+HIGH_ONLY
 38461 00006C82 F606[0203]C0            	test	byte [AllocMethod],HIGH_FIRST+HIGH_ONLY
 38462                                  					; Q: should we start scanning from 
 38463                                  					;    UMB's
 38464 00006C87 740D                    	jz	short norm_alloc	; N: scan from arena_head
 38465                                  		
 38466                                  	;;cmp	word [ss:UMB_HEAD],-1	; Q: Has umb_head been initialized
 38467                                  	;cmp	word [UMB_HEAD],-1
 38468                                  	;je	short norm_alloc	; N: scan from arena_head
 38469                                  
 38470                                  	;test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 38471 00006C89 F606[8900]01            	test	byte [UMBFLAG],LINKSTATE ; 1
 38472 00006C8E 7406                    	jz	short norm_alloc	; N: scan from arena_head
 38473                                  	
 38474                                  	;mov	ax,[ss:UMB_HEAD]
 38475                                  	;mov	[ss:START_ARENA],ax	; start_arena = umb_head
 38476 00006C90 A1[8C00]                	mov	ax,[UMB_HEAD]
 38477 00006C93 A3[8E00]                	mov	[START_ARENA],ax
 38478                                  					; M000 - end
 38479                                  norm_alloc:
 38480 00006C96 31C0                            XOR     AX,AX
 38481 00006C98 89C7                            MOV     DI,AX
 38482                                  	; 15/03/2018
 38483                                          ;MOV	[SS:FirstArena],AX	; init the options
 38484                                          ;MOV	[SS:BestArena],AX
 38485                                          ;MOV	[SS:LastArena],AX
 38486                                  	; 14/05/2019
 38487 00006C9A A3[4003]                	MOV	[FirstArena],AX		; init the options
 38488 00006C9D A3[4203]                        MOV	[BestArena],AX
 38489 00006CA0 A3[4403]                        MOV	[LastArena],AX
 38490 00006CA3 50                              PUSH    AX                      ; alloc_max <- 0
 38491                                  	; 04/08/2018
 38492                                  start_scan:
 38493                                  	;MOV	AX,[SS:arena_head]	; AX <- beginning of arena
 38494                                  	;MOV	AX,[arena_head]
 38495                                  
 38496                                  	; 14/05/2019	
 38497                                  	; MSDOS 6.0
 38498                                  	;mov	ax,[SS:START_ARENA]	; M000: AX <- beginning of arena
 38499 00006CA4 A1[8E00]                	mov	ax,[START_ARENA]
 38500                                  
 38501                                  	; 27/09/2023 (BugFix) (*) 
 38502                                  	; ( jump from 'alloc_chk' (ds<>ss, ax = [SS:START_ARENA]))
 38503                                  start_scan_x:
 38504                                  
 38505 00006CA7 E89BFF                  	CALL    check_signature         ; ES <- AX, carry set if error
 38506 00006CAA 7236                            JC      SHORT alloc_err		; IF error THEN GOTO err
 38507                                  
 38508                                  ;%endif
 38509                                  
 38510                                  ; 17/12/2022
 38511                                  %if 0
 38512                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38513                                  
 38514                                  	; MSDOS 6.0
 38515                                  	mov	ax,[ss:arena_head]
 38516                                  	mov	[ss:START_ARENA],ax	; assume LOW_FIRST
 38517                                  
 38518                                  	test	byte [ss:AllocMethod],HIGH_FIRST+HIGH_ONLY
 38519                                  					; Q: should we start scanning from 
 38520                                  					;    UMB's
 38521                                  	jz	short norm_alloc	; N: scan from arena_head
 38522                                  		
 38523                                  	;cmp	word [ss:UMB_HEAD],-1	; Q: Has umb_head been initialized
 38524                                  	;je	short norm_alloc	; N: scan from arena_head
 38525                                  
 38526                                  	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 38527                                  	jz	short norm_alloc	; N: scan from arena_head
 38528                                  	
 38529                                  	mov	ax,[ss:UMB_HEAD]
 38530                                  	mov	[ss:START_ARENA],ax	; start_arena = umb_head
 38531                                  					; M000 - end
 38532                                  norm_alloc:
 38533                                          XOR     AX,AX
 38534                                          MOV     DI,AX
 38535                                  	; 15/03/2018
 38536                                  	MOV	[SS:FirstArena],AX	; init the options
 38537                                  	MOV	[SS:BestArena],AX
 38538                                  	MOV	[SS:LastArena],AX
 38539                                          PUSH    AX                      ; alloc_max <- 0
 38540                                  	; 04/08/2018
 38541                                  start_scan:
 38542                                  	;MOV	AX,[SS:arena_head]	; AX <- beginning of arena
 38543                                  	; 14/05/2019	
 38544                                  	; MSDOS 6.0
 38545                                  	mov	ax,[SS:START_ARENA]	; M000: AX <- beginning of arena
 38546                                  	CALL    check_signature         ; ES <- AX, carry set if error
 38547                                          JC      SHORT alloc_err		; IF error THEN GOTO err
 38548                                  %endif
 38549                                  
 38550                                  alloc_scan:
 38551 00006CAC 06                              PUSH    ES
 38552 00006CAD 1F                              POP     DS                      ; DS <- ES
 38553 00006CAE 393E0100                        CMP     [ARENA.OWNER],DI ; 0
 38554 00006CB2 7469                            JZ      SHORT alloc_free	; IF current block is free THEN examine
 38555                                  
 38556                                  alloc_next:
 38557                                  	; MSDOS 6.0			; M000 - start 
 38558 00006CB4 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 38559 00006CBA 741C                    	jz	short norm_strat	; N: see if we reached last arena
 38560                                  	
 38561 00006CBC 36F606[0203]80          	test	byte [ss:AllocMethod],HIGH_FIRST
 38562                                  					; Q: is alloc strategy high_first
 38563 00006CC2 7414                    	jz	short norm_strat	; N: see if we reached last arena
 38564 00006CC4 36A1[8E00]              	mov	ax,[ss:START_ARENA]
 38565 00006CC8 363B06[2400]            	cmp	ax,[ss:arena_head]	; Q: did we start scan from 
 38566                                  					;    arena_head
 38567 00006CCD 7509                    	jne	short norm_strat	; N: see if we reached last arena
 38568 00006CCF 8CD8                    	mov	ax,ds			; ax = current block
 38569 00006CD1 363B06[8C00]            	cmp	ax,[ss:UMB_HEAD]	; Q: check against umb_head 
 38570 00006CD6 EB03                    	jmp	short alloc_chk_end
 38571                                  
 38572                                  norm_strat:
 38573                                  	;cmp	byte [di],5Ah ; 'Z'
 38574 00006CD8 803D5A                          CMP     BYTE [DI],arena_signature_end
 38575                                                                          ; IF current block is last THEN
 38576                                  alloc_chk_end:
 38577 00006CDB 740E                            JZ      SHORT alloc_end		;   GOTO end
 38578 00006CDD E85EFF                          CALL    arena_next              ; AX, ES <- next block, Carry set if error
 38579 00006CE0 73CA                            JNC     SHORT alloc_scan	; IF no error THEN GOTO scan
 38580                                  
 38581                                  alloc_err:
 38582 00006CE2 58                              POP     AX
 38583                                  
 38584                                  alloc_trashed:
 38585                                  	;LeaveCrit critMem
 38586 00006CE3 E84AAC                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0	
 38587                                          ;error	error_arena_trashed
 38588                                  	;mov	al,7
 38589 00006CE6 B007                    	MOV	AL,error_arena_trashed
 38590                                  alloc_errj:
 38591 00006CE8 E98F99                  	JMP	SYS_RET_ERR
 38592                                  
 38593                                  alloc_end:
 38594                                  	; 18/05/2019
 38595 00006CEB 36833E[4003]00                  CMP	WORD [SS:FirstArena],0
 38596 00006CF1 7403                    	jz	short alloc_chk 
 38597 00006CF3 E98400                  	jmp	alloc_do_split
 38598                                  
 38599                                  alloc_chk:
 38600                                  	; MSDOS 6.0
 38601 00006CF6 36A1[2400]              	mov	ax,[ss:arena_head]
 38602 00006CFA 363B06[8E00]            	cmp	ax,[ss:START_ARENA]	; Q: started scanning from arena_head
 38603 00006CFF 740E                    	je	short alloc_fail	; Y: not enough memory
 38604                                  					; N:
 38605                                  					; Q: is the alloc strat HIGH_ONLY
 38606 00006D01 36F606[0203]40          	test 	byte [ss:AllocMethod],HIGH_ONLY
 38607 00006D07 7506                    	jnz	short alloc_fail	; Y: return size of largest UMB
 38608                                  	
 38609 00006D09 36A3[8E00]              	mov	[ss:START_ARENA],ax	; N: start scanning from arena_head
 38610                                  	; 27/09/2023 (*)
 38611 00006D0D EB98                    	jmp	short start_scan_x ; (*) ; (BugFix)
 38612                                  	;jmp	short start_scan
 38613                                  					; M000 - end
 38614                                  
 38615                                  alloc_fail:
 38616                                          ;invoke Get_User_Stack
 38617 00006D0F E86597                          CALL	Get_User_Stack
 38618 00006D12 5B                      	POP     BX
 38619                                          ;MOV	[SI].user_BX,BX
 38620                                  	;MOV	[SI+2],BX
 38621 00006D13 895C02                  	mov	[SI+user_env.user_BX],bx
 38622                                  	;LeaveCrit critMem
 38623 00006D16 E817AC                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 38624                                  	;error	error_not_enough_memory
 38625                                  	;mov	al,8
 38626 00006D19 B008                    	MOV	AL,error_not_enough_memory
 38627                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38628 00006D1B EBCB                    	jmp	short alloc_errj
 38629                                  	;JMP	SYS_RET_ERR
 38630                                  
 38631                                  alloc_free:
 38632 00006D1D E835FF                          CALL    Coalesce		; add following free block to current
 38633 00006D20 72C0                            JC	SHORT alloc_err		; IF error THEN GOTO err
 38634 00006D22 8B0E0300                        MOV     CX,[ARENA.SIZE]
 38635 00006D26 5A                              POP     DX                      ; check for max found size
 38636 00006D27 39D1                            CMP     CX,DX
 38637 00006D29 7602                            JNA     SHORT alloc_test
 38638 00006D2B 89CA                            MOV     DX,CX
 38639                                  
 38640                                  alloc_test:
 38641 00006D2D 52                              PUSH    DX
 38642 00006D2E 39CB                            CMP     BX,CX                   ; IF BX > size of current block THEN
 38643 00006D30 7782                    	JA      SHORT alloc_next	;   GOTO next
 38644                                  
 38645                                  	; 15/03/2018
 38646 00006D32 36833E[4003]00                  CMP     WORD [SS:FirstArena],0
 38647 00006D38 7505                    	JNZ	SHORT alloc_best
 38648 00006D3A 368C1E[4003]                    MOV     [SS:FirstArena],DS	; save first one found	
 38649                                  alloc_best:
 38650 00006D3F 36833E[4203]00                  CMP     WORD [SS:BestArena],0
 38651 00006D45 740E                            JZ      SHORT alloc_make_best	; initial best
 38652 00006D47 06                              PUSH	ES
 38653 00006D48 368E06[4203]                    MOV     ES,[SS:BestArena]
 38654 00006D4D 26390E0300                      CMP     [ES:ARENA.SIZE],CX	; is size of best larger than found?
 38655 00006D52 07                              POP	ES
 38656 00006D53 7605                            JBE     SHORT alloc_last
 38657                                  alloc_make_best:
 38658 00006D55 368C1E[4203]                    MOV     [SS:BestArena],DS	; assign best
 38659                                  alloc_last:
 38660 00006D5A 368C1E[4403]                    MOV     [SS:LastArena],DS 	; assign last
 38661 00006D5F E952FF                          JMP     alloc_next
 38662                                  ;
 38663                                  ; split the block high
 38664                                  ;
 38665                                  alloc_do_split_high:
 38666 00006D62 368E1E[4403]                    MOV     DS,[SS:LastArena]
 38667 00006D67 8B0E0300                        MOV     CX,[ARENA.SIZE]
 38668 00006D6B 29D9                            SUB     CX,BX
 38669 00006D6D 8CDA                            MOV     DX,DS
 38670 00006D6F 7449                            JE      SHORT alloc_set_owner	; sizes are equal, no split
 38671 00006D71 01CA                            ADD     DX,CX                   ; point to next block
 38672 00006D73 8EC2                            MOV     ES,DX                   ; no decrement!
 38673 00006D75 49                              DEC     CX
 38674 00006D76 87D9                            XCHG    BX,CX                   ; bx has size of lower block
 38675 00006D78 EB2B                            JMP     SHORT alloc_set_sizes	; cx has upper (requested) size
 38676                                  ;
 38677                                  ; we have scanned memory and have found all appropriate blocks
 38678                                  ; check for the type of allocation desired; first and best are identical
 38679                                  ; last must be split high
 38680                                  ;
 38681                                  alloc_do_split:
 38682                                  
 38683                                  ; 17/12/2022
 38684                                  ; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38685                                  ;%if 0
 38686                                  	; 14/05/2019
 38687                                  	; MSDOS 6.0			; M000 - start
 38688                                  	;xor	cx,cx
 38689 00006D7A 368A0E[0203]            	mov	cl,[ss:AllocMethod]
 38690                                  	;and	cx,STRAT_MASK ; 0FF3Fh	; mask off bit 7
 38691 00006D7F 80E13F                  	and	cl,3Fh
 38692                                  	;cmp	cx,BEST_FIT ; 1		; Q; is the alloc strategy best_fit
 38693 00006D82 80F901                  	cmp	cl,BEST_FIT
 38694 00006D85 77DB                    	ja	short alloc_do_split_high
 38695                                  ;%endif
 38696                                  
 38697                                  	; 17/12/2022
 38698                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38699                                  	; MSDOS 6.0 & MSDOS 5.0
 38700                                  	;xor	cx,cx
 38701                                  	;mov	cl,[ss:AllocMethod]
 38702                                  	;and	cx,STRAT_MASK ; 0FF3Fh	; mask off bit 7
 38703                                  	;cmp	cx,BEST_FIT ; 1		; Q; is the alloc strategy best_fit
 38704                                  	;ja	short alloc_do_split_high
 38705                                  
 38706                                  	; 15/03/2018
 38707                                          ;;CMP	BYTE [SS:AllocMethod], 1
 38708                                  	; 04/08/2018
 38709                                  	;CMP	BYTE [SS:AllocMethod],BEST_FIT
 38710                                          ;JA	SHORT alloc_do_split_high
 38711                                          
 38712 00006D87 368E1E[4003]            	MOV     DS,[SS:FirstArena]        
 38713 00006D8C 7205                    	JB      SHORT alloc_get_size
 38714 00006D8E 368E1E[4203]            	MOV     DS,[SS:BestArena]
 38715                                  
 38716                                  alloc_get_size:
 38717 00006D93 8B0E0300                        MOV     CX,[ARENA.SIZE]
 38718 00006D97 29D9                            SUB     CX,BX                   ; get room left over
 38719 00006D99 8CD8                            MOV     AX,DS
 38720 00006D9B 89C2                            MOV     DX,AX                   ; save for owner setting
 38721 00006D9D 741B                            JE      SHORT alloc_set_owner	; IF BX = size THEN (don't split)
 38722 00006D9F 01D8                            ADD     AX,BX
 38723 00006DA1 40                              INC     AX                      ; remember the header
 38724 00006DA2 8EC0                            MOV     ES,AX                   ; ES <- DS + BX (new header location)
 38725 00006DA4 49                              DEC     CX                      ; CX <- size of split block
 38726                                  alloc_set_sizes:
 38727 00006DA5 891E0300                        MOV     [ARENA.SIZE],BX		; current size <- BX
 38728 00006DA9 26890E0300                      MOV     [ES:ARENA.SIZE],CX      ; split size <- CX
 38729                                  	;mov	bl,4Dh ; 'M'
 38730 00006DAE B34D                            MOV     BL,arena_signature_normal
 38731 00006DB0 861D                            XCHG    BL,[DI]			; current signature <- 4D
 38732 00006DB2 26881D                          MOV     [ES:DI],BL		; new block sig <- old block sig
 38733 00006DB5 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 38734                                  
 38735                                  alloc_set_owner:
 38736 00006DBA 8EDA                            MOV     DS,DX
 38737 00006DBC 36A1[3003]                      MOV     AX,[SS:CurrentPDB] ; 15/03/2018
 38738 00006DC0 A30100                          MOV     [ARENA.OWNER],AX
 38739 00006DC3 8CD8                            MOV     AX,DS
 38740 00006DC5 40                              INC     AX
 38741 00006DC6 5B                              POP     BX
 38742                                  	;LeaveCrit critMem
 38743 00006DC7 E866AB                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 38744                                  	
 38745                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38746                                  alloc_ok:
 38747                                          ;transfer SYS_RET_OK
 38748 00006DCA E9A398                  	JMP	SYS_RET_OK
 38749                                  
 38750                                  ;	BREAK $SETBLOCK - change size of an allocated block (if possible)
 38751                                  
 38752                                  ; MSDOS 6.0
 38753                                  ;----------------------------------------------------------------------------
 38754                                  ;**	$SETBLOCK - Change size of an Allocated Block
 38755                                  ;
 38756                                  ;	Setblock changes the size of an allocated block. First, we coalesce
 38757                                  ;	any following free space onto this block; then we try to trim the
 38758                                  ;	block down to the size requested.
 38759                                  ;
 38760                                  ;	Note that if the guy wants to grow the block but that growth fails,
 38761                                  ;	we still go ahead and coalesce any trailing free blocks onto it.
 38762                                  ;	Thus the maximum-size-possible value that we return has already
 38763                                  ;	been allocated! This is a bug, dare we fix it? BUGBUG
 38764                                  ;
 38765                                  ;	NOTE - $SETBLOCK is in bed with $ALLOC and jumps into $ALLOC to
 38766                                  ;		finish it's work. For this reason we build the allocsf
 38767                                  ;		structure on the frame, to make us compatible with $ALLOCs
 38768                                  ;		code.
 38769                                  ;
 38770                                  ;	ENTRY	(es) = segment of old block
 38771                                  ;		(bx) = newsize
 38772                                  ;		(ah) = SETBLOCK
 38773                                  ;
 38774                                  ;	EXIT	'C' clear if OK
 38775                                  ;		'C' set if error
 38776                                  ;		  (ax) = error_invalid_block
 38777                                  ;		       = error_arena_trashed
 38778                                  ;		       = error_not_enough_memory
 38779                                  ;		       = error_invalid_function
 38780                                  ;		  (bx) = maximum size possible, iff (ax) = error_not_enough_memory
 38781                                  ;	USES	???? BUGBUG
 38782                                  ;----------------------------------------------------------------------------
 38783                                  
 38784                                  ; MSDOS 2.11 (& MSDOS 3.3)
 38785                                  ;----------------------------------------------------------------------------
 38786                                  ;SUBTTL $SETBLOCK - change size of an allocated block (if possible)
 38787                                  ;
 38788                                  ;   Assembler usage:
 38789                                  ;           MOV     ES,block
 38790                                  ;           MOV     BX,newsize
 38791                                  ;           MOV     AH,setblock
 38792                                  ;           INT     21h
 38793                                  ;         if setblock fails for growing, BX will have the maximum
 38794                                  ;         size possible
 38795                                  ;   Error return:
 38796                                  ;           AX = error_invalid_block
 38797                                  ;              = error_arena_trashed
 38798                                  ;              = error_not_enough_memory
 38799                                  ;              = error_invalid_function
 38800                                  ;----------------------------------------------------------------------------
 38801                                  
 38802                                  _$SETBLOCK:        
 38803                                  	; 04/08/2018 - Retro DOS v3.0
 38804                                  	;EnterCrit   critMem
 38805 00006DCD E833AB                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 38806                                  
 38807 00006DD0 BF0000                  	MOV     DI,ARENA.SIGNATURE
 38808 00006DD3 8CC0                            MOV     AX,ES
 38809 00006DD5 48                              DEC     AX
 38810 00006DD6 E86CFE                          CALL    check_signature
 38811 00006DD9 7303                            JNC     SHORT setblock_grab
 38812                                  
 38813                                  setblock_bad:
 38814 00006DDB E905FF                          JMP     alloc_trashed
 38815                                  
 38816                                  setblock_grab:
 38817 00006DDE 8ED8                            MOV     DS,AX
 38818 00006DE0 E872FE                          CALL    Coalesce
 38819 00006DE3 72F6                            JC      SHORT setblock_bad
 38820 00006DE5 8B0E0300                        MOV     CX,[ARENA.SIZE]
 38821 00006DE9 51                              PUSH    CX
 38822 00006DEA 39CB                            CMP     BX,CX
 38823 00006DEC 76A5                            JBE     SHORT alloc_get_size
 38824 00006DEE E91EFF                          JMP     alloc_fail
 38825                                  
 38826                                  ;	BREAK $DEALLOC - free previously allocated piece of memory
 38827                                  
 38828                                  ; MSDOS 6.0
 38829                                  ;----------------------------------------------------------------------------
 38830                                  ;**	$DEALLOC - Free Heap Memory
 38831                                  ;
 38832                                  ;	ENTRY	(es) = address of item
 38833                                  ;
 38834                                  ;	EXIT	'C' clear of OK
 38835                                  ;		'C' set if error
 38836                                  ;		  (AX) = error_invalid_block
 38837                                  ;	USES	???? BUGBUG
 38838                                  
 38839                                  ; MSDOS 2.11 (& MSDOS 3.3)
 38840                                  ;----------------------------------------------------------------------------
 38841                                  ;SUBTTL $DEALLOC - free previously allocated piece of memory
 38842                                  ;
 38843                                  ;   Assembler usage:
 38844                                  ;           MOV     ES,block
 38845                                  ;           MOV     AH,dealloc
 38846                                  ;           INT     21h
 38847                                  ;
 38848                                  ;   Error return:
 38849                                  ;           AX = error_invalid_block
 38850                                  ;              = error_arena_trashed
 38851                                  ;---------------------------------------------------------------------------- 
 38852                                  
 38853                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38854                                  _$DEALLOC:
 38855                                  	; 14/05/2019 - Retro DOS v4.0    
 38856                                  	; 04/08/2018 - Retro DOS v3.0
 38857                                  	;EnterCrit   critMem
 38858 00006DF1 E80FAB                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 38859                                  
 38860                                  	; MSDOS 6.0			; M016, M068 - Start
 38861 00006DF4 36F606[8600]04          	test	byte [ss:DOS_FLAG],EXECA20OFF
 38862                                  					; Q: was the previous call an int 21
 38863                                  					;    exec call
 38864 00006DFA 740D                    	jz	short deallocate	; N: continue
 38865 00006DFC 36803E[8500]00          	cmp	byte [ss:A20OFF_COUNT], 0 ; Q: is count 0
 38866 00006E02 7505                    	jne	short deallocate	; N: continue
 38867                                  	;mov	byte [ss:A20OFF_COUNT], 1 ; Y: set count to 1
 38868                                  	; 25/09/2023
 38869 00006E04 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]
 38870                                  deallocate:				; M016, M068 - End
 38871 00006E09 BF0000                  	MOV     DI,ARENA.SIGNATURE ; = 0
 38872 00006E0C 8CC0                            MOV     AX,ES
 38873 00006E0E 48                              DEC     AX
 38874 00006E0F E833FE                          CALL    check_signature
 38875 00006E12 720A                            JC      SHORT dealloc_err
 38876 00006E14 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 38877                                  	;LeaveCrit critMem
 38878 00006E19 E814AB                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 38879                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38880                                          ;transfer SYS_RET_OK
 38881                                  dealloc_ok:
 38882 00006E1C EBAC                    	jmp	short alloc_ok
 38883                                  	;JMP	SYS_RET_OK
 38884                                  
 38885                                  dealloc_err:
 38886                                  	;LeaveCrit critMem
 38887 00006E1E E80FAB                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 38888                                          ;error	error_invalid_block
 38889                                  	;mov	al,9
 38890 00006E21 B009                    	MOV	AL,error_invalid_block
 38891                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38892                                  dealloc_errj:
 38893                                  AllocOperErrj:	; 17/12/2022
 38894 00006E23 E95498                  	JMP	SYS_RET_ERR
 38895                                  
 38896                                  ;	BREAK $AllocOper - get/set allocation mechanism
 38897                                  
 38898                                  ; MSDOS 6.0
 38899                                  ;----------------------------------------------------------------------------
 38900                                  ;**	$AllocOper - Get/Set Allocation Mechanism
 38901                                  ;
 38902                                  ;	Assembler usage:
 38903                                  ;           MOV     AH,AllocOper
 38904                                  ;           MOV     BX,method
 38905                                  ;           MOV     AL,func
 38906                                  ;           INT     21h
 38907                                  ;
 38908                                  ;	ENTRY	
 38909                                  ;		(al) = 0
 38910                                  ;		  Get allocation Strategy in (ax)
 38911                                  ;
 38912                                  ;		(al) = 1, (bx) = method = zw0000xy
 38913                                  ;		  Set allocation strategy.
 38914                                  ;		   w  = 1  => HIGH_ONLY
 38915                                  ;		   z  = 1  => HIGH_FIRST
 38916                                  ;		   xy = 00 => FIRST_FIT
 38917                                  ;		      = 01 => BEST_FIT
 38918                                  ;		      = 10 => LAST_FIT
 38919                                  ;
 38920                                  ;		(al) = 2
 38921                                  ;		  Get UMB link state in (al)
 38922                                  ;
 38923                                  ;		(al) = 3
 38924                                  ;		  Set UMB link state
 38925                                  ;		   (bx) = 0 => Unlink UMBs
 38926                                  ;		   (bx) = 1 => Link UMBs
 38927                                  ;
 38928                                  ;
 38929                                  ;	EXIT	'C' clear if OK
 38930                                  ;
 38931                                  ;		 if (al) = 0
 38932                                  ;		  (ax) = existing method
 38933                                  ;		 if (al) = 1
 38934                                  ;		  Sets allocation strategy
 38935                                  ;		 if (al) = 2
 38936                                  ;		  (al) = 0 => UMBs not linked
 38937                                  ;		  (al) = 1 => UMBs linked in
 38938                                  ;		 if (al) = 3
 38939                                  ;		  Links/Unlinks the UMBs into DOS chain
 38940                                  ;
 38941                                  ;		'C' set if error
 38942                                  ;		  AX = error_invalid_function
 38943                                  ;
 38944                                  ;	Rev. M000 - added support for HIGH_FIRST in (al) = 1. 7/9/90
 38945                                  ; 	Rev. M003 - added functions (al) = 2 and (al) = 3. 7/18/90
 38946                                  ;	Rev. M009 - (al) = 3 will return 'invalid function' in ax if
 38947                                  ;		    umbhead has'nt been initialized by sysinit and 'trashed
 38948                                  ;		    arena' if an arena sig is damaged.
 38949                                  ;----------------------------------------------------------------------------
 38950                                  
 38951                                  ; MSDOS 2.11 (& MSDOS 3.3)
 38952                                  ;----------------------------------------------------------------------------
 38953                                  ;SUBTTL $AllocOper - get/set allocation mechanism
 38954                                  ;
 38955                                  ;   Assembler usage:
 38956                                  ;           MOV     AH,AllocOper
 38957                                  ;           MOV     BX,method
 38958                                  ;           MOV     AL,func
 38959                                  ;           INT     21h
 38960                                  ;
 38961                                  ;   Error return:
 38962                                  ;           AX = error_invalid_function
 38963                                  ;----------------------------------------------------------------------------
 38964                                  
 38965                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38966                                  _$ALLOCOPER:
 38967                                  	; 14/05/2019 - Retro DOS v4.0
 38968                                  	; MSDOS 6.0
 38969 00006E26 08C0                    	or	al,al ; 0
 38970 00006E28 741E                    	jz	short AllocGetStrat
 38971                                  	; 17/12/2022
 38972                                  	;cmp	al,1
 38973                                  	;jz	short AllocSetStrat
 38974                                  
 38975                                  	; 01/12/2022
 38976                                  	;cmp	al, 2
 38977                                  	;jb	short AllocSetStrat
 38978                                  	;ja	short AllocSetLink
 38979                                  	;;jmp	short AllocGetLink
 38980                                  ;AllocGetLink:
 38981                                  	; MSDOS 6.0
 38982                                  	;mov	al,[ss:UMBFLAG]		; return link state in al
 38983                                  	;and 	al,LINKSTATE		
 38984                                  	;;transfer SYS_RET_OK
 38985                                  	;jmp	SYS_RET_OK
 38986                                  
 38987 00006E2A 3C02                    	cmp	al,2
 38988                                  	; 17/12/2022
 38989 00006E2C 7223                    	jb	short AllocSetStrat ; al = 1
 38990 00006E2E 7432                    	je	short AllocGetLink
 38991                                  
 38992                                  	;cmp	al,2
 38993                                  	;jz	short AllocGetLink
 38994 00006E30 3C03                    	cmp	al,3
 38995 00006E32 7436                    	jz	short AllocSetLink
 38996                                  
 38997                                  	; 15/04/2018
 38998                                  	;CMP	AL,1
 38999                                          ;JB	SHORT AllocOperGet
 39000                                          ;JZ	SHORT AllocOperSet
 39001                                  
 39002                                  AllocOperError:
 39003                                  	; 04/08/2018 - Retro DOS v3.0
 39004                                  	; MSDOS 3.3 (& MSDOS 6.0)	; Extended Error Locus	
 39005                                  	;mov	byte [ss:EXTERR_LOCUS],5
 39006 00006E34 36C606[2303]05                  MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 39007                                  	;error	error_invalid_function
 39008                                  	;mov	al,1
 39009 00006E3A B001                    	MOV	AL,error_invalid_function
 39010                                  	; 17/12/2022
 39011                                  ;AllocOperErrj:
 39012                                  	;JMP	SYS_RET_ERR
 39013                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39014                                  	;jmp	short dealloc_errj
 39015                                  	; 17/12/2022
 39016 00006E3C EBE5                    	jmp	short AllocOperErrj
 39017                                  
 39018                                  AllocArenaError:
 39019                                  	; MSDOS 6.0
 39020 00006E3E 36C606[2303]05          	MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 39021                                  					; M009: Extended Error Locus
 39022                                  	;error	error_arena_trashed	; M009:
 39023                                  	;mov	al,7
 39024 00006E44 B007                    	MOV	AL,error_arena_trashed
 39025                                  	;JMP	SYS_RET_ERR
 39026 00006E46 EBDB                    	jmp	short AllocOperErrj ; 17/12/2022
 39027                                  
 39028                                  AllocGetStrat: 
 39029                                  	; MSDOS 6.0
 39030                                  AllocOperGet:
 39031 00006E48 36A0[0203]                      MOV     AL,[SS:AllocMethod]
 39032 00006E4C 30E4                            XOR     AH,AH
 39033                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39034                                  	;transfer SYS_RET_OK
 39035                                  AllocOperOk:
 39036                                  	; 17/12/2022
 39037                                  	;jmp	short dealloc_ok
 39038 00006E4E E91F98                  	JMP	SYS_RET_OK
 39039                                  
 39040                                  AllocSetStrat: 
 39041                                  	; 14/05/2019
 39042                                  	; MSDOS 6.0
 39043 00006E51 53                      	push	bx			; M000 - start
 39044                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39045                                  	;and	bx,STRAT_MASK ; 0FF3Fh	; M064: mask off bit 6 & 7
 39046                                  	; 17/12/2022
 39047 00006E52 80E33F                  	and	bl,3Fh
 39048 00006E55 83FB02                  	cmp	bx,2			; BX must be 0-2
 39049                                  	;cmp	bl,2
 39050 00006E58 5B                      	pop	bx			; M000 - end
 39051 00006E59 77D9                    	ja	short AllocOperError
 39052                                  
 39053                                  AllocOperSet:
 39054 00006E5B 36881E[0203]                    MOV     [SS:AllocMethod],BL
 39055                                    	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39056                                  	;transfer SYS_RET_OK
 39057                                  AllocOperOkj:
 39058 00006E60 EBEC                    	jmp	short AllocOperOk
 39059                                  	;JMP	SYS_RET_OK
 39060                                  
 39061                                  AllocGetLink:
 39062                                  	; MSDOS 6.0
 39063 00006E62 36A0[8900]              	mov	al,[ss:UMBFLAG]		; return link state in al
 39064                                  	;and	al,1
 39065 00006E66 2401                    	and 	al,LINKSTATE		
 39066                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39067                                  	;transfer SYS_RET_OK
 39068                                  AllocOperOkj2:
 39069                                  	; 17/12/2022
 39070 00006E68 EBE4                    	jmp	short AllocOperOk
 39071                                  	;jmp	short AllocOperOkj
 39072                                  	;;JMP	SYS_RET_OK
 39073                                  
 39074                                  AllocSetLink:
 39075                                  	; MSDOS 6.0			; M009 - start
 39076 00006E6A 368B0E[8C00]            	mov	cx,[ss:UMB_HEAD]	; cx = umb_head
 39077 00006E6F 83F9FF                  	cmp	cx,0FFFFh		; Q: has umb_head been initialized
 39078 00006E72 74C0                    	je	short AllocOperError	; N: error
 39079                                  					; Y: continue
 39080                                  					; M009 - end
 39081 00006E74 83FB01                  	cmp	bx,1			
 39082 00006E77 7204                    	jb	short UnlinkUmbs
 39083 00006E79 741C                    	jz	short LinkUmbs
 39084                                  	
 39085 00006E7B EBB7                    	jmp	short AllocOperError
 39086                                  	
 39087                                  UnlinkUmbs:
 39088                                  	;test	byte [ss:UMBFLAG],1
 39089 00006E7D 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: umbs unlinked?
 39090 00006E83 7410                    	jz	short unlinked		; Y: return 
 39091                                  	
 39092 00006E85 E82900                  	call	GetLastArena		; get arena before umb_head in DS
 39093 00006E88 72B4                    	jc	short AllocArenaError	; M009: arena trashed
 39094                                  	
 39095                                  					; make it last
 39096 00006E8A C60600005A              	mov	byte [0],arena_signature_end
 39097                                  	
 39098                                  	;and	byte [ss:UMBFLAG],0FEh
 39099 00006E8F 368026[8900]FE          	and	byte [ss:UMBFLAG],~LINKSTATE ; indicate unlink'd state in umbflag
 39100                                  	
 39101                                  unlinked:
 39102                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39103                                  	;transfer SYS_RET_OK
 39104                                  	; 17/12/2022
 39105 00006E95 EBB7                    	jmp	short AllocOperOk
 39106                                  	;jmp	short AllocOperOkj2
 39107                                  	;;JMP	SYS_RET_OK
 39108                                  
 39109                                  LinkUmbs:
 39110 00006E97 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: umbs linked?
 39111 00006E9D 7510                    	jnz	short linked		; Y: return
 39112                                  	
 39113 00006E9F E80F00                  	call	GetLastArena		; get arena before umb_head
 39114 00006EA2 729A                    	jc	short AllocArenaError	; M009: arena trashed
 39115                                  	
 39116                                  					; make it normal. M061: ds points to
 39117                                  					; arena before umb_head
 39118 00006EA4 C60600004D              	mov	byte [0],arena_signature_normal
 39119                                  	
 39120 00006EA9 36800E[8900]01          	or	byte [ss:UMBFLAG],LINKSTATE ; indicate link'd state in umbflag
 39121                                  linked:
 39122                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39123                                  	;transfer SYS_RET_OK
 39124                                  	; 17/12/2022
 39125 00006EAF EB9D                    	jmp	short AllocOperOk
 39126                                  	;jmp	short unlinked
 39127                                  	;;JMP	SYS_RET_OK
 39128                                  
 39129                                  ; MSDOS 6.0
 39130                                  ;--------------------------------------------------------------------------
 39131                                  ; Procedure Name : GetLastArena		-  M003
 39132                                  ;
 39133                                  ; Inputs	 : cx = umb_head
 39134                                  ;
 39135                                  ;
 39136                                  ; Outputs	 : If UMBs are linked
 39137                                  ;			ES = umb_head
 39138                                  ;			DS = arena before umb_head
 39139                                  ;		   else
 39140                                  ;			DS = last arena
 39141                                  ;			ES = next arena. will be umb_head if NC.
 39142                                  ;
 39143                                  ;		   CY if error
 39144                                  ;
 39145                                  ; Uses		 : DS, ES, DI, BX
 39146                                  ;--------------------------------------------------------------------------
 39147                                  
 39148                                  ; 14/05/2019 - Retro DOS v4.0
 39149                                  ; DOSCODE:A4D6h (MSDOS 6.21, MSDOS.SYS)
 39150                                  
 39151                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39152                                  ; DOSCODE:A476h (MSDOS 5.0, MSDOS.SYS)
 39153                                  	
 39154                                  GetLastArena:
 39155 00006EB1 50                      	push	ax			; save ax
 39156                                  
 39157 00006EB2 36A1[2400]              	mov	ax,[ss:arena_head]
 39158 00006EB6 8EC0                    	mov	es,ax			; es = arena_head
 39159 00006EB8 31FF                    	xor	di,di
 39160                                  
 39161 00006EBA 26803D5A                	cmp     byte [es:di],arena_signature_end
 39162                                  					; Q: is this the last arena
 39163 00006EBE 7419                    	je	short GLA_done		; Y: return last arena in ES		
 39164                                  					
 39165                                  GLA_next:
 39166 00006EC0 8ED8                    	mov	ds,ax
 39167 00006EC2 E879FD                  	call	arena_next		; ax, es -> next arena
 39168                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39169                                  	;jc	short GLA_err
 39170                                  	; 17/12/2022
 39171 00006EC5 7228                    	jc	short GLA_err2
 39172                                  
 39173 00006EC7 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are UMBs linked
 39174 00006ECD 7506                    	jnz	short GLA_chkumb	; Y: terminating condition is 
 39175                                  					;    umb_head
 39176                                  					; N: terminating condition is 05Ah
 39177                                  
 39178 00006ECF 26803D5A                	cmp     byte [es:di],arena_signature_end
 39179                                  					; Q: is this the last arena
 39180 00006ED3 EB02                    	jmp	short GLA_@f
 39181                                  GLA_chkumb:
 39182 00006ED5 39C8                    	cmp	ax,cx			; Q: is this umb_head
 39183                                  GLA_@f:
 39184 00006ED7 75E7                    	jne	short GLA_next		; N: get next arena
 39185                                  
 39186                                  GLA_done:
 39187                                  					; M061 - Start
 39188 00006ED9 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are UMBs linked
 39189 00006EDF 750B                    	jnz	short GLA_ret		; Y: we're done
 39190                                  					; N: let us confirm that the next 
 39191                                  					;    arena is umb_head
 39192 00006EE1 8ED8                    	mov	ds,ax
 39193 00006EE3 E858FD                  	call	arena_next		; ax, es -> next arena
 39194                                  	;jc	short GLA_err
 39195 00006EE6 7207                    	jc	short GLA_err2
 39196 00006EE8 39C8                    	cmp	ax,cx			; Q: is this umb_head
 39197 00006EEA 7502                    	jne	short GLA_err		; N: error
 39198                                  					; M061 - End
 39199                                  GLA_ret:
 39200                                  	; 17/12/2022				
 39201                                  	;clc
 39202                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39203                                  	;clc
 39204 00006EEC 58                      	pop	ax			; M061
 39205 00006EED C3                      	retn				; M061
 39206                                  
 39207                                  GLA_err:
 39208 00006EEE F9                      	stc				; M061
 39209                                  GLA_err2:
 39210 00006EEF 58                      	pop	ax
 39211 00006EF0 C3                      	retn
 39212                                  
 39213                                  ;============================================================================
 39214                                  ; SRVCALL.ASM, MSDOS 6.0, 1991
 39215                                  ;============================================================================
 39216                                  ; 04/08/2018 - Retro DOS v3.0
 39217                                  
 39218                                  ;	TITLE SRVCALL - Server DOS call
 39219                                  ;	NAME  SRVCALL
 39220                                  
 39221                                  ;**	SRVCALL.ASM - Server DOS call functions
 39222                                  ;
 39223                                  ;
 39224                                  ;	$ServerCall
 39225                                  ;
 39226                                  ;	Modification history:
 39227                                  ;
 39228                                  ;	    Created: ARR 08 August 1983
 39229                                  
 39230                                  ;AsmVars <Installed>
 39231                                  
 39232                                  ;include dpl.asm
 39233                                  
 39234                                  ;Installed = TRUE
 39235                                  
 39236                                  ; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 39237                                  ; ---------------------------------------------------------------------------
 39238                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39239                                  
 39240                                  ;BREAK <ServerCall -- Server DOS call>
 39241                                  
 39242                                  ; DOSCODE:A517h (MSDOS 6.21, MSDOS.SYS)
 39243                                  ; DOSCODE:A4B7h (MSDOS 5.0, MSDOS.SYS)
 39244                                  
 39245                                  ;hkn; TABLE	SEGMENT
 39246                                  ;Public SRVC001S,SRVC001E
 39247                                  ;SRVC001S label byte
 39248                                  
 39249                                  SRVC001S:
 39250                                  
 39251 00006EF1 [F56E]                  SERVERTAB:	dw	SERVER_DISP
 39252 00006EF3 [476F]                  SERVERLEAVE:	dw	SERVERRETURN
 39253 00006EF5 0B                      SERVER_DISP:	db	(SERVER_DISP_END-SERVER_DISP-1)/2 ; = 11
 39254 00006EF6 [AF6F]                  		dw	SRV_CALL	; 0
 39255 00006EF8 [486F]                  		dw	COMMIT_ALL	; 1
 39256 00006EFA [7E6F]                  		dw	CLOSE_NAME	; 2
 39257 00006EFC [896F]                  		dw	CLOSE_UID	; 3
 39258 00006EFE [906F]                  		dw	CLOSE_UID_PID	; 4
 39259 00006F00 [976F]                  		dw	GET_LIST	; 5
 39260 00006F02 [F06F]                  		dw	GET_DOS_DATA	; 6
 39261 00006F04 [1470]                  		dw	SPOOL_OPER	; 7
 39262 00006F06 [1470]                  		dw	SPOOL_OPER	; 8
 39263 00006F08 [1470]                  		dw	SPOOL_OPER	; 9
 39264 00006F0A [2070]                  		dw	_$SetExtendedError  ; 10
 39265                                  
 39266                                  SERVER_DISP_END:  ;  LABEL BYTE
 39267                                  
 39268                                  ;SRVC001E label byte
 39269                                  
 39270                                  SRVC001E:
 39271                                  
 39272                                  ;hkn; TABLE	ENDS
 39273                                  
 39274                                  ;----------------------------------------------------------------------------
 39275                                  ;
 39276                                  ; Procedure Name : $ServerCall
 39277                                  ;
 39278                                  ; Inputs:
 39279                                  ;	DS:DX -> DPL  (except calls 7,8,9)
 39280                                  ; Function:
 39281                                  ;	AL=0	Server DOS call
 39282                                  ;	AL=1	Commit All files
 39283                                  ;	AL=2	Close file by name (SHARING LOADED ONLY) DS:DX in DPL -> name
 39284                                  ;	AL=3	Close all files for DPL_UID
 39285                                  ;	AL=4	Close all files for DPL_UID/PID_PID
 39286                                  ;	AL=5	Get open file list entry
 39287                                  ;		    IN: BX File Index
 39288                                  ;			CX User Index
 39289                                  ;		    OUT:ES:DI -> Name
 39290                                  ;			BX = UID
 39291                                  ;		    CX = # locked blocks held by this UID
 39292                                  ;	AL=6	Get DOS data area
 39293                                  ;		    OUT: DS:SI -> Start
 39294                                  ;			CX size in bytes of swap if indos
 39295                                  ;			DX size in bytes of swap always
 39296                                  ;	AL=7	Get truncate flag
 39297                                  ;	AL=8	Set truncate flag
 39298                                  ;	AL=9	Close all spool files
 39299                                  ;	AL=10	SetExtendedError
 39300                                  ;
 39301                                  ;----------------------------------------------------------------------------
 39302                                  
 39303                                  _$ServerCall:
 39304                                  	; 13/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39305                                  	; DOSCODE:A4D2h (MSDOS 5.0 MSDOS.SYS)		
 39306                                  	; 10/06/2019
 39307                                  	; 29/04/2019 - Retro DOS v4.0
 39308                                  	; DOSCODE:A532h (MSDOS 6.21 MSDOS.SYS)
 39309                                  
 39310                                  	; 05/08/2018 - Retro DOS v3.0
 39311                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 657Bh
 39312 00006F0C 3C07                    	CMP	AL,7
 39313 00006F0E 7204                    	JB	short SET_STUFF
 39314 00006F10 3C09                    	CMP	AL,9
 39315 00006F12 761A                    	JBE	short NO_SET_ID		; No DPL on calls 7,8,9
 39316                                  SET_STUFF:
 39317 00006F14 89D6                    	MOV	SI,DX			; Point to DPL with DS:SI
 39318                                  	;mov	bx,[si+12h]
 39319 00006F16 8B5C12                  	MOV	BX,[SI+DPL.UID]
 39320                                  
 39321                                  	; MSDOS 6.0
 39322                                  ;SR;
 39323                                  ; WIN386 updates the USER_ID itself. If WIN386 is present we skip the updating
 39324                                  ; of USER_ID
 39325                                  
 39326 00006F19 36F606[A110]01          	test	byte [SS:IsWin386],1
 39327 00006F1F 7505                    	jnz	short skip_win386
 39328                                  
 39329                                  ;hkn; SS override for user_id and proc_id
 39330                                  	; 15/08/2018
 39331 00006F21 36891E[3E03]            	MOV	[SS:USER_ID],BX		; Set UID
 39332                                  
 39333                                  skip_win386:
 39334 00006F26 8B5C14                  	MOV	BX,[SI+DPL.PID]
 39335 00006F29 36891E[3C03]            	MOV	[SS:PROC_ID],BX		; Set process ID
 39336                                  NO_SET_ID:
 39337                                  	; 10/06/2019 - Retro DOS v4.0
 39338 00006F2E 2EFF36[F36E]            	PUSH	word [cs:SERVERLEAVE]	; push return address
 39339 00006F33 2EFF36[F16E]            	PUSH	word [cS:SERVERTAB]	; push table address
 39340 00006F38 50                      	PUSH	AX
 39341 00006F39 E8DAA8                  	call	TableDispatch
 39342                                  
 39343                                  ;hkn; SS override
 39344                                  	;mov 	byte [SS:EXETERR_LOCUS],1
 39345 00006F3C 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 39346                                  	;error	error_invalid_function
 39347                                  	;mov	al,1
 39348 00006F42 B001                    	MOV	AL,error_invalid_function
 39349                                  servercall_error:
 39350 00006F44 E93397                  	JMP	SYS_RET_ERR
 39351                                  
 39352                                  SERVERRETURN:
 39353 00006F47 C3                      	retn
 39354                                  
 39355                                  ; Commit - iterate through the open file list and make sure that the
 39356                                  ; directory entries are correctly updated.
 39357                                  
 39358                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39359                                  COMMIT_ALL:
 39360 00006F48 31DB                    	XOR	BX,BX			;   for (i=0; ThisSFT=getSFT(i); i++)
 39361 00006F4A 16                      	push	ss
 39362 00006F4B 1F                      	pop	ds
 39363 00006F4C E8B4A9                  	call	ECritSFT		; Gonna scan SFT cache, lock it down
 39364                                  CommitLoop:
 39365 00006F4F 53                      	push	bx
 39366 00006F50 E82401                  	call	SFFromSFN
 39367 00006F53 7222                    	JC	short CommitDone
 39368 00006F55 26833D00                	cmp	word [es:di],0
 39369                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],0
 39370                                  					; if (ThisSFT->refcount != 0)
 39371 00006F59 7418                    	JZ	short CommitNext
 39372                                  	;cmp	word [es:di],0FFFFh ; -1
 39373 00006F5B 26833DFF                	cmp	word [ES:DI],sf_busy
 39374                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],sf_busy  
 39375                                  					; BUSY SFTs have god knows what
 39376 00006F5F 7412                    	JZ	short CommitNext	;   in them.
 39377                                  	; 17/12/2022
 39378 00006F61 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8) ; 80h
 39379                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet ; 8000h
 39380 00006F66 750B                    	JNZ	short CommitNext	;  Skip Network SFTs so the SERVER
 39381                                  					;	doesn't deadlock
 39382 00006F68 893E[9E05]              	MOV	[THISSFT],DI
 39383 00006F6C 8C06[A005]              	MOV	[THISSFT+2],ES
 39384 00006F70 E885C9                  	call	DOS_COMMIT		;	DOSCommit ();
 39385                                  CommitNext:
 39386 00006F73 5B                      	pop	bx
 39387 00006F74 43                      	INC	BX
 39388 00006F75 EBD8                    	JMP	short CommitLoop
 39389                                  CommitDone:
 39390 00006F77 E8B6A9                  	call	LCritSFT
 39391 00006F7A 5B                      	pop	bx
 39392                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39393                                  Commit_Ok:
 39394 00006F7B E9F296                  	jmp	SYS_RET_OK
 39395                                  	
 39396                                  
 39397                                  CLOSE_NAME:
 39398                                  
 39399                                  ;if installed
 39400                                  
 39401                                  ;hkn; SS override
 39402                                  	;call	far [ss:MFTcloN]
 39403 00006F7E 36FF1E[A400]            	Call	far [SS:JShare+(5*4)] ; 5 = MFTcloN
 39404                                  ;else
 39405                                  ;	Call	MFTcloN
 39406                                  ;endif
 39407                                  
 39408                                  CheckReturns:
 39409 00006F83 7202                    	JC	short func_err
 39410                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39411                                  	;transfer SYS_RET_OK
 39412                                  Commit_Okj:
 39413 00006F85 EBF4                    	jmp	short Commit_Ok
 39414                                  	;jmp	SYS_RET_OK
 39415                                  
 39416                                  func_err:
 39417                                  	;transfer SYS_RET_ERR
 39418                                  	;jmp	SYS_RET_ERR
 39419 00006F87 EBBB                    	jmp	short servercall_error
 39420                                  
 39421                                  CLOSE_UID:
 39422                                  
 39423                                  ;if installed
 39424                                  ;hkn; SS override
 39425                                  	;call	far [ss:MFTclU]
 39426 00006F89 36FF1E[9C00]            	Call	far [SS:JShare+(3*4)] ; 3 = MTFTclu
 39427                                  ;else
 39428                                  ;	Call	MFTclU
 39429                                  ;endif
 39430 00006F8E EBF3                    	JMP	short CheckReturns
 39431                                  
 39432                                  CLOSE_UID_PID:
 39433                                  
 39434                                  ;if installed
 39435                                  ;hkn; SS override
 39436                                  	;call	far [ss:MFTCloseP]
 39437 00006F90 36FF1E[A000]            	Call	far [SS:JShare+(4*4)] ; 4 = MFTCloseP 
 39438                                  ;else
 39439                                  ;	Call	MFTCloseP
 39440                                  ;endif
 39441 00006F95 EBEC                    	JMP	short CheckReturns
 39442                                  
 39443                                  GET_LIST:
 39444                                  
 39445                                  ;if installed
 39446                                  ;hkn; SS override
 39447                                  	;call	far [ss:MFT_get]
 39448 00006F97 36FF1E[B400]            	Call	far [SS:JShare+(9*4)] ; 9 = MFT_get
 39449                                  ;else
 39450                                  ;	Call	MFT_get
 39451                                  ;endif
 39452 00006F9C 72E9                    	JC	short func_err
 39453 00006F9E E8D694                  	call	Get_User_Stack
 39454                                  	;mov	[si+2],bx
 39455 00006FA1 895C02                  	MOV	[SI+user_env.user_BX],BX
 39456                                  	;mov	[si+10],di
 39457 00006FA4 897C0A                  	MOV	[SI+user_env.user_DI],DI
 39458                                  	;mov	[si+16],es
 39459 00006FA7 8C4410                  	MOV	[SI+user_env.user_ES],ES
 39460                                  SetCXOK:
 39461                                  	;mov	[si+4],cx
 39462 00006FAA 894C04                  	MOV	[SI+user_env.user_CX],CX
 39463                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39464                                  	;transfer SYS_RET_OK
 39465                                  Commit_Okj2:
 39466                                  	; 17/12/2022
 39467 00006FAD EBCC                    	jmp	short Commit_Ok
 39468                                  	;jmp	short Commit_Okj
 39469                                  	;;jmp	SYS_RET_OK
 39470                                  
 39471                                  SRV_CALL:
 39472 00006FAF 58                      	POP	AX			; get rid of call to $srvcall
 39473 00006FB0 1E                      	push	ds
 39474 00006FB1 56                      	push	si
 39475 00006FB2 E8C294                  	call	Get_User_Stack
 39476 00006FB5 5F                      	pop	di
 39477 00006FB6 07                      	pop	es
 39478                                  
 39479                                  ; DS:SI point to stack
 39480                                  ; ES:DI point to DPL
 39481                                  
 39482 00006FB7 E83BA8                  	call	XCHGP
 39483                                  
 39484                                  ; DS:SI point to DPL
 39485                                  ; ES:DI point to stack
 39486                                  ;
 39487                                  ; We now copy the registers from DPL to save stack
 39488                                  
 39489 00006FBA 56                      	push	si
 39490 00006FBB B90600                  	MOV	CX,6
 39491 00006FBE F3A5                    	REP	MOVSW			; Put in AX,BX,CX,DX,SI,DI
 39492 00006FC0 47                      	INC	DI
 39493 00006FC1 47                      	INC	DI			; Skip user_BP
 39494 00006FC2 A5                      	MOVSW				; DS
 39495 00006FC3 A5                      	MOVSW				; ES
 39496 00006FC4 5E                      	pop	si			; DS:SI -> DPL
 39497 00006FC5 8B04                    	mov	ax,[SI]
 39498                                  	;MOV	AX,[SI+DPL.AX]
 39499                                  	;mov	bx,[si+2]
 39500 00006FC7 8B5C02                  	MOV	BX,[SI+DPL.BX]
 39501                                  	;mov	cx,[si+4]
 39502 00006FCA 8B4C04                  	MOV	CX,[SI+DPL.CX]
 39503                                  	;mov	dx,[si+6]
 39504 00006FCD 8B5406                  	MOV	DX,[SI+DPL.DX]
 39505                                  	;mov	di,[si+10]
 39506 00006FD0 8B7C0A                  	MOV	DI,[SI+DPL.DI]
 39507                                  	;mov	es,[si+14]
 39508 00006FD3 8E440E                  	MOV	ES,[SI+DPL.ES]
 39509                                  	;push	word [si+8]
 39510 00006FD6 FF7408                  	PUSH	word [SI+DPL.SI]
 39511                                  	;mov	ds,[si+12]
 39512 00006FD9 8E5C0C                  	MOV	DS,[SI+DPL.DS]
 39513 00006FDC 5E                      	POP	SI
 39514                                  
 39515                                  ;hkn; SS override for next 3
 39516 00006FDD 368C1E[EC05]            	MOV	[SS:SAVEDS],DS
 39517 00006FE2 36891E[EA05]            	MOV	[SS:SAVEBX],BX
 39518 00006FE7 36C606[7205]FF          	MOV	byte [SS:FSHARING],-1	; set no redirect flag
 39519 00006FED E98593                  	jmp	REDISP
 39520                                  
 39521                                  GET_DOS_DATA:
 39522 00006FF0 16                      	push	ss
 39523 00006FF1 07                      	pop	es
 39524 00006FF2 BF[2003]                	MOV     DI,SWAP_START
 39525 00006FF5 B9[AC0A]                	MOV     CX,SWAP_END
 39526 00006FF8 BA[3A03]                	MOV     DX,SWAP_ALWAYS
 39527 00006FFB 29F9                    	SUB     CX,DI
 39528 00006FFD 29FA                    	SUB     DX,DI
 39529 00006FFF D1E9                    	SHR     CX,1                    ; div by 2, remainder in carry
 39530 00007001 83D100                  	ADC     CX,0                    ; div by 2 + round up
 39531 00007004 D1E1                    	SHL     CX,1                    ; round up to 2 boundary.
 39532 00007006 E86E94                  	call	Get_User_Stack
 39533                                  	;mov	[si+14],es
 39534 00007009 8C440E                  	MOV     [SI+user_env.user_DS],ES
 39535                                  	;mov	[si+8],di
 39536 0000700C 897C08                  	MOV     [SI+user_env.user_SI],DI
 39537                                  	;mov	[si+6],dx
 39538 0000700F 895406                  	MOV     [SI+user_env.user_DX],DX
 39539 00007012 EB96                    	JMP	short SetCXOK
 39540                                  
 39541                                  SPOOL_OPER:
 39542                                  	;CallInstall NETSpoolOper,MultNET,37,AX,BX
 39543                                  
 39544 00007014 50                      	push    ax
 39545 00007015 B82511                  	mov     ax,1125h
 39546 00007018 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
 39547                                  			; STACK: WORD subfunction
 39548                                  			; Return: CF set on error, AX = error code
 39549                                  			; STACK unchanged
 39550 0000701A 5B                      	pop	bx
 39551                                  	; 17/12/2022
 39552                                  	;JC	short func_err2
 39553 0000701B 7390                    	jnc	short Commit_Okj2
 39554                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39555                                  	;;jmp	SYS_RET_OK
 39556                                  	;jmp	short Commit_Okj2
 39557                                  	
 39558                                  func_err2:
 39559 0000701D E95A96                  	jmp	SYS_RET_ERR
 39560                                  
 39561                                  ;Break	<$SetExtendedError - set extended error for later retrieval>
 39562                                  ;--------------------------------------------------------------------------
 39563                                  ;
 39564                                  ; Procedure Name : $SetExtendedError
 39565                                  ;
 39566                                  ; $SetExtendedError takes extended error information and loads it up for the
 39567                                  ; next extended error call. This is used by interrupt-level proccessors to
 39568                                  ; mask their actions.
 39569                                  ;
 39570                                  ;   Inputs: DS:SI points to DPL which contains all registers
 39571                                  ;   Outputs: none
 39572                                  ;
 39573                                  ;---------------------------------------------------------------------------
 39574                                  
 39575                                  _$SetExtendedError:
 39576                                  
 39577                                  ;hkn; SS override for all variables used
 39578                                  
 39579 00007020 8B04                    	mov	ax,[si]
 39580                                  	;MOV	AX,[SI+DPL.AX]
 39581 00007022 36A3[2403]              	MOV	[SS:EXTERR],AX
 39582                                  	;mov	ax,[si+10]
 39583 00007026 8B440A                  	MOV	AX,[SI+DPL.DI]
 39584 00007029 36A3[2803]              	MOV	[SS:EXTERRPT],AX
 39585                                  	;mov	ax,[si+14]
 39586 0000702D 8B440E                  	MOV	AX,[SI+DPL.ES]
 39587 00007030 36A3[2A03]              	MOV	[SS:EXTERRPT+2],AX
 39588                                  	;mov	ax,[si+2]
 39589 00007034 8B4402                  	MOV	AX,[SI+DPL.BX]
 39590 00007037 36A3[2603]              	MOV	[SS:EXTERR_ACTION],AX
 39591                                  	;mov	ax,[si+4]
 39592 0000703B 8B4404                  	MOV	AX,[SI+DPL.CX]
 39593 0000703E 368826[2303]            	MOV	[SS:EXTERR_LOCUS],AH
 39594 00007043 C3                      	retn
 39595                                  
 39596                                  ;============================================================================
 39597                                  ; UTIL.ASM, MSDOS 6.0, 1991
 39598                                  ;============================================================================
 39599                                  ; 05/08/2018 - Retro DOS v3.0
 39600                                  ; 05/05/2019 - Retro DOS v4.0
 39601                                  
 39602                                  ;**	Handle related utilities for MSDOS 2.X.
 39603                                  ;----------------------------------------------------------------------------
 39604                                  ;	pJFNFromHandle	written
 39605                                  ;	SFFromHandle	written
 39606                                  ;	SFFromSFN	written
 39607                                  ;	JFNFree 	written
 39608                                  ;	SFNFree 	written
 39609                                  ;
 39610                                  ;	Modification history:
 39611                                  ;
 39612                                  ;	    Created: MZ 1 April 1983
 39613                                  ;----------------------------------------------------------------------------
 39614                                  
 39615                                  ;	BREAK	<pJFNFromHandle - return pointer to JFN table entry>
 39616                                  
 39617                                  ;**	pJFNFromHandle - Translate Handle to Pointer to JFN
 39618                                  ;----------------------------------------------------------------------------
 39619                                  ;	pJFNFromHandle takes a file handle and turns that into a pointer to
 39620                                  ;	the JFN entry (i.e., to a byte holding the internal file handle #)
 39621                                  ;
 39622                                  ;	NOTE:
 39623                                  ;	  This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 39624                                  ;	  at DOSINIT time with SS NOT DOSGROUP
 39625                                  ;
 39626                                  ;	ENTRY	(bx) = handle
 39627                                  ;	EXIT	'C' clear if ok
 39628                                  ;		  (es:di) = address of JFN value
 39629                                  ;		'C' set if error
 39630                                  ;		  (ax) = error code
 39631                                  ;	USES	AX, DI, ES, Flags
 39632                                  ;----------------------------------------------------------------------------
 39633                                  
 39634                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39635                                  
 39636                                  pJFNFromHandle:
 39637                                  	; 05/05/2019 - Retro DOS v4.0
 39638                                  	;getdseg <es>			; es -> dosdata
 39639 00007044 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 39640                                  	
 39641                                  	;MOV	ES,[cs:CurrentPDB]	; get user process data block
 39642 00007049 268E06[3003]            	mov	es,[es:CurrentPDB]
 39643                                  
 39644                                  	;cmp	bx,[ES:32h]
 39645 0000704E 263B1E3200              	CMP	BX,[ES:PDB.JFN_Length]	; is handle greater than allocated
 39646 00007053 7204                    	JB	short pjfn10		; no, get offset
 39647                                  ReturnCarry_inv_hndl: ; 05/08/2018 - Retro DOS v3.0
 39648                                  	;mov	al,6
 39649 00007055 B006                    	MOV     AL,error_invalid_handle ; appropriate error
 39650                                  ReturnCarry:
 39651 00007057 F9                      	STC                             ; signal error
 39652 00007058 C3                      	retn				; go back
 39653                                  pjfn10: 
 39654                                  	;les	di,[es:34h]
 39655 00007059 26C43E3400              	LES	DI,[ES:PDB.JFN_Pointer]	; get pointer to beginning of table
 39656 0000705E 01DF                    	ADD	DI,BX			; add in offset, clear 'C'
 39657                                  	;clc
 39658                                  pJFNFromHandle_error:
 39659 00007060 C3                      	retn
 39660                                  
 39661                                  ;BREAK <SFFromHandle - return pointer (or error) to SF entry from handle>
 39662                                  ;----------------------------------------------------------------------------
 39663                                  ;
 39664                                  ; Procedure Name : SFFromHandle
 39665                                  ;
 39666                                  ; SFFromHandle - Given a handle, get JFN and then index into SF table
 39667                                  ;
 39668                                  ;   Input:      BX has handle
 39669                                  ;   Output:     Carry Set
 39670                                  ;                   AX has error code
 39671                                  ;               Carry Reset
 39672                                  ;                   ES:DI has pointer to SF entry
 39673                                  ;   Registers modified: If error, AX,ES, else ES:DI
 39674                                  ; NOTE:
 39675                                  ;   This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 39676                                  ;       at DOSINIT time with SS NOT DOSGROUP
 39677                                  ;
 39678                                  ;----------------------------------------------------------------------------
 39679                                  
 39680                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39681                                  
 39682                                  SFFromHandle:
 39683 00007061 E8E0FF                  	CALL	pJFNFromHandle		; get jfn pointer
 39684                                  	;retc				; return if error
 39685 00007064 72FA                    	jc	short pJFNFromHandle_error
 39686 00007066 26803DFF                	CMP     BYTE [ES:DI],-1		; unused handle
 39687                                  	;JNZ	short GetSF		; nope, suck out SF
 39688                                  	;;mov	al,6
 39689                                  	;MOV	AL,error_invalid_handle ; appropriate error
 39690                                  	;jmp	short ReturnCarry	; signal it
 39691                                  	; 17/12/2022
 39692                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39693 0000706A 74E9                    	jz	short ReturnCarry_inv_hndl ; Retro DOS v3.0 modification
 39694                                  	;JNZ	short GetSF		; nope, suck out SF
 39695                                  	;;mov	al,6
 39696                                  	;MOV	AL,error_invalid_handle ; appropriate error
 39697                                  	;jmp	short ReturnCarry	; signal it
 39698                                  GetSF:
 39699 0000706C 53                      	push	bx			; save handle
 39700 0000706D 268A1D                  	MOV     BL,[ES:DI]		; get SFN
 39701 00007070 30FF                    	XOR     BH,BH                   ; ignore upper half
 39702 00007072 E80200                  	CALL    SFFromSFN               ; get real sf spot
 39703 00007075 5B                      	pop	bx			; restore
 39704 00007076 C3                      	retn                        	; say goodbye
 39705                                  
 39706                                  ;BREAK <SFFromSFN - index into SF table for SFN>
 39707                                  
 39708                                  ;**	SFFromSFN - Get an SF Table entry from an SFN
 39709                                  ;----------------------------------------------------------------------------
 39710                                  ;	SFFromSfn uses an SFN to index an entry into the SF table. This
 39711                                  ;	is more than just a simple index instruction because the SF table
 39712                                  ;	can be made up of multiple pieces chained together. We follow the
 39713                                  ;	chain to the right piece and then do the index operation.
 39714                                  ;
 39715                                  ;   NOTE:
 39716                                  ;	This routine is called from SFFromHandle which is called
 39717                                  ;       at DOSINIT time with SS NOT DOSGROUP
 39718                                  ;
 39719                                  ;	ENTRY	BX has SF index
 39720                                  ;	EXIT	'C' clear if OK
 39721                                  ;		  ES:DI points to SF entry
 39722                                  ;		'C' set if index too large
 39723                                  ;	USES	BX, DI, ES
 39724                                  ;----------------------------------------------------------------------------
 39725                                  
 39726                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39727                                  
 39728                                  SFFromSFN:
 39729                                  	; 05/05/2019 - Retro DOS v4.0
 39730                                  	;getdseg <es>			; es -> dosdata
 39731 00007077 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 39732                                  
 39733                                  	;LES	DI,[CS:SFT_ADDR]	; (es:di) = start of SFT table
 39734 0000707C 26C43E[2A00]            	les	di,[es:SFT_ADDR]
 39735                                  sfsfn5:	
 39736                                  	;cmp	bx,[es:di+4]
 39737 00007081 263B5D04                	CMP	BX,[ES:DI+SFT.SFCount]	; is handle in this table?
 39738 00007085 720E                    	JB	short sfsfn7		; yes, go grab it
 39739                                  	;sub	bx,[es:di+4]
 39740 00007087 262B5D04                	SUB     BX,[ES:DI+SFT.SFCount]
 39741 0000708B 26C43D                  	les	di,[es:di] ; 14/08/2018
 39742                                  	;LES	DI,[ES:DI+SFT.SFLink]	; get next table segment
 39743 0000708E 83FFFF                  	CMP     DI,-1                   ; end of tables?
 39744 00007091 75EE                    	JNZ	short sfsfn5		; no, try again
 39745 00007093 F9                      	STC
 39746 00007094 C3                      	retn				; return with error, not found
 39747                                  sfsfn7:
 39748 00007095 50                      	push	ax
 39749                                  	;mov	ax,53 ; MSDOS 3.3
 39750                                  	;mov	ax,59 ; MSDOS 6.0
 39751                                  	;MOV	AX,SF_ENTRY.size	; put it in a nice place
 39752                                  	
 39753                                  	; 17/12/2022
 39754 00007096 B03B                    	mov	al,SF_ENTRY.size ; 28/05/2019
 39755                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39756                                  	;mov	ax,SF_ENTRY.size ; 59
 39757                                  	
 39758 00007098 F6E3                    	MUL	BL			; (ax) = offset into this SF block
 39759 0000709A 01C7                    	ADD	DI,AX			; add base of SF block
 39760 0000709C 58                      	pop	ax
 39761                                  	;add	di,6
 39762 0000709D 83C706                  	ADD	DI,SFT.SFTable		; offset into structure, 'C' cleared
 39763 000070A0 C3                      	retn				; return with 'C' clear
 39764                                  
 39765                                  ;	BREAK <JFNFree - return a jfn pointer if one is free>
 39766                                  
 39767                                  ;**	JFNFree - Find a Free JFN Slot
 39768                                  ;----------------------------------------------------------------------------
 39769                                  ;	JFNFree scansthrough the JFN table and returnsa pointer to a free slot
 39770                                  ;
 39771                                  ;	ENTRY	(ss) = DOSDATA
 39772                                  ;	EXIT	'C' clear if OK
 39773                                  ;		  (bx) = new handle
 39774                                  ;		  (es:di) = pointer to JFN slot
 39775                                  ;		'C' set if error
 39776                                  ;		  (al) = error code
 39777                                  ;	USES	bx, di, es, flags
 39778                                  ;----------------------------------------------------------------------------
 39779                                  
 39780                                  JFNFree:
 39781 000070A1 31DB                    	XOR	BX,BX			; (bx) = initial JFN to try
 39782                                  jfnf1:	
 39783 000070A3 E89EFF                  	CALL	pJFNFromHandle		; get the appropriate handle
 39784 000070A6 7209                    	JC	short jfnf5		; no more handles
 39785 000070A8 26803DFF                	CMP     BYTE [ES:DI],-1		; free?
 39786 000070AC 7405                    	je	short jfnfx		; yes, carry is clear
 39787 000070AE 43                      	INC     BX                      ; no, next handle
 39788 000070AF EBF2                    	JMP	short jfnf1		; and try again
 39789                                  
 39790                                  	; Error. 'C' set
 39791                                  jfnf5:	
 39792                                  	;mov	al,4
 39793 000070B1 B004                    	MOV	AL,error_too_many_open_files
 39794                                  jfnfx:	
 39795 000070B3 C3                      	retn				; bye
 39796                                  
 39797                                  ;	BREAK <SFNFree - Allocate a free SFN>
 39798                                  
 39799                                  ;**	SFNFree - Allocate a Free SFN/SFT
 39800                                  ;----------------------------------------------------------------------------
 39801                                  ;	SFNFree scans through the sf table looking for a free entry
 39802                                  ;	If it finds one it partially allocates it by setting SFT_REF_COUNT = -1
 39803                                  ;
 39804                                  ;	The problem is that we want to mark the SFT busy so that other threads
 39805                                  ;	can't allocate the SFT before we're finished marking it up.  However,
 39806                                  ;	we can't just mark it busy because we may get blown out of our open
 39807                                  ;	by INT24 and leave the thing orphaned.	To solve this we mark it
 39808                                  ;	"allocation in progress" by setting SFT_REF_COUNT = -1.  If we see
 39809                                  ;	an SFT with this value we look to see if it belongs to this user
 39810                                  ;	and process.  If it does belong to us then it must be an orphan
 39811                                  ;	and we reclaim it.
 39812                                  ;
 39813                                  ;	BUGBUG - improve the performance. I guess it's smaller to call SFFromSFN
 39814                                  ;		over and over, but we could at least set a high water mark...
 39815                                  ;		cause an N^2 loop calling slow SFFromSFN is real slow, too slow
 39816                                  ;		even though this is not a frequently called routine - jgl
 39817                                  ;
 39818                                  ;	ENTRY	(ss) = DOSDATA
 39819                                  ;	EXIT	'C' clear if no error
 39820                                  ;		  (bx) = SFN
 39821                                  ;		  (es:di) = pointer to SFT
 39822                                  ;		  es:[di].SFT_REF_COUNT = -1
 39823                                  ;		'C' set if error
 39824                                  ;		  (al) = error code
 39825                                  ;	USES	bx, di, es, Flags
 39826                                  ;----------------------------------------------------------------------------
 39827                                  
 39828                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39829                                  	; DOSCODE:A682h (MSDOS 5.0 MSDOS.SYS)
 39830                                  
 39831                                  SFNFree:
 39832                                  	; 12/08/2018
 39833                                  	; 05/08/2018 - Retro DOS v3.0
 39834                                  	;
 39835                                  	; MSDOS 6.0
 39836 000070B4 50                      	push	ax
 39837 000070B5 31DB                    	xor	bx,bx			; (bx) = SFN to consider
 39838                                  sfnf5:	
 39839 000070B7 53                      	push	bx
 39840 000070B8 E8BCFF                  	call	SFFromSFN		; get the potential handle
 39841 000070BB 5B                      	pop	bx
 39842 000070BC 723A                    	jc	short sfnf95		; no more free SFNs
 39843 000070BE 26833D00                	cmp	word [ES:DI],0
 39844                                  	;cmp	word [ES:DI+SF_ENTRY.sf_Ref_Count],0 ; free?
 39845 000070C2 741D                    	je	short sfnf20			; yep, got one
 39846                                  	
 39847                                  	;cmp	word [es:di],0FFFFh ; -1
 39848 000070C4 26833DFF                	cmp	word [ES:DI],sf_busy
 39849                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 39850 000070C8 7403                    	je	short sfnf10		; special busy mark
 39851                                  sfnf7:	
 39852 000070CA 43                      	inc	bx			; try the next one
 39853 000070CB EBEA                    	jmp	short sfnf5
 39854                                  
 39855                                  ;	The SFT has the special "busy" mark; if it belongs to us then
 39856                                  ;	it was abandoned during a earlier call and we can use it.
 39857                                  ;
 39858                                  ;	(bx)	= SFN
 39859                                  ;	(es:di) = pointer to SFT
 39860                                  ;	(TOS)	= caller's (ax)
 39861                                  
 39862                                  sfnf10:	
 39863 000070CD 36A1[3E03]              	mov	ax,[SS:USER_ID]
 39864                                  	;cmp	[es:di+2Fh],ax
 39865 000070D1 2639452F                	cmp	[ES:DI+SF_ENTRY.sf_UID],ax
 39866 000070D5 75F3                    	jnz	short sfnf7		; not ours
 39867 000070D7 36A1[3C03]              	mov	ax,[SS:PROC_ID]
 39868                                  	;cmp	[es:di+31h],ax
 39869 000070DB 26394531                	cmp	[ES:DI+SF_ENTRY.sf_PID],ax
 39870 000070DF 75E9                    	jnz	short sfnf7		; can't use this one, try the next
 39871                                  
 39872                                  ;	We have an SFT to allocate
 39873                                  ;
 39874                                  ;	(bx)	= SFN
 39875                                  ;	(es:di) = pointer to SFT
 39876                                  ;	(TOS)	= caller's (ax)
 39877                                  
 39878                                  sfnf20:
 39879                                  	; cf = 0 ;; Retro DOS v3.0
 39880                                  
 39881                                  	;mov	word [es:di],0FFFFh
 39882 000070E1 26C705FFFF              	mov	word [ES:DI],sf_busy
 39883                                  					; make sure that this is allocated
 39884                                  	;mov	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 39885                                  
 39886 000070E6 36A1[3E03]              	mov	ax,[SS:USER_ID]
 39887                                  	;mov	[es:di+2Fh],ax
 39888 000070EA 2689452F                	mov	[ES:DI+SF_ENTRY.sf_UID],ax
 39889 000070EE 36A1[3C03]              	mov	ax,[SS:PROC_ID]
 39890                                  	;mov	[es:di+31h],ax
 39891 000070F2 26894531                	mov	[ES:DI+SF_ENTRY.sf_PID],ax
 39892                                  sfnf21: ;; Retro DOS v3.0
 39893                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39894                                  	;pop	ax
 39895                                  	;;clc
 39896                                  	;retn				; return with no error
 39897                                  	; 17/12/2022
 39898 000070F6 58                      	pop	ax
 39899                                  	;clc
 39900 000070F7 C3                      	retn
 39901                                  
 39902                                  ;**	Error - no more free SFNs
 39903                                  ;
 39904                                  ;	'C' set
 39905                                  ;	(TOS) = saved ax
 39906                                  
 39907                                  sfnf95: 
 39908 000070F8 58                      	pop	ax
 39909                                  	;mov	al,4
 39910 000070F9 B004                    	mov	al,error_too_many_open_files
 39911 000070FB C3                      	retn				; return with 'C' and error
 39912                                  
 39913                                  ;============================================================================
 39914                                  ; HANDLE.ASM, MSDOS 6.0, 1991
 39915                                  ;============================================================================
 39916                                  ; 13/07/2018 - Retro DOS v3.0
 39917                                  ; 20/05/2019 - Retro DOS v4.0
 39918                                  
 39919                                  ; DOSCODE:A72Bh (MSDOS 6.21, MSDOS.SYS)
 39920                                  
 39921                                  ;	BREAK <$Close - return a handle to the system>
 39922                                  ;----------------------------------------------------------------------------
 39923                                  ;
 39924                                  ;**	$Close - Close a file Handle
 39925                                  ;
 39926                                  ;	BUGBUG - close gets called a LOT with invalid handles - sizzle that
 39927                                  ;		path
 39928                                  ;
 39929                                  ;	Assembler usage:
 39930                                  ;	    MOV     BX, handle
 39931                                  ;	    MOV     AH, Close
 39932                                  ;	    INT     int_command
 39933                                  ;
 39934                                  ;	ENTRY	(bx) = handle
 39935                                  ;	EXIT	<normal INT21 return convention>
 39936                                  ;	USES	all
 39937                                  ;
 39938                                  ;----------------------------------------------------------------------------
 39939                                  
 39940                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39941                                  ; DOSCODE:A6CBh (MSDOS 5.0 MSDOS.SYS)
 39942                                  
 39943                                  _$CLOSE:
 39944                                  ;	Grab the SFT pointer from the JFN.
 39945                                  
 39946 000070FC E85A02                  	call	CheckOwner		; get system file entry
 39947 000070FF 722B                    	jc	short CloseError	; error return
 39948 00007101 16                      	push	ss
 39949 00007102 1F                      	pop	ds			; For DOS_CLOSE
 39950 00007103 893E[9E05]              	MOV	[THISSFT],DI		; save offset of pointer
 39951 00007107 8C06[A005]              	MOV	[THISSFT+2],ES		; save segment value
 39952                                  
 39953                                  ; DS:SI point to JFN table entry.
 39954                                  ; ES:DI point to SFT
 39955                                  ;
 39956                                  ; We now examine the user's JFN entry; If the file was a 70-mode file (network
 39957                                  ; FCB, we examine the ref count on the SFT;  if it was 1, we free the JFN.
 39958                                  ; If the file was not a net FCB, we free the JFN too.
 39959                                  
 39960                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],1
 39961 0000710B 26833D01                	cmp	word [ES:DI],1		; will the SFT become free?
 39962 0000710F 740A                    	jz	short FreeJFN 		; yes, free JFN anyway.
 39963                                  	;mov	al,[ES:DI+2]
 39964 00007111 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 39965                                  	;and	al,0F0h
 39966 00007115 24F0                    	AND	AL,SHARING_MASK
 39967                                  	;cmp	al,70h
 39968 00007117 3C70                    	CMP	AL,SHARING_NET_FCB
 39969 00007119 7407                    	JZ	short PostFree		; 70-mode and big ref count => free it
 39970                                  
 39971                                  ; The JFN must be freed.  Get the pointer to it and replace the contents with
 39972                                  ; -1.
 39973                                  
 39974                                  FreeJFN:
 39975 0000711B E826FF                  	call	pJFNFromHandle		;   d = pJFN (handle);
 39976 0000711E 26C605FF                	MOV	BYTE [ES:DI],0FFh	; release the JFN
 39977                                  PostFree:
 39978                                  
 39979                                  ; ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_CLOSE!
 39980                                  
 39981 00007122 E820C6                  	call	DOS_CLOSE
 39982                                  
 39983                                  ; DOS_Close may return an error. If we see such an error, we report it but
 39984                                  ; the JFN stays closed because DOS_Close always frees the SFT!
 39985                                  
 39986 00007125 7205                    	JC	short CloseError
 39987                                  	;mov	ah,3Eh
 39988 00007127 B43E                    	MOV	AH,CLOSE		; MZ Bogus multiplan fix
 39989                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39990                                  CloseOk:
 39991 00007129 E94495                  	jmp	SYS_RET_OK
 39992                                  CloseError:
 39993 0000712C E94B95                  	jmp	SYS_RET_ERR
 39994                                  
 39995                                  ;	BREAK <$Commit - commit the file>
 39996                                  ;----------------------------------------------------------------------------
 39997                                  ;
 39998                                  ;**	$Commit - Commit a File
 39999                                  ;
 40000                                  ;	$Commit "commits" a file to disk - all of it's buffers are
 40001                                  ;	flushed out.  BUGBUG - I'm pretty sure that $Commit doesn't update
 40002                                  ;	the directory entry, etc., so this commit is pretty useless. check
 40003                                  ;	and fix this!! jgl
 40004                                  ;
 40005                                  ;	Assembler usage:
 40006                                  ;	    MOV     BX, handle
 40007                                  ;	    MOV     AH, Commit
 40008                                  ;	    INT     int_command
 40009                                  ;
 40010                                  ;	ENTRY	(bx) = handle
 40011                                  ;	EXIT	none
 40012                                  ;	USES	all
 40013                                  ;;----------------------------------------------------------------------------
 40014                                  
 40015                                  _$COMMIT:
 40016                                  ;	Grab the SFT pointer from the JFN.
 40017                                  
 40018 0000712F E82702                  	call	CheckOwner		; get system file entry
 40019 00007132 7213                    	JC	short CommitError	; error return
 40020 00007134 16                      	push	ss
 40021 00007135 1F                      	pop	ds			; For DOS_COMMIT
 40022 00007136 893E[9E05]              	MOV	[THISSFT],DI		; save offset of pointer
 40023 0000713A 8C06[A005]              	MOV	[THISSFT+2],ES		; save segment value
 40024                                  
 40025                                  ;	ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_COMMIT
 40026                                  ;
 40027                                  ;	ES:DI point to SFT
 40028                                  
 40029 0000713E E8B7C7                  	call	DOS_COMMIT
 40030 00007141 7204                    	JC	short CommitError
 40031                                  	; 07/12/2022
 40032                                  	;jc	short CloseError
 40033                                  	;mov	ah,68h
 40034 00007143 B468                    	MOV	AH,COMMIT
 40035                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40036                                  	;jmp	SYS_RET_OK
 40037                                  CommitOk:
 40038 00007145 EBE2                    	jmp	short CloseOk	
 40039                                  
 40040                                  CommitError:
 40041                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40042                                  	;jmp	SYS_RET_ERR
 40043 00007147 EBE3                    	jmp	short CloseError
 40044                                  
 40045                                  ;	BREAK <$ExtHandle - extend handle count>
 40046                                  
 40047                                  ;**	$ExtHandle - Extend Handle Count
 40048                                  ;----------------------------------------------------------------------------
 40049                                  ;	Assembler usage:
 40050                                  ;	    MOV     BX, Number of Opens Allowed (MAX=65534;66535 is
 40051                                  ;	    MOV     AX, 6700H			 reserved to mark SFT
 40052                                  ;	    INT     int_command 		 busy )
 40053                                  ;
 40054                                  ;	ENTRY	(bx) = new number of handles
 40055                                  ;	EXIT	'C' clear if OK
 40056                                  ;		'C' set iff err
 40057                                  ;		  (ax) = error code
 40058                                  ;			 AX = error_not_enough_memory
 40059                                  ;			      error_too_many_open_files
 40060                                  ;	USES	all
 40061                                  ;----------------------------------------------------------------------------
 40062                                  
 40063                                  _$ExtHandle:
 40064 00007149 31ED                    	XOR	BP,BP			; 0: enlarge   1: shrink  2:psp
 40065                                  	;cmp	bx,20
 40066 0000714B 83FB14                  	CMP	BX,FILPERPROC
 40067 0000714E 7303                    	JAE	short exth2		; Don't set less than FilPerProc no
 40068 00007150 BB1400                  	MOV	BX,FILPERPROC
 40069                                  exth2:	
 40070 00007153 368E06[3003]            	MOV	ES,[ss:CurrentPDB]	; get user process data block;smr;SS Override
 40071                                  	;mov	cx,[ES:32h]
 40072 00007158 268B0E3200              	MOV	CX,[ES:PDB.JFN_Length]	; get number of handle allowed
 40073 0000715D 39CB                    	CMP	BX,CX			; the requested == current
 40074 0000715F 7455                    	JE	short ok_done 		; yes and exit
 40075 00007161 7722                    	JA	short larger		; go allocate new table
 40076                                  
 40077                                  ;	We're going to shrink the # of handles available
 40078                                  
 40079 00007163 BD0100                  	MOV	BP,1			; shrink
 40080                                  	;mov	ds,[ES:36h]
 40081 00007166 268E1E3600              	MOV	DS,[ES:PDB.JFN_Pointer+2] ;
 40082 0000716B 89DE                    	MOV	SI,BX			;
 40083 0000716D 29D9                    	SUB	CX,BX			; get difference
 40084                                  
 40085                                  ;	BUGBUG - code a SCASB here, should be a bit smaller
 40086                                  chck_handles:
 40087 0000716F 803CFF                  	CMP	BYTE [SI],-1		; scan through handles to ensure close
 40088 00007172 753D                    	JNZ	short too_many_files	; status
 40089 00007174 46                      	INC	SI
 40090 00007175 E2F8                    	LOOP	chck_handles
 40091 00007177 83FB14                  	CMP	BX,FILPERPROC		; = 20
 40092 0000717A 7709                    	JA	short larger		; no
 40093                                  
 40094 0000717C BD0200                  	MOV	BP,2			; psp
 40095                                  	;mov	di,24
 40096 0000717F BF1800                  	MOV	DI,PDB.JFN_TABLE	; es:di -> jfn table in psp
 40097 00007182 53                      	PUSH	BX
 40098 00007183 EB1D                    	JMP	short movhandl
 40099                                  
 40100                                  larger:
 40101 00007185 83FBFF                  	CMP	BX,-1			; 65535 is not allowed
 40102 00007188 747F                    	JZ	short invalid_func	; 10/08/2018
 40103 0000718A F8                      	CLC
 40104 0000718B 53                      	PUSH	BX			; save requested number
 40105 0000718C 83C30F                  	ADD	BX,0FH			; adjust to paragraph boundary
 40106 0000718F B104                    	MOV	CL,4
 40107                                  	;ror	bx,cl			; MSDOS 3.3
 40108 00007191 D3DB                    	RCR	BX,CL			; DOS 4.00 fix		;AC000;
 40109 00007193 81E3FF1F                	AND	BX,1FFFH		; clear most 3 bits
 40110                                  
 40111 00007197 55                      	PUSH	BP
 40112 00007198 E8DCFA                  	call	_$ALLOC			; allocate memory
 40113 0000719B 5D                      	POP	BP
 40114 0000719C 7266                    	JC	short no_memory		; not enough meory
 40115                                  
 40116 0000719E 8EC0                    	MOV	ES,AX			; es:di points to new table memory
 40117 000071A0 31FF                    	XOR	DI,DI
 40118                                  movhandl:
 40119 000071A2 368E1E[3003]            	MOV	DS,[ss:CurrentPDB] 	; get user PDB address	;smr;SS Override
 40120                                  
 40121 000071A7 F7C50300                	test	BP,3			; enlarge ?
 40122 000071AB 740C                    	JZ	short enlarge 		; yes
 40123 000071AD 59                      	POP	CX			; cx = the amount you shrink
 40124 000071AE 51                      	PUSH	CX
 40125 000071AF EB0C                    	JMP	short copy_hand
 40126                                  
 40127                                  ;	Done.  'C' clear
 40128                                  
 40129                                  ; 17/12/2022
 40130                                  ;ok_done:
 40131                                  ;	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40132                                  ;	;jmp	short CommitOk
 40133                                  ;	; 17/12/2022
 40134                                  ;	jmp	SYS_RET_OK
 40135                                  
 40136                                  too_many_files:
 40137                                  	;mov	al,4
 40138 000071B1 B004                    	MOV	AL,error_too_many_open_files
 40139                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40140                                  	;jmp	SYS_RET_ERR
 40141                                  CommitErrorj:
 40142                                  	;jmp	short CommitError
 40143                                  	; 17/12/2022
 40144 000071B3 E9C494                  	jmp	SYS_RET_ERR
 40145                                  
 40146                                  ; 17/12/2022 
 40147                                  ok_done:
 40148                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40149                                  	;jmp	short CommitOk
 40150                                  	; 17/12/2022
 40151 000071B6 E9B794                  	jmp	SYS_RET_OK
 40152                                  
 40153                                  enlarge:
 40154                                  	;mov	cx,[32h]
 40155 000071B9 8B0E3200                	MOV	CX,[PDB.JFN_Length]	; get number of old handles
 40156                                  copy_hand:
 40157 000071BD 89CA                    	MOV	DX,CX
 40158                                  	;lds	si,[34h]
 40159 000071BF C5363400                	LDS	SI,[PDB.JFN_Pointer]	; get old table pointer
 40160 000071C3 F3A4                    	REP	MOVSB			; copy infomation to new table
 40161 000071C5 59                      	POP	CX			; get new number of handles
 40162 000071C6 51                      	PUSH	CX			; save it again
 40163 000071C7 29D1                    	SUB	CX,DX			; get the difference
 40164 000071C9 B0FF                    	MOV	AL,-1			; set availability to handles
 40165 000071CB F3AA                    	REP	STOSB
 40166 000071CD 368E1E[3003]            	MOV	DS,[ss:CurrentPDB] 	; get user process data block;smr;SS Override
 40167                                  	;cmp	word [34h],0
 40168 000071D2 833E340000              	CMP	WORD [PDB.JFN_Pointer],0 ; check if original table pointer
 40169 000071D7 750D                    	JNZ	short update_info	; yes, go update PDB entries
 40170 000071D9 55                      	PUSH	BP
 40171 000071DA 1E                      	PUSH	DS			; save old table segment
 40172 000071DB 06                      	PUSH	ES			; save new table segment
 40173 000071DC 8E063600                	MOV	ES,[PDB.JFN_Pointer+2]	; get old table segment
 40174 000071E0 E80EFC                  	call	_$DEALLOC		; deallocate old table meomory
 40175 000071E3 07                      	POP	ES			; restore new table segment
 40176 000071E4 1F                      	POP	DS			; restore old table segment
 40177 000071E5 5D                      	POP	BP
 40178                                  
 40179                                  update_info:
 40180 000071E6 F7C50200                	test	BP,2			; psp?
 40181 000071EA 7408                    	JZ	short non_psp 		; no
 40182                                  	;mov	word [34h],18h ; 24
 40183 000071EC C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE ; restore
 40184 000071F2 EB06                    	JMP	short final
 40185                                  non_psp:
 40186                                  	;mov	word [34h],0
 40187 000071F4 C70634000000            	MOV	WORD [PDB.JFN_Pointer],0 ; new table pointer offset always 0
 40188                                  final:
 40189                                  	;mov	[36h],es	
 40190 000071FA 8C063600                	MOV	[PDB.JFN_Pointer+2],ES	; update table pointer segment
 40191                                  	;pop	word [32h]
 40192 000071FE 8F063200                	POP	word [PDB.JFN_Length]	; restore new number of handles
 40193                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40194                                  	;jmp	SYS_RET_OK
 40195                                  ok_done_j:
 40196 00007202 EBB2                    	jmp	short ok_done
 40197                                  
 40198                                  no_memory:
 40199 00007204 5B                      	POP	BX			; clean stack
 40200                                  	;mov	al,8
 40201 00007205 B008                    	MOV	AL,error_not_enough_memory
 40202                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40203                                  	;jmp	SYS_RET_ERR
 40204                                  CommitErrorj2:
 40205 00007207 EBAA                    	jmp	short CommitErrorj
 40206                                  
 40207                                  invalid_func:
 40208                                  	;mov	al,1
 40209 00007209 B001                    	MOV	AL,error_invalid_function
 40210                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40211                                  	;jmp	SYS_RET_ERR
 40212                                  CommitErrorj3:
 40213                                  	;jmp	short CommitErrorj2
 40214                                  	; 17/12/2022
 40215 0000720B EBA6                    	jmp	short CommitErrorj
 40216                                  
 40217                                  ; 20/05/2019 - Retro DOS v4.0
 40218                                  ; DOSCODE:A83Ah (MSDOS 6.21, MSDOS.SYS)
 40219                                  
 40220                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40221                                  ; DOSCODE:A7DAh (MSDOS 5.0 MSDOS.SYS)
 40222                                  
 40223                                  ;	BREAK <$READ - Read from a file handle>
 40224                                  ;----------------------------------------------------------------------------
 40225                                  ;
 40226                                  ;**	$Read - Read from a File Handle
 40227                                  ;
 40228                                  ;   Assembler usage:
 40229                                  ;
 40230                                  ;	LDS	DX, buf
 40231                                  ;	MOV	CX, count
 40232                                  ;	MOV	BX, handle
 40233                                  ;	MOV	AH, Read
 40234                                  ;	INT	int_command
 40235                                  ;	  AX has number of bytes read
 40236                                  ;
 40237                                  ;	ENTRY	(bx) = file handle
 40238                                  ;		(cx) = byte count
 40239                                  ;		(ds:dx) = buffer address
 40240                                  ;	EXIT	Through system call return so that to user:
 40241                                  ;		  'C' clear if OK
 40242                                  ;		    (ax) = bytes read
 40243                                  ;		  'C' set if error
 40244                                  ;		    (ax) = error code
 40245                                  ;
 40246                                  ;----------------------------------------------------------------------------
 40247                                  
 40248                                  _$READ:
 40249 0000720D BE[4D3B]                	MOV	SI,DOS_READ
 40250                                  ReadDo:
 40251 00007210 E831FE                  	call	pJFNFromHandle
 40252 00007213 7208                    	JC	short ReadError
 40253                                  
 40254 00007215 268A05                  	MOV	AL,[ES:DI]
 40255 00007218 E83E01                  	call	CheckOwner		; get the handle
 40256 0000721B 7303                    	JNC	short ReadSetup		; no errors do the operation
 40257                                  
 40258                                  ;	Have an error. 'C' set
 40259                                  
 40260                                  ReadError:
 40261                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40262                                  	;;jmp	SYS_RET_ERR		; go to error traps
 40263                                  	;jmp	short CommitErrorj3
 40264                                  	; 17/12/2022
 40265 0000721D E95A94                  	jmp	SYS_RET_ERR
 40266                                  
 40267                                  ReadSetup:
 40268 00007220 36893E[9E05]            	MOV	[ss:THISSFT],DI		; save offset of pointer;smr;SS Override
 40269 00007225 368C06[A005]            	MOV	[ss:THISSFT+2],ES	; save segment value	;smr;SS Override
 40270                                  	; 20/05/2019 - Retro DOS v4.0
 40271                                  	; MSDOS 6.0 
 40272                                  ;; Extended Open
 40273                                  	;test	byte [es:di+3],20h
 40274 0000722A 26F6450320              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],(INT_24_ERROR>>8)
 40275                                  						 ;AN000;;EO. need i24
 40276 0000722F 7406                    	JZ	short needi24 		     	 ;AN000;;EO. yes
 40277 00007231 36800E[F605]02          	OR	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF ; 2
 40278                                  					;AN000;;EO. set it off;smr;SS Override
 40279                                  needi24:				;AN000;
 40280                                  ;; Extended Open
 40281 00007237 36FF36[2C03]            	push	word [SS:DMAADD]
 40282 0000723C 36FF36[2E03]            	push	word [SS:DMAADD+2]	;smr;SS Override
 40283                                  
 40284                                  ;;;;;	BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 40285                                  
 40286                                  	; 26/07/2019
 40287                                  
 40288                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40289                                  	;
 40290                                  	; (It is not necessary to call 'Align_Buffer' proc here/below because
 40291                                  	; there is not another caller; it is better to put the code in this proc
 40292                                   	; here instead of calling it as a subroutine; but I have modified code
 40293                                  	; here for MSDOS 5.0 MSDOS.SYS address compatibility)
 40294                                  
 40295                                  	; MSDOS 6.0
 40296 00007241 E81300                  	CALL	Align_Buffer		;AN000;MS. align user's buffer
 40297                                  	
 40298                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40299                                  	; MSDOS 3.3
 40300                                  	;MOV	BX,DX			; copy offset
 40301                                  	;push	cx			; don't stomp on count
 40302                                  	;MOV	CL,4			; bits to shift bytes->para
 40303                                  	;SHR	BX,CL			; get number of paragraphs
 40304                                  	;pop	cx			; get count back
 40305                                  	;MOV	AX,DS			; get original segment
 40306                                  	;ADD	AX,BX			; get new segment
 40307                                  	;MOV	DS,AX			; in seg register
 40308                                  	;AND	DX,0Fh			; normalize offset
 40309                                  	;MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 40310                                  	;MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 40311                                  						;smr;SS Override
 40312                                  ;;;;;	END BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 40313                                  	
 40314 00007244 16                      	push	ss			; go for DOS addressability
 40315 00007245 1F                      	pop	ds
 40316                                  
 40317 00007246 FFD6                    	CALL	SI ; DOS_READ		; indirect call to operation
 40318                                  
 40319 00007248 8F06[2E03]              	pop	word [DMAADD+2]
 40320 0000724C 8F06[2C03]              	pop	word [DMAADD]
 40321                                  	;JNC	short READ_OK		;AN002;
 40322                                  	;JMP	short ReadError		;AN002; if error, say bye bye
 40323                                  	; 17/12/2022
 40324 00007250 72CB                    	jc	short ReadError
 40325                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40326                                  	;jnc	short READ_OK		;AN002;
 40327                                  	;jmp	short ReadError
 40328                                  
 40329                                  READ_OK:
 40330 00007252 89C8                    	MOV	AX,CX			; get correct return in correct reg
 40331                                  Read_Okj:
 40332                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40333                                  	;;jmp	SYS_RET_OK		; successful return
 40334                                  	;jmp	short ok_done_j
 40335                                  	; 17/12/2022
 40336 00007254 E91994                  	jmp	SYS_RET_OK
 40337                                  
 40338                                  ; 13/07/2018 - Retro DOS v3.0
 40339                                  
 40340                                  ;----------------------------------------------------------------------------
 40341                                  
 40342                                  ;   Input: DS:DX points to user's buffer addr
 40343                                  ;   Function: rearrange segment and offset for READ/WRITE buffer
 40344                                  ;   Output: [DMAADD] set
 40345                                  
 40346                                  ; 20/05/2019 - Retro DOS v4.0
 40347                                  ; 26/07/2019
 40348                                  ;	; MSDOS 6.0
 40349                                  ;Align_Buffer:
 40350                                  ;	MOV	BX,DX			; copy offset
 40351                                  ;	push	cx			; don't stomp on count
 40352                                  ;	MOV	CL,4			; bits to shift bytes->para
 40353                                  ;	SHR	BX,CL			; get number of paragraphs
 40354                                  ;	pop	cx			; get count back
 40355                                  ;	MOV	AX,DS			; get original segment
 40356                                  ;	ADD	AX,BX			; get new segment
 40357                                  ;	MOV	DS,AX			; in seg register
 40358                                  ;	AND	DX,0Fh			; normalize offset
 40359                                  ;	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 40360                                  ;	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 40361                                  ;						;smr;SS Override
 40362                                  ;	retn
 40363                                  
 40364                                  ; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40365                                  Align_Buffer:
 40366 00007257 89D3                    	MOV	BX,DX			; copy offset
 40367 00007259 51                      	push	cx			; don't stomp on count
 40368 0000725A B104                    	MOV	CL,4			; bits to shift bytes->para
 40369 0000725C D3EB                    	SHR	BX,CL			; get number of paragraphs
 40370 0000725E 59                      	pop	cx			; get count back
 40371 0000725F 8CD8                    	MOV	AX,DS			; get original segment
 40372 00007261 01D8                    	ADD	AX,BX			; get new segment
 40373 00007263 8ED8                    	MOV	DS,AX			; in seg register
 40374 00007265 83E20F                  	AND	DX,0Fh			; normalize offset
 40375 00007268 368916[2C03]            	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 40376 0000726D 368C1E[2E03]            	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 40377                                  						;smr;SS Override
 40378 00007272 C3                      	retn
 40379                                  
 40380                                  ; 20/05/2019 - Retro DOS v4.0
 40381                                  ; DOSCODE:A8A0h (MSDOS 6.21, MSDOS.SYS)
 40382                                  
 40383                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40384                                  ; DOSCODE:A840h (MSDOS 5.0 MSDOS.SYS)
 40385                                  
 40386                                  ;BREAK <$WRITE - write to a file handle>
 40387                                  ;----------------------------------------------------------------------------
 40388                                  ;
 40389                                  ;   Assembler usage:
 40390                                  ;	    LDS     DX, buf
 40391                                  ;	    MOV     CX, count
 40392                                  ;	    MOV     BX, handle
 40393                                  ;	    MOV     AH, Write
 40394                                  ;	    INT     int_command
 40395                                  ;	  AX has number of bytes written
 40396                                  ;   Errors:
 40397                                  ;	    AX = write_invalid_handle
 40398                                  ;	       = write_access_denied
 40399                                  ;
 40400                                  ;   Returns in register AX
 40401                                  ;
 40402                                  ;----------------------------------------------------------------------------
 40403                                  
 40404                                  _$WRITE:
 40405 00007273 BE[763D]                	MOV	SI,DOS_WRITE
 40406 00007276 EB98                    	JMP	short ReadDo
 40407                                  
 40408                                  ;BREAK <$LSEEK - move r/w pointer>
 40409                                  ;----------------------------------------------------------------------------
 40410                                  ;
 40411                                  ;   Assembler usage:
 40412                                  ;	    MOV     DX, offsetlow
 40413                                  ;	    MOV     CX, offsethigh
 40414                                  ;	    MOV     BX, handle
 40415                                  ;	    MOV     AL, method
 40416                                  ;	    MOV     AH, LSeek
 40417                                  ;	    INT     int_command
 40418                                  ;	  DX:AX has the new location of the pointer
 40419                                  ;   Error returns:
 40420                                  ;	    AX = error_invalid_handle
 40421                                  ;	       = error_invalid_function
 40422                                  ;   Returns in registers DX:AX
 40423                                  ;
 40424                                  ;----------------------------------------------------------------------------
 40425                                  
 40426                                  ; 21/05/2019 - Retro DOS v4.0
 40427                                  ; DOSCODE:A8A5h (MSDOS 6.21, MSDOS.SYS)
 40428                                  
 40429                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40430                                  ; DOSCODE:A845h (MSDOS 5.0 MSDOS.SYS)
 40431                                  
 40432                                  _$LSEEK:
 40433 00007278 E8DE00                  	call	CheckOwner		; get system file entry
 40434                                  
 40435                                  	; 17/12/2022
 40436                                  ;LSeekError:
 40437                                  	;JNC	short CHKOWN_OK		;AN002;
 40438                                  	;JMP	short ReadError		;AN002; error return
 40439                                  	; 17/12/2022
 40440                                  	; 02/06/2019
 40441 0000727B 72A0                    	jc	short ReadError
 40442                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40443                                  	;JNC	short CHKOWN_OK		;AN002;
 40444                                  	;JMP	short ReadError		;AN002; error return
 40445                                  
 40446                                  CHKOWN_OK:
 40447                                  					;AN002;
 40448 0000727D 3C02                    	CMP	AL,2			; is the seek value correct?
 40449 0000727F 760A                    	JBE	short LSeekDisp		; yes, go dispatch
 40450                                  	;mov	byte [ss:EXTERR_LOCUS],1 
 40451 00007281 36C606[2303]01          	MOV	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 40452                                  					;smr;SS Override
 40453                                  	;mov	al,1
 40454 00007287 B001                    	mov	al,error_invalid_function ; invalid method
 40455                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40456                                  LSeekError2:
 40457 00007289 EB92                    	jmp	short ReadError
 40458                                  
 40459                                  LSeekDisp:
 40460 0000728B 3C01                    	CMP	AL,1			; best way to dispatch; check middle
 40461 0000728D 720A                    	JB	short LSeekStore	; just store CX:DX
 40462 0000728F 771B                    	JA	short LSeekEOF		; seek from end of file
 40463                                  	;add	dx,[es:di+21]
 40464 00007291 26035515                	ADD	DX,[ES:DI+SF_ENTRY.sf_position]
 40465                                  	;adc	cx,[es:di+23]
 40466 00007295 26134D17                	ADC	CX,[ES:DI+SF_ENTRY.sf_position+2]
 40467                                  LSeekStore:
 40468 00007299 89C8                    	MOV	AX,CX			; AX:DX
 40469 0000729B 92                      	XCHG	AX,DX			; DX:AX is the correct value
 40470                                  LSeekSetpos:
 40471                                  	;mov	[es:di+21],ax
 40472 0000729C 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 40473                                  	;mov	[es:di+23],dx
 40474 000072A0 26895517                	MOV	[ES:DI+SF_ENTRY.sf_position+2],DX
 40475 000072A4 E8D091                  	call	Get_User_Stack
 40476                                  	;mov	[si+6],dx
 40477 000072A7 895406                  	MOV	[SI+user_env.user_DX],DX ; return DX:AX
 40478                                  	;jmp	SYS_RET_OK		; successful return
 40479                                  	; 25/06/2019
 40480                                  	;jmp	SYS_RET_OK_clc
 40481                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40482                                  	;jmp	SYS_RET_OK_clc
 40483                                  LSeekOk:
 40484 000072AA EBA8                    	jmp     short Read_Okj
 40485                                  
 40486                                  LSeekEOF:
 40487                                  	;;test	word [es:di+5],8000h
 40488                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 40489                                  	; 21/05/2019 - Retro DOS v4.0
 40490 000072AC 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 40491 000072B1 750A                    	JNZ	short Check_LSeek_Mode	; Is Net
 40492                                  LOCAL_LSeek:
 40493                                  	;add	dx,[es:di+17]
 40494 000072B3 26035511                	ADD	DX,[ES:DI+SF_ENTRY.sf_size]
 40495                                  	;adc	cx,[es:di+19]
 40496 000072B7 26134D13                	ADC	CX,[ES:DI+SF_ENTRY.sf_size+2]
 40497 000072BB EBDC                    	JMP	short LSeekStore	; go and set the position
 40498                                  
 40499                                  Check_LSeek_Mode:
 40500                                  	;;test	word [es:di+2],8000h
 40501                                  	;test	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 40502                                  	; 21/05/2019
 40503 000072BD 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 40504 000072C2 75EF                    	JNZ	short LOCAL_LSeek	; FCB treated like local file
 40505                                  	;mov	ax,[es:di+2]
 40506 000072C4 268B4502                	MOV	AX,[ES:DI+SF_ENTRY.sf_mode]
 40507                                  	;and	ax, 0F0h
 40508 000072C8 25F000                  	AND	AX,SHARING_MASK
 40509                                  	;cmp	ax,40h
 40510 000072CB 83F840                  	CMP	AX,SHARING_DENY_NONE
 40511 000072CE 7405                    	JZ	short NET_LSEEK		; LSEEK exported in this mode
 40512                                  	;cmp	ax,30h
 40513 000072D0 83F830                  	CMP	AX,SHARING_DENY_READ
 40514 000072D3 75DE                    	JNZ	short LOCAL_LSeek	; Treated like local Lseek
 40515                                  NET_LSEEK:
 40516                                  ;	JMP	short LOCAL_LSeek
 40517                                  ; REMOVE ABOVE INSTRUCTION TO ENABLE DCR 142
 40518                                  	;CallInstall Net_Lseek,MultNET,33
 40519                                  	;JNC	short LSeekSetPos
 40520                                  
 40521 000072D5 B82111                  	mov     ax,1121h
 40522 000072D8 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE
 40523                                  			; CX:DX = offset (in bytes) from end
 40524                                  			; ES:DI -> SFT, SFT DPB field -> DPB of drive with file
 40525                                  			; SS = DOS CS
 40526                                  			; Return: CF set on error
 40527                                  			; CF clear if successful, DX:AX = new file position
 40528 000072DA 73C0                    	jnb     short LSeekSetpos
 40529                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40530                                  	;jmp	SYS_RET_ERR
 40531                                  ;LSeekError3:
 40532                                  	; 17/12/2022
 40533                                  LSeekError:
 40534                                  	;jmp	short LSeekError2
 40535                                  DupErr:	; 17/12/2022
 40536 000072DC E99B93                  	jmp	SYS_RET_ERR
 40537                                  
 40538                                  ;BREAK <FileTimes - modify write times on a handle>
 40539                                  ;----------------------------------------------------------------------------
 40540                                  ;
 40541                                  ;   Assembler usage:
 40542                                  ;	    MOV AH, FileTimes (57H)
 40543                                  ;	    MOV AL, func
 40544                                  ;	    MOV BX, handle
 40545                                  ;	; if AL = 1 then then next two are mandatory
 40546                                  ;	    MOV CX, time
 40547                                  ;	    MOV DX, date
 40548                                  ;	    INT 21h
 40549                                  ;	; if AL = 0 then CX/DX has the last write time/date
 40550                                  ;	; for the handle.
 40551                                  ;
 40552                                  ;	AL=02		 get extended attributes
 40553                                  ;	   BX=handle
 40554                                  ;	   CX=size of buffer (0, return max size )
 40555                                  ;	   DS:SI query list (si=-1, selects all EA)
 40556                                  ;	   ES:DI buffer to hold EA list
 40557                                  ;
 40558                                  ;	AL=03		 get EA name list
 40559                                  ;	   BX=handle
 40560                                  ;	   CX=size of buffer (0, return max size )
 40561                                  ;	   ES:DI buffer to hold name list
 40562                                  ;
 40563                                  ;	AL=04		 set extended attributes
 40564                                  ;	   BX=handle
 40565                                  ;	   ES:DI buffer of EA list
 40566                                  ;
 40567                                  ;
 40568                                  ;   Error returns:
 40569                                  ;	    AX = error_invalid_function
 40570                                  ;	       = error_invalid_handle
 40571                                  ;
 40572                                  ;----------------------------------------------------------------------------
 40573                                  
 40574                                  ; 21/05/2019 - Retro DOS v4.0
 40575                                  ; DOSCODE:A90Dh (MSDOS 6.21, MSDOS.SYS)
 40576                                  
 40577                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40578                                  ; DOSCODE:A8ADh (MSDOS 5.0 MSDOS.SYS)
 40579                                  
 40580                                  _$FILE_TIMES:
 40581                                  	; 13/07/2018 - Retro DOS v3.0
 40582                                  
 40583                                  	; MSDOS 3.3
 40584                                  	;cmp	al,2			; correct subfunction ?
 40585                                  	;jb	short ft1
 40586                                  
 40587                                  	;;mov	byte [ss:EXTERR_LOCUS], 1
 40588                                  	;mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 40589                                  						;SS Overr
 40590                                  	;;mov	al,1
 40591                                  	;mov	al,error_invalid_function ; give bad return
 40592                                  	;jmp	SYS_RET_ERR
 40593                                  
 40594                                  	; MSDOS 6.0
 40595 000072DF 3C02                    	cmp	al,2			; correct subfunction ?
 40596 000072E1 7340                    	jae	short inval_func
 40597                                  ;ft1:
 40598 000072E3 E87300                  	call	CheckOwner		; get sft
 40599                                  	; 17/12/2022
 40600 000072E6 72F4                    	jc	short LSeekError	; bad handle
 40601                                  
 40602 000072E8 08C0                    	or	al,al			; get time/date ?
 40603 000072EA 7515                    	jnz	short ft_set_time
 40604                                  
 40605                                  ;------ here we get the time & date from the sft for the user
 40606                                  
 40607 000072EC FA                      	cli				; is this cli/sti reqd ? BUGBUG
 40608                                  	;mov	cx,[es:di+13]
 40609 000072ED 268B4D0D                	mov	cx,[es:di+SF_ENTRY.sf_time] ; get the time
 40610                                  	;mov	dx,[es:di+15]
 40611 000072F1 268B550F                	mov	dx,[es:di+SF_ENTRY.sf_date] ;  & date
 40612 000072F5 FB                      	sti
 40613 000072F6 E87E91                  	call	Get_User_Stack
 40614                                  	;mov	[si+4],cx
 40615 000072F9 894C04                  	mov	[si+user_env.user_CX],cx
 40616                                  	;mov	[si+6],dx
 40617 000072FC 895406                  	mov	[si+user_env.user_DX],dx
 40618 000072FF EB1F                    	jmp	short ok_ret
 40619                                  
 40620                                  ;------ here we set the time in sft
 40621                                  
 40622                                  ft_set_time:
 40623 00007301 E8FFA5                  	call    ECritSFT
 40624                                  	;mov	[es:di+13],cx
 40625 00007304 26894D0D                	mov	[es:di+SF_ENTRY.sf_time],cx ; drop in new time
 40626                                  	;mov	[es:di+15],dx
 40627 00007308 2689550F                	mov	[es:di+SF_ENTRY.sf_date],dx ;  and date	
 40628                                  
 40629 0000730C 31C0                    	xor	ax, ax
 40630 0000730E 36FF1E[C800]            	call	far [ss:JShare+(14*4)] ; 14 = ShSU	; SS Override
 40631                                  
 40632                                  ;------ set the flags in SFT entry
 40633                                  	;and	word [es:di+5],0FFBFh
 40634                                  	; 18/12/2022
 40635                                  	;and	byte [es:di+5],0BFh
 40636 00007313 26806505BF              	and	byte [es:di+SF_ENTRY.sf_flags],~devid_file_clean
 40637                                  	;and	word [es:di+SF_ENTRY.sf_flags],~devid_file_clean 
 40638                                  							; mark file as dirty
 40639                                  	;or	word [es:di+5],4000h
 40640                                  	; 17/12/2022
 40641                                  	;or	byte [es:di+6],40h
 40642 00007318 26804D0640              	or	byte [es:di+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8)
 40643                                  	;or	word [es:di+SF_ENTRY.sf_flags],sf_close_nodate
 40644                                  							; ask close not to
 40645                                  							;   bother about date
 40646                                  							;   and time
 40647 0000731D E810A6                  	call	LCritSFT
 40648                                  ok_ret:
 40649                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40650                                  	; 17/12/2022
 40651 00007320 E94D93                  	jmp	SYS_RET_OK
 40652                                  	;jmp	short LSeekOk
 40653                                  
 40654                                  inval_func:
 40655                                  	;mov	byte [ss:EXTERR_LOCUS],1
 40656 00007323 36C606[2303]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 40657                                  						;SS Overr
 40658                                  	;mov	al,1
 40659 00007329 B001                    	mov	al,error_invalid_function ; give bad return
 40660                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40661                                  ft_error:
 40662                                  	;;jmp	SYS_RET_ERR
 40663                                  	;jmp	short LSeekError3
 40664                                  	; 17/12/2022
 40665 0000732B EBAF                    	jmp	short LSeekError
 40666                                  
 40667                                  ; 21/05/2019 - Retro DOS v4.0
 40668                                  ; DOSCODE:A95Bh (MSDOS 6.21, MSDOS.SYS)
 40669                                  
 40670                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40671                                  ; DOSCODE:A8FBh (MSDOS 5.0 MSDOS.SYS)
 40672                                  
 40673                                  ;BREAK <$DUP - duplicate a jfn>
 40674                                  ;----------------------------------------------------------------------------
 40675                                  ;
 40676                                  ;   Assembler usage:
 40677                                  ;	    MOV     BX, fh
 40678                                  ;	    MOV     AH, Dup
 40679                                  ;	    INT     int_command
 40680                                  ;	  AX has the returned handle
 40681                                  ;   Errors:
 40682                                  ;	    AX = dup_invalid_handle
 40683                                  ;	       = dup_too_many_open_files
 40684                                  ;
 40685                                  ;----------------------------------------------------------------------------
 40686                                  
 40687                                  _$DUP:
 40688 0000732D 89D8                    	MOV	AX,BX			; save away old handle in AX
 40689 0000732F E86FFD                  	call	JFNFree 		; free handle? into ES:DI, new in BX
 40690                                  DupErrorCheck:
 40691 00007332 72A8                    	JC	short DupErr		; nope, bye
 40692 00007334 06                      	push	es
 40693 00007335 57                      	push	di			; save away SFT
 40694 00007336 5E                      	pop	si			; into convenient place DS:SI
 40695 00007337 1F                      	pop	ds
 40696 00007338 93                      	XCHG	AX,BX			; get back old handle
 40697 00007339 E81D00                  	call	CheckOwner		; get sft in ES:DI
 40698 0000733C 729E                    	JC	short DupErr		; errors go home
 40699 0000733E E8A2BD                  	call	DOS_Dup_Direct
 40700 00007341 E800FD                  	call	pJFNFromHandle		; get pointer
 40701 00007344 268A1D                  	MOV	BL,[ES:DI]		; get SFT number
 40702 00007347 881C                    	MOV	[SI],BL			; stuff in new SFT
 40703                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40704                                  	;jmp	SYS_RET_OK		; and go home
 40705 00007349 EBD5                    	jmp	short ok_ret
 40706                                  
 40707                                  	; 17/12/2022
 40708                                  ;DupErr:
 40709                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40710                                  	;;jmp	SYS_RET_ERR
 40711                                  	;jmp	short ft_error
 40712                                  
 40713                                  ;BREAK <$DUP2 - force a dup on a particular jfn>
 40714                                  ;----------------------------------------------------------------------------
 40715                                  ;
 40716                                  ;   Assembler usage:
 40717                                  ;	    MOV     BX, fh
 40718                                  ;	    MOV     CX, newfh
 40719                                  ;	    MOV     AH, Dup2
 40720                                  ;	    INT     int_command
 40721                                  ;   Error returns:
 40722                                  ;	    AX = error_invalid_handle
 40723                                  ;
 40724                                  ;----------------------------------------------------------------------------
 40725                                  
 40726                                  _$DUP2:
 40727 0000734B 53                      	push	bx
 40728 0000734C 51                      	push	cx			; save source
 40729 0000734D 89CB                    	MOV	BX,CX			; get one to close
 40730 0000734F E8AAFD                  	call	_$CLOSE			; close destination handle
 40731 00007352 5B                      	pop	bx
 40732 00007353 58                      	pop	ax			; old in AX, new in BX
 40733 00007354 E8EDFC                  	call	pJFNFromHandle		; get pointer
 40734 00007357 EBD9                    	JMP	short DupErrorCheck	; check error and do dup
 40735                                  
 40736                                  ;Break	<CheckOwner - verify ownership of handles from server>
 40737                                  ;----------------------------------------------------------------------------
 40738                                  ;   CheckOwner - Due to the ability of the server to close file handles for a
 40739                                  ;   process without the process knowing it (delete/rename of open files, for
 40740                                  ;   example), it is possible for the redirector to issue a call to a handle
 40741                                  ;   that it soes not rightfully own. We check here to make sure that the
 40742                                  ;   issuing process is the owner of the SFT. At the same time, we do a
 40743                                  ;   SFFromHandle to really make sure that the SFT is good.
 40744                                  ;
 40745                                  ;	ENTRY	BX has the handle
 40746                                  ;		User_ID is the current user
 40747                                  ;	EXIT	Carry Clear => ES:DI points to SFT
 40748                                  ;		Carry Set => AX has error code
 40749                                  ;	USES	none
 40750                                  ;----------------------------------------------------------------------------
 40751                                  
 40752                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40753                                  	; 21/05/2019 - Retro DOS v4.0
 40754                                  CheckOwner:
 40755                                  	; 13/07/2018 - Retro DOS v3.0
 40756                                  
 40757 00007359 E805FD                  	call	SFFromHandle
 40758 0000735C 721B                    	jc	short co_ret_label	; retc
 40759                                  
 40760 0000735E 50                      	push	ax
 40761                                  
 40762                                  	; MSDOS 6.0
 40763                                  
 40764                                  ;SR; WIN386 patch - Do not check for USER_ID for using handles since these 
 40765                                  ;SR; are shared across multiple VMs in win386.
 40766                                  
 40767 0000735F 36F606[A110]01          	test	byte [ss:IsWin386],1 ; 02/06/2019
 40768 00007365 7404                    	jz	short no_win386		;win386 is not present
 40769 00007367 31C0                    	xor	ax,ax			;set the zero flag
 40770 00007369 EB08                    	jmp	short _skip_win386	
 40771                                  
 40772                                  no_win386:
 40773 0000736B 36A1[3E03]              	mov	ax,[SS:USER_ID]		;smr;SS Override
 40774                                  	;cmp	ax,[es:di+47]
 40775 0000736F 263B452F                	cmp	ax,[es:di+SF_ENTRY.sf_UID]
 40776                                  
 40777                                  _skip_win386:
 40778 00007373 58                      	pop	ax
 40779                                  	
 40780                                  	; 17/12/2022
 40781 00007374 7403                    	jz	short co_ret_label
 40782                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40783                                  	;jnz	short CheckOwner_err
 40784                                  	;retn
 40785                                  	
 40786                                  CheckOwner_err:
 40787                                  	;mov	al,6
 40788 00007376 B006                    	mov	al,error_invalid_handle
 40789 00007378 F9                      	stc
 40790                                  
 40791                                  co_ret_label:
 40792 00007379 C3                      	retn
 40793                                  
 40794                                  ;============================================================================
 40795                                  ; MACRO.ASM, MSDOS 6.0, 1991
 40796                                  ;============================================================================
 40797                                  ; Retro	DOS v3.0 - 11/07/2018
 40798                                  ; 21/05/2019 - Retro DOS v4.0
 40799                                  
 40800                                  ;	TITLE	MACRO - Pathname and macro related internal routines
 40801                                  ;	NAME	MACRO
 40802                                  
 40803                                  ;	Microsoft Confidential
 40804                                  ;	Copyright (C) Microsoft Corporation 1991
 40805                                  ;	All Rights Reserved.
 40806                                  
 40807                                  ;**	MACRO.ASM
 40808                                  ;
 40809                                  ;	$AssignOper
 40810                                  ;	FIND_DPB
 40811                                  ;	InitCDS
 40812                                  ;	$UserOper
 40813                                  ;	GetVisDrv
 40814                                  ;	GetThisDrv
 40815                                  ;	GetCDSFromDrv
 40816                                  ;
 40817                                  ;   Revision history:
 40818                                  ;
 40819                                  ;	Created: MZ 4 April 1983
 40820                                  ;		 MZ 18 April 1983   Make TransFCB handle extended FCBs
 40821                                  ;		 AR 2 June 1983     Define/Delete macro for NET redir.
 40822                                  ;		 MZ 3 Nov 83	    Fix InitCDS to reset length to 2
 40823                                  ;		 MZ 4 Nov 83	    Fix NetAssign to use STRLEN only
 40824                                  ;		 MZ 18 Nov 83	    Rewrite string processing for subtree
 40825                                  ;				    aliasing.
 40826                                  ;
 40827                                  ;   MSDOS performs several types of name translation. First, we maintain for
 40828                                  ;   each valid drive letter the text of the current directory on that drive.
 40829                                  ;   For invalid drive letters, there is no current directory so we pretend to
 40830                                  ;   be at the root. A current directory is either the raw local directory
 40831                                  ;   (consisting of drive:\path) or a local network directory (consisting of
 40832                                  ;   \\machine\path. There is a limit on the point to which a .. is allowed.
 40833                                  ;
 40834                                  ;   Given a path, MSDOS will transform this into a real from-the-root path
 40835                                  ;   without . or .. entries. Any component that is > 8.3 is truncated to
 40836                                  ;   this and all * are expanded into ?'s.
 40837                                  ;
 40838                                  ;   The second part of name translation involves subtree aliasing. A list of
 40839                                  ;   subtree pairs is maintained by the external utility SUBST. The results of
 40840                                  ;   the previous 'canonicalization' are then examined to see if any of the
 40841                                  ;   subtree pairs is a prefix of the user path. If so, then this prefix is
 40842                                  ;   replaced with the other subtree in the pair.
 40843                                  ;
 40844                                  ;   A third part involves mapping this "real" path into a "physical" path.  A
 40845                                  ;   list of drive/subtree pairs are maintained by the external utility JOIN.
 40846                                  ;   The output of the previous translation is examined to see if any of the
 40847                                  ;   subtrees in this list are a prefix of the string. If so, then the prefix
 40848                                  ;   is replaced by the appropriate drive letter. In this manner, we can
 40849                                  ;   'mount' one device under another.
 40850                                  ;
 40851                                  ;   The final form of name translation involves the mapping of a user's
 40852                                  ;   logical drive number into the internal physical drive. This is
 40853                                  ;   accomplished by converting the drive number into letter:CON, performing
 40854                                  ;   the above translation and then converting the character back into a drive
 40855                                  ;   number.
 40856                                  ;
 40857                                  ;   There are two main entry points: TransPath and TransFCB. TransPath will
 40858                                  ;   take a path and form the real text of the pathname with all . and ..
 40859                                  ;   removed. TransFCB will translate an FCB into a path and then invoke
 40860                                  ;   TransPath.
 40861                                  ;
 40862                                  ;	A000	version 4.00  Jan. 1988
 40863                                  
 40864                                  ;Installed = TRUE
 40865                                  
 40866                                  ;	I_need	ThisCDS,DWORD		; pointer to CDS used
 40867                                  ;	I_need	CDSAddr,DWORD		; pointer to CDS table
 40868                                  ;	I_need	CDSCount,BYTE		; number of CDS entries
 40869                                  ;	I_need	CurDrv,BYTE		; current macro assignment (old
 40870                                  ;					; current drive)
 40871                                  ;	I_need	NUMIO,BYTE		; Number of physical drives
 40872                                  ;	I_need	fSharing,BYTE		; TRUE => no redirection allowed
 40873                                  ;	I_need	DummyCDS,80h		; buffer for dummy cds
 40874                                  ;	I_need	DIFFNAM,BYTE		; flag for MyName being set
 40875                                  ;	I_need	MYNAME,16		; machine name
 40876                                  ;	I_need	MYNUM,WORD		; machine number
 40877                                  ;	I_need	DPBHEAD,DWORD		; beginning of DPB chain
 40878                                  ;	I_need	EXTERR_LOCUS,BYTE	; Extended Error Locus
 40879                                  ;	I_need	DrvErr,BYTE		; drive error
 40880                                  
 40881                                  ;BREAK <$AssignOper -- Set up a Macro>
 40882                                  ;----------------------------------------------------------------------------
 40883                                  ; Inputs:
 40884                                  ;	AL = 00 get assign mode 		    (ReturnMode)
 40885                                  ;	AL = 01 set assign mode 		    (SetMode)
 40886                                  ;	AL = 02 get attach list entry		    (GetAsgList)
 40887                                  ;	AL = 03 Define Macro (attch start)
 40888                                  ;	    BL = Macro type
 40889                                  ;	       = 0 alias
 40890                                  ;	       = 1 file/device
 40891                                  ;	       = 2 drive
 40892                                  ;	       = 3 Char device -> network
 40893                                  ;	       = 4 File device -> network
 40894                                  ;	    DS:SI -> ASCIZ source name
 40895                                  ;	    ES:DI -> ASCIZ destination name
 40896                                  ;	AL = 04 Cancel Macro
 40897                                  ;	    DS:SI -> ASCIZ source name
 40898                                  ;	AL = 05 Modified get attach list entry
 40899                                  ;	AL = 06 Get ifsfunc item
 40900                                  ;	AL = 07 set in_use of a drive's CDS
 40901                                  ;	     DL = drive number, 0=default  0=A,,
 40902                                  ;	AL = 08 reset in_use of a drive's CDS
 40903                                  ;	     DL = drive number, 0=A, 1=B,,,
 40904                                  ; Function:
 40905                                  ;	Do macro stuff
 40906                                  ; Returns:
 40907                                  ;	Std Xenix style error return
 40908                                  ;----------------------------------------------------------------------------
 40909                                  
 40910                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40911                                  	; 21/05/2019 - Retro DOS v4.0
 40912                                  _$AssignOper:
 40913                                  	; MSDOS 6.0
 40914 0000737A 3C07                    	CMP	AL,7			      ; set in_use ?		;AN000;
 40915 0000737C 7525                    	JNZ	short chk08		      ; no			;AN000;
 40916                                  srinuse:								;AN000;
 40917 0000737E 50                      	PUSH	AX			      ; save al 		;AN000;
 40918 0000737F 88D0                    	MOV	AL,DL			      ; AL= drive id		;AN000;
 40919 00007381 E85601                  	CALL	GetCDSFromDrv		      ; ds:si -> cds		;AN000;
 40920 00007384 58                      	POP	AX			      ; 			;AN000;
 40921 00007385 7216                    	JC	short baddrv		      ; bad drive		;AN000;
 40922                                  	;cmp	word [si+45h],0
 40923 00007387 837C4500                	CMP	WORD [SI+curdir.devptr],0     ; dpb ptr =0 ?		;AN000;
 40924 0000738B 7410                    	JZ	short baddrv		      ;     no			;AN000;
 40925 0000738D 3C07                    	CMP	AL,7			      ; set ?			;AN000;
 40926 0000738F 7506                    	JNZ	short resetdrv		      ; no			;AN000;
 40927                                  	;or	word [si+43h],4000h
 40928                                  	; 17/12/2022
 40929                                  	;or	byte [si+44h],40h
 40930 00007391 804C4440                	or	byte [SI+curdir.flags+1],(curdir_inuse>>8)
 40931                                  	;OR	word [SI+curdir.flags],curdir_inuse ; set in_use	;AN000;
 40932 00007395 EB19                    	JMP	SHORT okdone		      ; 			;AN000;
 40933                                  resetdrv:
 40934                                  	;and	word [si+43h],0BFFFh					;AN000;
 40935                                  	; 18/12/2022
 40936 00007397 806444BF                	and	byte [SI+curdir.flags+1],0BFh ; (~curdir_inuse)>>8
 40937                                  	;AND	word [SI+curdir.flags],~curdir_inuse ; reset in_use	;AN000;
 40938 0000739B EB13                    	JMP	SHORT okdone		      ; 			;AN000;
 40939                                  
 40940                                  	; 17/12/2022
 40941                                  baddrv: 								;AN000;
 40942 0000739D B80F00                  	MOV	AX,error_invalid_drive	      ; error			;AN000;
 40943                                  
 40944                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40945                                  	;JMP	SHORT ASS_ERR		      ; 			;AN000;
 40946                                  	; 17/12/2022
 40947                                  	; 21/05/2019
 40948                                  ASS_ERR:
 40949 000073A0 E9D792                  	jmp	SYS_RET_ERR
 40950                                  
 40951                                  chk08:									;AN000;
 40952 000073A3 3C08                    	CMP	AL,8			      ; reset inuse ?		;AN000;
 40953 000073A5 74D7                    	JZ	short srinuse 		      ; yes			;AN000;
 40954                                  
 40955                                    ;IF	NOT INSTALLED
 40956                                  	;transfer NET_ASSOPER
 40957                                    ;ELSE
 40958                                  	; MSDOS 3.3 (& MSDOS 6.0)
 40959 000073A7 50                      	PUSH	AX
 40960                                  	;mov	ax,111Eh
 40961                                  	;MOV	AX,(MultNET SHL 8) OR 30
 40962 000073A8 B81E11                  	mov	ax,(MultNET*256)+30
 40963 000073AB CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
 40964                                  			; SS = DOS CS
 40965                                  			; STACK: WORD function to execute
 40966                                  			; Return: CF set on error, AX = error code
 40967                                  			; STACK unchanged
 40968 000073AD 5B                      	POP	BX			; Don't zap error code in AX
 40969 000073AE 72F0                    	JC	short ASS_ERR
 40970                                  okdone:
 40971 000073B0 E9BD92                  	jmp	SYS_RET_OK
 40972                                  
 40973                                  	; 17/12/2022
 40974                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40975                                  ;ASS_ERR:
 40976                                  	;jmp	SYS_RET_ERR
 40977                                  
 40978                                    ;ENDIF
 40979                                  
 40980                                  ;Break <FIND_DPB - Find a DPB from a drive number>
 40981                                  ;----------------------------------------------------------------------------
 40982                                  ;**	FIND_DPB - Find a DPB from a Drive #
 40983                                  ;
 40984                                  ;	ENTRY	AL has drive number A = 0
 40985                                  ;	EXIT	'C' set
 40986                                  ;		    No DPB for this drive number
 40987                                  ;		'C' clear
 40988                                  ;		    DS:SI points to DPB for drive
 40989                                  ;	USES	SI, DS, Flags
 40990                                  ;----------------------------------------------------------------------------
 40991                                  
 40992                                  	; 21/05/2019 - Retro DOS v4.0
 40993                                  FIND_DPB:
 40994 000073B3 36C536[2600]            	LDS	SI,[SS:DPBHEAD]		;smr;SS Override
 40995                                  fdpb5:	
 40996 000073B8 83FEFF                  	CMP	SI,-1
 40997 000073BB 7409                    	JZ	short fdpb10
 40998 000073BD 3A04                    	cmp	al,[si]
 40999                                  	;CMP	AL,[SI+DPB.DRIVE]
 41000 000073BF 7406                    	jz	short ret_label15	; Carry clear (retz)
 41001                                  	;;lds	si,[si+18h] ; MSDOS 3.3
 41002                                  	;lds	si,[si+19h] ; MSDOS 6.0
 41003 000073C1 C57419                  	LDS	SI,[SI+DPB.NEXT_DPB]
 41004 000073C4 EBF2                    	JMP	short fdpb5
 41005                                  fdpb10:	
 41006 000073C6 F9                      	STC
 41007                                  ret_label15:
 41008 000073C7 C3                      	retn
 41009                                  
 41010                                  ;	Break <InitCDS - set up an empty CDS>
 41011                                  ;----------------------------------------------------------------------------
 41012                                  ;**	InitCDS - Setup an Empty CDS
 41013                                  ;
 41014                                  ;	ENTRY	ThisCDS points to CDS
 41015                                  ;		AL has uppercase drive letter
 41016                                  ;	EXIT	ThisCDS is now empty
 41017                                  ;		(ES:DI) = CDS
 41018                                  ;		'C' set if no DPB associated with drive
 41019                                  ;	USES	AH,ES,DI, Flags
 41020                                  ;----------------------------------------------------------------------------
 41021                                  
 41022                                  ; 21/05/2019 - Retro DOS v4.0
 41023                                  ; DOSCODE:A9FDh (MSDOS 6.21, MSDOS.SYS)
 41024                                  
 41025                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41026                                  ; DOSCODE:A99Dh (MSDOS 5.0, MSDOS.SYS)
 41027                                  
 41028                                  InitCDS:
 41029                                  	; 19/08/2018
 41030                                  	; 05/08/2018 - Retro DOS v3.0
 41031                                  	; MSDOS 6.0
 41032 000073C8 50                      	push	ax			; save (AL) for caller
 41033 000073C9 36C43E[A205]            	LES	DI,[SS:THISCDS]		; (es:di) = CDS address
 41034                                  	;mov	word [es:di+67],0
 41035 000073CE 26C745430000            	MOV	word [ES:DI+curdir.flags],0 ; "free" CDS
 41036 000073D4 2C40                    	SUB	AL,"A"-1                ; A = 1
 41037 000073D6 363806[4600]            	CMP	[SS:NUMIO],AL		;smr;SS Override
 41038 000073DB 7236                    	JC	short icdsx		; Drive does not map a physical drive
 41039 000073DD 48                      	dec	ax			; (AL) = 0 if A, 1 if B, etc.
 41040 000073DE 50                      	PUSH	AX			; save drive number for later
 41041 000073DF 0441                    	add	al,"A"
 41042 000073E1 B43A                    	MOV	AH,':'
 41043 000073E3 268905                  	mov	[ES:DI],ax
 41044                                  	;MOV	[ES:DI+curdir.text],AX 	; set "x:"
 41045                                  	;mov	ax,"\"
 41046                                  	;mov	[es:di+2],ax
 41047                                  	;MOV	word [ES:DI+curdir.text+2],"\"	; NUL terminate
 41048 000073E6 26C745025C00            	mov	word [ES:DI+curdir.text+2],005Ch ; 19/08/2018
 41049                                  	;or	word [es:di+67],4000h
 41050                                  	;or	byte [es:di+68],40h
 41051 000073EC 26804D4440              	OR	byte [ES:DI+curdir.flags+1],(curdir_inuse>>8)
 41052 000073F1 29C0                    	sub	ax,ax
 41053                                  	;MOV	[es:di+73],ax ; 0
 41054 000073F3 26894549                	MOV	[ES:DI+curdir.ID],ax
 41055                                  	;mov	[es:di+75],ax ; 0
 41056 000073F7 2689454B                	MOV	[ES:DI+curdir.ID+2],ax
 41057 000073FB B002                    	mov	al,2
 41058                                  	;mov	[es:di+79],aX ; 2
 41059 000073FD 2689454F                	MOV	[ES:DI+curdir.end],ax
 41060 00007401 58                      	POP	AX			; (al) = drive number
 41061 00007402 1E                      	push	ds
 41062 00007403 56                      	push	si
 41063 00007404 E8ACFF                  	call	FIND_DPB
 41064 00007407 7208                    	JC	short icds5		; OOOOPPPPPSSSS!!!!
 41065                                  	;mov	[es:di+69],si
 41066 00007409 26897545                	MOV	[ES:DI+curdir.devptr],SI
 41067                                  	;mov	[es:di+71],ds
 41068 0000740D 268C5D47                	MOV	[ES:DI+curdir.devptr+2],DS
 41069                                  icds5:	
 41070 00007411 5E                      	pop	si
 41071 00007412 1F                      	pop	ds
 41072                                  icdsx:	
 41073 00007413 58                      	pop	ax
 41074                                  RET45:
 41075 00007414 C3                      	retn
 41076                                  
 41077                                  ;Break <$UserOper - get/set current user ID (for net)>
 41078                                  ;----------------------------------------------------------------------------
 41079                                  ;   $UserOper - retrieve or initiate a user id string.	MSDOS will only
 41080                                  ;	maintain this string and do no verifications.
 41081                                  ;
 41082                                  ;   Inputs:	AL has function type (0-get 1-set 2-printer-set 3-printer-get
 41083                                  ;				      4-printer-set-flags,5-printer-get-flags)
 41084                                  ;		DS:DX is user string pointer (calls 1,2)
 41085                                  ;		ES:DI is user buffer (call 3)
 41086                                  ;		BX is assign index (calls 2,3,4,5)
 41087                                  ;		CX is user number (call 1)
 41088                                  ;		DX is flag word (call 4)
 41089                                  ;   Outputs:	If AL = 0 then the current user string is written to DS:DX
 41090                                  ;			and user CX is set to the user number
 41091                                  ;		If AL = 3 then CX bytes have been put at input ES:DI
 41092                                  ;		If AL = 5 then DX is flag word
 41093                                  ;----------------------------------------------------------------------------
 41094                                  
 41095                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41096                                  	; 21/05/2019 - Retro DOS v4.0
 41097                                  _$UserOper:
 41098                                  	; 05/08/2018 - Retro DOS v3.0
 41099                                  	; MSDOS 6.0 (& MSDOS 3.3)
 41100 00007415 50                      	PUSH	AX
 41101 00007416 2C01                    	SUB	AL,1			; quick dispatch on 0,1
 41102 00007418 58                      	POP	AX
 41103 00007419 7211                    	JB	short UserGet 		; return to user the string
 41104 0000741B 742E                    	JZ	short UserSet 		; set the current user
 41105 0000741D 3C05                    	CMP	AL,5			; test for 2,3,4 or 5
 41106 0000741F 763D                    	JBE	short UserPrint		; yep
 41107                                  	;mov	byte [ss:EXTERR_LOCUS],1
 41108 00007421 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ;smr;SS Override 
 41109                                  					; Extended Error Locus
 41110                                  	;error	error_invalid_function	; not 0,1,2,3
 41111                                  	;mov	al,1
 41112 00007427 B001                    	MOV	AL,error_invalid_function
 41113                                  useroper_error:
 41114                                  	; 17/12/2022
 41115                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41116 00007429 E94E92                  	JMP	SYS_RET_ERR
 41117                                  	;jmp	short ASS_ERR
 41118                                  
 41119                                  UserGet:
 41120                                  ; Transfer MYNAME to DS:DX
 41121                                  ; Set Return CX to MYNUM
 41122 0000742C 1E                      	PUSH	DS			; switch registers
 41123 0000742D 07                      	POP	ES
 41124 0000742E 89D7                    	MOV	DI,DX			; destination
 41125 00007430 368B0E[0E00]            	MOV	CX,[SS:MYNUM]		; Get number	;smr;SS Override
 41126 00007435 E83F90                  	call	Get_User_Stack
 41127                                  	;mov	[si+4],cx
 41128 00007438 894C04                  	MOV	[SI+user_env.user_CX],CX ; Set number return
 41129 0000743B 16                      	push	ss			; point to DOSDATA
 41130 0000743C 1F                      	pop	ds
 41131 0000743D BE[0503]                	MOV	SI,MYNAME		; point source to user string
 41132                                  UserMove:
 41133 00007440 B90F00                  	MOV	CX,15
 41134 00007443 F3A4                    	REP	MOVSB			; blam.
 41135 00007445 31C0                    	XOR	AX,AX			; 16th byte is 0
 41136 00007447 AA                      	STOSB
 41137                                  UserBye:
 41138 00007448 E92592                  	jmp	SYS_RET_OK		; no errors here
 41139                                  
 41140                                  UserSet:
 41141                                  ; Transfer DS:DX to MYNAME
 41142                                  ; CX to MYNUM
 41143 0000744B 36890E[0E00]            	MOV	[SS:MYNUM],CX				;smr;SS Override
 41144 00007450 89D6                    	MOV	SI,DX			; user space has source
 41145 00007452 16                      	push	ss
 41146 00007453 07                      	pop	es
 41147 00007454 BF[0503]                	MOV	DI,MYNAME		; point dest to user string
 41148 00007457 36FE06[0403]            	INC	byte [SS:DIFFNAM]	; signal change ;smr;SS Override
 41149 0000745C EBE2                    	JMP	short UserMove
 41150                                  
 41151                                  UserPrint:
 41152                                  
 41153                                    ;IF NOT Installed
 41154                                    ;	transfer PRINTER_GETSET_STRING
 41155                                    ;ELSE
 41156 0000745E 50                      	PUSH	AX
 41157                                  	;mov	ax,111Fh
 41158                                  	;MOV	AX,(MultNET SHL 8) OR 31
 41159 0000745F B81F11                  	mov	ax,(MultNET<<8)|31
 41160 00007462 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
 41161                                  			; STACK: WORD function
 41162                                  			; Return: CF set on error, AX = error code
 41163                                  			; STACK unchanged
 41164 00007464 5A                      	POP	DX			; Clean stack
 41165                                  	;JNC	short OKPA
 41166 00007465 73E1                    	jnc	short UserBye ; 21/05/2019
 41167                                  	; 17/12/2022
 41168 00007467 EBC0                    	jmp	short useroper_error
 41169                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41170                                  	;jnb     short OKPA
 41171                                  	;jmp     short useroper_error
 41172                                  
 41173                                  	; 17/12/2022
 41174                                  ;OKPA:
 41175                                  ;	jmp	short UserBye
 41176                                  
 41177                                    ;ENDIF
 41178                                  
 41179                                  
 41180                                  ;Break	<GetVisDrv - return visible drive>
 41181                                  ;----------------------------------------------------------------------------
 41182                                  ;   GetVisDrv - correctly map non-spliced inuse drives
 41183                                  ;
 41184                                  ;   Inputs:	AL has drive identifier (0=default)
 41185                                  ;   Outputs:	Carry Set - invalid drive/macro
 41186                                  ;		Carry Clear - AL has physical drive (0=A)
 41187                                  ;		    ThisCDS points to CDS
 41188                                  ;   Registers modified: AL
 41189                                  ;----------------------------------------------------------------------------
 41190                                  
 41191                                  	; 21/05/2019 - Retro DOS v4.0
 41192                                  	; DOSCODE:AA9Fh (MSDOS 6.21, MSDOS.SYS)
 41193                                  
 41194                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41195                                  	; DOSCODE:AA3Fh (MSDOS 5.0, MSDOS.SYS)	
 41196                                  GetVisDrv:
 41197                                  	; 05/08/2018 - Retro DOS v3.0
 41198                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6839h
 41199 00007469 E81900                  	CALL	GETTHISDRV		; get inuse drive
 41200 0000746C 72A6                    	jc	short RET45
 41201 0000746E 1E                      	push	ds
 41202 0000746F 56                      	push	si
 41203 00007470 36C536[A205]            	LDS	SI,[SS:THISCDS]		;smr;SS Override
 41204                                  	;test	word [si+67],2000h
 41205                                  	; 17/12/2022
 41206                                  	;test	byte [si+68],20h
 41207 00007475 F6444420                	test	byte [SI+curdir.flags+1],(curdir_splice>>8)
 41208                                  	;TEST	word [SI+curdir.flags],curdir_splice
 41209 00007479 5E                      	pop	si
 41210 0000747A 1F                      	pop	ds
 41211 0000747B 7497                    	jz	short RET45		; if not spliced, return OK
 41212                                  	; MSDOS 6.0
 41213                                  	;mov	byte [ss:DrvErr],0Fh
 41214 0000747D 36C606[1006]0F          	MOV	byte [SS:DrvErr],error_invalid_drive ;IFS. ;AN000;smr;SS Override
 41215 00007483 F9                      	STC				; signal error
 41216 00007484 C3                      	retn
 41217                                  
 41218                                  ;Break <Getthisdrv - map a drive designator (0=def, 1=A...)>
 41219                                  ;----------------------------------------------------------------------------
 41220                                  ;   GetThisDrv - look through a set of macros and return the current drive and
 41221                                  ;	macro pointer
 41222                                  ;
 41223                                  ;   Inputs:	AL has drive identifier (1=A, 0=default)
 41224                                  ;   Outputs:
 41225                                  ;		Carry Set - invalid drive/macro
 41226                                  ;		Carry Clear - AL has physical drive (0=A)
 41227                                  ;		   ThisCDS points to macro
 41228                                  ;   Registers modified: AL
 41229                                  ;----------------------------------------------------------------------------
 41230                                  
 41231                                  	; 21/05/2019 - Retro DOS v4.0
 41232                                  	; DOSCODE:AABCh (MSDOS 6.21, MSDOS.SYS)
 41233                                  
 41234                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41235                                  	; DOSCODE:AA5Ch (MSDOS 5.0, MSDOS.SYS)	
 41236                                  GETTHISDRV:
 41237                                  	; 05/08/2018
 41238                                  	; 12/07/2018 - Retro DOS v3.0
 41239                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6850h
 41240                                  	; MSDOS 3.3 (& MSDOS 6.0)
 41241 00007485 08C0                    	OR	AL,AL			; are we using default drive?
 41242 00007487 7505                    	JNZ	SHORT GTD10		; no, go get the CDS pointers
 41243 00007489 36A0[3603]              	MOV	AL,[SS:CURDRV]		; get the current drive
 41244                                  	;INC	ax			; Counteract next instruction
 41245                                  	; 04/09/2018
 41246                                  	;inc	al
 41247                                  	; 07/12/2022
 41248 0000748D 40                      	inc	ax
 41249                                  GTD10:	
 41250                                  	;DEC	AX
 41251                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41252 0000748E 48                      	dec	ax			; 0 = A
 41253                                  	;dec	al
 41254 0000748F 1E                      	PUSH	DS			; save world
 41255 00007490 56                      	PUSH	SI
 41256                                  	;mov	byte [ss:EXTERR_LOCUS],2
 41257 00007491 36C606[2303]02          	MOV	BYTE [SS:EXTERR_LOCUS],errLOC_Disk		;smr;SS Override
 41258 00007497 36F606[7205]FF          	TEST	BYTE [SS:FSHARING],-1	; Logical or Physical?	;smr;SS Override
 41259 0000749D 7420                    	JZ	SHORT GTD20		; Logical
 41260 0000749F 50                      	PUSH	AX
 41261 000074A0 06                      	PUSH	ES
 41262 000074A1 57                      	PUSH	DI
 41263 000074A2 36C706[A205][F304]      	MOV	WORD [SS:THISCDS],DUMMYCDS ;smr;SS Override
 41264                                  	;mov	[SS:THISCDS+2],CS ; MSDOS 3.3
 41265 000074A9 368C16[A405]            	MOV	[SS:THISCDS+2],SS ; MSDOS 6.0 ;ThisCDS = &DummyCDS;smr;
 41266 000074AE 0441                    	ADD	AL,'A'
 41267 000074B0 E815FF                  	CALL	InitCDS			; InitCDS(c);
 41268                                  	;test	word [es:di+67],4000h
 41269                                  	; 17/12/2022
 41270                                  	;test	byte [es:di+68],40h
 41271 000074B3 26F6454440              	test	byte [ES:DI+curdir.flags+1],(curdir_inuse>>8)
 41272                                  	;TEST	WORD [ES:DI+curdir.flags],curdir_inuse	; Clears carry
 41273 000074B8 5F                      	POP	DI
 41274 000074B9 07                      	POP	ES
 41275 000074BA 58                      	POP	AX
 41276 000074BB 740D                    	JZ	SHORT GTD30		; Not a physical drive.
 41277 000074BD EB18                    	JMP	SHORT GTDX		; carry clear
 41278                                  GTD20:
 41279 000074BF E81800                  	CALL	GetCDSFromDrv
 41280 000074C2 7206                    	JC	SHORT GTD30	; Unassigned CDS -> return error already set
 41281                                  	;test	word [si+43h],4000h
 41282                                  	; 17/12/2022
 41283                                  	;test	byte [si+44h],40h
 41284 000074C4 F6444440                	test	byte [SI+curdir.flags+1],(curdir_inuse>>8)
 41285                                  	;TEST	WORD [SI+curdir.flags],curdir_inuse ; Clears Carry
 41286 000074C8 750D                    	JNZ	SHORT GTDX		; carry clear
 41287                                  GTD30:	
 41288                                  	; 21/05/2019
 41289                                  	; MSDOS 6.0
 41290 000074CA B00F                    	MOV	AL,error_invalid_drive	; invalid FAT drive
 41291 000074CC 36A2[1006]              	MOV	BYTE [ss:DrvErr],AL	; save this for IOCTL
 41292                                  	; MSDOS 3.3 (.& MSDOS 6.0)
 41293 000074D0 36C606[2303]01          	MOV	BYTE [ss:EXTERR_LOCUS],errLOC_Unk
 41294 000074D6 F9                      	STC
 41295                                  GTDX:	
 41296 000074D7 5E                      	POP	SI			; restore world
 41297 000074D8 1F                      	POP	DS
 41298 000074D9 C3                      	RETN
 41299                                   
 41300                                  
 41301                                  ;Break <GetCDSFromDrv - convert a drive number to a CDS pointer>
 41302                                  ;----------------------------------------------------------------------------
 41303                                  ;   GetCDSFromDrv - given a physical drive number, convert it to a CDS
 41304                                  ;	pointer, returning an error if the drive number is greater than the
 41305                                  ;	number of CDS's
 41306                                  ;
 41307                                  ;   Inputs:	AL is physical unit # A=0...
 41308                                  ;   Outputs:	Carry Set if Bad Drive
 41309                                  ;		Carry Clear
 41310                                  ;		    DS:SI -> CDS
 41311                                  ;		    [THISCDS] = DS:SI
 41312                                  ;   Registers modified: DS,SI
 41313                                  ;----------------------------------------------------------------------------
 41314                                  
 41315                                  	; 21/05/2019 - Retro DOS v4.0
 41316                                  GetCDSFromDrv:
 41317 000074DA 363A06[4700]            	CMP	AL,[SS:CDSCOUNT]	; is this a valid designator;smr;SS Override
 41318                                  	;JB	SHORT GetCDS	; cf=1	; yes, go get the macro
 41319                                  	;STC				; signal error
 41320                                  	;RETN				; bye
 41321                                  	; 23/09/2023
 41322 000074DF F5                      	cmc	; cf=1 <-> cf=0
 41323 000074E0 7217                    	jc	short GetCDS_retn
 41324                                  GetCDS:
 41325                                  	; 23/09/2023
 41326                                  	;PUSH	BX
 41327 000074E2 50                      	PUSH	AX
 41328 000074E3 36C536[3C00]            	LDS	SI,[SS:CDSADDR]		; get pointer to table	;smr;SS Override
 41329                                  	;mov	bl,81 ; MSDOS 3.3
 41330                                  	;mov	bl,88 ; MSDOS 6.0 
 41331                                  	; 23/09/2023
 41332                                  	;MOV	BL,curdir.size		; size in convenient spot
 41333                                  	;MUL	BL			; get net offset
 41334 000074E8 B458                    	mov	ah,curdir.size
 41335 000074EA F6E4                    	mul	ah
 41336 000074EC 01C6                    	ADD	SI,AX ; *		; convert to true pointer
 41337 000074EE 368936[A205]            	MOV	[SS:THISCDS],SI		; store convenient offset;smr;SS Override
 41338 000074F3 368C1E[A405]            	MOV	[SS:THISCDS+2],DS	; store convenient segment;smr;SS Override
 41339 000074F8 58                      	POP	AX
 41340                                  	; 23/09/2023
 41341                                  	;POP	BX
 41342                                  	; (cf must be 0 here) ; *
 41343                                  	;CLC				; no error
 41344                                  GetCDS_retn:
 41345 000074F9 C3                      	RETN				; bye!
 41346                                  
 41347                                  ;============================================================================
 41348                                  ; MACRO2.ASM, MSDOS 6.0, 1991
 41349                                  ;============================================================================
 41350                                  ; Retro	DOS v3.0 - 12/07/2018
 41351                                  ; 22/05/2019 - Retro DOS v4.0
 41352                                  
 41353                                  ;BREAK <TransFCB - convert an FCB into a path, doing substitution>
 41354                                  ;----------------------------------------------------------------------------
 41355                                  ;   TransFCB - Copy an FCB from DS:DX into a reserved area doing all of the
 41356                                  ;       gritty substitution.
 41357                                  ;
 41358                                  ;   Inputs:     DS:DX - pointer to FCB
 41359                                  ;               ES:DI - point to destination
 41360                                  ;   Outputs:    Carry Set - invalid path in final map
 41361                                  ;               Carry Clear - FCB has been mapped into ES:DI
 41362                                  ;                   Sattrib is set from possibly extended FCB
 41363                                  ;                   ExtFCB set if extended FCB found
 41364                                  ;   Registers modified: most
 41365                                  ;----------------------------------------------------------------------------
 41366                                  
 41367                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41368                                  TransFCB:
 41369                                  	; 22/05/2019 - Retro DOS v4.0
 41370                                  	; 12/07/2018 - Retro DOS v3.0
 41371                                  	;LocalVar FCBTmp,16
 41372                                  	;ENTER
 41373 000074FA 55                      	push	bp
 41374 000074FB 89E5                    	mov	bp,sp
 41375                                  	;sub	sp,15	; MSDOS 3.3
 41376 000074FD 83EC10                  	sub	sp,16	; MSDOS 6.0
 41377 00007500 16                      	push	ss
 41378 00007501 07                      	pop	es
 41379 00007502 06                      	push	es
 41380 00007503 57                      	push	di
 41381                                  	;lea	di,[bp-15] ; MSDOS 3.3
 41382                                  	;LEA	DI,FCBTmp 
 41383 00007504 8D7EF0                  	lea	di,[bp-16]		; point to FCB temp area
 41384 00007507 36C606[6C05]00          	mov	byte [SS:EXTFCB],0	; no extended FCB found ;smr;SS Override
 41385 0000750D 36C606[6D05]00          	mov	byte [SS:SATTRIB],0	; default search attributes;smr;SS Override
 41386 00007513 E85FAD                  	call	GetExtended             ; get FCB, extended or not
 41387                                  	; 06/12/2022
 41388 00007516 740D                    	jz	short GetDrive		; not an extended FCB, get drive
 41389 00007518 8A44FF                  	mov	AL,[SI-1]               ; get attributes
 41390 0000751B 36A2[6D05]              	mov	[SS:SATTRIB],AL		; store search attributes;smr;SS Override
 41391 0000751F 36C606[6C05]FF          	mov	byte [SS:EXTFCB],-1	; signal extended FCB  ;smr;SS Override
 41392                                  GetDrive:
 41393 00007525 AC                      	lodsb				; get drive byte
 41394 00007526 E85CFF                  	call	GETTHISDRV
 41395 00007529 722A                    	jc	short BadPack
 41396 0000752B E87303                  	call	TextFromDrive           ; convert 0-based drive to text
 41397                                  
 41398                                  ; Scan the source to see if there are any illegal chars
 41399                                  
 41400                                  	;mov	bx,CharType		; load lookup table
 41401 0000752E B90B00                  	mov	cx,11
 41402 00007531 56                      	push	si			; back over name, ext
 41403                                  FCBScan:
 41404 00007532 AC                      	lodsb				; get a byte
 41405                                  	
 41406                                  	; 09/08/2018
 41407                                  	;;xlat	byte [es:bx]
 41408                                  	;es	xlat
 41409                                  
 41410                                  	; 22/05/2019 - Retro DOS v4.0	
 41411 00007533 E8FCE4                  	call	GetCharType		; get flags
 41412                                  
 41413                                  	;test	al,8	
 41414 00007536 A808                    	test	al,FFCB
 41415 00007538 741B                    	jz	short BadPack
 41416                                  NextCh: 
 41417 0000753A E2F6                    	loop	FCBScan
 41418 0000753C 5E                      	pop	si
 41419 0000753D 89FB                    	mov	bx,di
 41420 0000753F E891B1                  	call	PackName                ; crunch the path
 41421 00007542 5F                      	pop	di			; get original destination
 41422 00007543 07                      	pop	es
 41423 00007544 16                      	push	ss			; get DS addressability
 41424 00007545 1F                      	pop	ds
 41425                                  	;lea	si,[bp-15] ; MSDOS 3.3
 41426                                  	;LEA	SI,FCBTmp		; point at new pathname
 41427 00007546 8D76F0                  	lea	si,[bp-16]
 41428 00007549 803F00                  	cmp	byte [bx],0
 41429 0000754C 7407                    	jz	short BadPack
 41430 0000754E 55                      	push	bp
 41431 0000754F E80E00                  	call	TransPathSet            ; convert the path
 41432 00007552 5D                      	pop	bp
 41433 00007553 7303                    	jnc	short FCBRet		; bye with transPath error code
 41434                                  BadPack:
 41435 00007555 F9                      	STC
 41436                                  	;mov	al,3
 41437 00007556 B003                    	MOV     AL,error_path_not_found
 41438                                  FCBRet: 
 41439                                  	;LEAVE
 41440 00007558 89EC                    	mov	sp,bp
 41441 0000755A 5D                      	pop	bp
 41442                                  TransPath_retn:
 41443 0000755B C3                      	retn
 41444                                  
 41445                                  ; 12/07/2018 - Retro DOS v3.0
 41446                                  
 41447                                  ;BREAK <TransPath - copy a path, do string sub and put in current dir>
 41448                                  ;----------------------------------------------------------------------------
 41449                                  ;
 41450                                  ;   TransPath - copy a path from DS:SI to ES:DI, performing component string
 41451                                  ;       substitution, insertion of current directory and fixing . and ..
 41452                                  ;       entries. Perform splicing. Allow input string to match splice
 41453                                  ;       exactly.
 41454                                  ;
 41455                                  ;   TransPathSet - Same as above except No splicing is performed if input path
 41456                                  ;       matches splice.
 41457                                  ;
 41458                                  ;   TransPathNoSet - No splicing/local using is performed at all.
 41459                                  ;
 41460                                  ;   The following anomalous behaviour is required:
 41461                                  ;
 41462                                  ;       Drive letters on devices are ignored. (set up DummyCDS)
 41463                                  ;       Paths on devices are ignored. (truncate to 0-length)
 41464                                  ;       Raw net I/O sets ThisCDS => NULL.
 41465                                  ;       fSharing => dummyCDS and no subst/splice. Only canonicalize.
 41466                                  ;
 41467                                  ;   Other behaviour:
 41468                                  ;
 41469                                  ;       ThisCDS set up.
 41470                                  ;       FatRead done on local CDS.
 41471                                  ;       ValidateCDS done on local CDS.
 41472                                  ;
 41473                                  ;   Brief flowchart:
 41474                                  ;
 41475                                  ;       if fSharing then
 41476                                  ;           set up DummyCDS (ThisCDS)
 41477                                  ;           canonicalize (sets cMeta)
 41478                                  ;           splice
 41479                                  ;           fatRead
 41480                                  ;           return
 41481                                  ;       if \\ or d:\\ lead then
 41482                                  ;           set up null CDS (ThisCDS)
 41483                                  ;           canonicalize (sets cMeta)
 41484                                  ;           return
 41485                                  ;       if device then
 41486                                  ;           set up dummyCDS (ThisCDS)
 41487                                  ;           canonicalize (sets cMeta)
 41488                                  ;           return
 41489                                  ;       if file then
 41490                                  ;           getCDS (sets (ThisCDS) from name)
 41491                                  ;           validateCDS (may reset current dir)
 41492                                  ;           Copy current dir
 41493                                  ;           canonicalize (set cMeta)
 41494                                  ;           splice
 41495                                  ;           generate correct CDS (ThisCDS)
 41496                                  ;           if local then
 41497                                  ;               fatread
 41498                                  ;           return
 41499                                  ;
 41500                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 41501                                  ;               DI - point to buffer in DOSDATA
 41502                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 41503                                  ;                   syntax, etc. or user FAILed to I 24.
 41504                                  ;               WFP_Start - points to beginning of buffer
 41505                                  ;               Curr_Dir_End - points to end of current dir in path
 41506                                  ;               DS - DOSDATA
 41507                                  ;   Registers modified: most
 41508                                  ;
 41509                                  ;----------------------------------------------------------------------------
 41510                                  
 41511                                  ; 22/05/2019
 41512                                  ; 13/05/2019 - Retro DOS v4.0
 41513                                  ; DOSCODE:AB99h (MSDOS 6.21, MSDOS.SYS)
 41514                                  
 41515                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41516                                  ; DOSCODE:AB39h (MSDOS 5.0, MSDOS.SYS)
 41517                                  
 41518                                  TransPath:
 41519 0000755C 30C0                    	XOR     AL,AL
 41520 0000755E EB02                    	JMP     SHORT SetSplice
 41521                                  TransPathSet:
 41522 00007560 B0FF                    	MOV     AL,-1
 41523                                  SetSplice:
 41524 00007562 36A2[4C03]              	MOV	[SS:NoSetDir],AL	;   NoSetDir = !fExact; ;smr;SS Override
 41525 00007566 B0FF                    	MOV     AL,-1
 41526                                  TransPathNoSet:
 41527 00007568 36A2[7105]              	MOV	[SS:FSPLICE],AL		;   fSplice = TRUE;     ;smr;SS Override
 41528 0000756C 36C606[7A05]FF          	MOV	byte [ss:CMETA],-1      			;smr;SS Override
 41529 00007572 36893E[B205]            	MOV     [SS:WFP_START],DI 				;smr;SS Override
 41530 00007577 36C706[B605]FFFF        	MOV	word [SS:CURR_DIR_END],-1 ; crack from start	;smr;SS Override
 41531 0000757E 16                      	push	ss
 41532 0000757F 07                      	pop	es
 41533                                  	;lea	bp,[di+134]
 41534 00007580 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; end of buffer
 41535                                  ;
 41536                                  ; if this is through the server dos call, fsharing is set. We set up a
 41537                                  ; dummy cds and let the operation go.
 41538                                  ;
 41539 00007584 36F606[7205]FF          	TEST	byte [SS:FSHARING],-1	; if no sharing		;smr;SS Override
 41540 0000758A 7435                    	JZ	short CheckUNC		; skip to UNC check
 41541                                  ;
 41542                                  ; ES:DI point to buffer
 41543                                  ;
 41544 0000758C E8FC02                  	CALL	DriveFromText           ; get drive and advance DS:SI
 41545 0000758F E8F3FE                  	call	GETTHISDRV              ; Set ThisCDS and convert to 0-based
 41546 00007592 722A                    	jc	short NoPath
 41547 00007594 E80A03                  	CALL	TextFromDrive		; drop in new
 41548 00007597 8D5D01                  	LEA	BX,[DI+1]               ; backup limit
 41549 0000759A E83401                  	CALL	Canonicalize            ; copy and canonicalize
 41550 0000759D 72BC                    	jc	short TransPath_retn	; errors
 41551                                  ;
 41552                                  ; Perform splices for net guys.
 41553                                  ;
 41554 0000759F 16                      	push	ss
 41555 000075A0 1F                      	pop	ds
 41556 000075A1 8B36[B205]              	MOV     SI,[WFP_START] 		; point to name
 41557 000075A5 F606[7105]FF            	TEST	byte [FSPLICE],-1
 41558 000075AA 7403                    	JZ	short NoServerSplice
 41559 000075AC E83102                  	CALL    Splice
 41560                                  NoServerSplice:
 41561 000075AF 16                      	push	ss
 41562 000075B0 1F                      	pop	ds                      ; for FATREAD
 41563 000075B1 C43E[A205]              	LES     DI,[THISCDS]		; for fatread
 41564 000075B5 E84BA3                  	call	ECritDisk
 41565 000075B8 E8CEEA                  	call	FATREAD_CDS
 41566 000075BB E872A3                  	call	LCritDisk
 41567                                  NoPath:
 41568                                  	;mov	al,3
 41569 000075BE B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 41570 000075C0 C3                      	retn				; any errors are in Carry flag
 41571                                  
 41572                                  ; Let the network decide if the name is for a spooled device. It will map
 41573                                  ; the name if so.
 41574                                  
 41575                                  CheckUNC:
 41576 000075C1 36C706[A205]FFFF        	MOV     WORD [SS:THISCDS],-1	; NULL thisCDS		;smr;SS Override
 41577                                  	;CallInstall NetSpoolCheck,MultNET,35
 41578 000075C8 B82311                  	mov	ax,1123h
 41579 000075CB CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
 41580                                  			; DS:SI -> ASCIZ filename to canonicalize
 41581                                  			; ES:DI -> 128-byte buffer for qualified name
 41582                                  			; Return: CF set if not resolved
 41583 000075CD 7329                    	JNC	short UNCDone
 41584                                  
 41585                                  ; At this point the name is either a UNC-style name (prefixed with two leading
 41586                                  ; \\s) or is a local file/device. Remember that if a net-spooled device was
 41587                                  ; input, then the name has been changed to the remote spooler by the above net
 41588                                  ; call. Also, there may be a drive in front of the \\.
 41589                                  
 41590                                  NO_CHECK:
 41591 000075CF E8B902                  	CALL    DriveFromText		; eat drive letter
 41592 000075D2 50                      	PUSH    AX                      ; save it
 41593 000075D3 8B04                    	MOV     AX,[SI]			; get first two bytes of path
 41594 000075D5 E877E4                  	call    PATHCHRCMP              ; convert to normal form
 41595 000075D8 86E0                    	XCHG    AH,AL                   ; swap for second byte
 41596 000075DA E872E4                  	call    PATHCHRCMP              ; convert to normal form
 41597 000075DD 751F                    	JNZ	short CheckDevice	; not a path char
 41598 000075DF 38C4                    	CMP     AH,AL                   ; are they same?
 41599 000075E1 751B                    	JNZ	short CheckDevice	; nope
 41600                                  
 41601                                  ; We have a UNC request. We must copy the string up to the beginning of the
 41602                                  ; local machine root path
 41603                                  
 41604 000075E3 58                      	POP     AX
 41605 000075E4 A5                      	MOVSW                           ; get the lead \\.
 41606                                  UNCCpy:
 41607 000075E5 AC                      	LODSB                           ; get a byte
 41608 000075E6 E811E4                   	call	UCase                   ;AN000;; convert the char
 41609 000075E9 08C0                    	OR      AL,AL
 41610 000075EB 740E                    	JZ	short UNCTerm		; end of string. All done.
 41611 000075ED E85FE4                  	call    PATHCHRCMP              ; is it a path char?
 41612 000075F0 89FB                    	MOV     BX,DI                   ; backup position
 41613 000075F2 AA                      	STOSB
 41614 000075F3 75F0                    	JNZ	short UNCCpy		; no, go copy
 41615 000075F5 E8D900                  	CALL    Canonicalize            ; wham (and set cMeta)
 41616                                  UNCDone:
 41617 000075F8 16                      	push	ss
 41618 000075F9 1F                      	pop	ds
 41619 000075FA C3                       	retn				; return error code
 41620                                  UNCTerm:
 41621 000075FB AA                      	STOSB                           ;AN000;
 41622 000075FC EBFA                    	JMP	short UNCDone		;AN000;
 41623                                  
 41624                                  CheckDevice:
 41625                                  
 41626                                  ; Check DS:SI for device. First eat any path stuff
 41627                                  
 41628 000075FE 58                      	POP     AX                      ; retrieve drive info
 41629 000075FF 803C00                  	CMP     BYTE [SI],0		; check for null file
 41630 00007602 7504                    	JNZ	short CheckPath
 41631                                  	;mov	al,2 
 41632 00007604 B002                    	MOV     AL,error_file_not_found ; bad file error
 41633 00007606 F9                      	STC                             ; signal error on null input
 41634 00007607 C3                      	RETN				; bye!
 41635                                  CheckPath:
 41636 00007608 50                      	push	ax
 41637 00007609 55                      	push	bp			; save drive number
 41638                                  
 41639                                  
 41640                                  ; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41641                                  %if 0
 41642                                  	; MSDOS 6.0
 41643                                  ;;;BUGBUG BUG 10-26-1992 scottq
 41644                                  ;;;This is a hack for the CDROM extensions (2.1) who scan looking
 41645                                  ;;;for the following POP BP == 5Dh (restore <bp,ax>).
 41646                                  ;;;The problem is that a direct call to CheckThisDevice can (and did)
 41647                                  ;;;end up having a 5D in the opcode's displacement field. The
 41648                                  ;;;scanning code would choke on this thinking it was a POP BP instruction.
 41649                                  ;;;
 41650                                  ;;;What we do here is do a call to a function that is less than 5Dh
 41651                                  ;;;bytes away (and assert its not exactly 5D away) that jmps (transfers)
 41652                                  ;;;to the correct function. This cannot accidently insert a 5Dh.
 41653                                  ;;;
 41654                                  ;;;More info:
 41655                                  ;;;  This particular scan is begun at the UNCdone label for 32 bytes
 41656                                  ;;;looking for pop BP, so you cannot put a 5D between here and there.
 41657                                  ;;;
 41658                                  	call	no5Dshere
 41659                                  start5Dhack:
 41660                                  ;following is replaced with 5Dhack code--Invoke CheckThisDevice
 41661                                  backfrom5Dhack:
 41662                                  
 41663                                  %endif
 41664                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41665                                  	; Note: 'call no5Dshere' is not required for MSDOS 5.0 MSDOS.SYS
 41666 0000760A E8C4D6                  	call    CheckThisDevice	; E8h,6Fh,0D6h
 41667                                  
 41668 0000760D 5D                      	pop	bp
 41669 0000760E 58                      	pop	ax			; get drive letter back
 41670 0000760F 731C                    	JNC	short DoFile		; yes we have a file.
 41671                                  
 41672                                  ; We have a device. AX has drive letter. At this point we may fake a CDS ala
 41673                                  ; sharing DOS call. We know by getting here that we are NOT in a sharing DOS
 41674                                  ; call.
 41675                                  
 41676 00007611 36C606[7205]FF          	MOV	byte [SS:FSHARING],-1	; simulate sharing dos call;smr;SS Override
 41677 00007617 E86BFE                  	call	GETTHISDRV              ; set ThisCDS and init DUMMYCDS
 41678 0000761A 36C606[7205]00          	MOV     byte [SS:FSHARING],0	;                       ;smr;SS Override
 41679                                  
 41680                                  ; Now that we have noted that we have a device, we put it into a form that
 41681                                  ; getpath can understand. Normally getpath requires d:\ to begin the input
 41682                                  ; string. We relax this to state that if the d:\ is present then the path
 41683                                  ; may be a file. If D:/ (note the forward slash) is present then we have
 41684                                  ; a device.
 41685                                  
 41686 00007620 E87E02                  	CALL    TextFromDrive
 41687 00007623 B02F                    	MOV     AL,'/'                  ; path sep.
 41688 00007625 AA                      	STOSB
 41689 00007626 E8A0A1                  	call	StrCpy			; move remainder of string
 41690                                  
 41691 00007629 F8                      	CLC                             ; everything OK.
 41692 0000762A 16                      	push	ss
 41693 0000762B 1F                      	pop	ds                      ; remainder of OK stuff
 41694                                  DoFile_retn:
 41695 0000762C C3                      	retn
 41696                                  
 41697                                  ; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41698                                  %if 0
 41699                                  
 41700                                  no5Dshere:
 41701                                  	; 10/08/2018
 41702                                  	jmp	CheckThisDevice		; snoop for device
 41703                                  %endif
 41704                                  
 41705                                  ;.erre (no5Dshere - start5Dhack - 5D)
 41706                                  
 41707                                  ; We have a file. Get the raw CDS.
 41708                                  
 41709                                  DoFile:
 41710                                  	; MSDOS 3.3 (& MSDOS 6.0)
 41711                                  
 41712 0000762D E839FE                  	call	GetVisDrv               ; get proper CDS
 41713                                  	;mov	al,3 
 41714 00007630 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad file error
 41715 00007632 72F8                    	jc	short DoFile_retn  ; CARRY set -> bogus drive/spliced
 41716                                  
 41717                                  ; ThisCDS has correct CDS. DS:SI advanced to point to beginning of path/file.
 41718                                  ; Make sure that CDS has valid directory; ValidateCDS requires a temp buffer
 41719                                  ; Use the one that we are going to use (ES:DI).
 41720                                  
 41721                                  	;SAVE    <DS,SI,ES,DI>		; save all string pointers.
 41722 00007634 1E                      	push	ds
 41723 00007635 56                      	push	si
 41724 00007636 06                      	push	es
 41725 00007637 57                      	push	di
 41726 00007638 E8DAD5                  	call	ValidateCDS             ; poke CDS and make everything OK
 41727                                  	;RESTORE <DI,ES,SI,DS>		; get back pointers
 41728 0000763B 5F                      	pop	di
 41729 0000763C 07                      	pop	es
 41730 0000763D 5E                      	pop	si
 41731 0000763E 1F                      	pop	ds
 41732                                  	;mov	al,3
 41733 0000763F B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 41734                                  	;retc				; someone failed an operation
 41735 00007641 72E9                    	jc	short DoFile_retn
 41736                                  
 41737                                  ; ThisCDS points to correct CDS. It contains the correct text of the
 41738                                  ; current directory. Copy it in.
 41739                                  
 41740 00007643 1E                      	push	ds
 41741 00007644 56                      	push	si
 41742 00007645 36C536[A205]            	LDS     SI,[SS:THISCDS]		; point to CDS	;smr;SS Override
 41743 0000764A 89FB                    	MOV     BX,DI                   ; point to destination
 41744                                  	;add	bx,[si+79] ; MSDOS 6.0
 41745 0000764C 035C4F                  	ADD     BX,[SI+curdir.end]	; point to backup limit
 41746                                  	;lea	bp,[di+134]
 41747 0000764F 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; regenerate end of buffer
 41748                                  					;AN000;
 41749 00007653 E882A1                  	call	FStrCpy                 ; copy string. ES:DI point to end
 41750 00007656 4F                      	DEC     DI                      ; point to NUL byte
 41751                                  
 41752                                  ; Make sure that there is a path char at end.
 41753                                  
 41754 00007657 B05C                    	MOV     AL,'\'
 41755 00007659 263845FF                	CMP     [ES:DI-1],AL
 41756 0000765D 7401                    	JZ	short GetOrig
 41757 0000765F AA                      	STOSB
 41758                                  
 41759                                  ; Now get original string.
 41760                                  
 41761                                  GetOrig:
 41762 00007660 4F                      	DEC     DI                      ; point to path char
 41763 00007661 5E                      	pop	si
 41764 00007662 1F                      	pop	ds
 41765                                  
 41766                                  ; BX points to the end of the root part of the CDS (at where a path char
 41767                                  ; should be). Now, we decide whether we use this root or extend it with the
 41768                                  ; current directory. See if the input string begins with a leading 
 41770 00007663 E8D000                  	CALL    PathSep                 ; is DS:SI a path sep?
 41771 00007666 7511                    	JNZ	short PathAssure	; no, DI is correct. Assure a path char
 41772 00007668 08C0                    	OR      AL,AL                   ; end of string?
 41773 0000766A 7410                    	JZ	short DoCanon		; yes, skip.
 41774                                  ;
 41775                                  ; The string does begin with a \. Reset the beginning of the canonicalization
 41776                                  ; to this root. Make sure that there is a path char there and advance the
 41777                                  ; source string over all leading \'s.
 41778                                  ;
 41779 0000766C 89DF                    	MOV     DI,BX                   ; back up to root point.
 41780                                  SkipPath:
 41781 0000766E AC                      	LODSB
 41782 0000766F E8DDE3                  	call    PATHCHRCMP
 41783 00007672 74FA                    	JZ	short SkipPath
 41784 00007674 4E                      	DEC     SI
 41785 00007675 08C0                    	OR      AL,AL
 41786 00007677 7403                    	JZ	short DoCanon
 41787                                  
 41788                                  ; DS:SI start at some file name. ES:DI points at some path char. Drop one in
 41789                                  ; for yucks.
 41790                                  
 41791                                  PathAssure:
 41792 00007679 B05C                    	MOV     AL,'\'	; 5Ch
 41793 0000767B AA                      	STOSB
 41794                                  
 41795                                  ; ES:DI point to the correct spot for canonicalization to begin.
 41796                                  ; BP is the max extent to advance DI
 41797                                  ; BX is the backup limit for ..
 41798                                  
 41799                                  DoCanon:
 41800 0000767C E85200                  	CALL    Canonicalize            ; wham.
 41801                                  	;retc				; badly formatted path.
 41802 0000767F 72AB                    	jc	short DoFile_retn
 41803                                  
 41804                                  ; The string has been moved to ES:DI. Reset world to DOS context, pointers
 41805                                  ; to wfp_start and do string substitution. BP is still the max position in
 41806                                  ; buffer.
 41807                                  
 41808 00007681 16                      	push	ss
 41809 00007682 1F                      	pop	ds
 41810 00007683 8B3E[B205]              	MOV     DI,[WFP_START]		; DS:SI point to string
 41811 00007687 C536[A205]              	LDS     SI,[THISCDS]		; point to CDS
 41812 0000768B E81B02                  	CALL    PathPref                ; is there a prefix?
 41813 0000768E 7514                    	JNZ	short DoSplice		; no, do splice
 41814                                  
 41815                                  ; We have a match. Check to see if we ended in a path char.
 41816                                  
 41817 00007690 8A44FF                  	MOV     AL,[SI-1]		; last char to match
 41818 00007693 E8B9E3                  	call    PATHCHRCMP              ; did we end on a path char? (root)
 41819 00007696 740C                    	JZ	short DoSplice		; yes, no current dir here.
 41820                                  Pathline:                               ; 2/13/KK
 41821 00007698 26803D00                	CMP     BYTE [ES:DI],0		; end at NUL?
 41822 0000769C 7406                    	JZ	short DoSplice
 41823 0000769E 47                      	INC     DI                      ; point to after current path char
 41824 0000769F 36893E[B605]            	MOV     [SS:CURR_DIR_END],DI	; point to correct spot ;smr;SS Override
 41825                                  
 41826                                  ; Splice the result.
 41827                                  
 41828                                  DoSplice:
 41829 000076A4 16                      	push	ss
 41830 000076A5 1F                      	pop	ds			; back to DOSDATA
 41831 000076A6 8B36[B205]              	MOV     SI,[WFP_START]		; point to beginning of string
 41832 000076AA 31C9                    	XOR     CX,CX
 41833 000076AC F606[7105]FF            	TEST	byte [FSPLICE],-1
 41834 000076B1 7403                    	JZ	short SkipSplice
 41835 000076B3 E82A01                  	CALL    Splice                  ; replaces in place.
 41836                                  SkipSplice:
 41837                                  
 41838                                  ; The final thing is to assure ourselves that a FATREAD is done on the local
 41839                                  ; device.
 41840                                  
 41841 000076B6 16                      	push	ss
 41842 000076B7 1F                      	pop	ds
 41843 000076B8 C43E[A205]              	LES     DI,[THISCDS]		; point to correct drive
 41844                                  	;test	word [es:di+67],8000h
 41845                                  	; 17/12/2022
 41846                                  	;test	byte [es:di+68],80h
 41847 000076BC 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8 ; 04/12/2022
 41848                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet ; 8000h
 41849 000076C1 750D                    	JNZ	short Done		; net, no fatread necessary (retnz)
 41850 000076C3 E30B                    	JCXZ    Done
 41851 000076C5 E83BA2                  	call	ECritDisk
 41852 000076C8 E8BEE9                  	call	FATREAD_CDS
 41853 000076CB E862A2                  	call	LCritDisk
 41854                                  	;mov	al, 3
 41855 000076CE B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 41856                                  Done:   
 41857 000076D0 C3                      	retn                         ; any errors in carry flag.
 41858                                  
 41859                                  ; 13/07/2018
 41860                                  
 41861                                  ;BREAK <Canonicalize - copy a path and remove . and .. entries>
 41862                                  ;----------------------------------------------------------------------------
 41863                                  ;   Canonicalize - copy path removing . and .. entries.
 41864                                  ;
 41865                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 41866                                  ;               ES:DI - point to buffer
 41867                                  ;               BX - backup limit (offset from ES) points to slash
 41868                                  ;               BP - end of buffer
 41869                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 41870                                  ;                   syntax, etc.
 41871                                  ;               Carry Clear -
 41872                                  ;                   DS:DI - advanced to end of string
 41873                                  ;                   ES:DI - advanced to end of canonicalized form after nul
 41874                                  ;   Registers modified: AX CX DX (in addition to those above)
 41875                                  ;----------------------------------------------------------------------------
 41876                                  
 41877                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41878                                  
 41879                                  Canonicalize:
 41880                                  
 41881                                  ; We copy all leading path separators.
 41882                                  
 41883 000076D1 AC                      	LODSB                           ;   while (PathChr (*s))
 41884 000076D2 E87AE3                  	call    PATHCHRCMP
 41885 000076D5 7507                    	JNZ	short CanonDec
 41886 000076D7 39EF                    	CMP     DI,BP                   ;       if (d > dlim)
 41887 000076D9 7319                    	JAE	short CanonBad		;           goto error;
 41888 000076DB AA                      	STOSB
 41889 000076DC EBF3                    	JMP	short Canonicalize	;           *d++ = *s++;
 41890                                  CanonDec:
 41891 000076DE 4E                      	DEC     SI
 41892                                  
 41893                                  ; Main canonicalization loop. We come here with DS:SI pointing to a textual
 41894                                  ; component (no leading path separators) and ES:DI being the destination
 41895                                  ; buffer.
 41896                                  
 41897                                  CanonLoop:
 41898                                  
 41899                                  ; If we are at the end of the source string, then we need to check to see that
 41900                                  ; a potential drive specifier is correctly terminated with a path sep char.
 41901                                  ; Otherwise, do nothing
 41902                                  
 41903 000076DF 31C0                    	XOR     AX,AX
 41904 000076E1 3804                    	CMP     [SI],AL                 ;       if (*s == 0) {
 41905 000076E3 751A                    	JNZ	short DoComponent
 41906 000076E5 26807DFF3A              	CMP     BYTE [ES:DI-1],':'	;           if (d[-1] == ':')
 41907 000076EA 7505                    	JNZ	short DoTerminate
 41908 000076EC B05C                    	MOV     AL,'\'                  ;               *d++ = '\';
 41909 000076EE AA                      	STOSB
 41910 000076EF 88E0                    	MOV     AL,AH
 41911                                  DoTerminate:
 41912 000076F1 AA                      	STOSB                           ;           *d++ = 0;
 41913 000076F2 F8                      	CLC                             ;           return (0);
 41914 000076F3 C3                      	retn
 41915                                  
 41916                                  CanonBad:
 41917 000076F4 E8CB01                  	CALL	ScanPathChar            ; check for path chars in rest of string
 41918                                  	;mov	al,3
 41919 000076F7 B003                    	MOV     AL,error_path_not_found ; Set up for bad path error
 41920 000076F9 7402                    	JZ	short PathEnc		; path character encountered in string
 41921                                  	;mov	al,2
 41922 000076FB B002                    	MOV     AL,error_file_not_found ; Set bad file error
 41923                                  PathEnc:
 41924 000076FD F9                      	STC
 41925                                  CanonBad_retn:
 41926 000076FE C3                      	retn
 41927                                  
 41928                                  ; We have a textual component that we must copy. We uppercase it and truncate
 41929                                  ; it to 8.3
 41930                                  
 41931                                  DoComponent:                            ;           }
 41932 000076FF E85000                  	CALL    CopyComponent		;       if (!CopyComponent (s, d))
 41933 00007702 72FA                    	jc	short CanonBad_retn	;           return (-1);
 41934                                  
 41935                                  ; We special case the . and .. cases.  These will be backed up.
 41936                                  
 41937                                  	;CMP	WORD PTR ES:[DI],'.' + (0 SHL 8)
 41938 00007704 26833D2E                	CMP	WORD [ES:DI],002Eh
 41939 00007708 7408                    	JZ	short Skip1
 41940                                  	;CMP	WORD PTR ES:[DI],'..'
 41941 0000770A 26813D2E2E              	CMP     WORD [ES:DI],2E2Eh
 41942 0000770F 750A                    	JNZ	short CanonNormal
 41943 00007711 4F                      	DEC     DI                      ;           d--;
 41944                                  Skip1:  
 41945 00007712 E82A00                  	CALL    SkipBack                ;           SkipBack ();
 41946                                  	;mov	al,3
 41947 00007715 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 41948 00007717 72E5                    	jc	short CanonBad_retn
 41949 00007719 EB02                    	JMP     short CanonPath         ;           }
 41950                                  
 41951                                  ; We have a normal path. Advance destination pointer over it.
 41952                                  
 41953                                  CanonNormal:                            ;       else
 41954 0000771B 01CF                    	ADD     DI,CX                   ;           d += ct;
 41955                                  
 41956                                  ; We have successfully copied a component. We are now pointing at a path
 41957                                  ; sep char or are pointing at a nul or are pointing at something else.
 41958                                  ; If we point at something else, then we have an error.
 41959                                  
 41960                                  CanonPath:
 41961 0000771D E81600                  	CALL    PathSep
 41962 00007720 75D2                    	JNZ	short CanonBad		; something else...
 41963                                  
 41964                                  ; Copy the first path char we see.
 41965                                  
 41966 00007722 AC                      	LODSB                           ; get the char
 41967 00007723 E829E3                  	call    PATHCHRCMP              ; is it path char?
 41968 00007726 75B6                    	JNZ	short CanonDec		; no, go test for nul
 41969 00007728 39EF                    	CMP     DI,BP                   ; beyond buffer end?
 41970 0000772A 73C8                    	JAE	short CanonBad		; yep, error.
 41971 0000772C AA                      	STOSB                           ; copy the one byte
 41972                                  
 41973                                  ; Skip all remaining path chars
 41974                                  
 41975                                  CanonPathLoop:
 41976 0000772D AC                      	LODSB                           ; get next byte
 41977 0000772E E81EE3                  	call    PATHCHRCMP              ; path char again?
 41978 00007731 74FA                    	JZ	short CanonPathLoop	; yep, grab another
 41979 00007733 4E                      	DEC     SI                      ; back up
 41980 00007734 EBA9                    	JMP	short  CanonLoop	; go copy component
 41981                                  
 41982                                  ;BREAK <PathSep - determine if char is a path separator>
 41983                                  ;----------------------------------------------------------------------------
 41984                                  ;   PathSep - look at DS:SI and see if char is / \ or NUL
 41985                                  ;   Inputs:     DS:SI - point to a char
 41986                                  ;   Outputs:    AL has char from DS:SI (/ => \)
 41987                                  ;               Zero set if AL is / \ or NUL
 41988                                  ;               Zero reset otherwise
 41989                                  ;   Registers modified: AL
 41990                                  ;----------------------------------------------------------------------------
 41991                                  
 41992                                  PathSep:
 41993 00007736 8A04                    	MOV     AL,[SI]                 ; get the character
 41994                                  PathSepGotCh:				; already have character
 41995 00007738 08C0                    	OR      AL,AL                   ; test for zero
 41996 0000773A 74C2                    	jz	short CanonBad_retn	; return if equal to zero (NUL)
 41997                                  	;call	PATHCHRCMP              ; check for path character
 41998                                  	;retn				; and return HIS determination
 41999                                  	; 18/12/2022
 42000 0000773C E910E3                  	jmp	PATHCHRCMP
 42001                                  
 42002                                  
 42003                                  ;BREAK <SkipBack - move backwards to a path separator>
 42004                                  ;----------------------------------------------------------------------------
 42005                                  ;   SkipBack - look at ES:DI and backup until it points to a / ;   Inputs:     ES:DI - point to a char
 42007                                  ;               BX has current directory back up limit (point to a / \)
 42008                                  ;   Outputs:    ES:DI backed up to point to a path char
 42009                                  ;               AL has char from output ES:DI (path sep if carry clear)
 42010                                  ;               Carry set if illegal backup
 42011                                  ;               Carry Clear if ok
 42012                                  ;   Registers modified: DI,AL
 42013                                  ;----------------------------------------------------------------------------
 42014                                  
 42015                                  SkipBack:
 42016 0000773F 39DF                    	CMP     DI,BX                   ;   while (TRUE) {
 42017 00007741 720B                    	JB	short SkipBad		;       if (d < dlim)
 42018 00007743 4F                      	DEC     DI                      ;           goto err;
 42019 00007744 268A05                  	MOV     AL,[ES:DI]		;       if (pathchr (*--d))
 42020 00007747 E805E3                  	call    PATHCHRCMP              ;           break;
 42021 0000774A 75F3                    	JNZ	short SkipBack		;       }
 42022 0000774C F8                      	CLC                             ;   return (0);
 42023 0000774D C3                      	retn				;
 42024                                  SkipBad:                                ;err:
 42025                                  	;mov	al,3
 42026 0000774E B003                    	MOV     AL,error_path_not_found ; bad path error
 42027 00007750 F9                      	STC                             ;   return (-1);
 42028 00007751 C3                      	retn				;
 42029                                  
 42030                                  ;Break <CopyComponent - copy out a file path component>
 42031                                  ;----------------------------------------------------------------------------
 42032                                  ;   CopyComponent - copy a file component from a path string (DS:SI) into ES:DI
 42033                                  ;
 42034                                  ;   Inputs:     DS:SI - source path
 42035                                  ;               ES:DI - destination
 42036                                  ;               ES:BP - end of buffer
 42037                                  ;   Outputs:    Carry Set - too long
 42038                                  ;               Carry Clear - DS:SI moved past component
 42039                                  ;                   CX has length of destination
 42040                                  ;   Registers modified: AX,CX,DX
 42041                                  ;----------------------------------------------------------------------------
 42042                                  
 42043                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42044                                  
 42045                                  CopyComponent:
 42046                                  
 42047                                  %define CopyBP	 [BP]		; word
 42048                                  %define CopyD	 [BP+2]		; dword
 42049                                  %define CopyDoff [BP+2]		; word
 42050                                  %define CopyS	 [BP+6]		; dword
 42051                                  %define CopySoff [BP+6]		; word
 42052                                  %define CopyTemp [BP+10]	; byte
 42053                                  
 42054 00007752 83EC0E                  	SUB     SP,14                   ; room for temp buffer
 42055 00007755 1E                      	push	ds
 42056 00007756 56                      	push	si
 42057 00007757 06                      	push	es
 42058 00007758 57                      	push	di
 42059 00007759 55                      	push	bp
 42060 0000775A 89E5                    	MOV     BP,SP
 42061 0000775C B42E                    	MOV     AH,'.'
 42062 0000775E AC                      	LODSB
 42063 0000775F AA                      	STOSB
 42064 00007760 38E0                    	CMP     AL,AH                   ;   if ((*d++=*s++) == '.') {
 42065 00007762 7518                    	JNZ	short NormalComp
 42066 00007764 E8CFFF                  	CALL    PathSep                 ;       if (!pathsep(*s))
 42067 00007767 740B                    	JZ	short NulTerm
 42068                                  TryTwoDot:
 42069 00007769 AC                      	LODSB                           ;           if ((*d++=*s++) != '.'
 42070 0000776A AA                      	STOSB
 42071 0000776B 38E0                    	CMP     AL,AH
 42072 0000776D 7557                    	JNZ	short CopyBad
 42073 0000776F E8C4FF                  	CALL    PathSep
 42074 00007772 7552                    	JNZ	short CopyBad		;               || !pathsep (*s))
 42075                                  NulTerm:                                ;               return -1;
 42076 00007774 30C0                    	XOR     AL,AL                   ;       *d++ = 0;
 42077 00007776 AA                      	STOSB
 42078 00007777 897606                  	MOV     CopySoff,SI
 42079 0000777A EB47                    	JMP     SHORT _GoodRet		;       }
 42080                                  NormalComp:                             ;   else {
 42081 0000777C 8B7606                  	MOV     SI,CopySoff ; [bp+6]
 42082 0000777F E80BE2                  	call	NameTrans               ;       s = NameTrans (s, Name1);
 42083 00007782 3B7606                  	CMP     SI,CopySoff             ;       if (s == CopySOff)
 42084 00007785 743F                    	JZ	short CopyBad		;           return (-1);
 42085 00007787 36F606[7205]FF          	TEST	byte [SS:FSHARING],-1	;       if (!fSharing) {;smr;SS Override
 42086 0000778D 7510                    	JNZ	short DoPack
 42087 0000778F 80E201                  	AND     DL,1                    ;           cMeta += fMeta;
 42088 00007792 360016[7A05]            	ADD	[ss:CMETA],DL		;           if (cMeta > 0);smr;SS Override
 42089 00007797 7F2D                    	JG	short CopyBad		;               return (-1);
 42090 00007799 7504                    	JNZ	short DoPack		;           else
 42091 0000779B 08D2                    	OR      DL,DL                   ;           if (cMeta == 0 && fMeta == 0)
 42092 0000779D 742F                    	JZ	short CopyBadPath	;               return (-1);
 42093                                  DoPack:                                 ;           }
 42094 0000779F 897606                  	MOV     CopySoff,SI ; [bp+6]
 42095 000077A2 16                      	push	ss
 42096 000077A3 1F                      	pop	ds
 42097 000077A4 BE[4B05]                	MOV     SI,NAME1
 42098 000077A7 8D7E0A                  	LEA     DI,CopyTemp ; [bp+10]
 42099 000077AA 57                      	push	di
 42100 000077AB E825AF                  	call	PackName                ;       PackName (Name1, temp);
 42101 000077AE 5F                      	pop	di
 42102 000077AF E82FA0                  	call	StrLen                  ;       if (strlen(temp)+d > bp)
 42103 000077B2 49                      	DEC     CX
 42104 000077B3 034E02                  	ADD     CX,CopyDoff ; [bp+2]
 42105                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42106                                  	;cmp	cx,[bp+0]
 42107                                  	; 15/12/2022
 42108                                  	;cmp	cx,[bp]
 42109 000077B6 3B4E00                  	CMP	CX,CopyBP   ; [bp+0]
 42110 000077B9 730B                    	JAE	short CopyBad		;           return (-1);
 42111 000077BB 89FE                    	MOV     SI,DI                   ;       strcpy (d, temp);
 42112 000077BD C47E02                  	LES     DI,CopyD    ; [bp+2]	
 42113 000077C0 E815A0                  	call	FStrCpy
 42114                                  _GoodRet:				;       }
 42115 000077C3 F8                      	CLC
 42116 000077C4 EB0B                    	JMP     SHORT CopyEnd           ;   return 0;
 42117                                  CopyBad:
 42118 000077C6 F9                      	STC
 42119 000077C7 E8F800                  	CALL    ScanPathChar            ; check for path chars in rest of string
 42120                                  	;mov	al,2
 42121 000077CA B002                    	MOV     AL,error_file_not_found ; Set up for bad file error
 42122 000077CC 7503                    	JNZ	short CopyEnd
 42123                                  CopyBadPath:
 42124 000077CE F9                      	STC
 42125                                  	;mov	al,3
 42126 000077CF B003                    	MOV     AL,error_path_not_found ; Set bad path error
 42127                                  CopyEnd:
 42128 000077D1 5D                      	pop	bp
 42129 000077D2 5F                      	pop	di
 42130 000077D3 07                      	pop	es
 42131 000077D4 5E                      	pop	si
 42132 000077D5 1F                      	pop	ds
 42133 000077D6 9F                      	LAHF
 42134 000077D7 83C40E                  	ADD     SP,14                   ; reclaim temp buffer
 42135 000077DA E804A0                  	call	StrLen
 42136 000077DD 49                      	DEC     CX
 42137 000077DE 9E                      	SAHF
 42138 000077DF C3                      	retn
 42139                                  
 42140                                  ; 14/05/2019 - Retro DOS v4.0
 42141                                  ; DOSCODE:AE22h (MSDOS 6.21, MSDOS.SYS)
 42142                                  
 42143                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42144                                  ; DOSCODE:ADBFh (MSDOS 5.0, MSDOS.SYS)
 42145                                  
 42146                                  ;Break <Splice - pseudo mount by string substitution>
 42147                                  ;----------------------------------------------------------------------------
 42148                                  ;   Splice - take a string and substitute a prefix if one exists. Change
 42149                                  ;       ThisCDS to point to physical drive CDS.
 42150                                  ;   Inputs:     DS:SI point to string
 42151                                  ;               NoSetDir = TRUE => exact matches with splice fail
 42152                                  ;   Outputs:    DS:SI points to thisCDS
 42153                                  ;               ES:DI points to DPB
 42154                                  ;               String at DS:SI may be reduced in length by removing prefix
 42155                                  ;               and substituting drive letter.
 42156                                  ;               CX = 0 If no splice done
 42157                                  ;               CX <> 0 otherwise
 42158                                  ;               ThisCDS points to proper CDS if spliced, otherwise it is
 42159                                  ;                   left alone
 42160                                  ;               ThisDPB points to proper DPB
 42161                                  ;   Registers modified: DS:SI, ES:DI, BX,AX,CX
 42162                                  ;----------------------------------------------------------------------------
 42163                                  
 42164                                  Splice:
 42165 000077E0 36F606[5A00]FF          	TEST	byte [SS:SPLICES],-1	;smr;SS Override
 42166 000077E6 7469                    	JZ	short AllDone
 42167 000077E8 36FF36[A205]            	push	word [SS:THISCDS]
 42168 000077ED 36FF36[A405]            	push	word [SS:THISCDS+2]	; TmpCDS = ThisCDS;smr;SS Override
 42169 000077F2 1E                      	push	ds
 42170 000077F3 56                      	push	si
 42171 000077F4 5F                      	pop	di
 42172 000077F5 07                      	pop	es
 42173 000077F6 31C0                    	XOR     AX,AX                   ;   for (i=1; s = GetCDSFromDrv (i); i++)
 42174                                  SpliceScan:
 42175 000077F8 E8DFFC                  	call	GetCDSFromDrv
 42176 000077FB 724A                    	JC	short SpliceDone
 42177 000077FD FEC0                    	INC     AL
 42178                                  	; 17/12/2022
 42179                                  	;test	byte [si+68],20h
 42180 000077FF F6444420                	test	byte [si+curdir.flags+1],curdir_splice>>8 ; 04/12/2022
 42181                                  	;;test	word [si+67],2000h
 42182                                  	;TEST	word [SI+curdir.flags],curdir_splice
 42183 00007803 74F3                    	JZ	short SpliceScan 	;       if ( Spliced (i) ) {
 42184 00007805 57                      	push	di
 42185 00007806 E8A000                  	CALL    PathPref                ;           if (!PathPref (s, d))
 42186 00007809 7403                    	JZ	short SpliceFound	;
 42187                                  SpliceSkip:
 42188 0000780B 5F                      	pop	di
 42189 0000780C EBEA                    	JMP	short SpliceScan	;               continue;
 42190                                  SpliceFound:
 42191 0000780E 26803D00                	CMP     BYTE [ES:DI],0		;           if (*s || NoSetDir) {
 42192 00007812 7508                    	JNZ	short SpliceDo
 42193 00007814 36F606[4C03]FF          	TEST	byte [ss:NoSetDir],-1			;smr;SS Override
 42194 0000781A 75EF                    	JNZ	short SpliceSkip
 42195                                  SpliceDo:
 42196 0000781C 89FE                    	MOV     SI,DI                   ;               p = src + strlen (p);
 42197 0000781E 06                      	push	es
 42198 0000781F 1F                      	pop	ds
 42199 00007820 5F                      	pop	di
 42200 00007821 E87F00                  	CALL	TextFromDrive1          ;               src = TextFromDrive1(src,i);
 42201 00007824 36A1[B605]              	MOV     AX,[SS:CURR_DIR_END]			;smr;SS Override
 42202 00007828 09C0                    	OR      AX,AX
 42203 0000782A 7808                    	JS	short NoPoke
 42204 0000782C 01F8                    	ADD     AX,DI                   ;               curdirend += src-p;
 42205 0000782E 29F0                    	SUB     AX,SI
 42206 00007830 36A3[B605]              	MOV     [SS:CURR_DIR_END],AX			;smr;SS Override
 42207                                  NoPoke:
 42208 00007834 803C00                  	CMP     BYTE [SI],0		;               if (*p)
 42209 00007837 7503                    	JNZ	short SpliceCopy	;                   *src++ = '\\';
 42210 00007839 B05C                    	MOV     AL,"\"
 42211 0000783B AA                      	STOSB
 42212                                  SpliceCopy:                             ;               strcpy (src, p);
 42213 0000783C E8999F                  	call	FStrCpy
 42214 0000783F 83C404                  	ADD     SP,4                    ; throw away saved stuff
 42215 00007842 80C901                  	OR      CL,1                    ; signal splice done.
 42216 00007845 EB0C                    	JMP     SHORT DoSet             ;               return;
 42217                                  SpliceDone:                             ;               }
 42218 00007847 368F06[A405]            	pop	word [SS:THISCDS+2]     ;   ThisCDS = TmpCDS;
 42219 0000784C 368F06[A205]            	pop	word [SS:THISCDS]			;smr;SS Override
 42220                                  AllDone:
 42221 00007851 31C9                    	XOR     CX,CX
 42222                                  DoSet:
 42223 00007853 36C536[A205]            	LDS     SI,[SS:THISCDS]		;   ThisDPB = ThisCDS->devptr;;smr;SS Override
 42224                                  	;les	di,[si+69]
 42225 00007858 C47C45                  	LES     DI,[SI+curdir.devptr]	
 42226 0000785B 36893E[8A05]            	MOV	[SS:THISDPB],DI				;smr;SS Override
 42227 00007860 368C06[8C05]            	MOV	[SS:THISDPB+2],ES			;smr;SS Override
 42228                                  Splice_retn:
 42229 00007865 C3                      	retn
 42230                                  
 42231                                  ; 15/05/2019 - Retro DOS v4.0
 42232                                  ; DOSCODE:AEA9h (MSDOS 6.21, MSDOS.SYS)
 42233                                  
 42234                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42235                                  ; DOSCODE:AE46h (MSDOS 5.0, MSDOS.SYS)
 42236                                  
 42237                                  ;Break <$NameTrans - partially process a name>
 42238                                  ;----------------------------------------------------------------------------
 42239                                  ;   $NameTrans - allow users to see what names get mapped to. This call
 42240                                  ;   performs only string substitution and canonicalization, not splicing.  Due
 42241                                  ;   to Transpath playing games with devices, we need to insure that the output
 42242                                  ;   has drive letter and : in it.
 42243                                  ;
 42244                                  ;   Inputs:     DS:SI - source string for translation
 42245                                  ;               ES:DI - pointer to buffer
 42246                                  ;   Outputs:
 42247                                  ;       Carry Clear
 42248                                  ;               Buffer at ES:DI is filled in with data
 42249                                  ;               ES:DI point byte after nul byte at end of dest string in buffer
 42250                                  ;       Carry Set
 42251                                  ;               AX = error_path_not_found
 42252                                  ;   Registers modified: all
 42253                                  ;----------------------------------------------------------------------------
 42254                                  
 42255                                  _$NameTrans:
 42256 00007866 1E                      	push	ds
 42257 00007867 56                      	push	si
 42258 00007868 06                      	push	es
 42259 00007869 57                      	push	di
 42260 0000786A 51                      	push	cx ; MSDOS 6.0
 42261                                  	
 42262                                  	; MSDOS 6.0	
 42263                                  ; M027 - Start
 42264                                  ;
 42265                                  ; Sattrib must be set up with default values here. Otherwise, the value from
 42266                                  ; a previous DOS call is used for attrib and DevName thinks it is not a 
 42267                                  ; device if the old call set the volume attribute bit. Note that devname in
 42268                                  ; dir2.asm gets ultimately called by Transpath. See also M026. Also save
 42269                                  ; and restore CX.
 42270                                  
 42271                                  	;mov	ch,16h
 42272 0000786B B516                    	mov     ch,attr_hidden+attr_system+attr_directory
 42273 0000786D E8B902                  	call	SetAttrib
 42274                                  
 42275                                  ; M027 - End
 42276                                  
 42277                                  	; MSDOS 3.3 (& MSDOS 6.0)
 42278 00007870 BF[BE03]                	MOV     DI,OPENBUF
 42279 00007873 E8E6FC                  	CALL    TransPath               ; to translation (everything)
 42280 00007876 59                      	pop	cx ; MSDOS 6.0
 42281 00007877 5F                      	pop     di
 42282 00007878 07                      	pop	es
 42283 00007879 5E                      	pop     si
 42284 0000787A 1F                      	pop     ds
 42285 0000787B 7303                    	JNC	short TransOK
 42286 0000787D E9FA8D                  	jmp	SYS_RET_ERR
 42287                                  TransOK:
 42288 00007880 BE[BE03]                	MOV     SI,OPENBUF
 42289 00007883 16                      	push	ss
 42290 00007884 1F                      	pop	ds
 42291                                  ;GotText:
 42292 00007885 E8509F                  	call	FStrCpy
 42293 00007888 E9E58D                  	jmp	SYS_RET_OK
 42294                                  
 42295                                  ;Break   <DriveFromText - return drive number from a text string>
 42296                                  ;----------------------------------------------------------------------------
 42297                                  ;   DriveFromText - examine DS:SI and remove a drive letter, advancing the
 42298                                  ;   pointer.
 42299                                  ;
 42300                                  ;   Inputs:     DS:SI point to a text string
 42301                                  ;   Outputs:    AL has drive number
 42302                                  ;               DS:SI advanced
 42303                                  ;   Registers modified: AX,SI.
 42304                                  ;----------------------------------------------------------------------------
 42305                                  
 42306                                  DriveFromText:
 42307 0000788B 30C0                    	XOR     AL,AL                   ;       drive = 0;
 42308                                  	;CMP	BYTE [SI],0		;       if (*s &&
 42309                                  	; 23/09/2023
 42310 0000788D 3804                    	cmp	[si],al ; 0
 42311 0000788F 74D4                    	jz	short Splice_retn
 42312 00007891 807C013A                	CMP     BYTE [SI+1],':'		;           s[1] == ':') {
 42313 00007895 75CE                    	jnz	short Splice_retn
 42314 00007897 AD                      	LODSW                           ;           drive = (*s | 020) - 'a'+1;
 42315 00007898 0C20                    	OR      AL,20h
 42316                                  	;sub	al,60h
 42317 0000789A 2C60                    	SUB     AL,'a'-1                ;           s += 2;
 42318 0000789C 75C7                    	jnz	short Splice_retn
 42319 0000789E B0FF                    	MOV	AL,-1                   ; nuke AL...
 42320                                  	; 23/09/2023
 42321                                  	;dec	al ; -1
 42322 000078A0 C3                      	retn				;           }
 42323                                  
 42324                                  ;Break   <TextFromDrive - convert a drive number to a text string>
 42325                                  ;----------------------------------------------------------------------------
 42326                                  ;   TextFromDrive - turn AL into a drive letter: and put it at es:di with
 42327                                  ;   trailing :. TextFromDrive1 takes a 1-based number.
 42328                                  ;
 42329                                  ;   Inputs:     AL has 0-based drive number
 42330                                  ;   Outputs:    ES:DI advanced
 42331                                  ;   Registers modified: AX
 42332                                  ;----------------------------------------------------------------------------
 42333                                  
 42334                                  TextFromDrive:
 42335 000078A1 FEC0                    	INC     AL
 42336                                  TextFromDrive1:
 42337                                  	;add	al,40h
 42338 000078A3 0440                    	ADD     AL,'A'-1                ;   *d++ = drive-1+'A';
 42339 000078A5 B43A                    	MOV     AH,":"	; 3Ah           ;   strcat (d, ":");
 42340 000078A7 AB                      	STOSW
 42341                                  PathPref_retn:
 42342 000078A8 C3                      	retn
 42343                                  
 42344                                  ;Break   <PathPref - see if one path is a prefix of another>
 42345                                  ;----------------------------------------------------------------------------
 42346                                  ;   PathPref - compare DS:SI with ES:DI to see if one is the prefix of the
 42347                                  ;   other.  Remember that only at a pathchar break are we allowed to have a
 42348                                  ;   prefix: A:\ and A:\FOO
 42349                                  ;
 42350                                  ;   Inputs:     DS:SI potential prefix
 42351                                  ;               ES:DI string
 42352                                  ;   Outputs:    Zero set => prefix found
 42353                                  ;                   DI/SI advanced past matching part
 42354                                  ;               Zero reset => no prefix, DS/SI garbage
 42355                                  ;   Registers modified: CX
 42356                                  ;----------------------------------------------------------------------------
 42357                                  
 42358                                  PathPref:
 42359 000078A9 E8439F                  	call	DStrLen                 ; get length
 42360 000078AC 49                      	DEC     CX                      ; do not include nul byte
 42361 000078AD F3A6                    	REPZ    CMPSB                   ; compare
 42362 000078AF 75F7                    	jnz	short PathPref_retn	; if NZ then return NZ
 42363 000078B1 50                      	push	ax			; save char register
 42364 000078B2 8A44FF                  	MOV     AL,[SI-1]               ; get last byte to match
 42365 000078B5 E897E1                  	call    PATHCHRCMP              ; is it a path char (Root!)
 42366 000078B8 7406                    	JZ	short Prefix		; yes, match root (I hope)
 42367                                  NotSep:                                 ; 2/13/KK
 42368 000078BA 268A05                  	MOV     AL,[ES:DI]		; get next char to match
 42369 000078BD E878FE                  	CALL    PathSepGotCh            ; was it a pathchar?
 42370                                  Prefix:
 42371 000078C0 58                      	pop	ax			; get back original
 42372 000078C1 C3                      	retn
 42373                                  
 42374                                  ;Break   <ScanPathChar - see if there is a path character in a string>
 42375                                  ;----------------------------------------------------------------------------
 42376                                  ;     ScanPathChar - search through the string (pointed to by DS:SI) for
 42377                                  ;     a path separator.
 42378                                  ;
 42379                                  ;     Input:    DS:SI target string (null terminated)
 42380                                  ;     Output:   Zero set => path separator encountered in string
 42381                                  ;               Zero clear => null encountered
 42382                                  ;     Registers modified: SI
 42383                                  ;----------------------------------------------------------------------------
 42384                                  
 42385                                  ScanPathChar:
 42386 000078C2 AC                      	LODSB                           ; fetch a character
 42387 000078C3 E872FE                  	call    PathSepGotCh
 42388 000078C6 75FA                    	JNZ	short ScanPathChar	; not \, / or NUL => go back for more
 42389                                  	;call	PATHCHRCMP              ; path separator?
 42390                                  	;retn
 42391                                  	; 18/12/2022
 42392 000078C8 E984E1                  	jmp	PATHCHRCMP
 42393                                  
 42394                                  ;============================================================================
 42395                                  ; FILE.ASM, MSDOS 6.0, 1991
 42396                                  ;============================================================================
 42397                                  ; 14/07/2018 - Retro DOS v3.0
 42398                                  
 42399                                  ; 13/05/2019 - Retro DOS v4.0
 42400                                  ; DOSCODE:AF10h (MSDOS 6.21, MSDOS.SYS)
 42401                                  
 42402                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42403                                  ; DOSCODE:AEADh (MSDOS 5.0, MSDOS.SYS)
 42404                                  
 42405                                  ; MSDOS 2.11
 42406                                  ;BREAK <$Open - open a file handle>
 42407                                  ;----------------------------------------------------------------------------
 42408                                  ;   Assembler usage:
 42409                                  ;           LDS     DX, Name
 42410                                  ;           MOV     AH, Open
 42411                                  ;           MOV     AL, access
 42412                                  ;           INT     int_command
 42413                                  ;
 42414                                  ;       ACCESS          Function
 42415                                  ;       ------          --------
 42416                                  ;       open_for_read   file is opened for reading
 42417                                  ;       open_for_write  file is opened for writing
 42418                                  ;       open_for_both   file is opened for both reading and writing.
 42419                                  ;
 42420                                  ;   Error returns:
 42421                                  ;           AX = error_invalid_access
 42422                                  ;              = error_file_not_found
 42423                                  ;              = error_access_denied
 42424                                  ;              = error_too_many_open_files
 42425                                  ;----------------------------------------------------------------------------
 42426                                  
 42427                                  ; MSDOS 6.0
 42428                                  ;	BREAK <$Open - open a file from a path string>
 42429                                  ;----------------------------------------------------------------------------
 42430                                  ;
 42431                                  ;**	$OPen - Open a File
 42432                                  ;
 42433                                  ;	given a path name in DS:DX and an open mode in AL, $Open opens the
 42434                                  ;	file and and returns a handle
 42435                                  ;
 42436                                  ;	ENTRY	(DS:DX) = pointer to asciz name
 42437                                  ;		(AL) = open mode
 42438                                  ;	EXIT	'C' clear if OK
 42439                                  ;		  (ax) = file handle
 42440                                  ;		'C' set if error
 42441                                  ;		  (ax) = error code
 42442                                  ;	USES	all
 42443                                  ;
 42444                                  ;----------------------------------------------------------------------------
 42445                                  
 42446                                  ; 13/05/2019 - Retro DOS v4.0
 42447                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42448                                  
 42449                                  _$OPEN:       
 42450 000078CB 30E4                    	xor	ah,ah  ; MSDOS 6.0	
 42451                                  _$Open2:
 42452                                  	;mov	ch,16h
 42453 000078CD B516                    	mov	ch,attr_hidden+attr_system+attr_directory
 42454 000078CF E85702                  	call	SetAttrib
 42455 000078D2 B9[2032]                	mov	cx,DOS_OPEN
 42456                                  
 42457                                  	;xor	ah,ah  ; MSDOS 3.3
 42458                                  
 42459 000078D5 50                      	push	ax
 42460                                  
 42461                                  ;*	General file open/create code. The $CREATE call and the various
 42462                                  ;	$OPEN calls all come here.
 42463                                  ;
 42464                                  ;	We'll share a lot of the standard stuff of allocating SFTs, cracking
 42465                                  ;	path names, etc., and then dispatch to our individual handlers.
 42466                                  ;	WARNING - this info and list is just a guess, not definitive - jgl
 42467                                  ;
 42468                                  ;	(TOS) = create mode
 42469                                  ;	(CX) = address of routine to call to do actual function
 42470                                  ;	(DS:DX) = ASCIZ name
 42471                                  ;	SAttrib = Attribute mask
 42472                                  
 42473                                  ;	Get a free SFT and mark it "being allocated"
 42474                                  
 42475                                  AccessFile:
 42476 000078D6 E82AA0                  	call	ECritSFT
 42477 000078D9 E8D8F7                  	call	SFNFree			; get a free sfn
 42478 000078DC E851A0                  	call	LCritSFT
 42479 000078DF 7214                    	jc	short OpenFailJ		; oops, no free sft's
 42480 000078E1 36891E[AA05]            	MOV	[SS:SFN],BX		; save the SFN for later;smr;SS Override
 42481 000078E6 36893E[9E05]            	MOV	[SS:THISSFT],DI		; save the SF offset	;smr;SS Override
 42482 000078EB 368C06[A005]            	MOV	[SS:THISSFT+2],ES	; save the SF segment	;smr;SS Override
 42483                                  
 42484                                  ;	Find a free area in the user's JFN table.
 42485                                  
 42486 000078F0 E8AEF7                  	call	JFNFree			; get a free jfn
 42487 000078F3 7303                    	jnc	short SaveJFN
 42488                                  OpenFailJ:
 42489 000078F5 E99300                  	JMP	OpenFail		; there were free JFNs... try SFN
 42490                                  
 42491                                  SaveJFN:
 42492 000078F8 36893E[AE05]            	mov	[ss:PJFN],DI		; save the jfn offset	;smr;SS Override
 42493 000078FD 368C06[B005]            	MOV	[ss:PJFN+2],ES		; save the jfn segment	;smr;SS Override
 42494 00007902 36891E[AC05]            	MOV	[ss:JFN],BX		; save the jfn itself	;smr;SS Override
 42495                                  
 42496                                  ;	We have been given an JFN. We lock it down to prevent other tasks from
 42497                                  ;	reusing the same JFN.
 42498                                  
 42499 00007907 368B1E[AA05]            	MOV	BX,[ss:SFN]					;smr;SS Override
 42500 0000790C 26881D                  	MOV	[ES:DI],BL		; assign the JFN
 42501 0000790F 89D6                    	MOV	SI,DX			; get name in appropriate place
 42502 00007911 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 42503 00007914 51                      	push	cx			; save routine to call
 42504 00007915 E844FC                  	call	TransPath		; convert the path
 42505 00007918 5B                      	pop	bx			; (bx) = routine to call
 42506                                  
 42507 00007919 36C536[9E05]            	LDS	SI,[SS:THISSFT]					;smr;SS Override
 42508 0000791E 720A                    	JC	short OpenCleanJ	; no error, go and open file
 42509 00007920 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1				;smr;SS Override
 42510 00007926 7404                    	JZ	short SetSearch
 42511                                  	;mov	al,2
 42512 00007928 B002                    	MOV	AL,error_file_not_found ; no meta chars allowed
 42513                                  OpenCleanJ:
 42514 0000792A EB50                    	JMP	short OpenClean
 42515                                  
 42516                                  SetSearch:
 42517 0000792C 58                      	pop	ax			; Mode (Open), Attributes (Create)
 42518                                  
 42519                                  ;	We need to get the new inheritance bits.
 42520                                  
 42521 0000792D 31C9                    	xor	cx,cx
 42522                                  	; MSDOS 6.0
 42523                                  	;mov	[si+2],cx ; 0
 42524 0000792F 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],cx ; initialize mode field to 0
 42525                                  	;mov    [si+51],cx ; 0
 42526 00007932 894C33                  	MOV	[SI+SF_ENTRY.sf_MFT],cx	 ; clean out sharing info
 42527                                  	;
 42528 00007935 81FB[2032]              	CMP	BX,DOS_OPEN
 42529 00007939 7509                    	JNZ	short _DoOper
 42530                                  	;test   al,80h
 42531 0000793B A880                    	test	AL,SHARING_NO_INHERIT	; look for no inher
 42532 0000793D 7405                    	JZ	short _DoOper ; 10/08/2018
 42533 0000793F 247F                    	AND	AL,7Fh			; mask off inherit bit
 42534                                  	;mov	cx,1000h
 42535 00007941 B90010                  	MOV	CX,sf_no_inherit
 42536                                  _DoOper:
 42537                                  	;; MSDOS 3.3
 42538                                  	;;mov	word [si+2], 0
 42539                                  	;;mov	word [si+33h], 0
 42540                                  	;MOV	word [SI+SF_ENTRY.sf_mode],0
 42541                                  	;MOV	word [SI+SF_ENTRY.sf_MFT],0
 42542                                  
 42543                                  	; MSDOS 6.0
 42544                                  ;**	Check if this is an extended open. If so you must set the
 42545                                  ;	modes in sf_mode. Call Set_EXT_mode to do all this. See
 42546                                  ;	Set_EXT_mode in creat.asm
 42547                                  
 42548                                  	; MSDOS 6.0
 42549                                  	;SAVE	<di, es>                ;M022 conditional removed here
 42550 00007944 57                      	push	di
 42551 00007945 06                      	push	es
 42552 00007946 1E                      	push	ds
 42553 00007947 07                      	pop	es
 42554 00007948 56                      	push	si
 42555 00007949 5F                      	pop	di			; (es:di) = SFT address
 42556 0000794A E8BFB8                  	call	Set_EXT_mode
 42557                                  	;RESTORE <es, di>
 42558 0000794D 07                      	pop	es
 42559 0000794E 5F                      	pop	di
 42560                                  
 42561                                  	;Context DS
 42562 0000794F 16                      	push	ss
 42563 00007950 1F                      	pop	ds	
 42564                                  
 42565 00007951 51                      	push	cx
 42566 00007952 FFD3                    	CALL	BX			; blam!
 42567 00007954 59                      	pop	cx
 42568 00007955 C536[9E05]              	LDS	SI,[THISSFT]
 42569 00007959 721A                    	JC	short OpenE2		;AN000;FT. chek extended open hooks first
 42570                                  	;jc	short OpenE ; MSDOS 3.3
 42571                                  
 42572                                  ;	The SFT was successfully opened. Remove busy mark.
 42573                                  
 42574                                  OpenOK:
 42575                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],1
 42576 0000795B C7040100                	mov	word [SI],1
 42577                                  	;or	[SI+5],cx
 42578 0000795F 094C05                  	OR	[SI+SF_ENTRY.sf_flags],CX ; set no inherit bit if necessary
 42579                                  
 42580                                  ; If the open mode is 70, we scan the system for other SFT's with the same
 42581                                  ; contents. If we find one, then we can 'collapse' thissft onto the already
 42582                                  ; opened one. Otherwise we use this new one. We compare uid/pid/mode/mft
 42583                                  ;
 42584                                  ; Since this is only relevant on sharer systems, we stick this code into the
 42585                                  ; sharer.
 42586                                  
 42587 00007962 36A1[AC05]              	MOV	AX,[ss:JFN]				;smr;SS Override
 42588 00007966 36FF1E[C000]            	Call	far [ss:JShare+(12*4)]	; 12 = ShCol	;smr;SS Override
 42589                                  
 42590 0000796B 36C706[AA05]FFFF        	MOV	word [ss:SFN],-1	; clear out sfn pointer	;smr;SS Override
 42591                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42592                                  OpenOkj:
 42593 00007972 E9FB8C                  	jmp	SYS_RET_OK		; bye with no errors
 42594                                  
 42595                                  	; MSDOS 6.0
 42596                                  ;Extended Open hooks check
 42597                                  OpenE2:					;AN000;;EO.
 42598 00007975 83F857                  	CMP	AX,error_invalid_parameter ;AN000;;EO. IFS extended open ?
 42599 00007978 7503                    	JNZ	short OpenE		;AN000;;EO. no.
 42600 0000797A EB11                    	JMP	short OpenCritLeave	;AN000;;EO. keep handle
 42601                                  
 42602                                  ;	Extended Open hooks check
 42603                                  ;
 42604                                  ;	AL has error code.  Stack has argument to dos_open/dos_create.
 42605                                  
 42606                                  OpenClean:
 42607 0000797C 5B                      	pop	bx			; clean off stack
 42608                                  OpenE:
 42609                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],0 ; release SFT
 42610 0000797D C7040000                	mov	word [SI],0
 42611 00007981 36C536[AE05]            	LDS	SI,[ss:PJFN]		;smr;SS Override
 42612 00007986 C604FF                  	MOV	BYTE [SI],0FFh		; free the SFN...
 42613 00007989 EB02                    	JMP	SHORT OpenCritLeave
 42614                                  
 42615                                  OpenFail:
 42616 0000798B FB                      	STI
 42617 0000798C 59                      	pop	cx			; Clean stack
 42618                                  OpenCritLeave:
 42619 0000798D 36C706[AA05]FFFF        	MOV	word [SS:SFN],-1	; remove mark.
 42620                                  
 42621                                  	; MSDOS 6.0
 42622                                  ; File Tagging DOS 4.00
 42623 00007994 36833E[2403]25          	CMP	word [SS:EXTERR],error_Code_Page_Mismatched
 42624                                  					;AN000;;FT. code page mismatch
 42625 0000799A 7503                    	JNZ	short NORERR	  	;AN000;;FT. no
 42626 0000799C E9E38C                  	jmp	From_GetSet		;AN000;;FT. yes
 42627                                  NORERR: 				;AN000;
 42628                                  ; File Tagging DOS 4.00
 42629                                  
 42630 0000799F E9D88C                  	jmp	SYS_RET_ERR		; no free, return error
 42631                                  
 42632                                  ; MSDOS 2.11
 42633                                  ;BREAK <$CREAT - creat a new file and open him for input>
 42634                                  ;----------------------------------------------------------------------------
 42635                                  ;   Assembler usage:
 42636                                  ;           LDS     DX, name
 42637                                  ;           MOV     AH, Creat
 42638                                  ;           MOV     CX, access
 42639                                  ;           INT     21h
 42640                                  ;       ; AX now has the handle
 42641                                  ;
 42642                                  ;   Error returns:
 42643                                  ;           AX = error_access_denied
 42644                                  ;              = error_path_not_found
 42645                                  ;              = error_too_many_open_files
 42646                                  ;----------------------------------------------------------------------------
 42647                                  
 42648                                  ; MSDOS 6.0
 42649                                  ;	BREAK <$Creat - create a brand-new file>
 42650                                  ;----------------------------------------------------------------------------
 42651                                  ;
 42652                                  ;**	$Creat - Create a File
 42653                                  ;
 42654                                  ;	$Creat creates the directory entry specified in DS:DX and gives it the
 42655                                  ;	initial attributes contained in CX
 42656                                  ;
 42657                                  ;	ENTRY	(DS:DX) = ASCIZ path name
 42658                                  ;		(CX) = initial attributes
 42659                                  ;	EXIT	'C' set if error
 42660                                  ;		  (ax) = error code
 42661                                  ;		'C' clear if OK
 42662                                  ;		  (ax) = file handle
 42663                                  ;	USES	all
 42664                                  ;
 42665                                  ;----------------------------------------------------------------------------
 42666                                  
 42667                                  _$CREAT:
 42668 000079A2 51                      	push	cx			; Save attributes on stack
 42669 000079A3 B9[EF30]                	mov	CX,DOS_CREATE		; routine to call
 42670                                  AccessSet:
 42671                                  	;mov	byte [ss:SATTRIB],6
 42672 000079A6 36C606[6D05]06          	mov	byte [ss:SATTRIB],attr_hidden+attr_system ;smr;SS Override
 42673                                  	; 10/08/2018
 42674 000079AC E927FF                  	JMP	AccessFile		; use good ol' open
 42675                                  
 42676                                  ; MSDOS 6.0 (MSDOS 3.3)
 42677                                  ;	BREAK <$CHMOD - change file attributes>
 42678                                  ;----------------------------------------------------------------------------
 42679                                  ;
 42680                                  ;**	$CHMOD - Change File Attributes
 42681                                  ;
 42682                                  ;   Assembler usage:
 42683                                  ;	    LDS     DX, name
 42684                                  ;	    MOV     CX, attributes
 42685                                  ;	    MOV     AL,func (0=get, 1=set)
 42686                                  ;	    INT     21h
 42687                                  ;   Error returns:
 42688                                  ;	    AX = error_path_not_found
 42689                                  ;	    AX = error_access_denied
 42690                                  ;
 42691                                  ;----------------------------------------------------------------------------
 42692                                  
 42693                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42694                                  _$CHMOD:
 42695                                  	; 05/08/2018 - Retro DOS v3.0
 42696                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6FCCh ,
 42697 000079AF BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 42698 000079B2 50                      	push	ax
 42699 000079B3 51                      	push	cx			; save function and attributes
 42700 000079B4 89D6                    	MOV	SI,DX			; get things in appropriate places
 42701 000079B6 E8A7FB                  	call	TransPathSet		; get correct path
 42702 000079B9 59                      	pop	cx
 42703 000079BA 58                      	pop	ax			; and get function and attrs back
 42704 000079BB 7257                    	JC	short ChModErr		; errors get mapped to path not found
 42705 000079BD 16                      	push	ss			; set up for later possible calls
 42706 000079BE 1F                      	pop	ds
 42707 000079BF 803E[7A05]FF            	CMP	byte [CMETA],-1
 42708 000079C4 754E                    	JNZ	short ChModErr
 42709                                  	;mov	byte [SATTRIB],16h
 42710 000079C6 C606[6D05]16            	MOV	byte [SATTRIB],attr_hidden+attr_system+attr_directory
 42711 000079CB 2C01                    	SUB	AL,1			; fast way to discriminate
 42712 000079CD 720B                    	JB	short ChModGet		; 0 -> go get value
 42713 000079CF 7417                    	JZ	short ChModSet		; 1 -> go set value
 42714                                  	;mov	byte [EXTERR_LOCUS],1
 42715 000079D1 C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 42716                                  	;mov	al,1
 42717 000079D6 B001                    	mov	al,error_invalid_function ; bad value
 42718                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42719                                  chmod_errj:	
 42720                                  	;;jmp	SYS_RET_ERR
 42721                                  	;jmp	short ChModE	
 42722 000079D8 EBC5                    	jmp	short NORERR	; 06/12/2022
 42723                                  ChModGet:
 42724 000079DA E80BB6                  	call	GET_FILE_INFO		; suck out the ol' info
 42725 000079DD 7237                    	JC	short ChModE		; error codes are already set for ret
 42726 000079DF E8958A                  	call	Get_User_Stack		; point to user saved vaiables
 42727                                  	;mov	[SI+4],ax
 42728 000079E2 894404                  	MOV	[SI+user_env.user_CX],AX ; return the attributes
 42729                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility
 42730                                  OpenOkj2:
 42731                                  	; 17/12/2022
 42732                                  	;;jmp	SYS_RET_OK		; say sayonara
 42733                                  	;jmp	short OpenOkj
 42734                                  	; 25/06/2019
 42735 000079E5 E98B8C                  	jmp	SYS_RET_OK_clc
 42736                                  
 42737                                  ChModSet:
 42738 000079E8 89C8                    	MOV	AX,CX			; get attrs in position
 42739 000079EA E859B6                  	call	SET_FILE_ATTRIBUTE	; go set
 42740 000079ED 7227                    	JC	short ChModE		; errors are set
 42741                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility
 42742                                  	;jmp	SYS_RET_OK
 42743                                  OpenOkj3:
 42744                                  	;jmp	short OpenOkj2
 42745                                  	; 17/12/2022
 42746 000079EF E97E8C                  	jmp	SYS_RET_OK
 42747                                  
 42748                                  ; 17/12/2022
 42749                                  %if 0
 42750                                  ChModErr:
 42751                                  NotFound:	; 17/12/2022
 42752                                  	;mov	al,3
 42753                                  	mov	al,error_path_not_found
 42754                                  ChModE:
 42755                                  UnlinkE:	; 17/12/2022
 42756                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42757                                  	;;jmp	SYS_RET_ERR
 42758                                  	;jmp	short chmod_errj
 42759                                  	; 17/12/2022
 42760                                  	jmp	short NORERR
 42761                                  %endif
 42762                                  
 42763                                  ; 22/05/2019 - Retro DOS v4.0
 42764                                  ; DOSCODE:B039h (MSDOS 6.21, MSDOS.SYS)
 42765                                  
 42766                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42767                                  ; DOSCODE:AFD6h (MSDOS 5.0, MSDOS.SYS)
 42768                                  
 42769                                  ;	BREAK <$UNLINK - delete a file entry>
 42770                                  ;----------------------------------------------------------------------------
 42771                                  ;
 42772                                  ;**	$UNLINK - Delete a File
 42773                                  ;
 42774                                  ;
 42775                                  ;	Assembler usage:
 42776                                  ;	    LDS     DX, name
 42777                                  ;	    IF VIA SERVER DOS CALL
 42778                                  ;	     MOV     CX,SEARCH_ATTRIB
 42779                                  ;	    MOV     AH, Unlink
 42780                                  ;	    INT     21h
 42781                                  ;
 42782                                  ;	ENTRY	(ds:dx) = path name
 42783                                  ;		(cx) = search_attribute, if via server_dos
 42784                                  ;	EXIT	'C' clear if no error
 42785                                  ;		'C' set if error
 42786                                  ;		  (ax) = error code
 42787                                  ;			= error_file_not_found
 42788                                  ;			= error_access_denied
 42789                                  ;
 42790                                  ;----------------------------------------------------------------------------
 42791                                  
 42792                                  _$UNLINK:
 42793 000079F2 51                      	push	cx			; Save possible CX input parm
 42794 000079F3 89D6                    	MOV	SI,DX			; Point at input string
 42795 000079F5 BF[BE03]                	MOV	DI,OPENBUF		; temp spot for path
 42796 000079F8 E865FB                  	call	TransPathSet		; go get normalized path
 42797 000079FB 59                      	pop	cx
 42798 000079FC 7216                    	JC	short ChModErr		; badly formed path
 42799 000079FE 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1	; meta chars?	;smr;SS Override
 42800 00007A04 750E                    	JNZ	short NotFound
 42801 00007A06 16                      	push	ss
 42802 00007A07 1F                      	pop	ds
 42803                                  	;mov	ch,6
 42804 00007A08 B506                    	mov	ch,attr_hidden+attr_system ; unlink appropriate files
 42805 00007A0A E81C01                  	call	SetAttrib
 42806 00007A0D E879B1                  	call	DOS_DELETE		; remove that file
 42807                                  	;JC	short UnlinkE 		; error is there
 42808                                  	; 17/12/2022
 42809 00007A10 728D                    	jc	short NORERR
 42810                                  
 42811                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42812                                  UnlinkOk:
 42813                                  	;jmp	SYS_RET_OK		; okey doksy
 42814 00007A12 EBDB                    	jmp	short OpenOkj3
 42815                                  
 42816                                  	; 17/12/2022
 42817                                  ChModErr:	; 17/12/2022
 42818                                  NotFound:
 42819                                  	;mov	al,3
 42820 00007A14 B003                    	MOV	AL,error_path_not_found
 42821                                  ChModE:		; 17/12/2022
 42822                                  UnlinkE:
 42823                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42824                                  	;;jmp	SYS_RET_ERR		; bye
 42825                                  	;jmp	short ChModE
 42826                                  	; 17/12/2022
 42827 00007A16 EB87                    	jmp	short NORERR
 42828                                  
 42829                                  ;BREAK <$RENAME - move directory entries around>
 42830                                  ;----------------------------------------------------------------------------
 42831                                  ;
 42832                                  ;   Assembler usage:
 42833                                  ;	    LDS     DX, source
 42834                                  ;	    LES     DI, dest
 42835                                  ;	    IF VIA SERVER DOS CALL
 42836                                  ;	      MOV   CX,SEARCH_ATTRIB
 42837                                  ;	    MOV     AH, Rename
 42838                                  ;	    INT     21h
 42839                                  ;
 42840                                  ;   Error returns:
 42841                                  ;	    AX = error_file_not_found
 42842                                  ;	       = error_not_same_device
 42843                                  ;	       = error_access_denied
 42844                                  ;
 42845                                  ;----------------------------------------------------------------------------
 42846                                  
 42847                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42848                                  _$RENAME:
 42849                                  	; MSDOS 3.3 (& MSDOS 6.0)
 42850 00007A18 51                      	push	cx
 42851 00007A19 1E                      	push	ds
 42852 00007A1A 52                      	push	dx			; save source and possible CX arg
 42853 00007A1B 06                      	PUSH	ES
 42854 00007A1C 1F                      	POP	DS			; move dest to source
 42855 00007A1D 89FE                    	MOV	SI,DI			; save for offsets
 42856 00007A1F BF[3E04]                	MOV	DI,RENBUF
 42857 00007A22 E83BFB                  	call	TransPathSet		; munge the paths
 42858 00007A25 36FF36[B205]            	PUSH	word [ss:WFP_START]	; get pointer	;smr;SS Override
 42859 00007A2A 368F06[B405]            	POP	word [ss:REN_WFP]	; stash it	;smr;SS Override
 42860 00007A2F 5E                      	pop	si
 42861 00007A30 1F                      	pop	ds
 42862 00007A31 59                      	pop	cx			; get back source and possible CX arg
 42863                                  epjc2:	
 42864 00007A32 72E0                    	JC	short ChModErr		; get old error
 42865 00007A34 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1			;smr;SS Override
 42866 00007A3A 75D8                    	JNZ	short NotFound
 42867 00007A3C 51                      	push	cx			; Save possible CX arg
 42868 00007A3D BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 42869 00007A40 E81DFB                  	call	TransPathSet		; wham
 42870 00007A43 59                      	pop	cx
 42871 00007A44 72EC                    	JC	short epjc2
 42872 00007A46 16                      	push	ss
 42873 00007A47 1F                      	pop	ds
 42874 00007A48 803E[7A05]FF            	CMP	byte [CMETA],-1
 42875 00007A4D 72C5                    	JB	short NotFound
 42876                                  
 42877                                  	; MSDOS 6.0
 42878 00007A4F FF36[A205]              	PUSH	WORD [THISCDS]		   ;AN000;;MS.save thiscds
 42879 00007A53 FF36[A405]              	PUSH	WORD [THISCDS+2]	   ;AN000;;MS.
 42880 00007A57 BF[BE03]                	MOV	DI,OPENBUF		   ;AN000;;MS.
 42881 00007A5A 16                      	PUSH	SS			   ;AN000;;MS.
 42882 00007A5B 07                      	POP	ES			   ;AN000;;MS.es:di-> source
 42883 00007A5C 30C0                    	XOR	AL,AL			   ;AN000;;MS.scan all CDS
 42884                                  rnloop: 				   ;AN000;
 42885 00007A5E E879FA                  	call	GetCDSFromDrv		   ;AN000;;MS.
 42886 00007A61 7210                    	JC	short dorn		   ;AN000;;MS.	end of CDS
 42887 00007A63 E8419D                  	call	StrCmp			   ;AN000;;MS.	current dir ?
 42888 00007A66 7404                    	JZ	short rnerr		   ;AN000;;MS.	yes
 42889 00007A68 FEC0                    	INC	AL			   ;AN000;;MS.	next
 42890 00007A6A EBF2                    	JMP	short rnloop		   ;AN000;;MS.
 42891                                  rnerr:					   ;AN000;
 42892 00007A6C 83C404                  	ADD	SP,4			   ;AN000;;MS. pop thiscds
 42893                                  	;error	error_current_directory    ;AN000;;MS.
 42894 00007A6F B010                    	mov	al,error_current_directory 
 42895                                  	;jmp	SYS_RET_ERR
 42896                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42897 00007A71 EBA3                    	jmp	short UnlinkE
 42898                                  dorn:					   ;AN000;
 42899 00007A73 368F06[A405]            	POP	WORD [SS:THISCDS+2]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 42900 00007A78 368F06[A205]            	POP	WORD [SS:THISCDS]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 42901                                  
 42902 00007A7D 16                      	push	ss
 42903 00007A7E 1F                      	pop	ds
 42904                                  
 42905                                  	; MSDOS 3.3 (& MSDOS 6.0)
 42906                                  	;mov	ch,16h
 42907 00007A7F B516                    	mov	ch,attr_directory+attr_hidden+attr_system
 42908                                  					; rename appropriate files
 42909 00007A81 E8A500                  	call	SetAttrib
 42910 00007A84 E815B3                  	call	DOS_RENAME		; do the deed
 42911 00007A87 728D                    	JC	short UnlinkE 		; errors
 42912                                  
 42913                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42914                                  	;jmp	SYS_RET_OK
 42915 00007A89 EB87                    	jmp	short UnlinkOk
 42916                                  
 42917                                  
 42918                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42919                                  
 42920                                  ; 14/07/2018 - Retro DOS v3.0
 42921                                  ; MSDOS 3.3 (& MSDOS 6.0)
 42922                                  
 42923                                  ;Break <$CreateNewFile - Create a new directory entry>
 42924                                  ;----------------------------------------------------------------------------
 42925                                  ;   CreateNew - Create a new directory entry.  Return a file handle if there
 42926                                  ;	was no previous directory entry, and fail if a directory entry with
 42927                                  ;	the same name existed previously.
 42928                                  ;
 42929                                  ;   Inputs:	DS:DX point to an ASCIZ file name
 42930                                  ;		CX contains default file attributes
 42931                                  ;   Outputs:	Carry Clear:
 42932                                  ;		    AX has file handle opened for read/write
 42933                                  ;		Carry Set:
 42934                                  ;		    AX has error code
 42935                                  ;   Registers modified: All
 42936                                  ;----------------------------------------------------------------------------
 42937                                  
 42938                                  _$CreateNewFile:
 42939 00007A8B 51                      	push	cx			; Save attributes on stack
 42940 00007A8C B9[B631]                	MOV	CX,DOS_Create_New	; routine to call
 42941 00007A8F E914FF                  	JMP	AccessSet		; use good ol' open
 42942                                  
 42943                                  ;**	BinToAscii - convert a number to a string.
 42944                                  ;----------------------------------------------------------------------------
 42945                                  ;	BinToAscii converts a 16 bit number into a 4 ascii characters.
 42946                                  ;	This routine is used to generate temp file names so we don't spend
 42947                                  ;	the time and code needed for a true hex number, we just use
 42948                                  ;	A thorugh O.
 42949                                  ;
 42950                                  ;	ENTRY	(ax) = value
 42951                                  ;		(es:di) = destination
 42952                                  ;	EXIT	(es:di) updated by 4
 42953                                  ;	USES	cx, di, flags
 42954                                  ;----------------------------------------------------------------------------
 42955                                  
 42956                                  ; MSDOS 3.3
 42957                                  ;BinToAscii:
 42958                                  ;	mov     cx,4
 42959                                  ;bta5:
 42960                                  ;	push    cx
 42961                                  ;	mov     cl,4
 42962                                  ;	rol     ax,cl
 42963                                  ;	push    ax
 42964                                  ;	and     al,0Fh
 42965                                  ;	add     al,'0'
 42966                                  ;	cmp     al,'9'
 42967                                  ;	jbe     short bta6
 42968                                  ;	add     al,7
 42969                                  ;bta6: 
 42970                                  ;	stosb
 42971                                  ;	pop     ax
 42972                                  ;	pop     cx
 42973                                  ;	loop    bta5
 42974                                  ;	retn
 42975                                  
 42976                                  ; MSDOS 6.0
 42977                                  BinToAscii:
 42978 00007A92 B90404                  	mov	cx,404h			; (ch) = digit counter, (cl) = shift cnt
 42979                                  bta5:	
 42980 00007A95 D3C0                    	ROL	AX,CL			; move leftmost nibble into rightmost
 42981 00007A97 50                      	push	ax			; preserve remainder of digits
 42982 00007A98 240F                    	AND	AL,0Fh			; grab low nibble
 42983 00007A9A 0441                    	ADD	AL,'A'			; turn into ascii
 42984 00007A9C AA                      	STOSB				; drop in the character
 42985 00007A9D 58                      	pop	ax			; (ax) = shifted number
 42986 00007A9E FECD                    	dec	ch
 42987 00007AA0 75F3                    	jnz	short bta5		; process 4 digits
 42988 00007AA2 C3                      	retn
 42989                                  
 42990                                  ;Break	<$CreateTempFile - create a unique name>
 42991                                  ;----------------------------------------------------------------------------
 42992                                  ;   $CreateTemp - given a directory, create a unique name in that directory.
 42993                                  ;	Method used is to get the current time, convert to a name and attempt
 42994                                  ;	a create new. Repeat until create new succeeds.
 42995                                  ;
 42996                                  ;   Inputs:	DS:DX point to a null terminated directory name.
 42997                                  ;		CX  contains default attributes
 42998                                  ;   Outputs:	Unique name is appended to DS:DX directory.
 42999                                  ;		AX has handle
 43000                                  ;   Registers modified: all
 43001                                  ;----------------------------------------------------------------------------
 43002                                  
 43003                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43004                                  
 43005                                  _$CreateTempFile:
 43006                                  	;Enter
 43007 00007AA3 55                      	push	bp
 43008 00007AA4 89E5                    	mov	bp,sp
 43009                                  
 43010                                  	;LocalVar  EndPtr,DWORD
 43011                                  	;LocalVar  FilPtr,DWORD
 43012                                  	;LocalVar  Attr,WORD
 43013                                  
 43014 00007AA6 83EC0A                  	sub	sp,10
 43015                                  
 43016                                  	;test	cx,0FFD8h
 43017 00007AA9 F7C1D8FF                	test	CX,~attr_changeable
 43018 00007AAD 7405                    	JZ	short OKatts		; Ok if no non-changeable bits set
 43019                                  
 43020                                  ; We need this "hook" here to detect these cases (like user sets one both of
 43021                                  ; vol_id and dir bits) because of the structure of the or $CreateNewFile loop
 43022                                  ; below. The code loops on error_access_denied, but if one of the non
 43023                                  ; changeable attributes is specified, the loop COULD be infinite or WILL be
 43024                                  ; infinite because CreateNewFile will fail with access_denied always. Thus we
 43025                                  ; need to detect these cases before getting to the loop.
 43026                                  
 43027                                  	;mov	ax, 5
 43028 00007AAF B80500                  	MOV	AX,error_access_denied
 43029 00007AB2 EB69                    	JMP	SHORT SETTMPERR
 43030                                  
 43031                                  OKatts:
 43032                                  	;MOV	attr,CX 		; save attribute
 43033 00007AB4 894EF6                  	mov     [bp-10],cx
 43034                                  	;MOV	FilPtrL,DX		; pointer to file
 43035 00007AB7 8956F8                  	mov	[bp-8],dx
 43036                                  	;MOV	FilPtrH,DS
 43037 00007ABA 8C5EFA                  	mov	[bp-6],ds
 43038                                  	;MOV	EndPtrH,DS		; seg pointer to end of dir
 43039 00007ABD 8C5EFE                  	mov	[bp-2],ds
 43040 00007AC0 1E                      	PUSH	DS
 43041 00007AC1 07                      	POP	ES			; destination for nul search
 43042 00007AC2 89D7                    	MOV	DI,DX
 43043 00007AC4 89F9                    	MOV	CX,DI
 43044 00007AC6 F7D9                    	NEG	CX			; number of bytes remaining in segment
 43045                                  	; MSDOS 6.0
 43046 00007AC8 09C9                    	OR	CX,CX			;AN000;MS. cx=0 ? ds:dx on segment boundary
 43047 00007ACA 7501                    	JNZ	short okok		;AN000;MS. no
 43048                                  	;MOV	CX,-1			;AN000;MS.
 43049                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43050                                  	; 17/12/2022
 43051 00007ACC 49                      	dec	cx  ; mov cx,-1
 43052                                  	;mov	cx,-1 ; 0FFFh
 43053                                  okok:					;AN000;
 43054 00007ACD 31C0                    	XOR	AX,AX			;AN000;
 43055 00007ACF F2AE                    	REPNZ	SCASB			;AN000;
 43056                                  					;AN000;
 43057 00007AD1 4F                      	DEC	DI			; point back to the null
 43058 00007AD2 268A45FF                	MOV	AL,[ES:DI-1]		; Get char before the NUL
 43059 00007AD6 E876DF                  	call	PATHCHRCMP		; Is it a path separator?
 43060 00007AD9 7403                    	JZ	short SETENDPTR		; Yes
 43061                                  STOREPTH:
 43062 00007ADB B05C                    	MOV	AL,'\'
 43063 00007ADD AA                      	STOSB				; Add a path separator (and INC DI)
 43064                                  SETENDPTR:
 43065                                  	;MOV	EndPtrL,DI		; pointer to the tail
 43066 00007ADE 8856FC                  	mov	[bp-4],dl
 43067                                  CreateLoop:
 43068 00007AE1 16                      	push	ss			; let ReadTime see variables
 43069 00007AE2 1F                      	pop	ds
 43070 00007AE3 55                      	push	bp
 43071 00007AE4 E8AF90                  	call	READTIME		; go get time
 43072 00007AE7 5D                      	pop	bp
 43073                                  ;
 43074                                  ; Time is in CX:DX. Go drop it into the string.
 43075                                  ;
 43076                                  	;les	di,EndPtr		; point to the string
 43077 00007AE8 C47EFC                  	les	di,[BP-4]
 43078 00007AEB 89C8                    	mov	ax,cx
 43079 00007AED E8A2FF                  	call	BinToAscii		; store upper word
 43080 00007AF0 89D0                    	mov	ax,dx
 43081 00007AF2 E89DFF                  	call	BinToAscii		; store lower word
 43082 00007AF5 30C0                    	xor	al,al
 43083 00007AF7 AA                      	STOSB				; nul terminate
 43084                                  	;LDS	DX,FilPtr		; get name
 43085 00007AF8 C556F8                  	lds	dx,[bp-8]
 43086                                  	;MOV	CX,Attr 		; get attr
 43087 00007AFB 8B4EF6                  	mov	cx,[bp-10]
 43088 00007AFE 55                      	push	bp
 43089 00007AFF E889FF                  	CALL	_$CreateNewFile		; try to create a new file
 43090 00007B02 5D                      	pop	bp
 43091 00007B03 7319                    	JNC	short CreateDone	; failed, go try again
 43092                                  
 43093                                  ; The operation failed and the error has been mapped in AX. Grab the extended
 43094                                  ; error and figure out what to do.
 43095                                  
 43096                                  	;; MSDOS 3.3			; M049 - start
 43097                                  ;;	mov	ax,[ss:EXTERR]				;smr;SS Override
 43098                                  ;;	cmp	al,error_file_exists
 43099                                  ;;	jz	short CreateLoop	; file existed => try with new name
 43100                                  ;;	cmp	al,error_access_denied
 43101                                  ;;	jz	short CreateLoop	; access denied (attr mismatch)
 43102                                  
 43103                                  	; MSDOS 6.0
 43104                                  	;cmp	al,50h
 43105 00007B05 3C50                    	CMP	AL,error_file_exists	; Q: did file already exist
 43106 00007B07 74D8                    	JZ	short CreateLoop	; Y: try again
 43107                                  	;cmp	al,5
 43108 00007B09 3C05                    	CMP	AL,error_access_denied	; Q: was it access denied
 43109 00007B0B 7510                    	JNZ	short SETTMPERR		; N: Error out
 43110                                  					; Y: Check to see if we got this due
 43111                                  					;    to the network drive. Note that
 43112                                  					;    the redir will set the exterr
 43113                                  					;    to error_cannot_make if this is 
 43114                                  					;    so. 
 43115 00007B0D 36803E[2403]41          	CMP	byte [SS:EXTERR],error_net_access_denied ; M069
 43116                                  					; See if it's REALLY an att mismatch
 43117 00007B13 7408                    	je	short SETTMPERR		; no, network error, stop
 43118                                  ;M070
 43119                                  ; If the user failed on an I24, we do not want to try again
 43120                                  ;
 43121 00007B15 36803E[2403]53          	cmp	byte [SS:EXTERR],error_FAIL_I24 ;User failed on I24? ;M070
 43122                                  	;je	short SETTMPERR		;yes, do not try again ;M070
 43123                                  
 43124                                  	;jmp	short CreateLoop	;attr mismatch, try again ;M070
 43125                                  	; 17/12/2022
 43126 00007B1B 75C4                    	jne	short CreateLoop ; 10/06/2019 
 43127                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43128                                  	;jz	short SETTMPERR
 43129                                  	;jmp	short CreateLoop
 43130                                  
 43131                                  ;;	MOV	AL,error_access_denied	; Return this "extended" error
 43132                                  					; M049 - end
 43133                                  SETTMPERR:
 43134 00007B1D F9                      	STC
 43135                                  CreateDone:
 43136                                  	;Leave
 43137 00007B1E 89EC                    	mov	sp,bp
 43138 00007B20 5D                      	pop	bp
 43139 00007B21 7203                    	JC	short CreateFail
 43140 00007B23 E94A8B                  	jmp	SYS_RET_OK		; success!
 43141                                  CreateFail:
 43142 00007B26 E9518B                  	jmp	SYS_RET_ERR
 43143                                  
 43144                                  ;   SetAttrib will set the search attribute (SAttrib) either to the normal
 43145                                  ;   (CH) or to the value in CL if the current system call is through
 43146                                  ;   serverdoscall.
 43147                                  ;
 43148                                  ;   Inputs:	fSharing == FALSE => set sattrib to CH
 43149                                  ;		fSharing == TRUE => set sattrib to CL
 43150                                  ;   Outputs:	none
 43151                                  ;   Registers changed:	CX
 43152                                  
 43153                                  SetAttrib:
 43154 00007B29 36F606[7205]FF          	test	byte [SS:FSHARING],-1		;smr;SS Override
 43155 00007B2F 7502                    	jnz	short Set
 43156 00007B31 88E9                    	mov	cl,ch
 43157                                  Set:
 43158 00007B33 36880E[6D05]            	mov	byte [ss:SATTRIB],cl		;smr;SS Override
 43159 00007B38 C3                      	retn
 43160                                  
 43161                                  ; 14/07/2018 - Retro DOS v3.0
 43162                                  ; MSDOS 6.0
 43163                                  
 43164                                  ; 29/04/2019 - Retro DOS v4.0
 43165                                  
 43166                                  ;Break	<Extended_Open- Extended open the file>
 43167                                  ;----------------------------------------------------------------------------
 43168                                  ; Input: AL= 0 reserved  AH=6CH
 43169                                  ;	 BX= mode
 43170                                  ;	 CL= create attribute  CH=search attribute (from server)
 43171                                  ;	 DX= flag
 43172                                  ;	 DS:SI = file name
 43173                                  ;	 ES:DI = parm list
 43174                                  ;			   DD  SET EA list (-1) null
 43175                                  ;			   DW  n  parameters
 43176                                  ;			   DB  type (TTTTTTLL)
 43177                                  ;			   DW  IOMODE
 43178                                  ; Function: Extended Open
 43179                                  ; Output: carry clear
 43180                                  ;		     AX= handle
 43181                                  ;		     CX=1 file opened
 43182                                  ;			2 file created/opened
 43183                                  ;			3 file replaced/opened
 43184                                  ;	  carry set: AX has error code
 43185                                  ;----------------------------------------------------------------------------
 43186                                  
 43187                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43188                                  _$Extended_Open:			  ;AN000;
 43189                                  	;ASSUME	CS:DOSCODE,SS:DOSDATA	  ;AN000;
 43190 00007B39 368916[F405]            	MOV	[SS:EXTOPEN_FLAG],DX	  ;AN000;EO. save ext. open flag;smr;SS Override
 43191 00007B3E 36C706[F705]0000        	MOV	word [SS:EXTOPEN_IO_MODE],0 ;AN000;EO. initialize IO mode;smr;SS Override
 43192                                  	; 17/12/2022
 43193 00007B45 F6C6FE                  	test	dh,0FEh ; 04/12/2022 
 43194                                  	;;test	dx,0FE00h
 43195                                  	;TEST	DX,RESERVED_BITS_MASK	  ;AN000;EO. reserved bits 0  ?
 43196 00007B48 7545                    	JNZ	short ext_inval2	  ;AN000;EO. no
 43197 00007B4A 88D4                    	MOV	AH,DL			  ;AN000;EO. make sure flag is right
 43198 00007B4C 80FA00                  	CMP	DL,0			  ;AN000;EO. all fail ?
 43199 00007B4F 743E                    	JZ	short ext_inval2	  ;AN000;EO. yes, error
 43200                                  	;and	dl,0Fh
 43201 00007B51 80E20F                  	AND	DL,EXISTS_MASK		  ;AN000;EO. get exists action byte
 43202 00007B54 80FA02                  	CMP	DL,2			  ;AN000;EO, > 02
 43203 00007B57 7736                    	JA	short ext_inval2	  ;AN000;EO. yes ,error
 43204                                  	;and	ah,0F0h
 43205 00007B59 80E4F0                  	AND	AH,NOT_EXISTS_MASK	  ;AN000;EO. get no exists action byte
 43206 00007B5C 80FC10                  	CMP	AH,10H			  ;AN000;EO. > 10
 43207 00007B5F 772E                    	JA	short ext_inval2	  ;AN000;EO. yes error
 43208                                  
 43209 00007B61 368C06[FB05]            	MOV	[SS:SAVE_ES],ES		  ;AN000;EO. save API parms;smr;SS Override
 43210 00007B66 36893E[F905]            	MOV	[SS:SAVE_DI],DI		  ;AN000;EO.;smr;SS Override
 43211 00007B6B 36FF36[F405]            	PUSH	word [SS:EXTOPEN_FLAG]	  ;AN000;EO.;smr;SS Override
 43212 00007B70 368F06[FD05]            	POP	word [SS:SAVE_DX]	  ;AN000;EO.;smr;SS Override
 43213 00007B75 36890E[FF05]            	MOV	[SS:SAVE_CX],CX		  ;AN000;EO.;smr;SS Override
 43214 00007B7A 36891E[0106]            	MOV	[SS:SAVE_BX],BX		  ;AN000;EO.;smr;SS Override
 43215 00007B7F 368C1E[0506]            	MOV	[SS:SAVE_DS],DS		  ;AN000;EO.;smr;SS Override
 43216 00007B84 368936[0306]            	MOV	[SS:SAVE_SI],SI		  ;AN000;EO.;smr;SS Override
 43217 00007B89 89F2                    	MOV	DX,SI			  ;AN000;EO. ds:dx points to file name
 43218 00007B8B 89D8                    	MOV	AX,BX			  ;AN000;EO. ax= mode
 43219 00007B8D EB0A                    	JMP	SHORT goopen2		  ;AN000;;EO. do normal
 43220                                  ext_inval2:				  ;AN000;;EO.
 43221                                  	;mov	al,1
 43222 00007B8F B001                    	mov	al,error_invalid_function ;AN000;EO.. invalid function
 43223                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43224                                  eo_err:
 43225                                  	;jmp	SYS_RET_ERR
 43226 00007B91 EB93                    	jmp	short CreateFail
 43227                                  
 43228                                  ext_inval_parm:				  ;AN000;EO..
 43229 00007B93 59                      	POP	CX			  ;AN000;EO..  pop up satck
 43230 00007B94 5E                      	POP	SI			  ;AN000;EO..
 43231                                  	;error	error_invalid_data	  ;AN000;EO..  invalid parms
 43232                                  	;mov	al,13
 43233 00007B95 B00D                    	mov	al,error_invalid_data
 43234                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43235                                  	;;jmp	SYS_RET_ERR
 43236                                  	;jmp	short eo_err
 43237                                  	; 17/12/2022
 43238 00007B97 EB8D                    	jmp	short CreateFail
 43239                                  
 43240                                  	; 17/12/2022	
 43241                                  ;error_return:				  ;AN000;EO.
 43242                                  ;	retn				  ;AN000;EO.. return with error
 43243                                  
 43244                                  goopen2:				  ;AN000;
 43245                                  	; 17/12/2022
 43246                                  	;test	bh,20h				 
 43247 00007B99 F6C720                  	test	bh,INT_24_ERROR>>8 ; 04/12/2022
 43248                                  	;;test	bx,2000h
 43249                                  	;TEST	BX,INT_24_ERROR		  ;AN000;EO.. disable INT 24 error ?
 43250 00007B9C 7406                    	JZ	short goopen		  ;AN000;EO.. no
 43251                                  	;or	byte [SS:EXTOPEN_ON],2
 43252 00007B9E 36800E[F605]02          	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_I24_OFF ;AN000;EO.. set bit to disable;smr;SS Override
 43253                                  goopen:					  ;AN000;
 43254                                  	;or	byte [SS:EXTOPEN_ON],1 
 43255 00007BA4 36800E[F605]01          	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_ON  ;AN000;EO.. set Extended Open active;smr;SS Override
 43256                                  	;AND	word [SS:EXTOPEN_FLAG],0FFh  ;AN000;EO.create new ?;smr;SS Override
 43257                                  	; 18/12/2022
 43258 00007BAA 36C606[F505]00          	mov	byte [SS:EXTOPEN_FLAG+1],0 ; AND word [SS:EXTOPEN_FLAG],0FFh
 43259                                  	;cmp	word [SS:EXTOPEN_FLAG],10h
 43260 00007BB0 36833E[F405]10          	CMP	word [SS:EXTOPEN_FLAG],EXT_EXISTS_FAIL+EXT_NEXISTS_CREATE ;AN000;FT.;smr;SS Override
 43261 00007BB6 7516                    	JNZ	short chknext 		  ;AN000;;EO. no
 43262 00007BB8 E8D0FE                  	call	_$CreateNewFile		  ;AN000;;EO. yes
 43263 00007BBB 723F                    	JC	short error_return	  ;AN000;;EO. error
 43264                                  
 43265 00007BBD 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 43266 00007BC3 7438                    	JZ	short ok_return2	  ;AN000;;EO. yes
 43267                                  	;mov	word [SS:EXTOPEN_FLAG],2
 43268 00007BC5 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED ;AN000;EO. creted/opened;smr;SS Override
 43269 00007BCC EB7F                    	JMP	setXAttr		  ;AN000;;EO. set XAs
 43270                                  
 43271                                  	; 17/12/2022
 43272                                  ;ok_return2:
 43273                                  ;	jmp	SYS_RET_OK		  ;AN000;;EO.
 43274                                  
 43275                                  chknext:
 43276                                  	; 17/12/2022
 43277 00007BCE 36F606[F405]01          	test	byte [SS:EXTOPEN_FLAG],EXT_EXISTS_OPEN ; 1
 43278                                  	;;test	word [SS:EXTOPEN_FLAG],1
 43279                                  	;TEST	word [SS:EXTOPEN_FLAG],EXT_EXISTS_OPEN ;AN000;;EO. exists open;smr;SS Override
 43280 00007BD4 752A                    	JNZ	short exist_open	  ;AN000;;EO. yes
 43281 00007BD6 E8C9FD                  	call	_$CREAT			  ;AN000;;EO. must be replace open
 43282 00007BD9 7221                    	JC	short error_return	  ;AN000;;EO. return with error
 43283 00007BDB 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 43284 00007BE1 741A                    	JZ	short ok_return2	  ;AN000;;EO. yes
 43285 00007BE3 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED ;AN000;EO. prsume create/open;smr;SS Override
 43286 00007BEA 36F606[F605]04          	TEST	byte [SS:EXTOPEN_ON],EXT_FILE_NOT_EXISTS ;AN000;;EO. file not exists ?;smr;SS Override
 43287 00007BF0 755B                    	JNZ	short setXAttr		  ;AN000;;EO. no
 43288 00007BF2 36C706[F405]0300        	MOV	word [SS:EXTOPEN_FLAG],ACTION_REPLACED_OPENED ;AN000;;EO. replaced/opened;smr;SS Override
 43289 00007BF9 EB52                    	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 43290                                  error_return2:
 43291 00007BFB F9                      	STC 				  ; Set Carry again to flag error ;AN001;
 43292                                  error_return:	 ;17/12/2022
 43293 00007BFC C3                      	retn				  ;AN000;;EO. return with error
 43294                                  
 43295                                  	; 17/12/2022
 43296                                  ok_return:
 43297                                  ok_return2:
 43298 00007BFD E9708A                  	jmp	SYS_RET_OK
 43299                                  
 43300                                  exist_open:				  ;AN000;
 43301 00007C00 36F606[7205]FF          	test	byte [SS:FSHARING],-1	  ;AN000;;EO. server doscall?;smr;SS Override
 43302 00007C06 7402                    	jz	short noserver		  ;AN000;;EO. no
 43303 00007C08 88E9                    	MOV	CL,CH			  ;AN000;;EO. cl=search attribute
 43304                                  noserver:
 43305 00007C0A E8C0FC                  	call	_$Open2			  ;AN000;;EO. do open
 43306 00007C0D 732F                    	JNC	short ext_ok		  ;AN000;;EO.
 43307 00007C0F 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. error and IFS call;smr;SS Override
 43308 00007C15 74E4                    	JZ	short error_return2	  ;AN000;;EO. return with error
 43309                                  local_extopen:
 43310                                  	;cmp	ax,2
 43311 00007C17 83F802                  	CMP	AX,error_file_not_found   ;AN000;;EO. file not found error
 43312 00007C1A 75DF                    	JNZ	short error_return2	  ;AN000;;EO. no,
 43313                                  	;;test	word [SS:EXTOPEN_FLAG],10h
 43314                                  	; 17/12/2022
 43315 00007C1C 36F606[F405]10          	test	byte [SS:EXTOPEN_FLAG],EXT_NEXISTS_CREATE ; 10h
 43316                                  	;TEST	word [SS:EXTOPEN_FLAG],EXT_NEXISTS_CREATE ;AN000;;EO. want to fail;smr;SS Override
 43317                                  	;JNZ	short do_creat		  ;AN000;;EO. yes
 43318                                  	;JMP	short extexit 		  ;AN000;;EO. yes
 43319                                  	; 17/12/2022
 43320 00007C22 745D                    	jz	short extexit ; 10/06/2019
 43321                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43322                                  	;jnz	short do_creat
 43323                                  	;jmp	short extexit
 43324                                  do_creat:
 43325 00007C24 368B0E[FF05]            	MOV	CX,[SS:SAVE_CX]		  ;AN000;;EO. get ds:dx for file name;smr;SS Override
 43326 00007C29 36C536[0306]            	LDS	SI,[SS:SAVE_SI]		  ;AN000;;EO. cx = attribute;smr;SS Override
 43327 00007C2E 89F2                    	MOV	DX,SI			  ;AN000;;EO.
 43328 00007C30 E86FFD                  	call	_$CREAT			  ;AN000;;EO. do create
 43329 00007C33 724C                    	JC	short extexit 		  ;AN000;;EO. error
 43330                                  	;mov	word [SS:EXTOPEN_FLAG],2
 43331 00007C35 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED
 43332                                  					  ;AN000;;EO. is created/opened;smr;SS Override
 43333 00007C3C EB0F                    	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 43334                                  
 43335                                  ext_ok:
 43336 00007C3E 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS call ?;smr;SS Override
 43337 00007C44 74B7                    	JZ	short ok_return		  ;AN000;;EO. yes
 43338                                  	;mov	word [SS:EXTOPEN_FLAG],1
 43339 00007C46 36C706[F405]0100        	MOV	word [SS:EXTOPEN_FLAG],ACTION_OPENED ;AN000;;EO. opened;smr;SS Override
 43340                                  setXAttr:
 43341                                  	; 29/04/2019
 43342 00007C4D 50                      	push	ax
 43343 00007C4E E82688                  	call	Get_User_Stack		  ;AN000;;EO.
 43344 00007C51 36A1[F405]              	MOV	AX,[SS:EXTOPEN_FLAG]	  ;AN000;;EO.;smr;SS Override
 43345                                  	;mov	[si+4],ax
 43346 00007C55 894404                  	MOV	[SI+user_env.user_CX],AX  ;AN000;;EO. set action code for cx
 43347 00007C58 58                      	pop	ax			  ;AN000;;EO.
 43348 00007C59 8904                    	mov	[si],ax
 43349                                  	;MOV	[SI+user_env.user_AX],AX  ;AN000;;EO. set handle for ax
 43350                                  	; 17/12/2022
 43351 00007C5B EBA0                    	jmp	short ok_return
 43352                                  ;ok_return:				  ;AN000;
 43353                                  	;jmp	SYS_RET_OK		  ;AN000;;EO.
 43354                                  
 43355                                  extexit2:				  ;AN000; ERROR RECOVERY
 43356 00007C5D 5B                      	POP	BX			  ;AN000;EO. close the handle
 43357 00007C5E 50                      	PUSH	AX			  ;AN000;EO. save error code from set XA
 43358                                  	;cmp	word [SS:EXTOPEN_FLAG],2
 43359 00007C5F 36833E[F405]02          	CMP	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED
 43360                                  					  ;AN000;EO. from create;smr;SS Override
 43361 00007C65 750C                    	JNZ	short justopen		  ;AN000;EO.
 43362 00007C67 36C536[0306]            	LDS	SI,[SS:SAVE_SI]		  ;AN000;EO. cx = attribute;smr;SS Override
 43363 00007C6C C514                    	LDS	DX,[SI]			  ;AN000;EO.
 43364 00007C6E E881FD                  	call	_$UNLINK 		  ;AN000;EO. delete the file
 43365 00007C71 EB03                    	JMP	SHORT reserror		  ;AN000;EO.
 43366                                  
 43367                                  justopen:				  ;AN000;
 43368 00007C73 E886F4                  	call	_$CLOSE			  ;AN000;EO. pretend never happend
 43369                                  reserror:				  ;AN000;
 43370 00007C76 58                      	POP	AX			  ;AN000;EO. restore error code from set XA
 43371 00007C77 EB08                    	JMP	SHORT extexit		  ;AN000;EO.
 43372                                  
 43373                                  ext_file_unfound:			  ;AN000;
 43374                                  	;mov	ax,2
 43375 00007C79 B80200                  	MOV	AX,error_file_not_found   ;AN000;EO.
 43376 00007C7C EB03                    	JMP	SHORT extexit		  ;AN000;EO.
 43377                                  ext_inval:				  ;AN000;
 43378                                  	;mov	ax,1
 43379 00007C7E B80100                  	MOV	AX,error_invalid_function ;AN000;EO.
 43380                                  lockoperr:	; 17/12/2022
 43381                                  extexit:
 43382 00007C81 E9F689                  	jmp	SYS_RET_ERR		  ;AN000;EO.
 43383                                  
 43384                                  ;============================================================================
 43385                                  ; LOCK.ASM, MSDOS 6.0, 1991
 43386                                  ;============================================================================
 43387                                  ; 14/07/2018 - Retro DOS v3.0
 43388                                  ; 22/05/2019 - Retro DOS v4.0
 43389                                  
 43390                                  ;BREAK <$LockOper - Lock Calls>
 43391                                  ;----------------------------------------------------------------------------
 43392                                  ;
 43393                                  ;   Assembler usage:
 43394                                  ;	    MOV     BX, Handle	       (DOS 3.3)
 43395                                  ;	    MOV     CX, OffsetHigh
 43396                                  ;	    MOV     DX, OffsetLow
 43397                                  ;	    MOV     SI, LengthHigh
 43398                                  ;	    MOV     DI, LengthLow
 43399                                  ;	    MOV     AH, LockOper
 43400                                  ;	    MOV     AL, Request
 43401                                  ;	    INT     21h
 43402                                  ;
 43403                                  ;   Error returns:
 43404                                  ;	    AX = error_invalid_handle
 43405                                  ;	       = error_invalid_function
 43406                                  ;	       = error_lock_violation
 43407                                  ;
 43408                                  ;   Assembler usage:
 43409                                  ;	    MOV     AX, 5C??	       (DOS 4.00)
 43410                                  ;
 43411                                  ;				    0? lock all
 43412                                  ;				    8? lock write
 43413                                  ;				    ?2 lock multiple
 43414                                  ;				    ?3 unlock multiple
 43415                                  ;				    ?4 lock/read
 43416                                  ;				    ?5 write/unlock
 43417                                  ;				    ?6 add (lseek EOF/lock/write/unlock)
 43418                                  ;	    MOV     BX, Handle
 43419                                  ;	    MOV     CX, count or size
 43420                                  ;	    LDS     DX, buffer
 43421                                  ;	    INT     21h
 43422                                  ;
 43423                                  ;   Error returns:
 43424                                  ;	    AX = error_invalid_handle
 43425                                  ;	       = error_invalid_function
 43426                                  ;	       = error_lock_violation
 43427                                  ;
 43428                                  ;----------------------------------------------------------------------------
 43429                                  
 43430                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43431                                  _$LockOper:
 43432 00007C84 3C01                    	CMP	AL,1
 43433 00007C86 770B                    	JA	short lock_bad_func
 43434                                  
 43435 00007C88 57                      	PUSH	DI			       ; Save LengthLow
 43436 00007C89 E8D5F3                  	call	SFFromHandle		       ; ES:DI -> SFT
 43437 00007C8C 731D                    	JNC	short lock_do 		       ; have valid handle
 43438 00007C8E 5F                      	POP	DI			       ; Clean stack
 43439                                  	;mov	al,6
 43440 00007C8F B006                    	mov	al,error_invalid_handle
 43441                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43442                                  ;lockoperr:
 43443                                  	;jmp	SYS_RET_ERR
 43444                                  	; 17/12/2022
 43445 00007C91 EBEE                    	jmp	short lockoperr ; jmp SYS_RET_ERR
 43446                                  
 43447                                  lock_bad_func:
 43448                                  	;mov	byte [ss:EXTERR_LOCUS],1
 43449 00007C93 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus;smr;SS Override
 43450                                  	;mov	al,1
 43451 00007C99 B001                    	mov	al,error_invalid_function
 43452                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43453                                  lockoperrj:
 43454                                  	;jmp	SYS_RET_ERR
 43455 00007C9B EBE4                    	jmp	short lockoperr
 43456                                  
 43457                                  	; 22/05/2019 - Retro DOS v4.0
 43458                                  
 43459                                  	; MSDOS 6.0 
 43460                                  ; Align_buffer call has been deleted, since it corrupts the DTA (6/5/88) P5013
 43461                                  ; Dead code deleted, MD, 23 Mar 90
 43462                                  
 43463                                  ;lock_do:
 43464                                  ;	; MSDOS 3.3
 43465                                  ;	or	al,al
 43466                                  ;	pop	ax
 43467                                  ;	jz	short DOS_Lock
 43468                                  ;DOS_Unlock:
 43469                                  ;	;test	word [es:di+5],8000h
 43470                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 43471                                  ;	JZ	short LOCAL_UNLOCK
 43472                                  ;	push    ax
 43473                                  ;	mov     ax,110Bh
 43474                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 43475                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 43476                                  ;			; STACK: WORD low word of size, ES:DI -> SFT for file
 43477                                  ;			; SFT DPB field -> DPB of drive containing file
 43478                                  ;			; Return: CF set error
 43479                                  ;	pop     bx
 43480                                  ;	jmp     short ValChk
 43481                                  ;
 43482                                  ;LOCAL_UNLOCK:
 43483                                  ;	Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 43484                                  ;ValChk:
 43485                                  ;	JNC	short Lock_OK
 43486                                  ;lockerror:
 43487                                  ;	jmp	SYS_RET_ERR
 43488                                  ;Lock_OK:
 43489                                  ;	;MOV	AX,[SS:Temp_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 43490                                  ;	jmp	SYS_RET_OK
 43491                                  ;DOS_Lock:
 43492                                  ;	;test	word [es:di+5],8000h
 43493                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 43494                                  ;	JZ	short LOCAL_LOCK
 43495                                  ;	;CallInstall NET_XLock,MultNET,10
 43496                                  ;	mov     ax, 110Ah
 43497                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 43498                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 43499                                  ;			; STACK: WORD low word of size, ES:DI -> SFT
 43500                                  ;			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 43501                                  ;			; Return: CF set error
 43502                                  ;	JMP	short ValChk
 43503                                  ;
 43504                                  ;LOCAL_LOCK:
 43505                                  ;	Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 43506                                  ;	JMP	short ValChk
 43507                                  
 43508                                  ; 17/12/2022
 43509                                  LOCAL_UNLOCK:
 43510                                  	; MSDOS 3.3
 43511                                  	;Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 43512                                  	; MSDOS 6.0
 43513 00007C9D FF1E[AC00]              	Call	far [JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 43514                                  ValChk:
 43515 00007CA1 7302                    	JNC	short Lock_OK
 43516                                  lockerror:
 43517                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43518                                  	;;jmp	SYS_RET_ERR
 43519                                  	;jmp	short lockoperrj
 43520                                  	; 17/12/2022
 43521 00007CA3 EBDC                    	jmp	short lockoperr	; jmp SYS_RET_ERR
 43522                                  Lock_OK:
 43523                                  	;MOV	AX,[SS:TEMP_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 43524                                  	; 10/06/2019
 43525 00007CA5 A1[0C06]                	mov	ax,[TEMP_VAR]
 43526 00007CA8 E9C589                  	jmp	SYS_RET_OK
 43527                                  
 43528                                  	; 22/05/2019
 43529                                  lock_do:
 43530                                  	; MSDOS 6.0
 43531 00007CAB 89C3                    	MOV	BX,AX				; save AX
 43532 00007CAD BD[A903]                	MOV	BP,Lock_Buffer			; get DOS LOCK buffer
 43533                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43534                                  	;;mov	[bp+0],dx
 43535                                  	;MOV	[BP+LockBuf.Lock_position],DX	; set low offset
 43536                                  	; 15/12/2022
 43537 00007CB0 895600                  	mov	[bp],dx
 43538                                  	;mov	[bp+2],cx
 43539 00007CB3 894E02                  	MOV	[BP+LockBuf.Lock_position+2],CX; set high offset
 43540 00007CB6 59                      	POP	CX				; get low length
 43541                                  	;mov	[bp+4],cx
 43542 00007CB7 894E04                  	MOV	[BP+LockBuf.Lock_length],CX	; set low length
 43543                                  	;mov	[bp+6],si
 43544 00007CBA 897606                  	MOV	[BP+LockBuf.Lock_length+2],SI	; set high length
 43545 00007CBD B90100                  	MOV	CX,1				; one range
 43546                                  
 43547                                  ;	PUSH	CS				;
 43548                                  ;	POP	DS				; DS:DX points to
 43549                                  
 43550 00007CC0 16                      	push	ss
 43551 00007CC1 1F                      	pop	ds
 43552                                  
 43553 00007CC2 89EA                    	MOV	DX,BP				; Lock_Buffer
 43554                                  	;test	al,1
 43555 00007CC4 A801                    	TEST	AL,UNLOCK_ALL			; function 1
 43556                                  	;JNZ	short DOS_Unlock		; yes
 43557                                  	;JMP	short DOS_Lock			; function 0
 43558                                  	; 17/12/2022
 43559                                  	; 10/06/2019
 43560 00007CC6 740E                    	jz	short DOS_Lock
 43561                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43562                                  	;JNZ	short DOS_Unlock
 43563                                  	;JMP	short DOS_Lock
 43564                                  
 43565                                  DOS_Unlock:
 43566                                  	;;test	word [es:di+5],8000h
 43567                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 43568 00007CC8 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 43569 00007CCD 74CE                    	JZ	short LOCAL_UNLOCK
 43570                                  
 43571                                  lock_unlock: ; 22/05/2019
 43572                                  	
 43573                                  	;CallInstall Net_Xlock,MultNET,10
 43574                                  	
 43575                                  	; MSDOS 3.3
 43576                                  	;mov     ax,110Bh
 43577                                  	;int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 43578                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 43579                                  			; STACK: WORD low word of size, ES:DI -> SFT for file
 43580                                  			; SFT DPB field -> DPB of drive containing file
 43581                                  			; Return: CF set error
 43582                                  	; MSDOS 6.0
 43583 00007CCF B80A11                  	mov     ax,110Ah
 43584 00007CD2 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 43585                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 43586                                  			; STACK: WORD low word of size, ES:DI -> SFT
 43587                                  			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 43588                                  			; Return: CF set error
 43589                                  
 43590 00007CD4 EBCB                    	JMP	SHORT ValChk
 43591                                  
 43592                                  ; 17/12/2022
 43593                                  %if 0
 43594                                  LOCAL_UNLOCK:
 43595                                  	; MSDOS 3.3
 43596                                  	;Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 43597                                  	; MSDOS 6.0
 43598                                  	Call	far [JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 43599                                  ValChk:
 43600                                  	JNC	short Lock_OK
 43601                                  lockerror:
 43602                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43603                                  	;jmp	SYS_RET_ERR
 43604                                  	jmp	short lockoperrj
 43605                                  Lock_OK:
 43606                                  	;MOV	AX,[SS:TEMP_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 43607                                  	; 10/06/2019
 43608                                  	mov	ax,[TEMP_VAR]
 43609                                  	jmp	SYS_RET_OK
 43610                                  %endif
 43611                                  
 43612                                  DOS_Lock:
 43613                                  	;;test	word [es:di+5],8000h
 43614                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 43615 00007CD6 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 43616 00007CDB 7407                    	JZ	short LOCAL_LOCK
 43617                                  
 43618                                  	;CallInstall NET_XLock,MultNET,10
 43619                                  
 43620 00007CDD B80A11                  	mov     ax,110Ah
 43621 00007CE0 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 43622                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 43623                                  			; STACK: WORD low word of size, ES:DI -> SFT
 43624                                  			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 43625                                  			; Return: CF set error
 43626                                  
 43627 00007CE2 EBBD                    	JMP	short ValChk
 43628                                  
 43629                                  LOCAL_LOCK:
 43630                                  	; MSDOS 3.3
 43631                                  	;Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 43632                                  	; MSDOS 6.0
 43633 00007CE4 FF1E[A800]              	Call	far [JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 43634                                  
 43635 00007CE8 EBB7                    	JMP	short ValChk
 43636                                  
 43637                                  ; 14/07/2018 - Retro DOS v3.0
 43638                                  ; LOCK_CHECK
 43639                                  ;MSDOS 6.0 (& MSDOS 3.3)
 43640                                  
 43641                                  ;----------------------------------------------------------------------------
 43642                                  ; Inputs:
 43643                                  ;	Outputs of SETUP
 43644                                  ;	[USER_ID] Set
 43645                                  ;	[PROC_ID] Set
 43646                                  ; Function:
 43647                                  ;	Check for lock violations on local I/O
 43648                                  ;	Retries are attempted with sleeps in between
 43649                                  ; Outputs:
 43650                                  ;    Carry clear
 43651                                  ;	Operation is OK
 43652                                  ;    Carry set
 43653                                  ;	A lock violation detected
 43654                                  ; Outputs of SETUP preserved
 43655                                  ;----------------------------------------------------------------------------
 43656                                  
 43657                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43658                                  	; 22/05/2019 - Retro DOS v4.0
 43659                                  LOCK_CHECK:
 43660 00007CEA 8B1E[1A00]              	MOV	BX,[RetryCount]	; Number retries
 43661                                  LockRetry:
 43662 00007CEE 53                      	push	bx		; save regs
 43663 00007CEF 50                      	push	ax ; MSDOS 6.0
 43664                                  
 43665                                  	;MSDOS 3.3
 43666                                  	;Call	far [ss:JShare+(8*4)]	; 8 = chk_block
 43667                                  	;MSDOS 6.0
 43668 00007CF0 FF1E[B000]              	Call	far [JShare+(8*4)]	; 8 = chk_block
 43669                                  
 43670 00007CF4 58                      	pop	ax ; MSDOS 6.0
 43671 00007CF5 5B                      	pop	bx		; restrore regs
 43672 00007CF6 7307                    	jnc	short lc_ret_label ; There are no locks (retnc)
 43673                                  LockN:
 43674 00007CF8 E8019B                  	call	Idle		; wait a while
 43675 00007CFB 4B                      	DEC	BX		; remember a retry
 43676 00007CFC 75F0                    	JNZ	short LockRetry	; more retries left...
 43677 00007CFE F9                      	STC
 43678                                  lc_ret_label:
 43679 00007CFF C3                      	retn
 43680                                  
 43681                                  ; 14/07/2018 - Retro DOS v3.0
 43682                                  ; LOCK_VIOLATION
 43683                                  ;MSDOS 6.0 (& MSDOS 3.3)
 43684                                  
 43685                                  ;----------------------------------------------------------------------------
 43686                                  ; Inputs:
 43687                                  ;	[THISDPB] set
 43688                                  ;	[READOP] indicates whether error on read or write
 43689                                  ; Function:
 43690                                  ;	Handle Lock violation on compatibility (FCB) mode SFTs
 43691                                  ; Outputs:
 43692                                  ;	Carry set if user says FAIL, causes error_lock_violation
 43693                                  ;	Carry clear if user wants a retry
 43694                                  ;
 43695                                  ; DS, ES, DI, CX preserved, others destroyed
 43696                                  ;----------------------------------------------------------------------------
 43697                                  
 43698                                  LOCK_VIOLATION:
 43699 00007D00 1E                      	PUSH	DS
 43700 00007D01 06                      	PUSH	ES
 43701 00007D02 57                      	PUSH	DI
 43702 00007D03 51                      	PUSH	CX
 43703                                  	;mov	ax,21h
 43704 00007D04 B82100                  	MOV	AX,error_lock_violation
 43705                                  	;mov	byte [ALLOWED],18h
 43706 00007D07 C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 43707 00007D0C C42E[8A05]              	LES	BP,[THISDPB]
 43708 00007D10 BF0100                  	MOV	DI,1		; Fake some registers
 43709 00007D13 89F9                    	MOV	CX,DI
 43710                                  	;mov	dx,[es:bp+11]
 43711 00007D15 268B560B                	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 43712 00007D19 E89CDF                  	call	HARDERR
 43713 00007D1C 59                      	POP	CX
 43714 00007D1D 5F                      	POP	DI
 43715 00007D1E 07                      	POP	ES
 43716 00007D1F 1F                      	POP	DS
 43717 00007D20 3C01                    	CMP	AL,1
 43718 00007D22 74DB                    	jz	short lc_ret_label ; 1 = retry, carry clear
 43719 00007D24 F9                      	STC
 43720 00007D25 C3                      	retn
 43721                                  
 43722                                  ; 14/07/2018 - Retro DOS v3.0
 43723                                  
 43724                                  ;----------------------------------------------------------------------------
 43725                                  
 43726                                  ;	do a retz to return error
 43727                                  
 43728                                  	; 22/05/2019 - Retro DOS v4.0
 43729                                  CheckShare:
 43730                                  	; MSDOS 3.3
 43731                                  	;cmp	byte [cs:fShare],0
 43732                                  	;retn
 43733                                  
 43734                                  	; MSDOS 6.0
 43735 00007D26 1E                      	push	ds			;smr;
 43736                                  	;getdseg <ds>			; ds -> dosdata
 43737 00007D27 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 43738 00007D2C 803E[0303]00            	cmp	byte [fShare],0
 43739 00007D31 1F                      	pop	ds			;smr;
 43740 00007D32 C3                      	retn
 43741                                  	
 43742                                  ;============================================================================
 43743                                  ; SHARE.ASM, MSDOS 6.0, 1991
 43744                                  ;============================================================================
 43745                                  ; 14/07/2018 - Retro DOS v3.0
 43746                                  ; 22/05/2019 - Retro DOS v4.0
 43747                                  
 43748                                  ; SHARE_CHECK
 43749                                  ;----------------------------------------------------------------------------
 43750                                  ; Inputs:
 43751                                  ;       [THISSFT] Points to filled in local file/device SFT for new
 43752                                  ;               instance of file sf_mode ALWAYS has mode (even on FCB SFTs)
 43753                                  ;       [WFP_START] has full path of name
 43754                                  ;       [USER_ID] Set
 43755                                  ;       [PROC_ID] Set
 43756                                  ; Function:
 43757                                  ;       Check for sharing violations on local file/device access
 43758                                  ; Outputs:
 43759                                  ;    Carry clear
 43760                                  ;       Sharing approved
 43761                                  ;    Carry set
 43762                                  ;       A sharing violation detected
 43763                                  ;           AX is error code
 43764                                  ; USES    ALL but DS
 43765                                  ;----------------------------------------------------------------------------
 43766                                  
 43767                                  	; 22/05/2019 - Retro DOS v4.0
 43768                                  SHARE_CHECK:
 43769                                  	; 26/07/2019
 43770 00007D33 FF1E[9400]              	call	far [JShare+(1*4)] 	; 1 = MFT_Enter
 43771                                  shchk_retn:
 43772 00007D37 C3                      	retn
 43773                                  
 43774                                  ; SHARE_VIOLATION
 43775                                  ;----------------------------------------------------------------------------
 43776                                  ; Inputs:
 43777                                  ;       [THISDPB] Set
 43778                                  ;       AX has error code
 43779                                  ; Function:
 43780                                  ;       Handle Sharing errors
 43781                                  ; Outputs:
 43782                                  ;       Carry set if user says FAIL, causes error_sharing_violation
 43783                                  ;       Carry clear if user wants a retry
 43784                                  ;
 43785                                  ; DS, ES, DI preserved, others destroyed
 43786                                  ;----------------------------------------------------------------------------
 43787                                  
 43788                                  SHARE_VIOLATION:
 43789 00007D38 1E                      	PUSH    DS
 43790 00007D39 06                      	PUSH	ES
 43791 00007D3A 57                      	PUSH    DI
 43792 00007D3B C606[7505]00            	MOV     byte [READOP],0		; All share errors are reading
 43793                                  	;mov	byte [ALLOWED],18h
 43794 00007D40 C606[4B03]18            	MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 43795 00007D45 C42E[8A05]              	LES     BP,[THISDPB]
 43796 00007D49 BF0100                  	MOV     DI,1			; Fake some registers
 43797 00007D4C 89F9                    	MOV     CX,DI
 43798                                  	;mov	dx,[es:bp+17]
 43799 00007D4E 268B5611                	MOV     DX,[ES:BP+DPB.DIR_SECTOR]
 43800 00007D52 E863DF                  	call	HARDERR
 43801 00007D55 5F                      	POP     DI
 43802 00007D56 07                      	POP	ES
 43803 00007D57 1F                      	POP     DS
 43804 00007D58 3C01                    	CMP     AL,1
 43805 00007D5A 74DB                    	jz	short shchk_retn	; 1 = retry, carry clear
 43806 00007D5C F9                      	STC
 43807 00007D5D C3                      	retn
 43808                                  
 43809                                  ;----------------------------------------------------------------------------
 43810                                  ;   ShareEnd - terminate sharing info on a particular SFT/UID/PID. This does
 43811                                  ;       NOT perform a close, it merely asserts that the sharing information
 43812                                  ;       for the SFT/UID/PID may be safely released.
 43813                                  ;
 43814                                  ;   Inputs:     ES:DI points to an SFT
 43815                                  ;   Outputs:    None
 43816                                  ;   Registers modified: all except DS,ES,DI
 43817                                  ;----------------------------------------------------------------------------
 43818                                  
 43819                                  ShareEnd:
 43820                                  	; 26/07/2019
 43821 00007D5E FF1E[9800]              	call	far [JShare+(2*4)]	; 2 = MFTClose
 43822 00007D62 C3                      	retn
 43823                                  
 43824                                  ;Break <ShareEnter - attempt to enter a node into the sharing set>
 43825                                  ;----------------------------------------------------------------------------
 43826                                  ;   ShareEnter - perform a retried entry of a nodde into the sharing set. If
 43827                                  ;   the max number of retries is exceeded, we notify the user via int 24.
 43828                                  ;
 43829                                  ;   Inputs:     ThisSFT points to the SFT
 43830                                  ;               WFP_Start points to the WFP
 43831                                  ;   Outputs:    Carry clear => successful entry
 43832                                  ;               Carry set => failed system call
 43833                                  ;   Registers modified: all
 43834                                  ;----------------------------------------------------------------------------
 43835                                  
 43836                                  ShareEnter:
 43837 00007D63 51                      	push	cx
 43838                                  retry:
 43839 00007D64 8B0E[1A00]              	mov     cx,[RetryCount]
 43840                                  attempt:
 43841 00007D68 C43E[9E05]              	les     di,[THISSFT]		; grab sft
 43842 00007D6C 31C0                    	XOR     AX,AX
 43843                                   	;mov	[es:di+51],axfff
 43844 00007D6E 26894533                	MOV     [ES:DI+SF_ENTRY.sf_MFT],AX ; indicate free SFT
 43845 00007D72 51                      	push	cx
 43846 00007D73 E8BDFF                  	call    SHARE_CHECK             ; attempt to enter into the sharing set
 43847 00007D76 59                      	pop	cx
 43848 00007D77 730A                    	jnc	short done		; success, let the user see this
 43849 00007D79 E8809A                  	call	Idle                    ; wait a while
 43850 00007D7C E2EA                    	loop    attempt                 ; go back for another attempt
 43851 00007D7E E8B7FF                  	call    SHARE_VIOLATION         ; signal the problem to the user
 43852 00007D81 73E1                    	jnc	short retry		; user said to retry, go do it
 43853                                  done:
 43854 00007D83 59                      	pop	cx
 43855 00007D84 C3                      	retn
 43856                                  
 43857                                  ;============================================================================
 43858                                  ; EXEPATCH.ASM (MSDOS 6.0, 1991)
 43859                                  ;============================================================================
 43860                                  ; 29/04/2019 - Retro DOS 4.0
 43861                                  
 43862                                  ;** EXEPATCH.ASM 
 43863                                  ;----------------------------------------------------------------------------
 43864                                  ;	Contains the foll:
 43865                                  ;
 43866                                  ;		- code to find and overlay buggy unpack code
 43867                                  ;		- new code to be overlayed on buggy unpack code 
 43868                                  ;		- old code sequence to identify buggy unpack code
 43869                                  ;
 43870                                  ;	Revision history:
 43871                                  ;
 43872                                  ;		Created: 5/14/90
 43873                                  ;----------------------------------------------------------------------------
 43874                                  
 43875                                  ;----------------------------------------------------------------------------
 43876                                  ;
 43877                                  ; M020 : Fix for rational bug - for details see routine header
 43878                                  ; M028 : 4b04 implementation
 43879                                  ; M030 : Fixing bug in EXEPACKPATCH (EXEC_CS is an un-relocated value)
 43880                                  ; M032 : set turnoff bit only if DOS in HMA.
 43881                                  ; M033 : if IP < 2 then not exepacked.
 43882                                  ; M046 : support for a 4th version of exepacked files.
 43883                                  ; M068 : support for copy protected apps.
 43884                                  ; M071 : use A20OFF_COUNT of 10.
 43885                                  ;
 43886                                  ;----------------------------------------------------------------------------
 43887                                  
 43888                                  PATCH1_COM_OFFSET	EQU	06CH
 43889                                  PATCH1_OFFSET		EQU	028H
 43890                                  PATCH1_CHKSUM		EQU	0EF4EH
 43891                                  CHKSUM1_LEN		EQU	11CH/2 ; 142
 43892                                  
 43893                                  PATCH2_COM_OFFSET	EQU	076H
 43894                                  PATCH2_OFFSET		EQU	032H
 43895                                  
 43896                                  	; The strings that start at offset 076h have two possible 
 43897                                  	; check sums that are defined as PATCH2_CHKSUM PATCH2A_CHKSUM
 43898                                  
 43899                                  PATCH2_CHKSUM		EQU	78B2H
 43900                                  CHKSUM2_LEN		EQU	119H/2
 43901                                  PATCH2A_CHKSUM		EQU	1C47H		; M046
 43902                                  CHKSUM2A_LEN		EQU	103H/2		; M046
 43903                                  
 43904                                  PATCH3_COM_OFFSET	EQU	074H
 43905                                  PATCH3_OFFSET		EQU	032H
 43906                                  PATCH3_CHKSUM		EQU	4EDEH
 43907                                  CHKSUM3_LEN		EQU	117H/2
 43908                                  
 43909                                  ;**	Data structure passed for ExecReady call
 43910                                  ;
 43911                                  ;struc ERStruc
 43912                                  ; .ER_Reserved:	resw	1	; reserved, should be zero
 43913                                  ; .ER_Flags:	resw	1
 43914                                  ; .ER_ProgName:	resd	1	; ptr to ASCIIZ str of prog name
 43915                                  ; .ER_PSP:	resw	1	; PSP of the program
 43916                                  ; .ER_StartAddr: resd	1	; Start CS:IP of the program
 43917                                  ; .ER_ProgSize:	resd	1	; Program size including PSP
 43918                                  ; .size:
 43919                                  ;endstruc
 43920                                  
 43921                                  ;DOSCODE SEGMENT
 43922                                  
 43923                                  	; 22/05/2019 - Retro DOS v4.0
 43924                                  	; DOSCODE:B3DDh (MSDOS 6.21, MSDOS.SYS)
 43925                                  
 43926                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43927                                  	; DOSCODE:B37Ah (MSDOS 5.0, MSDOS.SYS)
 43928                                  
 43929                                  ; M028 - BEGIN
 43930                                  
 43931                                  ;--------------------------------------------------------------------------
 43932                                  ;
 43933                                  ;	Procedure Name		: ExecReady
 43934                                  ;
 43935                                  ;	Input			: DS:DX -> ERStruc (see exe.inc)
 43936                                  ;
 43937                                  ;--------------------------------------------------------------------------
 43938                                  
 43939                                  ExecReady:
 43940 00007D85 89D6                    	mov	si,dx			; move the pointer into a friendly one
 43941                                  	;;test	word [si+2],1
 43942                                  	; 17/12/2022
 43943 00007D87 F6440201                	test	byte [si+ERStruc.ER_Flags],ER_EXE ; 1
 43944                                  	;test	word [si+ERStruc.ER_Flags],ER_EXE ; COM or EXE ?
 43945 00007D8B 7413                    	jz	short er_setver		; only setver for .COM files
 43946                                  
 43947                                  	;mov	ax,[si+8]
 43948 00007D8D 8B4408                  	mov	ax,[si+ERStruc.ER_PSP]
 43949 00007D90 83C010                  	add	ax,10h
 43950 00007D93 8EC0                    	mov	es,ax
 43951                                  
 43952                                  	;mov	cx,[si+10]
 43953 00007D95 8B4C0A                  	mov	cx,[si+ERStruc.ER_StartAddr]   ; M030
 43954                                  	;mov	cx,[si+12]
 43955 00007D98 8B440C                  	mov	ax,[si+ERStruc.ER_StartAddr+2] ; M030
 43956                                  
 43957                                  	;call	[ss:FixExePatch]
 43958 00007D9B 36FF16[880D]            	call	word [ss:FixExePatch] ; 28/12/2022
 43959                                  	
 43960                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43961                                  	;call	[ss:Rational386PatchPtr]
 43962                                  
 43963                                  er_setver:
 43964                                  	;;test	word [si+2],2		; Q: is this an overlay
 43965                                  	; 17/12/2022
 43966 00007DA0 F6440202                	test	byte [si+ERStruc.ER_Flags],ER_OVERLAY ; 2
 43967                                  	;test	word [si+ERStruc.ER_Flags],ER_OVERLAY
 43968 00007DA4 7518                    	jnz	short er_chkdoshi	; Y: set A20OFF_COUNT if DOS high
 43969                                  					; N: set up lie version first
 43970 00007DA6 1E                      	push	ds
 43971 00007DA7 56                      	push	si
 43972                                  	;lds	si,[si+4]
 43973 00007DA8 C57404                  	lds	si,[si+ERStruc.ER_ProgName]
 43974 00007DAB E876ED                  	call	Scan_Execname1
 43975 00007DAE E887ED                  	call	Scan_Special_Entries
 43976 00007DB1 5E                      	pop	si
 43977 00007DB2 1F                      	pop	ds
 43978                                  	;mov	es,[si+8]
 43979 00007DB3 8E4408                  	mov	es,[si+ERStruc.ER_PSP]
 43980 00007DB6 36A1[020F]              	mov	ax,[ss:SPECIAL_VERSION]
 43981 00007DBA 26A34000                	mov	[es:PDB.Version],ax
 43982                                  
 43983                                  er_chkdoshi:
 43984 00007DBE 36803E[870D]00          	cmp	byte [ss:DosHasHMA],0	; M032: Q: is dos in HMA (M021)
 43985 00007DC4 741F                    	je	short er_done		; M032: N: done
 43986                                  
 43987                                  					; M068 - Start
 43988                                  	;mov	ax,[si+8]
 43989 00007DC6 8B4408                  	mov	ax,[si+ERStruc.ER_PSP]	; ax = PSP
 43990                                  
 43991                                  	;or	byte [ss:DOS_FLAG],4
 43992 00007DC9 36800E[8600]04          	or	byte [ss:DOS_FLAG],EXECA20OFF ; Set bit to signal int 21
 43993                                  					; ah = 25 & ah= 49. See dossym.inc 
 43994                                  					; under TAG M003 & M009 for 
 43995                                  					; explanation
 43996                                  	;;test	word [si+2],1
 43997                                  	; 17/12/2022
 43998 00007DCF F6440201                	test	byte [si+ERStruc.ER_Flags],ER_EXE ; 1
 43999                                  	;test	word [si+ERStruc.ER_Flags],ER_EXE ; Q: COM file
 44000 00007DD3 7507                    	jnz	short er_setA20		; N: inc a20off_count, set 
 44001                                  					;    a20off_psp and ret
 44002 00007DD5 1E                         	push	ds
 44003 00007DD6 8ED8                    	mov	ds,ax			; DS = load segment of com file.
 44004 00007DD8 E88E02                  	call	IsCopyProt		; check if copy protected
 44005 00007DDB 1F                      	pop	ds
 44006                                  
 44007                                  er_setA20:
 44008                                  	; We need to inc the A20OFF_COUNT here. Note that if the count
 44009                                  	; is non-zero at this point it indicates that the A20 is to be 
 44010                                  	; turned off for that many int 21 calls made by the app. In 
 44011                                  	; addition the A20 has to be turned off when we exit from this 
 44012                                  	; call. Hence the inc.
 44013                                  
 44014 00007DDC 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]		
 44015 00007DE1 36A3[6300]              	mov	[ss:A20OFF_PSP],ax	; set the PSP for which A20 is to be
 44016                                  					; turned OFF.
 44017                                  er_done:				; M068 - End
 44018 00007DE5 31C0                    	xor	ax,ax
 44019 00007DE7 C3                      	retn
 44020                                  
 44021                                  ; M028 - END
 44022                                  
 44023                                  
 44024                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 44025                                  %if 0
 44026                                  
 44027                                  ;----------------------------------------------------------------------------
 44028                                  ;
 44029                                  ; procedure : Rational386Patch
 44030                                  ;
 44031                                  ; Older versions of the Rational DOS Extender have several bugs which trash
 44032                                  ; 386 registers (usually just the high word of 32 bit registers) during
 44033                                  ; interrupt processing. Lotus 123 3.1+ is a popular application that uses a
 44034                                  ; version of the Rational extender with the 32 bit register trashing bugs.
 44035                                  ;
 44036                                  ; This routine applies patches to the Rational DOS Extender to work around
 44037                                  ; most of the register trashing bugs.
 44038                                  ;
 44039                                  ; Note that there are additional register trashing bugs not fixed by these
 44040                                  ; patches. In particular, the high word of ESP and the FS and GS registers
 44041                                  ; may be modified on interrupts.
 44042                                  ;
 44043                                  ; There are two different Rational DOS Extender patchs in this module.
 44044                                  ; Rational386Patch is to correct 386 register trashing bugs on 386 or later
 44045                                  ; processors. This patch code is executed when MS-DOS is running on a 386
 44046                                  ; or later processor, regardless of whether MS-DOS is running in the HMA
 44047                                  ; or not.
 44048                                  ;
 44049                                  ; The other Rational patch routine (RationalPatch, below) fixes a register
 44050                                  ; trashing problem on 286 processors, and is only executed if MS-DOS is
 44051                                  ; running in the HMA.
 44052                                  ;
 44053                                  ; This patch detection and replacement is based on an example supplied by
 44054                                  ; Ben Williams at Rational.
 44055                                  ;
 44056                                  ;----------------------------------------------------------------------------
 44057                                  
 44058                                  ; 22/05/2019 - Retro DOS v4.0
 44059                                  ; DOSCODE:B448h (MSDOS 6.21, MSDOS.SYS)
 44060                                  
 44061                                  ;----------------------------------------------------------------------------
 44062                                  ;
 44063                                  ; INPUT : ES = segment where program got loaded
 44064                                  ;
 44065                                  ;----------------------------------------------------------------------------
 44066                                  
 44067                                  rpFind1:
 44068                                  	db	0FAh, 0E4h, 21h, 60h, 33h, 0C0h, 0E6h, 43h, 8Bh, 16h
 44069                                  
 44070                                  rpFind1Len equ	$ - rpFind1
 44071                                  
 44072                                  ;	cli
 44073                                  ;	in	al, 21h
 44074                                  ;	pusha
 44075                                  ;	xor	ax, ax
 44076                                  ;	out	43h, al
 44077                                  ;	mov	dx, ...
 44078                                  
 44079                                  rpFind1a:
 44080                                  	db	0B0h, 0Eh, 0E6h, 37h, 33h, 0C0h, 0E6h, 0F2h
 44081                                  
 44082                                  rpFind1aLen equ	$ - rpFind1a
 44083                                  
 44084                                  ;	mov	al, 0Eh
 44085                                  ;	out	37h, al
 44086                                  ;	xor	ax, ax
 44087                                  ;	out	0F2h, al
 44088                                  
 44089                                  ; bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI
 44090                                  
 44091                                  rpFind2:
 44092                                  	db	0Fh, 20h, 0C0h
 44093                                  
 44094                                  rpFind2Len equ	$ - rpFind2
 44095                                  
 44096                                  ;	mov	eax, cr0	;may be preceeded by PUSH CX (51h)
 44097                                  
 44098                                  rpFind3:
 44099                                  	db	0Fh, 22h, 0C0h, 0EAh
 44100                                  
 44101                                  rpFind3Len equ	$ - rpFind3
 44102                                  
 44103                                  ;	mov	cr0, eax	;may be preceeded by POP CX (59h)
 44104                                  ;	jmp	far ptr xxx	;change far ptr to go to replace3
 44105                                  ;	mov	ss, bx		;8E D3 ... and come back at or after this
 44106                                  
 44107                                  ; note, there is no rpRepl1 string
 44108                                  
 44109                                  rpRepl2:
 44110                                   	db	66h, 50h, 51h, 0Fh, 20h, 0C0h
 44111                                  
 44112                                  rpRepl2Len equ	$ - rpRepl2
 44113                                  
 44114                                  ;	push	eax
 44115                                  ;	push	cx
 44116                                  ;	mov	eax, cr0
 44117                                  
 44118                                  rpRepl3:
 44119                                  	db	8Eh, 0D3h, 59h, 66h, 58h
 44120                                  
 44121                                  rpRepl3Len equ	$ - rpRepl3
 44122                                  
 44123                                  ;	mov	ss, bx
 44124                                  ;	pop	cx
 44125                                  ;	pop	eax
 44126                                  
 44127                                  ; bug # 2 -- loss of high EAX and ESI on 386+ only if VCPI
 44128                                  
 44129                                  rpFind4:
 44130                                  	db	93h, 58h, 8Bh, 0CCh
 44131                                  
 44132                                  rpFind4Len equ	$ - rpFind4
 44133                                  
 44134                                  ;	xchg	bx, ax
 44135                                  ;	pop	ax
 44136                                  ;	mov	cx, sp
 44137                                  
 44138                                  rpFind5:
 44139                                  	db	0B8h, 0Ch, 0DEh, 0CDh, 67h, 8Bh, 0E1h, 0FFh, 0E3h
 44140                                  
 44141                                  rpFind5Len equ	$ - rpFind5
 44142                                  
 44143                                  ;	mov	ax, DE0Ch
 44144                                  ;	int	67h
 44145                                  ;	mov	sp, cx
 44146                                  ;	jmp	bx
 44147                                  
 44148                                  rpRepl4:
 44149                                  	db	93h, 58h, 8Bh, 0CCh
 44150                                  	db	02Eh, 066h, 0A3h
 44151                                  
 44152                                  rpRepl4o1Len equ $ - rpRepl4
 44153                                  
 44154                                  	db	00h, 00h
 44155                                  	db	02Eh, 066h, 89h, 36h
 44156                                  
 44157                                  rpRepl4o2Len equ $ - rpRepl4
 44158                                  
 44159                                  	db	00h, 00h
 44160                                  
 44161                                  rpRepl4Len equ	$ - rpRepl4
 44162                                  
 44163                                  ;	xchg	bx, ax
 44164                                  ;	pop	ax
 44165                                  ;	mov	cx, sp
 44166                                  ;	mov	dword ptr cs:[xxxx], eax
 44167                                  ;	mov	dword ptr cs:[xxxx], esi
 44168                                  
 44169                                  rpRepl5:
 44170                                  	db	8Bh, 0E1h
 44171                                  	db	2Eh, 66h, 0A1h
 44172                                  
 44173                                  rpRepl5o1Len equ $ - rpRepl5
 44174                                  
 44175                                  	db	00h, 00h
 44176                                  	db	2Eh, 66h, 8Bh, 36h
 44177                                  
 44178                                  rpRepl5o2Len equ $ - rpRepl5
 44179                                  
 44180                                  	db	00h, 00h
 44181                                  	db	0FFh, 0E3h
 44182                                  
 44183                                  rpRepl5Len equ	$ - rpRepl5
 44184                                  
 44185                                  ;	mov	sp, cx
 44186                                  ;	mov	eax, dword ptr cs:[xxxx]
 44187                                  ;	mov	esi, dword ptr cs:[xxxx]
 44188                                  ;	jmp	bx
 44189                                  
 44190                                  ; bug # 3 -- loss of high EAX, EBX, ECX, EDX on 386+ only if VCPI
 44191                                  
 44192                                  rpFind6:
 44193                                  	db	0FAh, 52h, 51h
 44194                                  
 44195                                  rpFind6Len equ	$ - rpFind6
 44196                                  
 44197                                  ;	cli
 44198                                  ;	push	dx
 44199                                  ;	push	cx
 44200                                  
 44201                                  rpFind7a:
 44202                                  	db	0B8h, 0Ch, 0DEh, 66h, 26h, 0FFh, 1Eh
 44203                                  
 44204                                  rpFind7aLen equ	$ - rpFind7a
 44205                                  
 44206                                  ;	mov	ax, 0DE0Ch
 44207                                  ;	call	fword ptr es:[xxxx]
 44208                                  
 44209                                  rpFind7b:
 44210                                  	db	59h, 5Ah, 5Bh
 44211                                  
 44212                                  rpFind7bLen equ	$ - rpFind7b
 44213                                  
 44214                                  ;	pop	cx
 44215                                  ;	pop	dx
 44216                                  ;	pop	bx
 44217                                  
 44218                                  rpRepl6 :
 44219                                  	db	0FAh, 66h, 50h, 66h, 53h, 66h, 51h, 66h, 52h
 44220                                  
 44221                                  rpRepl6Len equ	$ - rpRepl6
 44222                                  
 44223                                  ;	cli
 44224                                  ;	push	eax
 44225                                  ;	push	ebx
 44226                                  ;	push	ecx
 44227                                  ;	push	edx
 44228                                  
 44229                                  rpRepl7:
 44230                                  	db	66h, 5Ah, 66h, 59h, 66h, 5Bh, 66h, 58h, 5Bh
 44231                                  
 44232                                  rpRepl7Len equ	$ - rpRepl7
 44233                                  
 44234                                  ;	pop	edx
 44235                                  ;	pop	ecx
 44236                                  ;	pop	ebx
 44237                                  ;	pop	eax
 44238                                  ;	pop	bx
 44239                                  
 44240                                  ; bug # 4 -- loss of high EAX and EBX on 386+ only if VCPI
 44241                                  
 44242                                  rpFind8:
 44243                                   	db	60h, 06h, 1Eh, 0B8h, 00h, 00h, 8Eh, 0D8h
 44244                                  
 44245                                  rpFind8Len equ	$ - rpFind8
 44246                                  
 44247                                  ;	pusha
 44248                                  ;	push	es
 44249                                  ;	push	ds
 44250                                  ;	mov	ax, dgroup	;jump back to here from replace8
 44251                                  ;	mov	ds, ax
 44252                                  
 44253                                  rpFind9 :
 44254                                  	db	1Fh, 07h, 61h
 44255                                  
 44256                                  rpFind9Len equ	$ - rpFind9
 44257                                  
 44258                                  ;	pop	ds
 44259                                  ;	pop	es
 44260                                  ;	popa
 44261                                  
 44262                                  rpRepl8:
 44263                                   	db	66h, 60h, 06h, 1Eh
 44264                                  
 44265                                  rpRepl8Len equ	$ - rpRepl8
 44266                                  
 44267                                  ;	pushad
 44268                                  ;	push	es
 44269                                  ;	push	ds
 44270                                  
 44271                                  rpRepl9:
 44272                                  	db	1Fh, 07h, 66h, 61h, 0C3h
 44273                                  
 44274                                  rpRepl9Len equ	$ - rpRepl9
 44275                                  
 44276                                  ;	pop	ds
 44277                                  ;	pop	es
 44278                                  ;	popad
 44279                                  ;	retn			;no need to jmp back to main-line
 44280                                  
 44281                                  ;----------------------------------------------------------------------------
 44282                                  
 44283                                  struc SearchPair
 44284                                   .sp_off1: resw 1	; offset of 1st search string
 44285                                   .sp_len1: resw 1	; length of 1st search string
 44286                                   .sp_off2: resw 1	; 2nd string
 44287                                   .sp_len2: resw 1	; 2nd string
 44288                                   .sp_diff: resw 1	; max difference between offsets
 44289                                   .size:
 44290                                  endstruc
 44291                                  
 44292                                  ;rpBug1Strs SearchPair	<offset rpFind2, rpFind2Len, offset rpFind3, rpFind3Len, 20h>
 44293                                  
 44294                                  rpBug1Strs:
 44295                                  	dw	rpFind2
 44296                                  	dw	rpFind2Len ; 3
 44297                                  	dw	rpFind3
 44298                                  	dw	rpFind3Len ; 4
 44299                                  	dw	20h
 44300                                  
 44301                                  ;rpBug2Strs SearchPair	<offset rpFind4, rpFind4Len, offset rpFind5, rpFind5Len, 80h>
 44302                                  
 44303                                  rpBug2Strs:
 44304                                  	dw	rpFind4
 44305                                  	dw	rpFind4Len ; 4
 44306                                  	dw	rpFind5
 44307                                  	dw	rpFind5Len ; 9
 44308                                  	dw	80h
 44309                                  
 44310                                  ;rpBug3Strs SearchPair	<offset rpFind6, rpFind6Len, offset rpFind7a, rpFind7aLen, 80h>
 44311                                  
 44312                                  rpBug3Strs:
 44313                                  	dw	rpFind6
 44314                                  	dw	rpFind6Len ; 3
 44315                                  	dw	rpFind7a
 44316                                  	dw	rpFind7aLen ; 7
 44317                                  	dw	80h
 44318                                  
 44319                                  ;rpBug4Strs SearchPair	<offset rpFind8, 4, offset rpFind9, rpFind9Len, 80h>
 44320                                  
 44321                                  rpBug4Strs:
 44322                                  	dw	rpFind8
 44323                                  	dw	4
 44324                                  	dw	rpFind9
 44325                                  	dw	rpFind9Len ; 3
 44326                                  	dw	80h
 44327                                  
 44328                                  ;----------------------------------------------------------------------------
 44329                                  
 44330                                  struc StackVars
 44331                                   .sv_wVersion:	resw 1		; Rational extender version #
 44332                                   .sv_cbCodeSeg: resw 1		; code seg size to scan
 44333                                   .sv_pPatch:	resw 1		; offset of next avail patch byte
 44334                                   .size:
 44335                                  endstruc
 44336                                  
 44337                                  ;----------------------------------------------------------------------------
 44338                                  
 44339                                  ; 22/05/2019 - Retro DOS v4.0
 44340                                  
 44341                                  Rational386Patch:
 44342                                  	; Do a few quick checks to see if this looks like a Rational
 44343                                  	; Extended application. Hopefully this will quickly weed out
 44344                                  	; most non Rational apps.
 44345                                  
 44346                                  	cmp	word [es:0],395		; version number goes here - versions
 44347                                  	jae	short rp3QuickOut	;   3.95+ don't need patching
 44348                                  
 44349                                  	cmp	word [es:0Ch],20h	; always has this value here
 44350                                  	jne	short rp3QuickOut
 44351                                  
 44352                                  	push	ax
 44353                                  
 44354                                  	mov	ax,18h 			; extender has 18h at
 44355                                  	cmp	[es:24],ax		;   offsets 24, 28, & 36
 44356                                  	jne	short rp3QO_ax
 44357                                  	cmp	[es:28],ax
 44358                                  	jne	short rp3QO_ax
 44359                                  	cmp	[es:36],ax
 44360                                  	je	short rp3Maybe
 44361                                  rp3QO_ax:
 44362                                  	pop	ax
 44363                                  rp3QuickOut:
 44364                                  	retn
 44365                                  
 44366                                  ; It might be the rational extender, do more extensive checking
 44367                                  
 44368                                  rp3Maybe:
 44369                                  	cld
 44370                                  	push	bx			; note ax pushed above
 44371                                  	push	cx
 44372                                  	push	dx
 44373                                  	push	si
 44374                                  	push	di
 44375                                  	push	es
 44376                                  	push	ds			; we use all of them
 44377                                  	push	bp
 44378                                  	sub	sp,StackVars.size  ; 6	; make space for stack variables
 44379                                  	mov	bp,sp
 44380                                  
 44381                                  	push	cs
 44382                                  	pop	ds
 44383                                  
 44384                                  	mov	ax,[es:0]		; save version #
 44385                                  	;mov	[bp+StackVars.sv_wVersion],ax
 44386                                  	mov	[bp],ax	
 44387                                  					; check that binary version # matches
 44388                                  	call	VerifyVersion		;   ascii string
 44389                                  	jne	short rp3Exit_j
 44390                                  
 44391                                  ; Looks like this is it, find where to put the patch code.  The
 44392                                  ; patch will be located on top of Rational code specific to 80286
 44393                                  ; processors, so these patchs MUST NOT be applied if running on
 44394                                  ; an 80286 system.
 44395                                  
 44396                                  	; Rational says the code to patch will never be beyond offset 46xxh
 44397                                  
 44398                                  	mov	cx,4500h		; force search len to 4700h (searches
 44399                                  	;mov	[bp+2],cx
 44400                                  	mov	[bp+StackVars.sv_cbCodeSeg],cx	; start at offset 200h)
 44401                                  
 44402                                  	mov	es,[es:20h]		; es=code segment
 44403                                  
 44404                                  	mov	si,rpFind1		; string to find
 44405                                  	mov	dx,rpFind1Len ; 10	; length to match
 44406                                  	call	ScanCodeSeq		; look for code seq
 44407                                  	jz	short rpGotPatch
 44408                                  
 44409                                  ; According to Rational, some very old versions of the extender may not
 44410                                  ; have the find1 code sequence. If the find1 code wasn't found above,
 44411                                  ; try an alternative patch area which is on top of NEC 98xx switching code.
 44412                                  
 44413                                  	mov	si,rpFind1a
 44414                                  	mov	dx,rpFind1aLen  ;8
 44415                                  	call	ScanCodeSeq
 44416                                  	jz	short rpGotPatch
 44417                                  
 44418                                  rp3Exit_j:
 44419                                  	jmp	rp3Exit
 44420                                  
 44421                                  ; Found the location to write patch code! DI = offset in code seg.
 44422                                  
 44423                                  rpGotPatch:
 44424                                  	;mov	[bp+4],di
 44425                                  	mov	[bp-StackVars.sv_pPatch],di	; save patch pointer
 44426                                  
 44427                                  ;----------------------------------------------------------------------------
 44428                                  ; Bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI
 44429                                  
 44430                                  	;cmp	word [bp+0],381
 44431                                  	;cmp	word [bp+StackVars.sv_wVersion],381 ; only need bug 1 if version
 44432                                  	cmp	word [bp],381
 44433                                  	jae	short rpBug2			;   < 3.81
 44434                                  
 44435                                  	mov	bx,rpBug1Strs			; locate find2 & find3 code
 44436                                  	call	FindBadCode
 44437                                  	jc	short rpBug2
 44438                                  
 44439                                  ; si = rpFind2 offset, di = rpFind3 offset
 44440                                  
 44441                                  	push	di
 44442                                  	mov	di,si				; rpFind2 offset
 44443                                  	mov	dx,rpFind2Len ; 3
 44444                                  
 44445                                  	cmp	byte [es:di-1],51h	 	; find2 preceeded by push cx?
 44446                                  	jne	short rp_no_cx
 44447                                  
 44448                                  	dec	di				;   yes, gobble up push cx too
 44449                                  	inc	dx
 44450                                  rp_no_cx:
 44451                                  	mov	si,rpRepl2			; patch out find2 sequence
 44452                                  	mov	cx,rpRepl2Len  ; 6
 44453                                  	call	GenPatch
 44454                                  
 44455                                  	pop	di				; rpFind3 offset
 44456                                  	cmp	byte [es:di-1],59h 		; find3 preceeded by pop cx?
 44457                                  	jne	short rp_no_cx2
 44458                                  
 44459                                  	mov	byte [es:di-1],90h		;   yes, no-op it
 44460                                  rp_no_cx2:
 44461                                  	;mov	ax,[bp+4]
 44462                                  	mov	ax,[bp+StackVars.sv_pPatch]	; change offset of far jmp
 44463                                  	;mov	[es:di+4],ax
 44464                                  	mov	[es:di+rpFind3Len],ax		;   to go to patch code
 44465                                  
 44466                                  	push	di				; save find3 offset
 44467                                  	mov	si,rpRepl3			; copy repl3 to patch area
 44468                                  	mov	cx,rpRepl3Len ; 5
 44469                                  	call	CopyPatch
 44470                                  
 44471                                  	pop	bx				; find3 offset
 44472                                  	add	bx,rpFind3Len+4	 ; 8		; skip over find3 and far jmp
 44473                                  	call	GenJump 			; jmp back from patch area
 44474                                  	;mov	[bp+4],di
 44475                                  	mov	[bp+StackVars.sv_pPatch], di	;   to main-line, update patch
 44476                                  						;   area pointer
 44477                                  
 44478                                  ;----------------------------------------------------------------------------
 44479                                  ; Bug # 2 -- loss of high regs on 386+ under VCPI only
 44480                                  
 44481                                  rpBug2:
 44482                                  	mov	bx,rpBug2Strs			; locate find4 & find5 code
 44483                                  	call	FindBadCode
 44484                                  	jc	short rpBug3
 44485                                  
 44486                                  ; si = rpFind4 offset, di = rpFind5 offset
 44487                                  
 44488                                  	;push	word [bp+4]
 44489                                  	push	word [bp+StackVars.sv_pPatch]	; save current patch pointer
 44490                                  						;   (where repl4 goes)
 44491                                  	push	di				; save find5 offset
 44492                                  
 44493                                  	mov	di,si
 44494                                  	mov	dx,rpFind4Len ; 4
 44495                                  	mov	si,rpRepl4
 44496                                  	mov	cx,rpRepl4Len ; 15
 44497                                  	call	GenPatch			; patch out find4 code
 44498                                  
 44499                                  	pop	di				; find5 offset
 44500                                  	add	di,5				; keep 5 bytes of find5 code
 44501                                  	;mov	bx,[bp+4]
 44502                                  	mov	bx,[bp+StackVars.sv_pPatch]	; jump to patch area
 44503                                  	push	bx				; save repl5 location
 44504                                  	call	GenJump
 44505                                  
 44506                                  	mov	si,rpRepl5			; copy repl5 code to patch
 44507                                  	mov	cx,rpRepl5Len  ; 15		;   area -- it has a jmp bx
 44508                                  	call	CopyPatch			;   so no need to jmp back to
 44509                                  						;   main-line code
 44510                                  
 44511                                  ; patches have been made, now update the patch code to store/load dwords just
 44512                                  ; after the code in the patch area
 44513                                  
 44514                                  	pop	di				; repl5 location
 44515                                  	pop	si				; repl4 location
 44516                                  
 44517                                  	;mov	ax,[bp+4]
 44518                                  	mov	ax,[bp+StackVars.sv_pPatch]	; (where dwords go)
 44519                                  
 44520                                  	;mov	[es:si+7],ax
 44521                                  	mov	[es:si+rpRepl4o1Len],ax		; offset for EAX
 44522                                  	;mov	[es:di+5],ax
 44523                                  	mov	[es:di+rpRepl5o1Len],ax
 44524                                  	add	ax,4
 44525                                  	;mov	[es:si+0Dh],ax
 44526                                  	mov	[es:si+rpRepl4o2Len],ax		; offset for ESI
 44527                                  	;mov	[es:di+0Bh],ax
 44528                                  	mov	[es:di+rpRepl5o2Len],ax
 44529                                  
 44530                                  	;add	word [bp+4],8
 44531                                  	add	word [bp+StackVars.sv_pPatch],8	; reserve space for 2 dwords in
 44532                                  						; patch area
 44533                                  
 44534                                  ;----------------------------------------------------------------------------
 44535                                  ; Bug # 3 -- loss of high regs on 386+ under VCPI only
 44536                                  
 44537                                  rpBug3:
 44538                                  	mov	bx,rpBug3Strs			; locate find6 & find7a code
 44539                                  	call	FindBadCode
 44540                                  	jc	short rpBug4
 44541                                  
 44542                                  	;add	di,9
 44543                                  	add	di,rpFind7aLen + 2		; skip over offset in find7a
 44544                                  	push	si				;   code and locate find7b
 44545                                  	mov	si,rpFind7b			;   sequence
 44546                                  	mov	dx,rpFind7bLen ; 3
 44547                                  	call	ScanCodeSeq_di
 44548                                  	pop	si
 44549                                  	jnz	short rpBug4
 44550                                  
 44551                                  	push	di				; save find7b code offset
 44552                                  
 44553                                  	mov	di,si
 44554                                  	mov	dx,rpFind6Len ; 3
 44555                                  	mov	si,rpRepl6
 44556                                  	mov	cx,rpRepl6Len ; 9
 44557                                  	call	GenPatch			; patch out find6 code
 44558                                  
 44559                                  	pop	di
 44560                                  	mov	dx,rpFind7bLen ; 3
 44561                                  	mov	si,rpRepl7
 44562                                  	mov	cx,rpRepl7Len ; 9
 44563                                  	call	GenPatch			; patch out find7b code
 44564                                  
 44565                                  ;----------------------------------------------------------------------------
 44566                                  ; Bug # 4 -- loss of high regs on 386+ under VCPI only
 44567                                  
 44568                                  rpBug4:
 44569                                  	;cmp	word [bp+0],360
 44570                                  	;cmp	word [bp+StackVars.sv_wVersion],360 ; only applies if 
 44571                                  	cmp	word [bp],360
 44572                                  	jbe	short rp3Exit 			; version > 3.60 and < 3.95
 44573                                  
 44574                                  	mov	bx,rpBug4Strs			; locate find8 & find9 code
 44575                                  	call	FindBadCode
 44576                                  	jc	short rp3Exit
 44577                                  
 44578                                  	push	di				; save find9 code offset
 44579                                  
 44580                                  	mov	di,si
 44581                                  	mov	dx,3
 44582                                  	mov	si,rpRepl8
 44583                                  	mov	cx,rpRepl8Len ; 4
 44584                                  	call	GenPatch			; patch out find8 code
 44585                                  
 44586                                  	pop	di				; find9 offset
 44587                                  	;mov	bx,[bp+4]
 44588                                  	mov	bx,[bp+StackVars.sv_pPatch]	; patch find9 to jmp to
 44589                                  	call	GenJump 			;   patch area
 44590                                  
 44591                                  	mov	si,rpRepl9			; copy replacement code to
 44592                                  	mov	cx,rpRepl9Len ; 5		;   patch area--it does a RET
 44593                                  	call	CopyPatch			;   so no jmp back to main-line
 44594                                  
 44595                                  rp3Exit:
 44596                                  	add	sp,StackVars.size
 44597                                  	pop	bp
 44598                                  	pop	ds
 44599                                  	pop	es
 44600                                  	pop	di
 44601                                  	pop	si
 44602                                  	pop	dx
 44603                                  	pop	cx
 44604                                  	pop	bx
 44605                                  	pop	ax
 44606                                  	retn
 44607                                  
 44608                                  ;----------------------------------------------------------------------------
 44609                                  ;
 44610                                  ; FindBadCode
 44611                                  ;
 44612                                  ; Searches Rational code segment looking for a pair of find strings (all
 44613                                  ; patches have at least two find strings).
 44614                                  ;
 44615                                  ; Entry:
 44616                                  ;	ES    = code segment to search
 44617                                  ;	DS:BX = search pair structure for this search
 44618                                  ;	[bp].sv_cbCodeSeg = length of code seg to search
 44619                                  ;
 44620                                  ; Exit:
 44621                                  ;	CY flag clear if both strings found, and
 44622                                  ;	SI    = offset in ES of 1st string
 44623                                  ;	DI    = offset in ES of 2nd string
 44624                                  ;	CY set if either string not found, or strings too far apart
 44625                                  ;
 44626                                  ; Used:
 44627                                  ;	CX
 44628                                  ;
 44629                                  ;----------------------------------------------------------------------------
 44630                                  
 44631                                  ;struc SearchPair
 44632                                  ; .sp_off1: resw 1	; offset of 1st search string
 44633                                  ; .sp_len1: resw 1	; length of 1st search string
 44634                                  ; .sp_off2: resw 1	; 2nd string
 44635                                  ; .sp_len2: resw 1	; 2nd string
 44636                                  ; .sp_diff: resw 1	; max difference between offsets
 44637                                  ; .size:
 44638                                  ;endstruc
 44639                                  
 44640                                  FindBadCode:
 44641                                  	;mov	cx,[bp+2]
 44642                                  	mov	cx,[bp+StackVars.sv_cbCodeSeg]	; search length
 44643                                  
 44644                                  	mov	si,[bx]	; mov si,[bx+0]
 44645                                  	;mov	si,[bx+Searchpair.sp_off1] ; ds:si -> search string
 44646                                  	
 44647                                  	;mov	dx,[bx+2]
 44648                                  	mov	dx,[bx+SearchPair.sp_len1] ; dx = search len
 44649                                  	call	ScanCodeSeq
 44650                                  	jnz	short fbc_error		; done if 1st not found
 44651                                  
 44652                                  	push	di			; save 1st string offset
 44653                                  
 44654                                  	;mov	si,[bx+4]
 44655                                  	mov	si,[bx+SearchPair.sp_off2]
 44656                                  	;mov	dx,[bx+6]
 44657                                  	mov	dx,[bx+SearchPair.sp_len2]
 44658                                  	call	ScanCodeSeq_di		; don't change flags after this!
 44659                                  
 44660                                  	pop	si			; restore 1st string offset
 44661                                  	jnz	short fbc_error
 44662                                  
 44663                                  	mov	ax,di			; sanity check that
 44664                                  	sub	ax,si			;   si < di && di - si <= allowed diff
 44665                                  	jc	short fbc_error
 44666                                  	;cmp	ax,[bx+8]
 44667                                  	cmp	ax,[bx+SearchPair.sp_diff]
 44668                                  	ja	short fbc_error
 44669                                  
 44670                                  	clc
 44671                                  	retn
 44672                                  
 44673                                  fbc_error:
 44674                                  	stc
 44675                                  	retn
 44676                                  
 44677                                  ;----------------------------------------------------------------------------
 44678                                  ;
 44679                                  ; GenPatch
 44680                                  ;
 44681                                  ; Generate a patch sequence. 1) insert a jump at the buggy code location
 44682                                  ; (jumps to the patch code area), 2) copy the selected patch code to the
 44683                                  ; patch area, 3) insert a jump from the patch area back to the main-line
 44684                                  ; code.
 44685                                  ;
 44686                                  ; Entry:
 44687                                  ;	ES:DI = start of buggy code to be patched
 44688                                  ;	DX    = length of buggy code to be patched
 44689                                  ;	DS:SI = replacement patch code
 44690                                  ;	CX    = length of replacement patch code
 44691                                  ;	[bp].sv_pPatch = offset in ES of where to copy patch code
 44692                                  ;
 44693                                  ; Exit:
 44694                                  ;	DI, [bp].sv_pPatch = byte after generated patch code
 44695                                  ;
 44696                                  ; Used:
 44697                                  ;	AX, BX, SI, Flags
 44698                                  ;
 44699                                  ;----------------------------------------------------------------------------
 44700                                  
 44701                                  GenPatch:
 44702                                  	push	di			;save offset of buggy code
 44703                                  
 44704                                  	;mov	bx,[bp+4]
 44705                                  	mov	bx,[bp+StackVars.sv_pPatch]
 44706                                  					;jump from buggy code to patch area
 44707                                  	call	GenJump
 44708                                  
 44709                                  	call	CopyPatch		;copy replacement code to patch area
 44710                                  
 44711                                  	pop	bx			;offset of buggy code + buggy code
 44712                                  	add	bx,dx			;  length = return from patch offset
 44713                                  
 44714                                  	call	GenJump 		;jump from patch area back to main-
 44715                                  	;mov	[bp+4],di
 44716                                  	mov	[bp+StackVars.sv_pPatch],di
 44717                                  					;  line code, update patch pointer
 44718                                  	retn
 44719                                  
 44720                                  ;----------------------------------------------------------------------------
 44721                                  ;
 44722                                  ; CopyPatch
 44723                                  ;
 44724                                  ; Copies patch code to patch location.
 44725                                  ;
 44726                                  ; Entry:
 44727                                  ;	DS:SI = patch code to be copied
 44728                                  ;	ES    = segment of code to patch
 44729                                  ;	CX    = length of code to copy
 44730                                  ;	[bp].sv_pPatch = offset in ES of where to copy patch code
 44731                                  ;
 44732                                  ; Exit:
 44733                                  ;	DI, [bp].sv_pPatch = byte after copied patch code
 44734                                  ;
 44735                                  ; Used:
 44736                                  ;	SI, Flags
 44737                                  ;
 44738                                  ;----------------------------------------------------------------------------
 44739                                  
 44740                                  CopyPatch:
 44741                                  	push	cx
 44742                                  	;mov	di,[bp+4]
 44743                                  	mov	di,[bp+StackVars.sv_pPatch] ;patch pointer is the dest offset
 44744                                  	cld
 44745                                  	rep movsb
 44746                                  	pop	cx
 44747                                  	;mov	[bp+4],di
 44748                                  	mov	[bp+StackVars.sv_pPatch],di ;update net pointer location
 44749                                  	retn
 44750                                  
 44751                                  ;----------------------------------------------------------------------------
 44752                                  ;
 44753                                  ; GenJump
 44754                                  ;
 44755                                  ; Generates a rel16 JMP instruction at location 'from' to location 'to'.
 44756                                  ;
 44757                                  ; Entry:
 44758                                  ;	ES:DI = from location (where to put jmp instruction)
 44759                                  ;	BX    = to location (where to jump to)
 44760                                  ;
 44761                                  ; Exit:
 44762                                  ;	DI = byte after generated jump
 44763                                  ;
 44764                                  ; Used:
 44765                                  ;	AX
 44766                                  ;
 44767                                  ;----------------------------------------------------------------------------
 44768                                  
 44769                                  GenJump:
 44770                                  	mov	al,0E9h		; jmp rel16 opcode
 44771                                  	stosb
 44772                                  
 44773                                  	mov	ax,bx		; calc offset to 'to' location
 44774                                  	sub	ax,di
 44775                                  	sub	ax,2
 44776                                  
 44777                                  	stosw			; output offset
 44778                                  
 44779                                  	retn
 44780                                  
 44781                                  ;----------------------------------------------------------------------------
 44782                                  ;
 44783                                  ; ScanCodeSeq
 44784                                  ;
 44785                                  ; Looks for a pattern pointed to by DS:SI & len DX in ES:200 to ES:200+CX-1
 44786                                  ;
 44787                                  ; returns in ES:DI the start of the pattern if Zero flag is set
 44788                                  ;
 44789                                  ;----------------------------------------------------------------------------
 44790                                  
 44791                                  ScanCodeSeq:
 44792                                  	mov	di,200h
 44793                                  ScanCodeSeq_di:
 44794                                  	push	cx
 44795                                  	sub	cx,dx
 44796                                  	inc	cx
 44797                                  scsagain:
 44798                                  	push	si
 44799                                  	push	di
 44800                                  	push	cx
 44801                                  	mov	cx,dx
 44802                                  	rep	cmpsb
 44803                                  	pop	cx
 44804                                  	pop	di
 44805                                  	pop	si
 44806                                  	je	short scsfound
 44807                                  	inc	di
 44808                                  	loop	scsagain
 44809                                  scsfound:
 44810                                  	pop	cx
 44811                                  vvexit:		; 18/12/2022
 44812                                  	retn
 44813                                  	
 44814                                  ;----------------------------------------------------------------------------
 44815                                  ;
 44816                                  ; VerifyVersion
 44817                                  ;
 44818                                  ; Checks whether the binary version from ES:0 matches the ASCII version
 44819                                  ; from ES:2A.
 44820                                  ;
 44821                                  ;       Entry: AX = binary version number 
 44822                                  ;       Exit : Z flag set if version numbers match
 44823                                  ;
 44824                                  ;----------------------------------------------------------------------------
 44825                                  
 44826                                  VerifyVersion:
 44827                                  	mov	si,[es:2Ah]		; offset of version number
 44828                                  					;  in ascii
 44829                                  	mov	bl,10
 44830                                  	add	si,3			; point to last digit
 44831                                  
 44832                                  	call	VVDigit
 44833                                  	jne	short vvexit
 44834                                  	call	VVDigit
 44835                                  	jne	short vvexit
 44836                                  	cmp	byte [es:si],'.'
 44837                                  	jne	short vvexit
 44838                                  	dec	si
 44839                                  	;call	VVDigit
 44840                                  	; 18/12/2022
 44841                                  	;jmp	short VVDigit
 44842                                  ;vvexit:
 44843                                  	;retn
 44844                                  VVDigit:
 44845                                  	div	bl
 44846                                  	add	ah,'0'
 44847                                  	dec	si
 44848                                  	cmp	[es:si+1],ah
 44849                                  	mov	ah,0			; do not xor or sub we need Z
 44850                                  	retn
 44851                                  
 44852                                  %endif
 44853                                  
 44854                                  ;-----------------------------------------------------------------------
 44855                                  
 44856                                  ; 23/05/2019 - Retro DOS v4.0
 44857                                  ; DOSCODE:B702h (MSDOS 6.21, MSDOS.SYS)
 44858                                  
 44859                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 44860                                  ; DOSCODE:B3E0h (MSDOS 5.0, MSDOS.SYS)
 44861                                  
 44862                                  exepatch_start:	 ; label byte
 44863                                  
 44864                                  	; The following is the code that'll be layed over the buggy unpack
 44865                                  	; code.
 44866                                  str1:
 44867 00007DE8 06                      	db  06h	  		;push	es		 
 44868 00007DE9 8CD8                    	db  8Ch,0D8h		;mov	ax,ds 
 44869                                  
 44870                                  first_stop equ	$-str1
 44871                                  			
 44872 00007DEB 2BC2                    	db  2Bh, 0C2h		;sub	ax, dx			
 44873                                  
 44874                                  first:  ; label	byte
 44875                                  
 44876 00007DED 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 44877 00007DEF 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 44878 00007DF1 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 44879 00007DF4 57                      	db  57h	    		;push	di
 44880 00007DF5 B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 44881 00007DF8 B0FF                    	db  0B0h,0FFh 		;mov	al,0FFH 		
 44882 00007DFA F3AE                    	db  0F3h,0AEh 		;repz	scasb			
 44883 00007DFC 47                      	db  47h	    		;inc	di			
 44884 00007DFD 8BF7                    	db  8Bh,0F7h  		;mov	si,di			
 44885 00007DFF 5F                      	db  5Fh	    		;pop	di
 44886 00007E00 58                      	db  58h	    		;pop	ax
 44887                                  
 44888                                  second_stop equ	$-first
 44889                                  
 44890 00007E01 2BC2                    	db  2Bh,0C2h  		;sub	ax, dx			
 44891                                  
 44892                                  second: ; label	byte
 44893                                  
 44894 00007E03 8EC0                    	db  8Eh,0C0h  		;mov	es,ax			
 44895                                  		    		;NextRec:				
 44896 00007E05 B90402                  	db  0B9h,04h,02h	;mov	cx, 0204h
 44897                                  		    		;norm_agn:				
 44898 00007E08 8BC6                    	db  8Bh,0C6h		;mov	ax,si			
 44899 00007E0A F7D0                    	db  0F7h,0D0h		;not	ax		
 44900 00007E0C D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 44901 00007E0E 7413                    	db  74h,13h		;jz	short SI_ok			
 44902 00007E10 8CDA                    	db  8Ch,0DAh		;mov	dx,ds			
 44903 00007E12 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H
 44904 00007E15 2BD0                    	db  2Bh,0D0h		;sub	dx,ax			
 44905 00007E17 7308                    	db  73h,08h		;jnc	short SItoDS			
 44906 00007E19 F7DA                    	db  0F7h,0DAh		;neg	dx			
 44907 00007E1B D3E2                    	db  0D3h,0E2h		;shl	dx,cl			
 44908 00007E1D 2BF2                    	db  2Bh,0F2h		;sub	si,dx			
 44909 00007E1F 33D2                    	db  33h,0D2h		;xor	dx,dx			
 44910                                  				;SItoDS: 				
 44911 00007E21 8EDA                    	db  8Eh,0DAh		;mov	ds,dx		
 44912                                  				;SI_ok:					
 44913 00007E23 87F7                    	db  87h,0F7h		;xchg	si,di			
 44914 00007E25 1E                      	db  1Eh			;push	ds			
 44915 00007E26 06                      	db  06h			;push	es			
 44916 00007E27 1F                      	db  1Fh			;pop	ds			
 44917 00007E28 07                      	db  07h			;pop	es			
 44918 00007E29 FECD                    	db  0FEh,0CDh		;dec	ch			
 44919 00007E2B 75DB                    	db  75h,0DBh		;jnz	short norm_agn		
 44920 00007E2D AC                      	db  0ACh		;lodsb			
 44921 00007E2E 92                      	db  92h			;xchg	dx,ax
 44922 00007E2F 4E                      	db  4Eh			;dec	si
 44923 00007E30 AD                      	db  0ADh		;lodsw			
 44924 00007E31 8BC8                    	db  8Bh,0C8h		;mov	cx,ax		
 44925 00007E33 46                      	db  46h			;inc	si		
 44926 00007E34 8AC2                    	db  8Ah,0C2h		;mov	al,dl		
 44927 00007E36 24FE                    	db  24h,0FEh		;and	al,0FEH		
 44928 00007E38 3CB0                    	db  3Ch,0B0h		;cmp	al,RPTREC
 44929 00007E3A 7505                    	db  75h,05h		;jne	short TryEnum
 44930 00007E3C AC                      	db  0ACh		;lodsb				
 44931 00007E3D F3AA                    	db  0F3h,0AAh		;rep stosb			
 44932                                  
 44933                                  ;	db  0EBh,07h,90h	;jmp	short TryNext
 44934 00007E3F EB06                    	db  0EBh,06h		;jmp	short TryNext
 44935                                  
 44936                                  				;TryEnum:
 44937 00007E41 3CB2                    	db  3Ch,0B2h		;cmp	al,ENMREC
 44938 00007E43 756C                    	db  75h,6Ch		;jne	short CorruptExe		
 44939 00007E45 F3A4                    	db  0F3h,0A4h		;rep movsb			
 44940                                  				;TryNext:
 44941                                  
 44942 00007E47 92                      	db  92h			;xchg	dx,ax
 44943                                  ;	db  8Ah,0C2h		;mov	al,dl			
 44944                                  
 44945 00007E48 A801                    	db  0A8h,01h		;test	al,1			
 44946 00007E4A 74B9                    	db  74h,0B9h		;jz	short NextRec			
 44947 00007E4C 9090                    	db  90h,90h		;nop,nop
 44948                                  	
 44949                                  last_stop equ $-second
 44950                                  size_str1 equ $-str1
 44951                                  
 44952                                  	; The following is the code that we need to look for in the exe
 44953                                  	; file.
 44954                                  
 44955                                  scan_patch1: ; label byte
 44956                                  
 44957 00007E4E 8CC3                    	db  8Ch,0C3h		;mov	bx,es			
 44958 00007E50 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 44959 00007E52 2BC2                    	db  2Bh,0C2h		;sub	ax,dx
 44960 00007E54 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 44961 00007E56 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 44962 00007E58 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 44963 00007E5B B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 44964 00007E5E B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 44965 00007E60 F3AE                    	db  0F3h,0AEh		;repz	scasb			
 44966 00007E62 47                      	db  47h			;inc	di			
 44967 00007E63 8BF7                    	db  8Bh,0F7h		;mov	si,di
 44968 00007E65 8BC3                    	db  8Bh,0C3h		;mov	ax,bx			
 44969 00007E67 2BC2                    	db  2Bh,0C2h		;sub	ax, dx
 44970 00007E69 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 44971 00007E6B BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 44972                                  				;NextRec:
 44973 00007E6E B104                    	db  0B1h,04h		;mov	cl,4
 44974 00007E70 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 44975 00007E72 F7D0                    	db  0F7h,0D0h		;not	ax		
 44976 00007E74 D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 44977 00007E76 7409                    	db  74h,09h		;jz	short SI_ok
 44978 00007E78 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 44979 00007E7A 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 44980 00007E7C 8EDA                    	db  8Eh,0DAh		;mov	ds,dx		
 44981 00007E7E 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H	       
 44982                                  	       			;SI_ok:
 44983 00007E81 8BC7                    	db  8Bh,0C7h		;mov	ax,di		
 44984 00007E83 F7D0                    	db  0F7h,0D0h		;not	ax
 44985 00007E85 D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 44986 00007E87 7409                    	db  74h,09h		;jz	short DI_ok
 44987 00007E89 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 44988 00007E8B 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 44989 00007E8D 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 44990 00007E8F 83CFF0                  	db  83h,0CFh,0F0h	;or	di,0FFF0H
 44991                                  				;DI_ok:
 44992                                  
 44993                                  size_scan_patch1 equ $-scan_patch1
 44994                                  
 44995                                  scan_patch2: ; label byte
 44996                                  			
 44997 00007E92 8CC3                    	db  8Ch,0C3h		;mov	bx,es			
 44998 00007E94 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 44999 00007E96 48                      	db  48h			;dec	ax
 45000 00007E97 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 45001 00007E99 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 45002 00007E9B BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 45003 00007E9E B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 45004 00007EA1 B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 45005 00007EA3 F3AE                    	db  0F3h,0AEh		;repz	scasb			
 45006 00007EA5 47                      	db  47h			;inc	di			
 45007 00007EA6 8BF7                    	db  8Bh,0F7h		;mov	si,di
 45008 00007EA8 8BC3                    	db  8Bh,0C3h		;mov	ax,bx			
 45009 00007EAA 48                      	db  48h			;dec	ax
 45010 00007EAB 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 45011 00007EAD BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH		
 45012                                  				;NextRec:
 45013 00007EB0 B104                    	db  0B1h,04h		;mov	cl,4
 45014 00007EB2 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 45015 00007EB4 F7D0                    	db  0F7h,0D0h		;not	ax		
 45016 00007EB6 D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 45017 00007EB8 740A                    	db  74h,0Ah		;jz	short SI_ok
 45018 00007EBA 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 45019 00007EBC 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 45020 00007EBE 8EDA                    	db  8Eh,0DAh		;mov	ds,dx		
 45021 00007EC0 81CEF0FF                	db  81h,0CEh,0F0h,0FFh
 45022                                  				;or	si,0FFF0H
 45023                                  				;SI_ok:
 45024 00007EC4 8BC7                    	db  8Bh,0C7h		;mov	ax,di		
 45025 00007EC6 F7D0                    	db  0F7h,0D0h		;not	ax
 45026 00007EC8 D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 45027 00007ECA 740A                    	db  74h,0Ah		;jz	short DI_ok
 45028 00007ECC 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 45029 00007ECE 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 45030 00007ED0 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 45031 00007ED2 81CFF0FF                	db  81h,0CFh,0F0h,0FFh
 45032                                  				;or	di,0FFF0H
 45033                                  				;DI_ok:
 45034                                  
 45035                                  size_scan_patch2 equ $-scan_patch2
 45036                                  
 45037                                  scan_patch3: ; label byte
 45038                                  
 45039 00007ED6 8CC3                    	db  8Ch,0C3h		;mov	bx,es			
 45040 00007ED8 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 45041 00007EDA 48                      	db  48h			;dec	ax
 45042 00007EDB 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 45043 00007EDD 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 45044 00007EDF BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 45045 00007EE2 B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 45046 00007EE5 B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 45047 00007EE7 F3AE                    	db  0F3h,0AEh		;repz	scasb			
 45048 00007EE9 47                      	db  47h			;inc	di			
 45049 00007EEA 8BF7                    	db  8Bh,0F7h		;mov	si,di
 45050 00007EEC 8BC3                    	db  8Bh,0C3h		;mov	ax,bx			
 45051 00007EEE 48                      	db  48h			;dec	ax
 45052 00007EEF 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 45053 00007EF1 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH		
 45054                                  				;NextRec:
 45055 00007EF4 B104                    	db  0B1h,04h		;mov	cl,4
 45056 00007EF6 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 45057 00007EF8 F7D0                    	db  0F7h,0D0h		;not	ax		
 45058 00007EFA D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 45059 00007EFC 7409                    	db  74h,09h		;jz	short SI_ok
 45060 00007EFE 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 45061 00007F00 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 45062 00007F02 8EDA                    	db  8Eh,0DAh		;mov	ds,dx	
 45063 00007F04 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H	
 45064                                  				;SI_ok:
 45065 00007F07 8BC7                    	db  8Bh,0C7h		;mov	ax,di		
 45066 00007F09 F7D0                    	db  0F7h,0D0h		;not	ax
 45067 00007F0B D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 45068 00007F0D 7409                    	db  74h,09h		;jz	short DI_ok
 45069 00007F0F 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 45070 00007F11 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 45071 00007F13 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 45072 00007F15 83CFF0                  	db  83h,0CFh,0F0h	;or	di,0FFF0H
 45073                                  				;DI_ok:
 45074                                  
 45075                                  size_scan_patch3 equ $-scan_patch3
 45076                                  
 45077                                  scan_com: ; label byte
 45078                                  
 45079 00007F18 AC                      	db  0ACh		;lodsb			
 45080 00007F19 8AD0                    	db  8Ah,0D0h		;mov	dl,al		
 45081 00007F1B 4E                      	db  4Eh			;dec	si
 45082 00007F1C AD                      	db  0ADh		;lodsw			
 45083 00007F1D 8BC8                    	db  8Bh,0C8h		;mov	cx,ax		
 45084 00007F1F 46                      	db  46h			;inc	si		
 45085 00007F20 8AC2                    	db  8Ah,0C2h		;mov	al,dl		
 45086 00007F22 24FE                    	db  24h,0FEh		;and	al,0FEH		
 45087 00007F24 3CB0                    	db  3Ch,0B0h		;cmp	al,RPTREC
 45088 00007F26 7506                    	db  75h,06h		;jne	short TryEnum
 45089 00007F28 AC                      	db  0ACh		;lodsb				
 45090 00007F29 F3AA                    	db  0F3h,0AAh		;rep stosb			
 45091 00007F2B EB0790                  	db  0EBh,07h,90h	;jmp	short TryNext
 45092                                  				;TryEnum:
 45093 00007F2E 3CB2                    	db  3Ch,0B2h		;cmp	al,ENMREC
 45094 00007F30 756B                    	db  75h,6Bh		;jne	short CorruptExe		
 45095 00007F32 F3A4                    	db  0F3h,0A4h		;rep movsb			
 45096                                  				;TryNext:
 45097 00007F34 8AC2                    	db  8Ah,0C2h		;mov	al,dl			
 45098 00007F36 A801                    	db  0A8h,01h		;test	al,1			
 45099                                  ;	db  74h,0BAh		;jz	short NextRec			
 45100                                  
 45101                                  size_scan_com	equ	$-scan_com
 45102                                  
 45103                                  ;-----------------------------------------------------------------------
 45104                                  
 45105                                  ; 23/05/2019 - Retro DOS v4.0
 45106                                  ; DOSCODE:B852h (MSDOS 6.21, MSDOS.SYS)
 45107                                  
 45108                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45109                                  ; DOSCODE:B530h (MSDOS 5.0, MSDOS.SYS)
 45110                                  
 45111                                  ExePatch:
 45112                                  	; 28/12/2022 - Retro DOS v4.1
 45113                                  	;call	ExePackPatch
 45114                                  	;;call	word [ss:RationalPatchPtr]
 45115                                  	;retn
 45116                                  	; 28/12/2022
 45117                                  	;jmp	short ExePackPatch
 45118                                  
 45119                                  ;-----------------------------------------------------------------------
 45120                                  ;
 45121                                  ; Procedure Name 	: ExePackPatch
 45122                                  ;
 45123                                  ; Inputs	 	: DS 			-> DOSDATA
 45124                                  ;			  ES:0 			-> read in image
 45125                                  ;			  ax:cx = start cs:ip of program
 45126                                  ; Output		:		
 45127                                  ;
 45128                                  ;	1. If ES <= 0fffh
 45129                                  ;	   2. if exepack signature ('RB') found
 45130                                  ;	      3. if common code to patch compares (for 3 diff. versions)
 45131                                  ;	       	 4. if rest of the code & checksum compares
 45132                                  ;	  	    5. overlay buggy code with code in 
 45133                                  ;		       doscode:str1.
 45134                                  ;		 6. endif
 45135                                  ;	      7. endif
 45136                                  ;	   8. endif
 45137                                  ;	9. endif
 45138                                  ;
 45139                                  ;
 45140                                  ; Uses			: NONE
 45141                                  ;
 45142                                  ;-----------------------------------------------------------------------
 45143                                  		
 45144                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45145                                  	; 23/05/2019 - Retro DOS v4.0	
 45146                                  ExePackPatch:
 45147 00007F38 53                      	push	bx
 45148 00007F39 8CC3                    	mov	bx,es			; bx has load segment
 45149 00007F3B 81FBFF0F                	cmp	bx,0FFFh		; Q: is the load segment > 64K
 45150 00007F3F 7602                    	jbe	short ep_cont		; N: 
 45151 00007F41 5B                      	pop	bx			; Y: no need to patch
 45152 00007F42 C3                      	retn
 45153                                  ep_cont:
 45154 00007F43 1E                      	push	ds
 45155 00007F44 06                      	push	es
 45156 00007F45 50                      	push	ax
 45157 00007F46 51                      	push	cx
 45158 00007F47 56                      	push	si
 45159 00007F48 57                      	push	di
 45160                                  	
 45161                                  		; M033 - start
 45162                                  		; exepacked programs have an IP of 12h (>=2)
 45163                                  
 45164 00007F49 83E902                  	sub	cx,2			; Q: is IP >=2 
 45165 00007F4C 7303                    	jnb	short epp_1		; N: exit
 45166 00007F4E E9C500                  	jmp	ep_notpacked
 45167                                  					; ax:cx now points to location of
 45168                                  					; 'RB' if this is an exepacked file.
 45169                                  		; M033 - end
 45170                                  epp_1:
 45171 00007F51 89CF                    	mov	di,cx
 45172 00007F53 8EC0                    	mov	es,ax
 45173 00007F55 36893E[8700]            	mov	[ss:UNPACK_OFFSET],di	; save pointer to 'RB' in 
 45174                                  					; unpack_offset
 45175                                  
 45176 00007F5A 26813D5242              	cmp	word [es:di],'RB' ; 4252h
 45177                                  	;ljne	ep_notpacked
 45178 00007F5F 7403                    	je	short epp_2
 45179 00007F61 E9B200                  	jmp	ep_notpacked
 45180                                  epp_2:
 45181 00007F64 0E                      	push	cs
 45182 00007F65 1F                      	pop	ds			; set ds to cs
 45183                                  
 45184                                  	;add	di,6Ch
 45185 00007F66 83C76C                  	add	di,PATCH1_COM_OFFSET	; es:di -> points to place in packed 
 45186                                  					;          file where we hope to find
 45187                                  					;	   scan string. 
 45188                                  
 45189 00007F69 E8B200                  	call	chk_common_str		; check for match
 45190                                  
 45191 00007F6C 7524                    	jnz	short ep_chkpatch2	; Q: does the patch match
 45192                                  					; N: check at patch2_offset
 45193                                  					; Y: check for rest of patch string
 45194 00007F6E BE[4E7E]                	mov	si,scan_patch1
 45195                                  					; ds:si -> scan string 
 45196 00007F71 368B3E[8700]            	mov	di,[ss:UNPACK_OFFSET]	; restore di to point to 'RB'
 45197                                  
 45198                                  	;add	di,28h
 45199                                  	; 07/12/2022
 45200 00007F76 83C728                  	add	di,PATCH1_OFFSET	; es:di -> points to place in packed 
 45201                                  					;          file where we hope to find
 45202                                  					;	   scan string. 
 45203                                  	;mov	cx,68
 45204 00007F79 B94400                  	mov	cx,size_scan_patch1
 45205                                  	;mov	bx,142
 45206 00007F7C BB8E00                  	mov	bx,CHKSUM1_LEN
 45207                                  	;mov	ax,0EF4Eh
 45208 00007F7F B84EEF                  	mov	ax,PATCH1_CHKSUM
 45209 00007F82 E8AD00                  	call	chk_patchsum		; check if patch and chk sum compare
 45210 00007F85 7208                    	jc	short ep_done1		; Q: did we pass the test
 45211                                  					; N: exit
 45212                                  					; Y: overlay code with new 
 45213 00007F87 BE[E87D]                	mov	si,str1
 45214                                  	;mov	cx,102
 45215 00007F8A B96600                  	mov	cx,size_str1
 45216                                  	
 45217 00007F8D F3A4                    	rep	movsb
 45218                                  ep_done1:
 45219 00007F8F E98400                  	jmp	ep_done
 45220                                  
 45221                                  ep_chkpatch2:
 45222                                  	;mov	di,76h
 45223 00007F92 BF7600                  	mov	di,PATCH2_COM_OFFSET	; es:di -> possible location of patch
 45224                                  					; in another version of unpack
 45225 00007F95 E88600                  	call	chk_common_str		; check for match
 45226                                  
 45227 00007F98 7544                    	jnz	short ep_chkpatch3	; Q: does the patch match
 45228                                  					; N: check for patch3_offset
 45229                                  					; Y: check for rest of patch string
 45230                                  
 45231 00007F9A BE[927E]                	mov	si,scan_patch2
 45232                                  					; ds:si -> scan string 
 45233                                  	;mov	di,32h
 45234 00007F9D BF3200                  	mov	di,PATCH2_OFFSET	; es:di -> points to place in packed 
 45235                                  					;          file where we hope to find
 45236                                  	;mov	cx,68			;	   scan string. 
 45237 00007FA0 B94400                  	mov	cx,size_scan_patch2
 45238                                  	;mov	bx,140
 45239 00007FA3 BB8C00                  	mov	bx,CHKSUM2_LEN
 45240                                  	;mov	ax,78B2h
 45241 00007FA6 B8B278                  	mov	ax,PATCH2_CHKSUM
 45242 00007FA9 E88600                  	call	chk_patchsum		; check if patch and chk sum compare
 45243                                  
 45244                                  					; M046 - Start
 45245                                  					; Q: did we pass the test
 45246 00007FAC 7311                    	jnc	short ep_patchcode2		; Y: overlay code with new 
 45247                                  					; N: try with a different chksum
 45248                                  
 45249 00007FAE BE[927E]                	mov	si,scan_patch2
 45250                                  					; ds:si -> scan string 
 45251                                  	;mov	cx,68
 45252 00007FB1 B94400                  	mov	cx,size_scan_patch2
 45253                                  	;mov	bx,129
 45254 00007FB4 BB8100                  	mov	bx,CHKSUM2A_LEN
 45255                                  	;mov	ax,1C47h
 45256 00007FB7 B8471C                  	mov	ax,PATCH2A_CHKSUM
 45257 00007FBA E87500                  	call	chk_patchsum		; check if patch and chk sum compare
 45258                                  					; Q: did we pass the test
 45259 00007FBD 7257                    	jc	short ep_notpacked		; N: try with a different chksum
 45260                                  					; Y: overlay code with new 
 45261                                  						
 45262                                  ep_patchcode2:			       	; M046 - End
 45263 00007FBF BE[E87D]                	mov	si,str1
 45264                                  	;mov	cx,3
 45265 00007FC2 B90300                  	mov	cx,first_stop
 45266 00007FC5 F3A4                    	rep	movsb
 45267 00007FC7 B89048                  	mov	ax,4890h		; ax = opcodes for dec ax, nop
 45268 00007FCA AB                      	stosw
 45269 00007FCB 83C602                  	add	si,2
 45270                                  	;mov	cx,20
 45271 00007FCE B91400                  	mov	cx,second_stop
 45272 00007FD1 F3A4                    	rep	movsb
 45273 00007FD3 AB                      	stosw				; put in dec ax and nop
 45274 00007FD4 83C602                  	add	si,2
 45275                                  	;mov	cx,75
 45276 00007FD7 B94B00                  	mov	cx,last_stop
 45277 00007FDA F3A4                    	rep	movsb
 45278 00007FDC EB38                    	jmp	short ep_done
 45279                                  
 45280                                  ep_chkpatch3:
 45281                                  	;mov	di,74h
 45282 00007FDE BF7400                  	mov	di,PATCH3_COM_OFFSET	; es:di -> possible location of patch
 45283                                  					; in another version of unpack
 45284 00007FE1 E83A00                  	call	chk_common_str		; check for match
 45285                                  
 45286 00007FE4 7530                    	jnz	short ep_notpacked	; Q: does the patch match
 45287                                  					; N: exit
 45288                                  					; Y: check for rest of patch string
 45289 00007FE6 BE[D67E]                	mov	si,scan_patch3
 45290                                  					; ds:si -> scan string 
 45291                                  	;mov	di,32h
 45292 00007FE9 BF3200                  	mov	di,PATCH3_OFFSET	; es:di -> points to place in packed 
 45293                                  					;          file where we hope to find
 45294                                  					;	   scan string. 
 45295                                  	;mov	cx,66
 45296 00007FEC B94200                  	mov	cx,size_scan_patch3
 45297                                  	;mov	bx,139
 45298 00007FEF BB8B00                  	mov	bx,CHKSUM3_LEN
 45299                                  	;mov	ax,4EDEh
 45300 00007FF2 B8DE4E                  	mov	ax,PATCH3_CHKSUM
 45301 00007FF5 E83A00                  	call	chk_patchsum		; check if patch and chk sum compare
 45302 00007FF8 721C                    	jc	short ep_notpacked	; Q: did we pass the test
 45303                                  					; N: exit
 45304                                  					; Y: overlay code with new 
 45305 00007FFA BE[E87D]                	mov	si,str1
 45306                                  	;mv	cx,3
 45307 00007FFD B90300                  	mov	cx,first_stop
 45308 00008000 F3A4                    	rep	movsb
 45309 00008002 B048                    	mov	al,48h			; al = opcode for dec ax
 45310 00008004 AA                      	stosb
 45311 00008005 83C602                  	add	si,2
 45312                                  	;mov	cx,20
 45313 00008008 B91400                  	mov	cx,second_stop
 45314 0000800B F3A4                    	rep	movsb
 45315 0000800D AA                      	stosb				; put in dec ax
 45316 0000800E 83C602                  	add	si,2
 45317                                  	;mov	cx,75
 45318 00008011 B94B00                  	mov	cx,last_stop
 45319 00008014 F3A4                    	rep	movsb
 45320                                  
 45321                                  ep_notpacked:
 45322                                  	;stc
 45323                                  ep_done:
 45324 00008016 5F                      	pop	di
 45325 00008017 5E                      	pop	si
 45326 00008018 59                      	pop	cx
 45327 00008019 58                      	pop	ax
 45328 0000801A 07                      	pop	es
 45329 0000801B 1F                      	pop	ds
 45330 0000801C 5B                      	pop	bx
 45331 0000801D C3                      	retn
 45332                                  
 45333                                  ;-------------------------------------------------------------------------
 45334                                  ;
 45335                                  ; 	Procedure Name	: chk_common_str
 45336                                  ;
 45337                                  ;	Input		: DS = DOSCODE
 45338                                  ;			; ES:DI points to string in packed file
 45339                                  ;
 45340                                  ;	Output		; Z if match else NZ
 45341                                  ;
 45342                                  ;-------------------------------------------------------------------------
 45343                                  
 45344                                  	; 23/05/2019 - Retro DOS v4.0
 45345                                  chk_common_str:
 45346 0000801E BE[187F]                	mov	si,scan_com
 45347                                  					; ds:si -> scan string 
 45348                                  	;mov	cx,32
 45349 00008021 B92000                  	mov	cx,size_scan_com
 45350                                  
 45351 00008024 F3A6                    	repe	cmpsb	       
 45352                                  
 45353                                  					; M046 - start
 45354                                  	; a fourth possible version of these exepacked programs have a 
 45355                                  	; 056h instead of 06Bh. See scan_com above
 45356                                  	;
 45357                                  	; 	db  75h, 6Bh		;jne CorruptExe		
 45358                                  	;
 45359                                  	; If the mismatch at this point is due to a 56h instead of 6Bh 
 45360                                  	; we shall try to match the rest of the string
 45361                                  	;
 45362                                  
 45363 00008026 7409                    	jz	short ccs_done
 45364 00008028 26807DFF56              	cmp	byte [es:di-1],56h
 45365 0000802D 7502                    	jnz	short ccs_done
 45366                                  
 45367 0000802F F3A6                    	repe	cmpsb	    
 45368                                  ccs_done:				; M046 - end
 45369 00008031 C3                      	retn
 45370                                  
 45371                                  ;-------------------------------------------------------------------------
 45372                                  ;
 45373                                  ;	Procedure Name	: chk_patchsum
 45374                                  ;
 45375                                  ;	Input		: DS:SI -> string we're looking for
 45376                                  ;			: ES:DI -> offset in packed file
 45377                                  ;			: CX 	= scan length
 45378                                  ;			: BX	= length of check sum
 45379                                  ;			: AX 	= value of check sum
 45380                                  ;
 45381                                  ;	Output		: if patch & check sum compare
 45382                                  ;				NC
 45383                                  ;			  else
 45384                                  ;				CY
 45385                                  ;
 45386                                  ;	Uses		: AX, BX, CX, SI
 45387                                  ;
 45388                                  ;-------------------------------------------------------------------------
 45389                                  
 45390                                  	; 23/05/2019 - Retro DOS v4.0
 45391                                  chk_patchsum:
 45392 00008032 57                      	push	di
 45393                                  
 45394 00008033 F3A6                    	repe	cmpsb			   
 45395                                  
 45396 00008035 7518                    	jnz	short cp_fail		; Q: does the patch match
 45397                                  					; N: exit
 45398                                  					; Y:	
 45399                                  
 45400                                  		; we do a check sum starting from the location of the 
 45401                                  		; exepack signature 'RB' up to 11c/2 bytes, the end of the
 45402                                  		; unpacking code.
 45403                                  
 45404 00008037 368B3E[8700]            	mov	di,[ss:UNPACK_OFFSET]	; di -> start of unpack code
 45405 0000803C 89D9                    	mov	cx,bx			; cx = length of check sum
 45406                                  
 45407 0000803E 89C3                    	mov	bx,ax			; save check sum passed to us in bx
 45408 00008040 31C0                    	xor	ax,ax
 45409                                  ep_chksum:
 45410 00008042 260305                  	add	ax,[es:di]
 45411 00008045 83C702                  	add	di,2
 45412 00008048 E2F8                    	loop	ep_chksum
 45413                                  
 45414 0000804A 5F                      	pop	di			; restore di
 45415                                  
 45416 0000804B 39D8                    	cmp	ax,bx		 	; Q: does the check sum match
 45417                                  	;jne	short cp_fail		; N: exit
 45418                                  					; Y: 
 45419                                  	; 25/09/2023
 45420                                  	;clc	
 45421                                  	;retn
 45422 0000804D 74E2                    	je	short ccs_done ; cf=0
 45423                                  	
 45424                                  cp_fail:
 45425 0000804F F9                      	stc
 45426 00008050 C3                      	retn
 45427                                  
 45428                                  ; 28/12/2022 - Retro DOS v4.1
 45429                                  %if 0
 45430                                  ;--------------------------------------------------------------------------- 
 45431                                  
 45432                                  
 45433                                  ; M020 : BEGIN
 45434                                  ;
 45435                                  ;---------------------------------------------------------------------------
 45436                                  ;
 45437                                  ; procedure : RationalPatch
 45438                                  ;
 45439                                  ; A routine (in Ration DOS extender) which is invoked at hardware interrupts
 45440                                  ; clobbers CX register on 286 machines. (123 release 3 uses Rational DOS
 45441                                  ; extender). This routine identifies Buggy Rational EXEs and fixes the bug.
 45442                                  ;
 45443                                  ; THE BUG is in the following code sequence:
 45444                                  ;
 45445                                  ;8b 0e 10 00	mov	cx, ds:[10h]		; delay count
 45446                                  ;90		even				; word align
 45447                                  ;e2 fe		loop	$			; wait		CLOBBERS CX
 45448                                  ;e8 xx xx	call	set_A20			; enable A20
 45449                                  ;
 45450                                  ; This patch routine replaces the mov & the loop with a far call into a
 45451                                  ; routine in DOS data segment which is in low memory (because A20 line
 45452                                  ; is off). The routine (RatBugCode) in DOS data saves & restores CX around
 45453                                  ; a mov & loop.
 45454                                  ;
 45455                                  ; Identification of Buggy Rational EXE
 45456                                  ; ====================================
 45457                                  ;
 45458                                  ; (ALL OFFSETS ARE IN THE PROGRAM SECTION - EXCLUDING THE EXE HEADER)
 45459                                  ;
 45460                                  ; OFFSET				Contains
 45461                                  ; ------				--------
 45462                                  ; 0000h			100 times Version number in binary
 45463                                  ;			bug exists in version 3.48 thru 3.83 (both inclusive)
 45464                                  ;
 45465                                  ; 000ah			the WORDS : 0000h, 0020h, 0000h, 0040h, 0001h
 45466                                  ;
 45467                                  ; 002ah			offset where version number is stored in ASCII
 45468                                  ;				e.g. '3.48A'
 45469                                  ;
 45470                                  ; 0030h			offset of copyright string. Copyright strings either
 45471                                  ;			start with "DOS/16M Copyright...." or
 45472                                  ;			"Copyright.....". The string contains
 45473                                  ;			"Rational Systems, Inc."
 45474                                  ;
 45475                                  ; 0020h			word : Paragraph offset of the buggy code segment
 45476                                  ;				from the program image
 45477                                  ; 0016h			word : size of buggy code segment
 45478                                  ;
 45479                                  ;	Buggy code is definite to start after offset 200h in its segment
 45480                                  ;
 45481                                  ;----------------------------------------------------------------------------
 45482                                  
 45483                                  ; 23/05/2019 - Retro DOS v4.0
 45484                                  ; DOSCODE:B976h (MSDOS 6.21, MSDOS.SYS)
 45485                                  
 45486                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45487                                  ; DOSCODE:B654h (MSDOS 5.0, MSDOS.SYS)
 45488                                  
 45489                                  RScanPattern1:
 45490                                  	db	0, 0, 20h, 0, 0, 0, 40h, 0, 1, 0
 45491                                  
 45492                                  RLen1 equ $ - RScanPattern1
 45493                                  
 45494                                  RScanPattern2:
 45495                                  	db	8Bh, 0Eh, 10h, 00h, 90h, 0E2h, 0FEh, 0E8h
 45496                                  
 45497                                  RLen2 equ $ - RScanPattern2
 45498                                  
 45499                                  RScanPattern3:
 45500                                  	db	8Bh, 0Eh, 10h, 00h, 0E2h, 0FEh, 0E8h
 45501                                  
 45502                                  RLen3 equ $ - RScanPattern2
 45503                                  
 45504                                  ; DOSCODE:B98Fh (MSDOS 6.21, MSDOS.SYS)
 45505                                  ; DOSCODE:B66Dh (MSDOS 5.0, MSDOS.SYS)
 45506                                  
 45507                                  ;----------------------------------------------------------------------------
 45508                                  ;
 45509                                  ; INPUT : ES = segment where program got loaded
 45510                                  ;
 45511                                  ;----------------------------------------------------------------------------
 45512                                  
 45513                                  RationalPatch:
 45514                                  	cld
 45515                                  	push	ax
 45516                                  	push	bx
 45517                                  	push	cx
 45518                                  	push	dx
 45519                                  	push	si
 45520                                  	push	di
 45521                                  	push	es
 45522                                  	push	ds			; we use all of them
 45523                                  	mov	di,0Ah			; look for pat1 at offset 0Ah
 45524                                  	push	cs
 45525                                  	pop	ds
 45526                                  	
 45527                                  	mov	si,RScanPattern1
 45528                                  	;mov	cx,10
 45529                                  	mov	cx,RLen1
 45530                                  	rep	cmpsb			; do we have the pattern ?
 45531                                  	jne	short rpexit
 45532                                  	mov	ax,[es:0]
 45533                                  	cmp	ax,348			; is it a buggy version ?
 45534                                  	jb	short rpexit
 45535                                  	cmp	ax,383			; is it a buggy version
 45536                                  	ja	short rpexit
 45537                                  
 45538                                  	call	VerifyVersion
 45539                                  	jne	short rpexit
 45540                                  
 45541                                  	mov	cx,[es:16h]		; Length of buggy code seg
 45542                                  	sub	cx,200h			; Length we search (we start
 45543                                  					;  at offset 200h)
 45544                                  	mov	es,[es:20h]		; es=buggy code segment
 45545                                  	mov	si,RScanPattern2
 45546                                  	;mov	dx,8	
 45547                                  	mov	dx,RLen2
 45548                                  	call	ScanCodeSeq		; look for code seq with nop
 45549                                  	jz	short rpfound
 45550                                  
 45551                                  	mov	si,RScanPattern3
 45552                                  	;mov	dx,15
 45553                                  	mov	dx,RLen3
 45554                                  	call	ScanCodeSeq		; look for code seq w/o nop
 45555                                  	jnz	short rpexit
 45556                                  
 45557                                  rpfound:
 45558                                  	
 45559                                  ;	we set up a far call into DOS data
 45560                                  ;	dx has the length of the code seq we were searching for
 45561                                  
 45562                                  	mov	al,9Ah			; far call opcode
 45563                                  	stosb
 45564                                  	mov	ax,RatBugCode
 45565                                  	stosw
 45566                                  	mov	ax,ss
 45567                                  	stosw
 45568                                  	mov	cx,dx
 45569                                  	sub	cx,6			; filler (with NOPs)
 45570                                  	mov	al,90h
 45571                                  	rep	stosb
 45572                                  rpexit:
 45573                                  	pop	ds
 45574                                  	pop	es
 45575                                  	pop	di
 45576                                  	pop	si
 45577                                  	pop	dx
 45578                                  	pop	cx
 45579                                  	pop	bx
 45580                                  	pop	ax
 45581                                  	retn
 45582                                  
 45583                                  ; M020 END
 45584                                  
 45585                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45586                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
 45587                                  
 45588                                  ; DOSCODE:B6D8h (MSDOS 5.0, MSDOS.SYS)
 45589                                  
 45590                                  ;----------------------------------------------------------------------------
 45591                                  ;
 45592                                  ; ScanCodeSeq
 45593                                  ;
 45594                                  ; Looks for a pattern pointed to by DS:SI & len DX in ES:200 to ES:200+CX-1
 45595                                  ;
 45596                                  ; returns in ES:DI the start of the pattern if Zero flag is set
 45597                                  ;
 45598                                  ;----------------------------------------------------------------------------
 45599                                  
 45600                                  ScanCodeSeq:
 45601                                  	; 17/12/2022
 45602                                  	mov	di,200h
 45603                                  ;ScanCodeSeq_di:
 45604                                  	push	cx
 45605                                  	sub	cx,dx
 45606                                  	inc	cx
 45607                                  	; 17/12/2022
 45608                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 45609                                  	;mov	di,200h
 45610                                  scsagain:
 45611                                  	push	si
 45612                                  	push	di
 45613                                  	push	cx
 45614                                  	mov	cx,dx
 45615                                  	rep	cmpsb
 45616                                  	pop	cx
 45617                                  	pop	di
 45618                                  	pop	si
 45619                                  	je	short scsfound
 45620                                  	inc	di
 45621                                  	loop	scsagain
 45622                                  scsfound:
 45623                                  	pop	cx
 45624                                  vvexit:		; 18/12/2022
 45625                                  	retn
 45626                                  
 45627                                  
 45628                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45629                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
 45630                                  
 45631                                  ; DOSCODE:B6F0h (MSDOS 5.0, MSDOS.SYS)
 45632                                  
 45633                                  ;----------------------------------------------------------------------------
 45634                                  ;
 45635                                  ; VerifyVersion
 45636                                  ;
 45637                                  ; Checks whether the binary version from ES:0 matches the ASCII version
 45638                                  ; from ES:2A.
 45639                                  ;
 45640                                  ;       Entry: AX = binary version number 
 45641                                  ;       Exit : Z flag set if version numbers match
 45642                                  ;
 45643                                  ;----------------------------------------------------------------------------
 45644                                  
 45645                                  VerifyVersion:
 45646                                  	mov	si,[es:2Ah]		; offset of version number
 45647                                  					;  in ascii
 45648                                  	mov	bl,10
 45649                                  	add	si,3			; point to last digit
 45650                                  
 45651                                  	call	VVDigit
 45652                                  	jne	short vvexit
 45653                                  	call	VVDigit
 45654                                  	jne	short vvexit
 45655                                  	cmp	byte [es:si],'.' ; 2Eh
 45656                                  	jne	short vvexit
 45657                                  	dec	si
 45658                                  	;call	VVDigit
 45659                                  	; 18/12/2022
 45660                                  	;jmp	short VVDigit
 45661                                  ;vvexit:
 45662                                  	;retn
 45663                                  VVDigit:
 45664                                  	div	bl
 45665                                  	add	ah,'0' ; 30h
 45666                                  	dec	si
 45667                                  	cmp	[es:si+1],ah
 45668                                  	mov	ah,0			; do not xor or sub we need Z
 45669                                  	retn
 45670                                  
 45671                                  ;--------------------------------------------------------------------------- 
 45672                                  %endif	; 28/12/2022
 45673                                  
 45674                                  ;---------------------------------------------------------------------------
 45675                                  ;
 45676                                  ;	M068
 45677                                  ;
 45678                                  ; 	Procedure Name	: IsCopyProt
 45679                                  ;
 45680                                  ;	Inputs		: DS:100 -> start of com file just read in
 45681                                  ;
 45682                                  ;	Outputs		: sets the A20OFF_COUNT variable to 10 if 
 45683                                  ;			  the program loaded in DS:100 uses a MICROSOFT
 45684                                  ;			  copy protect scheme that relies on the A20 line
 45685                                  ;			  being turned off for it's scheme to work.
 45686                                  ;
 45687                                  ;			  Note: The int 21 function dispatcher will turn 
 45688                                  ;				a20 off, if the A20OFF_COUNT is non-zero 
 45689                                  ;				and dec the A20OFF_COUNT before	iretting 
 45690                                  ;				to the user. 
 45691                                  ;
 45692                                  ;	Uses		: ES, DI, SI, CX
 45693                                  ;
 45694                                  ;---------------------------------------------------------------------------
 45695                                  
 45696                                  ; 23/05/2019 - Retro DOS v4.0
 45697                                  
 45698                                  CPStartOffset	EQU	0175h
 45699                                  CPID1Offset	EQU	011Bh
 45700                                  CPID2Offset	EQU	0173h
 45701                                  CPID3Offset	EQU	0146h
 45702                                  CPID4Offset	EQU	0124h
 45703                                  ID1		EQU	05343h
 45704                                  ID2		EQU	05044h
 45705                                  ID3		EQU	0F413h
 45706                                  ID4		EQU	08000h
 45707                                  
 45708                                  ; DOSCODE:B9FAh (MSDOS 6.21, MSDOS.SYS)
 45709                                  
 45710                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45711                                  ; DOSCODE:B71Ch (MSDOS 5.0, MSDOS.SYS)
 45712                                  
 45713                                  CPScanPattern:
 45714 00008051 89264801                	db	89h,26h,48h,01h		 ; mov [148],sp
 45715 00008055 8C0E4C01                	db	8Ch,0Eh,4Ch,01h		 ; mov [14C],cs
 45716 00008059 C7064A010001            	db	0C7h,06h,4Ah,01h,00h,01h ; mov [14A],100h 
 45717 0000805F 8C0E1301                	db 	8Ch,0Eh,13h,01h		 ; mov [113],cs
 45718 00008063 B82001                  	db	0B8h,20h,01h		 ; mov ax,120h
 45719 00008066 BE0001                  	db	0BEh,00h,01h		 ; mov si,100h
 45720                                  
 45721                                  CPSPlen	EQU $ - CPScanPattern
 45722                                  
 45723                                  ; DOSCODE:BA12h (MSDOS 6.21, MSDOS.SYS)
 45724                                  ; DOSCODE:B734h (MSDOS 5.0, MSDOS.SYS)
 45725                                  
 45726                                  IsCopyProt:
 45727 00008069 813E1B014353            	cmp	word [CPID1Offset],ID1
 45728 0000806F 752D                    	jne	short CP_done
 45729                                  
 45730 00008071 813E73014450            	cmp	word [CPID2Offset],ID2
 45731 00008077 7525                    	jne	short CP_done
 45732                                  
 45733 00008079 813E460113F4            	cmp	word [CPID3Offset],ID3
 45734 0000807F 751D                    	jne	short CP_done
 45735                                  
 45736 00008081 813E24010080            	cmp	word [CPID4Offset],ID4
 45737 00008087 7515                    	jne	short CP_done
 45738                                  
 45739 00008089 0E                      	push	cs
 45740 0000808A 07                      	pop	es
 45741 0000808B BF[5180]                	mov	di,CPScanPattern	; es:di -> Pattern to find
 45742                                  
 45743 0000808E BE7501                  	mov	si,CPStartOffset	; ds:si -> possible location 
 45744                                  					; of pattern
 45745                                  
 45746 00008091 B91800                  	mov	cx,CPSPlen ; 24		; cx = length of pattern
 45747 00008094 F3A6                    	repe	cmpsb
 45748 00008096 7506                    	jnz	short CP_done
 45749                                  
 45750 00008098 36C606[8500]0A          	mov	byte [ss:A20OFF_COUNT],0Ah ; M071
 45751                                  CP_done:
 45752 0000809E C3                      	retn
 45753                                  	
 45754                                  ;DOSCODE ENDS
 45755                                  
 45756                                  	;END
 45757                                  
 45758                                  ;----------------------------------------------------------------------------
 45759                                  
 45760                                  ;align 2 ; 05/09/2018 (Error!)
 45761                                  
 45762                                  ; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45763                                  ;align 16 ; 08/09/2018 (OK.)
 45764 0000809F 90                      align 2
 45765                                  
 45766                                  ; 06/08/2018 - Retro DOS v3.0
 45767                                  ;============================================================================
 45768                                  ; MSINIT.ASM
 45769                                  ;============================================================================
 45770                                  ; 22/04/2019 - Retro DOS v4.0 (MSINIT.ASM, MSDOS 6.0, 1991)
 45771                                  ;
 45772                                  ; MAIN ENTRY FOR DOS INITIALIZATION
 45773                                  ;
 45774                                  	; 15/07/2018 - Retro DOS v3.0
 45775                                  	; (MSDOS 3.3, IBMDOS.COM, 1987)
 45776                                  
 45777                                  ; temp iret instruction
 45778                                  
 45779                                  
 45780                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45781                                  ; DOSCODE:B76Ah (MSDOS 5.0, MSDOS.SYS)
 45782                                  
 45783                                  initiret: ; MSDOS 6.0
 45784                                  SYSBUF:
 45785                                  ;IRETT: ; 06/05/2019
 45786 000080A0 CF                      	iret
 45787                                  
 45788                                  ; 22/04/2019 - Retro DOS v4.0
 45789                                  
 45790                                  ; pointer to the BIOS data segment that will be available just to the
 45791                                  ; initialization code
 45792                                  
 45793 000080A1 7000                    InitBioDataSeg:	dw 70h ; KERNEL_SEGMENT = 0070h
 45794                                  
 45795                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45796                                  ; DOSCODE:B76Dh (MSDOS 5.0, MSDOS.SYS)
 45797                                  
 45798                                  ; Convert AX from a number of bytes to a number of paragraphs (round up).
 45799                                  
 45800                                  ParaRound:
 45801 000080A3 83C00F                  	add	ax, 15
 45802 000080A6 D1D8                    	rcr	ax, 1
 45803 000080A8 D1E8                    	shr	ax, 1
 45804 000080AA D1E8                    	shr	ax, 1
 45805 000080AC D1E8                    	shr	ax, 1
 45806 000080AE C3                      	retn
 45807                                  
 45808                                  ; MAIN ENTRY FOR DOS INITIALIZATION
 45809                                  
 45810                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45811                                  	; DOSCODE:B779h (MSDOS 5.0, MSDOS.SYS)
 45812                                  	
 45813                                  	; 30/05/2019
 45814                                  	; 22/04/2019 - Retro DOS v4.0
 45815                                  	; 07/07/2018 - Retro DOS v3.0
 45816                                  	; Retro DOS v2.0 - 03/03/2018
 45817                                  	; 03/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45818                                  	; MSDOS 5.0 - MSDOS.SYS, offset 79A9h
 45819                                  DOSINIT:
 45820                                  	; MSDOS 6.21 - MSDOS.SYS, offset 7C77h
 45821                                  	;
 45822                                  	; Far call from SYSINIT
 45823                                  	; DX = Memory size in paragraphs
 45824                                  	; DS:SI = [DEVICE_LIST] (SYSINIT.S) 
 45825                                  	;	  (Retro DOS v2.0, 16/03/2018)
 45826                                  	;
 45827                                  	; ES:DI = ptr to BIOS communication block (sysinit3.s)
 45828                                  	;	  (Retro DOS v4.0, 20/04/2019)
 45829                                  
 45830 000080AF FA                              CLI
 45831 000080B0 FC                              CLD
 45832                                  
 45833                                  	; 03/11/2022
 45834                                  	;push	dx ; 30/05/2019		; save parameters from BIOS
 45835                                  	
 45836                                  	; 17/12/2022
 45837                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 45838                                  	;push	dx ; =*=		; save parameters from BIOS
 45839                                  	
 45840 000080B1 56                      	push	si
 45841 000080B2 1E                      	push	ds
 45842 000080B3 57                      	push	di			;save di (ptr to BiosComBlock)
 45843                                  
 45844 000080B4 8CC3                    	mov	bx,es			;bx:di = ptr to BiosComBlock
 45845                                  
 45846                                  ; First, move the DOS data segment to its final location in low memory
 45847                                  
 45848                                  	;;mov	ax,0BF69h ; MSDOS 6.21 MSDOS.SYS, file offset 7C7Fh
 45849                                  	;mov	ax,0BC77h ; MSDOS 5.0 MSDOS.SYS, file offset 79B1h	
 45850 000080B6 B8[3085]                	mov	ax,MEMSTRT		; get offset of end of init code
 45851                                  
 45852                                  	;add	ax,15	; 0Fh		; round to nearest paragraph
 45853                                  	;and	ax,~15	; 0FFF0h	; boundary
 45854                                  
 45855                                  	;mov	si,ax			; si = offset of DOSDATA in current 
 45856                                  					; code segment
 45857                                  
 45858                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 45859 000080B9 83C00F                  	add	ax,15			; round to nearest paragraph
 45860 000080BC 83E0F0                  	and	ax,~15			; boundary
 45861                                  
 45862 000080BF 89C6                    	mov	si,ax			; si = offset of DOSDATA in current 
 45863                                  					; code segment
 45864                                  	; 05/12/2022
 45865                                  	; 30/04/2019 - Retro DOS v4.0
 45866                                  	;xor	si,si
 45867                                  	
 45868 000080C1 8CC8                    	mov	ax,cs
 45869 000080C3 8ED8                    	mov	ds,ax			; ds = current code segment
 45870                                  					; DS:SI now points to dosdata
 45871                                  
 45872                                  	;mov	es,[cs:0BA49h] ; MSDOS 6.21 IO.SYS, offset 7C8Eh 
 45873                                  	;mov	es,[cs:InitBioDataSeg]	; First access to DosDataSg in
 45874                                  					;  BData segment. Cannot use
 45875                                  					;  getdseg macro here!!!
 45876                                  	; 17/12/2022
 45877 000080C5 8E06[A180]              	mov	es,[InitBioDataSeg]
 45878                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 45879                                  	;mov	es,[cs:InitBioDataSeg]  ; ds = cs !
 45880                                  
 45881                                  	;mov	es,[es:3]
 45882 000080C9 268E060300              	mov	es,[es:DosDataSg]	; Get free location in low memory
 45883                                  
 45884 000080CE 31FF                    	xor	di,di			; ES:DI now points to RAM data
 45885                                  
 45886                                  	;mov	cx,4970  ; Offset 0BA78h in MSDOS 6.21 MSDOS.SYS)
 45887                                  	;mov	cx,4976  ; 25/05/2019
 45888                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45889                                  	;mov	cx,4962
 45890                                  	;mov	cx,MSDAT001E		; get end of dosdata = size of dosdata
 45891 000080D0 B96D14                  	mov	cx,DOSDATASIZE ; = 4962 for MSDOS 5.0 MSDOS.SYS
 45892 000080D3 F3A4                    	rep	movsb			; move data to final location
 45893                                  	
 45894 000080D5 5F                      	pop	di			; restore ptr to BiosComBlock
 45895 000080D6 1F                      	pop	ds			; restore parms from BIOS
 45896 000080D7 5E                      	pop	si
 45897                                  	; 17/12/2022
 45898                                  	;pop	dx ; 30/05/2019	
 45899                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 45900                                  	;pop	dx ; =*=		
 45901                                  
 45902 000080D8 06                      	push	es
 45903 000080D9 1E                      	push	ds
 45904 000080DA 07                      	pop	es			; es:si -> device chain
 45905 000080DB 1F                      	pop	ds			; ds points to dosdata
 45906                                  
 45907                                  ;SR;
 45908                                  ;We get a ptr to the BIOS exchange data block. This has been setup right 
 45909                                  ;now so that the EXEC call knows when SysInit is present to do the special
 45910                                  ;lie table handling for device drivers. This can be expanded later on to
 45911                                  ;establish a communication block from the BIOS to the DOS.
 45912                                  
 45913                                  	;mov	[1040h],di	; Offset 0BA87h in MSDOS 6.21 MSDOS.SYS)
 45914                                  	;mov	[1042h],bx
 45915 000080DC 893E[A310]              	mov	[BiosDataPtr],di
 45916 000080E0 891E[A510]              	mov	[BiosDataPtr+2],bx	; save ptr to BiosComBlock
 45917                                  
 45918 000080E4 2E8C1E[0700]            	mov	[cs:DosDSeg],ds		; set pointer to dosdata in code seg
 45919                                  
 45920                                  	; Set the segment of Lowint23/24/28Addr in msctrlc.asm to dosdata
 45921                                  
 45922 000080E9 2E8C1E[5E5A]            	mov	[cs:LowInt23Addr+2],ds	; set pointers in code seg
 45923 000080EE 2E8C1E[625A]            	mov	[cs:LowInt24Addr+2],ds
 45924 000080F3 2E8C1E[665A]            	mov	[cs:LowInt28Addr+2],ds
 45925                                  
 45926                                  	;mov	[346h],dx	; MSDOS 6.21 DOSDATA addresses
 45927                                  	;mov	[584h],sp
 45928                                  	;mov	[586h],ss
 45929 000080F8 8916[4603]                  	mov	[ENDMEM],dx	; =*=
 45930 000080FC 8926[8405]              	mov	[USER_SP],sp
 45931 00008100 8C16[8605]              	mov	[USER_SS],ss
 45932                                  
 45933 00008104 8CD8                    	mov	ax,ds		; set up ss:sp to dosdata:dskstack
 45934 00008106 8ED0                    	mov	ss,ax
 45935                                  
 45936                                  	;mov	sp,920h		; MSDOS 6.21 DOSDATA address
 45937                                  	;mov	sp,offset dosdata:dskstack
 45938 00008108 BC[2009]                	mov	sp,DSKSTACK
 45939                                  
 45940                                  ;M023
 45941                                  ; Init patch ptrs to default values
 45942                                  
 45943                                  	;mov	word [1212h],RetExePatch
 45944                                  	;mov	word [1214h],RetExePatch
 45945                                  	;mov	word [61h],RetExePatch
 45946 0000810B C706[880D][0A6C]        	mov	word [FixExePatch],RetExePatch	; M023
 45947                                  	; 28/12/2022 - Retro DOS v4.1
 45948                                  	;mov	word [RationalPatchPtr],RetExePatch ; M023
 45949 00008111 C706[6100][0A6C]        	mov	word [ChkCopyProt],RetExePatch	; M068
 45950                                  
 45951                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 45952                                  %if 0	; 19/09/2023
 45953                                  
 45954                                  ; Setup to call 386 Rational DOS Extender patch routine if running on
 45955                                  ; a 386 or later. Unlike other patches, this is not dependent on MS-DOS
 45956                                  ; running in the HMA.
 45957                                  
 45958                                  	call	WhatCPUType	; get cpu type (0 < 286,1==286,2 >= 386)
 45959                                  	cmp	al,2		;   386 or later?
 45960                                  	mov	ax,Rational386Patch
 45961                                  	jae	short di_set_patch
 45962                                  	mov	ax,RetExePatch	; < 386, don't need this patch
 45963                                  di_set_patch:
 45964                                  	mov	[Rational386PatchPtr],ax ; patch routine or RET instr.
 45965                                  
 45966                                  %endif
 45967                                  	; Set up the variable temp_dosloc to point to the dos code segment
 45968                                  
 45969 00008117 8CC8                    	mov	ax,cs		; ax = current segment of DOS code
 45970                                  
 45971                                  	; ax now holds segment of DOS code
 45972 00008119 A3[AA0A]                	mov	[TEMP_DOSLOC],ax   ; store temp location of DOS
 45973                                  
 45974 0000811C 8C06[4A00]              	mov	word [NULDEV+2],es ; nuldev -> points to device chain
 45975 00008120 8936[4800]              	mov	word [NULDEV],si
 45976                                  ;SR;
 45977                                  ; There are some locations in the Win386 instance data structures
 45978                                  ; which need to be set up with the DOS data segment. First, initialize
 45979                                  ; the segment part of the instance table pointer in the SIS.
 45980                                  
 45981                                  	;mov	[0FF2h],ds ; [Win386_Info+14+2]	
 45982 00008124 8C1E[3710]              	mov	[Win386_Info+Win386_SIS.Instance_Data_Ptr+2],ds
 45983                                  
 45984                                  ; Now initialize the segment part of the pointer to the data in each
 45985                                  ; instance table entry.
 45986                                  
 45987 00008128 56                      	push	si		; preserve pointer to device chain
 45988                                  	; 18/12/2022
 45989                                  	; cx = 0
 45990 00008129 B107                    	mov	cl,7
 45991                                  	;mov	cx,7		; There are 7 entries in the instance table
 45992                                  				; M019
 45993                                  	;mov	si,0FF6h ; offset (dosdata:Instance_Table+2)
 45994 0000812B BE[3F10]                	mov	si,Instance_Table+2 ; point si to segment field
 45995                                  Instance_init_loop:
 45996 0000812E 8C1C                    	mov	[si],ds		; set offset in instance entry
 45997                                  	;add	si,6
 45998 00008130 83C606                  	add	si,size_of_Win386_IIS ; move on to next entry
 45999 00008133 E2F9                    	loop	Instance_init_loop
 46000                                  
 46001                                  ;Initialize the WIN386 2.xx instance table with the DOS data segment value
 46002                                  
 46003                                  	; 18/12/2022
 46004 00008135 B105                    	mov	cl,5
 46005                                  	;mov	cx,5		; There are five entries in the instance table
 46006                                  
 46007                                  	;mov	si,(offset dosdata:OldInstanceJunk) + 6
 46008                                  	;mov	si,11EDh	; point si to segment field
 46009 00008137 BE[3212]                	mov	si,OldInstanceJunk+6
 46010                                  OldInstance_init_loop:
 46011 0000813A 8C1C                    	mov	[si],ds		; set offset in instance entry
 46012 0000813C 83C606                  	add	si,6		; move on to next entry
 46013 0000813F E2F9                    	loop	OldInstance_init_loop
 46014 00008141 5E                      	pop	si		; restore pointer to device chain
 46015                                  
 46016                                  ; End of WIN386 2.xx compatibility bullshit
 46017                                  
 46018                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46019                                  %if 0	
 46020                                     	; 30/04/2019
 46021                                  	;push	es
 46022                                  	;pop	ds
 46023                                  			; ds:si points to console device
 46024                                  
 46025                                  	; 24/04/2019 - Retro DOS v4.0
 46026                                  
 46027                                  	; 15/07/2018
 46028                                  	; MSDOS 3.3 (IBMDOS.COM, 1987)
 46029                                  	; (Set INT 2Ah handler address to an 'IRET')
 46030                                  
 46031                                  	; need crit vector inited to use deviocall
 46032                                  	;push	ds			; preserve segment of device chain
 46033                                  	push	es ; 30/04/2019
 46034                                  
 46035                                  %endif
 46036                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46037 00008142 06                      	push	es
 46038                                  	; 17/12/2022
 46039                                  	;pop	ds
 46040                                  	;push	ds
 46041                                  
 46042 00008143 31C0                    	xor	ax,ax
 46043 00008145 8ED8                    	mov	ds,ax			; point DS to int vector table
 46044 00008147 B8[A080]                	mov	ax,initiret
 46045                                  	;mov	[0A8h],ax  ; [2Ah*4]
 46046 0000814A A3A800                  	mov	[addr_int_ibm],ax
 46047 0000814D 8CC8                    	mov	ax,cs
 46048                                  	;mov	[0AAh],ax  ; [(2Ah*4)+2] 		
 46049 0000814F A3AA00                  	mov	[addr_int_ibm+2],ax
 46050 00008152 1F                      	pop	ds			; restore segment of device chain
 46051                                  
 46052 00008153 E81C02                  	call	CHARINIT  		; initialize console driver
 46053 00008156 56                      	push	si			; save pointer to header
 46054                                  
 46055 00008157 16                      	push	ss			; move pointer to dos data...
 46056 00008158 07                      	pop	es			; ...into ES
 46057                                  
 46058                                  	;initialize sft for file 0 (CON)
 46059                                  
 46060                                          ; 07/07/2018 - Retro DOS v3.0
 46061                                  	; 24/04/2019 - Retro DOS v4.0
 46062                                  	;mov	di,SFTABL+6 
 46063 00008159 BF[D200]                	MOV     DI,SFTABL+SFT.SFTable	; Point to sft 0
 46064 0000815C B80300                          MOV     AX,3
 46065 0000815F AB                              STOSW           	; Refcount
 46066 00008160 FEC8                            DEC     AL
 46067 00008162 AB                              STOSW           	; Access rd/wr, compatibility
 46068 00008163 30C0                            XOR     AL,AL
 46069 00008165 AA                              STOSB           	; attribute
 46070                                  	;mov	al,0C3h
 46071 00008166 B0C3                    	mov	al,devid_device_EOF|devid_device|ISCIN|ISCOUT
 46072 00008168 AB                      	STOSW			; flags
 46073 00008169 89F0                            mov	ax,si
 46074 0000816B AB                              stosw			; device pointer in devptr	
 46075 0000816C 8CD8                            mov	ax,ds
 46076 0000816E AB                      	stosw
 46077 0000816F 31C0                    	xor	ax,ax	; 0
 46078 00008171 AB                      	stosw			; firclus
 46079 00008172 AB                      	stosw			; time
 46080 00008173 AB                      	stosw			; date
 46081 00008174 48                      	dec	ax	; -1
 46082 00008175 AB                      	stosw			; size
 46083 00008176 AB                      	stosw
 46084 00008177 40                      	inc	ax	; 0
 46085 00008178 AB                      	stosw			; position
 46086 00008179 AB                      	stosw
 46087                                  	;add	di,7
 46088 0000817A 83C707                  	add	di,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
 46089                                  				; point at name
 46090                                  	;add	si,10
 46091 0000817D 83C60A                  	add	si,SYSDEV.NAME	; sdevname
 46092                                  				; point to name
 46093 00008180 B90400                  	mov	cx,4
 46094 00008183 F3A5                    	rep	movsw		; name
 46095 00008185 B103                    	mov	cl,3
 46096 00008187 B020                    	mov	al," "
 46097 00008189 F3AA                    	rep	stosb		; extension
 46098                                  
 46099 0000818B 5E                      	pop	si		; get back pointer to header
 46100                                  
 46101                                  				; mark device as CON I/O
 46102                                  	; 15/07/2018
 46103                                          ;OR	BYTE [SI+4],ISCIN|ISCOUT ; or byte [si+4],3
 46104 0000818C 804C0403                	OR	BYTE [SI+SYSDEV.ATT],ISCIN|ISCOUT
 46105                                  	; 12/03/2018
 46106                                  	;mov	[ss:32h],si
 46107 00008190 368936[3200]            	MOV     [SS:BCON],SI
 46108                                  	;mov	[ss:34h],ds
 46109 00008195 368C1E[3400]                    MOV     [SS:BCON+2],DS
 46110                                  
 46111                                  	; initialize each device until the clock device is found
 46112                                  
 46113                                  CHAR_INIT_LOOP:
 46114 0000819A C534                            LDS     SI,[SI]			; AUX device
 46115 0000819C E8D301                  	call	CHARINIT 
 46116                                         	;15/07/2018
 46117                                  	;test	byte [SI+4],8
 46118 0000819F F6440408                	TEST    BYTE [SI+SYSDEV.ATT],ISCLOCK
 46119 000081A3 74F5                            JZ      SHORT CHAR_INIT_LOOP
 46120                                  	; 12/03/2018
 46121                                  	;mov	[ss:2Eh],si
 46122 000081A5 368936[2E00]                    MOV     [SS:BCLOCK],SI
 46123                                  	;mov	[ss:30h],ds
 46124 000081AA 368C1E[3000]                    MOV     [SS:BCLOCK+2],DS
 46125                                          ;MOV	BP,MEMSTRT ; Retro DOS 3.0 ; ES:BP points to DPB
 46126                                  
 46127                                  	;mov	bp,4970			; bp = pointer to free mem
 46128                                  	;mov	bp,4976  ; 25/05/2019 - Retro DOS v4.0
 46129                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
 46130                                  	;mov	bp,4962 ; (MSDOS 5.0 MSDOS.SYS)
 46131 000081AF BD6D14                  	mov	bp,MSDAT001E		; es:bp points to dpb area
 46132                                  
 46133 000081B2 36892E[2600]            	mov	[ss:DPBHEAD],bp		; set offset of pointer to DPB's
 46134 000081B7 368C06[2800]            	mov	[ss:DPBHEAD+2],es	; set segment of pointer to DPB's
 46135                                  PERDRV:
 46136                                  	;lds	si,[SI+SYSDEV.NEXT] ; 15/07/2018
 46137 000081BC C534                            LDS	SI,[SI]			; Next device
 46138 000081BE 83FEFF                          CMP	SI,-1	; 0FFFFh
 46139 000081C1 7479                    	JZ	SHORT CONTINIT
 46140                                  
 46141 000081C3 E8AC01                          call	CHARINIT
 46142                                  
 46143                                  	; Retro DOS v2.0 - 16/03/2018 (NOTE for 'CHARINIT' return):
 46144                                  	; [CALLUNIT] = Number of drives for (Disk) Block Dev Driver ([DRVMAX])
 46145                                  	;           (..When the command is 'DSK$INIT', as in 'CHARINIT')
 46146                                  	; [CALLBPB] = [DEVCALL.COUNT] = Address of the BPB (DEVCALL offset 18)
 46147                                  	; (REF: MSDOS 3.3 MSBIO2.ASM, MSDATA.INC, MSDISK.ASM, MSBIO1.ASM)
 46148                                  	; (.. !DSK$IN' in MSBIO1.ASM)
 46149                                  	; DEVCALL.MEDIA = CALLUNIT (DEVCALL offset 13)
 46150                                  
 46151                                          ; 15/07/2018
 46152                                  	;test	word [SI+4],8000h		; DEVTYP
 46153                                          ; 17/12/2022
 46154                                  	;test	byte [SI+5],80h
 46155 000081C6 F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8) ; 80h
 46156                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP ; 8000h
 46157 000081CA 75F0                    	JNZ     SHORT PERDRV			; Skip any other character devs
 46158                                  
 46159 000081CC 368A0E[6703]                    MOV	CL,[SS:CALLUNIT] ; 12/03/2018
 46160 000081D1 30ED                    	XOR     CH,CH
 46161                                          ; 07/07/2018
 46162                                  	;MOV	[SI+10],CL		; Number of units in name field
 46163 000081D3 884C0A                  	mov	[si+SYSDEV.NAME],cl	; sdevname        
 46164 000081D6 368A16[4600]            	MOV     DL,[SS:NUMIO]	; 15/03/2018
 46165 000081DB 30F6                    	XOR     DH,DH
 46166 000081DD 36000E[4600]            	ADD	[SS:NUMIO],CL	; 12/03/2018
 46167 000081E2 1E                      	PUSH    DS
 46168 000081E3 56                              PUSH    SI
 46169 000081E4 36C51E[6C03]            	LDS	BX,[SS:CALLBPB]	; 12/03/2018
 46170                                  
 46171                                  PERUNIT:
 46172 000081E9 8B37                            MOV     SI,[BX]                 ; DS:SI Points to BPB
 46173 000081EB 43                              INC     BX
 46174 000081EC 43                              INC     BX                      ; On to next BPB
 46175                                  	; 15/12/2022
 46176                                  	; 07/07/2018
 46177                                          ;mov	[ES:BP+DPB.DRIVE],DL
 46178 000081ED 26885600                	MOV     [ES:BP],DL
 46179                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46180                                  	;;mov	[ES:BP+0],DL
 46181                                  	;mov	[ES:BP+DPB.DRIVE],DL
 46182                                  
 46183                                  	;MOV	[ES:BP+1],DH
 46184 000081F1 26887601                	MOV	[ES:BP+DPB.UNIT],DH
 46185 000081F5 53                              PUSH    BX
 46186 000081F6 51                              PUSH    CX
 46187 000081F7 52                              PUSH    DX
 46188                                  
 46189                                          ;invoke	$SETDPB
 46190 000081F8 E88092                          CALL	_$SETDPB		; build DPB!
 46191                                  
 46192                                  	; 07/07/2018
 46193                                  	;MOV	AX,[ES:BP+2]
 46194 000081FB 268B4602                	mov	ax,[ES:BP+DPB.SECTOR_SIZE]
 46195                                          ; 12/03/2018
 46196 000081FF 363B06[3600]            	CMP	AX,[SS:MAXSEC]		; Q:is this the largest sector so far
 46197 00008204 7604                    	JBE     SHORT NOTMAX		; N:
 46198 00008206 36A3[3600]              	MOV	[SS:MAXSEC],AX		; Y: save it in maxsec
 46199                                  NOTMAX:					
 46200                                  	; set the next dpb field in the currently built bpb
 46201                                  	; and mark as never accessed
 46202                                          
 46203                                  	; 24/04/2019
 46204 0000820A 89E8                    	mov	ax,bp			; get pointer to DPB
 46205                                  	;add	ax,33
 46206 0000820C 83C03D                  	add	ax,DPBSIZ		; advance pointer to next DPB
 46207                                  					; set seg & offset of next DPB
 46208                                  	;mov	[es:bp+25],ax
 46209 0000820F 26894619                	mov	[es:bp+DPB.NEXT_DPB],ax
 46210                                  	;mov	[es:bp+27],es
 46211 00008213 268C461B                	mov	[es:bp+DPB.NEXT_DPB+2],es
 46212                                  					; mark as never accessed
 46213                                  	;mov	byte [es:bp+24],0FFh
 46214 00008217 26C64618FF              	mov	byte [es:bp+DPB.FIRST_ACCESS],-1
 46215                                  
 46216 0000821C 5A                      	POP     DX
 46217 0000821D 59                              POP     CX
 46218 0000821E 5B                              POP     BX
 46219 0000821F 8CD8                            MOV     AX,DS                   ; save segment of bpb array
 46220 00008221 5E                              POP     SI
 46221 00008222 1F                              POP     DS
 46222                                  					; ds:si -> device header
 46223                                  					; store it in the corresponding dpb
 46224                                  	; 07/07/2018
 46225                                          ;MOV	[ES:BP+19],SI ; 24/04/2019
 46226 00008223 26897613                	mov	[ES:BP+DPB.DRIVER_ADDR],si
 46227                                          ;MOV	[ES:BP+21],DS ; 24/04/2019
 46228 00008227 268C5E15                	mov	[ES:BP+DPB.DRIVER_ADDR+2],ds
 46229                                  
 46230 0000822B 1E                              PUSH    DS			; save pointer to device header
 46231 0000822C 56                              PUSH    SI
 46232 0000822D FEC6                            INC     DH			; inc unit #
 46233 0000822F FEC2                            INC     DL			; inc drive #
 46234 00008231 8ED8                            MOV     DS,AX			; restore segment of BPB array
 46235                                          ;add	bp,33 ; 24/04/2019
 46236 00008233 83C53D                  	ADD     BP,DPBSIZ		; advance pointer to next dpb
 46237 00008236 E2B1                    	LOOP    PERUNIT			; process all units in each driver
 46238                                          
 46239 00008238 5E                      	POP     SI			; restore pointer to device header
 46240 00008239 1F                              POP     DS
 46241 0000823A EB80                    	JMP	PERDRV			; process all drivers in chain
 46242                                  
 46243                                  CONTINIT:
 46244                                  	; 24/04/2019
 46245                                  	;sub	bp,33			; set link in last DPB to -1
 46246 0000823C 83ED3D                  	sub	bp,DPBSIZ		; back up to last dpb
 46247                                  					; set last link offset & segment
 46248                                  	;mov	word [bp+25],0FFFFh
 46249 0000823F C74619FFFF              	mov	word [bp+DPB.NEXT_DPB],-1
 46250                                  	;mov	word [bp+27],0FFFFh
 46251 00008244 C7461BFFFF              	mov	word [bp+DPB.NEXT_DPB+2],-1
 46252                                  	;add	bp,33
 46253 00008249 83C53D                  	add	BP,DPBSIZ		; advance to free memory again
 46254                                  					; the DPB chain is done.  
 46255 0000824C 16                      	push	ss
 46256 0000824D 1F                      	pop	ds
 46257                                  
 46258 0000824E 89E8                    	mov	ax,bp
 46259 00008250 E850FE                  	call	ParaRound		; round up to segment
 46260                                  
 46261 00008253 8CDA                    	mov	dx,ds			; dx = dosdata segment
 46262 00008255 01C2                    	add	dx,ax			; dx = ds+ax first free segment
 46263                                  
 46264 00008257 BB0F00                  	mov	bx,0Fh
 46265                                  	
 46266                                  	; 24/05/2019
 46267                                  	;mov	cx,[ENDMEM]
 46268                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46269                                  	; 17/12/2022
 46270                                  	;mov	cx,[ENDMEM] 
 46271                                  					; set seg inpacketto dosdata					
 46272 0000825A 8C1E[A203]              	mov	[DSKCHRET+3],ds ; mov [DOSSEG_INIT],ds 
 46273                                  
 46274                                  ; Patch in the segments of the interrupt vectors with current code segment.
 46275                                  ; Also patch in the segment of the pointers in the dosdata area.
 46276                                  ;
 46277                                  ; Note: Formerly, temp_dosloc was initialized to -1 until after these
 46278                                  ; calls were done. The procedure patch_misc_segments is called multiple
 46279                                  ; times, and relies on temp_dosloc being initialized to -1 as a flag
 46280                                  ; for the first invocation. Thus, we must set it to -1 for this call.
 46281                                  
 46282 0000825E 52                      	push	dx			; preserve first free segment
 46283                                  
 46284 0000825F A1[AA0A]                	mov	ax,[TEMP_DOSLOC]	; ax = segment to patch in 
 46285 00008262 8EC0                    	mov	es,ax			; es = segment of DOS
 46286 00008264 C706[AA0A]FFFF          	mov	word [TEMP_DOSLOC],-1	; -1 means first call to patch_misc_segments
 46287                                  
 46288 0000826A E8AF01                  	call	patch_vec_segments	; uses AX as doscode segment
 46289 0000826D E8E401                  	call	patch_misc_segments	; patch in segments for sharer and 
 46290                                  					; other tables with seg in ES.
 46291                                  	; 17/12/2022
 46292                                  	; cx = 0
 46293 00008270 8C06[AA0A]              	mov	[TEMP_DOSLOC],es	; put back segment of dos code
 46294                                  
 46295 00008274 5A                      	pop	dx			; restore first free segment
 46296                                  
 46297                                  ; We shall now proceed to set the offsets of the interrupt vectors handled
 46298                                  ; by DOS to their appropriate values in DOSCODE. In case the DOS loads in
 46299                                  ; HIMEM the offsets also will be patched to their appropriate values in the
 46300                                  ; low_mem_stub by seg_reinit.
 46301                                  
 46302                                  	;xor	ax,ax ; 0
 46303                                  	;mov	ds,ax
 46304                                  	;mov	es,ax
 46305                                  	; 17/12/2022
 46306                                  	; cx = 0
 46307                                  	;xor	cx,cx ; 0
 46308 00008275 8ED9                    	mov	ds,cx
 46309 00008277 8EC1                    	mov	es,cx
 46310                                  
 46311                                  	; set the segment of int 24 vector that was 
 46312                                  	; left out by patch_vec_segments above.
 46313                                  
 46314                                  	; 17/12/2022
 46315                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46316                                  ;%if 0
 46317                                  	; 24/05/2019
 46318                                  	;;mov	di,90h
 46319                                  	;;mov	di,4*int_fatal_abort
 46320                                  	;mov	di,addr_int_fatal_abort
 46321 00008279 BF9200                  	mov	di,addr_int_fatal_abort+2 ; 24/05/2019
 46322                                  
 46323 0000827C 36A1[AA0A]              	mov	ax,[ss:TEMP_DOSLOC]
 46324                                  	;mov	[di+2],ax  ; int 24h segment
 46325 00008280 8905                    	mov	[di],ax ; 24/05/2019
 46326                                  
 46327                                  	;;mov	di,82h
 46328                                  	;mov	di,INTBASE+2
 46329                                  
 46330                                  ;%endif
 46331                                  	; 17/12/2022
 46332                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46333                                  	;;mov	di,90h
 46334                                  	;;mov	di,4*int_fatal_abort
 46335                                  	;mov	di,addr_int_fatal_abort
 46336                                  	;mov	ax,[ss:TEMP_DOSLOC]
 46337                                  	;mov	[di+2],ax  ; int 24h segment
 46338                                  	;;mov	di,82h
 46339                                  	;mov	di,INTBASE+2
 46340                                  
 46341                                  	; set default divide trap offset
 46342                                  
 46343                                  	;mov	word ptr ds:[0],offset doscode:divov
 46344 00008282 C7060000[395C]          	mov	word [0],DIVOV	
 46345                                  
 46346                                  	; set vectors 20-28 and 2a-3f to point to iret.
 46347                                  
 46348                                  	;mov	di,80h
 46349 00008288 BF8000                  	mov	di,INTBASE
 46350                                  	;mov	ax,offset doscode:irett
 46351 0000828B B8[CB02]                	mov	ax,IRETT
 46352                                  
 46353                                  	; 17/12/2022
 46354                                  	; cx = 0
 46355 0000828E B109                    	mov	cl,9
 46356                                  	;mov	cx,9			; set 9 offsets (skip 2 between each)
 46357                                  					;   sets offsets for ints 20h-28h
 46358                                  iset1:
 46359 00008290 AB                      	stosw
 46360                                  	;add	di,2
 46361                                  	; 20/09/2023
 46362 00008291 47                      	inc	di
 46363 00008292 47                      	inc	di
 46364 00008293 E2FB                    	loop	iset1
 46365                                  
 46366 00008295 83C704                  	add	di,4			; skip vector 29h
 46367                                  
 46368                                  ;	mov	cx,6			; set 6 offsets (skip 2 between each)
 46369                                  ;					;   sets offsets for ints 2ah-2fh
 46370                                  ;iset2:
 46371                                  ;	stosw
 46372                                  ;	add	di,2
 46373                                  ;	loop	iset2
 46374                                  
 46375                                  ; 30h & 31H is the CPM call entry point whose segment address is set up by
 46376                                  ; patch_vec_segments above. So skip it.
 46377                                  
 46378                                  ;	add	di,8			; skip vector 30h & 31h 
 46379                                  
 46380                                  	;;;
 46381                                  	; 06/05/2019 - Retro DOS v4.0
 46382                                  	;mov	cx,5			; set offsets for int 2Ah-2Eh
 46383                                  	; 17/12/2022
 46384 00008298 B105                    	mov	cl,5 ; 28/06/2019
 46385                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46386                                  	;mov	cx,6
 46387                                  iset2:
 46388 0000829A AB                      	stosw
 46389                                  	;add	di,2
 46390                                  	; 20/09/2023
 46391 0000829B 47                      	inc	di
 46392 0000829C 47                      	inc	di
 46393 0000829D E2FB                    	loop	iset2
 46394                                  
 46395                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46396                                  	; 17/12/2022
 46397 0000829F 83C70C                  	add	di,12			; skip vectors 2Fh, 30h & 31h
 46398                                  	;add	di,8
 46399                                  	;;;
 46400                                  
 46401                                  	; 17/12/2022
 46402 000082A2 B10E                    	mov	cl,14
 46403                                  	;mov	cx,14			; set 14 offsets (skip 2 between each)
 46404                                  					;   sets offsets for ints 32h-3fh
 46405                                  iset3:
 46406 000082A4 AB                      	stosw
 46407                                  	;add	di,2
 46408                                  	; 20/09/2023
 46409 000082A5 47                      	inc	di
 46410 000082A6 47                      	inc	di
 46411 000082A7 E2FB                    	loop	iset3
 46412                                  
 46413                                  ;if installed
 46414                                  	; set the offset of int2f handler
 46415                                  	;mov	word [0BCh],INT2F
 46416 000082A9 C706BC00[3C07]          	mov	word [02Fh*4],INT2F
 46417                                  	; set segment to doscode as we have to do int 2f to check for XMS
 46418 000082AF 36A1[AA0A]              	mov	ax,[ss:TEMP_DOSLOC]	; get segment of doscode
 46419                                  	;mov	[0BEh],ax
 46420 000082B3 A3BE00                  	mov	[(02Fh*4)+2],ax
 46421                                  ;endif
 46422                                  	; set up entry point call at vectors 30-31h. Note the segment of the 
 46423                                  	; long jump will be patched in by seg_reinit
 46424                                  
 46425                                  	;mov	byte [C0h],0EAh
 46426 000082B6 C606C000EA              	mov	byte [ENTRYPOINT],mi_long_jmp
 46427                                  	;mov	byte [C1h],CALL_ENTRY
 46428 000082BB C706C100[CC02]          	mov	word [ENTRYPOINT+1],CALL_ENTRY
 46429                                  
 46430 000082C1 C7068000[C502]          	mov	word [addr_int_abort],QUIT	; INT 20h
 46431 000082C7 C7068400[F102]          	mov	word [addr_int_command],COMMAND ; INT 21h
 46432 000082CD C70688000001            	mov	word [addr_int_terminate],100h	; INT 22h
 46433 000082D3 89168A00                	mov	word [addr_int_terminate+2],dx	
 46434 000082D7 C7069400[2D05]          	mov	word [addr_int_disk_read],ABSDRD   ; INT 25h
 46435 000082DD C7069800[DC05]          	mov	word [addr_int_disk_write],ABSDWRT ; INT 26h 
 46436 000082E3 C7069C00[AD6B]          	mov	word [addr_int_keep_process],STAY_RESIDENT ; INT 27h
 46437                                  
 46438 000082E9 16                      	push	ss
 46439 000082EA 1F                      	pop	ds
 46440                                  	
 46441                                  	; 24/05/2019
 46442                                  	;push	ss
 46443                                  	;pop	es
 46444                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46445                                  	; 17/12/2022
 46446                                  	;push	ss
 46447                                  	;pop	es
 46448                                  
 46449 000082EB 52                      	push	dx			; remember address of arena
 46450                                  
 46451 000082EC 42                      	inc	dx			; leave room for arena header
 46452                                  	;mov	[330h],dx
 46453 000082ED 8916[3003]              	mov     [CurrentPDB],dx		; set current pdb
 46454                                  
 46455 000082F1 31FF                    	xor	di,di			; point es:di at end of memory
 46456 000082F3 8EC2                    	mov	es,dx			; ...where psp will be
 46457 000082F5 31C0                    	xor	ax,ax
 46458                                  	;mov	cx,80h			; psp is 128 words
 46459                                  	; 17/12/2022
 46460 000082F7 B180                    	mov	cl,128 ; 28/06/2019
 46461                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46462                                  	;mov	cx,128
 46463                                  
 46464 000082F9 F3AB                    	rep	stosw			; zero out psp area
 46465 000082FB A1[4603]                        mov     ax,[ENDMEM]
 46466                                  	
 46467                                  	; 17/12/2022
 46468                                  	; cx = 0
 46469 000082FE E8DC93                  	call	SETMEM         	 	; build psp at dx; ax is memory size
 46470                                  
 46471                                  	; ds, es now point to PSP
 46472                                  
 46473 00008301 16                      	push	ss
 46474 00008302 1F                      	pop	ds
 46475                                  
 46476                                  	;mov	di,24
 46477 00008303 BF1800                  	mov	di,PDB.JFN_TABLE	; es:di -> pdb_jfn_table in psp
 46478 00008306 31C0                    	xor	ax,ax
 46479 00008308 AB                      	stosw
 46480 00008309 AA                      	stosb				; 0,1 and 2 are con device
 46481 0000830A B0FF                    	mov	al,0FFh
 46482                                  	;mov	cx,FILPERPROC-3 ; 17
 46483                                  	; 17/12/2022
 46484                                  	; cx = 4
 46485 0000830C B111                    	mov	cl,FILPERPROC-3 ; 17
 46486 0000830E F3AA                    	rep	stosb			; rest are unused
 46487                                  
 46488 00008310 16                      	push	ss
 46489 00008311 07                      	pop	es
 46490                                  					; must be set to print messages
 46491 00008312 8C1E[2C00]              	mov	[SFT_ADDR+2],ds     
 46492                                  
 46493                                  ; after this point the char device functions for con will work for
 46494                                  ; printing messages
 46495                                  
 46496                                  	; 24/04/2019 - Retro DOS v4.0
 46497                                  
 46498                                  ; 12/05/2019
 46499                                  ;
 46500                                  ;write_version_msg:
 46501                                  ;
 46502                                  ;	;if	(not ibm)
 46503                                  ;	;mov	si,offset doscode:header
 46504                                  ;	mov	si,HEADER
 46505                                  ;outmes:
 46506                                  ;	;lods	cs:byte ptr [si]
 46507                                  ;	cs
 46508                                  ;	lodsb
 46509                                  ;	cmp	al,"$"
 46510                                  ;	je	short outdone
 46511                                  ;	call	OUTT
 46512                                  ;	jmp	short outmes
 46513                                  ;outdone:
 46514                                  ;	push	ss			; out stomps on segments
 46515                                  ;	pop	ds
 46516                                  ;	push	ss
 46517                                  ;	pop	es
 46518                                  ;	;endif
 46519                                  
 46520                                  	; at this point es is dosdata
 46521                                  
 46522                                  	; Fill in the segment addresses of sysinitvar and country_cdpg 
 46523                                  	; in sysinittable (ms_data.asm)
 46524                                  
 46525                                  	;mov	si,0D28h
 46526 00008316 BE[790D]                	mov	si,SysInitTable
 46527                                  
 46528                                  	; 17/12/2022
 46529                                  	; ds = es = ss
 46530                                  
 46531                                  	; 17/12/2022
 46532                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46533                                  ;%if 0
 46534                                  	;;mov	[es:si+6],es
 46535                                  	;mov	[es:si+SYSI_EXT.Country_Tab+2],es
 46536                                  	;;mov	[es:si+2],es
 46537                                  	;mov	[es:si+SYSI_EXT.SysInitVars+2],es
 46538                                  	
 46539 00008319 8C4406                  	mov	[si+SYSI_EXT.Country_Tab+2],es
 46540 0000831C 8C4402                  	mov	[si+SYSI_EXT.SysInitVars+2],es
 46541                                  
 46542                                  	; buffhead -> dosdata:hashinitvar 
 46543                                  
 46544                                  	;mov	[es:BUFFHEAD+2],es	; BUGBUG - unused, remove this
 46545 0000831F 8C06[3A00]              	mov	[BUFFHEAD+2],es
 46546                                  	;mov	si,offset dosdata:hashinitvar ; and all other references
 46547                                  	;mov	si,6Dh
 46548 00008323 BE[6D00]                	mov	si,HASHINITVAR
 46549                                  	;mov	[es:BUFFHEAD],si
 46550 00008326 8936[3800]              	mov	[BUFFHEAD],si
 46551                                  
 46552 0000832A 5A                              pop     dx                      ; restore address of arena
 46553                                  
 46554                                  	;mov	[032Ch+2],dx
 46555 0000832B 8916[2E03]                      mov     [DMAADD+2],dx
 46556                                  
 46557                                  	;mov	[es:arena_head],dx
 46558 0000832F 8916[2400]              	mov	[arena_head],dx
 46559                                  
 46560                                  ;%endif
 46561                                  
 46562                                  ; 17/12/2022
 46563                                  %if 0
 46564                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46565                                  	;;;
 46566                                  	;mov	[es:si+6],es
 46567                                  	mov	[es:si+SYSI_EXT.Country_Tab+2],es
 46568                                  	;mov	[es:si+2],es
 46569                                  	mov	[es:si+SYSI_EXT.SysInitVars+2],es
 46570                                  
 46571                                  	; buffhead -> dosdata:hashinitvar 
 46572                                  
 46573                                  	mov	[es:BUFFHEAD+2],es	; BUGBUG - unused, remove this
 46574                                  	;mov	si,offset dosdata:hashinitvar ; and all other references
 46575                                  	;mov	si,6Dh
 46576                                  	mov	si,HASHINITVAR
 46577                                  	mov	[es:BUFFHEAD],si
 46578                                  
 46579                                          pop     dx                      ; restore address of arena
 46580                                  
 46581                                  	;mov	[032Ch+2],dx
 46582                                          mov     [DMAADD+2],dx
 46583                                  
 46584                                  	mov	[es:arena_head],dx
 46585                                  	;;;
 46586                                  %endif
 46587                                  
 46588 00008333 8EDA                            mov     ds,dx
 46589                                  
 46590                                  	;mov	byte [0],'Z'
 46591 00008335 C60600005A              	mov     byte [ARENA.SIGNATURE],arena_signature_end
 46592                                          ;mov	word [1],0
 46593 0000833A C70601000000            	mov     word [ARENA.OWNER],arena_owner_system
 46594                                  
 46595 00008340 36A1[4603]                      mov     ax,[ss:ENDMEM]
 46596 00008344 29D0                    	sub	ax,dx
 46597 00008346 48                              dec     ax
 46598 00008347 A30300                          mov     [ARENA.SIZE],ax
 46599                                  
 46600                                  	; point to sft 0
 46601                                  
 46602                                  	;mov	di,offset dosdata:sftabl + sftable
 46603                                  	;mov	di,SFTABL+6
 46604 0000834A BF[D200]                	mov	di,SFTABL+SFT.SFTable
 46605 0000834D B80300                          mov     ax,3
 46606 00008350 AB                              stosw           		; adjust refcount
 46607                                  
 46608                                  	; es:di is shared data area i.e., es:di -> dosdata:sysinttable
 46609                                  
 46610                                          ;mov	di,offset dosdata:sysinittable
 46611                                  	;mov	di,0D28h
 46612 00008351 BF[790D]                	mov	di,SysInitTable	
 46613                                  
 46614 00008354 42                      	inc	dx			; advance dx from arena to psp
 46615 00008355 8EDA                    	mov	ds,dx			; point ds to psp
 46616                                  
 46617                                  					; pass the address os seg_reinit 
 46618                                  					; in dx
 46619 00008357 BA[C583]                	mov	dx,seg_reinit
 46620 0000835A B9[E87D]                	mov	cx,exepatch_start
 46621 0000835D 81E9[0000]              	sub	cx,_$STARTCODE		; cx = (doscode - exepatch) - dosinit
 46622                                  
 46623 00008361 B8[A080]                	mov	ax,SYSBUF
 46624 00008364 2D[0000]                	sub	ax,_$STARTCODE		; ax = size of doscode - dosinit
 46625                                  	
 46626 00008367 368B26[8405]                    mov     sp,[ss:USER_SP]		; use ss override for next 2
 46627 0000836C 368E16[8605]                    mov     ss,[ss:USER_SS]
 46628                                  
 46629 00008371 CB                              retf
 46630                                  
 46631                                  ;
 46632                                  ; END OF DOSINIT
 46633                                  ;
 46634                                  ;--------------------------------------------------------------------------
 46635                                  
 46636                                  CHARINIT:
 46637                                  	; 24/04/2019 - Retro DOS v4.0
 46638                                  	; 07/07/2018 - Retro DOS v3.0
 46639                                  	;mov	byte [ss:035Ah],26 ; 1Ah
 46640 00008372 36C606[5A03]1A                  MOV	BYTE [SS:DEVCALL_REQLEN],DINITHL
 46641                                  	;mov	byte [ss:035Bh],0
 46642 00008378 36C606[5B03]00                  MOV	BYTE [SS:DEVCALL_REQUNIT],0
 46643                                  	;mov	byte [ss:035Ch],0
 46644 0000837E 36C606[5C03]00                  MOV	BYTE [SS:DEVCALL_REQFUNC],DEVINIT
 46645                                  	;mov	word [ss:035BD],0
 46646 00008384 36C706[5D03]0000                MOV	WORD [SS:DEVCALL_REQSTAT],0
 46647 0000838B 06                              PUSH	ES
 46648 0000838C 53                              PUSH	BX
 46649 0000838D 50                              PUSH	AX
 46650 0000838E BB[5A03]                        MOV	BX,DEVCALL
 46651                                          ;PUSH	CS
 46652 00008391 16                      	PUSH	SS ; 30/04/2019
 46653 00008392 07                              POP	ES
 46654 00008393 E88FCC                          CALL	DEVIOCALL2	
 46655 00008396 58                      	POP	AX
 46656 00008397 5B                              POP	BX
 46657 00008398 07                              POP	ES
 46658 00008399 C3                              RETN
 46659                                  
 46660                                  ; 25/04/2019 - Retro DOS v4.0
 46661                                  
 46662                                  ;-----------------------------------------------------------------------------
 46663                                  ;
 46664                                  ;	check_XMM: routine to check presence of XMM driver
 46665                                  ;
 46666                                  ;	Exit:   Sets up the XMM entry point in XMMcontrol in DOSDATA
 46667                                  ;
 46668                                  ;	USED:	none
 46669                                  ;
 46670                                  ;-----------------------------------------------------------------------------
 46671                                  
 46672                                  check_XMM: ; proc near
 46673                                  ;
 46674                                  ; determine whether or not an XMM driver is installed
 46675                                  ;
 46676 0000839A 50                      	push	ax
 46677                                  	;mov	ax,(XMM_MULTIPLEX<<8)+XMM_INSTALL_CHECK
 46678 0000839B B80043                  	mov	ax,4300h
 46679 0000839E CD2F                    	int	2Fh
 46680                                  		; - Multiplex - XMS - INSTALLATION CHECK
 46681                                  		; Return: AL = 80h XMS driver installed
 46682                                  		; AL <> 80h no driver
 46683 000083A0 3C80                    	cmp	al,80h			; Q: installed
 46684 000083A2 751D                    	jne	short cXMM_no_driver	; N: set error, quit
 46685                                  ;
 46686                                  ; get the XMM control functions entry point, save it, we
 46687                                  ; need to call it later.
 46688                                  ;
 46689 000083A4 53                      	push	bx
 46690 000083A5 52                      	push	dx
 46691 000083A6 1E                      	push	ds
 46692 000083A7 06                      	push	es
 46693                                  	;mov	ax,(XMM_MULTIPLEX<<8)+XMM_FUNCTION_ADDR
 46694 000083A8 B81043                  	mov	ax,4310h
 46695 000083AB CD2F                    	int	2Fh
 46696                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
 46697                                  		; Return: ES:BX -> driver entry point
 46698                                  
 46699 000083AD 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 46700                                  
 46701 000083B2 891E[AD11]              	mov	[XMMcontrol],bx
 46702 000083B6 8C06[AF11]              	mov	[XMMcontrol+2],es
 46703                                  cXMMexit:
 46704 000083BA F8                      	clc
 46705 000083BB 07                      	pop	es
 46706 000083BC 1F                      	pop	ds
 46707 000083BD 5A                      	pop	dx
 46708 000083BE 5B                      	pop	bx
 46709 000083BF 58                      	pop	ax
 46710 000083C0 C3                      	retn				; done
 46711                                  ;
 46712                                  ; set carry if XMM driver not present
 46713                                  ;
 46714                                  cXMM_no_driver:
 46715 000083C1 F9                      	stc
 46716 000083C2 58                      	pop	ax
 46717 000083C3 C3                      	retn
 46718                                  
 46719                                  ;-----------------------------------------------------------------------------
 46720                                  ;
 46721                                  ; Procedure Name : seg_reinit
 46722                                  ;
 46723                                  ; Inputs	 : ES has final dos code location
 46724                                  ;		   AX = 0 / 1
 46725                                  ;
 46726                                  ; Outputs	 : Patch in the sharer and other tables with seg in ES
 46727                                  ;		   if AX =0
 46728                                  ;		      if first entry
 46729                                  ;			 patch segment & offset of vectors with stub
 46730                                  ;			 and stub with segment in ES
 46731                                  ;		      else
 46732                                  ;			 patch stub with segment in ES
 46733                                  ;
 46734                                  ;		   else if AX = 1
 46735                                  ;			patch segment of vectors with segment in ES
 46736                                  ;
 46737                                  ; NOTE		 : This routine can be called at most twice!
 46738                                  ;
 46739                                  ; Regs Mod.	 : es, ax, di, cx, bx
 46740                                  ;-----------------------------------------------------------------------------
 46741                                  
 46742 000083C4 00                      num_entry: db	0		; keeps track of the # of times this routine
 46743                                  				; has been called. (0 or 1)
 46744                                  
 46745                                  	; 04/11/2022 - Retro DOS v4.0 (ref: MSDOS 5.0)
 46746                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BAB7h
 46747                                  	; 25/05/2019 - Retro DOS v4.0 (ref: MSDOS 6.21)
 46748                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:0BDA5h
 46749                                  
 46750                                  seg_reinit:	; proc	far
 46751 000083C5 1E                      	push	ds
 46752                                  
 46753 000083C6 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 46754                                  
 46755 000083CB E88600                  	call	patch_misc_segments	; patch in segments for sharer and 
 46756                                  					; other tables with seg in ES.
 46757                                  	; 17/12/2022
 46758                                  	; cx = 0
 46759 000083CE 39C8                    	cmp	ax,cx ; 0
 46760                                  	;cmp	ax,0
 46761 000083D0 753D                    	jne	short patch_vec_seg	; patch vectors with segment in es
 46762                                  
 46763                                  	; 17/12/2022
 46764 000083D2 2E380E[C483]            	cmp	[cs:num_entry],cl ; 0
 46765                                  	;cmp	byte [cs:num_entry],0	; Q: is it the first call to this
 46766 000083D7 7508                    	jne	short second_entry	; N: just patch the stub with 
 46767                                  					;    segment in ES
 46768                                  					; Y: patch the vectors with stub
 46769 000083D9 8CD8                    	mov	ax,ds
 46770 000083DB E83E00                  	call	patch_vec_segments	; patch the segment of vectors
 46771 000083DE E8BD00                  	call	patch_offset		; patch the offsets of vectors 
 46772                                  					; with those in the stub.
 46773                                  	; 17/12/2022
 46774                                  	; cx = 0
 46775                                  second_entry:
 46776 000083E1 8CC0                    	mov	ax,es			; patch the stub with segment in es
 46777                                  
 46778                                  	;mov	di,OFFSET DOSDATA:DOSINTTABLE
 46779                                  	;mov	di,1062h	; (same table addr for MSDOS 5.0 and MSDOS 6.21)
 46780 000083E3 BF[AC10]                	mov	di,DOSINTTABLE
 46781                                  	; 17/12/2022
 46782                                  	; cx = 0
 46783                                  	;mov	cx,9
 46784 000083E6 B109                    	mov	cl,9
 46785 000083E8 1E                      	push	ds			
 46786 000083E9 07                      	pop	es			; es:di -> DOSINTTABLE
 46787                                  
 46788                                  dosinttabloop:
 46789                                  	;add	di,2
 46790                                  	; 19/06/2023
 46791 000083EA 47                      	inc	di
 46792 000083EB 47                      	inc	di
 46793 000083EC AB                      	stosw
 46794 000083ED E2FB                    	loop	dosinttabloop	
 46795                                  
 46796                                  ; For ROMDOS, this routine will only be called when the DOS wants to
 46797                                  ; use the HMA, so we don't want to check CS
 46798                                  
 46799                                  ;ifndef ROMDOS
 46800 000083EF 3D00F0                  	cmp	ax,0F000h		; Q: is the DOS running in the HMA
 46801 000083F2 7220                    	jb	short sr_done		; N: done
 46802                                  ;endif
 46803 000083F4 E8A3FF                  	call	check_XMM		; Y: set up the XMS entry point
 46804 000083F7 721B                    	jc	short sr_done		; failed to set up XMS do not do
 46805                                  					; A20 toggling in the stub.
 46806                                  	; 17/12/2022
 46807                                  	; cx = 0
 46808 000083F9 E81D01                  	call	patch_in_nops		; enable the stub to check A20 state
 46809                                  ; M021-
 46810                                  	;mov	byte [1211h],1
 46811 000083FC C606[870D]01            	mov	byte [DosHasHMA],1	; set flag telling DOS control of HMA
 46812                                  				
 46813                                  					; set pointer to the routine that 
 46814                                  					; patches buggy exepacked code.
 46815                                  	;mov	[FixExePatch],offset DOSCODE:ExePatch
 46816 00008401 C706[880D][387F]        	mov	word [FixExePatch],ExePatch
 46817                                  					; M068: set pointer to the routine 
 46818                                  					; M068: that detects copy protected
 46819                                  					; M068: apps
 46820                                  	;mov	[ChkCopyProt],offset DOSCODE:IsCopyProt
 46821 00008407 C706[6100][6980]        	mov	word [ChkCopyProt],IsCopyProt
 46822                                  
 46823                                  	; 19/09/2023
 46824 0000840D EB05                    	jmp	short sr_done
 46825                                  
 46826                                  ; 28/12/2022 - Retro DOS v4.1
 46827                                  %if 0
 46828                                  ;----------------------------------------------------------------------------
 46829                                  
 46830                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:0BDF1h
 46831                                  
 46832                                  ;	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 46833                                  ;
 46834                                  ;; M020 - begin
 46835                                  ;
 46836                                  ;	call	WhatCPUType
 46837                                  ;	cmp	al,1
 46838                                  ;	jne	short sr_done 		; we need Rational Patch only
 46839                                  ;					;  on 286 systems
 46840                                  ;	;mov	[RationalPatchPtr],offset DOSCODE:RationalPatch
 46841                                  ;	mov	word [RationalPatchPtr],RationalPatch
 46842                                  ;
 46843                                  ;; M020 - end
 46844                                  ;
 46845                                  ;	jmp	short sr_done
 46846                                  ;
 46847                                  ;patch_vec_seg:				; patch vectors with segment in es
 46848                                  ;	mov	ax,es
 46849                                  ;	call	patch_vec_segments	; patch in DOSCODE for the segments
 46850                                  ;					; NOTE we don't have to patch the 
 46851                                  ;					; offsets as they have been already
 46852                                  ;					; set to the doscode offsets at
 46853                                  ;					; DOSINIT.
 46854                                  ;sr_done:
 46855                                  ;	mov	byte [cs:num_entry],1
 46856                                  ;	pop	ds
 46857                                  ;	retf	; ! far return !
 46858                                  
 46859                                  ;----------------------------------------------------------------------------
 46860                                  ;
 46861                                  ; Procedure Name : WhatCPUType
 46862                                  ;
 46863                                  ; Inputs	 : none
 46864                                  ;
 46865                                  ; Outputs	 : AL = 0 if CPU <  286
 46866                                  ;		      = 1 if CPU == 286
 46867                                  ;		      = 2 if CPU >= 386
 46868                                  ;
 46869                                  ; Regs. Mod.	 : AX
 46870                                  ;
 46871                                  ;----------------------------------------------------------------------------
 46872                                  
 46873                                  WhatCPUType:
 46874                                  	; 25/04/2019 - Retro DOS v4.0
 46875                                  	;get_cpu_type	; done with a MACRO which can't be generated > once
 46876                                  
 46877                                  	;CPUTYPE.INC (MSDOS 6.0, 1991)
 46878                                  
 46879                                  ; Note: this must be a macro, and not a subroutine in the BIOS since
 46880                                  ; 	it is called from both CODE and SYSINITSEG.
 46881                                  ;
 46882                                  ;------GET_CPU_TYPE-----------------------------------May, 88 by M.Williamson
 46883                                  ;  Returns: AX = 0 if 8086 or 8088
 46884                                  ;              = 1 if 80286
 46885                                  ;              = 2 if 80386
 46886                                  
 46887                                  	; 04/11/2022
 46888                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BB03h
 46889                                  
 46890                                  Get_CPU_Type:	;macro
 46891                                  	pushf
 46892                                  	push	bx			; preserve bx
 46893                                  	xor	bx,bx			; init bx to zero
 46894                                  
 46895                                  	xor	ax,ax			; 0000 into AX
 46896                                  	push	ax			; put it on the stack...
 46897                                  	popf				; ...then shove it into the flags
 46898                                  	pushf				; get it back out of the flags...
 46899                                  	pop	ax			; ...and into ax
 46900                                  	and	ax,0F000h		; mask off high four bits
 46901                                  	cmp	ax,0F000h		; was it all 1's?
 46902                                  	je	short cpu_8086		; aye; it's an 8086 or 8088
 46903                                  
 46904                                  	mov	ax,0F000h		; now try to set the high four bits..
 46905                                  	push	ax
 46906                                  	popf
 46907                                  	pushf
 46908                                  	pop	ax			; ...and see what happens
 46909                                  	and	ax,0F000h		; any high bits set ?
 46910                                  	jz	short cpu_286		; nay; it's an 80286
 46911                                  
 46912                                  cpu_386:				; bx starts as zero
 46913                                  	inc	bx			; inc twice if 386
 46914                                  cpu_286:				; just inc once if 286
 46915                                  	inc	bx
 46916                                  cpu_8086:				; don't inc at all if 086
 46917                                  	mov	ax,bx			; put CPU type value in ax
 46918                                  	pop	bx			; restore original bx
 46919                                  	popf
 46920                                  	
 46921                                  	;endm
 46922                                  
 46923                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS)
 46924                                  	retn	; 19/09/2023
 46925                                  
 46926                                  ; 19/09/2023
 46927                                  ;	; 04/11/2022
 46928                                  ;	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BB27h
 46929                                  ;	cmp	al,1
 46930                                  ;	jne	short sr_done 		; we need Rational Patch only
 46931                                  ;					;  on 286 systems
 46932                                  ;	mov	word [RationalPatchPtr],RationalPatch
 46933                                  
 46934                                  ;----------------------------------------------------------------------------
 46935                                  %endif	; 28/12/2022
 46936                                  
 46937                                  	; 19/09/2023
 46938                                  	;jmp	short sr_done
 46939                                  
 46940                                  patch_vec_seg:				; patch vectors with segment in es
 46941 0000840F 8CC0                    	mov	ax,es
 46942 00008411 E80800                  	call	patch_vec_segments	; patch in DOSCODE for the segments
 46943                                  					; NOTE we don't have to patch the 
 46944                                  					; offsets as they have been already
 46945                                  					; set to the doscode offsets at
 46946                                  					; DOSINIT.
 46947                                  sr_done:
 46948 00008414 2EC606[C483]01          	mov	byte [cs:num_entry],1
 46949 0000841A 1F                      	pop	ds
 46950 0000841B CB                      	retf	; ! far return !
 46951                                  
 46952                                  ;----------------------------------------------------------------------------
 46953                                  ;
 46954                                  ; Procedure Name : patch_vec_segments
 46955                                  ;
 46956                                  ; Inputs	 : ax -> has segment address to patch in
 46957                                  ;		   ds -> DOSDATA
 46958                                  ;
 46959                                  ; Outputs	 : Patches in AX as the segment for the following vectors:
 46960                                  ;			
 46961                                  ;			0,20-28,3a-3f
 46962                                  ;
 46963                                  ; Regs. Mod.	 : DI,CX,DX,AX
 46964                                  ;
 46965                                  ;----------------------------------------------------------------------------
 46966                                  
 46967                                  patch_vec_segments:
 46968                                  
 46969 0000841C 06                      	push	es
 46970                                  
 46971 0000841D 31C9                    	xor	cx,cx ; 0
 46972 0000841F 8EC1                    	mov	es,cx
 46973                                  
 46974                                  	;mov	di,82h
 46975 00008421 BF8200                  	mov	di,INTBASE+2		; di -> segment of int 20 vector
 46976                                  
 46977 00008424 26A30200                	mov	[es:2],ax		; segment of default divide trap handler
 46978                                  
 46979                                  					; set vectors 20 & 21
 46980                                  	; 04/11/2022
 46981                                  	;mov	cx,2
 46982                                  	; 17/12/2022
 46983                                  	;mov	cl,2
 46984                                  ps_set1:
 46985 00008428 AB                      	stosw	; int 20h segment
 46986                                  	;add	di,2
 46987                                  	; 17/12/2022
 46988 00008429 47                      	inc	di
 46989 0000842A 47                      	inc	di
 46990                                  	;loop	ps_set1
 46991                                  
 46992                                  	; 17/12/2022
 46993 0000842B AB                      	stosw	; int 21h segment
 46994                                  	;inc	di
 46995                                  	;inc	di
 46996                                  
 46997                                  	;add	di,4			; skip int 22h vector
 46998 0000842C 83C706                  	add	di,6 ; *
 46999                                  
 47000 0000842F AB                      	stosw				; set int 23h
 47001 00008430 83C706                  	add	di,6			; skip int 24h
 47002                                  
 47003                                  					; set vectors 25-28 and 2a-3f 
 47004                                  	; 04/11/2022
 47005                                  	;mov	cx,4			; set 4 segments
 47006                                  	; 17/12/2022
 47007 00008433 B104                    	mov	cl,4
 47008                                  ps_set2:
 47009 00008435 AB                      	stosw				
 47010                                  	;add	di,2
 47011                                  	; 17/12/2022
 47012 00008436 47                      	inc	di
 47013 00008437 47                      	inc	di
 47014 00008438 E2FB                    	loop	ps_set2
 47015                                  
 47016 0000843A 83C704                  	add	di,4			; skip int 29h vector (fast con) as it may
 47017                                  					;   already be set.
 47018                                  	; 04/11/2022
 47019                                  	;mov	cx,6			; set 6 segs (skip 2 between each)
 47020                                  	; 17/12/2022
 47021 0000843D B106                    	mov	cl,6			;  set segs for ints 2ah-2fh
 47022                                  ps_set3:
 47023 0000843F AB                      	stosw
 47024                                  	;add	di,2
 47025                                  	; 17/12/2022
 47026 00008440 47                      	inc	di
 47027 00008441 47                      	inc	di
 47028 00008442 E2FB                    	loop	ps_set3
 47029                                  
 47030                                  ; 30h & 31H is the CPM call entry point whose segment address is set up by
 47031                                  ; below. So skip it.
 47032                                  
 47033 00008444 83C708                  	add	di,8			; skip vector 30h & 31h 
 47034                                  	
 47035                                  	; 04/11/2022
 47036                                  	;mov	cx,14			; set 14 segs (skip 2 between each)
 47037                                  	; 17/12/2022
 47038 00008447 B10E                    	mov	cl,14			;   sets segs for ints 32h-3fh
 47039                                  ps_set4:
 47040 00008449 AB                      	stosw
 47041                                  	;add	di,2
 47042                                  	; 17/12/2022
 47043 0000844A 47                      	inc	di
 47044 0000844B 47                      	inc	di
 47045 0000844C E2FB                    	loop	ps_set4
 47046                                  
 47047                                  ; set offset of int2f
 47048                                  
 47049                                  ;if installed
 47050                                  ;	mov	word ptr es:[02fh * 4],offset doscode:int2f
 47051                                  ;endif
 47052                                  	;mov	[es:0C3h],ax
 47053 0000844E 26A3C300                	mov	[es:ENTRYPOINT+3],ax
 47054                                  	; 17/12/2022
 47055                                  	; cx = 0
 47056 00008452 07                      	pop	es
 47057 00008453 C3                      	retn
 47058                                  
 47059                                  ;---------------------------------------------------------------------------
 47060                                  ;
 47061                                  ; Procedure Name : patch_misc_segments
 47062                                  ;
 47063                                  ; Inputs	 : es = segment to patch in
 47064                                  ;		   ds = dosdata
 47065                                  ;
 47066                                  ; outputs	 : patches in the sharer and other tables in the dos
 47067                                  ;		   with right dos code segment in es
 47068                                  ;
 47069                                  ; Regs Mod	 : DI,SI,CX
 47070                                  ;
 47071                                  ;---------------------------------------------------------------------------
 47072                                  
 47073                                  patch_misc_segments:
 47074                                  
 47075 00008454 53                      	push	bx
 47076 00008455 06                      	push	es
 47077 00008456 50                      	push	ax
 47078                                  
 47079 00008457 8CC0                    	mov	ax,es			; ax - > DOS segment
 47080                                  	
 47081 00008459 1E                      	push	ds
 47082 0000845A 07                      	pop	es			; es -> DOSDATA
 47083                                  	
 47084                                  ; initialize the jump table for the sharer...
 47085                                  
 47086                                  	;mov	di,offset dosdata:jshare
 47087                                  	;mov	di,90h
 47088 0000845B BF[9000]                	mov	di,JShare
 47089                                  	;mov	bx,[0AAAh]
 47090 0000845E 8B1E[AA0A]              	mov	bx,[TEMP_DOSLOC]	; bx = location to which the share
 47091                                  					; table was patched during the first
 47092                                  					; call to this routine
 47093 00008462 B90F00                  	mov	cx,15
 47094                                  jumptabloop:
 47095                                  	;add	di,2			; skip offset
 47096                                  	; 17/12/2022
 47097 00008465 47                      	inc	di
 47098 00008466 47                      	inc	di
 47099 00008467 83FBFF                  	cmp	bx,-1 ; 0FFFFh		; Q: is this called for the 1st time
 47100 0000846A 7405                    	je	short share_patch	; Y: patch in sharer table
 47101                                  					; N: 
 47102 0000846C 263B1D                  	cmp	bx,[es:di]		; Q: has share been installed
 47103 0000846F 7501                    	jne	short no_share_patch	; Y: don't patch in sharer table
 47104                                  share_patch:
 47105 00008471 AB                      	stosw				; drop in segment
 47106                                  no_share_patch:
 47107 00008472 E2F1                    	loop	jumptabloop
 47108                                  					; BUGBUG patching the country info 
 47109                                  					; with dosdata can be done inline
 47110                                  					; in dosinit.
 47111                                  					; for dos 3.3 country info
 47112                                  					; table address
 47113                                  
 47114                                  	;mov	si,offset dosdata:country_cdpg
 47115                                  	;mov	si,122Ah   
 47116 00008474 BE[5113]                	mov	si,COUNTRY_CDPG
 47117                                  					; initialize double word
 47118                                  					; pointers with dosdata in ds
 47119                                  	;mov	[si+4Fh],ds
 47120                                  	;mov	[si+54h],ds
 47121                                  	;mov	[si+59h],ds
 47122                                  	;mov	[si+5Eh],ds
 47123                                  	;mov	[si+80h],ds
 47124                                  	;mov	[si+63h],ds
 47125 00008477 8C5C4F                  	mov	[si+DOS_CCDPG.ccUcase_ptr+2],ds    
 47126 0000847A 8C5C54                  	mov	[si+DOS_CCDPG.ccFileUcase_ptr+2],ds 
 47127 0000847D 8C5C59                  	mov	[si+DOS_CCDPG.ccFileChar_ptr+2],ds
 47128 00008480 8C5C5E                  	mov	[si+DOS_CCDPG.ccCollate_ptr+2],ds
 47129 00008483 8C9C8000                	mov	[si+DOS_CCDPG.ccMono_ptr+2],ds
 47130 00008487 8C5C63                  	mov	[si+DOS_CCDPG.ccDBCS_ptr+2],ds	
 47131                                  
 47132                                  					; fastopen routines are in doscode
 47133                                  					; so patch with doscode seg in ax
 47134                                  
 47135                                  	;mov	si,offset dosdata:fastopentable
 47136                                  	;mov	si,0D30h
 47137 0000848A BE[6312]                	mov	si,FastOpenTable
 47138                                  
 47139                                  	; 17/12/2022
 47140                                  	; bx = [TEMP_DOSLOC]
 47141 0000848D 83FBFF                  	cmp	bx,-1
 47142                                  	;cmp	word [TEMP_DOSLOC],-1	; Q: first time 
 47143 00008490 7405                    	je	short fast_patch	; Y: patch segment
 47144                                  	;mov	cx,[TEMP_DOSLOC]
 47145                                  					; Q: has fastopen patched in it's
 47146                                  					;    segment
 47147                                  	; 17/12/2022
 47148 00008492 3B5C04                  	cmp	bx,[si+fastopen_entry.name_caching+2]
 47149                                  	;;cmp	cx,[si+4]
 47150                                  	;cmp	cx,[si+fastopen_entry.name_caching+2]
 47151 00008495 7503                    	jne	short no_fast_patch	; Y: don't patch in doscode seg
 47152                                  
 47153                                  fast_patch:
 47154                                  	;mov	[si+4],ax
 47155 00008497 894404                  	mov	[si+fastopen_entry.name_caching+2],ax
 47156                                  no_fast_patch:
 47157                                  	; 17/12/2022
 47158                                  	; cx = 0
 47159 0000849A 58                      	pop	ax
 47160 0000849B 07                      	pop	es
 47161 0000849C 5B                      	pop	bx
 47162                                  
 47163 0000849D C3                      	retn
 47164                                  
 47165                                  ;--------------------------------------------------------------------------
 47166                                  ;
 47167                                  ; Procedure Name : patch_offset
 47168                                  ; 
 47169                                  ; Inputs	 : NONE
 47170                                  ;
 47171                                  ; Outputs	 : Patches in the offsets in the low_mem_stub for vectors
 47172                                  ;		   0,20-28,3a-3f, and 30,31
 47173                                  ;
 47174                                  ;
 47175                                  ; Regs. Mod	 : AX,DI,CX
 47176                                  ;--------------------------------------------------------------------------
 47177                                  
 47178                                  patch_offset:
 47179 0000849E 06                      	push	es		; preserve es
 47180                                  
 47181 0000849F 31C0                    	xor	ax,ax
 47182 000084A1 8EC0                    	mov	es,ax
 47183                                  				; set default divide trap address
 47184                                  	;mov	word ptr es:[0],offset dosdata:ldivov	
 47185                                  	;mov	word [es:0],108Ah
 47186 000084A3 26C7060000[D410]        	mov	word [es:0],ldivov
 47187                                  
 47188                                  	;mov	di,80h
 47189 000084AA BF8000                  	mov	di,INTBASE	; di-> offset of int 20 handler
 47190                                  	;mov	ax,offset dosdata:lirett
 47191                                  	;mov	ax,10DAh
 47192 000084AD B8[2411]                	mov	ax,lirett
 47193                                  				; set vectors 20 & 21 to point to iret.
 47194                                  	; 17/12/2022
 47195                                  	; cx = 0
 47196                                  
 47197                                  	;mov	cx,2		; set 2 offsets (skip 2 between each)
 47198                                  po_iset1:
 47199 000084B0 AB                      	stosw	; int 20h offset
 47200                                  	;add	di,2 ; *
 47201                                  	;loop	po_iset1
 47202                                  	; 17/12/2022
 47203 000084B1 47                      	inc	di
 47204 000084B2 47                      	inc	di
 47205 000084B3 AB                      	stosw	; int 21h offset
 47206                                  
 47207                                  	;add	di,4		; skip vector 22h
 47208                                  	; 17/12/2022
 47209 000084B4 83C706                  	add	di,6 ; *	
 47210                                  
 47211 000084B7 AB                      	stosw			; set offset of 23h
 47212                                  	;add	di,6		; skip 24h
 47213                                  	; 19/09/2023
 47214 000084B8 83C712                  	add	di,18		; skip 23h segment and int 24-25-26-27h
 47215                                  
 47216                                  				; set vectors 25-28 and 2a-3f to iret.
 47217                                  	; 04/11/2022
 47218                                  	;mov	cx,4		; set 4 offsets (skip 2 between each)
 47219                                  	; 19/09/2023
 47220                                  	; 17/12/2022
 47221                                  	;mov	cl,4		;   sets offsets for ints 25h-28h
 47222                                  po_iset2:
 47223 000084BB AB                      	stosw		; set offset for int 28h ; 19/09/2023
 47224                                  	;add	di,2
 47225                                  	; 19/09/2023
 47226                                  	; 17/12/2022
 47227                                  	;inc	di
 47228                                  	;inc	di
 47229                                  	; 19/09/2023
 47230                                  	;loop	po_iset2
 47231                                  
 47232                                  	;add	di,4		; skip vector 29h
 47233                                  	; 19/09/2023
 47234 000084BC 83C706                  	add	di,6	; skip int 28h segment and int 29h ; 19/09/2023
 47235                                  
 47236                                  	; 04/11/2022
 47237                                  	;mov	cx,6		; set 6 offsets (skip 2 between each)
 47238                                  	; 17/12/2022
 47239                                  	;mov	cl,6		;   sets offsets for ints 2ah-2fh
 47240 000084BF B105                    	mov	cl,5		; sets offsets for ints 2Ah-2Eh
 47241                                  po_iset3:
 47242 000084C1 AB                      	stosw
 47243                                  	;add	di,2
 47244                                  	; 17/12/2022
 47245 000084C2 47                      	inc	di
 47246 000084C3 47                      	inc	di
 47247 000084C4 E2FB                    	loop	po_iset3
 47248                                  
 47249                                  ; 30h & 31H is the CPM call entry point whose offset address is set up by
 47250                                  ; below. So skip it.
 47251                                  
 47252                                  	;add	di,8		; skip vector 30h & 31h 
 47253                                  	; 17/12/2022
 47254 000084C6 83C70C                  	add	di,12		; skip vector 2Fh, 30h & 31h
 47255                                  
 47256                                  	; 04/11/2022
 47257                                  	;mov	cx,14		; set 14 offsets (skip 2 between each)
 47258                                  				;   sets offsets for ints 32h-3fh
 47259                                  	; 17/12/2022
 47260 000084C9 B10E                    	mov	cl,14 ; 26/06/2019
 47261                                  po_iset4:
 47262 000084CB AB                      	stosw
 47263                                  	;add	di,2
 47264                                  	; 17/12/2022
 47265 000084CC 47                      	inc	di
 47266 000084CD 47                      	inc	di
 47267 000084CE E2FB                    	loop	po_iset4
 47268                                  
 47269                                  ;if installed
 47270                                  	;mov	word ptr es:[02fh * 4],offset dosdata:lint2f
 47271                                  	;mov	word [es:0BCh],10C6h ; (MSDOS 5.0 & 6.21)
 47272 000084D0 26C706BC00[1011]        	mov	word [es:(2Fh*4)],lint2f
 47273                                  ;endif
 47274                                  
 47275                                  ; set up entry point call at vectors 30-31h
 47276                                  	;mov	byte [es:0C0h],0EAh
 47277 000084D7 26C606C000EA            	mov	byte [es:ENTRYPOINT],mi_long_jmp
 47278                                  	;mov	word [es:0C1h],10D0h
 47279                                  
 47280 000084DD 26C706C100[1A11]        	mov	word [es:ENTRYPOINT+1],lcall_entry
 47281                                  
 47282                                  							; 19/09/2023
 47283                                  	;mov	word [es:80h],1094h
 47284 000084E4 26C7068000[DE10]        	mov	word [es:addr_int_abort],lquit		; int 20h
 47285                                  	;mov	word [es:84h],109Eh
 47286 000084EB 26C7068400[E810]        	mov	word [es:addr_int_command],lcommand	; int 21h
 47287                                  	;mov	word [es:94h],10A8h
 47288 000084F2 26C7069400[F210]        	mov	word [es:addr_int_disk_read],labsdrd	; int 25h  
 47289                                  	;mov	word [es:98h],10B2h
 47290 000084F9 26C7069800[FC10]        	mov	word [es:addr_int_disk_write],labsdwrt	; int 26h
 47291                                  	;mov	word [es:9Ch],10BCh
 47292 00008500 26C7069C00[0611]        	mov	word [es:addr_int_keep_process],lstay_resident	; int 27h
 47293                                  
 47294                                  	; 17/12/2022
 47295                                  	; CX = 0
 47296 00008507 07                      	pop	es		; restore es
 47297 00008508 C3                      	retn
 47298                                  
 47299                                  ;--------------------------------------------------------------------------
 47300                                  ;
 47301                                  ; 	Procedure Name	:	patch_in_nops
 47302                                  ;
 47303                                  ; 	Entry		: 	ES -> DOSDATA
 47304                                  ;
 47305                                  ;	Regs Mod	: 	cx, di
 47306                                  ;
 47307                                  ;	Description:
 47308                                  ;		This routine patches in 2 nops at the offsets specified in 
 47309                                  ;	patch_table. This basically enables the low mem stub to start 
 47310                                  ;	making XMS calls.
 47311                                  ;
 47312                                  ;--------------------------------------------------------------------------
 47313                                  
 47314                                  	; 04/11/2022
 47315                                  	; (MSDOS 5.0 MSDOS.SYS)
 47316                                  	; DOSCODE:0BC50h
 47317                                  
 47318                                  patch_table:	; label	byte
 47319                                  	;dw	offset dosdata:i0patch
 47320                                  	;dw	offset dosdata:i20patch
 47321                                  	;dw	offset dosdata:i21patch
 47322                                  	;dw	offset dosdata:i25patch
 47323                                  	;dw	offset dosdata:i26patch
 47324                                  	;dw	offset dosdata:i27patch
 47325                                  	;dw	offset dosdata:i2fpatch
 47326                                  	;dw	offset dosdata:cpmpatch
 47327 00008509 [D410]                  	dw	i0patch
 47328 0000850B [DE10]                  	dw	i20patch
 47329 0000850D [E810]                  	dw	i21patch
 47330 0000850F [F210]                  	dw	i25patch
 47331 00008511 [FC10]                  	dw	i26patch
 47332 00008513 [0611]                  	dw	i27patch
 47333 00008515 [1011]                  	dw	i2fpatch
 47334 00008517 [1A11]                  	dw	cpmpatch
 47335                                  
 47336                                  patch_table_size equ ($-patch_table)/2
 47337                                  
 47338                                  patch_in_nops:
 47339 00008519 50                      	push	ax
 47340 0000851A 56                      	push	si
 47341 0000851B BE[0985]                	mov	si,patch_table
 47342 0000851E B89090                  	mov	ax,9090h ; nop, nop
 47343                                  	; 17/12/2022
 47344                                  	; cx = 0
 47345                                  	;mov	cx,8
 47346                                  	;mov	cx,patch_table_size ; 8
 47347 00008521 B108                    	mov	cl,patch_table_size ; 8
 47348                                  pin_loop:
 47349 00008523 2E8B3C                  	mov	di,[cs:si]
 47350 00008526 AB                      	stosw
 47351                                  	;add	si,2
 47352                                  	; 17/12/2022
 47353 00008527 46                      	inc	si
 47354 00008528 46                      	inc	si
 47355 00008529 E2F8                    	loop	pin_loop
 47356 0000852B 5E                      	pop	si
 47357 0000852C 58                      	pop	ax
 47358 0000852D C3                      	retn
 47359                                  
 47360                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 47361                                  ; ---------------------------------------------------------------------------
 47362                                  ; MSDOS 5.0 - MSDOS.SYS offset BC77h, file offset 7EA7h
 47363                                  ; ---------------------------------------------------------------------------
 47364                                  
 47365                                  	; 05/12/2022 - temporary ; (paragraph alinment)
 47366                                  DOSCODE_END:
 47367                                  	;times	9 db 0	; db 9 dup(0)
 47368                                  	; 18/12/2022
 47369 0000852E 0000                    	dw	0  ;	times 2 db 0
 47370                                  
 47371                                  ;align 16
 47372                                  	; DOSCODE:BC80h	(MSDOS 5.0 MSDOS.SYS file offset 7EB0h)
 47373                                  	; MSDOS.SYS file offset: 32432 (start of DOSDATA)
 47374                                  
 47375                                  ; ---------------------------------------------------------------------------
 47376                                  
 47377                                  
 47378                                  ;memstrt label word
 47379                                  ; ---------------------------------------------------------------------------
 47380                                  ; MSDOS 6.21 - MSDOS.SYS offset BF69h, file offset 8189h
 47381                                  ; ---------------------------------------------------------------------------
 47382                                  
 47383                                  MEMSTRT: ; 25/04/2019 - Retro DOS v4.0
 47384                                  
 47385                                  ; if not ROMDOS, then we close the dos code segment, otherwise we close
 47386                                  ; the dos initialization segment
 47387                                  
 47388                                  ;ifndef ROMDOS
 47389                                  
 47390                                  ;doscode ends
 47391                                  
 47392                                  ;else
 47393                                  
 47394                                  ;;dosinitseg ends
 47395                                  
 47396                                  ;endif ; ROMDOS
 47397                                  
 47398                                  ;============================================================================
 47399                                  
 47400                                  ; DPUBLIC <ParaRound, cXMM_no_driver, cXMMexit, char_init_loop, charinit>
 47401                                  ; DPUBLIC <check_XMM, continit, dosinttabloop, endlist>
 47402                                  ; DPUBLIC <initiret, iset1, iset2, jumptabloop, nxtentry>
 47403                                  ; DPUBLIC <notmax,  patch_offset, perdrv>
 47404                                  ; DPUBLIC <perunit, po_iset1, po_iset2, po_iset3>
 47405                                  ; DPUBLIC <ps_set1, ps_set2, ps_set3, seg_reinit>
 47406                                  ; DPUBLIC <sr_done, version_fake_table, xxx>
 47407                                  
 47408                                  ;; burasý doscode sonu
 47409                                  
 47410                                  ;============================================================================
 47411                                  ; DOSDATA
 47412                                  ;============================================================================
 47413                                  ; 29/04/2019 - Retro DOS 4.0
 47414                                  
 47415                                  ;[BITS 16]
 47416                                  
 47417                                  ;[ORG 0]
 47418                                  
 47419                                  ; 25/04/2019 - Retro DOS v4.0
 47420                                  
 47421                                  ;============================================================================
 47422                                  ; DOSDATA - MSDOS 6.21 - MSDOS.SYS Offset 0BF70h, file offset 8190h
 47423                                  ;============================================================================
 47424                                  
 47425                                  ;align 16
 47426                                  	; DOSDATA (MSDOS.SYS kernel DATA) segment starts here...
 47427                                  	; (4970 bytes for MSDOS 6.21)
 47428                                  	; (4976 bytes for Retro DOS v4.0, 25/05/2019 modification.)
 47429                                  
 47430                                  ;============================================================================
 47431                                  ; MSCONST.ASM (MSDOS 6.0, 1991)
 47432                                  ;============================================================================
 47433                                  ; 03/11/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 47434                                  ; 25/04/2019 - Retro DOS 4.0 (MSDOS 6.21)
 47435                                  ; 16/07/2018 - Retro DOS 3.0	
 47436                                  
 47437                                  ;Break <Initialized data and data used at DOS initialization>
 47438                                  ;----------------------------------------------------------------------------
 47439                                  
 47440                                  ; We need to identify the parts of the data area that are relevant to tasks
 47441                                  ; and those that are relevant to the system as a whole. Under 3.0, the system
 47442                                  ; data will be gathered with the system code. The process data under 2.x will
 47443                                  ; be available for swapping and under 3.0 it will be allocated per-process.
 47444                                  ;
 47445                                  ; The data that is system data will be identified by [SYSTEM] in the comments
 47446                                  ; describing that data item.
 47447                                  
 47448                                  ;DOSDATA SEGMENT
 47449                                  
 47450                                  ; 04/11/2022
 47451                                  ;[ORG 0]
 47452                                  
 47453                                  ; ----------------------------------------------------------------------------
 47454                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 47455                                  ; ----------------------------------------------------------------------------
 47456                                  ; DOSDATA segment start offset from beginning of MSDOS.SYS file: 32432 (7EB0h)
 47457                                  ; (3DD0h+7EB0h = 0BC80h) - for MSDOS 5.0 kernel file -
 47458                                  ; ----------------------------------------------------------------------------
 47459                                  
 47460                                  ; 04/11/2022
 47461                                  
 47462                                  ;DOSDATA:0000h
 47463                                  
 47464                                  align 16
 47465                                  
 47466                                  ; ----------------------------------------------------------------------------
 47467                                  ; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 47468                                  ; ----------------------------------------------------------------------------
 47469                                  
 47470                                  segment .data  vstart=0 ; 06/12/2022
 47471                                  
 47472                                  ; ============================================================================
 47473                                  
 47474                                  ; 06/12/2022
 47475                                  ;DOSDATASTART equ $
 47476                                  DOSDATASTART:
 47477                                  
 47478                                  
 47479                                  ;hkn; add 4 bytes to get correct offsets since jmp has been removed in START
 47480                                  
 47481                                  	;; 03/11/2022
 47482                                  	;jmp	DOSINIT		; MSDOS 5.0 - MSDOS.SYS (DOSDATA:0000h)
 47483                                  
 47484                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 47485                                  	;db	4 dup (?)	
 47486 00000000 00<rep 4h>              	times	4 db 0
 47487                                  
 47488                                  	; 29/04/2019 - Retro DOS v4.0 modification
 47489                                  	;dw 	_$STARTCODE ; DOSCODE offset and/or size of DOSDATA
 47490                                  	;dw	0
 47491                                  
 47492                                  	;EVEN
 47493                                  
 47494                                  ;align 2
 47495                                  
 47496                                  ; WANGO!!! The following word is used by SHARE and REDIR to determin data
 47497                                  ; area compatability. This location must be incremented EACH TIME the data
 47498                                  ; area here gets mucked with.
 47499                                  ;
 47500                                  ; Also, do NOT change this position relative to DOSDATA:0.
 47501                                  
 47502                                  MSCT001S:	; LABEL BYTE
 47503                                  	
 47504                                  DataVersion:	
 47505 00000004 0100                    	dw	1	;AC000; [SYSTEM] version number for DOS DATA
 47506                                  
 47507                                  ;hkn; add 8 bytes to get correct offsets since BugTyp, BugLev and "BUG " has 
 47508                                  ;hkn; been removed to DOSCODE above
 47509                                  
 47510                                  ;M044
 47511                                  ; First part of save area for saving last para of Window memory
 47512                                  
 47513                                  WinoldPatch1:	; db 8 dup (?)	;M044
 47514 00000006 00<rep 8h>              	times	8 db 0
 47515                                  
 47516                                  	; MSDOS 6.21 DOSDATA:000Eh
 47517                                  MYNUM:			; Offset 000Eh
 47518 0000000E 0000                    	dw	0	; [SYSTEM] A number that goes with MYNAME
 47519                                  FCBLRU: 		; [SYSTEM] LRU count for FCB cache
 47520 00000010 0000                    	dw	0
 47521                                  OpenLRU:
 47522 00000012 0000                    	dw	0	; [SYSTEM] LRU count for FCB cache opens
 47523                                  OEM_HANDLER: 		
 47524 00000014 FFFFFFFF                	dd	-1	; [SYSTEM] Pointer to OEM handler code
 47525                                  
 47526                                  ;	BUGBUG - who uses LeaveAddr?  What if we want to rework the
 47527                                  ;;			way that we leave DOS???? - jgl
 47528                                  
 47529                                  LeaveAddr:
 47530 00000018 [F603]                  	dw	LeaveDOS  ; <<OFFSET DOSCODE:LeaveDOS>> ; [SYSTEM]
 47531                                  RetryCount:		
 47532 0000001A 0300                    	dw	3	; [SYSTEM] Share retries
 47533                                  RetryLoop:
 47534 0000001C 0100                    	dw	1	; [SYSTEM] Share retries
 47535                                  LastBuffer:
 47536 0000001E FFFFFFFF                	dd	-1	; [SYSTEM] Buffer queue recency pointer
 47537                                  CONTPOS:
 47538 00000022 0000                    	dw	0	; [SYSTEM] location in buffer of next read
 47539                                  arena_head:
 47540 00000024 0000                    	dw	0	; [SYSTEM] Segment # of first arena in memory
 47541                                  
 47542                                  ;; 16/07/2018
 47543                                  ;;***************************************************************************
 47544                                  ;; NOTE: INT 21H AH=52H !  (http://stanislavs.org/helppc/int_21-52.html)
 47545                                  ;;***************************************************************************
 47546                                  ;; INT 21,52 - Get Pointer to DOS "INVARS" (Undocumented)
 47547                                  ;;
 47548                                  ;;	AH = 52h
 47549                                  ;;
 47550                                  ;;	on return:
 47551                                  ;;	ES:BX = pointer to DOS "invars", a table of pointers used by DOS.
 47552                                  ;;		Known "invars" fields follow (varies with DOS version):
 47553                                  ;;
 47554                                  ;;	Offset Size		 Description
 47555                                  ;;
 47556                                  ;;	 -12   word   sharing retry count (DOS 3.1-3.3)
 47557                                  ;;	 -10   word   sharing retry delay  (DOS 3.1-3.3)
 47558                                  ;;	  -8   dword  pointer to current disk buffer (DOS 3.x)
 47559                                  ;;	  -4   word   pointer in DOS code segment of unread CON input;
 47560                                  ;;		      0 indicates no unread input (DOS 3.x)
 47561                                  ;;	  -2   word   segment of first Memory Control Block (MCB)
 47562                                  ;;	  00   dword  pointer to first DRIVE PARAMETER TABLE (A:) in chain
 47563                                  ;;	  04   dword  pointer to DOS System File Table (SFT)
 47564                                  ;;	  08   dword  pointer to $CLOCK device driver
 47565                                  ;;	  0C   dword  pointer to CON device driver
 47566                                  ;;	  10   byte   number of logical drives in system
 47567                                  ;;	  11   word   maximum bytes/block of any block device
 47568                                  ;;	  13   dword  pointer to DOS cache buffer header
 47569                                  ;;	  17 18bytes  NUL device header, first 4 bytes of device header
 47570                                  ;;		      point to the next device in device chain
 47571                                  ;;
 47572                                  ;;***************************************************************************
 47573                                  
 47574                                  ; The following block of data is used by SYSINIT. 
 47575                                  ; Do not change the order or size of this block
 47576                                  
 47577                                  ;SYSINITVAR:
 47578                                  ;----------------------------------------------------------------------------
 47579                                  SYSINITVARS:
 47580                                  DPBHEAD:
 47581 00000026 00000000                	dd	0	; [SYSTEM] Pointer to head of DPB-FAT list
 47582                                  SFT_ADDR:
 47583 0000002A [CC000000]              	dd	SFTABL	; [SYSTEM] Pointer to first SFT table
 47584                                  BCLOCK:
 47585 0000002E 00000000                	dd	0	; [SYSTEM] The CLOCK device
 47586                                  BCON:
 47587 00000032 00000000                	dd	0	; [SYSTEM] Console device entry points
 47588                                  MAXSEC:
 47589 00000036 8000                    	dw	128	; [SYSTEM] Maximum allowed sector size
 47590                                  BUFFHEAD:
 47591 00000038 00000000                	dd	0	; [SYSTEM] Pointer to head of buffer queue
 47592                                  CDSADDR:
 47593 0000003C 00000000                	dd	0	; [SYSTEM] Pointer to curdir structure table
 47594                                  SFTFCB:
 47595 00000040 00000000                	dd	0	; [SYSTEM] pointer to FCB cache table
 47596                                  KEEPCOUNT:
 47597 00000044 0000                    	dw	0	; [SYSTEM] count of FCB opens to keep
 47598                                  NUMIO:
 47599 00000046 00                      	db	0	; [SYSTEM] Number of disk tables
 47600                                  CDSCOUNT:
 47601 00000047 00                      	db	0	; [SYSTEM] Number of CDS structures in above
 47602                                  
 47603                                  ; A fake header for the NUL device
 47604                                  NULDEV:
 47605 00000048 00000000                	dd	0	; [SYSTEM] Link to rest of device list
 47606                                  	;dw	8004h
 47607 0000004C 0480                    	dw	DEVTYP|ISNULL ; [SYSTEM] Null device attributes
 47608 0000004E [160E]                  	dw	SNULDEV	; [SYSTEM] Strategy entry point
 47609 00000050 [1B0E]                  	dw	INULDEV	; [SYSTEM] Interrupt entry point
 47610 00000052 4E554C2020202020        	db	"NUL     " ; [SYSTEM] Name of null device
 47611                                  SPLICES:
 47612 0000005A 00                      	db	0	; [SYSTEM] TRUE => splices being done
 47613                                  
 47614                                  Special_Entries:
 47615 0000005B 0000                    	dw	0	; [SYSTEM] address of special entries ;AN000;
 47616                                  UU_IFS_DOS_CALL:
 47617 0000005D 00000000                	dd	0	; [SYSTEM] entry for IFS DOS service ;AN000;
 47618                                  ; 
 47619                                  ; UU_IFS_HEADER:
 47620                                  ; 	dd	0	; [SYSTEM] IFS header chain ;AN000;
 47621                                  
 47622                                  ChkCopyProt:
 47623 00000061 0000                    	dw	0	; M068
 47624                                  A20OFF_PSP:
 47625 00000063 0000                    	dw	0	; M068
 47626                                  BUFFERS_PARM1:
 47627 00000065 0000                    	dw	0	; [SYSTEM] value of BUFFERS= ,m	;AN000;
 47628                                  BUFFERS_PARM2:
 47629 00000067 0000                    	dw	0	; [SYSTEM] value of BUFFERS= ,n ;AN000;
 47630                                  BOOTDRIVE:
 47631 00000069 00                      	db	0	; [SYSTEM] the boot drive ;AN000;
 47632                                  DDMOVE:
 47633 0000006A 00                      	db	0 	; [SYSTEM] 1 if we need DWORD move ;AN000;
 47634                                  EXT_MEM_SIZE:
 47635 0000006B 0000                    	dw	0	; [SYSTEM] extended memory size	;AN000;
 47636                                  
 47637                                  HASHINITVAR: ; LABEL   WORD	; AN000;
 47638                                  ;
 47639                                  ; Replaced by next two declarations
 47640                                  ;
 47641                                  ;UU_BUF_HASH_PTR:
 47642                                  ;	dd	0	; [SYSTEM] buffer Hash table addr
 47643                                  ;UU_BUF_HASH_COUNT:
 47644                                  ;	dw	1	; [SYSTEM] number of Hash entries
 47645                                  
 47646                                  BufferQueue:
 47647 0000006D 00000000                	dd	0	; [SYSTEM] Head of the buffer Queue
 47648                                  DirtyBufferCount:
 47649 00000071 0000                    	dw	0	; [SYSTEM] Count of Dirty buffers in the Que
 47650                                  			; BUGBUG ---- change to byte
 47651                                  SC_CACHE_PTR:
 47652 00000073 00000000                	dd	0	; [SYSTEM] secondary cache pointer
 47653                                  SC_CACHE_COUNT:
 47654 00000077 0000                    	dw	0 	; [SYSTEM] secondary cache count
 47655                                  BuffInHMA:
 47656 00000079 00                      	db	0	; Flag to indicate that buffs are in HMA
 47657                                  LoMemBuff:
 47658 0000007A 00000000                	dd	0	; Ptr to intermediate buffer
 47659                                  			;  in Low mem when buffs are in HMA
 47660                                  ;
 47661                                  ; All variables which have UU_ as prefix can be reused for other
 47662                                  ; purposes and can be renamed. All these variables were used for
 47663                                  ; EMS support of Buffer Manager. Now they are useless for Buffer
 47664                                  ; manager ---- MOHANS
 47665                                  ;
 47666                                  	;I_am	UU_BUF_EMS_FIRST_PAGE,3,<0,0,0>  
 47667                                  UU_BUF_EMS_FIRST_PAGE:	
 47668 0000007E 000000                  	db	0,0,0	; holds the first page above 640K
 47669                                  
 47670                                  	;;I_am	UU_BUF_EMS_NPA640,WORD,<0> ; holds the number of pages 
 47671                                  ;UU_BUF_EMS_NPA640:			   ; above 640K	
 47672                                  ;	dw	0			
 47673                                  
 47674                                  CL0FATENTRY:
 47675 00000081 FFFF                    	dw	-1	; M014:	Holds the data that
 47676                                  			; is used in pack/unpack rts.
 47677                                  			; in fat.asm if cluster 0 is specified.
 47678                                  			; SR;
 47679                                  IoStatFail:
 47680 00000083 00                      	db	0	; IoStatFail has been added to 
 47681                                  			; record a fail on an I24 
 47682                                  			; issued from IOFUNC on a status call. 
 47683                                  
 47684                                  ;***	I_am	UU_BUF_EMS_MODE,BYTE,<-1>	; EMS mode 	;AN000;
 47685                                  ;***	I_am	UU_BUF_EMS_HANDLE,BYTE		; buffer EMS handle ;AN000;
 47686                                  ;***	I_am	UU_BUF_EMS_PAGE_FRAME,WORD ,<-1>; EMS page frame # ;AN000;
 47687                                  ;***	I_am	UU_BUF_EMS_SEG_CNT,WORD,<1>	; EMS seg count	;AN000;
 47688                                  ;***	I_am	UU_BUF_EMS_PFRAME,WORD		; EMS page frame seg address ;AN000;
 47689                                  ;***	I_am	UU_BUF_EMS_RESERV,WORD,<0> 	; reserved	;AN000;
 47690                                  ;
 47691                                  ;***	I_am	UU_BUF_EMS_MAP_BUFF,1,<0>	; this is not used to save the
 47692                                  						; state of the 	buffers page.
 47693                                  						; This one byte is retained to
 47694                                  						; keep the size of this data 
 47695                                  						; block the same.;
 47696                                  ALLOCMSAVE:
 47697 00000084 00                      	db	0	; M063: temp var. used to 
 47698                                  			; M063: save alloc method in
 47699                                  			; M063: msproc.asm
 47700                                  A20OFF_COUNT:
 47701 00000085 00                      	db	0	; M068: indiactes the # of 
 47702                                  			; M068: int 21 calls for 
 47703                                  			; M068: which A20 is off
 47704                                  DOS_FLAG:
 47705 00000086 00                      	db	0	; see DOSSYM.INC for Bit 
 47706                                  			; definitions
 47707                                  UNPACK_OFFSET:
 47708 00000087 0000                    	dw	0	; saves pointer to the start
 47709                                  			; of unpack code in exepatch.
 47710                                  			; asm.
 47711                                  UMBFLAG:
 47712 00000089 00                      	db	0 	; M003: bit 0 indicates the 
 47713                                  			; M003: link state of the UMBs
 47714                                  			; M003: whether linked or not 
 47715                                  			; M003: to the DOS arena chain
 47716                                  SAVE_AX:
 47717 0000008A 0000                    	dw	0	; M000: temp varibale to store ax
 47718                                  			; M000: in msproc.asm
 47719                                  UMB_HEAD:
 47720 0000008C FFFF                    	dw	-1	; M000: this is initialized to  
 47721                                  			; M000: the first umb arena by 
 47722                                  			; M000: BIOS sysinit.
 47723                                  START_ARENA:
 47724 0000008E 0100                    	dw	1	; M000: this is the first arena 
 47725                                  			; M000: from which DOS will 
 47726                                  			; M000: start its scan for alloc.
 47727                                  
 47728                                  ; End of SYSINITVar block
 47729                                  ;----------------------------------------------------------------------------
 47730                                  
 47731                                  ; 25/04/2019 - Retro DOS v4.0
 47732                                  
 47733                                  ; 16/07/2018
 47734                                  ; MSDOS 3.3 (& MDOS 6.0)
 47735                                  
 47736                                  ;
 47737                                  ; Sharer jump table
 47738                                  ;
 47739                                  
 47740                                  ;PUBLIC	JShare
 47741                                  	;EVEN
 47742                                  
 47743                                  ;JShare	LABEL	DWORD
 47744                                  ;	DW	OFFSET DOSCODE:BadCall, 0
 47745                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	1   MFT_enter
 47746                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	2   MFTClose
 47747                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	3   MFTclU
 47748                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	4   MFTCloseP
 47749                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	5   MFTCloN
 47750                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	6   set_block
 47751                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	7   clr_block
 47752                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	8   chk_block
 47753                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	9   MFT_get
 47754                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	10  ShSave
 47755                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	11  ShChk
 47756                                  ;	DW	OFFSET DOSCODE:OKCall , 0  ;	12  ShCol
 47757                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	13  ShCloseFile
 47758                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	14  ShSU
 47759                                  
 47760                                  align 2
 47761                                  
 47762                                  JShare:
 47763 00000090 [3607]0000              		DW	BadCall,0
 47764 00000094 [3A07]0000              MFT_enter:	DW	OKCall, 0  ; 1   MFT_enter
 47765 00000098 [3A07]0000              MFTClose:	DW	OKCall, 0  ; 2   MFTClose
 47766 0000009C [3607]0000              MFTclU:		DW	BadCall,0  ; 3   MFTclU
 47767 000000A0 [3607]0000              MFTCloseP:	DW	BadCall,0  ; 4   MFTCloseP
 47768 000000A4 [3607]0000              MFTCloN:	DW	BadCall,0  ; 5   MFTCloN
 47769 000000A8 [3607]0000              set_block:	DW	BadCall,0  ; 6   set_block
 47770 000000AC [3607]0000              clr_block:	DW	BadCall,0  ; 7   clr_block
 47771 000000B0 [3A07]0000              chk_block:	DW	OKCall, 0  ; 8   chk_block
 47772 000000B4 [3607]0000              MFT_get:	DW	BadCall,0  ; 9   MFT_get
 47773 000000B8 [3607]0000              ShSave:		DW	BadCall,0  ; 10  ShSave
 47774 000000BC [3607]0000              ShChk:		DW	BadCall,0  ; 11  ShChk
 47775 000000C0 [3A07]0000              ShCol:		DW	OKCall, 0  ; 12  ShCol
 47776 000000C4 [3607]0000              ShCloseFile:	DW	BadCall,0  ; 13  ShCloseFile
 47777 000000C8 [3607]0000              ShSU:		DW	BadCall,0  ; 14  ShSU
 47778                                  
 47779                                  
 47780                                  ;============================================================================
 47781                                  ; CONST2.ASM (MSDOS 6.0, 1991)
 47782                                  ;============================================================================
 47783                                  ; 25/04/2019 - Retro DOS 4.0 
 47784                                  ; 16/07/2018 - Retro DOS 3.0	
 47785                                  
 47786                                  ;Break <Initialized data and data used at DOS initialization>
 47787                                  ;----------------------------------------------------------------------------
 47788                                  
 47789                                  ; We need to identify the parts of the data area that are relevant to tasks
 47790                                  ; and those that are relevant to the system as a whole.  Under 3.0, the system
 47791                                  ; data will be gathered with the system code.  The process data under 2.x will
 47792                                  ; be available for swapping and under 3.0 it will be allocated per-process.
 47793                                  ;
 47794                                  ; The data that is system data will be identified by [SYSTEM] in the comments
 47795                                  ; describing that data item.
 47796                                  
 47797                                  ;DOSDATA SEGMENT WORD PUBLIC 'DATA'
 47798                                  
 47799                                  ;
 47800                                  ; Table of routines for assignable devices
 47801                                  ;
 47802                                  ; MSDOS allows assignment if the following standard devices:
 47803                                  ;   stdin  (usually CON input)
 47804                                  ;   stdout (usually CON output)
 47805                                  ;   auxin  (usually AUX input)
 47806                                  ;   auxout (usually AUX output)
 47807                                  ;   stdlpt (usually PRN output)
 47808                                  ;
 47809                                  ; SPECIAL NOTE:
 47810                                  ;   Status of a file is a strange idea. We choose to handle it in this manner:
 47811                                  ;   If we're not at end-of-file, then we always say that we have a character.
 47812                                  ;   Otherwise, we return ^Z as the character and set the ZERO flag. In this
 47813                                  ;   manner we can support program written under the old DOS (they use ^Z as EOF
 47814                                  ;   on devices) and programs written under the new DOS (they use the ZERO flag
 47815                                  ;   as EOF).
 47816                                  
 47817                                  ; Default SFTs for boot up
 47818                                  
 47819                                  		;PUBLIC	SFTABL
 47820                                  
 47821                                  SFTABL:	   ; LABEL   DWORD		; [SYSTEM] file table
 47822 000000CC FFFF                    		DW -1			; [SYSTEM] link to next table
 47823 000000CE FFFF                    		DW -1			; [SYSTEM] link seg to next table
 47824 000000D0 0500                    		DW sf_default_number	; [SYSTEM] Number of entries in table
 47825                                  		;times 295 db 0 ; MSDOS 6.0
 47826 000000D2 00<rep 127h>            		times (sf_default_number*sf_entry_size) db 0
 47827                                  
 47828                                  ; the next two variables relate to the position of the logical stdout/stdin
 47829                                  ; cursor. They are only meaningful when stdin/stdout are assigned to the
 47830                                  ; console.
 47831                                  		; DOSDATA:01F9h (MSDOS 6.21)
 47832 000001F9 00                      CARPOS:		db 0			; [SYSTEM] cursor position in stdin
 47833 000001FA 00                      STARTPOS:	db 0			; [SYSTEM] position of cursor at beginning
 47834                                  					;	   of buffered input call
 47835 000001FB 00<rep 80h>             INBUF:		times 128 db 0		; [SYSTEM] general device input buffer
 47836 0000027B 00<rep 83h>             CONBUF:		times 131 db 0		; [SYSTEM] The rest of INBUF and console buffer
 47837                                  		; DOSDATA:02FEh (MSDOS 6.21)
 47838 000002FE 00                      PFLAG:		db 0			; [SYSTEM] printer echoing flag
 47839 000002FF 00                      VERFLG:		db 0			; [SYSTEM] Initialize with verify off
 47840 00000300 03                      CHARCO:		db 00000011b		; [SYSTEM] Allows statchks every 4 chars...
 47841                                  switch_character:
 47842 00000301 2F                      chSwitch:	db '/'			; UNUSED - obsolete datum, can be reused
 47843 00000302 00                      AllocMethod:	db 0			; [SYSTEM] how to alloc first(best)last
 47844 00000303 00                      fShare:		db 0			; [SYSTEM] TRUE => sharing installed
 47845 00000304 01                      DIFFNAM:	db 1			; [SYSTEM] Indicates when MYNAME has changed
 47846 00000305 20<rep 10h>             MYNAME:		times 16 db 20h		; [SYSTEM] My network name
 47847                                  
 47848                                  ; The following table is a list of addresses that the sharer patches to be
 47849                                  ; PUSH AX to enable the critical sections
 47850                                  
 47851                                  		; DOSDATA:0315h (MSDOS 6.21)
 47852                                  
 47853                                  ;PUBLIC	CritPatch
 47854                                  
 47855                                  CritPatch:	; LABEL WORD
 47856                                  
 47857                                  ;IRP sect,<critDisk,critDevice>
 47858                                  
 47859                                  ;IF (NOT REDIRECTOR) AND (NOT SHAREF)
 47860                                  ;
 47861                                  ;SR; Change code patch address to a variable in data segment
 47862                                  ;
 47863                                  ;       dw OFFSET DOSDATA: redir_patch
 47864                                  ;       dw OFFSET DOSDATA: redir_patch
 47865                                  ;
 47866                                  ;;hkn	Short_Addr  E&sect
 47867                                  ;;hkn	Short_Addr  L&sect
 47868                                  ;
 47869                                  ;ELSE
 47870                                  ;	DW	0
 47871                                  ;	DW	0
 47872                                  ;ENDIF
 47873                                  ;ENDM
 47874                                  ;	DW	0
 47875                                  
 47876                                  	; 25/07/2019 - Retro DOS v4.0 (MSDOS 6.21)
 47877                                   
 47878 00000315 [860D]                  	dw 	redir_patch
 47879 00000317 [860D]                  	dw 	redir_patch			
 47880 00000319 [860D]                  	dw	redir_patch
 47881 0000031B [860D]                  	dw 	redir_patch
 47882                                  
 47883 0000031D 0000                    	dw	0
 47884                                  
 47885                                  ; WARNING!!! PRINT and PSPRINT *REQUIRE* ErrorMode to precede INDOS.
 47886                                  ; Also, IBM server 1.0 requires this also.
 47887                                  
 47888                                  	;EVEN			; Force swap area to start on word boundry
 47889 0000031F 90                      align 2
 47890                                  	;PUBLIC	SWAP_START
 47891                                  SWAP_START:	; LABEL BYTE
 47892 00000320 00                      ERRORMODE:	db 0		; Flag for INT 24 processing
 47893 00000321 00                      INDOS:		db 0		; DOS status for interrupt processing
 47894 00000322 FF                      WPERR:		db -1		; Write protect error flag
 47895 00000323 00                      EXTERR_LOCUS:	db 0		; Extended Error Locus
 47896 00000324 0000                    EXTERR:		dw 0		; Extended Error code
 47897                                  
 47898                                  ;WARNING Following two bytes Accessed as word in $GetExtendedError
 47899 00000326 00                      EXTERR_ACTION:	db 0		; Extended Error Action
 47900 00000327 00                      EXTERR_CLASS:	db 0		; Extended Error Class
 47901                                  ; end warning
 47902                                   
 47903 00000328 00000000                EXTERRPT:	dd 0		; Extended Error pointer
 47904                                  
 47905 0000032C 80000000                DMAADD:		dd 80h		; User's disk transfer address (disp/seg)
 47906 00000330 0000                    CurrentPDB:	dw 0		; Current process identifier
 47907 00000332 0000                    ConC_Spsave:	dw 0		; saved SP before ^C
 47908 00000334 0000                    exit_code:	dw 0		; exit code of last proc.
 47909 00000336 00                      CURDRV:		db 0		; Default drive (init A)
 47910 00000337 00                      CNTCFLAG:	db 0		; ^C check in dispatch disabled
 47911                                  ;				; F.C. 2/17/86
 47912 00000338 00                      CPSWFLAG:	db 0		; Code Page Switching Flag  DOS 4.00
 47913 00000339 00                      CPSWSAVE:	db 0		; copy of above in case of ABORT
 47914                                  ;align 2
 47915                                  SWAP_ALWAYS:	; 05/08/2018
 47916 0000033A 0000                    USER_IN_AX:	dw 0		; User INPUT AX value (used for
 47917                                  				;   extended error type stuff.
 47918                                  				;   NOTE: does not have Correct value on
 47919                                  				;   1-12, OEM, Get/Set CurrentPDB,
 47920                                  				;   GetExtendedError system calls)
 47921 0000033C 0000                    PROC_ID:	dw 0		; PID for sharing (0 = local)
 47922 0000033E 0000                    USER_ID:	dw 0		; Machine for sharing (0 = local)
 47923 00000340 0000                    FirstArena:	dw 0		; first free block found
 47924 00000342 0000                    BestArena:	dw 0		; best free block found
 47925 00000344 0000                    LastArena:	dw 0		; last free block found
 47926 00000346 0000                    ENDMEM:		dw 0		; End of memory used in DOSINIT
 47927 00000348 0000                    LASTENT:	dw 0		; Last entry for directory search
 47928 0000034A 00                      FAILERR:	db 0		; NZ if user did FAIL on I 24
 47929 0000034B 00                      ALLOWED:	db 0		; Allowed I 24 answers (see allowed_)
 47930 0000034C 00                      NoSetDir:	db 0		; true -> do not set directory
 47931 0000034D 00                      DidCTRLC:	db 0		; true -> we did a ^C exit
 47932 0000034E 00                      SpaceFlag:	db 0		; true -> embedded spaces are allowed in FC
 47933                                  
 47934                                  ; Warning!  The following items are accessed as a WORD in TIME.ASM
 47935                                  	;EVEN
 47936 0000034F 90                      align 2
 47937                                  		; DOSDATA:0350h (MSDOS 6.21)
 47938 00000350 00                      DAY:		db 0		; Day of month
 47939 00000351 00                      MONTH:		db 0		; Month of year
 47940 00000352 0000                    YEAR:		dw 0		; Year (with century)
 47941 00000354 FFFF                    DAYCNT:		dw -1		; Day count from beginning of year
 47942 00000356 00                      WEEKDAY:	db 0		; Day of week
 47943                                  ; end warning
 47944                                  
 47945 00000357 00                      CONSWAP:	db 0		; TRUE => console was swapped during device read
 47946 00000358 01                      IDLEINT:	db 1		; TRUE => idle int is allowed
 47947 00000359 00                      fAborting:	db 0		; TRUE => abort in progress
 47948                                  
 47949                                  ; Combination of all device call parameters
 47950                                  	;PUBLIC	DEVCALL 	;
 47951                                  ;DEVCALL SRHEAD	<>		; basic header for disk packet
 47952                                  DEVCALL: ; 08/08/2018
 47953 0000035A 00                      DEVCALL_REQLEN:  db 0 		;Length in bytes of request block
 47954 0000035B 00                      DEVCALL_REQUNIT: db 0		;Device unit number
 47955 0000035C 00                      DEVCALL_REQFUNC: db 0		;Type of request
 47956 0000035D 0000                    DEVCALL_REQSTAT: dw 0		;Status Word
 47957 0000035F 00<rep 8h>                       times 8 db 0		;Reserved for queue links
 47958                                  
 47959                                  	;PUBLIC	CALLUNIT
 47960                                  CALLUNIT: ; LABEL   BYTE	; unit number for disk
 47961                                  CALLFLSH: ; LABEL   WORD	;
 47962 00000367 00                      CALLMED:	db 0		; media byte
 47963                                  CALLBR:	  ; LABEL   DWORD	;
 47964                                  	;PUBLIC	CALLXAD 	;
 47965                                  CALLXAD:  ; LABEL   DWORD	;
 47966 00000368 00                      CALLRBYT:	db 0		;
 47967                                  	;PUBLIC	CALLVIDM	;
 47968                                  CALLVIDM: ; LABEL   DWORD	;
 47969 00000369 00<rep 3h>              	times 3 db 0	;
 47970                                  	;PUBLIC CallBPB		;
 47971                                  CALLBPB:  ; LABEL   DWORD	;
 47972                                  CALLSCNT:			;
 47973 0000036C 0000                    		dw 0		;
 47974                                  	;PUBLIC	CALLSSEC	;
 47975                                  CALLSSEC: ; LABEL   WORD	;
 47976 0000036E 0000                    		dw 0		;
 47977 00000370 00000000                CALLVIDRW:	dd 0		;
 47978                                  ;MSDOS 6.0
 47979 00000374 00000000                CALLNEWSC:	dd 0		; starting sector for >32mb
 47980 00000378 00000000                CALLDEVAD:	dd 0		; stash for device entry point
 47981                                  
 47982                                  ; Same as above for I/O calls	;
 47983                                  				;
 47984                                  	;PUBLIC	IOCall		;
 47985                                  ;IOCALL	SRHEAD	<>		;
 47986                                  IOCALL:	; 07/08/2018
 47987 0000037C 00                      IOCALL_REQLEN:	db 0		;Length in bytes of request block
 47988 0000037D 00                      IOCALL_REQUNIT:	db 0		;Device unit number
 47989 0000037E 00                      IOCALL_REQFUNC: db 0		;Type of request
 47990 0000037F 0000                    IOCALL_REQSTAT: dw 0		;Status Word
 47991 00000381 00<rep 8h>              	times 8	db 0		;Reserved for queue links
 47992                                  IOFLSH:	  ; LABEL   WORD	;
 47993                                          ;PUBLIC  IORCHR		;
 47994                                  IORCHR:	  ; LABEL   BYTE	;
 47995 00000389 00                      IOMED:		db 0		;
 47996 0000038A 00000000                IOXAD:		dd 0		;
 47997 0000038E 0000                    IOSCNT:		dw 0		;
 47998 00000390 0000                    IOSSEC:		dw 0		;
 47999                                  
 48000                                  ; Call struct for DSKSTATCHK	;
 48001 00000392 0E                      DSKSTCALL:	db DRDNDHL 	; = 14
 48002 00000393 00                      		db 0
 48003 00000394 05                      DSKSTCOM:	db DEVRDND	; = 5
 48004 00000395 0000                    DSKSTST:	dw 0		;
 48005 00000397 00<rep 8h>              	times 8	db 0		;
 48006 0000039F 00                      DSKCHRET:	db 0		;
 48007                                  
 48008                                  ;hkn; short_addr has been changed to provide offset in DOSCODE.
 48009                                  ;hkn; deviobuf is in DATA seg (DOSDATA)
 48010                                  ;hkn   short_addr  DEVIOBUF	;
 48011                                  	
 48012 000003A0 [BC03]                  DEVIOBUF_PTR	dw DEVIOBUF
 48013 000003A2 0000                    DOSSEG_INIT	dw 0		; DOS segment set at Init
 48014 000003A4 0100                    DSKSTCNT:	dw 1		;
 48015 000003A6 0000                    		dw 0		;
 48016                                  
 48017 000003A8 00                      CreatePDB:	db 0		; flag for creating a process
 48018                                  
 48019                                  ;MSDOS 6.0
 48020                                  Lock_Buffer:	; LABEL  DWORD	;MS. DOS Lock Buffer for Ext Lock
 48021 000003A9 00000000                		dd 0		;MS. position
 48022 000003AD 00000000                		dd 0		;MS. length
 48023                                  
 48024                                  ;hkn; the foll. was moved from dosmes.asm.
 48025                                  
 48026                                  ; 29/01/2024 Retro DOS v5.0 (PCDOS v7.1 IBMDOS.COM)
 48027                                  ; DOSDATA:03B1h
 48028 000003B1 90                      IOCTL_drvnum:	db 90h ; nop
 48029                                  
 48030                                  	;EVEN
 48031                                  align 2				; needed to maintain offsets
 48032                                  
 48033                                  		; DOSDATA:03B2h (MSDOS 6.21)
 48034                                  USERNUM:
 48035 000003B2 0000                     		dw 0		; 24 bit user number
 48036 000003B4 00                      		db 0
 48037                                  ;IF IBM
 48038                                  ;IF IBMCOPYRIGHT
 48039                                  ;OEMNUM:	DB 0		; 8 bit OEM number
 48040                                  ;ELSE
 48041                                  ;OEMNUM:	DB 0FFh		; 8 bit OEM number
 48042                                  ;ENDIF
 48043                                  ;ELSE
 48044 000003B5 FF                      OEMNUM:		DB 0FFh
 48045                                  ;ENDIF
 48046                                  
 48047                                  ;============================================================================
 48048                                  ; MS_DATA.ASM (MSDOS 6.0, 1991)
 48049                                  ;============================================================================
 48050                                  ; 25/04/2019 - Retro DOS 4.0
 48051                                  
 48052                                  ; Retro DOS v4.0 NOTE: (by Erdogan Tan, 25/04/2019)
 48053                                  ; ----------------------------------------------------------
 48054                                  ; This data section which was named as uninitialized data
 48055                                  ; (as overlayed by initialization code) but follows 
 48056                                  ; initialized data section from DOSDATA:03B6h address
 48057                                  ; (in otherwords, the method is different than MSDOS 3.3,
 48058                                  ; and there is not overlaying..)
 48059                                  ; **********************************************************
 48060                                  ; Reference: MSDOS 6.21 kernel DOSDATA section (4970 bytes)
 48061                                  ; follows DOSCODE section in the kernel file (MSDOS.SYS) 
 48062                                  ; (it is located at offset 0BF70h, file offset 0BF70h-3DE0h) 
 48063                                  ; but starts from offset 0 (ORG 0) and ends at offset 1370h.
 48064                                  ; TIMEBUF is at offset 03B6h.
 48065                                  ; **********************************************************	
 48066                                  
 48067                                  ;Break <Uninitialized data overlayed by initialization code>
 48068                                  ;----------------------------------------------------------------------------
 48069                                  ;DOSDATA    SEGMENT WORD PUBLIC 'DATA'
 48070                                  ; Init code overlaps with data area below
 48071                                  
 48072                                  ; 	ORG     0
 48073                                  
 48074                                  MSDAT001S:	; label byte
 48075                                  
 48076                                  ; DOSDATA:03B6h	; MSDOS 6.21 (MSDOS.SYS, file offset 0BF70h-3DE0h+3B6h)
 48077                                  TIMEBUF: ;	times 6 db 0
 48078 000003B6 0000<rep 3h>            	times 3 dw	0		; Time read from clock device
 48079 000003BC 0000                    DEVIOBUF:	dw	0		; Buffer for I/O under file assignment
 48080                                  
 48081                                  ; The following areas are used as temp buffer in EXEC system call
 48082                                  
 48083                                  ; DOSDATA:03BEh
 48084                                  OPENBUF: ;times 64  dw	0
 48085 000003BE 00<rep 80h>             	times	128 db	0		; buffer for name operations
 48086                                  RENBUF:	
 48087 0000043E 00<rep 80h>             	times	128 db	0		; buffer for rename destination
 48088                                  
 48089                                  ; Buffer for search calls
 48090                                  SEARCHBUF:	
 48091 000004BE 00<rep 35h>             	times	53  db	0		; internal search buffer
 48092                                  DUMMYCDS:  ;times 88 db 0
 48093 000004F3 00<rep 58h>             	times	curdirLen db 0
 48094                                  
 48095                                  ; End of contiguous buffer
 48096                                   
 48097                                  ; Temporary directory entry for use by many routines. Device directory
 48098                                  ; entries (bogus) are built here.
 48099                                  
 48100                                  ; DOSDATA:054Bh
 48101                                  
 48102                                  DEVFCB:	; LABEL   BYTE			; Uses NAME1, NAME2, combined
 48103                                  
 48104                                  ; WARNING..  do not alter position of NAME1 relative to DEVFCB
 48105                                  ; without first examining BUILD_DEVICE_ENT. Look carefully at DOS_RENAME
 48106                                  ; as well as it is the only guy who uses NAME2 and DESTSTART.
 48107                                  
 48108                                  NAME1:	
 48109 0000054B 00<rep Ch>                      times 	12 db	0		; File name buffer
 48110                                  NAME2:
 48111 00000557 00<rep Dh>              	times	13 db	0 		;
 48112                                  DESTSTART:
 48113 00000564 0000                    	dw	0			;
 48114                                          ;DB      ((SIZE DIR_ENTRY) - ($ - DEVFCB)) DUP (?)
 48115                                  	;times	5  db	0
 48116 00000566 00<rep 5h>              	times	((dir_entry.size)-($-DEVFCB)) db 0
 48117                                  
 48118                                  ; End Temporary directory entry.
 48119                                  
 48120 0000056B 00                      ATTRIB:	db	0		; storage for file attributes
 48121                                  EXTFCB:	
 48122 0000056C 00                      	db	0		; TRUE => extended FCB in use
 48123                                  SATTRIB:
 48124 0000056D 00                      	db	0		; Storage for search attributes
 48125                                  OPEN_ACCESS:
 48126 0000056E 00                      	db	0		; access of open system call
 48127                                  FOUNDDEL:
 48128 0000056F 00                      	db	0		; true => file was deleted
 48129                                  FOUND_DEV:
 48130 00000570 00                      	db	0		; true => search found a device
 48131                                  FSPLICE:
 48132 00000571 00                      	db	0		; true => do a splice in transpath
 48133                                  FSHARING:
 48134 00000572 00                      	db	0		; TRUE => no redirection
 48135                                  SECCLUSPOS:
 48136 00000573 00                      	db	0		; Position of first sector within cluster
 48137 00000574 00                      TRANS:	db	0		;
 48138 00000575 00                      READOP:	db	0		;
 48139                                  THISDRV:
 48140 00000576 00                      	db	0		;
 48141                                  CLUSFAC:
 48142 00000577 00                      	db	0		;
 48143                                  CLUSSPLIT:
 48144 00000578 00                      	db	0		;
 48145                                  INSMODE:
 48146 00000579 00                      	db	0		; true => insert mode in buffered read
 48147 0000057A 00                      CMETA:	db	0		; count of meta'ed components found
 48148 0000057B 00                      VOLID:	db	0		;
 48149                                  EXIT_TYPE:
 48150 0000057C 00                      	db	0		; type of exit...
 48151                                   
 48152                                  	;EVEN
 48153                                  
 48154 0000057D 90                      align 2
 48155                                  
 48156                                  ; DOSDATA:057Eh
 48157                                  
 48158                                  ; WARNING - the following two items are accessed as a word
 48159                                  
 48160                                  CREATING:
 48161 0000057E 00                      	db	0		; true => creating a file
 48162 0000057F 00                      DELALL:	db	0		; = 0 iff BUGBUG
 48163                                  				; = DIRFREE iff BUGBUG
 48164                                  EXITHOLD:
 48165 00000580 00000000                	dd	0		; Temp location for proc terminate
 48166                                  USER_SP:
 48167 00000584 0000                    	dw	0		; User SP for system call
 48168                                  USER_SS:
 48169 00000586 0000                    	dw	0		; User SS for system call
 48170                                  CONTSTK:
 48171 00000588 0000                    	dw	0		;
 48172                                  THISDPB:
 48173 0000058A 00000000                	dd	0		;
 48174                                  CLUSSAVE:
 48175 0000058E 0000                    	dw	0		;
 48176                                  CLUSSEC:
 48177 00000590 00000000                	dd	0		;>32mb			AC0000
 48178                                  PREREAD:
 48179 00000594 0000                    	dw	0		; 0 means preread; 1 means optional
 48180 00000596 0000                    FATBYT:	dw	0		; Used by ALLOCATE
 48181                                  FATBYTE:
 48182 00000598 0000                    	dw	0		; Used by $SLEAZEFUNC
 48183                                  ; DOSDATA:059Ah
 48184 0000059A 00000000                DEVPT:	dd	0		;
 48185                                  THISSFT:
 48186 0000059E 00000000                	dd	0		; Address of user SFT
 48187                                  THISCDS:
 48188 000005A2 00000000                	dd	0		; Address of current CDS
 48189                                  THISFCB:
 48190 000005A6 00000000                	dd	0		; Address of user FCB
 48191 000005AA FFFF                    SFN:	dw	-1		; SystemFileNumber found for accessfile
 48192 000005AC 0000                    JFN:	dw	0		; JobFileNumber found for accessfile
 48193 000005AE 00000000                PJFN:	dd	0		; PointerJobFileNumber found for accessfile
 48194                                  WFP_START:
 48195 000005B2 0000                    	dw	0		;
 48196                                  REN_WFP:
 48197 000005B4 0000                    	dw	0		;
 48198                                  CURR_DIR_END:
 48199 000005B6 0000                    	dw	0		;
 48200                                  NEXTADD:
 48201 000005B8 0000                    	dw	0		;
 48202                                  LASTPOS:
 48203 000005BA 0000                    	dw	0		;
 48204                                  CLUSNUM:
 48205 000005BC 0000                    	dw	0		;
 48206 000005BE 00000000                DIRSEC:	dd	0		;>32mb			AC0000
 48207                                  DIRSTART:
 48208 000005C2 0000                    	dw	0		;
 48209 000005C4 00000000                SECPOS:	dd	0		;>32mb Position of first sector accessed
 48210 000005C8 00000000                VALSEC:	dd	0		;>32mb Number of valid (previously written)
 48211                                                                  ; sectors
 48212                                  BYTSECPOS:
 48213 000005CC 0000                    	dw	0		; Position of first byte within sector
 48214                                  BYTPOS: ;times	4 db 0		; Byte position in file of access
 48215 000005CE 0000<rep 2h>                    times	2 dw 0
 48216                                  BYTCNT1:
 48217 000005D2 0000                    	dw	0		; No. of bytes in first sector
 48218                                  BYTCNT2:
 48219 000005D4 0000                    	dw	0		; No. of bytes in last sector
 48220 000005D6 0000                    SECCNT:	dw	0		; No. of whole sectors
 48221                                  ; DOSDATA:05D8h
 48222                                  ENTFREE:
 48223 000005D8 0000                    	dw	0		;
 48224                                  ENTLAST:
 48225 000005DA 0000                    	dw	0		;
 48226                                  NXTCLUSNUM:
 48227 000005DC 0000                    	dw	0		;
 48228                                  GROWCNT:
 48229 000005DE 00000000                	dd	0		;
 48230 000005E2 00000000                CURBUF:	dd	0		;
 48231 000005E6 00000000                CONSFT:	dd	0		; SFT of console swapped guy.
 48232 000005EA 0000                    SAVEBX:	dw	0		;
 48233 000005EC 0000                    SAVEDS:	dw	0		;
 48234                                  RESTORE_TMP:
 48235 000005EE 0000                    	dw	0		; return address for restore world
 48236 000005F0 0000                    NSS:	dw	0
 48237 000005F2 0000                    NSP:	dw	0
 48238                                  ; DOSDATA:05F4h
 48239                                  EXTOPEN_FLAG:
 48240 000005F4 0000                    	dw	0		;FT. extended open input flag	;AN000;
 48241                                  EXTOPEN_ON:
 48242 000005F6 00                      	db	0		;FT. extended open conditional flag ;AN000;
 48243                                  EXTOPEN_IO_MODE:
 48244 000005F7 0000                    	dw	0		;FT. extended open io mode	;AN000;
 48245                                  SAVE_DI:
 48246 000005F9 0000                    	dw	0		;FT. extended open saved DI	;AN000;
 48247                                  SAVE_ES:
 48248 000005FB 0000                    	dw	0		;FT. extended open saved ES	;AN000;
 48249                                  SAVE_DX:
 48250 000005FD 0000                    	dw	0		;FT. extended open saved DX	;AN000;
 48251                                  SAVE_CX:
 48252 000005FF 0000                    	dw	0		;FT. extended open saved CX	;AN000;
 48253                                  SAVE_BX:
 48254 00000601 0000                    	dw	0		;FT. extended open saved BX	;AN000;
 48255                                  SAVE_SI:
 48256 00000603 0000                    	dw	0		;FT. extended open saved SI	;AN000;
 48257                                  SAVE_DS:
 48258 00000605 0000                    	dw	0		;FT. extended open saved DS	;AN000;
 48259                                  
 48260                                  ; DOSDATA:0607h
 48261                                  
 48262                                  ; HIGH_SECTOR is a hack to allow passing 32-bit sector numbers where
 48263                                  ; we used to just pass 16 bits in a register. Now High_SECTOR holds
 48264                                  ; the high 16, the low 16 are still in the register.
 48265                                  
 48266                                  HIGH_SECTOR:	
 48267 00000607 0000                    	dw	0		;>32mb higher sector #		;AN000;
 48268                                  	; 25/09/2023
 48269                                  OffsetMagicPatch:
 48270                                  	;dw	MagicPatch	;scottq 8/6/92
 48271                                  	; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 48272 00000609 0000                    	dw	0
 48273                                  				;see dos\mpatch.asm
 48274                                  DISK_FULL:
 48275 0000060B 00                      	db	0		;>32mb indicating disk full when 1 ;AN000;
 48276                                  TEMP_VAR:
 48277 0000060C 0000                    	dw	0		; temporary variable for everyone ;AN000;
 48278                                  TEMP_VAR2:
 48279 0000060E 0000                    	dw	0		; temporary variable 2 for everyone ;AN000;
 48280 00000610 00                      DrvErr:	db	0		; used to save drive error	;AN000;
 48281                                  DOS34_FLAG:
 48282 00000611 0000                    	dw	0		; common flag for DOS 3.4	;AN000;
 48283                                  NO_FILTER_PATH:
 48284 00000613 00000000                	dd	0		; pointer to original path	;AN000;
 48285                                  NO_FILTER_DPATH:
 48286 00000617 00000000                	dd	0		; pointer to original path of destination ;AN000;
 48287                                  ; M008
 48288                                  AbsRdWr_SS:
 48289 0000061B 0000                    	dw	0		; INT 25/26 user stack segment
 48290                                  AbsRdWr_SP:
 48291 0000061D 0000                    	dw	0		; INT 25/26 user stack offset
 48292                                  
 48293                                  	; I_am   UU_Callback_flag,BYTE,<0>  ; Unused
 48294                                  ; M008
 48295                                  	; 01/01/2024 
 48296                                  	; PCDOS 7.1 IBMDOS.COM - DOSDATA:061Fh
 48297                                  	;db 	0
 48298                                   
 48299                                  ; make those pushes fast!!!
 48300                                  ;EVEN
 48301                                  
 48302 0000061F 90                      align 2
 48303                                  
 48304                                  StackSize   equ 180h  ; 384	; gross but effective
 48305                                  
 48306                                  ;StackSize  equ 300h  ;	768	; This is a "trial" change IBM hasn't
 48307                                  ;				; made up their minds about
 48308                                   
 48309                                  ; WARNING!!!! DskStack may grow into AUXSTACK due to interrupt service.
 48310                                  ; This is NO problem as long as AUXSTACK comes immediately before DSKSTACK
 48311                                  
 48312                                  RENAMEDMA:	; LABEL   BYTE	; See DOS_RENAME
 48313                                   
 48314 00000620 00<rep 180h>                    times	StackSize db	0	; db 384 dup(0) ;  PCDOS 7.1
 48315                                  AUXSTACK:			; LABEL   BYTE
 48316                                   
 48317 000007A0 00<rep 180h>                    times	StackSize db 	0	; db 384 dup(0) ;  PCDOS 7.1
 48318                                  DSKSTACK:			; LABEL   BYTE
 48319                                  	; 01/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
 48320                                  	; (PCDOS 7.1 IBMDOS.COM - DOSDATA:0920h)
 48321                                  	;db '@#IBM:12.01.2003.build_1.32#@ IBMDOS.COM(USA)',0 
 48322                                  	;times	StackSize-($-DSKSTACK) db 0  ; db 338 dup(0) ; PCDOS 7.1
 48323 00000920 00<rep 180h>            	times	StackSize db 	0	;
 48324                                  IOSTACK:			; LABEL   BYTE
 48325                                  
 48326                                  ; DOSDATA:0AA0h 
 48327                                   
 48328                                  ; patch space for Boca folks.
 48329                                  ; Say What????!!! This does NOT go into the swappable area!
 48330                                  ; NOTE: We include the decl of ibmpatch in ms-dos even though it is not needed.
 48331                                  ;       This allows the REDIRector to work on either IBM or MS-DOS.
 48332                                   
 48333                                  IBMPATCH: ; label byte
 48334                                  PRINTER_FLAG:
 48335 00000AA0 00                      	db	0		; [SYSTEM] status of PRINT utility
 48336                                  VOLCHNG_FLAG:
 48337 00000AA1 00                      	db	0		; [SYSTEM] true if volume label created
 48338                                  VIRTUAL_OPEN:
 48339 00000AA2 00                      	db	0		; [SYSTEM] non-zero if we opened a virtual file
 48340                                   
 48341                                  ; Following 4 variables moved to MSDATA.asm from MSTABLE.asm (P4986)
 48342                                  
 48343                                  FSeek_drive:
 48344 00000AA3 00                      	db	0		;AN000; fastseek drive #
 48345                                  FSeek_firclus:
 48346 00000AA4 0000                    	dw	0		;AN000; fastseek first cluster #
 48347                                  FSeek_logclus:
 48348 00000AA6 0000                    	dw	0		;AN000; fastseek logical cluster #
 48349                                  FSeek_logsave:
 48350 00000AA8 0000                    	dw	0		;AN000; fastseek returned log clus #
 48351                                  
 48352                                  ; DOSDATA:0AAAh
 48353                                  
 48354                                  TEMP_DOSLOC:
 48355 00000AAA FFFF                    	dw	-1		;stores the temporary location of dos
 48356                                  				;at SYSINIT time.
 48357                                  SWAP_END:  ; LABEL   BYTE
 48358                                   
 48359                                  ; THE FOLLOWING BYTE MUST BE HERE, IMMEDIATELY FOLLOWING SWAP_END. IT CANNOT
 48360                                  ; BE USED. If the size of the swap data area is ODD, it will be rounded up
 48361                                  ; to include this byte.
 48362                                   
 48363                                  	; 05/01/2024
 48364                                  	;db	0
 48365                                  
 48366                                  ; DOSDATA:0AADh
 48367                                   
 48368                                  ;hkn;	DB	(512+80+32-(SWAP_END-ibmpatch)) DUP (?)
 48369                                  
 48370                                  ; ---------------------------------------------------------------------------
 48371                                  ; 05/01/2024 - Retro DOS v5.0 
 48372                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:0AA5h
 48373                                  
 48374                                  	; 24/01/2024
 48375                                  LNE_COUNT:
 48376 00000AAC 0000                    	dw	0	; long name entry count (for file)
 48377                                  
 48378 00000AAE 00<rep Eh>              	times 14 db 0
 48379                                  
 48380                                  ENTLAST_PREV:
 48381 00000ABC 0000                    	dw	0	; previous ENTLAST (for long name search !?)
 48382                                  
 48383 00000ABE 00<rep 24h>             	times 36 db 0
 48384                                  
 48385                                  absdrw_extd:
 48386 00000AE2 00                      	db	0
 48387                                  DIRSTART_HW:
 48388 00000AE3 0000                    	dw	0
 48389                                  CLUSNUM_HW:
 48390 00000AE5 0000                    	dw	0
 48391                                  NXTCLUSNUM_HW:
 48392 00000AE7 0000                    	dw	0
 48393                                  LASTPOS_HW:
 48394 00000AE9 0000                    	dw	0
 48395                                  FATBYT_HW:
 48396 00000AEB 0000                    	dw	0
 48397                                  DESTSTART_HW:
 48398 00000AED 0000                    	dw	0
 48399                                  CLUSTNUM_HW:
 48400 00000AEF 0000                    	dw	0
 48401                                  CLUSDATA_HW:	; cluster data (0 = release, -1 = allocate) ; 30/01/2024
 48402 00000AF1 0000                    	dw	0
 48403                                  CCONTENT_HW:
 48404 00000AF3 0000                    	dw	0
 48405                                  ROOTCLUST_HW:
 48406 00000AF5 0000                    	dw	0
 48407                                  word_AF0:
 48408 00000AF7 0000                    	dw	0
 48409                                  CLUSTERS_HW:
 48410 00000AF9 0000                    	dw	0
 48411 00000AFB 0000                    	dw	0
 48412 00000AFD 0000                    	dw	0
 48413                                  CLSKIP_HW:
 48414 00000AFF 0000                    	dw	0
 48415                                  
 48416                                  ;DOSDATA    ENDS
 48417                                  
 48418                                  ;============================================================================
 48419                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
 48420                                  ;============================================================================
 48421                                  ; 27/04/2019 - Retro DOS 4.0
 48422                                  ; 16/07/2018 - Retro DOS 3.0
 48423                                  
 48424                                  ;DOSDATA Segment
 48425                                  
 48426                                  ; DOSDATA:0AADh (MSDOS 6.21, MSDOS.SYS)
 48427                                  
 48428                                  ; DOSDATA:0AFAh (PCDOS 7.1, IBMDOS.COM) ; 05/01/2024
 48429                                  
 48430                                  ;
 48431                                  ; upper case table
 48432                                  ; ---------------------------------------------------------------------------
 48433                                  UCASE_TAB:	; label   byte
 48434 00000B01 8000                    	dw	128
 48435 00000B03 809A45418E418F80        	db	128,154,069,065,142,065,143,128 
 48436 00000B0B 4545454949498E8F        	db	069,069,069,073,073,073,142,143
 48437 00000B13 9092924F994F5555        	db	144,146,146,079,153,079,085,085
 48438 00000B1B 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
 48439 00000B23 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
 48440 00000B2B A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
 48441 00000B33 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 48442 00000B3B B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 48443 00000B43 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 48444 00000B4B C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 48445 00000B53 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 48446 00000B5B D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 48447 00000B63 E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
 48448 00000B6B E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 48449 00000B73 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 48450 00000B7B F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 48451                                  ;
 48452                                  ; file upper case table
 48453                                  ; ---------------------------------------------------------------------------
 48454                                  FILE_UCASE_TAB:	; label  byte
 48455 00000B83 8000                    	dw	128
 48456 00000B85 809A45418E418F80        	db	128,154,069,065,142,065,143,128
 48457 00000B8D 4545454949498E8F        	db	069,069,069,073,073,073,142,143
 48458 00000B95 9092924F994F5555        	db	144,146,146,079,153,079,085,085
 48459 00000B9D 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
 48460 00000BA5 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
 48461 00000BAD A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
 48462 00000BB5 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 48463 00000BBD B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 48464 00000BC5 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 48465 00000BCD C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 48466 00000BD5 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 48467 00000BDD D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 48468 00000BE5 E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
 48469 00000BED E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 48470 00000BF5 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 48471 00000BFD F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 48472                                  ;
 48473                                  ; file char list
 48474                                  ; ---------------------------------------------------------------------------
 48475                                  FILE_CHAR_TAB:	; label  byte
 48476 00000C05 1600                    	dw	22				; length
 48477 00000C07 0100FF                  	db	1,0,255 			; include all
 48478 00000C0A 000020                  	db	0,0,20h 			; exclude 0 - 20h
 48479 00000C0D 020E2E222F5C5B5D3A-     	db	2,14,'."/\[]:|<>+=;,'           ; exclude 14 special
 48479 00000C16 7C3C3E2B3D3B2C     
 48480                                  	;db	24 dup (?)			; reserved
 48481 00000C1D 00<rep 18h>             	times	24 db 0
 48482                                  
 48483                                  ;
 48484                                  ; collate table
 48485                                  ; ---------------------------------------------------------------------------
 48486                                  COLLATE_TAB:	; label   byte
 48487 00000C35 0001                    	dw	256
 48488 00000C37 0001020304050607        	db	0,1,2,3,4,5,6,7
 48489 00000C3F 08090A0B0C0D0E0F        	db	8,9,10,11,12,13,14,15
 48490 00000C47 1011121314151617        	db	16,17,18,19,20,21,22,23
 48491 00000C4F 18191A1B1C1D1E1F        	db	24,25,26,27,28,29,30,31
 48492 00000C57 2021222324252627        	db	" ","!",'"',"#","$","%","&","'"
 48493 00000C5F 28292A2B2C2D2E2F        	db	"(",")","*","+",",","-",".","/"
 48494 00000C67 3031323334353637        	db	"0","1","2","3","4","5","6","7"
 48495 00000C6F 38393A3B3C3D3E3F        	db	"8","9",":",";","<","=",">","?"
 48496 00000C77 4041424344454647        	db	"@","A","B","C","D","E","F","G"
 48497 00000C7F 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
 48498 00000C87 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
 48499 00000C8F 58595A5B5C5D5E5F        	db	"X","Y","Z","[","\","]","^","_"
 48500 00000C97 6041424344454647        	db	"`","A","B","C","D","E","F","G"
 48501 00000C9F 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
 48502 00000CA7 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
 48503 00000CAF 58595A7B7C7D7E7F        	db	"X","Y","Z","{","|","}","~",127
 48504 00000CB7 4355454141414143        	db	"C","U","E","A","A","A","A","C"
 48505 00000CBF 4545454949494141        	db	"E","E","E","I","I","I","A","A"
 48506 00000CC7 4541414F4F4F5555        	db	"E","A","A","O","O","O","U","U"
 48507 00000CCF 594F552424242424        	db	"Y","O","U","$","$","$","$","$"
 48508 00000CD7 41494F554E4EA6A7        	db	"A","I","O","U","N","N",166,167
 48509 00000CDF 3FA9AAABAC212222        	db	"?",169,170,171,172,"!",'"','"'
 48510 00000CE7 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 48511 00000CEF B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 48512 00000CF7 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 48513 00000CFF C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 48514 00000D07 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 48515 00000D0F D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 48516 00000D17 E053                    	db	224,"S"
 48517 00000D19 E2E3E4E5E6E7            	db	226,227,228,229,230,231
 48518 00000D1F E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 48519 00000D27 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 48520 00000D2F F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 48521                                  
 48522                                  ; ------------------------------------------------<MSKK01>----------------------
 48523                                  
 48524                                  ; DOSDATA:0CE3h
 48525                                  
 48526                                  ; 29/04/2019
 48527                                  
 48528                                  ; dbcs is not supported in DOS 3.3
 48529                                  ;		   DBCS_TAB	    CC_DBCS <>
 48530                                  ;
 48531                                  ; DBCS for DOS 4.00			   2/12/KK
 48532                                  
 48533                                  DBCS_TAB:	; label byte		;AN000;  2/12/KK
 48534                                  ; ------------------------------------------------<MSKK01>----------------------
 48535                                  ;ifdef	DBCS
 48536                                  ; ifdef	  JAPAN
 48537                                  ;		dw	6		; <MSKK01>
 48538                                  ;		db	081h,09fh	; <MSKK01>
 48539                                  ;		db	0e0h,0fch	; <MSKK01>
 48540                                  ;		db	0,0		; <MSKK01>
 48541                                  ;
 48542                                  ;		db	0,0,0,0,0,0,0,0,0,0	; <MSKK01>
 48543                                  ; endif
 48544                                  ; ifdef	  TAIWAN
 48545                                  ;		dw	4		; <TAIWAN>
 48546                                  ;		db	081h,0FEh	; <TAIWAN>
 48547                                  ;		db	0,0		; <TAIWAN>
 48548                                  ;
 48549                                  ;		db	0,0,0,0,0,0,0,0,0,0,0,0
 48550                                  ; endif
 48551                                  ; ifdef   KOREA                         ; Keyl
 48552                                  ;               dw      4               ; <KOREA>
 48553                                  ;               db      0A1h,0FEh       ; <KOREA>
 48554                                  ;               db      0,0             ; <KOREA>
 48555                                  ;
 48556                                  ;		db	0,0,0,0,0,0,0,0,0,0,0,0
 48557                                  ;  endif
 48558                                  ;else
 48559 00000D37 0000                    		dw	0		;AN000;  2/12/KK   max number
 48560                                  		;db	16 dup(0)	;AN000;  2/12/KK
 48561 00000D39 00<rep 10h>             		times	16 db 0
 48562                                  
 48563                                  ;		dw	6		;  2/12/KK
 48564                                  ;		db	081h,09Fh	;  2/12/KK
 48565                                  ;		db	0E0h,0FCh	;  2/12/KK
 48566                                  ;		db	0,0		;  2/12/KK
 48567                                  ;
 48568                                  ;endif
 48569                                  ; ------------------------------------------------<MSKK01>----------------------
 48570                                  
 48571                                  ; DOSDATA:0CF5h
 48572                                  
 48573                                  ; ---------------------------------------------------------------------------
 48574                                  ;
 48575                                  ;CASE MAPPER ROUTINE FOR 80H-FFH character range, DOS 3.3
 48576                                  ;     ENTRY: AL = Character to map
 48577                                  ;     EXIT:  AL = The converted character
 48578                                  ; Alters no registers except AL and flags.
 48579                                  ; The routine should do nothing to chars below 80H.
 48580                                  ; ---------------------------------------------------------------------------
 48581                                  ; Example:
 48582                                  
 48583                                  MAP_CASE:
 48584                                  ;Procedure MAP_CASE,FAR
 48585                                  
 48586 00000D49 3C80                    	CMP	AL,80h
 48587 00000D4B 7301                    	JAE	short Map1	;Map no chars below 80H ever
 48588 00000D4D CB                      	RETF
 48589                                  Map1:
 48590 00000D4E 2C80                    	SUB	AL,80h		;Turn into index value
 48591 00000D50 1E                      	PUSH	DS
 48592 00000D51 53                      	PUSH	BX
 48593 00000D52 BB[030B]                	MOV	BX,UCASE_TAB+2
 48594                                  FINISH:
 48595 00000D55 0E                      	PUSH	CS		;Move to DS
 48596 00000D56 1F                      	POP	DS
 48597 00000D57 D7                      	XLAT			;Get upper case character
 48598 00000D58 5B                      	POP	BX
 48599 00000D59 1F                      	POP	DS
 48600                                  L_RET:	
 48601 00000D5A CB                      	RETF
 48602                                  
 48603                                  ;EndProc MAP_CASE
 48604                                  
 48605                                  ; ---------------------------------------------------------------------------
 48606                                  
 48607                                  ; The variables for ECS version are moved here for the same data alignments
 48608                                  ; as IBM-DOS and MS-DOS.
 48609                                  
 48610                                  InterChar:
 48611 00000D5B 00                      	db	0	; Interim character flag ( 1= interim)  ;AN000;
 48612                                  ;------- NOTE: NEXT TWO BYTES SOMETIMES USED AS A WORD !! -------------------
 48613                                  DUMMY:	; LABEL   WORD
 48614                                  InterCon:  
 48615 00000D5C 00                      	db	0	; Console in Interim mode ( 1= interim) ;AN000;
 48616                                  SaveCurFlg:
 48617 00000D5D 00                      	db	0	; Print, do not advance cursor flag     ;AN000;
 48618                                  
 48619                                  ; ---------------------------------------------------------------------------
 48620                                  
 48621                                  ; 17/01/2024 - Retro DOS v5.0
 48622                                  ;TEMPSEG:  dw	0	;hkn; used to store ds.
 48623                                  ;redir_patch:
 48624                                  ;	  db	0
 48625                                  
 48626                                  ; DOSDATA:0D0Dh
 48627                                  
 48628                                  Mark1:	; label byte
 48629                                  
 48630                                  ;IF2
 48631                                  ;	IF ((OFFSET MARK1) GT (OFFSET MSVERSION) )
 48632                                  ;		%OUT !DATA CORRUPTION!MARK1 OFFSET TOO BIG. RE-ORGANIZE DATA.
 48633                                  ;	ENDIF
 48634                                  ;ENDIF
 48635                                  
 48636 00000D5E 00<rep 5h>              	  times 5 db 0
 48637                                  
 48638                                  ;############################################################################
 48639                                  ;
 48640                                  ; ** HACK FOR DOS 4.0 REDIR **
 48641                                  ; 
 48642                                  ; The redir requires the following:
 48643                                  ;
 48644                                  ;	MSVERS	offset D12H
 48645                                  ;	YRTAB	offset D14H
 48646                                  ; 	MONTAB	offset D1CH
 48647                                  ;
 48648                                  ; WARNING! WARNING!
 48649                                  ; 
 48650                                  ; MARK1 SHOULD NOT BE >= 0D12H. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
 48651                                  ; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
 48652                                  ;
 48653                                  ; CURRENTLY MARK1 = 0D0DH
 48654                                  ;
 48655                                  ;############################################################################
 48656                                  
 48657                                  	;ORG	0D12h
 48658                                  
 48659                                  ; DOSDATA:0D12h (MSDOS 6.21, MSDOS.SYS)
 48660                                  
 48661                                  	;db	6
 48662                                  	;db	20
 48663                                  
 48664                                  	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
 48665                                  MSVERSION:				; MS-DOS version in hex for $GET_VERSION
 48666 00000D63 07                      MSMAJORV: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
 48667 00000D64 0A                      MSMINORV: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
 48668                                  
 48669                                  ; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
 48670                                  ;
 48671                                  ;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>
 48672                                  ;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 
 48673                                  
 48674                                  ; Days in year
 48675                                  
 48676                                  YRTAB:   
 48677 00000D65 C8A6                    	DB	200,166			; Leap year
 48678 00000D67 C8A5                    	DB	200,165
 48679 00000D69 C8A5                    	DB	200,165
 48680 00000D6B C8A5                    	DB	200,165
 48681                                  
 48682                                  ; Days of each month
 48683                                  
 48684                                  MONTAB:        
 48685 00000D6D 1F                      	DB      31                      ; January
 48686                                  february:
 48687 00000D6E 1C                      	DB	28 			; February--reset each 
 48688                                  					; time year changes
 48689 00000D6F 1F                              DB      31                      ; March
 48690 00000D70 1E                              DB      30                      ; April
 48691 00000D71 1F                              DB      31                      ; May
 48692 00000D72 1E                              DB      30                      ; June
 48693 00000D73 1F                              DB      31                      ; July
 48694 00000D74 1F                              DB      31                      ; August
 48695 00000D75 1E                              DB      30                      ; September
 48696 00000D76 1F                              DB      31                      ; October
 48697 00000D77 1E                              DB      30                      ; November
 48698 00000D78 1F                              DB      31                      ; December
 48699                                  
 48700                                  ;----------------THE FOLL. BLOCK MOVED FROM TABLE SEG IN MS_TABLE.ASM-------
 48701                                  
 48702                                  ; SYS init extended table,   DOS 3.3   F.C. 5/29/86
 48703                                  
 48704                                  SysInitTable:
 48705                                  	;dw	SYSINITVAR
 48706 00000D79 [2600]                  	dw	SYSINITVARS	; pointer to sysinit var
 48707 00000D7B 0000                            dw      0		; segment
 48708 00000D7D [5113]                          dw	COUNTRY_CDPG	; pointer to country tabl
 48709 00000D7F 0000                            dw      0		; segment of pointer
 48710                                  
 48711                                  	;;;
 48712                                  	; 17/01/2024 - Retro DOS v5.0
 48713                                  	; PCDOS 7.1 IBMDOS.COM - DOSDATA:0D60h
 48714                                  	;
 48715 00000D81 00<rep 3h>              	times	3 db 0
 48716                                  TEMPSEG:
 48717 00000D84 0000                    	dw	0
 48718                                  redir_patch:
 48719 00000D86 00                      	db	0
 48720                                  
 48721                                  ; 17/01/2024
 48722                                  %if 1
 48723                                  
 48724                                  ; M021-
 48725                                  ;
 48726                                  ; DosHasHMA - This flag is set by seg_reinit when the DOS actually
 48727                                  ; 	takes control of the HMA. When running, this word is a reliable
 48728                                  ;	indicator that the DOS is actually using HMA. You can't just use
 48729                                  ;	CS, because ROMDOS uses HMA with CS < F000.
 48730                                  
 48731                                  DosHasHMA:
 48732 00000D87 00                      	db	0
 48733                                  FixExePatch:
 48734 00000D88 0000                    	dw	0		; M012
 48735                                  
 48736                                  %endif
 48737                                  
 48738                                  UnknownPatch:
 48739 00000D8A 0000                    	dw	0
 48740                                  	;;;
 48741                                  
 48742                                  ; 17/01/2024
 48743                                  %if 0
 48744                                  
 48745                                  ; DOS 3.3 F.C. 6/12/86
 48746                                  ; FASTOPEN communications area DOS 3.3   F.C. 5/29/86
 48747                                  
 48748                                  FastTable:				; a better name
 48749                                  FastOpenTable:
 48750                                  	dw      2                       ; number of entries
 48751                                  	dw      FastRet			; pointer to ret instr.
 48752                                  	dw      0                       ; and will be modified by
 48753                                  	dw      FastRet			; FASTxxx when loaded in
 48754                                  	dw      0
 48755                                  
 48756                                  ; DOS 3.3 F.C. 6/12/86
 48757                                  
 48758                                  FastFlg:				; flags
 48759                                  FastOpenFlg:
 48760                                  	db	0			; don't change the foll: order
 48761                                  
 48762                                  %endif
 48763                                  
 48764                                  ; FastOpen_Ext_Info is used as a temporary storage for saving dirpos,dirsec
 48765                                  ; and clusnum which are filled by DOS 3.nc when calling FastOpen Insert
 48766                                  ; or filled by FastOPen when calling FastOpen Lookup
 48767                                  
 48768                                  FastOpen_Ext_Info: ; label  byte	;dirpos
 48769                                  	;db	SIZE FASTOPEN_EXTENDED_INFO dup(0)
 48770                                  	;times	11 db 0
 48771 00000D8C 00<rep Bh>              	times	FEI.size db 0
 48772                                  
 48773                                  ; Dir_Info_Buff is a dir entry buffer which is filled by FastOPen
 48774                                  ; when calling FastOpen Lookup
 48775                                  
 48776                                  Dir_Info_Buff:	; label  byte
 48777                                  	;db   	SIZE dir_entry dup (0)
 48778                                  	;times	32 db 0
 48779 00000D97 00<rep 20h>             	times	dir_entry.size db 0
 48780                                  
 48781                                  Next_Element_Start:
 48782 00000DB7 0000                    	dw	0			; save next element start offset
 48783                                  Del_ExtCluster:
 48784 00000DB9 0000                    	dw	0			; for dos_delete
 48785                                  
 48786                                  ; The following is a stack and its pointer for interrupt 2F which is used
 48787                                  ; by NLSFUNC. There is no significant use of this stack, we are just trying
 48788                                  ; not to destroy the INT 21 stack saved for the user.
 48789                                  
 48790                                  USER_SP_2F:	; LABEL  WORD
 48791 00000DBB [BD0D]                  	dw    	FAKE_STACK_2F
 48792                                  
 48793                                  Packet_Temp:	; label  word		; temporary packet used by readtime
 48794                                  DOS_TEMP:	; label  word		; temporary word
 48795                                  FAKE_STACK_2F:  
 48796                                  	; dw  14 dup (0)		; 12 register temporary storage
 48797 00000DBD 0000<rep Eh>            	times 14 dw 0
 48798                                  
 48799                                  Hash_Temp: 	;label  word		; temporary word
 48800                                  	;dw   4 dup (0)			; temporary hash table during config.sys
 48801 00000DD9 0000<rep 4h>            	times 4 dw 0
 48802                                              	
 48803                                  SCAN_FLAG:	
 48804 00000DE1 00                      	db     0			; flag to indicate key ALT_Q
 48805                                  DATE_FLAG:
 48806 00000DE2 0000                    	dw     0                	; flag to update the date
 48807                                  
 48808                                  FETCHI_TAG:	; label  word		; OBSOLETE - no longer used
 48809 00000DE4 0000                    	dw     0			; formerly part of IBM's piracy protection
 48810                                  
 48811                                  MSG_EXTERROR:	; label  DWORD 		; for system message addr
 48812 00000DE6 00000000                	dd     0               		; for extended error
 48813 00000DEA 00000000                	dd     0			; for parser
 48814 00000DEE 00000000                	dd     0			; for critical errror
 48815 00000DF2 00000000                	dd     0			; for IFS
 48816 00000DF6 00000000                	dd     0			; for code reduction
 48817                                  
 48818                                  SEQ_SECTOR:	; label  DWORD 		; last sector read
 48819 00000DFA FFFFFFFF                	dd     -1
 48820                                  SC_SECTOR_SIZE:
 48821 00000DFE 0000                    	dw	0			; sector size for SC
 48822                                  SC_DRIVE:
 48823 00000E00 00                      	db	0			; drive # for secondary cache
 48824                                  
 48825                                  ; 17/01/2024
 48826                                  ;CurSC_DRIVE:
 48827                                  ;	db	-1			; current SC drive
 48828                                                     
 48829                                  CurSC_SECTOR:
 48830 00000E01 00000000                	dd	0			; current SC starting sector         
 48831                                  SC_STATUS:
 48832 00000E05 0000                    	dw	0			; SC status word                     
 48833                                  SC_FLAG:
 48834 00000E07 00                      	db	0			; SC flag                            
 48835                                  AbsDskErr:
 48836 00000E08 0000                    	dw	0			; Storage for Abs dsk read/write err
 48837                                                                                            
 48838                                  NO_NAME_ID:	; label byte
 48839 00000E0A 4E4F204E414D452020-     	db	'NO NAME    '		; null media id
 48839 00000E13 2020               
 48840                                  
 48841                                  ;hkn; moved from TABLE segment in kstrin.asm
 48842                                  
 48843                                  KISTR001S:	; label	byte		; 2/17/KK
 48844 00000E15 00                      LOOKSIZ: DB	0			; 0 if byte, NZ if word	2/17/KK
 48845                                  KISTR001E:	; label	byte		; 2/17/KK
 48846                                  
 48847                                  ; the nul device driver used to be part of the code. However, since the 
 48848                                  ; header is in the data, and the entry points are only given as an offset,
 48849                                  ; the strategy and interrupt entry points must also be in the data now.
 48850                                  
 48851                                  ; DOSDATA:0DC6h
 48852                                  
 48853                                  SNULDEV:
 48854                                  ;procedure snuldev,far
 48855                                  	;or	word [es:bx+3],100h
 48856                                  	; 17/12/2022
 48857                                  	;or	byte [es:bx+4],01h
 48858                                  	; 05/01/2024 - Retro DOS v4.2 (*)
 48859                                  	; (Original MSDOS and RetroDOS DATA address compatibility) (*)
 48860                                  	;;or	byte [es:bx+SRHEAD.REQSTAT+1],(STDON>>8)
 48861                                  	;or	word [es:bx+SRHEAD.REQSTAT],STDON ; set done bit
 48862                                  	; 05/01/2024 - Retro DOS v5.0
 48863 00000E16 26804F0401              	or	byte [es:bx+SRHEAD.REQSTAT+1],(STDON>>8)
 48864                                  INULDEV:
 48865 00000E1B CB                      	retf				; must not be a return!
 48866                                  ;endproc snuldev
 48867                                  
 48868                                  ;M044
 48869                                  ; Second part of save area for saving last para of Windows memory
 48870                                  
 48871                                  ; 17/01/2024
 48872                                  ;WinoldPatch2:
 48873                                  ;	;db	8 dup (?)	; M044
 48874                                  ;	times	8 db 0	
 48875                                  
 48876                                  UmbSave2:
 48877                                  	;db	5 dup (?)	; M062
 48878 00000E1C 00<rep 5h>              	times	5 db 0
 48879                                  UmbSaveFlag:
 48880 00000E21 00                      	db	0		; M062
 48881                                  
 48882                                  ; DOSDATA:0DDBh
 48883                                  
 48884                                  Mark2:	; label byte
 48885                                  
 48886                                  ;IF2
 48887                                  ;	IF ((OFFSET MARK2) GT (OFFSET ERR_TABLE_21) )
 48888                                  ;		%OUT !DATA CORRUPTION!MARK2 OFFSET TOO BIG. RE-ORGANIZE DATA.
 48889                                  ;	ENDIF
 48890                                  ;ENDIF
 48891                                  
 48892                                  ;############################################################################
 48893                                  ;
 48894                                  ; ** HACK FOR DOS 4.0 REDIR **
 48895                                  ; 
 48896                                  ; The redir requires the following:
 48897                                  ;
 48898                                  ;	ERR_TABLE_21	offset DDBH
 48899                                  ;	ERR_TABLE_24	offset E5BH
 48900                                  ; 	ErrMap24	offset EABH
 48901                                  ;
 48902                                  ; WARNING! WARNING!
 48903                                  ;
 48904                                  ; MARK2 SHOULD NOT BE >= 0DDBH. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
 48905                                  ; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
 48906                                  ;
 48907                                  ; CURRENTLY MARK2 = 0DD0H
 48908                                  ;
 48909                                  ;############################################################################
 48910                                  
 48911                                  	;ORG	0DDBh
 48912                                  
 48913                                  ; DOSDATA:0DDBh (MSDOS 6.21, MSDOS.SYS)
 48914                                  
 48915                                  ; ---------------------------------------------------------------------------
 48916                                  ;
 48917                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 21H
 48918                                  ; errors. Each entry is 4 bytes long:
 48919                                  ;
 48920                                  ;       Err#,Class,Action,Locus
 48921                                  ;
 48922                                  ; A value of 0FFh indicates a call specific value (ie. should already
 48923                                  ; be set). AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
 48924                                  ; THE END, IT IS ASSUMES THAT CLASS, ACTION, LOCUS IS ALREADY SET.
 48925                                  ;
 48926                                  ; ---------------------------------------------------------------------------
 48927                                  
 48928                                  ;ErrTab  Macro   err,class,action,locus
 48929                                  ;ifidn <locus>,<0FFh>
 48930                                  ;    DB  error_&err,errCLASS_&class,errACT_&action,0FFh
 48931                                  ;ELSE
 48932                                  ;    DB  error_&err,errCLASS_&class,errACT_&action,errLOC_&locus
 48933                                  ;ENDIF
 48934                                  ;ENDM
 48935                                  
 48936                                  ERR_TABLE_21: ; LABEL   BYTE
 48937 00000E22 010704FF                    DB  error_invalid_function,       errCLASS_Apperr,    errACT_Abort,    0FFh
 48938 00000E26 02080302                    DB  error_file_not_found,         errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 48939 00000E2A 03080302                    DB  error_path_not_found,         errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 48940 00000E2E 04010401                    DB  error_too_many_open_files,    errCLASS_OutRes,    errACT_Abort,    errLOC_Unk
 48941 00000E32 050303FF                    DB  error_access_denied,          errCLASS_Auth,      errACT_User,     0FFh
 48942 00000E36 06070401                    DB  error_invalid_handle,         errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 48943 00000E3A 07070505                    DB  error_arena_trashed,          errCLASS_Apperr,    errACT_Panic,    errLOC_Mem
 48944 00000E3E 08010405                    DB  error_not_enough_memory,      errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 48945 00000E42 09070405                    DB  error_invalid_block,          errCLASS_Apperr,    errACT_Abort,    errLOC_Mem
 48946 00000E46 0A070405                    DB  error_bad_environment,        errCLASS_Apperr,    errACT_Abort,    errLOC_Mem
 48947 00000E4A 0B090301                    DB  error_bad_format,             errCLASS_BadFmt,    errACT_User,     errLOC_Unk
 48948 00000E4E 0C070401                    DB  error_invalid_access,         errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 48949 00000E52 0D090401                    DB  error_invalid_data,           errCLASS_BadFmt,    errACT_Abort,    errLOC_Unk
 48950 00000E56 0F080302                    DB  error_invalid_drive,          errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 48951 00000E5A 10030302                    DB  error_current_directory,      errCLASS_Auth,      errACT_User,     errLOC_Disk
 48952 00000E5E 110D0302                    DB  error_not_same_device,        errCLASS_Unk,       errACT_User,     errLOC_Disk
 48953 00000E62 12080302                    DB  error_no_more_files,          errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 48954 00000E66 500C0302                    DB  error_file_exists,            errCLASS_Already,   errACT_User,     errLOC_Disk
 48955 00000E6A 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 48956 00000E6E 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 48957 00000E72 540104FF                    DB  error_out_of_structures,      errCLASS_OutRes,    errACT_Abort,    0FFh
 48958 00000E76 56030301                    DB  error_invalid_password,       errCLASS_Auth,      errACT_User,     errLOC_Unk
 48959 00000E7A 52010402                    DB  error_cannot_make,            errCLASS_OutRes,    errACT_Abort,    errLOC_Disk
 48960 00000E7E 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,     errLOC_Net
 48961 00000E82 550C0303                    DB  error_already_assigned,       errCLASS_Already,   errACT_User,     errLOC_Net
 48962 00000E86 57090301                    DB  error_invalid_parameter,      errCLASS_BadFmt,    errACT_User,     errLOC_Unk
 48963 00000E8A 530D0401                    DB  error_FAIL_I24,               errCLASS_Unk,       errACT_Abort,    errLOC_Unk
 48964 00000E8E 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 48965                                      ; MSDOS 6.0
 48966 00000E92 26010401                    DB  error_handle_EOF,             errCLASS_OutRes,    errACT_Abort,    errLOC_Unk ;AN000;
 48967 00000E96 27010401                    DB  error_handle_Disk_Full,       errCLASS_OutRes,    errACT_Abort,    errLOC_Unk ;AN000;
 48968 00000E9A 5A0D0402                    DB  error_sys_comp_not_loaded,    errCLASS_Unk,       errACT_Abort,    errLOC_Disk ;AN001;
 48969 00000E9E FFFFFFFF                    DB  0FFh,                         0FFH,       	  0FFH,       	   0FFh
 48970                                  
 48971                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D2Ah
 48972                                  ;ERR_TABLE_21:	db 1,7,4,0FFh
 48973                                  ;		db 2,8,3,2
 48974                                  ;		db 3,8,3,2
 48975                                  ;		db 4,1,4,1
 48976                                  ;		db 5,3,3,0FFh
 48977                                  ;		db 6,7,4,1
 48978                                  ;		db 7,7,5,5
 48979                                  ;		db 8,1,4,5
 48980                                  ;		db 9,7,4,5
 48981                                  ;		db 0Ah,7,4,5
 48982                                  ;		db 0Bh,9,3,1
 48983                                  ;		db 0Ch,7,4,1
 48984                                  ;		db 0Dh,9,4,1
 48985                                  ;		db 0Fh,8,3,2
 48986                                  ;		db 10h,3,3,2
 48987                                  ;		db 11h,0Dh,3,2
 48988                                  ;		db 12h,8,3,2
 48989                                  ;		db 50h,0Ch,3,2
 48990                                  ;		db 20h,0Ah,2,2
 48991                                  ;		db 21h,0Ah,2,2
 48992                                  ;		db 54h,1,4,0FFh
 48993                                  ;		db 56h,3,3,1
 48994                                  ;		db 52h,1,4,2
 48995                                  ;		db 32h,9,3,3
 48996                                  ;		db 55h,0Ch,3,3
 48997                                  ;		db 57h,9,3,1
 48998                                  ;		db 53h,0Dh,4,1
 48999                                  ;		db 24h,1,4,5
 49000                                  ; MSDOS 6.0 (MSDOS 6.21)
 49001                                  ;		db 26h,1,4,1
 49002                                  ;		db 27h,1,4,1
 49003                                  ;		db 5Ah,0Dh,4,2
 49004                                  ; MSDOS 6.0 & MSDOS 3.3
 49005                                  ;		db 0FFh,0FFh,0FFh,0FFh
 49006                                  
 49007                                  ; DOSDATA:0E5Bh (MSDOS 6.21, MSDOS.SYS)
 49008                                  
 49009                                  ; ---------------------------------------------------------------------------
 49010                                  ;
 49011                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 24H
 49012                                  ; errors. Each entry is 4 bytes long:
 49013                                  ;
 49014                                  ;       Err#,Class,Action,Locus
 49015                                  ;
 49016                                  ; A Locus value of 0FFh indicates a call specific value (ie. should already
 49017                                  ; be set). AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
 49018                                  ; THE END.
 49019                                  ;
 49020                                  ; ---------------------------------------------------------------------------
 49021                                  
 49022                                  ERR_TABLE_24: ; LABEL   BYTE
 49023 00000EA2 130B0702                    DB  error_write_protect,          errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 49024 00000EA6 14040501                    DB  error_bad_unit,               errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 49025 00000EAA 150507FF                    DB  error_not_ready,              errCLASS_HrdFail,   errACT_IntRet,   0FFh
 49026 00000EAE 16040501                    DB  error_bad_command,            errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 49027 00000EB2 170B0402                    DB  error_CRC,                    errCLASS_Media,     errACT_Abort,    errLOC_Disk
 49028 00000EB6 18040501                    DB  error_bad_length,             errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 49029 00000EBA 19050102                    DB  error_seek,                   errCLASS_HrdFail,   errACT_Retry,    errLOC_Disk
 49030 00000EBE 1A0B0702                    DB  error_not_DOS_disk,           errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 49031 00000EC2 1B0B0402                    DB  error_sector_not_found,       errCLASS_Media,     errACT_Abort,    errLOC_Disk
 49032 00000EC6 1C020704                    DB  error_out_of_paper,           errCLASS_TempSit,   errACT_IntRet,   errLOC_SerDev
 49033 00000ECA 1D0504FF                    DB  error_write_fault,            errCLASS_HrdFail,   errACT_Abort,    0FFh
 49034 00000ECE 1E0504FF                    DB  error_read_fault,             errCLASS_HrdFail,   errACT_Abort,    0FFh
 49035 00000ED2 1F0D04FF                    DB  error_gen_failure,            errCLASS_Unk,       errACT_Abort,    0FFh
 49036 00000ED6 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 49037 00000EDA 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 49038 00000EDE 220B0702                    DB  error_wrong_disk,             errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 49039 00000EE2 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,     errLOC_Net
 49040 00000EE6 23070401                    DB  error_FCB_unavailable,        errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 49041 00000EEA 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 49042 00000EEE FF0D05FF                    DB	0FFh,                         errCLASS_Unk,       errACT_Panic,    0FFh
 49043                                  
 49044                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D9Eh
 49045                                  ;ERR_TABLE_24:	db 13h,0Bh,7,2
 49046                                  ;		db 14h,4,5,1
 49047                                  ;		db 15h,5,7,0FFh
 49048                                  ;		db 16h,4,5,1
 49049                                  ;		db 17h,0Bh,4,2
 49050                                  ;		db 18h,4,5,1
 49051                                  ;		db 19h,5,1,2
 49052                                  ;		db 1Ah,0Bh,7,2
 49053                                  ;		db 1Bh,0Bh,4,2
 49054                                  ;		db 1Ch,2,7,4
 49055                                  ;		db 1Dh,5,4,0FFh
 49056                                  ;		db 1Eh,5,4,0FFh
 49057                                  ;		db 1Fh,0Dh,4,0FFh
 49058                                  ;		db 20h,0Ah,2,2
 49059                                  ;		db 21h,0Ah,2,2
 49060                                  ;		db 22h,0Bh,7,2
 49061                                  ;		db 32h,9,3,3
 49062                                  ;		db 23h,7,4,1
 49063                                  ;		db 24h,1,4,5
 49064                                  ;		db 0FFh,0Dh,5,0FFh
 49065                                  
 49066                                  ; DOSDATA:0EABh (MSDOS 6.21, MSDOS.SYS)
 49067                                  
 49068                                  ; ---------------------------------------------------------------------------
 49069                                  ;
 49070                                  ; We need to map old int 24 errors and device driver errors into the new set
 49071                                  ; of errors. The following table is indexed by the new errors
 49072                                  ;
 49073                                  ; ---------------------------------------------------------------------------
 49074                                  
 49075                                  ;Public  ErrMap24
 49076                                  ErrMap24: ; Label   BYTE
 49077 00000EF2 13                          DB  error_write_protect	; 0
 49078 00000EF3 14                          DB  error_bad_unit		; 1
 49079 00000EF4 15                          DB  error_not_ready		; 2
 49080 00000EF5 16                          DB  error_bad_command	; 3
 49081 00000EF6 17                          DB  error_CRC		; 4
 49082 00000EF7 18                          DB  error_bad_length	; 5
 49083 00000EF8 19                          DB  error_seek		; 6
 49084 00000EF9 1A                          DB  error_not_DOS_disk	; 7
 49085 00000EFA 1B                          DB  error_sector_not_found	; 8
 49086 00000EFB 1C                          DB  error_out_of_paper	; 9
 49087 00000EFC 1D                          DB  error_write_fault	; A
 49088 00000EFD 1E                          DB  error_read_fault	; B
 49089 00000EFE 1F                          DB  error_gen_failure	; C
 49090 00000EFF 1F                          DB  error_gen_failure	; D  RESERVED
 49091 00000F00 1F                          DB  error_gen_failure	; E  RESERVED
 49092 00000F01 22                          DB  error_wrong_disk	; F
 49093                                  
 49094                                  ;ErrMap24: db 13h, 14h, 15h, 16h, 17h, 18h, 19h, 1Ah
 49095                                  ;	   db 1Bh, 1Ch, 1Dh, 1Eh, 1Fh, 1Fh, 1Fh, 22h
 49096                                  	
 49097                                  ErrMap24End: ; LABEL   BYTE
 49098                                  
 49099                                  ; DOSDATA:0E5Bh (MSDOS 6.21, MSDOS.SYS)
 49100                                  
 49101                                  ; ---------------------------------------------------------------------------
 49102                                  
 49103                                  ; 27/04/2019 - Retro DOS v4.0
 49104                                  
 49105                                  ; 17/01/2024
 49106                                  ;FIRST_BUFF_ADDR:
 49107                                  ;	dw	0			; first buffer address
 49108                                  
 49109                                  SPECIAL_VERSION:
 49110 00000F02 0000                    	dw	0			;AN006; used by INT 2F 47H
 49111                                  FAKE_COUNT:
 49112 00000F04 00<rep FFh>             	times 255 db 0			;AN008; fake version count
 49113                                  OLD_FIRSTCLUS:
 49114 00001003 0000                    	dw	0			;AN011; save old first cluster for fastopen
 49115                                  
 49116                                  ; ---------------------------------------------------------------------------
 49117                                  
 49118                                  ;smr; moved from TABLE segment in exec.asm
 49119                                  
 49120 00001005 0000                    exec_init_SP: dw 0
 49121 00001007 0000                    exec_init_SS: dw 0
 49122 00001009 0000                    exec_init_IP: dw 0
 49123 0000100B 0000                    exec_init_CS: dw 0
 49124                                  
 49125                                  exec_signature:
 49126 0000100D 0000                    	dw	0	; must contain 4D5A (yay zibo!)
 49127                                  exec_len_mod_512:
 49128 0000100F 0000                    	dw	0	; low 9 bits of length
 49129                                  exec_pages:
 49130 00001011 0000                    	dw	0	; number of 512b pages in file
 49131                                  exec_rle_count:
 49132 00001013 0000                    	dw	0	; count of reloc entries
 49133                                  exec_par_dir:
 49134 00001015 0000                    	dw	0	; number of paragraphs before image
 49135                                  exec_min_BSS:
 49136 00001017 0000                    	dw	0	; minimum number of para of BSS
 49137                                  exec_max_BSS:
 49138 00001019 0000                    	dw	0	; max number of para of BSS
 49139                                  exec_SS:
 49140 0000101B 0000                    	dw	0	; stack of image
 49141                                  exec_SP:
 49142 0000101D 0000                    	dw	0	; SP of image
 49143                                  exec_chksum:
 49144 0000101F 0000                    	dw	0	; checksum of file (ignored)
 49145                                  exec_IP:
 49146 00001021 0000                    	dw	0	; IP of entry
 49147                                  exec_CS:
 49148 00001023 0000                    	dw	0	; CS of entry
 49149                                  exec_rle_table:
 49150 00001025 0000                    	dw	0	; byte offset of reloc table
 49151                                  
 49152                                  exec_header_len	equ $-exec_signature			;PBUGBUG
 49153                                  
 49154                                  ;smr; eom
 49155                                  
 49156                                  ; ---------------------------------------------------------------------------
 49157                                  
 49158                                  ;SR;
 49159                                  ; WIN386 instance table for DOS
 49160                                  
 49161                                  Win386_Info:
 49162                                  	;db	3, 0
 49163                                  	; 17/01/2024 - PCDOS 7.1 IBMDOS.COM
 49164 00001027 0400                    	db	4, 0	; WIN386_SIS version
 49165 00001029 00000000                	dd	0	; .Next_Dev_Ptr
 49166                                  Win386_Inf_Virt_Dev_Ptr:
 49167 0000102D 00000000                	dd	0	; .Virt_Dev_File_Ptr
 49168 00001031 00000000                	dd	0	; .Reference_Data
 49169                                  Instance_Data_Ptr:
 49170 00001035 [3D10]0000              	dw	Instance_Table, 0
 49171                                  	; 17/01/2024 - PCDOS 7.1 IBMDOS.COM
 49172                                  	;;
 49173 00001039 [8310]0000              	dw	Unknown_Table, 0  ; (what is this and what for ?)
 49174                                  	;;
 49175                                  
 49176                                  Instance_Table:
 49177 0000103D [2200]00000200          	dw	CONTPOS, 0, 2
 49178 00001043 [3200]00000400          	dw	BCON, 0, 4
 49179 00001049 [F901]00000601          	dw	CARPOS, 0, 106h
 49180 0000104F [0003]00000100          	dw	CHARCO, 0, 1
 49181 00001055 [0510]00002200          	dw	exec_init_SP, 0, 34	; M074
 49182 0000105B [8900]00000100          	dw	UMBFLAG,0,1		; M019
 49183 00001061 [8C00]00000200          	dw	UMB_HEAD,0,2		; M019
 49184                                  	;;;
 49185                                  	; 17/01/2024 - PCDOS 7.1 IBMDOS.COM
 49186 00001067 [8600]C9000100          	dw	DOS_FLAG, 0C9h, 1
 49187 0000106D [DF13]C9000100          	dw	INDOS_FLAG, 0C9h, 1 ; (what for a 2nd INDOS flag, windows?)	
 49188 00001073 [E013]C9000100          	dw	DEVIO_IN_PROGRESS, 0C9h, 1
 49189                                  				; "devio call in progress" status flag ptr
 49190                                  	;;;
 49191 00001079 00000000                	dw	0, 0
 49192                                  
 49193                                  	;;;
 49194                                  	; 17/01/2024 - PCDOS 7.1 IBMDOS.COM
 49195 0000107D FFFF                    	dw	0FFFFh
 49196 0000107F FFFF                    	dw	0FFFFh
 49197                                  CL0FATENTRY_HW:
 49198 00001081 FFFF                    	dw	0FFFFh
 49199                                  Unknown_Table:
 49200 00001083 0000                    	dw	0
 49201 00001085 C900                    	dw	0C9h
 49202 00001087 [CC00]                  	dw	SFTABL		; DOSDATA:00CCh
 49203 00001089 [F901]                  	dw	CARPOS
 49204 0000108B C900                    	dw	0C9h
 49205 0000108D [7412]                  	dw	UNKNOWN1	; ? (points to DOSDATA:114Dh)
 49206 0000108F 0000                    	dw	0
 49207 00001091 0000                    	dw	0
 49208                                  	;;;
 49209                                  
 49210                                  ; M001; SR;
 49211                                  ; M001; On DOSMGR call ( cx == 0 ), we need to return a table of offsets of
 49212                                  ; M001; some DOS variables. Note that the only really important variable in
 49213                                  ; M001; this is User_Id. The other variables are needed only to patch stuff
 49214                                  ; M001; which does not need to be done in DOS 5.0. 
 49215                                  
 49216                                  ; 29/12/2022
 49217                                  ; (MSDOS 6.21 MSDOS.SYS DOSDATA:1022h)
 49218                                  
 49219                                  Win386_DOSVars:
 49220 00001093 05                      	db	5	;Major version 5 ; M001
 49221 00001094 00                      	db	0	;Minor version 0 ; M001
 49222 00001095 [EC05]                  	dw	SAVEDS	; M001
 49223 00001097 [EA05]                  	dw	SAVEBX	; M001
 49224 00001099 [2103]                  	dw	INDOS	; M001
 49225 0000109B [3E03]                  	dw	USER_ID	; M001
 49226 0000109D [1503]                  	dw	CritPatch ; M001
 49227 0000109F [8C00]                  	dw	UMB_HEAD ; M012
 49228                                  
 49229                                  ;SR;
 49230                                  ; Flag to indicate whether WIN386 is running or not
 49231                                  
 49232 000010A1 00                      IsWin386: db	0
 49233                                  
 49234                                  ;M018
 49235                                  ; This variable contains the path to the VxD device needed for Win386
 49236                                  
 49237                                  ; 09/01/2024
 49238                                  ;VxDpath: db	'c:\wina20.386',0	;M018
 49239                                  
 49240                                  ;End WIN386 support
 49241                                  
 49242                                  ; ---------------------------------------------------------------------------
 49243                                  
 49244                                  ;SR;
 49245                                  ; These variables have been added for the special lie support for device
 49246                                  ;drivers.
 49247                                  ;
 49248                                  
 49249                                  DriverLoad:	
 49250 000010A2 01                      	db	1	;initialized to do special handling
 49251                                  BiosDataPtr:
 49252 000010A3 00000000                	dd	0
 49253                                  
 49254                                  ; 29/12/2022 - Retro DOS v4.1
 49255                                  %if 0
 49256                                  
 49257                                  ; 27/04/2019 - Retro DOS v4.0
 49258                                  ; 04/11/2022
 49259                                  ; DOSDATA:1044h (MSDOS 6.21 & MSDOS 5.0, MSDOS.SYS)
 49260                                  
 49261                                  ;------------------------------------------------------------------------
 49262                                  ; Patch for Sidekick
 49263                                  ;
 49264                                  ; A documented method for finding the offset of the Errormode flag in the
 49265                                  ; dos swappable data area if for the app to scan in the dos segment (data)
 49266                                  ; for the following sequence of instructions.
 49267                                  ;
 49268                                  ; Ref: Part C, Article 11, pg 356 of MSDOS Encyclopedia
 49269                                  ;
 49270                                  ; The Offset of Errormode flag is 0320h
 49271                                  ;
 49272                                  ;------------------------------------------------------------------------
 49273                                  
 49274                                  	db	036h, 0F6h, 06h, 020h, 03h, 0FFh ; test ss:[errormode], -1
 49275                                  	db	075h, 0Ch			 ; jnz  NearLabel
 49276                                  	db	036h, 0FFh, 036h, 058h, 03h	 ; push ss:[NearWord]
 49277                                  	db	0CDh, 028h			 ; int  28h
 49278                                  
 49279                                  ;--------------------------------------------------------------------------
 49280                                  ; Patch for PortOfEntry - M036
 49281                                  ;
 49282                                  ; PortOfEntry by Sector Technology uses an un documented way of determining
 49283                                  ; the offset of Errormode flag. The following patch is to support them in
 49284                                  ; DOS 5.0. The corresponding code is actually in msdisp.asm
 49285                                  ;
 49286                                  ;---------------------------------------------------------------------------
 49287                                  
 49288                                  	db 	080h, 03Eh, 020h, 03h, 00h 	 ; cmp 	[errormode], 0
 49289                                  	db	075h, 037h			 ; jnz	NearLabel
 49290                                  	db 	0BCh, 0A0h, 0Ah		  	 ; mov	sp, dosdata:iostack
 49291                                  
 49292                                  %endif ; 29/12/2022
 49293                                  
 49294                                  ; DOSDATA:105Dh (MSDOS 6.21, MSDOS.SYS)
 49295                                  
 49296                                  ;--------------------------------------------------------------------------
 49297                                  
 49298                                  ;*** New FCB Implementation
 49299                                  ; This variable is used as a cache in the new FCB implementation to remember
 49300                                  ;the address of a local SFT that can be recycled for a regenerate operation
 49301                                  
 49302 000010A7 00000000                LocalSFT: dd	0		; 0 to indicate invalid pointer
 49303                                  
 49304                                  ;DOSDATA ENDS
 49305                                  
 49306                                  ;============================================================================
 49307                                  ; LMSTUB.ASM (MSDOS 6.0, 1991)
 49308                                  ;============================================================================
 49309                                  ; 27/04/2019 - Retro DOS 4.0
 49310                                  
 49311                                  ;DOSDATA  SEGMENT WORD PUBLIC 'DATA'
 49312                                  
 49313                                  ;---------------------------------------------------------------------------
 49314                                  ;	Low Memory Stub for DOS when DOS runs in HMA
 49315                                  ;----------------------------------------------------------------------------
 49316                                  	
 49317                                  	;db	90h
 49318                                  
 49319                                  	;EVEN
 49320 000010AB 90                      align 2
 49321                                  
 49322                                  ; DOSDATA:1062h (MSDOS 6.21, MSDOS.SYS)
 49323                                  
 49324                                  DOSINTTABLE:	; LABEL	DWORD
 49325                                  
 49326                                  	;DW	OFFSET DOSCODE:DIVOV 		, 0
 49327                                  	;DW	OFFSET DOSCODE:QUIT 		, 0
 49328                                  	;DW	OFFSET DOSCODE:COMMAND		, 0
 49329                                  	;DW	OFFSET DOSCODE:ABSDRD		, 0
 49330                                  	;DW	OFFSET DOSCODE:ABSDWRT		, 0
 49331                                  	;DW	OFFSET DOSCODE:Stay_resident	, 0
 49332                                  	;DW	OFFSET DOSCODE:INT2F		, 0
 49333                                  	;DW	OFFSET DOSCODE:CALL_ENTRY	, 0
 49334                                  	;DW	OFFSET DOSCODE:IRETT		, 0
 49335                                  	
 49336 000010AC [395C]0000              	dw	DIVOV 		, 0  ; DOSINTTABLE+0
 49337 000010B0 [C502]0000              	dw	QUIT 		, 0  ; DOSINTTABLE+4	
 49338 000010B4 [F102]0000              	dw	COMMAND		, 0  ; DOSINTTABLE+8
 49339 000010B8 [2D05]0000              	dw	ABSDRD		, 0  ; DOSINTTABLE+12
 49340 000010BC [DC05]0000              	dw	ABSDWRT		, 0  ; DOSINTTABLE+16
 49341 000010C0 [AD6B]0000              	dw	STAY_RESIDENT	, 0  ; DOSINTTABLE+20
 49342 000010C4 [3C07]0000              	dw	INT2F		, 0  ; DOSINTTABLE+24
 49343 000010C8 [CC02]0000              	dw	CALL_ENTRY	, 0  ; DOSINTTABLE+28
 49344 000010CC [CB02]0000              	dw	IRETT		, 0  ; DOSINTTABLE+32
 49345                                  
 49346 000010D0 0000                    SS_Save: dw	0		; save user's stack segment
 49347 000010D2 0000                    SP_Save: dw	0		; save user's stack offset
 49348                                  
 49349                                  ;-------------------------------------------------------------------------
 49350                                  ;
 49351                                  ; LOW MEM STUB:
 49352                                  ;
 49353                                  ; The low mem stub contains the entry points into DOS for all interrupts
 49354                                  ; handled by DOS. This stub is installed if the user specifies that the
 49355                                  ; DOS load in HIMEM. Each entry point does this.
 49356                                  ;
 49357                                  ; 	1. if jmp to 8 has been patched out
 49358                                  ;	   2. if A20 OFF
 49359                                  ;	      3. Enable A20
 49360                                  ;	   4. else 
 49361                                  ;	      5. just go to dos entry
 49362                                  ;	   6. endif
 49363                                  ;	7. else
 49364                                  ;	   8. just go to dos entry
 49365                                  ;	9. endif
 49366                                  ;
 49367                                  ;--------------------------------------------------------------------------
 49368                                  
 49369                                  ; 27/04/2019 - Retro DOS v4.0
 49370                                  
 49371                                  ; DOSDATA:108Ah (MSDOS 6.21, MSDOS.SYS)
 49372                                  
 49373                                  ;--------------------------------------------------------------------------
 49374                                  ;
 49375                                  ; DIVIDE BY 0 handler
 49376                                  ;
 49377                                  ;--------------------------------------------------------------------------
 49378                                  
 49379                                  ldivov:
 49380                                  	; The following jump, skipping the XMS calls will be patched to 
 49381                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 49382                                  	; needed because the stub is installed even before the XMS driver
 49383                                  	; is loaded if the user specifies dos=high in the config.sys
 49384                                  i0patch:
 49385 000010D4 EB03                    	jmp	short divov_cont
 49386                                  
 49387 000010D6 E8D800                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49388                                  divov_cont:
 49389 000010D9 2EFF2E[AC10]            	jmp	far [cs:DOSINTTABLE]	; jmp to DOS
 49390                                  
 49391                                  ;------------------------------------------------------------------------
 49392                                  ;
 49393                                  ; INT 20 Handler
 49394                                  ;
 49395                                  ; Here we do not have to set up the stack to return here as the abort call
 49396                                  ; will return to the address after the int 21 ah=4b call. This would be the
 49397                                  ; common exit point if A20 had been OFF (for TOGGLE DOS) and the A20 line
 49398                                  ; will be restored then.
 49399                                  ;
 49400                                  ;-------------------------------------------------------------------------
 49401                                  
 49402                                  lquit:
 49403                                  	; The following jump, skipping the XMS calls will be patched to 
 49404                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 49405                                  	; needed because the stub is installed even before the XMS driver
 49406                                  	; is loaded if the user specifies dos=high in the config.sys
 49407                                  i20patch:
 49408 000010DE EB03                    	jmp	short quit_cont
 49409                                  
 49410 000010E0 E8CE00                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49411                                  quit_cont:
 49412 000010E3 2EFF2E[B010]            	jmp	far [cs:DOSINTTABLE+4]	; jump to DOS
 49413                                  
 49414                                  ;--------------------------------------------------------------------------
 49415                                  ;
 49416                                  ; INT 21 Handler
 49417                                  ;
 49418                                  ;--------------------------------------------------------------------------
 49419                                  
 49420                                  lcommand:
 49421                                  	; The following jump, skipping the XMS calls will be patched to 
 49422                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 49423                                  	; needed because the stub is installed even before the XMS driver
 49424                                  	; is loaded if the user specifies dos=high in the config.sys
 49425                                  i21patch:
 49426 000010E8 EB03                    	jmp	short command_cont
 49427                                  
 49428 000010EA E8C400                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49429                                  command_cont:
 49430 000010ED 2EFF2E[B410]            	jmp	far [cs:DOSINTTABLE+8]	; jmp to DOS
 49431                                  
 49432                                  ;------------------------------------------------------------------------
 49433                                  ;
 49434                                  ; INT 25 
 49435                                  ;
 49436                                  ;----------------------------------------------------------------------------
 49437                                  
 49438                                  labsdrd:
 49439                                  	; The following jump, skipping the XMS calls will be patched to 
 49440                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 49441                                  	; needed because the stub is installed even before the XMS driver
 49442                                  	; is loaded if the user specifies dos=high in the config.sys
 49443                                  i25patch:
 49444 000010F2 EB03                    	jmp	short absdrd_cont
 49445                                  
 49446 000010F4 E8BA00                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49447                                  absdrd_cont:
 49448 000010F7 2EFF2E[B810]            	jmp	far [cs:DOSINTTABLE+12]	; jmp to DOS
 49449                                  
 49450                                  ;-------------------------------------------------------------------------
 49451                                  ;
 49452                                  ; INT 26
 49453                                  ;
 49454                                  ;-----------------------------------------------------------------------
 49455                                  
 49456                                  labsdwrt:
 49457                                  	; The following jump, skipping the XMS calls will be patched to 
 49458                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 49459                                  	; needed because the stub is installed even before the XMS driver
 49460                                  	; is loaded if the user specifies dos=high in the config.sys
 49461                                  i26patch:
 49462 000010FC EB03                    	jmp	short absdwrt_cont
 49463                                  
 49464 000010FE E8B000                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49465                                  absdwrt_cont:
 49466 00001101 2EFF2E[BC10]            	jmp	far [cs:DOSINTTABLE+16]	; jmp to DOS
 49467                                  
 49468                                  ;------------------------------------------------------------------------
 49469                                  ;
 49470                                  ; INT 27
 49471                                  ;
 49472                                  ;-----------------------------------------------------------------------
 49473                                  
 49474                                  lstay_resident:
 49475                                  	; The following jump, skipping the XMS calls will be patched to
 49476                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 49477                                  	; needed because the stub is installed even before the XMS driver
 49478                                  	; is loaded if the user specifies dos=high in the config.sys
 49479                                  i27patch:
 49480 00001106 EB03                    	jmp	short sr_cont
 49481                                  
 49482 00001108 E8A600                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49483                                  sr_cont:
 49484 0000110B 2EFF2E[C010]            	jmp	far [cs:DOSINTTABLE+20]	; jmp to DOS
 49485                                  
 49486                                  ;-----------------------------------------------------------------------------
 49487                                  ;
 49488                                  ; INT 2f
 49489                                  ;
 49490                                  ;-------------------------------------------------------------------------
 49491                                  
 49492                                  lint2f:
 49493                                  	; The following jump, skipping the XMS calls will be patched to 
 49494                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 49495                                  	; needed because the stub is installed even before the XMS driver
 49496                                  	; is loaded if the user specifies dos=high in the config.sys
 49497                                  i2fpatch:
 49498 00001110 EB03                    	jmp	short int2f_cont
 49499                                  
 49500 00001112 E89C00                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49501                                  int2f_cont:
 49502 00001115 2EFF2E[C410]            	jmp	far [cs:DOSINTTABLE+24]	; jmp to DOS
 49503                                  
 49504                                  ;-----------------------------------------------------------------------------
 49505                                  ;
 49506                                  ; CPM entry
 49507                                  ;
 49508                                  ;------------------------------------------------------------------------
 49509                                  
 49510                                  lcall_entry:
 49511                                  	; The following jump, skipping the XMS calls will be patched to 
 49512                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 49513                                  	; needed because the stub is installed even before the XMS driver
 49514                                  	; is loaded if the user specifies dos=high in the config.sys
 49515                                  cpmpatch:
 49516 0000111A EB03                    	jmp	short callentry_cont
 49517                                  
 49518 0000111C E89200                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49519                                  callentry_cont:
 49520 0000111F 2EFF2E[C810]            	jmp	far [cs:DOSINTTABLE+28]	; jmp to DOS
 49521                                  
 49522                                  ;--------------------------------------------------------------------------
 49523                                  
 49524                                  lirett:
 49525 00001124 CF                      	iret
 49526                                  
 49527                                  ;---------------------------------------------------------------------------
 49528                                  ;
 49529                                  ; LowIntXX:
 49530                                  ;
 49531                                  ; Interrupts from DOS that pass control to a user program must be done from
 49532                                  ; low memory, as the user program may change the state of the A20 line or
 49533                                  ; they may require that the A20 line be OFF. The following piece of code is
 49534                                  ; far call'd from the following places in DOS:
 49535                                  ;
 49536                                  ;	1. msctrlc.asm where dos issues an int 23h (ctrlc)
 49537                                  ;	2. msctrlc.asm where dos issues an int 24h (critical error)
 49538                                  ;	3. msctrlc.asm where dos issues an int 28h (idle int)
 49539                                  ;
 49540                                  ; The int 23 and int 24 handlers may decide to do a far return instead of an
 49541                                  ; IRET ane leave the flags on the stack. Therefore we save the return address
 49542                                  ; before doing the ints and then do a far junp back into DOS.
 49543                                  ;
 49544                                  ;---------------------------------------------------------------------------
 49545                                  
 49546 00001125 00000000                DosRetAddr23:	dd	0
 49547 00001129 00000000                DosRetAddr24:	dd	0
 49548 0000112D 00000000                DosRetAddr28:	dd	0
 49549                                  
 49550                                  	; Execute int 23h from low memory
 49551                                  LowInt23:
 49552                                  					; save the return address that is on
 49553                                  					; the stack
 49554 00001131 2E8F06[2511]            	pop	word [cs:DosRetAddr23]
 49555 00001136 2E8F06[2711]            	pop	word [cs:DosRetAddr23+2]
 49556                                  
 49557 0000113B CD23                    	int	23h			; ctrl C
 49558                                  					; turn on A20 it has been turned OFF
 49559                                  					; by int 28/23/24 handler.
 49560                                  
 49561 0000113D E87100                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF 
 49562                                  
 49563 00001140 2EFF2E[2511]            	jmp	far [cs:DosRetAddr23]	; jump back to DOS
 49564                                  
 49565                                  
 49566                                  	; Execute int 24h from low memory
 49567                                  LowInt24:
 49568                                  					; save the return address that is on
 49569                                  					; the stack
 49570 00001145 2E8F06[2911]            	pop	word [cs:DosRetAddr24]
 49571 0000114A 2E8F06[2B11]            	pop	word [cs:DosRetAddr24+2]
 49572                                  
 49573 0000114F CD24                    	int	24h			; crit error
 49574                                  					; turn on A20 it has been turned OFF
 49575                                  					; by int 28/23/24 handler.
 49576                                  
 49577 00001151 E85D00                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF
 49578                                  
 49579 00001154 2EFF2E[2911]            	jmp	far [cs:DosRetAddr24]	; jump back to DOS
 49580                                  
 49581                                  
 49582                                   
 49583                                  	; Execute int 28h from low memory
 49584                                  LowInt28:
 49585 00001159 CD28                    	int	28h			; idle int
 49586                                  					; turn on A20 it has been turned OFF
 49587                                  					; by int 28/23/24 handler.
 49588                                  
 49589 0000115B E85300                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF
 49590                                  
 49591 0000115E CB                      	retf
 49592                                  
 49593                                  ; DOSDATA:1115h (MSDOS 6.21, MSDOS.SYS)
 49594                                  
 49595                                  ;-------------------------------------------------------------------------
 49596                                  ;
 49597                                  ; int 21 ah=4b (exec) call will jump to the following label before xferring
 49598                                  ; control to the exec'd program. We turn off A20 inorder to allow programs
 49599                                  ; that have been packed by the faulty exepack utility to unpack correctly.
 49600                                  ; This is so because exepac'd programs rely on address wrap.
 49601                                  ;
 49602                                  ;------------------------------------------------------------------------- 
 49603                                  
 49604                                  disa20_xfer:
 49605 0000115F E83F00                  	call	XMMDisableA20		; disable A20
 49606                                  
 49607                                  	; Look at msproc.asm at label exec_go for understanding the following:
 49608                                  
 49609                                  	; DS:SI points to entry point
 49610                                  	; AX:DI points to initial stack
 49611                                  	; DX has PDB pointer
 49612                                  	; BX has initial AX value
 49613                                  
 49614 00001162 FA                      	cli
 49615 00001163 2EC606[2103]00          	mov	byte [cs:INDOS],0	; SS Override
 49616                                  
 49617 00001169 8ED0                    	mov	SS,AX			; set up user's stack
 49618 0000116B 89FC                    	mov	SP,DI			; and SP
 49619 0000116D FB                      	sti
 49620                                  
 49621 0000116E 1E                      	push	DS			; fake long call to entry
 49622 0000116F 56                      	push	SI
 49623 00001170 8EC2                    	mov	ES,DX			; set up proper seg registers
 49624 00001172 8EDA                    	mov	DS,DX
 49625 00001174 89D8                    	mov	AX,BX			; set up proper AX
 49626 00001176 CB                      	retf
 49627                                  
 49628                                  ;-------------------------------------------------------------------------
 49629                                  ;
 49630                                  ; M003:
 49631                                  ;
 49632                                  ; If an int 21 ah=25 call is made immediately after an exec call, DOS will
 49633                                  ; come here, turn A20 OFF restore user stack and registers before returning
 49634                                  ; to user. This is done in dos\msdisp.asm. This has been done to support 
 49635                                  ; programs compiled with MS PASCAL 3.2. See under TAG M003 in DOSSYM.INC for
 49636                                  ; more info.	
 49637                                  ;
 49638                                  ; Also at this point DS is DOSDATA. So we can assume DS DOSDATA. Note that
 49639                                  ; SS is also DOS stack. It is important that we do the XMS call on DOS's
 49640                                  ; stack to avoid additional stack overhead for the user.
 49641                                  ;
 49642                                  ; -------------------------------------------------------------------------
 49643                                  
 49644                                  disa20_iret:
 49645 00001177 E82700                  	call	XMMDisableA20
 49646 0000117A FE0E[2103]              	dec	byte [INDOS]
 49647 0000117E 8E16[8605]              	mov	SS,[USER_SS]		; restore user stack
 49648 00001182 8B26[8405]              	mov	SP,[USER_SP]
 49649 00001186 89E5                    	mov	BP,SP
 49650                                  	;mov	[BP+user_env.user_AX],AL
 49651 00001188 884600                  	mov	[bp],al
 49652 0000118B A1[F205]                	mov	AX,[NSP]
 49653 0000118E A3[8405]                	mov	[USER_SP],AX
 49654 00001191 A1[F005]                	mov	AX,[NSS]
 49655 00001194 A3[8605]                	mov	[USER_SS],AX
 49656                                  
 49657 00001197 58                      	pop	AX			; restore user regs
 49658 00001198 5B                      	pop	BX
 49659 00001199 59                      	pop	CX
 49660 0000119A 5A                      	pop	DX
 49661 0000119B 5E                      	pop	SI
 49662 0000119C 5F                      	pop	DI
 49663 0000119D 5D                      	pop	BP
 49664 0000119E 1F                      	pop	DS
 49665 0000119F 07                      	pop	ES
 49666 000011A0 CF                      	iret
 49667                                  
 49668                                  ;**************************************************************************
 49669                                  ;***	XMMDisableA20 - switch 20th address line
 49670                                  ;
 49671                                  ;	This routine is used to disable the 20th address line in
 49672                                  ;	the system using XMM calls.
 49673                                  ;
 49674                                  ;	ENTRY	none		;ds = _DATA
 49675                                  ;	EXIT	A20 line disabled
 49676                                  ;	USES	NOTHING
 49677                                  ;
 49678                                  ;**************************************************************************
 49679                                  
 49680                                  XMMDisableA20:
 49681 000011A1 53                      	push	bx
 49682 000011A2 50                      	push	ax
 49683                                  	;mov	ah,XMM_LOCAL_DISABLE_A20
 49684 000011A3 B406                    	mov	ah,6
 49685 000011A5 2EFF1E[AD11]            	call	far [cs:XMMcontrol]
 49686 000011AA 58                      	pop	ax
 49687 000011AB 5B                      	pop	bx
 49688 000011AC C3                      	retn
 49689                                  
 49690                                  ; The entry point in the BIOS XMS driver is defined here.
 49691                                  
 49692                                  XMMcontrol:
 49693 000011AD 00000000                	dd	0
 49694                                  
 49695                                  ;--------------------------------------------------------------------------
 49696                                  ;
 49697                                  ;***	EnsureA20ON - Ensures that A20 is ON
 49698                                  ;
 49699                                  ;	This routine is used to query the A20 state in
 49700                                  ;	the system using XMM calls.
 49701                                  ;
 49702                                  ;	ENTRY: none
 49703                                  ;
 49704                                  ;	EXIT : A20 will be ON
 49705                                  ;		
 49706                                  ; 	USES : NONE
 49707                                  ;
 49708                                  ;--------------------------------------------------------------------------
 49709                                  
 49710                                  ; 19/09/2023
 49711                                  ;LowMemory:	; label dword		; Set equal to 0000:0080
 49712                                  ;	dw	00080h
 49713                                  ;	dw	00000h
 49714                                  ;
 49715                                  ;HighMemory:	; label dword
 49716                                  ;	dw	00090h			; Set equal to FFFF:0090
 49717                                  ;	dw	0FFFFh
 49718                                  
 49719                                  EnsureA20ON:
 49720 000011B1 9C                      	pushf
 49721 000011B2 1E                      	push    ds
 49722 000011B3 06                      	push	es
 49723 000011B4 51                      	push	cx
 49724 000011B5 56                      	push	si
 49725 000011B6 57                      	push	di
 49726                                  
 49727                                  	; 19/09/2023
 49728                                  	;lds	si,[cs:LowMemory]	; Compare the 4 words at 0000:0080
 49729                                  	;les	di,[cs:HighMemory]	; with the 4 at FFFF:0090
 49730                                  
 49731 000011B7 31FF                    	xor	di,di
 49732 000011B9 8EC7                    	mov	es,di
 49733 000011BB 4F                      	dec	di
 49734 000011BC BE9000                  	mov	si,90h	; 0FFFFh:0090h	; HighMemory
 49735 000011BF 8EDF                    	mov	ds,di
 49736 000011C1 BF8000                  	mov	di,80h ; 0000h:0080h	; LowMemory
 49737                                  	
 49738 000011C4 B90400                  	mov	cx,4
 49739 000011C7 FC                      	cld
 49740 000011C8 F3A7                    	repe    cmpsw
 49741                                  
 49742 000011CA 7407                    	jz	short EA20_OFF
 49743                                  EA20_RET:
 49744 000011CC 5F                      	pop	di
 49745 000011CD 5E                      	pop	si
 49746 000011CE 59                      	pop	cx
 49747 000011CF 07                      	pop	es
 49748 000011D0 1F                      	pop	ds
 49749 000011D1 9D                      	popf
 49750 000011D2 C3                      	retn
 49751                                  
 49752                                  EA20_OFF:
 49753                                  	; We are going to do the XMS call on the DOS's AuxStack.
 49754                                  	; NOTE: ints are disabled at this point.
 49755                                  
 49756 000011D3 53                      	push	bx
 49757 000011D4 50                      	push	ax
 49758                                  
 49759 000011D5 8CD0                    	mov	ax,ss			; save user's stack pointer
 49760 000011D7 2EA3[D010]              	mov	[cs:SS_Save],ax
 49761 000011DB 2E8926[D210]            	mov	[cs:SP_Save],sp
 49762 000011E0 8CC8                    	mov	ax,cs
 49763 000011E2 8ED0                    	mov	ss,ax
 49764 000011E4 BC[A007]                	mov	sp,AUXSTACK
 49765                                  					; ss:sp -> DOSDATA:AuxStack
 49766                                  	;mov	ah,XMM_LOCAL_ENABLE_A20
 49767 000011E7 B405                    	mov	ah,5
 49768 000011E9 2EFF1E[AD11]            	call	far [cs:XMMcontrol]
 49769 000011EE 09C0                    	or	ax,ax
 49770 000011F0 740F                    	jz	short XMMerror		; AX = 0 fatal error
 49771                                  
 49772 000011F2 2EA1[D010]              	mov	ax,[cs:SS_Save]		; restore user stack
 49773 000011F6 8ED0                    	mov	ss,ax
 49774 000011F8 2E8B26[D210]            	mov	sp,[cs:SP_Save]
 49775                                  
 49776 000011FD 58                      	pop	ax
 49777 000011FE 5B                      	pop	bx
 49778                                  
 49779 000011FF EBCB                    	jmp	short EA20_RET
 49780                                  
 49781                                  XMMerror:				; M006 - Start
 49782 00001201 B40F                    	mov	ah,0Fh			; get video mode
 49783 00001203 CD10                    	int	10h
 49784 00001205 3C07                    	cmp	al,7			; Q: are we an MDA
 49785 00001207 7406                    	je	short XMMcont			; Y: do not change mode
 49786 00001209 30E4                    	xor	ah,ah ; 0			; set video mode
 49787 0000120B B002                    	mov	al,02h			; 80 X 25 text
 49788 0000120D CD10                    	int	10h
 49789                                  XMMcont:
 49790 0000120F B405                    	mov	ah,05h			; set display page
 49791 00001211 30C0                    	xor	al,al			; page 0
 49792 00001213 CD10                    	int	10h
 49793                                  	
 49794 00001215 BE[3A13]                	mov	si,XMMERRMSG
 49795 00001218 0E                      	push	cs
 49796 00001219 1F                      	pop	ds
 49797 0000121A FC                      	cld				; clear direction flag
 49798                                  XMMprnt:
 49799 0000121B AC                      	lodsb
 49800 0000121C 3C24                    	cmp	al,'$'			; indicates end of XMMERRMSG
 49801 0000121E 7409                    	jz	short XMMStall		; function 0Eh	
 49802 00001220 B40E                    	mov	ah,0Eh
 49803 00001222 BB0700                  	mov	bx,7
 49804 00001225 CD10                    	int	10h
 49805 00001227 EBF2                    	jmp	short XMMprnt
 49806                                  
 49807                                  XMMStall:
 49808 00001229 FB                      	sti				; allow the user to warm boot
 49809 0000122A EBFD                    	jmp	short XMMStall		; M006 - End
 49810                                  
 49811                                  ;---------------------------------------------------------------------------
 49812                                  
 49813                                  ; 27/04/2019 - Retro DOS v4.0
 49814                                  
 49815                                  ; retrodos4.s ; offset 0Ch in BIOS segment (0070h)
 49816                                  ALTAH	equ 0Ch
 49817                                  
 49818                                  ;This has been put in for WIN386 2.XX support. The format of the instance 
 49819                                  ;table was different for this. Segments will be patched in at init time.
 49820                                  
 49821                                  OldInstanceJunk:
 49822 0000122C 7000                    	dw	70h	;segment of BIOS
 49823 0000122E 0000                    	dw	0	;indicate stacks in SYSINIT area
 49824 00001230 0600                    	dw	6	;6 instance items
 49825                                  
 49826                                  	;dw	0,offset dosdata:contpos, 2
 49827                                  	;dw	0,offset dosdata:bcon, 4
 49828                                  	;dw	0,offset dosdata:carpos,106h
 49829                                  	;dw	0,offset dosdata:charco, 1
 49830                                  	;dw	0,offset dosdata:exec_init_sp, 34               ;M032
 49831                                  	;dw	070h,offset BData:altah, 1	 ; altah byte in bios
 49832                                  
 49833 00001232 0000[2200]0200          	dw	0,CONTPOS,2
 49834 00001238 0000[3200]0400          	dw	0,BCON,4
 49835 0000123E 0000[F901]0601          	dw	0,CARPOS,106h
 49836 00001244 0000[0003]0100          	dw	0,CHARCO,1
 49837 0000124A 0000[0510]2200          	dw	0,exec_init_SP,34
 49838 00001250 70000C000100            	dw	70h,ALTAH,1	; altah byte in bios
 49839                                  
 49840                                  ;---------------------------------------------------------------------------
 49841                                  
 49842                                  ; 17/01/2024
 49843                                  %if 0
 49844                                  
 49845                                  ; M021-
 49846                                  ;
 49847                                  ; DosHasHMA - This flag is set by seg_reinit when the DOS actually
 49848                                  ; 	takes control of the HMA. When running, this word is a reliable
 49849                                  ;	indicator that the DOS is actually using HMA. You can't just use
 49850                                  ;	CS, because ROMDOS uses HMA with CS < F000.
 49851                                  
 49852                                  DosHasHMA:
 49853                                  	db	0
 49854                                  FixExePatch:
 49855                                  	dw	0		; M012
 49856                                  
 49857                                  %endif
 49858                                  
 49859                                  ; 28/12/2022 - Retro DOS v4.1
 49860                                  ;RationalPatchPtr:
 49861                                  ;	dw	0		; M012
 49862                                  
 49863                                  ; End M021
 49864                                  
 49865                                  ;---------------------------------------------------------------------------
 49866                                  
 49867                                  ; 28/12/2022 - Retro DOS v4.1
 49868                                  %if 0
 49869                                  
 49870                                  ; M020 Begin
 49871                                  
 49872                                  RatBugCode:	; proc	far
 49873                                  	push	cx
 49874                                  	mov	cx,[10h]
 49875                                  rbc_loop:
 49876                                  	;loop	$
 49877                                  	loop	rbc_loop
 49878                                  	pop	cx
 49879                                  	retf
 49880                                  		
 49881                                  ; M020 End
 49882                                  
 49883                                  %endif
 49884                                  
 49885                                  ;---------------------------------------------------------------------------
 49886                                  	
 49887                                  UmbSave1:
 49888                                  	;db	11 dup (?)	; M023
 49889 00001256 00<rep Bh>              	times	11 db 0
 49890                                  
 49891                                  ;---------------------------------------------------------------------------
 49892                                  ; 16/01/2024 - Retrodos v5.0
 49893                                  ; PCDOS 7.1 IBMDOS.COM
 49894                                  ; DOSDATA: 113Ah
 49895                                  
 49896                                  OLD_FIRSTCLUS_HW:
 49897 00001261 0000                    	dw	0
 49898                                  
 49899                                  ; 17/01/2024 
 49900                                  %if 1
 49901                                  
 49902                                  ; DOS 3.3 F.C. 6/12/86
 49903                                  ; FASTOPEN communications area DOS 3.3   F.C. 5/29/86
 49904                                  
 49905                                  FastTable:				; a better name
 49906                                  FastOpenTable:
 49907 00001263 0200                    	dw      2                       ; number of entries
 49908 00001265 [9A18]                  	dw      FastRet			; pointer to ret instr.
 49909 00001267 0000                    	dw      0                       ; and will be modified by
 49910 00001269 [9A18]                  	dw      FastRet			; FASTxxx when loaded in
 49911 0000126B 0000                    	dw      0
 49912                                  
 49913                                  ; DOS 3.3 F.C. 6/12/86
 49914                                  
 49915                                  FastFlg:				; flags
 49916                                  FastOpenFlg:
 49917 0000126D 00                      	db	0			; don't change the foll: order
 49918                                  
 49919                                  %endif
 49920 0000126E 000000000000            	db	0,0,0,0,0,0
 49921                                  UNKNOWN1:
 49922 00001274 0000                    	dw	0
 49923 00001276 0000000000              	db	0,0,0,0,0
 49924                                  PATHNAMELEN:
 49925 0000127B 4300                    	dw	67
 49926                                   
 49927 0000127D 0000000000000000        	db	0,0,0,0,0,0,0,0
 49928 00001285 0000000000000000        	db	0,0,0,0,0,0,0,0
 49929 0000128D 0000000000000000        	db	0,0,0,0,0,0,0,0
 49930 00001295 00000000000000          	db	0,0,0,0,0,0,0
 49931                                  
 49932                                  ; 17/01/2024
 49933                                  ; DOSDATA:1175h
 49934                                  CurSC_DRIVE:
 49935 0000129C FF                      	db	-1  ; 0FFh	; current SC drive
 49936                                  
 49937                                  ;M044
 49938                                  ; Second part of save area for saving last para of Windows memory
 49939                                  
 49940                                  ; 17/01/2024
 49941                                  WinoldPatch2:
 49942                                  	;db	8 dup (?)	; M044
 49943 0000129D 00<rep 8h>              	times	8 db 0	
 49944                                  
 49945                                  FIRST_BUFF_ADDR:
 49946 000012A5 0000                    	dw	0
 49947                                  
 49948                                  ;----------------------------------------------------------------------------
 49949                                  ; 17/01/2024 - Retrodos v5.0
 49950                                  ; PCDOS 7.1 IBMDOS.COM
 49951                                  ; DOSDATA:1180h
 49952                                  
 49953                                  %if 1
 49954                                  
 49955                                  ;============================================================================
 49956                                  ; WPATCH.INC (MSDOS 6.0, 1991)  ;;; Windows 3.1 patches ;;;
 49957                                  ;============================================================================
 49958                                  ; 27/04/2019 - Retro DOS 4.0
 49959                                  
 49960                                  ; DOSDATA:12CFh (MSDOS 6.21, MSDOS.SYS)
 49961                                  
 49962                                  ; Retro DOS v5.0
 49963                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:1180h	
 49964                                  
 49965                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 49966                                  ; DOSDATA:12CFh (MSDOS 5.0, MSDOS.SYS)
 49967                                  
 49968                                  ; first and second DOS patches
 49969                                  ;	Non-console device read/write (system calls 3Fh and 40h)
 49970                                  ;
 49971                                  ; Code in disk.asm, 2 locations, one for read, one for write
 49972                                  ;	DVRDLP:
 49973                                  ;	DVWRTLP:
 49974                                  ;
 49975                                  ;
 49976                                  ; 036h	lds	si,SS:[????]				  ; ThisSFT
 49977                                  ;	lds	si,si+7 				  ; sf_devptr
 49978                                  ; 0E8h	call	????		<- "simulate" int28 event ; DSKSTATCHK
 49979                                  
 49980 000012A7 36C536                  DOSP1_ID:	db	036h,0C5h,036h
 49981 000012AA 3605C57407E8            DOSP1_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 49982                                  DOSP1_ID_LEN	equ	$-DOSP1_ID
 49983                                  
 49984 000012B0 9090                    		db	90h, 90h
 49985                                  
 49986 000012B2 36C536                  DOSP12_ID:	db	036h,0C5h,036h
 49987 000012B5 3605C57407E8            DOSP12_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 49988                                  DOSP12_ID_LEN	equ	$-DOSP1_ID
 49989                                  
 49990                                  ; DOSDATA:12E3h
 49991                                  
 49992                                  ; Third/Fourth DOS patch - System call 3Fh (Read) from console
 49993                                  ;
 49994                                  ; Code in disk.asm, 1 location
 49995                                  ;	GETBUF:
 49996                                  ;
 49997                                  ; 051h	push	cx	<- begin special int28 mode
 49998                                  ;	push	es
 49999                                  ;	push	di
 50000                                  ;	mov	dx,???? ; offset dosgroup:CONBUF
 50001                                  ;	call	????	; $STD_CON_STRING_INPUT
 50002                                  ;	pop	di
 50003                                  ;	pop	es
 50004                                  ; 059h	pop	cx	<- end special int28 mode
 50005                                  
 50006 000012BB 510657BA                DOSP3_ID:	db	051h,006h,057h,0BAh
 50007 000012BF 2902E8                  DOSP3_CONBUF:	db	029h,002h,0E8h
 50008                                  DOSP3_ID_LEN	equ	$-DOSP3_ID
 50009 000012C2 9AE35F07                		db	09Ah,0E3h,05Fh,007h	; ???? , pop di, pop es
 50010 000012C6 59                      DOSP4_ID:	db	059h			; pop cx
 50011                                  DOSP4_ID_OFF	equ	(DOSP4_ID - DOSP3_ID)
 50012                                  	
 50013                                  ; DOSDATA:12EFh
 50014                                  
 50015                                  ; Fifth DOS patch - System call 40h (Write) to console
 50016                                  ;
 50017                                  ; Code in disk.asm, 1 location
 50018                                  ;
 50019                                  ;		push	cx
 50020                                  ;      WRCONLP: lodsb
 50021                                  ;		cmp	al,1Ah
 50022                                  ;		jz	????
 50023                                  ;		call	????	<- "simulate" int28 event
 50024                                  ;		loop	WRCONLP
 50025                                  ;      CONEOF:	pop	ax
 50026                                  
 50027 000012C7 51                      DOSP5_ID:	db	051h			; push cx
 50028 000012C8 AC3C1A7405              		db	0ACh,03Ch,01Ah,074h,005h
 50029 000012CD E8                      		db	0E8h			; call
 50030                                  DOSP5_ID_LEN	equ	$-DOSP5_ID
 50031                                  
 50032                                  ; DOSDATA:12F6h
 50033                                  
 50034                                  ; Seventh DOS patch - System call entry, patch USER_ID with VMid for share
 50035                                  ;
 50036                                  ; Code in disp.asm, 1 location
 50037                                  ;
 50038                                  ;
 50039                                  ;	mov [SaveDS],ds
 50040                                  ;	mov [SaveBX],bx
 50041                                  ;	mov bx,cs
 50042                                  ;	mov ds,bx
 50043                                  ;	inc [indos]
 50044                                  ;	xor ax,ax
 50045                                  ;	mov [USER_ID],AX	<- Patch to set USER_ID to VMID
 50046                                  
 50047 000012CE 2E8C1E                  DOSP7_ID:	db	02Eh,08Ch,01Eh
 50048 000012D1 7E05                    DOSP7_SAVEDS:	db	07Eh,05h		; mov [SaveDS],ds
 50049 000012D3 2E891E                  		db	02Eh,089h,01Eh
 50050 000012D6 7C05                    DOSP7_SAVEBX:	db	07Ch,05h		; mov [SaveBX],bx
 50051 000012D8 8CCB                    		db	08Ch,0CBh		; mov bx,cs
 50052 000012DA 8EDB                    		db	08Eh,0DBh		; mov ds,bx
 50053 000012DC FE06                    		db	0FEh,006h
 50054 000012DE CF02                    DOSP7_INDOS:	db	0CFh,002h		; inc [indos]
 50055 000012E0 33C0                    		db	033h,0C0h		; xor ax,ax
 50056                                  DOSP7_ID_LEN	equ	$-DOSP7_ID
 50057                                  
 50058                                  ; DOSDATA:130Ah
 50059                                  
 50060                                  ; Eighth DOS patch - OWNER check in handle calls. For share, need to NOP test
 50061                                  ;
 50062                                  ; Code in handle.asm, 1 location in routine CheckOwner
 50063                                  ;
 50064                                  ;
 50065                                  ;
 50066                                  ;	push	ax
 50067                                  ;	mov	ax,ss:[USER_ID]     <- patch to XOR AX,AX to set zero
 50068                                  ;	cmp	ax,es:[di.sf_UID]   <- NOP
 50069                                  ;	pop	ax
 50070                                  ;	jz	????
 50071                                  
 50072 000012E2 50                      DOSP8_ID:	db	050h			; push ax
 50073 000012E3 36A1                    		db	036h,0A1h
 50074 000012E5 EA02                    DOSP8_USER_ID:	db	0EAh,002h		; mov  ax,ss:[USER_ID]
 50075 000012E7 263B45                  		db	026h,03Bh,045h		; cmp  ax,es:[di+2F]
 50076                                  DOSP8_ID_LEN	equ	$-DOSP8_ID
 50077 000012EA 2F58                    		db	02Fh,058h		; pop  ax
 50078                                  
 50079                                  ; DOSDATA:1314h
 50080                                  
 50081                                  ; 10th, 11th, 12th DOS patch - System call 3Fh (Read) in raw mode
 50082                                  ;
 50083                                  ;   Take RAW read to STDIN SFT and turn it into a polling loop doing
 50084                                  ;   a yeild when a character is not ready to be read.
 50085                                  ;
 50086                                  ; Code in disk.asm, 3 locations
 50087                                  ;
 50088                                  ;   DVRDRAW:
 50089                                  ;	    PUSH    ES
 50090                                  ;	    POP     DS
 50091                                  ;   ReadRawRetry:				<- Patch 10
 50092                                  ;	    MOV     BX,DI
 50093                                  ;	    XOR     AX,AX			<- Reenter #2
 50094                                  ;	    MOV     DX,AX
 50095                                  ;	    call    SETREAD
 50096                                  ;	    PUSH    DS				<- Reenter #1
 50097                                  ;	    LDS     SI,[THISSFT]
 50098                                  ;	    call    DEVIOCALL
 50099                                  ;	    MOV     DX,DI
 50100                                  ;	    MOV     AH,86H
 50101                                  ;	    MOV     DI,[DEVCALL.REQSTAT]
 50102                                  ;	    TEST    DI,STERR
 50103                                  ;	    JZ	    CRDROK
 50104                                  ;	    call    CHARHARD
 50105                                  ;	    MOV     DI,DX
 50106                                  ;	    OR	    AL,AL
 50107                                  ;	    JZ	    CRDROK
 50108                                  ;	    CMP     AL,3
 50109                                  ;	    JZ	    CRDFERR
 50110                                  ;	    POP     DS
 50111                                  ;	    JMP     ReadRawRetry
 50112                                  ;
 50113                                  ;   CRDFERR:
 50114                                  ;	    POP     DI				<- Patch 11
 50115                                  ;   DEVIOFERR:
 50116                                  ;	    LES     DI,[THISSFT]
 50117                                  ;	    jmp     SET_ACC_ERR_DS
 50118                                  ;
 50119                                  ;   CRDROK:
 50120                                  ;	    POP     DI				<- Patch 12
 50121                                  ;	    MOV     DI,DX
 50122                                  ;	    ADD     DI,[CALLSCNT]
 50123                                  ;	    JMP     SHORT ENDRDDEVJ3
 50124                                  
 50125 000012EC 061F                    DOSP10_ID:		db	006H,01FH
 50126                                  DOSP10_LOC_OFFSET	equ	$-DOSP10_ID
 50127 000012EE 8BDF                    DOSP10_LOC:		db	08BH,0DFH
 50128                                  DOSP10_REENT2_OFFSET	equ	$-DOSP10_LOC
 50129 000012F0 33C08BD0E8              			db	033H,0C0H,08BH,0D0H,0E8H
 50130                                  DOSP10_ID_LEN		equ	$-DOSP10_ID
 50131 000012F5 DF0E                    			db	0DFH,00EH
 50132                                  DOSP10_REENT1_OFFSET	equ	$-DOSP10_LOC
 50133 000012F7 1E36C5363605E8AF0E      			db	01EH,036H,0C5H,036H,036H,005H,0E8H,0AFH,00EH
 50134 00001300 8BD7B486368B3E          			db	08BH,0D7H,0B4H,086H,036H,08BH,03EH
 50135                                  DOSP10_PACKVAL_OFFSET	equ	$-DOSP10_ID
 50136 00001307 0903                    			db	009H,003H
 50137 00001309 F7C700807419E84717      			db	0F7H,0C7H,000H,080H,074H,019H,0E8H,047H,017H
 50138 00001312 8BFA0AC074103C0374-     			db	08BH,0FAH,00AH,0C0H,074H,010H,03CH,003H,074H,003H
 50138 0000131B 03                 
 50139 0000131C 1FEBCF                  			db	01FH,0EBH,0CFH
 50140                                  DOSP11_LOC_OFFSET	equ	$-DOSP10_ID
 50141 0000131F 5F                      			db	05FH
 50142                                  DOSP11_REENT_OFFSET	equ	$-DOSP10_LOC
 50143 00001320 36C43E3605E9A104        			db	036H,0C4H,03EH,036H,005H,0E9H,0A1H,004H
 50144                                  
 50145                                  DOSP12_LOC_OFFSET	equ	$-DOSP10_ID
 50146 00001328 5F8BFA                  			db	05FH,08BH,0FAH
 50147                                  ; DOSDATA:1353h
 50148                                  
 50149                                  ; 13th DOS patch - Actually a SYSINIT patch. Patches the stack fault code
 50150                                  ;		which prints the fatal stack fault error on DOS >= 3.20.
 50151                                  ;
 50152                                  ;	    Sets focus to current VM so user can see fatal message.
 50153                                  ;
 50154                                  ;
 50155                                  ;	l0: lodsb		<- Setfocus here
 50156                                  ;	    cmp al, '$'
 50157                                  ;	    je l1
 50158                                  ;	    mov bl, 7
 50159                                  ;	    mov ah, 0Eh
 50160                                  ;	    int 10h
 50161                                  ;	    jmp l0
 50162                                  ;	l1: jmp $
 50163                                  
 50164 0000132B AC                      DOSP13_ID:	db	0ACh			; l0: lodsb
 50165 0000132C 3C24                    		db	03Ch,024h		;     cmp al, '$'
 50166 0000132E 7408                    		db	074h,008h		;     je l1
 50167 00001330 B307                    		db	0B3h,007h		;     mov bl, 7
 50168 00001332 B40E                    		db	0B4h,00Eh		;     mov ah, 0Eh
 50169 00001334 CD10                    		db	0CDh,010h		;     int 10h
 50170 00001336 EBF3                    		db	0EBh,0F3h		;     jmp l0
 50171 00001338 EBFE                    		db	0EBh,0FEh		; l1: jmp $
 50172                                  DOSP13_ID_LEN	equ	$-DOSP13_ID
 50173                                  
 50174                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 50175                                  ; DOSDATA:1362h (MSDOS 5.0 MSDOS.SYS)
 50176                                  
 50177                                  ; 05/01/2024
 50178                                  %endif	; 05/11/2022
 50179                                  
 50180                                  ;----------------------------------------------------------------------------
 50181                                  
 50182                                  ; DOSDATA:122Ah
 50183                                  
 50184                                  Mark3:	; label byte
 50185                                  
 50186                                  ;IF2
 50187                                  ;	IF ((OFFSET MARK3) GT (OFFSET COUNTRY_CDPG) )
 50188                                  ;		%OUT !DATA CORRUPTION!MARK3 OFFSET TOO BIG. RE-ORGANIZE DATA.
 50189                                  ;	ENDIF
 50190                                  ;ENDIF
 50191                                  
 50192                                  ;----------------------------------------------------------------------------
 50193                                  
 50194                                  ; 27/04/2019 - Retro DOS v4.0
 50195                                  ; 05/01/2024 - Retro DOS v5.0
 50196                                  
 50197                                  ;include msdos.cl2			; XMMERRMSG
 50198                                  
 50199                                  ; DOSDATA:12B8h (MSDOS 6.22, MSDOS.SYS) ; 17/01/2024
 50200                                  ; DOSDATA:1213h (PCDOS 7.1, IBMDOS.COM) ; 05/01/2024
 50201                                  
 50202                                  XMMERRMSG:
 50203 0000133A 0D0A                    	db	0Dh,0Ah
 50204 0000133C 413230204861726477-     	db	'A20 Hardware Error',0Dh,0Ah,'$'
 50204 00001345 617265204572726F72-
 50204 0000134E 0D0A24             
 50205                                  
 50206                                  ;----------------------------------------------------------------------------
 50207                                  ; 17/01/2024 - Note: COUNTRY_CDPG must be at DOSDATA:122Ah (to 12B8h) addr
 50208                                  ; It is fixed at 122Ah in PCDOS 7.1 IBMDOS.COM and MSDOS 5.0-6.22 MSDOS.SYS					
 50209                                  ;----------------------------------------------------------------------------
 50210                                  
 50211                                  ;############################################################################
 50212                                  ;
 50213                                  ; ** HACK FOR DOS 4.0 REDIR **
 50214                                  ;
 50215                                  ; The dos 4.X redir requires that country_cdpg is at offset 0122ah. Any new
 50216                                  ; data variable that is to be added to DOSDATA must go in between Mark3
 50217                                  ; COUNTRY_CDPG if it can. 
 50218                                  ;
 50219                                  ; MARK3 SHOULD NOT BE > 122AH 
 50220                                  ;
 50221                                  ; As of 9/6/90, this area is FULL!
 50222                                  ;
 50223                                  ;############################################################################
 50224                                   
 50225                                  	;ORG	0122Ah
 50226                                  
 50227                                  ; DOSDATA:122Ah (MSDOS 6.21, MSDOS.SYS)
 50228                                  
 50229                                  ; 09/01/2024 - Retro DOS v5.0
 50230                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:122Ah
 50231                                  
 50232                                  ; 17/01/2024
 50233                                  ; MSDOS 5.0  MSDOS.SYS - DOSDATA:122Ah
 50234                                  ; MSDOS 6.22 MSDOS.SYS - DOSDATA:122Ah
 50235                                  
 50236                                  ; The following table is used for DOS 3.3
 50237                                  ;DOS country and code page information is defined here for DOS 3.3.
 50238                                  ;The initial value for ccDosCountry is 1 (USA).
 50239                                  ;The initial value for ccDosCodepage is 850.
 50240                                  
 50241                                  ; country and code page information
 50242                                  ; ---------------------------------------------------------------------------
 50243                                  COUNTRY_CDPG:	; label  byte
 50244 00001351 0000000000000000        	db   0,0,0,0,0,0,0,0		; reserved words
 50245 00001359 5C434F554E5452592E-     	db   '\COUNTRY.SYS',0		; path name of country.sys
 50245 00001362 53595300           
 50246                                  	;db   51 dup (?)
 50247 00001366 00<rep 33h>             	times 51 db 0
 50248                                  ; ------------------------------------------------<MSKK01>-------------------
 50249                                  ;ifdef	DBCS
 50250                                  ;  ifdef JAPAN
 50251                                  ;	dw   932			; system code page id (JAPAN)
 50252                                  ;  endif
 50253                                  ;  ifdef TAIWAN
 50254                                  ;	dw   938			; system code page id (TAIWAN)
 50255                                  ;  endif
 50256                                  ;  ifdef KOREA
 50257                                  ;	dw   934			; system code page id (KOREA IBM)
 50258                                  ;  endif
 50259                                  ;else
 50260 00001399 B501                    	dw   437			; system code page id
 50261                                  ;endif
 50262                                  ; ------------------------------------------------<MSKK01>-------------------
 50263 0000139B 0600                    	dw   6				; number of entries
 50264                                  COUNTRY_CDPG_76: ; COUNTRY_CDPG + 76 
 50265 0000139D 02                      	db   SetUcase  ; 2		; Ucase type
 50266 0000139E [010B]                  	dw   UCASE_TAB			;pointer to upper case table
 50267 000013A0 0000                    	dw   0				; segment of poiter
 50268 000013A2 04                      	db   SetUcaseFile  ; 4		; Ucase file char type
 50269 000013A3 [830B]                  	dw   FILE_UCASE_TAB 		;pointer to file upper case table
 50270 000013A5 0000                    	dw   0				; segment of poiter
 50271 000013A7 05                      	db   SetFileList ; 5		; valid file chars type
 50272 000013A8 [050C]                  	dw   FILE_CHAR_TAB 		;pointer to valid file char tab
 50273 000013AA 0000                    	dw   0				; segment of poiter
 50274 000013AC 06                      	db   SetCollate	; 6		; collate type
 50275 000013AD [350C]                  	dw   COLLATE_TAB		;pointer to collate table
 50276 000013AF 0000                    	dw   0				; segment of poiter
 50277 000013B1 07                      	db   SetDBCS	; 7		;AN000; DBCS Ev			2/12/KK
 50278 000013B2 [370D]                  	dw   DBCS_TAB			;AN000;pointer to DBCS Ev table	2/12/KK
 50279 000013B4 0000                    	dw   0				;AN000; segment of pointer	2/12/KK
 50280 000013B6 01                      	db   SetCountryInfo  ; 1	; country info type
 50281 000013B7 2600                    	dw   NEW_COUNTRY_SIZE		; extended country info size
 50282                                  ; ------------------------------------------------<MSKK01>-------------------
 50283                                  ;ifdef	DBCS
 50284                                  ;	...... 
 50285                                  ;else
 50286                                  	; 09/01/2024 - Retro DOS v5.0
 50287                                  	; PCDOS 7.1 IBMDOS.COM - DOSDATA:1292h
 50288                                  _COUNTRY_ID:
 50289 000013B9 0100                    	dw   1				; USA country id
 50290 000013BB B501                    	dw   437			; USA system code page id
 50291                                  COUNTRY_CDPG_108: ; COUNTRY_CDPG + 108	
 50292 000013BD 0000                    	dw   0 				; date format
 50293 000013BF 2400000000              	db   '$',0,0,0,0		; currency symbol
 50294 000013C4 2C00                    	db   ',',0			; thousand separator
 50295 000013C6 2E00                    	db   '.',0			; decimal separator
 50296 000013C8 2D00                    	db   '-',0			; date separator
 50297 000013CA 3A00                    	db   ':',0			; time separator
 50298 000013CC 00                      	db   0				; currency format flag
 50299 000013CD 02                      	db   2				; # of digits in currency
 50300 000013CE 00                      	db   0 				; time format
 50301 000013CF [490D]                  	dw   MAP_CASE			; mono case routine entry point
 50302 000013D1 0000                    	dw   0				; segment of entry point
 50303 000013D3 2C00                    	db   ',',0			; data list separator
 50304 000013D5 000000000000000000-     	dw   0,0,0,0,0			; reserved
 50304 000013DE 00                 
 50305                                  ;endif
 50306                                  ; ------------------------------------------------<MSKK01>-------------------
 50307                                  
 50308                                  ;----------------------------------------------------------------------------
 50309                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 50310                                  
 50311                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:12B8h
 50312                                  
 50313                                  INDOS_FLAG:
 50314 000013DF 00                      	db 0		; duplicated INDOS flag, what for ? 
 50315                                  			; (PCDOS 7.1 kernel CODE always updates it together
 50316                                  			; with 'INDOS' flag !?)
 50317                                  ; 09/01/2024
 50318                                  DEVIO_IN_PROGRESS:
 50319 000013E0 00                      	db 0
 50320                                  
 50321                                  ; 09/01/2024
 50322                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:12BAh
 50323                                  ; ----------
 50324                                  ; INTERNATIONALIZATION INFORMATION
 50325                                  ;	 for Get/Set Extended Country Info functions
 50326                                  
 50327 000013E1 454E5500                _ENU:	db 'ENU',0
 50328 000013E5 55534100                _USA:	db 'USA',0
 50329 000013E9 5553                    _US:	db 'US'
 50330 000013EB 0100                    	dw 1
 50331 000013ED 0200                    	dw 2
 50332 000013EF 0000                    	dw 0
 50333 000013F1 414D00                  _AM:	db 'AM',0
 50334 000013F4 504D00                  _PM:	db 'PM',0
 50335                                  _MMDDYY:
 50336 000013F7 4D2F642F7979202020-     	db 'M/d/yy     dddd,MMMMdd,yyyy         '
 50336 00001400 2020646464642C4D4D-
 50336 00001409 4D4D64642C79797979-
 50336 00001412 202020202020202020 
 50337 0000141B 00                      	db 0
 50338 0000141C 00                      	db 0
 50339 0000141D 0000                    	dw 0
 50340                                  
 50341                                  ; 09/01/2024
 50342                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:12F8h
 50343                                  
 50344                                  VxDpath:
 50345 0000141F 633A5C77696E613230-     	db 'c:\wina20.386',0
 50345 00001428 2E33383600         
 50346 0000142D 0000                    	dw 0
 50347                                  
 50348                                  ; 09/01/2024
 50349                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:1308h
 50350                                  
 50351                                  drive_flags:
 50352 0000142F 00<rep 1Ah>             	times 26 db 0
 50353                                  		 
 50354 00001449 01                              db 1
 50355                                  BiosComBlockPtr:
 50356 0000144A 0000<rep 2h>            	times 2 dw 0
 50357 0000144E 00<rep 5h>              	times 5 db 0
 50358 00001453 0400                    	dw 4
 50359 00001455 [DF13]                  	dw INDOS_FLAG
 50360 00001457 [2F14]                  	dw drive_flags
 50361 00001459 [5D14]                  	dw NLS_YES	; "YN"
 50362 0000145B [6114]                  	dw unknown_zero_dd
 50363                                  NLS_YES:
 50364 0000145D 59                      	db 'Y'
 50365 0000145E 4E                      NLS_NO:	db 'N'
 50366                                  NLS_yes2:
 50367 0000145F 79                      	db 'y'
 50368                                  NLS_no2:
 50369 00001460 6E                      	db 'n'
 50370                                  
 50371                                  unknown_zero_dd:
 50372 00001461 00000000                	dd 0
 50373                                  
 50374                                  ; ---------------------------------------------------------------------------
 50375                                  
 50376                                  ; 27/04/2019 - Retro DOS v4.0
 50377                                  
 50378                                  ;include msdos.cl2			; XMMERRMSG
 50379                                  
 50380                                  ; DOSDATA:12B8h (MSDOS 6.21, MSDOS.SYS)
 50381                                  
 50382                                  ;XMMERRMSG:
 50383                                  ;	db	0Dh,0Ah
 50384                                  ;	db	'A20 Hardware Error',0Dh,0Ah,'$'
 50385                                  
 50386                                  ; DOSDATA ends
 50387                                  
 50388                                  ; 05/11/2022
 50389                                  ;----------------------------------------------------------------------------
 50390                                  ; End of MSDOS 5.0 MSDOS.SYS /// Retro DOS v4.0 (2022) - 05/11/2022
 50391                                  ;----------------------------------------------------------------------------
 50392                                  
 50393                                  ; 28/12/2022 - Retro DOS v4.1
 50394                                  ; (windows 3.1 and Rational Extender patches are removed/disabled)
 50395                                  ; (Windows 3.1 does not use the patches below if DOS version is MSDOS 5.0)
 50396                                  ;----------------------------------------------------------------------------
 50397                                  %if 0
 50398                                  
 50399                                  ;----------------------------------------------------------------------------
 50400                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 50401                                  
 50402                                  ;============================================================================
 50403                                  ; WPATCH.INC (MSDOS 6.0, 1991)  ;;; Windows 3.1 patches ;;;
 50404                                  ;============================================================================
 50405                                  ; 27/04/2019 - Retro DOS 4.0
 50406                                  
 50407                                  ;DOSDATA Segment
 50408                                  
 50409                                  ; DOSDATA:12CFh (MSDOS 6.21, MSDOS.SYS)
 50410                                  
 50411                                  ; Retro DOS v5.0
 50412                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:1180h	
 50413                                  
 50414                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 50415                                  ; DOSDATA:12CFh (MSDOS 5.0, MSDOS.SYS)
 50416                                  
 50417                                  ; first and second DOS patches
 50418                                  ;	Non-console device read/write (system calls 3Fh and 40h)
 50419                                  ;
 50420                                  ; Code in disk.asm, 2 locations, one for read, one for write
 50421                                  ;	DVRDLP:
 50422                                  ;	DVWRTLP:
 50423                                  ;
 50424                                  ;
 50425                                  ; 036h	lds	si,SS:[????]				  ; ThisSFT
 50426                                  ;	lds	si,si+7 				  ; sf_devptr
 50427                                  ; 0E8h	call	????		<- "simulate" int28 event ; DSKSTATCHK
 50428                                  
 50429                                  DOSP1_ID:	db	036h,0C5h,036h
 50430                                  DOSP1_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 50431                                  DOSP1_ID_LEN	equ	$-DOSP1_ID
 50432                                  
 50433                                  		db	90h, 90h
 50434                                  
 50435                                  DOSP12_ID:	db	036h,0C5h,036h
 50436                                  DOSP12_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 50437                                  DOSP12_ID_LEN	equ	$-DOSP1_ID
 50438                                  
 50439                                  ; DOSDATA:12E3h
 50440                                  
 50441                                  ; Third/Fourth DOS patch - System call 3Fh (Read) from console
 50442                                  ;
 50443                                  ; Code in disk.asm, 1 location
 50444                                  ;	GETBUF:
 50445                                  ;
 50446                                  ; 051h	push	cx	<- begin special int28 mode
 50447                                  ;	push	es
 50448                                  ;	push	di
 50449                                  ;	mov	dx,???? ; offset dosgroup:CONBUF
 50450                                  ;	call	????	; $STD_CON_STRING_INPUT
 50451                                  ;	pop	di
 50452                                  ;	pop	es
 50453                                  ; 059h	pop	cx	<- end special int28 mode
 50454                                  
 50455                                  DOSP3_ID:	db	051h,006h,057h,0BAh
 50456                                  DOSP3_CONBUF:	db	029h,002h,0E8h
 50457                                  DOSP3_ID_LEN	equ	$-DOSP3_ID
 50458                                  		db	09Ah,0E3h,05Fh,007h	; ???? , pop di, pop es
 50459                                  DOSP4_ID:	db	059h			; pop cx
 50460                                  DOSP4_ID_OFF	equ	(DOSP4_ID - DOSP3_ID)
 50461                                  	
 50462                                  ; DOSDATA:12EFh
 50463                                  
 50464                                  ; Fifth DOS patch - System call 40h (Write) to console
 50465                                  ;
 50466                                  ; Code in disk.asm, 1 location
 50467                                  ;
 50468                                  ;		push	cx
 50469                                  ;      WRCONLP: lodsb
 50470                                  ;		cmp	al,1Ah
 50471                                  ;		jz	????
 50472                                  ;		call	????	<- "simulate" int28 event
 50473                                  ;		loop	WRCONLP
 50474                                  ;      CONEOF:	pop	ax
 50475                                  
 50476                                  DOSP5_ID:	db	051h			; push cx
 50477                                  		db	0ACh,03Ch,01Ah,074h,005h
 50478                                  		db	0E8h			; call
 50479                                  DOSP5_ID_LEN	equ	$-DOSP5_ID
 50480                                  
 50481                                  ; DOSDATA:12F6h
 50482                                  
 50483                                  ; Seventh DOS patch - System call entry, patch USER_ID with VMid for share
 50484                                  ;
 50485                                  ; Code in disp.asm, 1 location
 50486                                  ;
 50487                                  ;
 50488                                  ;	mov [SaveDS],ds
 50489                                  ;	mov [SaveBX],bx
 50490                                  ;	mov bx,cs
 50491                                  ;	mov ds,bx
 50492                                  ;	inc [indos]
 50493                                  ;	xor ax,ax
 50494                                  ;	mov [USER_ID],AX	<- Patch to set USER_ID to VMID
 50495                                  
 50496                                  DOSP7_ID:	db	02Eh,08Ch,01Eh
 50497                                  DOSP7_SAVEDS:	db	07Eh,05h		; mov [SaveDS],ds
 50498                                  		db	02Eh,089h,01Eh
 50499                                  DOSP7_SAVEBX:	db	07Ch,05h		; mov [SaveBX],bx
 50500                                  		db	08Ch,0CBh		; mov bx,cs
 50501                                  		db	08Eh,0DBh		; mov ds,bx
 50502                                  		db	0FEh,006h
 50503                                  DOSP7_INDOS:	db	0CFh,002h		; inc [indos]
 50504                                  		db	033h,0C0h		; xor ax,ax
 50505                                  DOSP7_ID_LEN	equ	$-DOSP7_ID
 50506                                  
 50507                                  ; DOSDATA:130Ah
 50508                                  
 50509                                  ; Eighth DOS patch - OWNER check in handle calls. For share, need to NOP test
 50510                                  ;
 50511                                  ; Code in handle.asm, 1 location in routine CheckOwner
 50512                                  ;
 50513                                  ;
 50514                                  ;
 50515                                  ;	push	ax
 50516                                  ;	mov	ax,ss:[USER_ID]     <- patch to XOR AX,AX to set zero
 50517                                  ;	cmp	ax,es:[di.sf_UID]   <- NOP
 50518                                  ;	pop	ax
 50519                                  ;	jz	????
 50520                                  
 50521                                  DOSP8_ID:	db	050h			; push ax
 50522                                  		db	036h,0A1h
 50523                                  DOSP8_USER_ID:	db	0EAh,002h		; mov  ax,ss:[USER_ID]
 50524                                  		db	026h,03Bh,045h		; cmp  ax,es:[di+2F]
 50525                                  DOSP8_ID_LEN	equ	$-DOSP8_ID
 50526                                  		db	02Fh,058h		; pop  ax
 50527                                  
 50528                                  ; DOSDATA:1314h
 50529                                  
 50530                                  ; 10th, 11th, 12th DOS patch - System call 3Fh (Read) in raw mode
 50531                                  ;
 50532                                  ;   Take RAW read to STDIN SFT and turn it into a polling loop doing
 50533                                  ;   a yeild when a character is not ready to be read.
 50534                                  ;
 50535                                  ; Code in disk.asm, 3 locations
 50536                                  ;
 50537                                  ;   DVRDRAW:
 50538                                  ;	    PUSH    ES
 50539                                  ;	    POP     DS
 50540                                  ;   ReadRawRetry:				<- Patch 10
 50541                                  ;	    MOV     BX,DI
 50542                                  ;	    XOR     AX,AX			<- Reenter #2
 50543                                  ;	    MOV     DX,AX
 50544                                  ;	    call    SETREAD
 50545                                  ;	    PUSH    DS				<- Reenter #1
 50546                                  ;	    LDS     SI,[THISSFT]
 50547                                  ;	    call    DEVIOCALL
 50548                                  ;	    MOV     DX,DI
 50549                                  ;	    MOV     AH,86H
 50550                                  ;	    MOV     DI,[DEVCALL.REQSTAT]
 50551                                  ;	    TEST    DI,STERR
 50552                                  ;	    JZ	    CRDROK
 50553                                  ;	    call    CHARHARD
 50554                                  ;	    MOV     DI,DX
 50555                                  ;	    OR	    AL,AL
 50556                                  ;	    JZ	    CRDROK
 50557                                  ;	    CMP     AL,3
 50558                                  ;	    JZ	    CRDFERR
 50559                                  ;	    POP     DS
 50560                                  ;	    JMP     ReadRawRetry
 50561                                  ;
 50562                                  ;   CRDFERR:
 50563                                  ;	    POP     DI				<- Patch 11
 50564                                  ;   DEVIOFERR:
 50565                                  ;	    LES     DI,[THISSFT]
 50566                                  ;	    jmp     SET_ACC_ERR_DS
 50567                                  ;
 50568                                  ;   CRDROK:
 50569                                  ;	    POP     DI				<- Patch 12
 50570                                  ;	    MOV     DI,DX
 50571                                  ;	    ADD     DI,[CALLSCNT]
 50572                                  ;	    JMP     SHORT ENDRDDEVJ3
 50573                                  
 50574                                  DOSP10_ID:		db	006H,01FH
 50575                                  DOSP10_LOC_OFFSET	equ	$-DOSP10_ID
 50576                                  DOSP10_LOC:		db	08BH,0DFH
 50577                                  DOSP10_REENT2_OFFSET	equ	$-DOSP10_LOC
 50578                                  			db	033H,0C0H,08BH,0D0H,0E8H
 50579                                  DOSP10_ID_LEN		equ	$-DOSP10_ID
 50580                                  			db	0DFH,00EH
 50581                                  DOSP10_REENT1_OFFSET	equ	$-DOSP10_LOC
 50582                                  			db	01EH,036H,0C5H,036H,036H,005H,0E8H,0AFH,00EH
 50583                                  			db	08BH,0D7H,0B4H,086H,036H,08BH,03EH
 50584                                  DOSP10_PACKVAL_OFFSET	equ	$-DOSP10_ID
 50585                                  			db	009H,003H
 50586                                  			db	0F7H,0C7H,000H,080H,074H,019H,0E8H,047H,017H
 50587                                  			db	08BH,0FAH,00AH,0C0H,074H,010H,03CH,003H,074H,003H
 50588                                  			db	01FH,0EBH,0CFH
 50589                                  DOSP11_LOC_OFFSET	equ	$-DOSP10_ID
 50590                                  			db	05FH
 50591                                  DOSP11_REENT_OFFSET	equ	$-DOSP10_LOC
 50592                                  			db	036H,0C4H,03EH,036H,005H,0E9H,0A1H,004H
 50593                                  
 50594                                  DOSP12_LOC_OFFSET	equ	$-DOSP10_ID
 50595                                  			db	05FH,08BH,0FAH
 50596                                  ; DOSDATA:1353h
 50597                                  
 50598                                  ; 13th DOS patch - Actually a SYSINIT patch. Patches the stack fault code
 50599                                  ;		which prints the fatal stack fault error on DOS >= 3.20.
 50600                                  ;
 50601                                  ;	    Sets focus to current VM so user can see fatal message.
 50602                                  ;
 50603                                  ;
 50604                                  ;	l0: lodsb		<- Setfocus here
 50605                                  ;	    cmp al, '$'
 50606                                  ;	    je l1
 50607                                  ;	    mov bl, 7
 50608                                  ;	    mov ah, 0Eh
 50609                                  ;	    int 10h
 50610                                  ;	    jmp l0
 50611                                  ;	l1: jmp $
 50612                                  
 50613                                  DOSP13_ID:	db	0ACh			; l0: lodsb
 50614                                  		db	03Ch,024h		;     cmp al, '$'
 50615                                  		db	074h,008h		;     je l1
 50616                                  		db	0B3h,007h		;     mov bl, 7
 50617                                  		db	0B4h,00Eh		;     mov ah, 0Eh
 50618                                  		db	0CDh,010h		;     int 10h
 50619                                  		db	0EBh,0F3h		;     jmp l0
 50620                                  		db	0EBh,0FEh		; l1: jmp $
 50621                                  DOSP13_ID_LEN	equ	$-DOSP13_ID
 50622                                  
 50623                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 50624                                  ; DOSDATA:1362h (MSDOS 5.0 MSDOS.SYS)
 50625                                  
 50626                                  ; 06/12/2022
 50627                                  ;DOSDATASIZE	equ  $ - DOSDATASTART ; 4962 bytes (1362h)
 50628                                  
 50629                                  ; DOSDATA ends
 50630                                  
 50631                                  ; 05/01/2024
 50632                                  %endif	; 05/11/2022
 50633                                  
 50634                                  ;============================================================================
 50635                                  ; MPATCH.ASM (MSDOS 6.0, 1993)
 50636                                  ;============================================================================
 50637                                  ; 27/04/2019 - Retro DOS 4.0
 50638                                  
 50639                                  ;mpatch.asm -- holds data patch location for callouts 
 50640                                  ; -- allocate cluster in rom.asm
 50641                                  ;
 50642                                  ; This area is pointed to by OffsetMagicPatch[609h] in fixed DOS data.
 50643                                  ; Currently, this location is used only by magicdrv.sys's patch to
 50644                                  ; cluster allocation, however it can be expanded to be used by other
 50645                                  ; patches. This is important since we have an easy-access pointer to
 50646                                  ; this location in OffsetMagicPatch. Magicdrv.sys is guaranteed to
 50647                                  ; only patch out a far call/retf, so any space after that could be
 50648                                  ; used as a patch by using OffsetMagicPatch+6. See rom.asm on how
 50649                                  ; to call out here.
 50650                                  ;
 50651                                  ; Currently, we allocate only the minimum space required for the 6
 50652                                  ; byte magicdrv patch, so if you change the dos data, you may want
 50653                                  ; to reserve space here if your new data will be position dependent
 50654                                  ; and would prohibit growing of this table.
 50655                                  ;       
 50656                                  ;history	-	created 8-7-92 by scottq
 50657                                  ;		-	added Rational386PatchPtr 2-1-93 by jimmat
 50658                                  ;
 50659                                  ;Exported Functions
 50660                                  ;==================
 50661                                  ;MagicPatch     -       callout patched by magidrv.sys for cluster allocations
 50662                                  
 50663                                  ; DosData Segment
 50664                                  
 50665                                  ; DOSDATA:1362h (MSDOS 6.21, MSDOS.SYS)
 50666                                  
 50667                                  ; ---------------------------------------------------------------------------
 50668                                  
 50669                                  ; Rational386PatchPtr points to either a RET instruction (80286 or less) or
 50670                                  ; a routine to fix buggy versions of the Rational DOS Extender (80386 or
 50671                                  ; greater). Added to this file because it needed to be somewhere and is
 50672                                  ; 'patch' related.
 50673                                  
 50674                                  Rational386PatchPtr:
 50675 00001465 0000                    	dw	0	; points to patch routine or RET instr.
 50676                                  ; ---------------------------------------------------------------------------
 50677                                  
 50678                                  MagicPatch:
 50679                                  ;MagicPatch proc far
 50680 00001467 CB                              retf            ;default is to just return to allocate
 50681 00001468 90                              nop             ;however, this code will be patched
 50682 00001469 90                              nop             ;by magicdrv.sys to
 50683 0000146A 90                              nop             ; call far ?:?     
 50684 0000146B 90                              nop             ; retf or perhaps just jmp far
 50685 0000146C 90                              nop             ;retf/nop take one byte, so we need six instructions
 50686                                                          ;for 6 byte patch
 50687                                  ;MagicPatch endp
 50688                                  
 50689                                  ; ---------------------------------------------------------------------------
 50690                                  
 50691                                  ;DosData Ends
 50692                                  
 50693                                  ; DOSDATA:136Ah
 50694                                  
 50695                                  ;----------------------------------------------------------------------------
 50696                                  
 50697                                  ;DOSDATALAST SEGMENT
 50698                                  
 50699                                  ; 29/04/2019 - Retro DOS v4.0
 50700                                  
 50701                                  ;----------------------------------------------------------------------------
 50702                                  ; 25/05/2019 - Retro DOS v4.0 Modification (paragraph alignment)
 50703                                  
 50704                                  ;db 0,1,12,64,19,0 ; ! Magic numbers !
 50705                                  
 50706                                  ;align 16
 50707                                  
 50708                                  ; !!! DOSDATA:1370h ; Retro DOS v4.0 only!
 50709                                  
 50710                                  ;----------------------------------------------------------------------------
 50711                                  
 50712                                  ; 05/01/2024
 50713                                  ;%endif	; 05/11/2022
 50714                                  
 50715                                  ; 05/12/2022
 50716                                  ;MSDAT001E:	; label byte
 50717                                  
 50718                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 50719                                  DOSDATAEND equ $
 50720                                  DOSDATASIZE equ DOSDATAEND - DOSDATASTART ; = 4962 for MSDOS 5.0 MSDOS.SYS
 50721                                  MSDAT001E equ DOSDATAEND - DOSDATASTART
 50722                                  
 50723                                  ;DOSDATALAST ENDS
 50724                                  
 50725                                  ; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 5.0 KERNEL via NASM)
 50726                                  ; DECEMBER 2022, ISTANBUL - TURKIYE.
 50727                                  ;============================================================================
 50728                                  ;	END
 50729                                  ;============================================================================
 50730                                  ; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 6.21 KERNEL via NASM)
 50731                                  ; -----------------------------
 50732                                  ; MAY 2019, ISTANBUL - TURKIYE.
