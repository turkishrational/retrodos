seg000:0000 ;
seg000:0000 ; +-------------------------------------------------------------------------+
seg000:0000 ; |	  This file has	been generated by The Interactive Disassembler (IDA)	|
seg000:0000 ; |		  Copyright (c)	2013 Hex-Rays, <support@hex-rays.com>		|
seg000:0000 ; |			     License info: 48-325F-7034-FF			|
seg000:0000 ; |			    Rico Baumgart, personal license			|
seg000:0000 ; +-------------------------------------------------------------------------+
seg000:0000 ;
seg000:0000 ; Input MD5	  : 4ED87A7F53B3F4492BBE2E0E72ABE4EF
seg000:0000 ; Input CRC32 : BD494D2D
seg000:0000
seg000:0000 ; File Name	  : C:\WinMe\jo.sys
seg000:0000 ; Format	  : MS-DOS SYS-file (perhaps device driver)
seg000:0000 ; Base Address: 0h Range: 0h-800h Loaded length: 800h
seg000:0000
seg000:0000		    .686p
seg000:0000		    .mmx
seg000:0000		    .model small
seg000:0000
seg000:0000 ; ===========================================================================
seg000:0000
seg000:0000 ; Segment type: Pure code
seg000:0000 seg000	    segment byte public	'CODE' use16
seg000:0000		    assume cs:seg000
seg000:0000		    assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:0000 unk_0	    db	4Dh ; M
seg000:0001		    db	5Ah ; Z
seg000:0002		    dw 0
seg000:0004		    dw 0		    ; block device
seg000:0006		    dw 0
seg000:0008		    dw 0
seg000:000A word_A	    dw 0		    ; May be device number
seg000:000C		    dw 0
seg000:000E		    dw 0
seg000:0010 MBR		    dd 7C00h		    ; DATA XREF: hard_disk_boot+2Ar
seg000:0010					    ; cdrom_fd_boot+18r
seg000:0014 word_14	    dw 0
seg000:0016		    dw 0FFFFh
seg000:0018 menu_header	    dw offset menu_row_1    ; DATA XREF: show_menu+3o
seg000:001A		    dw 0		    ; row 0, col 0
seg000:001C		    db 0
seg000:001D		    dw 40
seg000:001F start_of_string db 'Microsoft Windows ME CD-ROM Startup Menu'
seg000:0047 menu_row_1	    dw offset menu_row_2    ; DATA XREF: seg000:menu_headero
seg000:0049		    dw 100h		    ; row 1, col 0
seg000:004B		    db 0
seg000:004C		    db 40
seg000:004D		    db 0
seg000:004E menu_line	    db 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í'
seg000:004E		    db 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í'
seg000:004E		    db 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í'
seg000:0076 menu_row_2	    dw offset menu_row_3    ; DATA XREF: seg000:menu_row_1o
seg000:0076					    ; seg000:025Bo ...
seg000:0078		    dw 300h		    ; row 3, col 0
seg000:007A		    db 0
seg000:007B		    dw 23		    ; string length
seg000:007D menu_option_1   db '1.  Boot from Hard Disk'
seg000:0094 menu_row_3	    dw offset menu_row_4    ; DATA XREF: seg000:menu_row_2o
seg000:0094					    ; seg000:0263o ...
seg000:0096		    dw 400h		    ; row 4, col 0
seg000:0098		    db 0		    ; mode 0
seg000:0099		    dw 20
seg000:009B menu_option_2   db '2.  Boot from CD-ROM'
seg000:00AF menu_row_4	    dw 0		    ; DATA XREF: seg000:menu_row_3o
seg000:00AF					    ; end of menu rows
seg000:00B1		    dw 600h		    ; row 6, col 0
seg000:00B3		    db 1		    ; mode 1
seg000:00B4		    dw 19
seg000:00B6		    db 'Enter your choice: '
seg000:00C9 timer_text	    dw 0		    ; DATA XREF: wait_for_keypress+12o
seg000:00C9					    ; wait_for_keypress+61o
seg000:00CB		    dw 619h		    ; row 6, col 25
seg000:00CD		    db 0
seg000:00CE		    dw 18
seg000:00D0		    db 'Time remaining: __'
seg000:00E2 timer_ticks	    dw 2 dup(0)		    ; DATA XREF: wait_for_keypress:read_timer_1r
seg000:00E2					    ; wait_for_keypress+2Dw ...
seg000:00E6 timer_over	    db 0		    ; DATA XREF: seg000:m_getc_okw
seg000:00E6					    ; wait_for_keypressr ...
seg000:00E7 timer_divisor   db 18		    ; DATA XREF: wait_for_keypress+49r
seg000:00E7					    ; column 18
seg000:00E8 divisor_10	    db 10		    ; DATA XREF: wait_for_keypress+59r
seg000:00E8					    ; row 10
seg000:00E9 structure_buf   dw 19		    ; DATA XREF: hard_disk_boot+Ao
seg000:00E9					    ; 19 bytes empty structure buffer
seg000:00E9					    ; for INT 13h ah=4B00h
seg000:00EB		    db 17 dup(0)
seg000:00FC selection	    dw '1'                  ; DATA XREF: seg000:0221r
seg000:00FC					    ; seg000:0230r ...
seg000:00FC					    ; default choice is	1
seg000:00FE		    db 258 dup(0)
seg000:0200 ; ---------------------------------------------------------------------------
seg000:0200
seg000:0200 START$:
seg000:0200		    cli
seg000:0201		    mov	    ax,	0
seg000:0204		    mov	    ss,	ax
seg000:0206		    assume ss:seg000
seg000:0206		    mov	    sp,	7C00h
seg000:0209		    mov	    ax,	cs
seg000:020B		    mov	    es,	ax
seg000:020D		    assume es:seg000
seg000:020D		    mov	    ds,	ax
seg000:020F		    assume ds:seg000
seg000:020F		    cld
seg000:0210		    sti
seg000:0211		    call    show_menu
seg000:0214		    call    flush_keyb_buf
seg000:0217
seg000:0217 m_getc:				    ; CODE XREF: seg000:021Fj
seg000:0217					    ; seg000:026Bj ...
seg000:0217		    call    get_char
seg000:021A		    jb	    short m_getc_ok
seg000:021C		    call    wait_for_keypress
seg000:021F		    jnb	    short m_getc
seg000:0221		    mov	    ax,	cs:selection ; character (user has pressed this	key)
seg000:0225
seg000:0225 m_getc_ok:				    ; CODE XREF: seg000:021Aj
seg000:0225		    or	    cs:timer_over, 1
seg000:022B		    cmp	    ax,	0Dh	    ; CR
seg000:022E		    jnz	    short chk_choice_1
seg000:0230		    mov	    ax,	cs:selection
seg000:0234
seg000:0234 chk_choice_1:			    ; CODE XREF: seg000:022Ej
seg000:0234		    cmp	    ax,	31h ; '1'   ; Option 1
seg000:0237		    jnz	    short chk_choice_2
seg000:0239		    call    set_vmode
seg000:023C		    call    hard_disk_boot
seg000:023F		    jmp	    int19h
seg000:0242 ; ---------------------------------------------------------------------------
seg000:0242
seg000:0242 chk_choice_2:			    ; CODE XREF: seg000:0237j
seg000:0242		    cmp	    ax,	32h ; '2'   ; Option 2
seg000:0245		    jnz	    short chk_choice_up
seg000:0247		    call    set_vmode
seg000:024A		    call    cdrom_fd_boot
seg000:024D		    jmp	    short int19h
seg000:024F ; ---------------------------------------------------------------------------
seg000:024F
seg000:024F chk_choice_up:			    ; CODE XREF: seg000:0245j
seg000:024F		    cmp	    ax,	4800h	    ; up arrow
seg000:0252		    jnz	    short chk_choice_down
seg000:0254		    mov	    cs:selection, '1' ; user's menu choice is '1'
seg000:0254					    ; (but he/she has not ENTERed it yet)
seg000:025B		    mov	    si,	offset menu_row_2 ; selected (focused)
seg000:025E		    mov	    al,	70h	    ; character	attribute (highlighted)
seg000:0260		    call    display_row
seg000:0263		    mov	    si,	offset menu_row_3
seg000:0266		    mov	    al,	7	    ; character	attribute (normal)
seg000:0268		    call    display_row
seg000:026B		    jmp	    short m_getc
seg000:026D ; ---------------------------------------------------------------------------
seg000:026D
seg000:026D chk_choice_down:			    ; CODE XREF: seg000:0252j
seg000:026D		    cmp	    ax,	5000h	    ; down arrow
seg000:0270		    jnz	    short chk_choice_getc
seg000:0272		    mov	    cs:selection, '2' ; user's menu choice is '2'
seg000:0272					    ; (but he/she has not ENTERed it yet)
seg000:0279		    mov	    si,	offset menu_row_3 ; selected (focused)
seg000:027C		    mov	    al,	70h	    ; character	attribute (highlighted)
seg000:027E		    call    display_row
seg000:0281		    mov	    si,	offset menu_row_2
seg000:0284		    mov	    al,	7	    ; character	attribute (normal)
seg000:0286		    call    display_row
seg000:0289		    jmp	    short m_getc
seg000:028B ; ---------------------------------------------------------------------------
seg000:028B
seg000:028B chk_choice_getc:			    ; CODE XREF: seg000:0270j
seg000:028B		    jmp	    short m_getc
seg000:028D ; ---------------------------------------------------------------------------
seg000:028D
seg000:028D int19h:				    ; CODE XREF: seg000:023Fj
seg000:028D					    ; seg000:024Dj ...
seg000:028D		    int	    19h		    ; DISK BOOT
seg000:028D					    ; causes reboot of disk system
seg000:028F		    jmp	    short int19h
seg000:0291
seg000:0291 ; =============== S	U B R O	U T I N	E =======================================
seg000:0291
seg000:0291
seg000:0291 read_disk_sector_0 proc near	    ; CODE XREF: hard_disk_boot+1Ep
seg000:0291					    ; cdrom_fd_boot+2p
seg000:0291		    sub	    ax,	ax
seg000:0293		    mov	    es,	ax
seg000:0295		    mov	    bx,	7C00h
seg000:0298		    mov	    ax,	201h
seg000:029B		    mov	    cx,	1
seg000:029E		    mov	    dh,	0
seg000:02A0		    int	    13h		    ; DISK - READ SECTORS INTO MEMORY
seg000:02A0					    ; AL = number of sectors to	read, CH = track, CL = sector
seg000:02A0					    ; DH = head, DL = drive, ES:BX -> buffer to	fill
seg000:02A0					    ; Return: CF set on	error, AH = status, AL = number	of sectors read
seg000:02A2		    retn
seg000:02A2 read_disk_sector_0 endp
seg000:02A2
seg000:02A3
seg000:02A3 ; =============== S	U B R O	U T I N	E =======================================
seg000:02A3
seg000:02A3
seg000:02A3 hard_disk_boot  proc near		    ; CODE XREF: seg000:023Cp
seg000:02A3		    push    word ptr ss:0410h ;	ROMBIOS	DATA area,
seg000:02A3					    ; save equipment flags
seg000:02A8		    mov	    ax,	4B00h
seg000:02AB		    mov	    dl,	0	    ; terminate	drive A: emulation
seg000:02AD		    mov	    si,	offset structure_buf
seg000:02B0		    int	    13h		    ; DISK - Bootable CD-ROM - AL =TERMINATE DISK EMULATION
seg000:02B2		    pop	    word ptr ss:0410h ;	restore	equipment flags
seg000:02B7		    jnb	    short $+2
seg000:02B9
seg000:02B9 reset_hd:				    ; CODE XREF: hard_disk_boot+14j
seg000:02B9		    sub	    ax,	ax
seg000:02BB		    mov	    dl,	80h
seg000:02BD		    int	    13h		    ; DISK - RESET DISK	SYSTEM
seg000:02BD					    ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
seg000:02BF		    mov	    dl,	80h
seg000:02C1		    call    read_disk_sector_0
seg000:02C4		    jnb	    short jmp_to_mbr
seg000:02C6		    retn
seg000:02C7 ; ---------------------------------------------------------------------------
seg000:02C7
seg000:02C7 jmp_to_mbr:				    ; CODE XREF: hard_disk_boot+21j
seg000:02C7		    sub	    ax,	ax	    ; set ds and es to zero
seg000:02C9		    mov	    ds,	ax
seg000:02CB		    mov	    es,	ax
seg000:02CD		    jmp	    cs:MBR	    ; jump to master boot code
seg000:02CD hard_disk_boot  endp
seg000:02CD
seg000:02D2
seg000:02D2 ; =============== S	U B R O	U T I N	E =======================================
seg000:02D2
seg000:02D2
seg000:02D2 cdrom_fd_boot   proc near		    ; CODE XREF: seg000:024Ap
seg000:02D2		    mov	    dl,	0
seg000:02D4		    call    read_disk_sector_0
seg000:02D7		    jnb	    short read_sector_0_ok
seg000:02D9		    retn
seg000:02DA ; ---------------------------------------------------------------------------
seg000:02DA
seg000:02DA read_sector_0_ok:			    ; CODE XREF: cdrom_fd_boot+5j
seg000:02DA		    sub	    ax,	ax
seg000:02DC		    mov	    ds,	ax
seg000:02DE		    mov	    es,	ax
seg000:02E0		    mov	    si,	7C8Fh	    ; put 4 NOPs at BS offset 008Fh
seg000:02E0					    ; ('IO      SYS' name will be preserved by overwriting
seg000:02E0					    ;  'inc byte ptr ds:IO_SYS' code there) -otherwise, it would be
seg000:02E0					    ;  converted to 'JO      SYS' just as how we are here, in JO.SYS.)
seg000:02E3		    mov	    dword ptr [si], 90909090h ;	(overwrite JO.SYS loading code)
seg000:02EA		    jmp	    cs:MBR
seg000:02EA cdrom_fd_boot   endp
seg000:02EA
seg000:02EF
seg000:02EF ; =============== S	U B R O	U T I N	E =======================================
seg000:02EF
seg000:02EF
seg000:02EF set_vmode	    proc near		    ; CODE XREF: seg000:0239p
seg000:02EF					    ; seg000:0247p ...
seg000:02EF		    mov	    ax,	3
seg000:02F2		    int	    10h		    ; -	VIDEO -	SET VIDEO MODE
seg000:02F2					    ; AL = mode
seg000:02F4		    retn
seg000:02F4 set_vmode	    endp
seg000:02F4
seg000:02F5
seg000:02F5 ; =============== S	U B R O	U T I N	E =======================================
seg000:02F5
seg000:02F5
seg000:02F5 display_row	    proc near		    ; CODE XREF: seg000:0260p
seg000:02F5					    ; seg000:0268p ...
seg000:02F5		    movzx   di,	al
seg000:02F8		    mov	    ah,	3
seg000:02FA		    mov	    bh,	0
seg000:02FC		    int	    10h		    ; -	VIDEO -	READ CURSOR POSITION
seg000:02FC					    ; BH = page	number
seg000:02FC					    ; Return: DH,DL = row,column, CH = cursor start line, CL = cursor end line
seg000:02FE		    push    dx		    ; save cursor position
seg000:02FF		    push    word ptr [si+2]
seg000:0302		    mov	    cx,	40	    ; 40 colums
seg000:0305
seg000:0305 display_next_col:			    ; CODE XREF: display_row+2Fj
seg000:0305		    push    cx
seg000:0306		    mov	    ah,	2
seg000:0308		    mov	    bh,	0
seg000:030A		    mov	    dx,	[si+2]
seg000:030D		    int	    10h		    ; -	VIDEO -	SET CURSOR POSITION
seg000:030D					    ; DH,DL = row, column (0,0 = upper left)
seg000:030D					    ; BH = page	number
seg000:030F		    mov	    ah,	8
seg000:0311		    mov	    bh,	0
seg000:0313		    int	    10h		    ; -	VIDEO -	READ ATTRIBUTES/CHARACTER AT CURSOR POSITION
seg000:0313					    ; BH = display page
seg000:0313					    ; Return: AL = character
seg000:0313					    ; AH = attribute of	character (alpha modes)
seg000:0315		    mov	    ah,	9
seg000:0317		    mov	    bx,	di
seg000:0319		    mov	    bh,	0
seg000:031B		    mov	    cx,	1
seg000:031E		    int	    10h		    ; -	VIDEO -	WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION
seg000:031E					    ; AL = character, BH = display page
seg000:031E					    ; BL = attributes of character (alpha modes) or color (graphics modes)
seg000:031E					    ; CX = number of times to write character
seg000:0320		    inc	    word ptr [si+2] ; next column
seg000:0323		    pop	    cx
seg000:0324		    loop    display_next_col
seg000:0326		    pop	    word ptr [si+2]
seg000:0329		    mov	    ah,	2
seg000:032B		    mov	    bh,	0
seg000:032D		    pop	    dx		    ; restore cursor position
seg000:032E		    int	    10h		    ; -	VIDEO -	SET CURSOR POSITION
seg000:032E					    ; DH,DL = row, column (0,0 = upper left)
seg000:032E					    ; BH = page	number
seg000:0330		    retn
seg000:0330 display_row	    endp
seg000:0330
seg000:0331
seg000:0331 ; =============== S	U B R O	U T I N	E =======================================
seg000:0331
seg000:0331
seg000:0331 erase_timer_text proc near		    ; CODE XREF: wait_for_keypress+15p
seg000:0331		    mov	    ah,	3
seg000:0333		    mov	    bh,	0
seg000:0335		    int	    10h		    ; -	VIDEO -	READ CURSOR POSITION
seg000:0335					    ; BH = page	number
seg000:0335					    ; Return: DH,DL = row,column, CH = cursor start line, CL = cursor end line
seg000:0337		    push    dx
seg000:0338		    mov	    ah,	2
seg000:033A		    mov	    bh,	0
seg000:033C		    mov	    dx,	[si+2]
seg000:033F		    int	    10h		    ; -	VIDEO -	SET CURSOR POSITION
seg000:033F					    ; DH,DL = row, column (0,0 = upper left)
seg000:033F					    ; BH = page	number
seg000:0341		    mov	    ah,	0Ah
seg000:0343		    mov	    al,	20h ; ' '   ; blank / space (erase char)
seg000:0345		    mov	    bx,	7
seg000:0348		    mov	    cx,	[si+5]
seg000:034B		    int	    10h		    ; -	VIDEO -	WRITE CHARACTERS ONLY AT CURSOR	POSITION
seg000:034B					    ; AL = character, BH = display page	- alpha	mode
seg000:034B					    ; BL = color of character (graphics	mode, PCjr only)
seg000:034B					    ; CX = number of times to write character
seg000:034D		    mov	    ah,	2
seg000:034F		    mov	    bh,	0
seg000:0351		    pop	    dx
seg000:0352		    int	    10h		    ; -	VIDEO -	SET CURSOR POSITION
seg000:0352					    ; DH,DL = row, column (0,0 = upper left)
seg000:0352					    ; BH = page	number
seg000:0354		    retn
seg000:0354 erase_timer_text endp
seg000:0354
seg000:0355
seg000:0355 ; =============== S	U B R O	U T I N	E =======================================
seg000:0355
seg000:0355
seg000:0355 display_menu    proc near		    ; CODE XREF: display_menu+19j
seg000:0355					    ; wait_for_keypress+70p ...
seg000:0355		    or	    si,	si
seg000:0357		    jz	    short dm_ok
seg000:0359		    mov	    ah,	13h
seg000:035B		    mov	    al,	[si+4]
seg000:035E		    mov	    bx,	7
seg000:0361		    mov	    cx,	[si+5]	    ; string length (char count)
seg000:0364		    mov	    dx,	[si+2]	    ; cursor pos
seg000:0367		    lea	    bp,	[si+7]	    ; start_of_string
seg000:036A		    int	    10h		    ; -	VIDEO -	WRITE STRING (AT,XT286,PS,EGA,VGA)
seg000:036A					    ; AL = mode, BL = attribute	if AL bit 1 clear, BH =	display	page number
seg000:036A					    ; DH,DL = row,column of starting cursor position, CX = length of string
seg000:036A					    ; ES:BP -> start of	string
seg000:036C		    mov	    si,	[si]
seg000:036E		    jmp	    short display_menu
seg000:0370 ; ---------------------------------------------------------------------------
seg000:0370
seg000:0370 dm_ok:				    ; CODE XREF: display_menu+2j
seg000:0370		    retn
seg000:0370 display_menu    endp
seg000:0370
seg000:0371
seg000:0371 ; =============== S	U B R O	U T I N	E =======================================
seg000:0371
seg000:0371
seg000:0371 wait_for_keypress proc near		    ; CODE XREF: seg000:021Cp
seg000:0371		    test    cs:timer_over, 3
seg000:0377		    jz	    short read_timer_1
seg000:0379		    test    cs:timer_over, 2
seg000:037F		    jnz	    read_timer_3
seg000:0383		    mov	    si,	offset timer_text
seg000:0386		    call    erase_timer_text
seg000:0389		    or	    cs:timer_over, 2
seg000:038F		    jmp	    short read_timer_3
seg000:0391 ; ---------------------------------------------------------------------------
seg000:0391
seg000:0391 read_timer_1:			    ; CODE XREF: wait_for_keypress+6j
seg000:0391		    cmp	    dword ptr cs:timer_ticks, 0
seg000:0398		    jnz	    short read_timer_2
seg000:039A		    mov	    ah,	0
seg000:039C		    int	    1Ah		    ; CLOCK - GET TIME OF DAY
seg000:039C					    ; Return: CX:DX = clock count
seg000:039C					    ; AL = 00h if clock	was read or written (via AH=0,1) since the previous
seg000:039C					    ; midnight
seg000:039C					    ; Otherwise, AL > 0
seg000:039E		    mov	    cs:timer_ticks, dx
seg000:03A3		    mov	    cs:timer_ticks+2, cx
seg000:03A8
seg000:03A8 read_timer_2:			    ; CODE XREF: wait_for_keypress+27j
seg000:03A8		    mov	    ah,	0
seg000:03AA		    int	    1Ah		    ; CLOCK - GET TIME OF DAY
seg000:03AA					    ; Return: CX:DX = clock count
seg000:03AA					    ; AL = 00h if clock	was read or written (via AH=0,1) since the previous
seg000:03AA					    ; midnight
seg000:03AA					    ; Otherwise, AL > 0
seg000:03AC		    mov	    ax,	cx
seg000:03AE		    shl	    eax, 16	    ; high word
seg000:03B2		    mov	    ax,	dx
seg000:03B4		    sub	    eax, dword ptr cs:timer_ticks
seg000:03BA		    idiv    cs:timer_divisor ; result =	seconds
seg000:03BF		    sub	    al,	10	    ; al <= 10
seg000:03C1		    neg	    al		    ; -9 -> 9, -8 -> 8
seg000:03C3		    or	    al,	al	    ; 0	?
seg000:03C5		    jz	    short time_over
seg000:03C7		    movzx   ax,	al
seg000:03CA		    div	    cs:divisor_10
seg000:03CF		    or	    ax,	3030h
seg000:03D2		    mov	    si,	offset timer_text
seg000:03D5		    lea	    di,	[si+5]	    ; ofset "Time remaining: __" - 2
seg000:03D8		    add	    di,	[si+5]	    ; the end of "Time remaining: "
seg000:03DB		    cmp	    ax,	[di]	    ; same digits (numeric) ?
seg000:03DD		    mov	    [di], ax
seg000:03DF		    jz	    short read_timer_3 ; yes, don't display 'remain seconds' this time
seg000:03E1		    call    display_menu    ; no, display new numeric chars (and menu again) as	countdown
seg000:03E4		    mov	    ah,	13h	    ; display timer text and countdown value (numeric chars)
seg000:03E6		    mov	    al,	[si+4]
seg000:03E9		    mov	    bx,	7
seg000:03EC		    mov	    cx,	[si+5]
seg000:03EF		    mov	    dx,	[si+2]
seg000:03F2		    lea	    bp,	[si+7]
seg000:03F5		    int	    10h		    ; -	VIDEO -	WRITE STRING (AT,XT286,PS,EGA,VGA)
seg000:03F5					    ; AL = mode, BL = attribute	if AL bit 1 clear, BH =	display	page number
seg000:03F5					    ; DH,DL = row,column of starting cursor position, CX = length of string
seg000:03F5					    ; ES:BP -> start of	string
seg000:03F7
seg000:03F7 read_timer_3:			    ; CODE XREF: wait_for_keypress+Ej
seg000:03F7					    ; wait_for_keypress+1Ej ...
seg000:03F7		    clc
seg000:03F8		    retn
seg000:03F9 ; ---------------------------------------------------------------------------
seg000:03F9
seg000:03F9 time_over:				    ; CODE XREF: wait_for_keypress+54j
seg000:03F9		    stc
seg000:03FA		    retn
seg000:03FA wait_for_keypress endp
seg000:03FA
seg000:03FB
seg000:03FB ; =============== S	U B R O	U T I N	E =======================================
seg000:03FB
seg000:03FB
seg000:03FB show_menu	    proc near		    ; CODE XREF: seg000:0211p
seg000:03FB		    call    set_vmode	    ; set video	mode to	3 (80x25 text mode)
seg000:03FE		    mov	    si,	offset menu_header
seg000:0401		    call    display_menu
seg000:0404		    mov	    si,	offset menu_row_2
seg000:0407		    mov	    al,	70h
seg000:0409		    call    display_row
seg000:040C		    retn
seg000:040C show_menu	    endp
seg000:040C
seg000:040D
seg000:040D ; =============== S	U B R O	U T I N	E =======================================
seg000:040D
seg000:040D
seg000:040D flush_keyb_buf  proc near		    ; CODE XREF: seg000:0214p
seg000:040D					    ; flush_keyb_buf+Aj
seg000:040D		    mov	    ah,	1
seg000:040F		    int	    16h		    ; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
seg000:040F					    ; Return: ZF clear if character in buffer
seg000:040F					    ; AH = scan	code, AL = character
seg000:040F					    ; ZF set if	no character in	buffer
seg000:0411		    jz	    short flush_kbb_ok
seg000:0413		    mov	    ah,	0
seg000:0415		    int	    16h		    ; KEYBOARD - READ CHAR FROM	BUFFER,	WAIT IF	EMPTY
seg000:0415					    ; Return: AH = scan	code, AL = character
seg000:0417		    jmp	    short flush_keyb_buf
seg000:0419 ; ---------------------------------------------------------------------------
seg000:0419
seg000:0419 flush_kbb_ok:			    ; CODE XREF: flush_keyb_buf+4j
seg000:0419		    retn
seg000:0419 flush_keyb_buf  endp
seg000:0419
seg000:041A
seg000:041A ; =============== S	U B R O	U T I N	E =======================================
seg000:041A
seg000:041A
seg000:041A get_char	    proc near		    ; CODE XREF: seg000:m_getcp
seg000:041A		    mov	    ah,	1
seg000:041C		    int	    16h		    ; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
seg000:041C					    ; Return: ZF clear if character in buffer
seg000:041C					    ; AH = scan	code, AL = character
seg000:041C					    ; ZF set if	no character in	buffer
seg000:041E		    jnz	    short getchar
seg000:0420		    clc			    ; no key press
seg000:0421		    retn
seg000:0422 ; ---------------------------------------------------------------------------
seg000:0422
seg000:0422 getchar:				    ; CODE XREF: get_char+4j
seg000:0422		    mov	    ah,	0
seg000:0424		    int	    16h		    ; KEYBOARD - READ CHAR FROM	BUFFER,	WAIT IF	EMPTY
seg000:0424					    ; Return: AH = scan	code, AL = character
seg000:0426		    cmp	    ax,	4800h	    ; up (arrow) key
seg000:0429		    jz	    short getc_ok
seg000:042B		    cmp	    ax,	5000h	    ; down (arrow) key
seg000:042E		    jz	    short getc_ok
seg000:0430		    sub	    ah,	ah	    ; clear (zero) scan	code
seg000:0432
seg000:0432 getc_ok:				    ; CODE XREF: get_char+Fj
seg000:0432					    ; get_char+14j
seg000:0432		    stc			    ; a	key pressed
seg000:0433		    retn
seg000:0433 get_char	    endp
seg000:0433
seg000:0433 ; ---------------------------------------------------------------------------
seg000:0434		    db 972 dup(0)
seg000:0434 seg000	    ends
seg000:0434
seg000:0434
seg000:0434		    end
