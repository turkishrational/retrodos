

;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-325F-7034-FF			    |
; |			Rico Baumgart, personal	license			    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	4ED87A7F53B3F4492BBE2E0E72ABE4EF
; Input	CRC32 :	BD494D2D

; File Name   :	C:\WinMe\jo.sys
; Format      :	MS-DOS SYS-file	(perhaps device	driver)
; Base Address:	0h Range: 0h-800h Loaded length: 800h

		.686p
		.mmx
		.model small

; ===========================================================================

; Segment type:	Pure code
seg000		segment	byte public 'CODE' use16
		assume cs:seg000
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
unk_0		db  4Dh	; M
		db  5Ah	; Z
		dw 0
		dw 0			; block	device
		dw 0
		dw 0
word_A		dw 0			; May be device	number
		dw 0
		dw 0
MBR		dd 7C00h		; DATA XREF: hard_disk_boot+2Ar
					; cdrom_fd_boot+18r
word_14		dw 0
		dw 0FFFFh
menu_header	dw offset menu_row_1	; DATA XREF: show_menu+3o
		dw 0			; row 0, col 0
		db 0
		dw 40
start_of_string	db 'Microsoft Windows ME CD-ROM Startup Menu'
menu_row_1	dw offset menu_row_2	; DATA XREF: seg000:menu_headero
		dw 100h			; row 1, col 0
		db 0
		db 40
		db 0
menu_line	db 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í'
		db 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í'
		db 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í', 'Í'
menu_row_2	dw offset menu_row_3	; DATA XREF: seg000:menu_row_1o
					; seg000:025Bo	...
		dw 300h			; row 3, col 0
		db 0
		dw 23			; string length
menu_option_1	db '1.  Boot from Hard Disk'
menu_row_3	dw offset menu_row_4	; DATA XREF: seg000:menu_row_2o
					; seg000:0263o	...
		dw 400h			; row 4, col 0
		db 0			; mode 0
		dw 20
menu_option_2	db '2.  Boot from CD-ROM'
menu_row_4	dw 0			; DATA XREF: seg000:menu_row_3o
					; end of menu rows
		dw 600h			; row 6, col 0
		db 1			; mode 1
		dw 19
		db 'Enter your choice: '
timer_text	dw 0			; DATA XREF: wait_for_keypress+12o
					; wait_for_keypress+61o
		dw 619h			; row 6, col 25
		db 0
		dw 18
		db 'Time remaining: __'
timer_ticks	dw 2 dup(0)		; DATA XREF: wait_for_keypress:read_timer_1r
					; wait_for_keypress+2Dw ...
timer_over	db 0			; DATA XREF: seg000:m_getc_okw
					; wait_for_keypressr ...
timer_divisor	db 18			; DATA XREF: wait_for_keypress+49r
					; column 18
divisor_10	db 10			; DATA XREF: wait_for_keypress+59r
					; row 10
structure_buf	dw 19			; DATA XREF: hard_disk_boot+Ao
					; 19 bytes empty structure buffer
					; for INT 13h ah=4B00h
		db 17 dup(0)
selection	dw '1'                  ; DATA XREF: seg000:0221r seg000:0230r ...
					; default choice is 1
		db 258 dup(0)
; ---------------------------------------------------------------------------

START$:
		cli
		mov	ax, 0
		mov	ss, ax
		assume ss:seg000
		mov	sp, 7C00h
		mov	ax, cs
		mov	es, ax
		assume es:seg000
		mov	ds, ax
		assume ds:seg000
		cld
		sti
		call	show_menu
		call	flush_keyb_buf

m_getc:					; CODE XREF: seg000:021Fj seg000:026Bj ...
		call	get_char
		jb	short m_getc_ok
		call	wait_for_keypress
		jnb	short m_getc
		mov	ax, cs:selection ; character (user has pressed this key)

m_getc_ok:				; CODE XREF: seg000:021Aj
		or	cs:timer_over, 1
		cmp	ax, 0Dh		; CR
		jnz	short chk_choice_1
		mov	ax, cs:selection

chk_choice_1:				; CODE XREF: seg000:022Ej
		cmp	ax, 31h	; '1'   ; Option 1
		jnz	short chk_choice_2
		call	set_vmode
		call	hard_disk_boot
		jmp	int19h
; ---------------------------------------------------------------------------

chk_choice_2:				; CODE XREF: seg000:0237j
		cmp	ax, 32h	; '2'   ; Option 2
		jnz	short chk_choice_up
		call	set_vmode
		call	cdrom_fd_boot
		jmp	short int19h
; ---------------------------------------------------------------------------

chk_choice_up:				; CODE XREF: seg000:0245j
		cmp	ax, 4800h	; up arrow
		jnz	short chk_choice_down
		mov	cs:selection, '1' ; user's menu choice is '1'
					; (but he/she has not ENTERed it yet)
		mov	si, offset menu_row_2 ;	selected (focused)
		mov	al, 70h		; character attribute (highlighted)
		call	display_row
		mov	si, offset menu_row_3
		mov	al, 7		; character attribute (normal)
		call	display_row
		jmp	short m_getc
; ---------------------------------------------------------------------------

chk_choice_down:			; CODE XREF: seg000:0252j
		cmp	ax, 5000h	; down arrow
		jnz	short chk_choice_getc
		mov	cs:selection, '2' ; user's menu choice is '2'
					; (but he/she has not ENTERed it yet)
		mov	si, offset menu_row_3 ;	selected (focused)
		mov	al, 70h		; character attribute (highlighted)
		call	display_row
		mov	si, offset menu_row_2
		mov	al, 7		; character attribute (normal)
		call	display_row
		jmp	short m_getc
; ---------------------------------------------------------------------------

chk_choice_getc:			; CODE XREF: seg000:0270j
		jmp	short m_getc
; ---------------------------------------------------------------------------

int19h:					; CODE XREF: seg000:023Fj seg000:024Dj ...
		int	19h		; DISK BOOT
					; causes reboot	of disk	system
		jmp	short int19h

; =============== S U B	R O U T	I N E =======================================


read_disk_sector_0 proc	near		; CODE XREF: hard_disk_boot+1Ep
					; cdrom_fd_boot+2p
		sub	ax, ax
		mov	es, ax
		mov	bx, 7C00h
		mov	ax, 201h
		mov	cx, 1
		mov	dh, 0
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		retn
read_disk_sector_0 endp


; =============== S U B	R O U T	I N E =======================================


hard_disk_boot	proc near		; CODE XREF: seg000:023Cp
		push	word ptr ss:0410h ; ROMBIOS DATA area,
					; save equipment flags
		mov	ax, 4B00h
		mov	dl, 0		; terminate drive A: emulation
		mov	si, offset structure_buf
		int	13h		; DISK - Bootable CD-ROM - AL =TERMINATE DISK EMULATION
		pop	word ptr ss:0410h ; restore equipment flags
		jnb	short $+2

reset_hd:				; CODE XREF: hard_disk_boot+14j
		sub	ax, ax
		mov	dl, 80h
		int	13h		; DISK - RESET DISK SYSTEM
					; DL = drive (if bit 7 is set both hard	disks and floppy disks reset)
		mov	dl, 80h
		call	read_disk_sector_0
		jnb	short jmp_to_mbr
		retn
; ---------------------------------------------------------------------------

jmp_to_mbr:				; CODE XREF: hard_disk_boot+21j
		sub	ax, ax		; set ds and es	to zero
		mov	ds, ax
		mov	es, ax
		jmp	cs:MBR		; jump to master boot code
hard_disk_boot	endp


; =============== S U B	R O U T	I N E =======================================


cdrom_fd_boot	proc near		; CODE XREF: seg000:024Ap
		mov	dl, 0
		call	read_disk_sector_0
		jnb	short read_sector_0_ok
		retn
; ---------------------------------------------------------------------------

read_sector_0_ok:			; CODE XREF: cdrom_fd_boot+5j
		sub	ax, ax
		mov	ds, ax
		mov	es, ax
		mov	si, 7C8Fh	; put 4	NOPs at	BS offset 008Fh
					; ('IO      SYS' name will be preserved by overwriting
					;  'inc byte ptr ds:IO_SYS' code there) -otherwise, it would be
					;  converted to	'JO      SYS' just as how we are here, in JO.SYS.)
		mov	dword ptr [si],	90909090h ; (overwrite JO.SYS loading code)
		jmp	cs:MBR
cdrom_fd_boot	endp


; =============== S U B	R O U T	I N E =======================================


set_vmode	proc near		; CODE XREF: seg000:0239p seg000:0247p ...
		mov	ax, 3
		int	10h		; - VIDEO - SET	VIDEO MODE
					; AL = mode
		retn
set_vmode	endp


; =============== S U B	R O U T	I N E =======================================


display_row	proc near		; CODE XREF: seg000:0260p seg000:0268p ...
		movzx	di, al
		mov	ah, 3
		mov	bh, 0
		int	10h		; - VIDEO - READ CURSOR	POSITION
					; BH = page number
					; Return: DH,DL	= row,column, CH = cursor start	line, CL = cursor end line
		push	dx		; save cursor position
		push	word ptr [si+2]
		mov	cx, 40		; 40 colums

display_next_col:			; CODE XREF: display_row+2Fj
		push	cx
		mov	ah, 2
		mov	bh, 0
		mov	dx, [si+2]
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		mov	ah, 8
		mov	bh, 0
		int	10h		; - VIDEO - READ ATTRIBUTES/CHARACTER AT CURSOR	POSITION
					; BH = display page
					; Return: AL = character
					; AH = attribute of character (alpha modes)
		mov	ah, 9
		mov	bx, di
		mov	bh, 0
		mov	cx, 1
		int	10h		; - VIDEO - WRITE ATTRIBUTES/CHARACTERS	AT CURSOR POSITION
					; AL = character, BH = display page
					; BL = attributes of character (alpha modes) or	color (graphics	modes)
					; CX = number of times to write	character
		inc	word ptr [si+2]	; next column
		pop	cx
		loop	display_next_col
		pop	word ptr [si+2]
		mov	ah, 2
		mov	bh, 0
		pop	dx		; restore cursor position
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		retn
display_row	endp


; =============== S U B	R O U T	I N E =======================================


erase_timer_text proc near		; CODE XREF: wait_for_keypress+15p
		mov	ah, 3
		mov	bh, 0
		int	10h		; - VIDEO - READ CURSOR	POSITION
					; BH = page number
					; Return: DH,DL	= row,column, CH = cursor start	line, CL = cursor end line
		push	dx
		mov	ah, 2
		mov	bh, 0
		mov	dx, [si+2]
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		mov	ah, 0Ah
		mov	al, 20h	; ' '   ; blank / space (erase char)
		mov	bx, 7
		mov	cx, [si+5]
		int	10h		; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
					; AL = character, BH = display page - alpha mode
					; BL = color of	character (graphics mode, PCjr only)
					; CX = number of times to write	character
		mov	ah, 2
		mov	bh, 0
		pop	dx
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		retn
erase_timer_text endp


; =============== S U B	R O U T	I N E =======================================


display_menu	proc near		; CODE XREF: display_menu+19j
					; wait_for_keypress+70p ...
		or	si, si
		jz	short dm_ok
		mov	ah, 13h
		mov	al, [si+4]
		mov	bx, 7
		mov	cx, [si+5]	; string length	(char count)
		mov	dx, [si+2]	; cursor pos
		lea	bp, [si+7]	; start_of_string
		int	10h		; - VIDEO - WRITE STRING (AT,XT286,PS,EGA,VGA)
					; AL = mode, BL	= attribute if AL bit 1	clear, BH = display page number
					; DH,DL	= row,column of	starting cursor	position, CX = length of string
					; ES:BP	-> start of string
		mov	si, [si]
		jmp	short display_menu
; ---------------------------------------------------------------------------

dm_ok:					; CODE XREF: display_menu+2j
		retn
display_menu	endp


; =============== S U B	R O U T	I N E =======================================


wait_for_keypress proc near		; CODE XREF: seg000:021Cp
		test	cs:timer_over, 3
		jz	short read_timer_1
		test	cs:timer_over, 2
		jnz	read_timer_3
		mov	si, offset timer_text
		call	erase_timer_text
		or	cs:timer_over, 2
		jmp	short read_timer_3
; ---------------------------------------------------------------------------

read_timer_1:				; CODE XREF: wait_for_keypress+6j
		cmp	dword ptr cs:timer_ticks, 0
		jnz	short read_timer_2
		mov	ah, 0
		int	1Ah		; CLOCK	- GET TIME OF DAY
					; Return: CX:DX	= clock	count
					; AL = 00h if clock was	read or	written	(via AH=0,1) since the previous
					; midnight
					; Otherwise, AL	> 0
		mov	cs:timer_ticks,	dx
		mov	cs:timer_ticks+2, cx

read_timer_2:				; CODE XREF: wait_for_keypress+27j
		mov	ah, 0
		int	1Ah		; CLOCK	- GET TIME OF DAY
					; Return: CX:DX	= clock	count
					; AL = 00h if clock was	read or	written	(via AH=0,1) since the previous
					; midnight
					; Otherwise, AL	> 0
		mov	ax, cx
		shl	eax, 16		; high word
		mov	ax, dx
		sub	eax, dword ptr cs:timer_ticks
		idiv	cs:timer_divisor ; result = seconds
		sub	al, 10		; al <=	10
		neg	al		; -9 ->	9, -8 -> 8
		or	al, al		; 0 ?
		jz	short time_over
		movzx	ax, al
		div	cs:divisor_10
		or	ax, 3030h
		mov	si, offset timer_text
		lea	di, [si+5]	; ofset	"Time remaining: __" - 2
		add	di, [si+5]	; the end of "Time remaining: "
		cmp	ax, [di]	; same digits (numeric)	?
		mov	[di], ax
		jz	short read_timer_3 ; yes, don't display 'remain seconds' this time
		call	display_menu	; no, display new numeric chars	(and menu again) as countdown
		mov	ah, 13h		; display timer	text and countdown value (numeric chars)
		mov	al, [si+4]
		mov	bx, 7
		mov	cx, [si+5]
		mov	dx, [si+2]
		lea	bp, [si+7]
		int	10h		; - VIDEO - WRITE STRING (AT,XT286,PS,EGA,VGA)
					; AL = mode, BL	= attribute if AL bit 1	clear, BH = display page number
					; DH,DL	= row,column of	starting cursor	position, CX = length of string
					; ES:BP	-> start of string

read_timer_3:				; CODE XREF: wait_for_keypress+Ej
					; wait_for_keypress+1Ej ...
		clc
		retn
; ---------------------------------------------------------------------------

time_over:				; CODE XREF: wait_for_keypress+54j
		stc
		retn
wait_for_keypress endp


; =============== S U B	R O U T	I N E =======================================


show_menu	proc near		; CODE XREF: seg000:0211p
		call	set_vmode	; set video mode to 3 (80x25 text mode)
		mov	si, offset menu_header
		call	display_menu
		mov	si, offset menu_row_2
		mov	al, 70h
		call	display_row
		retn
show_menu	endp


; =============== S U B	R O U T	I N E =======================================


flush_keyb_buf	proc near		; CODE XREF: seg000:0214p
					; flush_keyb_buf+Aj
		mov	ah, 1
		int	16h		; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
					; Return: ZF clear if character	in buffer
					; AH = scan code, AL = character
					; ZF set if no character in buffer
		jz	short flush_kbb_ok
		mov	ah, 0
		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
					; Return: AH = scan code, AL = character
		jmp	short flush_keyb_buf
; ---------------------------------------------------------------------------

flush_kbb_ok:				; CODE XREF: flush_keyb_buf+4j
		retn
flush_keyb_buf	endp


; =============== S U B	R O U T	I N E =======================================


get_char	proc near		; CODE XREF: seg000:m_getcp
		mov	ah, 1
		int	16h		; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
					; Return: ZF clear if character	in buffer
					; AH = scan code, AL = character
					; ZF set if no character in buffer
		jnz	short getchar
		clc			; no key press
		retn
; ---------------------------------------------------------------------------

getchar:				; CODE XREF: get_char+4j
		mov	ah, 0
		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
					; Return: AH = scan code, AL = character
		cmp	ax, 4800h	; up (arrow) key
		jz	short getc_ok
		cmp	ax, 5000h	; down (arrow) key
		jz	short getc_ok
		sub	ah, ah		; clear	(zero) scan code

getc_ok:				; CODE XREF: get_char+Fj get_char+14j
		stc			; a key	pressed
		retn
get_char	endp

; ---------------------------------------------------------------------------
		db 972 dup(0)
seg000		ends


		end
