     1                                  ; ****************************************************************************
     2                                  ; COMMAND.COM (MSDOS 6.22 Command Interpreter) - RETRO DOS v4.2 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update:  06/08/2024 (v6.22 - 2024 optimization)
     5                                  ;		19/06/2023 (v6.22) ((Previous: 05/05/2023 COMMAND.COM v5.0))
     6                                  ; ----------------------------------------------------------------------------
     7                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     8                                  ; ----------------------------------------------------------------------------
     9                                  ; Assembler: NASM version 2.15 (2.11)
    10                                  ; ----------------------------------------------------------------------------
    11                                  ;	    ((nasm command6.s -l command6.lst -o COMMAND.COM)) 	
    12                                  ; ----------------------------------------------------------------------------
    13                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    14                                  ; by Microsoft, 18/08/1983
    15                                  ; ****************************************************************************
    16                                  ; Modified from 'COMMAND5.S' (MSDOS 5.0 COMMAND.COM) source code
    17                                  ; in NASM syntax (by Erdogan Tan), 05/05/2023
    18                                  ; ----------------------------------------------------------------------------
    19                                  ; Modified from 'COMMAND3.S' (MSDOS 3.3 COMMAND.COM) source code
    20                                  ; in NASM syntax (by Erdogan Tan), 20/10/2018
    21                                  ; ----------------------------------------------------------------------------
    22                                  ;; 11/09/2018 - Erdogan Tan
    23                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    24                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    25                                  ; ----------------------------------------------------------------------------
    26                                  ; MSDOS 6.0 source files:
    27                                  ;;============================================================================
    28                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    29                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    30                                  ;;============================================================================
    31                                  ;
    32                                  ; COMMAND.COM v6.0 source files:
    33                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    34                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    35                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    36                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    37                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    38                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    39                                  ;
    40                                  ; COMMAND.COM v2.11 source files:
    41                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    42                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    43                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    44                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    45                                  ;
    46                                  ; ----------------------------------------------------------------------------
    47                                  ; 09/01/2023 - COMMAND.COM v5.0 (Multi Section Binary File Format)
    48                                  
    49                                  ;============================================================================
    50                                  ; MSDOS 6.22 COMMAND.COM, DISASSEMBLED by Erdogan Tan, 17/05/2023-05/06/2023
    51                                  ;============================================================================
    52                                  
    53                                  ; -=========================================================================¬
    54                                  ; ¦     This file is generated by The Interactive Disassembler (IDA)        ¦
    55                                  ; ¦     Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>           ¦
    56                                  ; ¦                      Licensed to: Freeware version                      ¦
    57                                  ; L=========================================================================-
    58                                  ;
    59                                  ; Input MD5   : FAF051453F215165981F10BD73071D88
    60                                  ;
    61                                  ; File Name   : C:\Users\Erdo­an\Desktop\COMMAND.COM
    62                                  ; Format      : MS-DOS COM-file
    63                                  ; Base Address: 0h Range: 100h-D675h Loaded length: D575h
    64                                  
    65                                  ;============================================================================
    66                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    67                                  ;============================================================================
    68                                  ; 21/09/2018 - Retro DOS v3.0
    69                                  
    70                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    71                                  ;BREAK <system call definitions>
    72                                  
    73                                  ;
    74                                  ;	Microsoft Confidential
    75                                  ;	Copyright (C) Microsoft Corporation 1991
    76                                  ;	All Rights Reserved.
    77                                  ;
    78                                  
    79                                  ;SUBTTL	system call definitions
    80                                  ;PAGE
    81                                  
    82                                  Abort				EQU 0	;  0	  0
    83                                  STD_CON_INPUT			EQU 1	;  1	  1
    84                                  Std_Con_Output			EQU 2	;  2	  2
    85                                  Std_Aux_Input			EQU 3	;  3	  3
    86                                  Std_Aux_Output			EQU 4	;  4	  4
    87                                  Std_Printer_Output		EQU 5	;  5	  5
    88                                  Raw_Con_IO			EQU 6	;  6	  6
    89                                  RAW_CON_INPUT			EQU 7	;  7	  7
    90                                  Std_Con_Input_No_Echo		EQU 8	;  8	  8
    91                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    92                                  Std_Con_String_Input		EQU 10	; 10	  A
    93                                  Std_Con_Input_Status		EQU 11	; 11	  B
    94                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    95                                  DISK_RESET			EQU 13	; 13	  D
    96                                  Set_Default_Drive		EQU 14	; 14	  E
    97                                  FCB_Open			EQU 15	; 15	  F
    98                                  FCB_Close			EQU 16	; 16	 10
    99                                  Dir_Search_First		EQU 17	; 17	 11
   100                                  Dir_Search_Next 		EQU 18	; 18	 12
   101                                  FCB_Delete			EQU 19	; 19	 13
   102                                  FCB_Seq_Read			EQU 20	; 20	 14
   103                                  FCB_Seq_Write			EQU 21	; 21	 15
   104                                  FCB_Create			EQU 22	; 22	 16
   105                                  FCB_Rename			EQU 23	; 23	 17
   106                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
   107                                  Set_DMA 			EQU 26	; 26	 1A
   108                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   109                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   110                                  ;									   ;
   111                                  Get_Default_DPB 		EQU 31	; 31	 1F
   112                                  ;									   ;
   113                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   114                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   115                                  FCB_Random_Read 		EQU 33	; 33	 21
   116                                  FCB_Random_Write		EQU 34	; 34	 22
   117                                  Get_FCB_File_Length		EQU 35	; 35	 23
   118                                  Get_FCB_Position		EQU 36	; 36	 24
   119                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   120                                  Create_Process_Data_Block	EQU 38	; 38	 26
   121                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   122                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   123                                  Parse_File_Descriptor		EQU 41	; 41	 29
   124                                  Get_Date			EQU 42	; 42	 2A
   125                                  Set_Date			EQU 43	; 43	 2B
   126                                  Get_Time			EQU 44	; 44	 2C
   127                                  Set_Time			EQU 45	; 45	 2D
   128                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   129                                  ; Extended functionality group
   130                                  Get_DMA 			EQU 47	; 47	 2F
   131                                  GET_VERSION			EQU 48	; 48	 30
   132                                  Keep_Process			EQU 49	; 49	 31
   133                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   134                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   135                                  ;									   ;
   136                                  Get_DPB 			EQU 50	; 50	 32
   137                                  ;									   ;
   138                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   139                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   140                                  Set_CTRL_C_Trapping		EQU 51	; 51	 33
   141                                  Get_InDOS_Flag			EQU 52	; 52	 34
   142                                  Get_Interrupt_Vector		EQU 53	; 53	 35
   143                                  Get_Drive_Freespace		EQU 54	; 54	 36
   144                                  CHAR_OPER			EQU 55	; 55	 37
   145                                  International			EQU 56	; 56	 38
   146                                  ;   Directory Group
   147                                  MKDir				EQU 57	; 57	 39
   148                                  RMDir				EQU 58	; 58	 3A
   149                                  CHDir				EQU 59	; 59	 3B
   150                                  ;   File Group
   151                                  Creat				EQU 60	; 60	 3C
   152                                  OPEN				EQU 61	; 61	 3D
   153                                  CLOSE				EQU 62	; 62	 3E
   154                                  READ				EQU 63	; 63	 3F
   155                                  Write				EQU 64	; 64	 40
   156                                  Unlink				EQU 65	; 65	 41
   157                                  LSEEK				EQU 66	; 66	 42
   158                                  CHMod				EQU 67	; 67	 43
   159                                  IOCTL				EQU 68	; 68	 44
   160                                  XDUP				EQU 69	; 69	 45
   161                                  XDup2				EQU 70	; 70	 46
   162                                  Current_Dir			EQU 71	; 71	 47
   163                                  ;    Memory Group
   164                                  ALLOC				EQU 72	; 72	 48
   165                                  DEALLOC				EQU 73	; 73	 49
   166                                  SETBLOCK			EQU 74	; 74	 4A
   167                                  ;    Process Group
   168                                  Exec				EQU 75	; 75	 4B
   169                                  EXIT				EQU 76	; 76	 4C
   170                                  WAITPROCESS			EQU 77	; 77	 4D
   171                                  Find_First			EQU 78	; 78	 4E
   172                                  ;   Special Group
   173                                  Find_Next			EQU 79	; 79	 4F
   174                                  ; SPECIAL SYSTEM GROUP
   175                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   176                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   177                                  ;									   ;
   178                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   179                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   180                                  Get_In_Vars			EQU 82	; 82	 52
   181                                  SetDPB				EQU 83	; 83	 53
   182                                  ;									   ;
   183                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   184                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   185                                  Get_Verify_On_Write		EQU 84	; 84	 54
   186                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   187                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   188                                  ;									   ;
   189                                  Dup_PDB 			EQU 85	; 85	 55
   190                                  ;									   ;
   191                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   192                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   193                                  Rename				EQU 86	; 86	 56
   194                                  File_Times			EQU 87	; 87	 57
   195                                  AllocOper			EQU 88	; 88	 58
   196                                  ; Network extention system calls
   197                                  GetExtendedError		EQU 89	; 89	 59
   198                                  CreateTempFile			EQU 90	; 90	 5A
   199                                  CreateNewFile			EQU 91	; 91	 5B
   200                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   201                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   202                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   203                                  ;									   ;
   204                                  ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   205                                  					;	    CloseByName, CloseUser,
   206                                  					;	    CloseUserProcess,
   207                                  					;	    GetOpenFileList
   208                                  ;									   ;
   209                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   210                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   211                                  UserOper			EQU 94	; 94	 5E Get and Set
   212                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   213                                  xNameTrans			EQU 96	; 96	 60
   214                                  PathParse			EQU 97	; 97	 61
   215                                  GetCurrentPSP			EQU 98	; 98	 62
   216                                  Hongeul 			EQU 99	; 99	 63
   217                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   218                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   219                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   220                                  ;									   ;
   221                                  Set_Printer_Flag		EQU 100 ; 100	 64
   222                                  ;									   ;
   223                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   224                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   225                                  GetExtCntry			EQU 101 ; 101	 65
   226                                  GetSetCdPg			EQU 102 ; 102	 66
   227                                  ExtHandle			EQU 103 ; 103	 67
   228                                  Commit				EQU 104 ; 104	 68
   229                                  GetSetMediaID			EQU 105 ; 105	 69
   230                                  IFS_IOCTL			EQU 107 ; 107	 6B
   231                                  ExtOpen 			EQU 108 ; 108	 6C
   232                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   233                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   234                                  ;                                                                          ;
   235                                  ;ifdef ROMEXEC
   236                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   237                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   238                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
   239                                  ;endif
   240                                  ;                                                                          ;
   241                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   242                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   243                                  ;
   244                                  ;
   245                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   246                                  OEM_C1				EQU 249 ; 249	 F9
   247                                  OEM_C2				EQU 250 ; 250	 FA
   248                                  OEM_C3				EQU 251 ; 251	 FB
   249                                  OEM_C4				EQU 252 ; 252	 FC
   250                                  OEM_C5				EQU 253 ; 253	 FD
   251                                  OEM_C6				EQU 254 ; 254	 FE
   252                                  OEM_C7				EQU 255 ; 255	 FF
   253                                  
   254                                  ;============================================================================
   255                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   256                                  ;============================================================================
   257                                  ; 21/09/2018 - Retro DOS v3.0
   258                                  
   259                                  ;BREAK <Control character definitions>
   260                                  
   261                                  c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
   262                                  c_BS	    EQU     08h 	; ^H ASCII backspace
   263                                  c_CR	    EQU     0Dh 	; ^M ASCII carriage return
   264                                  c_LF	    EQU     0Ah 	; ^J ASCII linefeed
   265                                  c_ETB	    EQU     17h 	; ^W ASCII end of transmission
   266                                  c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
   267                                  c_ETX	    EQU     03h 	; ^C ASCII end of text
   268                                  c_HT	    EQU     09h 	; ^I ASCII tab
   269                                  
   270                                  ;============================================================================
   271                                  ; DIRENT.INC, MSDOS 6.0, 1991
   272                                  ;============================================================================
   273                                  ; 21/09/2018 - Retro DOS v3.0
   274                                  
   275                                  ;Break <Directory entry>
   276                                  
   277                                  ;	NOTE:  These offsets are also used in the DTA for
   278                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   279                                  ;	with the FCB filename field, and the rest of the
   280                                  ;	DIR_ENTRY fields follow. -DavidOls
   281                                  
   282                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   283                                  ;
   284                                  ;	+---------------------------+
   285                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   286                                  ;	+---------------------------+
   287                                  ;	|     (BYTE) attributes     |	    11	    B
   288                                  ;	+---------------------------+
   289                                  ;	|    (10 BYTE) reserved     |	    12	    C
   290                                  ;	+---------------------------+
   291                                  ;	| (WORD) time of last write |	    22	    16
   292                                  ;	+---------------------------+
   293                                  ;	| (WORD) date of last write |	    24	    18
   294                                  ;	+---------------------------+
   295                                  ;	|   (WORD) First cluster    |	    26	    1A
   296                                  ;	+---------------------------+
   297                                  ;	|     (DWORD) file size     |	    28	    1C
   298                                  ;	+---------------------------+
   299                                  ;
   300                                  ;   First byte of filename  = E5 -> free directory entry
   301                                  ;			    = 00 -> end of allocated directory
   302                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   303                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   304                                  ;
   305                                  
   306                                  STRUC DIR_ENTRY
   307 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   308 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   309 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   310 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   311 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   312 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   313 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   314 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   315 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   316 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   317 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   318                                  .size:
   319                                  
   320                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   321                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   322                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   323                                  ;	    this field is zero for subdirectory files.
   324                                  
   325                                  ENDSTRUC
   326                                  
   327                                  ATTR_READ_ONLY	equ	 1h
   328                                  ATTR_HIDDEN	equ	 2h
   329                                  ATTR_SYSTEM	equ	 4h
   330                                  ATTR_VOLUME_ID	equ	 8h
   331                                  ATTR_DIRECTORY	equ	10h
   332                                  ATTR_ARCHIVE	equ	20h
   333                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   334                                  				;   NO directory entry on a disk EVER
   335                                  				;   has this bit set. It is set non-zero
   336                                  				;   when a device is found by GETPATH
   337                                  
   338                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   339                                  				; OR of hard attributes for FINDENTRY
   340                                  
   341                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   342                                  				; ignore this(ese) attribute(s) during
   343                                  				; search first/next
   344                                  
   345                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   346                                  				; changeable via CHMOD
   347                                  
   348                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   349                                  
   350                                  ;============================================================================
   351                                  ; ERROR.INC, MSDOS 6.0, 1991
   352                                  ;============================================================================
   353                                  ; 21/09/2018 - Retro DOS v3.0
   354                                  
   355                                  ;**	ERROR.INC - DOS Error Codes
   356                                  ;
   357                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   358                                  ;    return error codes through AX.	If an error occurred then
   359                                  ;    the carry bit will be set and the error code is in AX.	If no error
   360                                  ;    occurred then the carry bit is reset and AX contains returned info.
   361                                  ;
   362                                  ;    Since the set of error codes is being extended as we extend the operating
   363                                  ;    system, we have provided a means for applications to ask the system for a
   364                                  ;    recommended course of action when they receive an error.
   365                                  ;
   366                                  ;    The GetExtendedError system call returns a universal error, an error
   367                                  ;    location and a recommended course of action.	The universal error code is
   368                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   369                                  ;    is issued.
   370                                  
   371                                  
   372                                  ;	2.0 error codes
   373                                  
   374                                  error_invalid_function		EQU	1
   375                                  ERROR_FILE_NOT_FOUND		EQU	2
   376                                  ERROR_PATH_NOT_FOUND		EQU	3
   377                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   378                                  ERROR_ACCESS_DENIED		EQU	5
   379                                  error_invalid_handle		EQU	6
   380                                  error_arena_trashed		EQU	7
   381                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   382                                  error_invalid_block		EQU	9
   383                                  error_bad_environment		EQU	10
   384                                  ERROR_BAD_FORMAT		EQU	11
   385                                  error_invalid_access		EQU	12
   386                                  ERROR_INVALID_DATA		EQU	13
   387                                  ;**** reserved			EQU	14	; *****
   388                                  error_invalid_drive		EQU	15
   389                                  error_current_directory 	EQU	16
   390                                  error_not_same_device		EQU	17
   391                                  ERROR_NO_MORE_FILES		EQU	18
   392                                  
   393                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   394                                  
   395                                  ERROR_WRITE_PROTECT		EQU	19
   396                                  error_bad_unit			EQU	20
   397                                  error_not_ready 		EQU	21
   398                                  error_bad_command		EQU	22
   399                                  error_CRC			EQU	23
   400                                  error_bad_length		EQU	24
   401                                  error_Seek			EQU	25
   402                                  error_not_DOS_disk		EQU	26
   403                                  error_sector_not_found		EQU	27
   404                                  error_out_of_paper		EQU	28
   405                                  error_write_fault		EQU	29
   406                                  error_read_fault		EQU	30
   407                                  ERROR_GEN_FAILURE		EQU	31
   408                                  
   409                                  ;	the new 3.0 error codes reported through INT 24
   410                                  
   411                                  error_sharing_violation 	EQU	32
   412                                  error_lock_violation		EQU	33
   413                                  error_wrong_disk		EQU	34
   414                                  ERROR_FCB_UNAVAILABLE		EQU	35
   415                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   416                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   417                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   418                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   419                                  
   420                                  ;	New OEM network-related errors are 50-79
   421                                  
   422                                  error_not_supported		EQU	50
   423                                  
   424                                  error_net_access_denied		EQU	65	;M028
   425                                  
   426                                  ;	End of INT 24 reportable errors
   427                                  
   428                                  error_file_exists		EQU	80
   429                                  error_DUP_FCB			EQU	81	; *****
   430                                  error_cannot_make		EQU	82
   431                                  error_FAIL_I24			EQU	83
   432                                  
   433                                  ;	New 3.0 network related error codes
   434                                  
   435                                  error_out_of_structures 	EQU	84
   436                                  error_Already_assigned		EQU	85
   437                                  error_invalid_password		EQU	86
   438                                  error_invalid_parameter 	EQU	87
   439                                  error_NET_write_fault		EQU	88
   440                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   441                                  
   442                                  ;============================================================================
   443                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   444                                  ;============================================================================
   445                                  ; 22/09/2018 - Retro DOS v3.0
   446                                  
   447                                  ;**	DevSym.inc - Device Symbols
   448                                  
   449                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   450                                  
   451                                  STRUC SYSDEV
   452 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   453 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   454 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   455 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   456 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   457                                  .size:
   458                                  ENDSTRUC
   459                                  
   460                                  ; 24/09/2018
   461                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   462                                  
   463                                  ;============================================================================
   464                                  ; CURDIR.INC, MSDOS 6.0, 1991
   465                                  ;============================================================================
   466                                  ; 21/09/2018 - Retro DOS v3.0
   467                                  
   468                                  DIRSTRLEN	EQU	64+3	; Max length in bytes of directory strings
   469                                  
   470                                  ;============================================================================
   471                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   472                                  ;============================================================================
   473                                  ; 21/09/2018 - Retro DOS v3.0
   474                                  
   475                                  ;/*
   476                                  ; *                      Microsoft Confidential
   477                                  ; *                      Copyright (C) Microsoft Corporation 1991
   478                                  ; *                      All Rights Reserved.
   479                                  ; */
   480                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   481                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   482                                  ;*************************************
   483                                  ; COMMAND EQUs which are not switch dependant
   484                                  
   485                                  ;		include	curdir.inc	; to get DIRSTRLEN
   486                                  ;		Note dossym.inc must already have been included!
   487                                  
   488                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   489                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   490                                  
   491                                  SYM		EQU	">"
   492                                  
   493                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   494                                  
   495                                  NORMPERLIN	EQU	1
   496                                  WIDEPERLIN	EQU	5
   497                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   498                                  BatLen		EQU	32		; buffer for batch files
   499                                  YES_ECHO	EQU	1		; echo line
   500                                  NO_ECHO 	EQU	0		; don't echo line
   501                                  No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
   502                                  call_in_progress EQU	1		; indicate we're in the CALL command
   503                                  length_call	EQU	4		; length of CALL
   504                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   505                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   506                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   507                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   508                                  nullcommand	EQU     1		; no command on command line
   509                                  END_OF_LINE	EQU    -1		;AN000; end of line return from parser
   510                                  END_OF_LINE_OUT EQU	0		;AN000; end of line for output
   511                                  END_OF_LINE_IN	EQU	0Dh		;AN000; end of line for input
   512                                  result_number	EQU	1		;AN000; number returned from parser
   513                                  result_string	EQU	3		;AN000; string returned from parser
   514                                  RESULT_FILESPEC EQU	5		;AN000; filespec returned from parser
   515                                  result_drive	EQU	6		;AN000; drive returned from parser
   516                                  result_date	EQU	7		;AN000; date returned from parser
   517                                  result_time	EQU	8		;AN000; time returned from parser
   518                                  RESULT_NO_ERROR EQU	0		;AN000; no error returned from parser
   519                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   520                                  util_msg_class	EQU	-1		;AN000; message class for utility
   521                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   522                                  parse_msg_class EQU	2		;AN000; message class for parse error
   523                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   524                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   525                                  colon_char	EQU	":"             ;AN000; colon character
   526                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   527                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   528                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   529                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   530                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   531                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   532                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   533                                  shell_action	equ	0FFh		;AN000; SHELL - return for taking SHELL specific action
   534                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   535                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   536                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   537                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   538                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   539                                  parm_block_size equ	11		;AN000; size of message subst block
   540                                  blank		equ	" "             ;AN000; blank character
   541                                  no_subst	equ	0		;AN000; no substitutions for messages
   542                                  one_subst	equ	1		;AN000; one substitution for messages
   543                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   544                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   545                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   546                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   547                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   548                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   549                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   550                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   551                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   552                                  capital_A	equ	'A'             ;AC000;
   553                                  vbar		equ	'|'             ;AC000;
   554                                  labracket	equ	'<'             ;AC000;
   555                                  rabracket	equ	'>'             ;AC000;
   556                                  dollar		equ	'$'             ;AC000;
   557                                  lparen		equ	'('             ;AC000;
   558                                  rparen		equ	')'             ;AC000;
   559                                  nullrparen	equ	29h		;AC000;
   560                                  in_word 	equ	4E49h		;AC000; 'NI'  ('IN' backwards)
   561                                  do_word 	equ	4F44h		;AC000; 'OD'  ('DO' backwards)
   562                                  star		equ	'*'             ;AC000;
   563                                  plus_chr	equ	'+'             ;AC000;
   564                                  small_a 	equ	'a'             ;AC000;
   565                                  small_z 	equ	'z'             ;AC000;
   566                                  dot_chr 	equ	'.'             ;AC000;
   567                                  tab_chr 	equ	9		;AN032;
   568                                  equal_chr	equ	'='             ;AN032;
   569                                  semicolon	equ	';'             ;AN049;
   570                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   571                                  dot_colon	equ	2e3ah		;AC000; '.:'
   572                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   573                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   574                                  AppendInstall	equ	0B700H		;AN020; append install check
   575                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   576                                  AppendGetState	equ	0B706H		;AN020; append get current state
   577                                  AppendSetState	equ	0B707H		;AN020; append set current state
   578                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   579                                  search_attr	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   580                                  
   581                                  ;*************************************
   582                                  ;* PARSE ERROR MESSAGES
   583                                  ;*************************************
   584                                  
   585                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   586                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   587                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   588                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   589                                  
   590                                  ;*************************************
   591                                  ;* EQUATES FOR MESSAGE RETRIEVER
   592                                  ;*************************************
   593                                  
   594                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   595                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   596                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   597                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   598                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   599                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   600                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   601                                  
   602                                  ;*********************************
   603                                  ;* EQUATES FOR INT 10H
   604                                  ;*********************************
   605                                  
   606                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   607                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   608                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   609                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   610                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   611                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   612                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   613                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   614                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   615                                  
   616                                  AltPipeChr	equ	"|"             ; alternate pipe character
   617                                  
   618                                  FCB		equ	5Ch
   619                                  
   620                                  STRUC VARSTRUC
   621 00000000 ??                      .ISDIR:		RESB	1
   622 00000001 ??                      .SIZ:		RESB	1
   623 00000002 ????                    .TTAIL:		RESW	1
   624 00000004 ??                      .INFO:		RESB	1
   625 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   626                                  .size:
   627                                  ENDSTRUC
   628                                  ;
   629                                  ; Flags for internal command parsing
   630                                  ;
   631                                  fCheckDrive	equ	00000001b	; validate drive letter
   632                                  fSwitchAllowed	equ	00000010b	; switches allowed
   633                                  fLimitHelp	equ	00000100b	; /? must appear alone
   634                                  
   635                                  ;
   636                                  ; Test switches
   637                                  ;
   638                                  fParse		EQU	0001h		; display results of parseline
   639                                  
   640                                  ;
   641                                  ; Batch segment structure
   642                                  ;
   643                                  ;   BYTE    type of segment
   644                                  ;   BYTE    echo state of parent on entry to batch file
   645                                  ;   WORD    segment of last batch file
   646                                  ;   WORD    segment for FOR command
   647                                  ;   BYTE    FOR flag state on entry to batch file
   648                                  ;   DWORD   offset for next line
   649                                  ;   10 WORD pointers to parameters. -1 is empty parameter
   650                                  ;   ASCIZ   file name (with . and ..)
   651                                  ;   BYTES   CR-terminated parameters
   652                                  ;   BYTE    0 flag to indicate end of parameters
   653                                  ;
   654                                  
   655                                  BATCHTYPE   equ 0
   656                                  
   657                                  STRUC BATCHSEGMENT
   658 00000000 ??                      .BatType:	RESB	1		; signature
   659 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   660                                  ; MSDOS 5.0 (& 6.0) - 11/01/2023
   661 00000002 ??                      .BatchEOF:	RESB	1		; records if EOF reached on file
   662 00000003 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   663 00000005 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   664 00000007 ??                      .BatForFlag:	RESB	1		; G state of FOR
   665 00000008 ????????                .BatSeek:	RESD	1		; lseek position of next char
   666 0000000C <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   667 00000020 ??                      .BatFile:	RESB	1		; beginning of batch file name
   668                                  .SIZE:
   669                                  ENDSTRUC
   670                                  
   671                                  ANULL		equ	0		; terminates an argv string
   672                                  ARGMAX		equ	64		; max args on a command line
   673                                  ;ARGBLEN 	equ	2*128		; 1char each plus term NUL
   674                                  ; 27/07/2024 - PCDOS 7.1 COMMAND.COM ;*
   675                                  ARGBLEN 	equ	2*64
   676                                  tplen		equ	64		; max size of one argument
   677                                  arg_cnt_error	equ	1		; number of args > MAXARG
   678                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   679                                  
   680                                  STRUC ARGV_ELE				; elements in the argv array
   681 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   682 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   683 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   684 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   685 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   686 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   687                                  .SIZE:	; 11 ; 27/07/2024
   688                                  ENDSTRUC
   689                                  
   690                                  STRUC ARG_UNIT
   691 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   692 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   693 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   694 000002C4 <res 100h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   695 000003C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   696                                  .SIZE:	; 1092 ; 27/07/2024 ; (it was 1348 in MSDOS 5.0-6.22 COMMAND.COM) ;*
   697                                  ENDSTRUC
   698                                  
   699                                  ; Equates for initialization
   700                                  ;
   701                                  INITINIT	equ	01h		; initialization in progress
   702                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   703                                  INITCTRLC	equ	04h		; already in ^C handler
   704                                  
   705                                  ;============================================================================
   706                                  ;  INTNAT.INC, MSDOS 6.0, 1991
   707                                  ;============================================================================
   708                                  ; 16/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM 
   709                                  
   710                                  ; Current structure of the data returned by the international call
   711                                  
   712                                  struc INTERNAT_BLOCK
   713 00000000 ????                    .date_tim_format: resw 1		; 0-USA, 1-EUR, 2-JAP
   714 00000002 ??????????              .currency_sym:	resb 5			; Currency Symbol 5 bytes
   715 00000007 ????                    .thous_sep:	resb 2			; Thousands separator 2 bytes
   716 00000009 ????                    .decimal_sep:	resb 2			; Decimal separator 2 bytes
   717 0000000B ????                    .date_sep:	resb 2			; Date separator 2 bytes
   718 0000000D ????                    .time_sep:	resb 2			; Decimal separator 2 bytes
   719 0000000F ??                      .bit_field:	resb 1			; Bit values
   720                                  					;   Bit 0 = 0 if currency symbol first
   721                                  					;	  = 1 if currency symbol last
   722                                  					;   Bit 1 = 0 if No space after currency symbol
   723                                  					;	  = 1 if space after currency symbol
   724                                  .currency_cents:
   725 00000010 ??                      		resb 1			; Number of places after currency dec point
   726 00000011 ??                      .time_24:	resb 1			; 1 if 24 hour time, 0 if 12 hour time
   727 00000012 ????????                .map_call:	resw 2			; Address of case mapping call (DWORD)
   728                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   729                                  					;  in pieces.
   730 00000016 ??                      .data_sep:	resb 1			; Data list separator character
   731 00000017 ??                      		resb 1
   732                                  endstruc
   733                                  
   734                                  ; Max size of the block returned by the INTERNATIONAL call
   735                                  
   736                                  internat_block_max equ 32
   737                                  
   738                                  ;============================================================================
   739                                  ; FIND.INC (MSDOS 3.3, 1987) - REDIRSYM.INC (MSDOS 6.0, 1991) 
   740                                  ;============================================================================
   741                                  ; 13/10/2018 - Retro DOS v3.0
   742                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM 
   743                                  
   744                                  ;Break	<find first/next buffer>
   745                                  
   746                                  	; MSDOS 3.3 & MSDOS 6.0
   747                                  
   748                                  struc FIND_BUF
   749 00000000 ??                      .DRIVE:	    resb 1	; drive of search
   750 00000001 <res Bh>                .NAME:	    resb 11	; formatted name
   751 0000000C ??                      .SATTR:	    resb 1	; attribute of search
   752 0000000D ????                    .LASTENT:   resw 1	; LastEnt
   753 0000000F ????                    .DIRSTART:  resw 1	; DirStart
   754 00000011 ????????                .NETID:	    resb 4	; Reserved for NET
   755 00000015 ??                      .ATTR:	    resb 1	; attribute found
   756 00000016 ????                    .TIMR:	    resw 1	; time
   757 00000018 ????                    .DATE:	    resw 1	; date
   758 0000001A ????                    .SIZE_L:    resw 1	; low(size)
   759 0000001C ????                    .SIZE_H:    resw 1	; high(size)
   760 0000001E <res Dh>                .PNAME:	    resb 13	; packed name
   761                                  .size:
   762                                  endstruc
   763                                  
   764                                  ;=============================================================================
   765                                  ; PDB.INC, MSDOS 6.0, 1991
   766                                  ;=============================================================================
   767                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   768                                  
   769                                  ;**	Process data block (otherwise known as program header)
   770                                  
   771                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   772                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   773                                  ;	for use.
   774                                  
   775                                  FILPERPROC	EQU     20
   776                                  
   777                                  struc PDB	; Process_data_block
   778 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   779 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   780 00000004 ??                                      resb 1
   781 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   782 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   783 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   784 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   785 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   786 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   787 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   788 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   789 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   790 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   791 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   792 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   793 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   794 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   795 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   796 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   797 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   798 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   799                                  				;  an extended FCB
   800                                  ;endstruc 	; MSDOS 3.3
   801                                  	  	; MSDOS 6.0
   802 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   803 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   804 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   805 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   806                                  endstruc
   807                                  
   808                                  ;=============================================================================
   809                                  ; VERSIONA.INC, MSDOS 6.0, 1991
   810                                  ;=============================================================================
   811                                  ; 24/09/2018 - Retro DOS v3.0
   812                                  
   813                                  ;major_version	equ 6		; Major DOS version
   814                                  ;minor_version	equ 0		; Minor DOS Version
   815                                  
   816                                  ;expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION
   817                                  
   818                                  ; MSDOS 3.3 COMMAND.COM
   819                                  ;MAJOR_VERSION	EQU 3
   820                                  ;MINOR_VERSION	EQU 30
   821                                  
   822                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
   823                                  ;MAJOR_VERSION	EQU 5		; Major DOS version
   824                                  ;MINOR_VERSION	EQU 0		; Minor DOS version
   825                                  
   826                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
   827                                  MAJOR_VERSION	EQU 6		; Major DOS version
   828                                  MINOR_VERSION	EQU 22		; Minor DOS version
   829                                  
   830                                  EXPECTED_VERSION EQU (MINOR_VERSION<<8)+MAJOR_VERSION	
   831                                  
   832                                  ;-----------------------------------------------------------------------------
   833                                  ; 21/09/2018
   834                                  ;-----------------------------------------------------------------------------
   835                                  ; Retro DOS v3.0 NOTE:  
   836                                  ;	Following source code is as disassembled code of MSDOS 3.3 COMMAND.COM
   837                                  ;	with minor modifications which are done by me (Erdogan Tan).
   838                                  ;	.. but comments and descriptions are from MSDOS 6.0 COMMAND.COM
   839                                  ;	source code files (written by using MASM syntax).
   840                                  ;-----------------------------------------------------------------------------
   841                                  ; All of this Retro DOS 3.0 (2018) source code has been written by using
   842                                  ; NASM (2.11) x86 assembly language/compiler syntax.	
   843                                  ;----------------------------------------------------------------------------- 	
   844                                  
   845                                  ;=============================================================================
   846                                  ; COMMAND1.ASM, MSDOS 6.0, 1991
   847                                  ;=============================================================================
   848                                  ; 21/09/2018 - Retro DOS v3.0
   849                                  
   850                                  ;	page ,132
   851                                  ;	title	COMMAND - resident code for COMMAND.COM
   852                                  ;	name	COMMAND
   853                                  
   854                                  ;/*
   855                                  ; *                      Microsoft Confidential
   856                                  ; *                      Copyright (C) Microsoft Corporation 1991
   857                                  ; *                      All Rights Reserved.
   858                                  ; */
   859                                  
   860                                  ;*****************************************************************************
   861                                  ;
   862                                  ; MODULE:	       COMMAND.COM
   863                                  ;
   864                                  ; DESCRIPTIVE NAME:    Default DOS command interpreter
   865                                  ;
   866                                  ; FUNCTION:	       This version of COMMAND is divided into three distinct
   867                                  ;		       parts.  First is the resident portion, which includes
   868                                  ;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
   869                                  ;		       error), and 2EH (command line execute); it also has
   870                                  ;		       code to test and, if necessary, reload the transient
   871                                  ;		       portion. Following the resident is the init code, which
   872                                  ;		       is overwritten after use.  Then comes the transient
   873                                  ;		       portion, which includes all command processing (whether
   874                                  ;		       internal or external).  The transient portion loads at
   875                                  ;		       the end of physical memory, and it may be overlayed by
   876                                  ;		       programs that need as much memory as possible. When the
   877                                  ;		       resident portion of command regains control from a user
   878                                  ;		       program, a check sum is performed on the transient
   879                                  ;		       portion to see if it must be reloaded.  Thus programs
   880                                  ;		       which do not need maximum memory will save the time
   881                                  ;		       required to reload COMMAND when they terminate.
   882                                  ;
   883                                  ; ENTRY POINT:	       PROGSTART
   884                                  ;
   885                                  ; INPUT:	       command line at offset 81H
   886                                  ;
   887                                  ; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
   888                                  ;		       from a secondary command processor via the EXIT
   889                                  ;		       internal command.
   890                                  ;
   891                                  ; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
   892                                  ;		       hang the system.
   893                                  ;
   894                                  ; INTERNAL REFERENCES:
   895                                  ;
   896                                  ;     ROUTINES:        See the COMMAND Subroutine Description Document
   897                                  ;		       (COMMAND.DOC)
   898                                  ;
   899                                  ;     DATA AREAS:      See the COMMAND Subroutine Description Document
   900                                  ;		       (COMMAND.DOC)
   901                                  ;
   902                                  ; EXTERNAL REFERENCES:
   903                                  ;
   904                                  ;      ROUTINES:       none
   905                                  ;
   906                                  ;      DATA AREAS:     none
   907                                  ;
   908                                  ;*****************************************************************************
   909                                  ;
   910                                  ;			      REVISION HISTORY
   911                                  ;			      ----------------
   912                                  ;
   913                                  ; DOS 1.00 to DOS 3.30
   914                                  ; --------------------------
   915                                  ; SEE REVISION LOG IN COPY.ASM ALSO
   916                                  ;
   917                                  ; REV 1.17
   918                                  ;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
   919                                  ;	       resident since the EXELOAD may have overwritten the transient.
   920                                  ;
   921                                  ; REV 1.18
   922                                  ;    05/21/82  IBM version always looks on drive A
   923                                  ;	       MSVER always looks on default drive
   924                                  ;
   925                                  ; REV 1.19
   926                                  ;    06/03/82  Drive spec now entered in command line
   927                                  ;    06/07/82  Added VER command (print DOS version number) and VOL command
   928                                  ;	       (print volume label)
   929                                  ;
   930                                  ; REV 1.20
   931                                  ;    06/09/82  Prints "directory" after directories
   932                                  ;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
   933                                  ;
   934                                  ; REV 1.50
   935                                  ;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
   936                                  ;	       do it right.
   937                                  ;
   938                                  ; REV 1.70
   939                                  ;	       EXEC used to fork off new processes
   940                                  ;
   941                                  ; REV 1.80
   942                                  ;	       C switch for single command execution
   943                                  ;
   944                                  ; REV 1.90
   945                                  ;	       Batch uses XENIX
   946                                  ;
   947                                  ; Rev 2.00
   948                                  ;	       Lots of neato stuff
   949                                  ;	       IBM 2.00 level
   950                                  ;
   951                                  ; Rev 2.01
   952                                  ;	       'D' switch for date time suppression
   953                                  ;
   954                                  ; Rev 2.02
   955                                  ;	       Default userpath is NUL rather than BIN
   956                                  ;		       same as IBM
   957                                  ;	       COMMAND split into pieces
   958                                  ;
   959                                  ; Rev 2.10
   960                                  ;	       INTERNATIONAL SUPPORT
   961                                  ;
   962                                  ; Rev 2.50
   963                                  ;	       all the 2.x new stuff -MU
   964                                  ;
   965                                  ; Rev 3.30     (Ellen G)
   966                                  ;	       CALL internal command (TBATCH2.ASM)
   967                                  ;	       CHCP internal command (TCMD2B.ASM)
   968                                  ;	       INT 24H support of abort, retry, ignore, and fail prompt
   969                                  ;	       @ sign suppression of batch file line
   970                                  ;	       Replaceable environment value support in batch files
   971                                  ;	       INT 2FH calls for APPEND
   972                                  ;	       Lots of PTR fixes!
   973                                  ;
   974                                  ; Beyond 3.30 to forever  (Ellen G)
   975                                  ; ----------------------
   976                                  ;
   977                                  ; A000 DOS 4.00  -	Use SYSPARSE for internal commands
   978                                  ;			Use Message Retriever services
   979                                  ;			/MSG switch for resident extended error msg
   980                                  ;			Convert to new capitalization support
   981                                  ;			Better error recovery on CHCP command
   982                                  ;			Code page file tag support
   983                                  ;			TRUENAME internal command
   984                                  ;			Extended screen line support
   985                                  ;			/P switch on DEL/ERASE command
   986                                  ;			Improved file redirection error recovery
   987                                  ;	(removed)	Improved batch file performance
   988                                  ;			Unconditional DBCS support
   989                                  ;			Volume serial number support
   990                                  ;	(removed)	COMMENT=?? support
   991                                  ;
   992                                  ; A001	PTM P20 	Move system_cpage from TDATA to TSPC
   993                                  ;
   994                                  ; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
   995                                  ;			require delimiters.
   996                                  ;
   997                                  ; A003	PTM P5,P9,P111	Included in A000 development
   998                                  ;
   999                                  ; A004	PTM P86 	Fix IF command to turn off piping before
  1000                                  ;			executing
  1001                                  ;
  1002                                  ; A005	DCR D17 	If user specifies an extension on the command
  1003                                  ;			line search for that extension only.
  1004                                  ;
  1005                                  ; A006	DCR D15 	New message for MkDir - "Directory already
  1006                                  ;			exists"
  1007                                  ;
  1008                                  ; A007	DCR D2		Change CTTY so that a write is done before XDUP
  1009                                  ;
  1010                                  ; A008	PTM P182	Change COPY to set default if invalid function
  1011                                  ;			returned from code page call.
  1012                                  ;
  1013                                  ; A009	PTM P179	Add CRLF to invalid disk change message
  1014                                  ;
  1015                                  ; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
  1016                                  ;			transient COMMAND.
  1017                                  ;
  1018                                  ; A011	DCR D130	Change redirection to overwrite an EOF mark
  1019                                  ;			before appending to a file.
  1020                                  ;
  1021                                  ; A012	PTM P189	Fix redirection error recovery.
  1022                                  ;
  1023                                  ; A013	PTM P330	Change date format
  1024                                  ;
  1025                                  ; A014	PTM P455	Fix echo parsing
  1026                                  ;
  1027                                  ; A015	PTM P517	Fix DIR problem with * vs *.
  1028                                  ;
  1029                                  ; A016	PTM P354	Fix extended error message addressing
  1030                                  ;
  1031                                  ; A017	PTM P448	Fix appending to 0 length files
  1032                                  ;
  1033                                  ; A018	PTM P566,P3903	Fix parse error messages to print out parameter
  1034                                  ;			the parser fails on. Fail on duplicate switches.
  1035                                  ;
  1036                                  ; A019	PTM P542	Fix device name to be printed correctly during
  1037                                  ;			critical error
  1038                                  ;
  1039                                  ; A020	DCR D43 	Set append state off while in DIR
  1040                                  ;
  1041                                  ; A021	PTM P709	Fix CTTY printing ascii characters.
  1042                                  ;
  1043                                  ; A022	DCR D209	Enhanced error recovery
  1044                                  ;
  1045                                  ; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
  1046                                  ;
  1047                                  ; A024	PTM P899	Fix EXTOPEN open modes.
  1048                                  ;
  1049                                  ; A025	PTM P922	Fix messages and optimize PARSE switches
  1050                                  ;
  1051                                  ; A026	DCR D191	Change redirection error recovery support.
  1052                                  ;
  1053                                  ; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
  1054                                  ;			with a carriage return.
  1055                                  ;
  1056                                  ; A028	PTM P1076	Print a blank line before printing invalid
  1057                                  ;			date and invalid time messages.
  1058                                  ;
  1059                                  ; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
  1060                                  ;			and TIME.
  1061                                  ;
  1062                                  ; A030	DCR D201	New extended attribute format.
  1063                                  ;
  1064                                  ; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
  1065                                  ;
  1066                                  ; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
  1067                                  ;
  1068                                  ; A033	PTM P1298	Fix problem with system crashes on ECHO >""
  1069                                  ;
  1070                                  ; A034	PTM P1387	Fix COPY D:fname+,, to work
  1071                                  ;
  1072                                  ; A035	PTM P1407	Fix so that >> (appending) to a device does
  1073                                  ;			do a read to determine eof.
  1074                                  ;
  1075                                  ; A036	PTM P1406	Use 69h instead of 44h to get volume serial
  1076                                  ;			so that ASSIGN works correctly.
  1077                                  ;
  1078                                  ; A037	PTM P1335	Fix COMMAND /C with FOR
  1079                                  ;
  1080                                  ; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
  1081                                  ;
  1082                                  ; A039	DCR D284	Change invalid code page tag from -1 to 0.
  1083                                  ;
  1084                                  ; A040	PTM P1787	Fix redirection to cause error when no file is
  1085                                  ;			specified.
  1086                                  ;
  1087                                  ; A041	PTM P1705	Close redirected files after internal APPEND
  1088                                  ;			executes.
  1089                                  ;
  1090                                  ; A042	PTM P1276	Fix problem of APPEND paths changes in batch
  1091                                  ;			files causing loss of batch file.
  1092                                  ;
  1093                                  ; A043	PTM P2208	Make sure redirection is not set up twice for
  1094                                  ;			CALL'ed batch files.
  1095                                  ;
  1096                                  ; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
  1097                                  ;			as an end of line character
  1098                                  ;
  1099                                  ; A045	PTM P2560	Make sure we don't lose parse, critical error,
  1100                                  ;			and extended message pointers when we EXIT if
  1101                                  ;			COMMAND /P is the top level process.
  1102                                  ;
  1103                                  ; A046	PTM P2690	Change COPY message "fn File not found" to
  1104                                  ;			"File not found - fn"
  1105                                  ;
  1106                                  ; A047	PTM P2819	Fix transient reload prompt message
  1107                                  ;
  1108                                  ; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
  1109                                  ;			when DBCS code was added.
  1110                                  ;
  1111                                  ; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
  1112                                  ;			on line.
  1113                                  ;
  1114                                  ; A050	PTM P3030	Fix TYPE to work properly on files > 64K
  1115                                  ;
  1116                                  ; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
  1117                                  ;
  1118                                  ; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
  1119                                  ;
  1120                                  ; A053	PTM P2865	Fix DIR to work in 40 column mode.
  1121                                  ;
  1122                                  ; A054	PTM P3407	Code reduction and critical error on single line
  1123                                  ;	PTM P3672	(Change to single parser exported under P3407)
  1124                                  ;
  1125                                  ; A055	PTM P3282	Reset message service variables in INT 23h to fix
  1126                                  ;			problems with breaking out of INT 24h
  1127                                  ;
  1128                                  ; A056	PTM P3389	Fix problem of environment overlaying transient.
  1129                                  ;
  1130                                  ; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
  1131                                  ;			before the "string".  EX: COMMAND /CDIR
  1132                                  ;
  1133                                  ; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
  1134                                  ;			DBCS switch.
  1135                                  ;
  1136                                  ; A059	PTM P3394	Change the TIME command to right align the display of
  1137                                  ;			the time.
  1138                                  ;
  1139                                  ; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
  1140                                  ;			messages to be disk based.  Only keep them if /MSG
  1141                                  ;			is used.
  1142                                  ;
  1143                                  ; A061	PTM P3928	Fix so that transient doesn't reload when breaking
  1144                                  ;			out of internal commands, due to substitution blocks
  1145                                  ;			not being reset.
  1146                                  ;
  1147                                  ; A062	PTM P4079	Fix segment override for fetching address of environment
  1148                                  ;			of parent copy of COMMAND when no COMSPEC exists in
  1149                                  ;			secondary copy of environment.	Change default slash in
  1150                                  ;			default comspec string to backslash.
  1151                                  ;
  1152                                  ; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
  1153                                  ;			text for critical error messages.
  1154                                  ;
  1155                                  ; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
  1156                                  ;	5/20/88 	with Microsoft product already shipped.
  1157                                  ;
  1158                                  ; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
  1159                                  ;	 5/20/88	with Microsoft product already shipped.
  1160                                  ;
  1161                                  ; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
  1162                                  ;	 5/24/88	cases; where the listing would barely fit without the
  1163                                  ;			header and space remaining.
  1164                                  ;
  1165                                  ; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
  1166                                  ;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
  1167                                  ;			environment was putting a "Z block" marker in the old
  1168                                  ;			environment.  The fix is to move to the old environment
  1169                                  ;			to the new environment before doing the SETBLOCK.
  1170                                  ;
  1171                                  ; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
  1172                                  ;        09/19/88       because the check for APPEND needed to be performed
  1173                                  ;                       before the DIR's findfirst.
  1174                                  ;
  1175                                  ; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
  1176                                  ;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
  1177                                  ;                       loading trans w/new comspec with no user change comspec.
  1178                                  ;
  1179                                  ; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
  1180                                  ;        11/05/88       Expansion of environment variables into batch line of
  1181                                  ;                       128 chars was not being counted and "%" which should be
  1182                                  ;                       ignored were being counted.
  1183                                  ;
  1184                                  ; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
  1185                                  ;        03/02/89       used.  Comspec_flag was not in protected data file be-
  1186                                  ;                       ing included in checksum and was being overwritten by
  1187                                  ;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
  1188                                  ;                       Also removed fix A069 (because flag now protected).
  1189                                  ;
  1190                                  ; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
  1191                                  ;        07/25/89       version and CSD version in U.S. date format.  Files
  1192                                  ;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
  1193                                  ;
  1194                                  ;***********************************************************************************
  1195                                  
  1196                                  ;
  1197                                  ;	Revision History
  1198                                  ;	================
  1199                                  ;
  1200                                  ;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
  1201                                  ;					at init time (date/time prompt)
  1202                                  ;
  1203                                  
  1204                                  ;
  1205                                  ;.xcref
  1206                                  ;.xlist
  1207                                  ;	include dossym.inc		; basic DOS symbol set
  1208                                  ;	include syscall.inc		; DOS function names
  1209                                  ;	include comsw.asm		; build version info
  1210                                  ;	include comequ.asm		; common command.com symbols
  1211                                  ;	include resmsg.equ		; resident message names
  1212                                  ;
  1213                                  ;	include comseg.asm		;segment ordering
  1214                                  ;.list
  1215                                  ;.cref
  1216                                  
  1217                                  ;CODERES segment public byte
  1218                                  ;CODERES ends
  1219                                  ;
  1220                                  ;DATARES 	segment public byte
  1221                                  ;		extrn	AccDen:byte
  1222                                  ;		extrn	Batch:word
  1223                                  ;		extrn	EchoFlag:byte
  1224                                  ;		extrn	ExeBad:byte
  1225                                  ;		extrn	ExecEMes:byte
  1226                                  ;		extrn	ExecErrSubst:byte
  1227                                  ;		extrn	ExtCom:byte
  1228                                  ;		extrn	ForFlag:byte
  1229                                  ;		extrn	IfFlag:byte
  1230                                  ;		extrn	InitFlag:BYTE
  1231                                  ;		extrn	Nest:word
  1232                                  ;		extrn	PipeFlag:byte
  1233                                  ;		extrn	RBadNam:byte
  1234                                  ;		extrn	RetCode:word
  1235                                  ;		extrn	SingleCom:word
  1236                                  ;		extrn	TooBig:byte
  1237                                  ;
  1238                                  ;		extrn	OldDS:word
  1239                                  ;
  1240                                  ;DATARES 	ends
  1241                                  ;
  1242                                  ;
  1243                                  ;INIT		segment public para
  1244                                  ;		extrn	ConProc:near
  1245                                  ;		extrn	Init_Contc_SpecialCase:near
  1246                                  ;INIT		ends
  1247                                  
  1248                                  ; 09/01/2023 - Erdogan Tan - Istanbul
  1249                                  ; --------------------------------------
  1250                                  ; 'command5.s' source code reference(s):
  1251                                  
  1252                                  ;	1) MSDOS 6.0 COMMAND.COM source files
  1253                                  ;	2) Disassembled MSDOS 5.0 COMMAND.COM - 11/11/1991 - 47845 bytes  
  1254                                  ;	   (Disassembler: HEX-RAYS IDA Pro Freeware Version 5.0)
  1255                                  ; ----------------------------------------------------------------------				 	 	
  1256                                  
  1257                                  ; -----------------------------------------------------------------------------
  1258                                  ; START OF RESIDENT PORTION
  1259                                  ; -----------------------------------------------------------------------------
  1260                                  ; SEGMENT - DATARES
  1261                                  ; -----------------------------------------------------------------------------
  1262                                  
  1263                                  section .RESGROUP ; vstart=100h  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) 
  1264                                  
  1265                                  ; 09/01/2023 - Retro DOS v4.0 (Modified COMMAND.COM v5.0)
  1266                                  
  1267                                  ;==============================================================================
  1268                                  ; STUB.ASM - MSDOS 6.0 - 1991
  1269                                  ;==============================================================================
  1270                                  
  1271                                  ;This file contains the low memory stub for command.com which hooks all the
  1272                                  ;entry points into the resident command.com and directs the calls to the
  1273                                  ;appropriate routines in the resident code which may be located in HIMEM. 
  1274                                  ;
  1275                                  ;The stub has been made part of the resident data and will always
  1276                                  ;be duplicated on every invocation of command.com. However, the only stubs
  1277                                  ;that actually hook the interrupt vectors belong to either the first 
  1278                                  ;command.com or to any other command.com executed with the /p switch. 
  1279                                  ;
  1280                                  ;The stub also keeps track of the current active data segment. The 
  1281                                  ;INIT code of each command.com updates this variable via an int 2fh mechanism
  1282                                  ;with its own data segment. The INIT code also updates a pointer in its data
  1283                                  ;segment to the previous resident data segment. Whenever a command.com exits,
  1284                                  ;the exit code picks up the previous data segment pointer from the current
  1285                                  ;data segment and patches it into the CurResDataSeg variable in the stub.
  1286                                  ;
  1287                                  ;Right now the stub does not bother about A20 switching. We assume
  1288                                  ;A20 is always on. It just does a far jump to the resident code with the 
  1289                                  ;value of the current data segment in one of the registers. A20 toggle 
  1290                                  ;support maybe added as a future enhancement, if the need is felt.
  1291                                  
  1292                                  	; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1293                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  1294                                  
  1295                                  	[ORG 100H]
  1296                                  
  1297                                  	; 21/09/2018 - Retro DOS v3.0
  1298                                  StartCode:
  1299 00000000 E9BD14                  	jmp	ConProc	; 10/01/2023 
  1300                                  
  1301                                  	; 09/01/2023
  1302                                  
  1303                                  ; Make following table word-aligned, and at the same time, provide a
  1304                                  ; signature that sysinit can use to (attempt to) validate the interpreter
  1305                                  
  1306                                  	;db	0	; MSDOS 5.0 COMMAND.COM - DATARESRES:0103h
  1307 00000003 66                      	db      ((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
  1308                                  
  1309                                  ;All the entry points declared below are patched in at INIT time with the
  1310                                  ;proper segment and offset values after the resident code segment has been
  1311                                  ;moved to its final location
  1312                                  
  1313                                  ;!!!WARNING!!!
  1314                                  ; All the dword ptrs from Int2f_Entry till MsgRetrv_Entry should be contiguous
  1315                                  ;because the init routine 'Patch_stub' (in init.asm) relies on this to patch
  1316                                  ;in the correct segments and offsets
  1317                                  
  1318                                  Int2f_Entry:
  1319 00000004 [D813]                  	dw	MsgInt2fHandler		; Address of int 2fh handler
  1320 00000006 0000                    	dw	0
  1321                                  Int2e_Entry:
  1322 00000008 [340E]                  	dw	Int_2e			; Address of int 2eh handler
  1323 0000000A 0000                    	dw	0
  1324                                  Ctrlc_Entry:
  1325 0000000C [F30C]                  	dw	ContC			; Address of Ctrl-C handler
  1326 0000000E 0000                    	dw	0
  1327                                  CritErr_Entry:
  1328 00000010 [F510]                  	dw	DSKERR			; Address of critical error handler
  1329 00000012 0000                    	dw	0
  1330                                  
  1331                                  Exec_Entry:
  1332 00000014 00000000                	dd	0			; Entry from transient to Ext_Exec
  1333                                  RemCheck_Entry:
  1334 00000018 00000000                	dd	0			; Entry from transient to TRemCheck
  1335                                  TrnLodCom1_Entry:
  1336 0000001C 00000000                	dd	0			; Entry from transient to LodCom1
  1337                                  LodCom_Entry:
  1338 00000020 00000000                	dd	0			; Entry after exit from command.com
  1339                                  MsgRetrv_Entry:
  1340 00000024 00000000                	dd	0			; Entry from external to MsgRetriever
  1341                                  HeadFix_Entry:
  1342 00000028 00000000                	dd	0			; Entry from trans to HeadFix
  1343                                  UMBOff_Entry:
  1344 0000002C 00000000                	dd	0			; Entry from here to UMBOff routine; M003
  1345                                  XMMCallAddr:
  1346 00000030 00000000                	dd	0			; Call address for XMM functions
  1347                                  ComInHMA:
  1348 00000034 00                      	db	0			; Flags if command.com in HMA
  1349                                  
  1350                                  Int2f_Trap:
  1351                                  	;sti	; 19/04/2023 (MSDOS 5.0 COMMAND.COM - RESGROUP:0135h)
  1352 00000035 E86400                  	call	CheckA20
  1353 00000038 1E                      	push	ds			; push current ds value
  1354 00000039 0E                      	push	cs			; push resident data segment value
  1355                                  	;jmp	cs:Int2f_Entry
  1356 0000003A 2EFF2E[0400]            	jmp	far [cs:Int2f_Entry]
  1357                                  
  1358                                  Int2e_Trap:
  1359 0000003F FB                      	sti
  1360 00000040 E85900                  	call	CheckA20
  1361 00000043 1E                      	push	ds			; push current ds value
  1362 00000044 0E                      	push	cs			; push resident data segment value
  1363                                  	;jmp	cs:Int2e_Entry
  1364 00000045 2EFF2E[0800]            	jmp	far [cs:Int2e_Entry]
  1365                                  
  1366                                  Ctrlc_Trap:
  1367 0000004A FB                      	sti
  1368 0000004B E84E00                  	call	CheckA20
  1369 0000004E 1E                      	push	ds			; push current ds value
  1370 0000004F 0E                      	push	cs			; push resident data segment value
  1371                                  	;jmp	cs:Ctrlc_Entry
  1372 00000050 2EFF2E[0C00]            	jmp	far [cs:Ctrlc_Entry]
  1373                                  
  1374                                  CritErr_Trap:
  1375 00000055 FB                      	sti
  1376 00000056 E84300                  	call	CheckA20
  1377 00000059 1E                      	push	ds			; push current ds value
  1378 0000005A 0E                      	push	cs			; push resident data segment value
  1379                                  	;jmp	cs:CritErr_Entry
  1380 0000005B 2EFF2E[1000]            	jmp	far [cs:CritErr_Entry]
  1381                                  
  1382                                  Exec_Trap:
  1383 00000060 E83900                  	call	CheckA20
  1384 00000063 1E                      	push	ds			; push current ds value
  1385 00000064 0E                      	push	cs			; push resident data segment value
  1386                                  	;jmp	cs:Exec_Entry
  1387 00000065 2EFF2E[1400]            	jmp	far [cs:Exec_Entry]
  1388                                  
  1389                                  RemCheck_Trap:
  1390 0000006A E82F00                  	call	CheckA20
  1391 0000006D 1E                      	push	ds			; push current ds value
  1392 0000006E 0E                      	push	cs			; push resident data segment value
  1393                                  	;jmp	cs:RemCheck_Entry
  1394 0000006F 2EFF2E[1800]            	jmp	far [cs:RemCheck_Entry]
  1395                                  
  1396                                  TrnLodCom1_Trap:
  1397 00000074 E82500                  	call	CheckA20
  1398 00000077 1E                      	push	ds			; push current ds value
  1399 00000078 0E                      	push	cs			; push resident data segment value
  1400                                  	;jmp	cs:TrnLodCom1_Entry
  1401 00000079 2EFF2E[1C00]            	jmp	far [cs:TrnLodCom1_Entry]
  1402                                  
  1403                                  LodCom_Trap:
  1404 0000007E E81B00                  	call	CheckA20
  1405 00000081 1E                      	push	ds			; push current ds value
  1406 00000082 0E                      	push	cs			; push resident data segment value
  1407                                  	;jmp	cs:LodCom_Entry
  1408 00000083 2EFF2E[2000]            	jmp	far [cs:LodCom_Entry]
  1409                                  
  1410                                  MsgRetrv_Trap:
  1411 00000088 E81100                  	call	CheckA20
  1412 0000008B 1E                      	push	ds			; push current ds value
  1413 0000008C 0E                      	push	cs			; push resident data segment value
  1414                                  	;jmp	cs:MsgRetrv_Entry
  1415 0000008D 2EFF2E[2400]            	jmp	far [cs:MsgRetrv_Entry]
  1416                                  
  1417                                  HeadFix_Trap:
  1418 00000092 E80700                  	call	CheckA20
  1419 00000095 1E                      	push	ds			; push current ds value
  1420 00000096 0E                      	push	cs			; push resident data segment value
  1421                                  	;jmp	cs:HeadFix_Entry
  1422 00000097 2EFF2E[2800]            	jmp	far [cs:HeadFix_Entry]
  1423                                  
  1424                                  ; ----------------------------------------------------------------------------
  1425                                  
  1426                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM
  1427                                  %if 0
  1428                                  	; 09/01/2023
  1429                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:019Dh
  1430                                  
  1431                                  	; 05/06/2023
  1432                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:019Ch
  1433                                  CheckA20:
  1434                                  	pushf				; save current flags
  1435                                  	cmp	byte [cs:ComInHMA],0	; is resident in HMA?
  1436                                  	jz	short A20_on		; no, jump to resident
  1437                                  
  1438                                  	call	QueryA20
  1439                                  	jnc	short A20_on		; A20 is on, jump to resident
  1440                                  
  1441                                  	call	EnableA20		; turn A20 on
  1442                                  A20_on:
  1443                                  	popf				; flags have to be unchanged
  1444                                  	retn
  1445                                  %else
  1446                                  	; 18/07/2024
  1447                                  	XMM_QUERY_A20 equ 7 ; 09/01/2023
  1448                                  	XMM_LOCAL_ENABLE_A20 equ 5
  1449                                  	; PCDOS 7.1 COMMAND.COM - RESGROUP:01FFh
  1450                                  CheckA20:
  1451 0000009C 9C                      	pushf				; save current flags
  1452 0000009D 2E803E[3400]00          	cmp	byte [cs:ComInHMA],0	; is resident in HMA?
  1453 000000A3 741A                    	jz	short A20_on		; no, jump to resident
  1454                                  	; 18/07/2024
  1455 000000A5 50                      	push	ax
  1456 000000A6 53                      	push	bx
  1457                                  QueryA20:
  1458                                  	;mov	ah,7
  1459 000000A7 B407                    	mov	ah,XMM_QUERY_A20
  1460                                  	;call	cs:XMMCallAddr
  1461 000000A9 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1462 000000AE 09C0                    	or	ax,ax
  1463                                  	; 16/04/2023
  1464 000000B0 750B                    	jnz	short QA20_ON		; A20 is on, jump to resident
  1465                                  	; 18/07/2024
  1466                                  EnableA20:
  1467                                  	;mov	ah,5
  1468 000000B2 B405                    	mov	ah,XMM_LOCAL_ENABLE_A20	; turn A20 on
  1469                                  	;call	cs:XMMCallAddr
  1470 000000B4 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1471 000000B9 09C0                    	or	ax,ax
  1472 000000BB 7404                    	jz	short XMMerror		; AX = 0 fatal error
  1473                                  QA20_ON:
  1474 000000BD 5B                      	pop	bx
  1475 000000BE 58                      	pop	ax
  1476                                  A20_on:
  1477 000000BF 9D                      	popf				; flags have to be unchanged
  1478 000000C0 C3                      	retn
  1479                                  ;If we get an error, we just loop forever
  1480                                  XMMerror:
  1481 000000C1 EBFE                    	jmp	short XMMerror
  1482                                  %endif
  1483                                  
  1484                                  ; ----------------------------------------------------------------------------
  1485                                  
  1486                                  ; M005; This is a far jump to the actual int 2fh entry point. The renormalized
  1487                                  ; M005; int 2fh cs:ip points here. We hardcode a far jump here to the int 2fh
  1488                                  ; M005; handler. Note that we have to hardcode a jump and we cannot use any
  1489                                  ; M005; pointers because our cs is going to be different. The segment to
  1490                                  ; M005; jump to is patched in at init time. (in init.asm)
  1491                                  
  1492                                  Carousel_i2f_Hook:			; M005
  1493 000000C3 EA                      	db	0EAh			; far jump opcode; M005
  1494 000000C4 [3500]                  	dw	Int2f_Trap ; DATARES	; int 2fh offset ; M005
  1495 000000C6 0000                    	dw	0			; int 2fh segment; M005
  1496                                  
  1497                                  ; ----------------------------------------------------------------------------
  1498                                  
  1499                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM
  1500                                  %if 0
  1501                                  	XMM_QUERY_A20 equ 7 ; 09/01/2023
  1502                                  QueryA20:
  1503                                  	push	bx
  1504                                  	push	ax
  1505                                  	;mov	ah,7
  1506                                  	mov	ah,XMM_QUERY_A20
  1507                                  	;call	cs:XMMCallAddr
  1508                                  	call	far [cs:XMMCallAddr]
  1509                                  	or	ax,ax
  1510                                  	pop	ax
  1511                                  	pop	bx
  1512                                  	; 16/04/2023
  1513                                  	jnz	short QA20_ON	; cf = 0	; AX = 1 => ON
  1514                                  	stc					; OFF
  1515                                  	;retn
  1516                                  QA20_ON:
  1517                                  	;clc					; ON
  1518                                  	retn
  1519                                  %endif
  1520                                  
  1521                                  ; ----------------------------------------------------------------------------
  1522                                  
  1523                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM
  1524                                  %if 0
  1525                                  	XMM_LOCAL_ENABLE_A20 equ 5
  1526                                  EnableA20:
  1527                                  	push	bx
  1528                                  	push	ax
  1529                                  	;mov	ah,5
  1530                                  	mov	ah,XMM_LOCAL_ENABLE_A20
  1531                                  	;call	cs:XMMCallAddr
  1532                                  	call	far [cs:XMMCallAddr]
  1533                                  	or	ax,ax
  1534                                  	jz	short XMMerror			; AX = 0 fatal error
  1535                                  	pop	ax
  1536                                  	pop	bx
  1537                                  	retn
  1538                                  ;If we get an error, we just loop forever
  1539                                  XMMerror:
  1540                                  	jmp	short XMMerror
  1541                                  %endif
  1542                                  
  1543                                  ; -----------------------------------------------------------------------------
  1544                                  
  1545                                  ; 05/06/2023
  1546                                  ;HV_Extern	equ	1
  1547                                  ;HV_LoadHigh	equ	1
  1548                                  ;HV_Stub	equ	1
  1549                                  ;	include	highvar.inc	; Make high-memory variables external here
  1550                                  ;	include	highexit.inc	; And add code for UnHideUMBs
  1551                                  
  1552                                  ;==============================================================================
  1553                                  ; HIGHEXIT.INC, MSDOS 6.0, 1992
  1554                                  ;==============================================================================
  1555                                  ; 05/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
  1556                                  
  1557                                  DOS_STRATEGY_GET equ  5800h	; Int 21h, Func 58h, Svc 0 = get alloc strategy
  1558                                  DOS_STRATEGY_SET equ  5801h	; Int 21h, Func 58h, Svc 1 = set alloc strategy
  1559                                  DOS_UMBLINK_GET	equ   5802h	; Int 21h, Func 58h, Svc 2 = get link state
  1560                                  DOS_UMBLINK_SET	equ   5803h	; Int 21h, Func 58h, Svc 3 = set link state
  1561                                  DOS_GET_LISTS	equ     52h	; Int 21h, Func 52h = get list of lists
  1562                                  
  1563                                  UMB_HeadIdx	equ     8Ch	; Offset from ES (after func52h) to get UMBHead
  1564                                  
  1565                                  	; 05/06/2023
  1566                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:01D9h
  1567                                  
  1568                                  ; -----------------------------------------------------------------------------
  1569                                  ;*** UnHideUMBs - Marks HIDDEN elements as FREE
  1570                                  ; -----------------------------------------------------------------------------
  1571                                  ; ENTRY:  None; perhaps, earlier, HideUMBs was called... if not, we have
  1572                                  ;               very little to do, as no elelments will be marked as HIDDEN.
  1573                                  ; EXIT:   Sets InHigh to zero; carry clear if HideUMBs was called earlier.
  1574                                  ; ERROR:  None
  1575                                  ; USES:   fInHigh (from highvar.inc), carry flag
  1576                                  ; -----------------------------------------------------------------------------
  1577                                  
  1578                                  UnHideUMBs:
  1579 000000C8 50                      	push	ax		; Save ax for what we're about to do
  1580                                  
  1581                                  ; -----------------------------------------------------------------------------
  1582                                  ; BUGBUG t-richj 11-8-92: The following six lines were commented out for a good
  1583                                  ;    length of time. Those six constitute a check of whether or not we should
  1584                                  ;    indeed clean up the upper-memory chain; without such a check, COMMAND.COM
  1585                                  ;    will destroy the current link-state and memory-allocation strategy after
  1586                                  ;    every command execution.
  1587                                  ; -----------------------------------------------------------------------------
  1588                                  
  1589                                  	; 05/06/2023
  1590                                  	;getdata al,fInHigh	; Get InHigh from data segment
  1591                                  	;
  1592                                  	;push	ds
  1593 000000C9 A0[D804]                	mov	al,[fInHigh]
  1594                                  	;pop	ds
  1595                                  
  1596                                  	;or	al, al
  1597                                  	;jnz	short uhu10	; If didn't call loadhigh/devicehigh earlier,
  1598                                  
  1599                                  	;pop	ax		; then there's nothing to do here... so
  1600                                  	;stc			; restore everything and return.  Just like
  1601                                  	;retn			; that.
  1602                                  
  1603                                  	; 05/06/2023
  1604 000000CC 3C01                    	cmp	al,1
  1605 000000CE 720F                    	jb	short uhu20	; cf=1
  1606                                  uhu10:	
  1607 000000D0 E8A000                  	call	linkumb		; Make sure UMBs are linked in.
  1608 000000D3 E82000                  	call	FreeUMBs
  1609                                  
  1610                                  	;putdata fInHigh, 0	; We're leaving, so update fInHigh.
  1611                                  	;
  1612                                  	;push	es
  1613                                  	;mov	byte [es:fInHigh],0
  1614                                  	;pop	es
  1615                                  	; 05/06/2023
  1616 000000D6 C606[D804]00            	mov	byte [fInHigh],0
  1617                                  
  1618 000000DB E80300                  	call	he_unlink	; Unlink UMBs
  1619                                  
  1620                                  	;pop	ax
  1621                                  	;clc
  1622                                  	;retn
  1623                                  
  1624 000000DE F8                      	clc
  1625                                  uhu20:
  1626 000000DF 58                      	pop	ax
  1627 000000E0 C3                      	retn
  1628                                  
  1629                                  ; -----------------------------------------------------------------------------
  1630                                  ;*** he_unlink - unlinks UMBs if fm_umb is set to 0
  1631                                  ; -----------------------------------------------------------------------------
  1632                                  ; ENTRY:    fm_umb == 1 : leave linked, else unlink
  1633                                  ; EXIT:     None
  1634                                  ; ERROR:    None
  1635                                  ; USES:     AX, BX
  1636                                  ; -----------------------------------------------------------------------------
  1637                                  
  1638                                  	; 05/06/2023
  1639                                  he_unlink:
  1640 000000E1 30FF                    	xor	bh, bh
  1641                                  	
  1642                                  	;getdata bl,fm_umb		; Restore original link-state
  1643                                  	;
  1644                                  	;push	ds
  1645 000000E3 8A1E[DD04]              	mov     bl,[fm_umb]
  1646                                  	;pop	ds
  1647                                  
  1648 000000E7 B80358                  	mov	ax,DOS_UMBLINK_SET ; 5803h
  1649 000000EA CD21                    	int	21h
  1650                                  
  1651                                  	;xor	bh, bh
  1652                                  	
  1653                                  	;getdata bl,fm_strat		; Restore original mem-alloc strategy
  1654                                  	;push	ds
  1655 000000EC 8A1E[DE04]              	mov     bl,[fm_strat]
  1656                                  	;pop	ds
  1657                                  
  1658 000000F0 B80158                  	mov	ax,DOS_STRATEGY_SET ; 5801h
  1659 000000F3 CD21                    	int	21h
  1660                                  
  1661 000000F5 C3                      	retn
  1662                                  
  1663                                  ; -----------------------------------------------------------------------------
  1664                                  ;*** freeUMBs - frees all HIDDEN memory elements in upper-memory.
  1665                                  ; -----------------------------------------------------------------------------
  1666                                  ; ENTRY:    None
  1667                                  ; EXIT:     None; HIDDEN memory elements returned to FREE
  1668                                  ; ERROR:    None (ignore CF)
  1669                                  ; USES:     Flags
  1670                                  ; -----------------------------------------------------------------------------
  1671                                  
  1672                                  	; 05/06/2023
  1673                                  arena_signature_end equ 5Ah ; 'Z'
  1674                                  arena_signature equ 0
  1675                                  arena_size equ 3
  1676                                  
  1677                                  FreeUMBs:
  1678 000000F6 50                      	push	ax
  1679 000000F7 06                      	push	es
  1680                                  
  1681 000000F8 E86900                  	call	HeadUmb		; Returns with carry if err, else ES == MCB
  1682 000000FB 721C                    	jc	short fusX
  1683                                  fus10:
  1684 000000FD 8EC0                    	mov	es,ax		; Prepare for the loop; ES = current MCB addr.
  1685 000000FF E81A00                  	call	isHideMCB	; Returns with ZF set if owner is 0
  1686 00000102 7503                    	jnz	short fus20
  1687 00000104 E84200                  	call	freeMCB
  1688                                  fus20:	
  1689 00000107 26A00000                	mov	al,[es:arena_signature] ; mov al,[es:0]
  1690 0000010B 3C5A                    	cmp	al,arena_signature_end ; 'Z' ; 5Ah
  1691 0000010D 740A                    	jz	short fusX	; That means this was the last MCB--that's it.
  1692                                  
  1693 0000010F 8CC0                    	mov	ax,es
  1694 00000111 2603060300              	add	ax,[es:arena_size] ; add ax,[es:3]
  1695 00000116 40                      	inc	ax
  1696                                  	;mov	es,ax		; Go on forward.
  1697                                  	;jmp	short fus10
  1698                                  	; 18/07/2024
  1699 00000117 EBE4                    	jmp	short fus10
  1700                                  fusX:
  1701 00000119 07                      	pop	es
  1702 0000011A 58                      	pop	ax
  1703 0000011B C3                      	retn
  1704                                  
  1705                                  ; -----------------------------------------------------------------------------
  1706                                  ;*** isHideMCB - returns with ZF set if current MCB (ES:0) is HIDDEN
  1707                                  ; -----------------------------------------------------------------------------
  1708                                  ; ENTRY:    ES:0 should point to an MCB
  1709                                  ; EXIT:     ZF set if MCB is hidden, else !ZF
  1710                                  ; ERROR:    None
  1711                                  ; USES:     Flags
  1712                                  ; -----------------------------------------------------------------------------
  1713                                  
  1714                                  	; 05/06/2023
  1715                                  SystemPSPOwner	equ 8
  1716                                  arena_owner	equ 1
  1717                                  arena_name	equ 8
  1718                                  
  1719                                  isHideMCB:
  1720 0000011C 50                      	push	ax
  1721                                  
  1722 0000011D 26833E010008            	cmp	word [es:arena_owner],SystemPSPOwner ; If the owner's SYSTEM
  1723 00000123 7522                    	jne	short ihm_x			     ; then check for HIDDEN
  1724                                  
  1725 00000125 26A10800                	mov	ax,[es:arena_name]   ; [es:8]
  1726 00000129 3D4849                  	cmp	ax,'HI' ; 4948h
  1727 0000012C 7519                    	jne	short ihm_x
  1728 0000012E 26A10A00                	mov	ax,[es:arena_name+2] ; [es:10]
  1729 00000132 3D4444                  	cmp	ax,'DD' ; 4444h
  1730 00000135 7510                    	jne	short ihm_x
  1731 00000137 26A10C00                	mov	ax,[es:arena_name+4] ; [es:12]
  1732 0000013B 3D454E                  	cmp	ax,'EN' ; 4E45h
  1733 0000013E 7507                    	jne	short ihm_x
  1734 00000140 26A10E00                	mov	ax,[es:arena_name+6] ; [es:14]
  1735 00000144 3D2020                  	cmp	ax,'  ' ; 2020h
  1736                                  ihm_x:
  1737 00000147 58                      	pop	ax
  1738 00000148 C3                      	retn
  1739                                  
  1740                                  ; -----------------------------------------------------------------------------
  1741                                  ;*** freeMCB - marks as free the MCB at ES:0
  1742                                  ; -----------------------------------------------------------------------------
  1743                                  ; ENTRY:    ES:0 should point to an MCB
  1744                                  ; EXIT:     None; MCB free'd
  1745                                  ; ERROR:    None
  1746                                  ; USES:     AX
  1747                                  ; -----------------------------------------------------------------------------
  1748                                  
  1749                                  	; 05/06/2023
  1750                                  freeMCB:
  1751 00000149 26C70601000000          	mov	word [es:arena_owner],0	; [es:1]
  1752 00000150 B82020                  	mov	ax,'  '
  1753 00000153 26A30800                	mov	[es:arena_name+0],ax	; [es:8]
  1754 00000157 26A30A00                	mov	[es:arena_name+2],ax
  1755 0000015B 26A30C00                	mov	[es:arena_name+4],ax
  1756 0000015F 26A30E00                	mov	[es:arena_name+6],ax	; [es:14]
  1757 00000163 C3                      	retn
  1758                                  
  1759                                  ; -----------------------------------------------------------------------------
  1760                                  ;*** HeadUmb - returns in AX the address of the first UMB block (0x9FFF)
  1761                                  ; -----------------------------------------------------------------------------
  1762                                  ; ENTRY:  Nothing
  1763                                  ; EXIT:   AX contains 0x9FFF for most systems
  1764                                  ; ERROR:  Carry set if pointer is 0xFFFF (if not set up yet--DH runs into this)
  1765                                  ; USES:   Flags, AX
  1766                                  ; -----------------------------------------------------------------------------
  1767                                  
  1768                                  	; 05/06/2023
  1769                                  HeadUmb:
  1770                                  	; 18/07/2024 - PCDOS 7.1 - RESGROUP:02CDh
  1771                                  	;push	si
  1772                                  	;push	ds
  1773 00000164 06                      	push	es
  1774                                  
  1775 00000165 B452                    	mov	ah,DOS_GET_LISTS	; Call int 21h, function 52h...
  1776 00000167 CD21                    	int	21h	; DOS - 2+ internal - GET LIST OF LISTS
  1777                                  			; Return: ES:BX -> DOS list of lists
  1778                                  
  1779 00000169 26A18C00                	mov	ax,[es:UMB_HeadIdx]	; And read what's in ES:008Ch
  1780 0000016D 83F8FF                  	cmp	ax,0FFFFh
  1781                                  	;je	short xhu_e		; If it's 0xFFFF, it's an error...
  1782                                  	;clc				; Else, it isn't.
  1783                                  	;jmp	short xhu_x
  1784                                  ;xhu_e:
  1785                                  	;stc
  1786                                  	; 05/06/2023
  1787 00000170 F5                      	cmc	; cf=0 -> cf=1
  1788                                  ;xhu_x:
  1789 00000171 07                      	pop	es
  1790                                  	; 18/07/2024
  1791                                  	;pop	ds
  1792                                  	;pop	si
  1793 00000172 C3                      	retn
  1794                                  
  1795                                  ; -----------------------------------------------------------------------------
  1796                                  ;*** linkumb - links UMBs not already linked in; updates fm_umb as needed
  1797                                  ; -----------------------------------------------------------------------------
  1798                                  ; ENTRY:    None
  1799                                  ; EXIT:     fm_umb == 0 if not linked in previously, 1 if already linked in
  1800                                  ; ERROR:    None
  1801                                  ; USES:     AX, BX, fm_umb
  1802                                  ; -----------------------------------------------------------------------------
  1803                                  
  1804                                  	; 05/06/2023
  1805                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:029Dh
  1806                                  linkumb:
  1807 00000173 B80258                  	mov	ax,DOS_UMBLINK_GET ; 5802h
  1808 00000176 CD21                    	int	21h			; Current link-state is now in al
  1809                                  
  1810 00000178 08C0                    	or	al,al			; BUGBUG: proper check?
  1811 0000017A 7508                    	jnz	short lumbX		; Jumps if UMBs already linked in
  1812                                  
  1813 0000017C B80358                  	mov	ax,DOS_UMBLINK_SET ; 5803h
  1814 0000017F BB0100                  	mov	bx,1
  1815 00000182 CD21                    	int	21h
  1816                                  lumbX:
  1817 00000184 C3                      	retn
  1818                                  
  1819                                  ;==============================================================================
  1820                                  ; STUB.ASM, MSDOS 6.0, 1991
  1821                                  ;==============================================================================
  1822                                  ; 05/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
  1823                                  
  1824                                  	; 09/01/2023 - Retro DOS v4.0 (& 4.1)
  1825                                  	; 05/06/2023 - Retro DOS 4.2
  1826                                  
  1827                                  ;The Exec call has to be issued from the data segment. The reason for this 
  1828                                  ;is TSRs. When a TSR does a call to terminate and stay resident, the call
  1829                                  ;returns with all registers preserved and so all our segment registers are
  1830                                  ;still set up. However, if the TSR unloads itself later on, it still 
  1831                                  ;comes back here. In this case the segment registers and the stack are
  1832                                  ;not set up and random things can happen. The only way to setup all the 
  1833                                  ;registers is to use the cs value and this can only be done when we are in
  1834                                  ;the data segment ourselves. So, this piece of code had to be moved from
  1835                                  ;the code segment to the data segment.
  1836                                  
  1837                                  	; MSDOS 6.22 COMMAND.COM RESGROUP:02AFh
  1838                                  Issue_Exec_Call:
  1839 00000185 CD21                    	int 	21h
  1840                                  
  1841                                  ;We disable interrupts while changing the stack because there is a bug in 
  1842                                  ;some old 8088 processors where interrupts are let through while ss & sp
  1843                                  ;are being changed.
  1844                                  
  1845 00000187 FA                      	cli
  1846 00000188 0E                      	push	cs
  1847 00000189 17                      	pop	ss
  1848                                  
  1849                                  	;;mov	sp,53Eh ; MSDOS 5.0 COMMAND.COM RESGROUP:01DFh
  1850                                  	;mov	sp,60Ah	; MSDOS 6.22 COMMAND.COM RESGROUP:02B4h
  1851                                  	;mov	sp,offset DATARES:RStack ; stack is set up
  1852 0000018A BC[D604]                	mov	sp,RStack		; stack is set up
  1853                                  
  1854                                  ; 05/06/2023	
  1855                                  %if 0	
  1856                                  	; 20/04/2023
  1857                                  	;sti
  1858                                  	;push	cs
  1859                                  	;pop	ds			; ds = DATARES
  1860                                  
  1861                                  ; M009; Restore UMB state to that before Exec
  1862                                  
  1863                                  	;pushf				;    This call frees HIDDEN umb's,
  1864                                  	;call	UnHideUMBs		; <- restores the memory-allocation
  1865                                  	;popf				;    strategy and link state, as app.
  1866                                  
  1867                                  	; 09/01/2023 - Retro DOS v4.0
  1868                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:01E2h
  1869                                  	; ----------------------
  1870                                  	sti
  1871                                  	push    cs
  1872                                  	pop     ds
  1873                                  	pushf
  1874                                  	;mov	al,[cs:fInHigh]
  1875                                  	; 18/04/2023
  1876                                  	mov	al,[fInHigh]
  1877                                  	test	al,80h
  1878                                  	jz      short uhu10
  1879                                  	and     al,7Fh
  1880                                  	;;call	cs:UMBOff_Entry
  1881                                  	;call	far [cs:UMBOff_Entry]
  1882                                  	call	far [UMBOff_Entry]
  1883                                  uhu10:
  1884                                  	;and	byte [cs:fInHigh],7Fh
  1885                                  	; 18/04/2023
  1886                                  	and	byte [fInHigh],7Fh
  1887                                  	popf
  1888                                  	; ----------------------
  1889                                  
  1890                                  %endif
  1891                                  	; 05/06/2023 - Retro DOS 4.2
  1892                                  	; MSDOS 6.22 COMMAND.COM RESGROUP:02B7h
  1893 0000018D FB                      	sti
  1894 0000018E 0E                      	push	cs
  1895 0000018F 1F                      	pop	ds			; ds = DATARES
  1896                                  
  1897                                  ; M009; Restore UMB state to that before Exec
  1898                                  
  1899 00000190 9C                      	pushf				;    This call frees HIDDEN umb's,
  1900 00000191 E834FF                  	call	UnHideUMBs		; <- restores the memory-allocation
  1901 00000194 9D                      	popf				;    strategy and link state, as app
  1902                                  
  1903                                  ;We now jump to the stub trap which returns us to the resident code. All
  1904                                  ;flags are preserved by the stub code.
  1905                                  
  1906 00000195 E9C8FE                  	jmp	Exec_Trap
  1907                                  
  1908                                  ;==============================================================================
  1909                                  ; RDATA.ASM, MSDOS 6.0, 1992
  1910                                  ;==============================================================================
  1911                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1912                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  1913                                  
  1914                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:02C2h (DATARES:02C2h) (*)
  1915                                  ; -----------------------------------------------------------------------------
  1916 00000198 636F78                  cox_location:	db 'cox' ; (*)	
  1917 0000019B 0000                    cox_Y_option:	dw 0     ; (*)
  1918                                  ; -----------------------------------------------------------------------------
  1919                                  
  1920                                  ;***	Message substitution blocks
  1921                                  
  1922                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:01FFh (DATARES:01FFh)
  1923                                  
  1924                                  ;BlkDevErrSubst	label	byte
  1925                                  ;BlkDevErrRw	subst	<STRING,>		; "reading" or "writing"
  1926                                  ;		subst	<CHAR,DATARES:DrvLet>	; block device drive letter
  1927                                  
  1928 0000019D 02                      BlkDevErrSubst: db	2
  1929 0000019E 0000                    BlkDevErrRw:	dw	0
  1930 000001A0 01                      		db	1
  1931 000001A1 [A301]                  		dw	DrvLet
  1932                                  
  1933 000001A3 41                      DrvLet:		db	'A'			; drive letter
  1934                                  
  1935                                  
  1936                                  ;CharDevErrSubst label	byte
  1937                                  ;CharDevErrRw	subst	<STRING,>		 ; "reading" or "writing"
  1938                                  ;CharDevErrDev	subst	<STRING,DATARES:DevName> ; character device name
  1939                                  
  1940 000001A4 02                      CharDevErrSubst: db	2
  1941 000001A5 0000                    CharDevErrRw:	dw	0
  1942 000001A7 02                      		db	2
  1943 000001A8 [B601]                  		dw	DevName
  1944                                  
  1945                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM - RESGROUP:0318h
  1946                                  ;DevName:	times 8 db 0  ; db 8 dup (?),0	; device name, asciiz
  1947                                  ;		db	0
  1948                                  
  1949                                  ;NeedVolSubst	label	byte
  1950                                  ;		subst	<STRING,DATARES:VolName> ; volume name
  1951                                  ;		subst	<HEX,DATARES:VolSer+2>	 ; hi word of serial #
  1952                                  ;		subst	<HEX,DATARES:VolSer>	 ; lo word of serial #
  1953                                  
  1954 000001AA 02                      NeedVolSubst:	db	2
  1955 000001AB [B301]                  		dw	VolName
  1956 000001AD 03                      		db	3
  1957 000001AE [C101]                  		dw	VolSer+2
  1958 000001B0 03                      		db	3
  1959 000001B1 [BF01]                  		dw	VolSer
  1960                                  
  1961                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM - RESGROUP:0321h
  1962                                  	; NOTE:	VolName and VolSer must be adjacent
  1963                                  ;VolName:	times 11 db 0 ; db 11 dup (?),0	; volume name
  1964                                  		; 18/07/2024
  1965 000001B3 000000                  VolName:	db	3 dup(0)
  1966 000001B6 0000000000000000        DevName:	db	8 dup(0)
  1967                                  	
  1968 000001BE 00                      		db	0
  1969 000001BF 00000000                VolSer:		dd	0			; volume serial #
  1970                                  
  1971 000001C3 00                      CDevAt:		db	0
  1972                                  
  1973                                  ;BadFatSubst	label	byte
  1974                                  ;		subst	<CHAR,DATARES:DrvLet>	; drive letter
  1975                                  
  1976 000001C4 01                      BadFatSubst:	db	1
  1977 000001C5 [A301]                  		dw	DrvLet
  1978                                  
  1979                                  ;PutBackSubst	label	byte
  1980                                  ;PutBackComSpec	subst	<STRING,>		  ; comspec string
  1981                                  ;		subst	<CHAR,DATARES:PutBackDrv> ; drive to put it in
  1982                                  
  1983 000001C7 02                      PutBackSubst:	db	2
  1984 000001C8 0000                    PutBackComSpec:	dw	0
  1985 000001CA 01                      		db	1
  1986 000001CB [CD01]                  		dw	PutBackDrv
  1987                                  
  1988 000001CD 20                      PutBackDrv:	db	' '	; db 20h	; drive letter
  1989                                  
  1990                                  ;ExecErrSubst	subst	<STRING,DATARES:SafePathBuffer>
  1991                                  
  1992 000001CE 02                      ExecErrSubst:	db	2
  1993 000001CF [0204]                  		dw	SafePathBuffer
  1994                                  
  1995 000001D1 00000000                NeedVol:	dd	0	; ptr to volume name from get ext err
  1996 000001D5 00                      ErrType: 	db	0	; critical error message style, 0=old, 1=new
  1997                                  
  1998 000001D6 00000000                Int_2e_Ret:	dd	0	; magic command executer return address
  1999 000001DA 0000                    Save_Pdb:	dw	0
  2000 000001DC 0000                    Parent:		dw	0
  2001 000001DE 00000000                OldTerm:	dd	0
  2002 000001E2 0000                    ErrCd_24:	dw	0
  2003 000001E4 0000                    Handle01:	dw	0
  2004 000001E6 00                      Loading:	db	0
  2005 000001E7 0000                    Batch:		dw	0	; assume no batch mode initially
  2006                                  
  2007                                  ;;;;SR;
  2008                                  ;;;; This flag has been added for a gross hack introduced in batch processing. 
  2009                                  ;;;;We use it to indicate that this batch file has no CR-LF before EOF and that
  2010                                  ;;;;we need to fake the CR-LF for the line to be properly processed
  2011                                  ;;;;
  2012                                  ;;;BatchEOF:	db	0
  2013                                  
  2014                                  	; Bugbug: ComSpec should be 64+3+12+1?
  2015                                  	; What's this comspec_end about?
  2016 000001E9 00<rep 40h>             ComSpec:	times 64 db 0 ; db 64 dup (0)
  2017 00000229 0000                    ComSpec_End:	dw	0
  2018                                  
  2019                                  ;Trans		label	dword
  2020                                  ;		dw	TRANGROUP:Command
  2021                                  
  2022                                  Trans:		;dw	12Ch
  2023                                  		; MSDOS 5.0 COMMAND.COM RESGROUP:0296h (DATARES:0296h)
  2024 0000022B [2C01]                  		dw	COMMAND ; 16/04/2023
  2025 0000022D 0000                    TrnSeg:		dw	0
  2026                                  
  2027 0000022F 00                      TrnMvFlg:	db	0	; set if transient portion has been moved
  2028                                  
  2029 00000230 00                      In_Batch:	db	0	; set if we are in batch processing mode
  2030 00000231 00                      Batch_Abort:	db	0	; set if user wants to abort from batch mode
  2031                                  
  2032 00000232 00                      ComDrv:		db	0	; drive spec to load autoexec and command
  2033 00000233 0000                    MemSiz:		dw	0
  2034 00000235 0000                    Sum:		dw	0
  2035 00000237 01                      ExtCom:		db	1	; for init, pretend just did an external
  2036 00000238 0000                    RetCode: 	dw	0
  2037 0000023A 00                      Crit_Err_Info:	db	0	; hold critical error flags for r,i,f
  2038                                  
  2039                                  
  2040                                  ; The echo flag needs to be pushed and popped around pipes and batch files.
  2041                                  ; We implement this as a bit queue that is shr/shl for push and pop.
  2042                                  
  2043 0000023B 01                      EchoFlag:	db	00000001b ; low bit true => echo commands
  2044 0000023C 01                      Suppress:	db	1	; used for echo, 1=echo line
  2045 0000023D 0000                    Io_Save: 	dw	0
  2046 0000023F 00                      RestDir: 	db	0
  2047 00000240 00                      PermCom: 	db	0	; true => permanent command
  2048                                  ; 05/06/2023
  2049 00000241 FFFF                    SemiPermCom:	dw      -1	; MSDOS 6.0 COMMAND.COM 
  2050                                  				; true => semi-permanent command (/K)
  2051 00000243 0000                    SingleCom:	dw	0	; true => single command version
  2052 00000245 FFFF                    VerVal:		dw	-1
  2053 00000247 00                      fFail:		db	0	; true => fail all int 24s
  2054 00000248 00                      IfFlag:		db	0	; true => IF statement in progress
  2055                                  
  2056 00000249 00                      ForFlag: 	db	0	; true => FOR statement in progress
  2057 0000024A 0000                    ForPtr:		dw	0
  2058                                  
  2059 0000024C 0000                    Nest:		dw	0	; nested batch file counter
  2060 0000024E 00                      Call_Flag:	db	0	; no CALL (batch command) in progress
  2061 0000024F 00                      Call_Batch_Flag: db	0
  2062 00000250 0000                    Next_Batch:	dw	0	; address of next batch segment
  2063 00000252 00                      NullFlag:	db	0	; flag if no command on command line
  2064 00000253 00<rep 5h>              FUCase_Addr:	times 5 db 0 ; db 5 dup (0)
  2065                                  				; buffer for file ucase address
  2066                                  ; Bugbug: don't need crit_msg_ anymore?
  2067                                  
  2068 00000258 0000                    Crit_Msg_Off:	dw	0	; saved critical error message offset
  2069 0000025A 0000                    Crit_Msg_Seg:	dw	0	; saved critical error message segment
  2070 0000025C 0000                    Dbcs_Vector_Addr: dw	0	; DBCS vector offset
  2071 0000025E 0000                    		 dw	0	; DBCS vector segment
  2072 00000260 0000                    Append_State:	dw	0	; current state of append
  2073                                  				;  (if Append_Flag is set)
  2074 00000262 00                      Append_Flag:	db	0	; set if append state is valid
  2075 00000263 00                      Re_Out_App:	db	0
  2076 00000264 00<rep 50h>             Re_OutStr:	times 64+3+13 db 0 ; db 64+3+13 dup (?)
  2077                                  
  2078                                  ; We flag the state of COMMAND in order to correctly handle the ^Cs at
  2079                                  ; various times. Here is the breakdown:
  2080                                  ;
  2081                                  ;   INITINIT	We are in the init code.
  2082                                  ;   INITSPECIAL We are in the date/time prompt
  2083                                  ;   INITCTRLC	We are handling a ^C already.
  2084                                  ;
  2085                                  ; If we get a ^C in the initialization but not in the date/time prompt, we
  2086                                  ; ignore the ^C. This is so the system calls work on nested commands.
  2087                                  ;
  2088                                  ; If we are in the date/time prompt at initialization, we stuff the user's
  2089                                  ; input buffer with a CR to pretend an empty response.
  2090                                  ;
  2091                                  ; If we are already handling a ^C, we set the carry bit and return to the user
  2092                                  ; (ourselves). We can then detect the carry set and properly retry the
  2093                                  ; operation.
  2094                                  
  2095                                  InitFlag:	;db	1
  2096 000002B4 01                      		db	INITINIT
  2097                                  
  2098                                  ; Note: these two bytes are referenced as a word
  2099 000002B5 00                      PipeFlag:	db	0
  2100 000002B6 00                      PipeFiles:	db	0
  2101                                  
  2102                                  ; (rdata.asm, msdos 6.0, 1992)
  2103                                  ; ----------------------------------------------------------------------------
  2104                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:0320h (DATARES:0320h)
  2105                                  
  2106                                  ;;SR
  2107                                  ;; Pipe1 & Pipe2 now need to store full-fledged pathnames
  2108                                  ;;
  2109                                  ;
  2110                                  ;; Bugbug: can we find any way around maintaining these
  2111                                  ;; large buffers?
  2112                                  ;
  2113                                  ;Pipe1		db	67+12 dup (?)
  2114                                  ;Pipe2		db	67+12 dup (?)
  2115                                  ;
  2116                                  ;PipePtr 	dw	?
  2117                                  ;
  2118                                  ;PipeStr 	db	129 dup (?)
  2119                                  ;
  2120                                  ;EndPipe	label	byte	; marks end of buffers; M004
  2121                                  ;
  2122                                  ;;SR;
  2123                                  ;; We can move our EndInit code into above buffers. This way, the code will
  2124                                  ;;automatically be discarded after init.
  2125                                  ;;
  2126                                  ;; M004; We overlap our code with the Pipe buffers located above by changing
  2127                                  ;; M004; the origin.
  2128                                  ;;
  2129                                  ;	ORG	Pipe1	; M004
  2130                                  ;
  2131                                  ;; Bugbug: really need a procedure header for EndInit, describing
  2132                                  ;; what it expects, what it does.
  2133                                  ;
  2134                                  
  2135                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2136                                  
  2137                                  Pipe1	equ	EndInit
  2138                                  Pipe2	equ	Pipe1+67+12
  2139                                  PipePtr	equ	Pipe2+67+12
  2140                                  PipeStr	equ	PipePtr+2
  2141                                  EndPipe	equ	PipeStr+129	; EndInit+289
  2142                                  
  2143                                  ; Bugbug: really need a procedure header for EndInit, describing
  2144                                  ; what it expects, what it does.
  2145                                  
  2146                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0320h
  2147                                  
  2148                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM (compatible with MSDOS 6.22)
  2149                                  ; MSDOS 6.22 COMMAND.COM - RESGROUP:03EAh 
  2150                                  
  2151                                  EndInit:
  2152 000002B7 1E                      	push	ds
  2153 000002B8 06                      	push	es		; save segments
  2154 000002B9 0E                      	push	cs
  2155 000002BA 1F                      	pop	ds		
  2156                                  	;assume	ds:RESGROUP
  2157                                  
  2158                                  ; M004; Save size of transient here before INIT segment is deallocated
  2159                                  
  2160 000002BB 8B16[D61E]              	mov	dx,[TrnSize]		; M004
  2161                                  ;M027
  2162                                  ; These variables are also defined in the INIT segment and need to be saved
  2163                                  ;before we resize
  2164                                  ;
  2165 000002BF A1[CA1E]                	mov	ax,[OldEnv]	; Old Environment seg ;M027
  2166 000002C2 8B1E[C61E]              	mov	bx,[EnvSiz]	; Size of new environment ;M027
  2167 000002C6 8B0E[CC1E]              	mov	cx,[UsedEnv]	; Size of old environment ;M027
  2168 000002CA 50                      	push	ax		; Save all these values ;M027
  2169 000002CB 53                      	push	bx		; M027
  2170 000002CC 51                      	push	cx		; M027
  2171                                  
  2172                                  
  2173                                  ; Bugbug: push ds, pop es here.
  2174                                  	;mov	bx,ds
  2175                                  	;mov	es,bx		; es = RESGROUP
  2176                                  	; 09/01/2023
  2177 000002CD 1E                      	push	ds
  2178 000002CE 07                      	pop	es
  2179                                  
  2180                                  ;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  2181                                  ; code + data for low COMMAND
  2182                                  
  2183 000002CF 8B1E[5804]              	mov	bx,[ResSize]	; Total size of resident
  2184 000002D3 B44A                    	mov	ah,4Ah
  2185                                  	;mov	ah,SETBLOCK
  2186 000002D5 CD21                    	int	21h		; Set block to resident size
  2187                                  
  2188                                  		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  2189                                  		; ES = segment address of block to change
  2190                                  		; BX = new size in paragraphs
  2191                                  
  2192                                  ;We check if this is for autoexec.bat (PermCom = 1). If so, we then
  2193                                  ;allocate a new batch segment, copy the old one into new batchseg and free
  2194                                  ;the old batchseg. Remember that the old batchseg was allocated on top of the
  2195                                  ;transient and we will leave a big hole if TSRs are loaded by autoexec.bat
  2196                                  ;
  2197                                  ; Bugbug: also describe why we alloc & copy batch seg BEFORE environment.
  2198                                  	
  2199 000002D7 803E[4002]01            	cmp	byte [PermCom],1 ; permanent command.com?
  2200 000002DC 7530                    	jne	short adjust_env ; no, do not free batchseg
  2201                                  
  2202 000002DE 833E[E701]00            	cmp	word [Batch],0	 ; was there a valid batchseg?
  2203 000002E3 7429                    	je	short adjust_env ; no, dont juggle
  2204                                  
  2205                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0Fh)/16 ; batchseg size
  2206                                  	; 21/01/2023
  2207 000002E5 BB0400                  	mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  2208                                  	;mov	bx,4	; 09/01/2023
  2209                                  			; (MSDOS 5.0 COMMAND COM RESGROUP:0350h)
  2210 000002E8 B448                    	mov	ah,48h
  2211                                  	;mov	ah,ALLOC
  2212 000002EA CD21                    	int	21h
  2213                                  
  2214                                  		; DOS - 2+ - ALLOCATE MEMORY
  2215                                  		; BX = number of 16-byte paragraphs desired
  2216                                  
  2217                                  ; Bugbug: I just had a thought. If DOS or SHARE or somebody leaves
  2218                                  ; a hole, the batch segment COULD already be in the ideal place. We
  2219                                  ; could be making it worse! We're second-guessing where memory
  2220                                  ; allocations go, which might not be such a great idea. Is there
  2221                                  ; a strategy, short of doing something even worse like diddling
  2222                                  ; arena headers, where we can minimize the possibility of fragmentation
  2223                                  ; under all cases? Hmm..
  2224                                  	
  2225 000002EC 7220                    	jc	short adjust_env ; no memory, use old batchseg
  2226                                  
  2227 000002EE 8EC0                    	mov	es,ax		 ; es = New batch segment
  2228 000002F0 31FF                    	xor	di,di
  2229 000002F2 31F6                    	xor	si,si
  2230                                  
  2231 000002F4 1E                      	push	ds
  2232 000002F5 8E1E[E701]              	mov	ds,[Batch]	 ; ds = Old Batch Segment
  2233                                  	;assume	ds:nothing
  2234                                  	;mov	cx,SIZE BatchSegment
  2235                                  	; 23/01/2023
  2236                                  	;mov	cx,BATCHSEGMENT.SIZE
  2237                                  	;;mov	cx,33	; 09/01/2023
  2238                                  	;		; (MSDOS 5.0 COMMAND COM RESGROUP:0364h)
  2239                                  	;
  2240                                  	;add	cx,16		 ; for the filename
  2241                                  	; 20/04/2023
  2242 000002F9 B93100                  	mov	cx,BATCHSEGMENT.SIZE+16
  2243                                  
  2244                                  	; Bugbug: 16? Shouldn't this be a common equate or something?
  2245                                  	; It's sure be bad if we copied more bytes than the batch segment
  2246                                  	; holds!
  2247                                  	
  2248 000002FC FC                      	cld
  2249 000002FD F3A4                    	rep	movsb
  2250 000002FF 1F                      	pop	ds
  2251                                  	;assume	ds:RESGROUP
  2252                                  
  2253 00000300 8CC1                    	mov	cx,es		; save new batch segment 
  2254 00000302 8E06[E701]              	mov	es,[Batch]
  2255 00000306 B449                    	mov	ah,49h
  2256                                  	;mov	ah,DEALLOC
  2257 00000308 CD21                    	int	21h		; free the old batch segment
  2258                                  
  2259                                  	; Bugbug: should we check for error?
  2260                                  
  2261 0000030A 890E[E701]              	mov	[Batch],cx	; store new batch segment address
  2262                                  
  2263                                  adjust_env:
  2264 0000030E 59                      	pop	cx		; cx = size of old env ;M027
  2265 0000030F 5B                      	pop	bx		; bx = size of new env needed ;M027
  2266 00000310 5D                      	pop	bp		; bp = old env seg ;M027
  2267                                  
  2268                                  ;Allocate the correct size for the environment
  2269                                  
  2270 00000311 B448                    	mov	ah,48h
  2271                                  	;mov	ah,ALLOC
  2272 00000313 CD21                    	int	21h		; get memory
  2273 00000315 7264                    	jc	short nomem_err	; out of memory,signal error
  2274                                  	
  2275                                  	; Bugbug: why not continue, leaving environment where it is?
  2276                                  
  2277 00000317 A3[DC03]                	mov	[EnvirSeg],ax	; Store new environment segment
  2278                                  	;;mov	[ds:2Ch],ax
  2279                                  	;mov	[2Ch],ax
  2280                                  	;mov	[PDB_Environ],ax ; Put new env seg in PSP
  2281 0000031A A32C00                  	mov	[PDB.ENVIRON],ax
  2282 0000031D 8EC0                    	mov	es,ax		; es = address of allocated memory
  2283                                  	;assume	es:nothing
  2284                                  
  2285                                  ;Copy the environment to the newly allocated segment
  2286                                  
  2287 0000031F 1E                      	push	ds
  2288 00000320 8EDD                    	mov	ds,bp		; ds = Old environment segment
  2289                                  	;assume	ds:nothing
  2290                                  
  2291 00000322 31F6                    	xor	si,si
  2292 00000324 89F7                    	mov	di,si		; Start transfer from 0
  2293                                  
  2294 00000326 FC                      	cld
  2295 00000327 F3A4                    	rep	movsb		; Do the copy
  2296                                  
  2297 00000329 1F                      	pop	ds		; ds = RESGROUP
  2298                                  	;assume	ds:RESGROUP
  2299                                  
  2300                                  ; We have to free the old environment block if it was allocated by INIT
  2301                                  
  2302                                  ; Bugbug: is this only for the case when we were NOT passed an environment,
  2303                                  ; or does it also apply to passed environments?
  2304                                  
  2305                                  ;M036
  2306                                  ; Free up old env segment always because this is a copy passed by Exec and
  2307                                  ; takes up memory that is never used
  2308                                  
  2309                                  ;M044
  2310                                  ; Go back to the old strategy of not freeing the environment. Freeing it leaves
  2311                                  ; a hole behind that Ventura does not like. Basically, Ventura gives strange
  2312                                  ; errors if it gets a memory alloc that it is below its load segment. The
  2313                                  ; freed environment creates a large enough hole for some of its allocs to fit
  2314                                  ; in
  2315                                  
  2316                                  	;cmp	byte [AllocedEnv],0 ; has env been allocated by INIT?
  2317                                          ;je	short no_free	    ; no, do not free it
  2318                                  	; 21/01/2023
  2319                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0398h
  2320 0000032A 803E[8C1E]00            	cmp	byte [AllocedEnv],0 ; flag - old environment segment
  2321 0000032F 7506                    	jne	short no_free
  2322                                  
  2323 00000331 8EC5                    	mov	es,bp
  2324 00000333 B449                    	mov	ah,49h
  2325                                  	;mov	ah,DEALLOC
  2326 00000335 CD21                    	int	21h		    ; Free it
  2327                                  no_free:
  2328                                  
  2329                                  ; M004; Start of changes
  2330                                  
  2331                                  ; Move the transient now. We will allocate the biggest block available
  2332                                  ; now and move the transient to the top of the block. We will then
  2333                                  ; deallocate this block. When the resident starts executing, it will
  2334                                  ; hopefully allocate this block again and find the transient intact.
  2335                                  
  2336 00000337 C606[2F02]01            	mov	byte [TrnMvFlg],1 ; Indicate that transient has been moved
  2337 0000033C 06                      	push	es
  2338                                  	;;mov	si,offset ResGroup:TranStart
  2339                                  	; 09/01/2023
  2340                                  	;;mov	si,2320h	; MSDOS 5.0 COMMAND.COM RESGROUP:03ABh
  2341                                  	; 05/06/2023
  2342                                  	;mov	si,26E0h	; MSDOS 6.22 COMMAND.COM RESGROUP:0475h
  2343 0000033D BE5025                  	mov	si,TRANSTART	; (End of the resident portion)
  2344                                  	;mov	di,0
  2345 00000340 31FF                    	xor	di,di ; 0
  2346                                  	;;mov	cx,offset TranGroup:TranSpaceEnd ; size to move
  2347                                  	;mov	cx,98C5h
  2348                                  	; 05/06/2023 - MSDOS 6.22 COMMAND.COM RESGROUP:047Bh
  2349                                  	;mov	cx,0AF95h	; TRANSIENT portion size
  2350 00000342 B927AA                  	mov	cx,TRANSPACEEND
  2351                                  	
  2352                                  ; Find the largest block available
  2353                                  
  2354 00000345 BBFFFF                  	mov	bx,0FFFFh
  2355 00000348 B448                    	mov	ah,48h
  2356                                  	;mov	ah,ALLOC
  2357 0000034A CD21                    	int	21h
  2358                                  
  2359                                  ; dx = size of transient saved previously 
  2360                                  
  2361 0000034C 39D3                    	cmp	bx,dx		; enough memory?
  2362 0000034E 722B                    	jb	short nomem_err	; not enough memory for transient
  2363                                  
  2364 00000350 B448                    	mov	ah,48h
  2365                                  	;mov	ah,ALLOC
  2366 00000352 CD21                    	int	21h		; get the largest block
  2367 00000354 7225                    	jc	short nomem_err	; something is really screwed up
  2368                                  
  2369 00000356 50                      	push	ax		; save memory address
  2370 00000357 01D8                    	add	ax,bx		; ax = top of my memory block
  2371 00000359 29D0                    	sub	ax,dx		; less size of transient
  2372 0000035B A3[2D02]                	mov	[TrnSeg],ax	; save transient segment
  2373 0000035E 8EC0                    	mov	es,ax		;
  2374 00000360 58                      	pop	ax		; restore our seg addr
  2375                                  
  2376                                  ; Everything is set for a move. We need to move in the reverse direction to
  2377                                  ; make sure we dont overwrite ourselves while copying
  2378                                  
  2379 00000361 01CE                    	add	si,cx
  2380 00000363 4E                      	dec	si
  2381 00000364 01CF                    	add	di,cx
  2382 00000366 4F                      	dec	di
  2383 00000367 FD                      	std
  2384 00000368 F3A4                    	rep	movsb
  2385 0000036A FC                      	cld
  2386                                  
  2387                                  ; Now we have to free up this block so that resident can get hold of it
  2388                                  
  2389 0000036B 8EC0                    	mov	es,ax
  2390 0000036D B449                    	mov	ah,49h
  2391                                  	;mov	ah,DEALLOC
  2392 0000036F CD21                    	int	21h		; release the memory block
  2393                                  
  2394                                  ; M004; End of changes
  2395                                  
  2396                                  	;mov	InitFlag,FALSE	; indicate INIT is done
  2397                                  	; 09/01/2023
  2398 00000371 C606[B402]00            	mov	byte [InitFlag],0	
  2399                                  
  2400 00000376 07                      	pop	es
  2401 00000377 1F                      	pop	ds
  2402                                  	;assume	ds:nothing
  2403                                  	
  2404                                  	; Bugbug: did we need to save & restore seg reg's during EndInit?
  2405                                  	
  2406 00000378 E903FD                  	jmp	LodCom_Trap	; allocate transient
  2407                                  
  2408                                  nomem_err:
  2409                                  
  2410                                  ;We call the error routine which will never return. It will either exit
  2411                                  ;with an error ( if not the first COMMAND ) or just hang after an error 
  2412                                  ;message ( if first COMMAND )
  2413                                  
  2414 0000037B E97A1A                  	jmp	Alloc_error
  2415                                  
  2416                                  ;EndCodeInit:	; label	byte		; M004
  2417                                  
  2418                                  	; 16/04/2023
  2419                                  	EndCodeInit equ $
  2420                                  
  2421                                  ;; M004; Check if the EndInit code will fit into the Pipe buffers above.
  2422                                  ;; M004; If not, we signal an assembly error
  2423                                  ;
  2424                                  ;IF2
  2425                                  ;	IF ($ GT EndPipe)
  2426                                  ;		.err
  2427                                  ;		%out	"ENDINIT CODE TOO BIG"
  2428                                  ;	ENDIF
  2429                                  ;ENDIF
  2430                                  
  2431                                  ;; M004; Set the origin back to what it was at the end of the buffers
  2432                                  ;;
  2433                                  ;		ORG	EndPipe		; M004
  2434                                  
  2435                                  ; 09/01/2023
  2436                                  ; MSDOS 5.0 COMMAND.COM - CODERES:03EDh
  2437                                  ; 05/06/2023
  2438                                  ; MSDOS 6.22 COMMAND.COM - CODERES:04B7h
  2439                                  ;	times 84 db 0	; db (EndPipe-EndCodeInit) dup(0)
  2440                                  
  2441                                  ; 16/04/2023
  2442                                  	FillBytes equ EndPipe - EndCodeInit
  2443                                  
  2444                                  ;%if EndCodeInit<EndPipe ; if (EndCodeInit < (EndInit+289))
  2445                                  ; 16/04/2023
  2446                                  %if FillBytes>0
  2447                                  	;times EndPipe - EndCodeInit db 0
  2448 0000037E 00<rep 5Ah>             	times FillBytes db 0
  2449                                  %endif
  2450                                  
  2451                                  ; 09/01/2023 - Retrodos v4.0 (& v4.1)
  2452                                  ; MSDOS 5.0 COMMAND.COM - CODERES:0441h ; EndInit+289
  2453                                  
  2454                                  ; 05/06/2023 - Retrodos v4.2
  2455                                  ; MSDOS 6.22 COMMAND.COM - CODERES:050Bh ; EndInit+289
  2456                                  
  2457                                  ;InPipePtr	dw	offset DATARES:Pipe1	; 320h
  2458                                  ;OutPipePtr	dw	offset DATARES:Pipe2	; 36Fh
  2459                                  
  2460 000003D8 [B702]                  InPipePtr:	dw	Pipe1 ;; 320h for MSDOS 5.0 COMMAND.COM
  2461                                  			      ; 3EAh for MSDOS 6.22 COMMAND.COM
  2462 000003DA [0603]                  OutPipePtr:	dw	Pipe2 ;; 36Fh for MSDOS 5.0 COMMAND.COM
  2463                                  			      ; 439h for MSDOS 6.22 COMMAND.COM
  2464                                  
  2465                                  Exec_Block:	; label	byte	; the data block for exec calls
  2466 000003DC 0000                    EnvirSeg:	dw	0
  2467                                  Com_Ptr:	; label	dword
  2468 000003DE 8000                    		dw	80h	; point at unformatted parameters
  2469 000003E0 0000                    		dw	0
  2470                                  Com_Fcb1:	; label	dword
  2471 000003E2 5C00                    		dw	5Ch
  2472 000003E4 0000                    		dw	0
  2473                                  Com_Fcb2:	; label	dword
  2474 000003E6 6C00                    		dw	6Ch
  2475 000003E8 0000                    		dw	0
  2476                                  
  2477                                  ; variables passed to transient
  2478                                  TranVars:	; label	byte
  2479                                  		;dw	offset DATARES:HeadFix_Trap
  2480 000003EA [9200]                  		dw	HeadFix_Trap
  2481 000003EC 0000                    MySeg:		dw	0	; put our own segment here
  2482 000003EE 0000                    LTpa:		dw	0	; will store tpa segment here
  2483 000003F0 2F                      RSwitChar:	db	"/"
  2484 000003F1 5C                      RDirChar:	db	"\"
  2485                                  		;dw	offset DATARES:Issue_Exec_Call
  2486 000003F2 [8501]                  		dw	Issue_Exec_Call
  2487 000003F4 0000                    MySeg1:		dw	0
  2488                                  		;dw	offset DATARES:RemCheck_Trap
  2489 000003F6 [6A00]                  		dw	RemCheck_Trap
  2490 000003F8 0000                    MySeg2:		dw	0
  2491 000003FA 0000                    ResTest: 	dw	0
  2492 000003FC 0000                    Res_Tpa:	dw	0	; original tpa (not rounded to 64k)
  2493                                  
  2494                                  ; 18/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
  2495 000003FE 0000                    Y_Flag:		dw	0
  2496                                  
  2497                                  TranVarEnd:	; label	byte
  2498                                  
  2499 00000400 0000                    OldErrNo:	dw	0
  2500                                  
  2501                                  ;* NOTE: MsgBuffer and SafePathBuffer use the same memory.
  2502                                  ;  MsgBuffer is only used while a command is being executed.
  2503                                  ;  SafePathBuffer is no longer needed, since it is used for
  2504                                  ;  unsuccessful program launches.
  2505                                  
  2506                                  MsgBuffer:	; label	byte	; buffer for messages from disk
  2507                                  SafePathBuffer: ; label	byte	; resident pathname for EXEC
  2508                                  	;Bugbug: Why so big a buffer?
  2509                                  		;db	64+3+13 dup (0)	; path + 'd:\' 'file.ext' + null
  2510 00000402 00<rep 50h>             		times	64+3+13 db 0		
  2511                                  
  2512                                  LENMSGORPATHBUF	equ $ - MsgBuffer
  2513                                  
  2514 00000452 00000000                Int2fHandler:	dd	0	; address of next int 2f handler
  2515 00000456 0000                    ResMsgEnd:	dw	0	; holds offset of msg end (end of resident)
  2516                                  
  2517                                  ;SR;
  2518                                  ; The three vars below have been added for a pure COMMAND.COM
  2519                                  
  2520 00000458 0000                    ResSize:	dw	0
  2521                                  
  2522                                  ;SR;
  2523                                  ; Moved the stack here from the code segment
  2524                                  ;
  2525                                  ; bugbug: Why this odd stack size? And what should stack size be?
  2526                                  	
  2527                                  		;db	(80h - 3) dup (?)
  2528                                  align 2
  2529 0000045A 00<rep 7Ch>             		times	124 db 0		
  2530                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:053Eh (offset RStack)
  2531                                  ; 05/06/2023
  2532                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:060Ah (offset RStack)
  2533                                  RStack:		; label	word
  2534 000004D6 0000                    OldDS:		dw	0	; keeps old ds value when jumping to
  2535                                  				; resident code segments
  2536                                  ;LoadHiFlg	db	0	; Flag set to 1 if UMB loading enabled ; M003
  2537                                  
  2538                                  ; include highvar.inc		; Add variables for 6.0 loadhigh functionality
  2539                                  ; -------------------------------
  2540                                  
  2541                                  ; fInHigh  - Is set to 1 during HideUMBs(), and back to zero in UnHideUMBs().
  2542                                  ; fUmbTiny - Is set to 1 if the user has specified /S on the command line.
  2543                                  ; SegLoad  - Segment address for first UMB specified; set automatically.
  2544                                  ; UmbLoad  - The load UMB number; for example, this is 3 if the user has
  2545                                  ;            given a command-line like "/L:3,500;4"
  2546                                  ; UmbUsed  - An array of characters, each of which is 1 if the UMB
  2547                                  ;            matching its index number was specified on the command-line;
  2548                                  ;            for example, after "/L:3,500;4;7", UmbUsed[3], [4] and [7]
  2549                                  ;            will be set to 1. All others will be set to 0.
  2550                                  ; UmbSize  - An array of words, each of which is interpreted as a size
  2551                                  ;            specified by the user for a UMB (in the above example, all
  2552                                  ;            elements would be zero save UmbSize[3], which would be 500.
  2553                                  ; fm_umb   - Set to the old UMB link-state (0x80 or 0x00)
  2554                                  ; fm_strat - Set to the old memory-allocation strategy (0$00000???)
  2555                                  ; fm_argc  - Number of arguments received by ParseVar() (see ParseVar()
  2556                                  ;            for details).
  2557                                  
  2558                                  ; - MSDOS 6.0 COMMAND.COM -
  2559                                  ;; To keep track of which UMBs were specified on the DH/LH command lines, and
  2560                                  ;; to keep track of the minimum sizes given for each, there're two arrays kept
  2561                                  ;; in { IO.SYS: sysinitseg / COMMAND.COM: DATARES }... each is MAXUMB elements
  2562                                  ;; big. 16 should be around 14 too many for most users, so there's no expected
  2563                                  ;; space problem (it's just such a nice round number, eh?).
  2564                                  
  2565                                  ; 05/06/2023
  2566                                  MAXUMB	equ	16
  2567                                  
  2568                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2569                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0540h (DATARES:0540h)
  2570                                  
  2571 000004D8 00                      fInHigh:	db	0
  2572                                  
  2573                                  ; MSDOS 6.0 COMMAND.COM
  2574                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  2575                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:060Dh (DATARES:060Dh)
  2576 000004D9 00                      fUmbTiny:	db	0
  2577 000004DA 0000                    SegLoad:	dw	0
  2578 000004DC 00                      UmbLoad:	db	0
  2579                                  
  2580                                  ; 19/07/2024
  2581                                  ; PCDOS 7.1 COMMAND.COM
  2582                                  %if 0
  2583                                  UmbUsed:	times MAXUMB db 0 ; db MAXUMB dup (?)
  2584                                  UmbSize:	times MAXUMB dw 0 ; dw MAXUMB dup (?)
  2585                                  %else
  2586                                  	; 19/07/2024 - Retro DOS v5.0 (& v4.2) COMMAND.COM
  2587                                  	UmbUsed equ MsgBuffer	; 16 bytes
  2588                                  	UmbSize equ UmbUsed+MAXUMB ; UmbUsed+16; 16 words
  2589                                  %endif
  2590                                  
  2591 000004DD 00                      fm_umb:		db	0
  2592 000004DE 00                      fm_strat:	db	0
  2593 000004DF 00                      fm_argc:	db	0
  2594                                  
  2595                                  ; UmbLoad is set to UNSPECIFED, below, until /L:umb is read; at which point
  2596                                  ; UmbLoad is set to the UMB number given.
  2597                                  
  2598                                  ;*** MESSAGES
  2599                                  ;    and other translatable text
  2600                                  
  2601                                  ; include comrmsg.inc	; M00
  2602                                  ; ------------------------------
  2603                                  
  2604                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2605                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0541h (DATARES:0541h)
  2606                                  
  2607                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  2608                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0644h (DATARES:0644h)
  2609                                  
  2610 000004E0 41                      ABORT_CHAR:	db 'A'
  2611 000004E1 52                      RETRY_CHAR:	db 'R'
  2612 000004E2 49                      IGNORE_CHAR:	db 'I'
  2613 000004E3 46                      FAIL_CHAR:	db 'F'
  2614 000004E4 59                      YES_CHAR:	db 'Y'
  2615 000004E5 4E                      NO_CHAR:	db 'N'
  2616 000004E6 05                      REQ_ABORT:	db 5
  2617 000004E7 41626F7274              		db 'Abort'
  2618 000004EC 07                      REQ_RETRY:	db 7
  2619 000004ED 2C205265747279          		db ', Retry'
  2620 000004F4 08                      REQ_IGNORE:	db 8
  2621 000004F5 2C2049676E6F7265        		db ', Ignore'
  2622 000004FD 06                      REQ_FAIL:	db 6
  2623 000004FE 2C204661696C            		db ', Fail'
  2624 00000504 01                      REQ_END:	db 1
  2625 00000505 3F                      		db '?'
  2626 00000506 08                      MREAD:		db 8
  2627 00000507 72656164696E6700        		db 'reading', 0
  2628 0000050F 08                      MWRITE:		db 8
  2629 00000510 77726974696E6700        		db 'writing', 0
  2630 00000518 0E                      MDRIVE:		db 14
  2631 00000519 202531206472697665-     		db ' %1 drive %2',0Dh,0Ah
  2631 00000522 2025320D0A         
  2632 00000527 0F                      MDEVICE:	db 15
  2633 00000528 202531206465766963-     		db ' %1 device %2',0Dh,0Ah
  2633 00000531 652025320D0A       
  2634 00000537 26                      MVOLSERIAL:	db 38
  2635 00000538 506C6561736520696E-     		db 'Please insert volume %1 serial %2-%3',0Dh,0Ah
  2635 00000541 7365727420766F6C75-
  2635 0000054A 6D6520253120736572-
  2635 00000553 69616C2025322D2533-
  2635 0000055C 0D0A               
  2636 0000055E 25                      BADFATMSG:	db 37
  2637 0000055F 46696C6520616C6C6F-     		db 'File allocation table bad, drive %1',0Dh,0Ah
  2637 00000568 636174696F6E207461-
  2637 00000571 626C65206261642C20-
  2637 0000057A 64726976652025310D-
  2637 00000583 0A                 
  2638 00000584 15                      COMBAD:		db 21
  2639 00000585 496E76616C69642043-     		db 'Invalid COMMAND.COM',0Dh,0Ah
  2639 0000058E 4F4D4D414E442E434F-
  2639 00000597 4D0D0A             
  2640 0000059A 21                      PUTBACKMSG:	db 33
  2641 0000059B 496E73657274206469-     		db 'Insert disk with %1 in drive %2',0Dh,0Ah
  2641 000005A4 736B20776974682025-
  2641 000005AD 3120696E2064726976-
  2641 000005B6 652025320D0A       
  2642 000005BC 21                      PROMPT:		db 33
  2643 000005BD 507265737320616E79-     		db 'Press any key to continue . . .',0Dh,0Ah
  2643 000005C6 206B657920746F2063-
  2643 000005CF 6F6E74696E7565202E-
  2643 000005D8 202E202E0D0A       
  2644 000005DE 1C                      ENDBATMES:	db 28
  2645 000005DF 0D0A                    		db 0Dh,0Ah
  2646 000005E1 5465726D696E617465-     		db 'Terminate batch job (Y/N)?'
  2646 000005EA 206261746368206A6F-
  2646 000005F3 622028592F4E293F   
  2647 000005FB 13                      EXECEMES:	db 19
  2648 000005FC 43616E6E6F74206578-     		db 'Cannot execute %1',0Dh,0Ah
  2648 00000605 65637574652025310D-
  2648 0000060E 0A                 
  2649 0000060F 13                      EXEBAD:		db 19
  2650 00000610 4572726F7220696E20-     		db 'Error in EXE file',0Dh,0Ah
  2650 00000619 4558452066696C650D-
  2650 00000622 0A                 
  2651 00000623 22                      TOOBIG:		db 34
  2652 00000624 50726F6772616D2074-     		db 'Program too big to fit in memory',0Dh,0Ah
  2652 0000062D 6F6F2062696720746F-
  2652 00000636 2066697420696E206D-
  2652 0000063F 656D6F72790D0A     
  2653 00000646 16                      NOHANDMES:	db 22
  2654 00000647 0D0A                    		db 0Dh,0Ah
  2655 00000649 4E6F20667265652066-     		db 'No free file handles'
  2655 00000652 696C652068616E646C-
  2655 0000065B 6573               
  2656 0000065D 1A                      RBADNAM:	db 26
  2657 0000065E 42616420436F6D6D61-     		db 'Bad Command or file name',0Dh,0Ah
  2657 00000667 6E64206F722066696C-
  2657 00000670 65206E616D650D0A   
  2658                                  ACCDENIED:	; 14/01/2023
  2659                                  		; 10/01/2023
  2660                                  ACCDEN:		;db 14
  2661                                  		;db 'Access denied '
  2662                                  		; 19/07/2024 - PCDOS 7.1
  2663 00000678 0D                      		db 13
  2664 00000679 416363657373206465-     		db 'Access denied'
  2664 00000682 6E696564           
  2665 00000686 19                      BMEMMES:	db 25
  2666 00000687 0D0A4D656D6F727920-     		db 0Dh,0Ah,'Memory allocation error'
  2666 00000690 616C6C6F636174696F-
  2666 00000699 6E206572726F72     
  2667 000006A0 26                      HALTMES:	db 38
  2668 000006A1 0D0A                    		db 0Dh,0Ah
  2669 000006A3 43616E6E6F74206C6F-     		db 'Cannot load COMMAND, system halted',0Dh,0Ah
  2669 000006AC 616420434F4D4D414E-
  2669 000006B5 442C2073797374656D-
  2669 000006BE 2068616C7465640D0A 
  2670 000006C7 21                      FRETMES:	db 33
  2671 000006C8 0D0A                    		db 0Dh,0Ah,
  2672 000006CA 43616E6E6F74207374-     		db 'Cannot start COMMAND, exiting',0Dh,0Ah
  2672 000006D3 61727420434F4D4D41-
  2672 000006DC 4E442C206578697469-
  2672 000006E5 6E670D0A           
  2673 000006E9 2E                      PATRICIDE:	db 46
  2674 000006EA 0D0A                    		db 0Dh,0Ah
  2675 000006EC 546F70206C6576656C-     		db 'Top level process aborted, cannot continue'
  2675 000006F5 2070726F6365737320-
  2675 000006FE 61626F727465642C20-
  2675 00000707 63616E6E6F7420636F-
  2675 00000710 6E74696E7565       
  2676 00000716 0D0A                    		db 0Dh,0Ah
  2677 00000718 02                      NEWLINE:	db 2
  2678 00000719 0D0A                    		db 0Dh, 0Ah
  2679                                  
  2680                                  ; 10/01/2023
  2681                                  ;; MSDOS 5.0 COMMAND.COM RESGROUP:077Dh
  2682                                  ; 05/06/2023
  2683                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0880h
  2684                                  
  2685 0000071B [FF0B]                  MsgPtrLists:	dw EXTMSGPTRS		; extended error messages
  2686 0000071D 0100                    		dw 1
  2687 0000071F [BA09]                  		dw PARSMSGPTRS		; parse	error messages
  2688 00000721 0100                    		dw 1
  2689 00000723 [FF0B]                  		dw EXTMSGPTRS		; critical error messages
  2690 00000725 0100                    		dw 1
  2691 00000727 0000                    		dw 0			; File system error messages
  2692 00000729 0000                    		dw 0			; are not supported.
  2693 0000072B [8800]                  		dw MsgRetrv_Trap	; disk retriever routine
  2694 0000072D 0000                    MySeg3:		dw 0			; segment of retriever routine
  2695                                  
  2696                                  ;; MSDOS 5.0 COMMAND.COM RESGROUP:0791h
  2697                                  ; 05/06/2023
  2698                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0894h
  2699                                  
  2700 0000072F 13                      CRMSG0:		db 19
  2701 00000730 57726974652070726F-     		db 'Write protect error'
  2701 00000739 74656374206572726F-
  2701 00000742 72                 
  2702 00000743 0C                      CRMSG1:		db 12
  2703 00000744 496E76616C69642075-     		db 'Invalid unit'
  2703 0000074D 6E6974             
  2704 00000750 09                      CRMSG2:		db 9
  2705 00000751 4E6F74207265616479      		db 'Not ready'
  2706 0000075A 16                      CRMSG3:		db 22
  2707 0000075B 496E76616C69642064-     		db 'Invalid device request'
  2707 00000764 657669636520726571-
  2707 0000076D 75657374           
  2708 00000771 0A                      CRMSG4:		db 10
  2709 00000772 44617461206572726F-     		db 'Data error'
  2709 0000077B 72                 
  2710 0000077C 21                      CRMSG5:		db 33
  2711 0000077D 496E76616C69642064-     		db 'Invalid device request parameters'
  2711 00000786 657669636520726571-
  2711 0000078F 756573742070617261-
  2711 00000798 6D6574657273       
  2712 0000079E 0A                      CRMSG6:		db 10
  2713 0000079F 5365656B206572726F-     		db 'Seek error'
  2713 000007A8 72                 
  2714 000007A9 12                      CRMSG7:		db 18
  2715 000007AA 496E76616C6964206D-     		db 'Invalid media type'
  2715 000007B3 656469612074797065 
  2716 000007BC 10                      CRMSG8:		db 16
  2717 000007BD 536563746F72206E6F-     		db 'Sector not found'
  2717 000007C6 7420666F756E64     
  2718 000007CD 1A                      CRMSG9:		db 26
  2719 000007CE 5072696E746572206F-     		db 'Printer out of paper error'
  2719 000007D7 7574206F6620706170-
  2719 000007E0 6572206572726F72   
  2720 000007E8 11                      CRMSG10:	db 17
  2721 000007E9 577269746520666175-     		db 'Write fault error'
  2721 000007F2 6C74206572726F72   
  2722 000007FA 10                      CRMSG11:	db 16
  2723 000007FB 52656164206661756C-     		db 'Read fault error'
  2723 00000804 74206572726F72     
  2724 0000080B 0F                      CRMSG12:	db 15
  2725 0000080C 47656E6572616C2066-     		db 'General failure'
  2725 00000815 61696C757265       
  2726 0000081B 11                      CRMSG13:	db 17
  2727 0000081C 53686172696E672076-     		db 'Sharing violation'
  2727 00000825 696F6C6174696F6E   
  2728 0000082D 0E                      CRMSG14:	db 14
  2729 0000082E 4C6F636B2076696F6C-     		db 'Lock violation'
  2729 00000837 6174696F6E         
  2730 0000083C 13                      CRMSG15:	db 19
  2731 0000083D 496E76616C69642064-     		db 'Invalid disk change'
  2731 00000846 69736B206368616E67-
  2731 0000084F 65                 
  2732 00000850 0F                      CRMSG16:	db 15
  2733 00000851 46434220756E617661-     		db 'FCB unavailable'
  2733 0000085A 696C61626C65       
  2734 00000860 19                      CRMSG17:	db 25
  2735 00000861 53797374656D207265-     		db 'System resource exhausted'
  2735 0000086A 736F75726365206578-
  2735 00000873 68617573746564     
  2736 0000087A 12                      CRMSG18:	db 18
  2737 0000087B 436F64652070616765-     		db 'Code page mismatch'
  2737 00000884 206D69736D61746368 
  2738 0000088D 0C                      CRMSG19:	db 12
  2739 0000088E 4F7574206F6620696E-     		db 'Out of input'
  2739 00000897 707574             
  2740 0000089A 17                      CRMSG20:	db 23
  2741 0000089B 496E73756666696369-     		db 'Insufficient disk space'
  2741 000008A4 656E74206469736B20-
  2741 000008AD 7370616365         
  2742                                  
  2743                                  ;; MSDOS 5.0 COMMAND.COM RESGROUP:0914h
  2744                                  ; 05/06/2023
  2745                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0A17h
  2746                                  
  2747 000008B2 [2F07]                  CRITMSGPTRS:	dw CRMSG0
  2748 000008B4 [4307]                  		dw CRMSG1
  2749 000008B6 [5007]                  		dw CRMSG2
  2750 000008B8 [5A07]                  		dw CRMSG3
  2751 000008BA [7107]                  		dw CRMSG4
  2752 000008BC [7C07]                  		dw CRMSG5
  2753 000008BE [9E07]                  		dw CRMSG6
  2754 000008C0 [A907]                  		dw CRMSG7
  2755 000008C2 [BC07]                  		dw CRMSG8
  2756 000008C4 [CD07]                  		dw CRMSG9
  2757 000008C6 [E807]                  		dw CRMSG10
  2758 000008C8 [FA07]                  		dw CRMSG11
  2759 000008CA [0B08]                  		dw CRMSG12
  2760 000008CC [1B08]                  		dw CRMSG13
  2761 000008CE [2D08]                  		dw CRMSG14
  2762 000008D0 [3C08]                  		dw CRMSG15
  2763 000008D2 [5008]                  		dw CRMSG16
  2764 000008D4 [6008]                  		dw CRMSG17
  2765 000008D6 [7A08]                  		dw CRMSG18
  2766 000008D8 [8D08]                  		dw CRMSG19
  2767 000008DA [9A08]                  		dw CRMSG20
  2768                                  
  2769                                  		; 14/01/2023
  2770                                  ;DataresEnd:	;; MSDOS 5.0 COMMAND.COM - DATARES:093Eh (RESGROUP:093Eh)
  2771                                  		; 05/06/2023
  2772                                  DataresEnd:	; MSDOS 6.22 COMMAND.COM - DATARES:0A41h (RESGROUP:0A41h)
  2773                                  
  2774 000008DC 13                      PAERRMSG0:	db 19
  2775 000008DD 546F6F206D616E7920-     		db 'Too many parameters'
  2775 000008E6 706172616D65746572-
  2775 000008EF 73                 
  2776 000008F0 1A                      PAERRMSG1:	db 26
  2777 000008F1 526571756972656420-     		db 'Required parameter missing'
  2777 000008FA 706172616D65746572-
  2777 00000903 206D697373696E67   
  2778 0000090B 0E                      PAERRMSG2:	db 14
  2779 0000090C 496E76616C69642073-     		db 'Invalid switch'
  2779 00000915 7769746368         
  2780 0000091A 0F                      PAERRMSG3:	db 15
  2781 0000091B 496E76616C6964206B-     		db 'Invalid keyword'
  2781 00000924 6579776F7264       
  2782 0000092A 01                      PAERRMSG4:	db 1
  2783 0000092B 20                      		db 20h
  2784 0000092C 24                      PAERRMSG5:	db 36
  2785 0000092D 506172616D65746572-     		db 'Parameter value not in allowed range'
  2785 00000936 2076616C7565206E6F-
  2785 0000093F 7420696E20616C6C6F-
  2785 00000948 7765642072616E6765 
  2786                                  PAERRMSG6:	; 10/01/2023
  2787 00000951 1B                      PAERRMSG7:	db 27
  2788 00000952 506172616D65746572-     		db 'Parameter value not allowed'
  2788 0000095B 2076616C7565206E6F-
  2788 00000964 7420616C6C6F776564 
  2789                                  ;PAERRMSG7:	db 27
  2790                                  ;		db 'Parameter value not allowed'
  2791 0000096D 1C                      PAERRMSG8:	db 28
  2792 0000096E 506172616D65746572-     		db 'Parameter format not correct'
  2792 00000977 20666F726D6174206E-
  2792 00000980 6F7420636F72726563-
  2792 00000989 74                 
  2793 0000098A 11                      PAERRMSG9:	db 17
  2794 0000098B 496E76616C69642070-     		db 'Invalid parameter'
  2794 00000994 6172616D65746572   
  2795 0000099C 1D                      PAERRMSG10:	db 29
  2796 0000099D 496E76616C69642070-     		db 'Invalid parameter combination'
  2796 000009A6 6172616D6574657220-
  2796 000009AF 636F6D62696E617469-
  2796 000009B8 6F6E               
  2797                                  
  2798                                  ;; MSDOS 5.0 COMMAND.COM RESGROUP:0A38h
  2799                                  ; 05/06/2023
  2800                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0B3Bh
  2801                                  
  2802 000009BA [DC08]                  PARSMSGPTRS:	dw PAERRMSG0
  2803 000009BC [F008]                  		dw PAERRMSG1
  2804 000009BE [0B09]                  		dw PAERRMSG2
  2805 000009C0 [1A09]                  		dw PAERRMSG3
  2806 000009C2 [2A09]                  		dw PAERRMSG4
  2807 000009C4 [2C09]                  		dw PAERRMSG5
  2808 000009C6 [5109]                  		dw PAERRMSG6
  2809 000009C8 [5109]                  		dw PAERRMSG7
  2810 000009CA [6D09]                  		dw PAERRMSG8
  2811 000009CC [8A09]                  		dw PAERRMSG9
  2812 000009CE [9C09]                  		dw PAERRMSG10
  2813                                  ; 21/04/2023
  2814                                  NUMPARSMSGS equ ($-PARSMSGPTRS)>>1 ; 14/01/2023
  2815                                  
  2816 000009D0 10                      INVLFUNCT:	db 16
  2817 000009D1 496E76616C69642066-     		db 'Invalid function'
  2817 000009DA 756E6374696F6E     
  2818 000009E1 0E                      FNOTFOUND:	db 14
  2819 000009E2 46696C65206E6F7420-     		db 'File not found'
  2819 000009EB 666F756E64         
  2820 000009F0 0E                      PNOTFOUND:	db 14
  2821 000009F1 50617468206E6F7420-     		db 'Path not found'
  2821 000009FA 666F756E64         
  2822 000009FF 13                      TOOMANYOF:	db 19
  2823 00000A00 546F6F206D616E7920-     		db 'Too many open files'
  2823 00000A09 6F70656E2066696C65-
  2823 00000A12 73                 
  2824                                  ; 14/01/2023
  2825                                  ;ACCDEN:	; 10/01/2023
  2826                                  ;ACCDENIED:	db 14
  2827                                  ;		db 'Access denied '
  2828 00000A13 0E                      INVHANDLE:	db 14
  2829 00000A14 496E76616C69642068-     		db 'Invalid handle'
  2829 00000A1D 616E646C65         
  2830 00000A22 1F                      MEMCBDEST:	db 31
  2831 00000A23 4D656D6F727920636F-     		db 'Memory control blocks destroyed'
  2831 00000A2C 6E74726F6C20626C6F-
  2831 00000A35 636B73206465737472-
  2831 00000A3E 6F796564           
  2832 00000A42 13                      INSUFFMEM:	db 19
  2833 00000A43 496E73756666696369-     		db 'Insufficient memory'
  2833 00000A4C 656E74206D656D6F72-
  2833 00000A55 79                 
  2834 00000A56 1C                      INVMEMBLA:	db 28
  2835 00000A57 496E76616C6964206D-     		db 'Invalid memory block address'
  2835 00000A60 656D6F727920626C6F-
  2835 00000A69 636B20616464726573-
  2835 00000A72 73                 
  2836 00000A73 13                      INVENVIRO:	db 19
  2837 00000A74 496E76616C69642045-     		db 'Invalid Environment'
  2837 00000A7D 6E7669726F6E6D656E-
  2837 00000A86 74                 
  2838 00000A87 0E                      INVFORMAT:	db 14
  2839 00000A88 496E76616C69642066-     		db 'Invalid format'
  2839 00000A91 6F726D6174         
  2840 00000A96 1A                      INVFNPARM:	db 26
  2841 00000A97 496E76616C69642066-     		db 'Invalid function parameter'
  2841 00000AA0 756E6374696F6E2070-
  2841 00000AA9 6172616D65746572   
  2842 00000AB1 0C                      INVLDDATA:	db 12
  2843 00000AB2 496E76616C69642064-     		db 'Invalid data'
  2843 00000ABB 617461             
  2844 00000ABE 1B                      INVDRVSPC:	db 27
  2845 00000ABF 496E76616C69642064-     		db 'Invalid drive specification'
  2845 00000AC8 726976652073706563-
  2845 00000AD1 696669636174696F6E 
  2846 00000ADA 23                      ATRCURDIR:	db 35
  2847 00000ADB 417474656D70742074-     		db 'Attempt to remove current directory'
  2847 00000AE4 6F2072656D6F766520-
  2847 00000AED 63757272656E742064-
  2847 00000AF6 69726563746F7279   
  2848 00000AFE 0F                      NOTSAMDEV:	db 15
  2849 00000AFF 4E6F742073616D6520-     		db 'Not same device'
  2849 00000B08 646576696365       
  2850 00000B0E 0D                      NOMOREFIL:	db 13
  2851 00000B0F 4E6F206D6F72652066-     		db 'No more files'
  2851 00000B18 696C6573           
  2852 00000B1C 0B                      FILEXISTS:	db 11
  2853 00000B1D 46696C652065786973-     		db 'File exists'
  2853 00000B26 7473               
  2854 00000B28 1B                      CANTMKDIR:	db 27
  2855 00000B29 43616E6E6F74206D61-     		db 'Cannot make directory entry'
  2855 00000B32 6B6520646972656374-
  2855 00000B3B 6F727920656E747279 
  2856 00000B44 0E                      FAILINT24:	db 14
  2857 00000B45 4661696C206F6E2049-     		db 'Fail on INT 24'
  2857 00000B4E 4E54203234         
  2858 00000B53 15                      TOOMANYRD:	db 21
  2859 00000B54 546F6F206D616E7920-     		db 'Too many redirections'
  2859 00000B5D 726564697265637469-
  2859 00000B66 6F6E73             
  2860 00000B69 15                      DUPLREDIR:	db 21
  2861 00000B6A 4475706C6963617465-     		db 'Duplicate redirection'
  2861 00000B73 207265646972656374-
  2861 00000B7C 696F6E             
  2862 00000B7F 10                      INVPASSWD:	db 16
  2863 00000B80 496E76616C69642070-     		db 'Invalid password'
  2863 00000B89 617373776F7264     
  2864 00000B90 11                      INVLDPARM:	db 17
  2865 00000B91 496E76616C69642070-     		db 'Invalid parameter'
  2865 00000B9A 6172616D65746572   
  2866 00000BA2 12                      NETDATFAU:	db 18
  2867 00000BA3 4E6574776F726B2064-     		db 'Network data fault'
  2867 00000BAC 617461206661756C74 
  2868 00000BB5 21                      FNOSUPNET:	db 33
  2869 00000BB6 46756E6374696F6E20-     		db 'Function not supported by network'
  2869 00000BBF 6E6F7420737570706F-
  2869 00000BC8 72746564206279206E-
  2869 00000BD1 6574776F726B       
  2870 00000BD7 27                      RSCNOTINS:	db 39
  2871 00000BD8 526571756972656420-     		db 'Required system component not installed'
  2871 00000BE1 73797374656D20636F-
  2871 00000BEA 6D706F6E656E74206E-
  2871 00000BF3 6F7420696E7374616C-
  2871 00000BFC 6C6564             
  2872                                  
  2873                                  ;; MSDOS 5.0 COMMAND.COM RESGROUP:0C8Ch
  2874                                  ; 05/06/2023
  2875                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0D8Fh
  2876                                  
  2877 00000BFF [D009]                  EXTMSGPTRS:	dw INVLFUNCT
  2878 00000C01 [E109]                  		dw FNOTFOUND
  2879 00000C03 [F009]                  		dw PNOTFOUND
  2880 00000C05 [FF09]                  		dw TOOMANYOF
  2881 00000C07 [7806]                  		dw ACCDENIED
  2882 00000C09 [130A]                  		dw INVHANDLE
  2883 00000C0B [220A]                  		dw MEMCBDEST
  2884 00000C0D [420A]                  		dw INSUFFMEM
  2885 00000C0F [560A]                  		dw INVMEMBLA
  2886 00000C11 [730A]                  		dw INVENVIRO
  2887 00000C13 [870A]                  		dw INVFORMAT
  2888 00000C15 [960A]                  		dw INVFNPARM
  2889 00000C17 [B10A]                  		dw INVLDDATA
  2890 00000C19 0000                    		dw 0
  2891 00000C1B [BE0A]                  		dw INVDRVSPC
  2892 00000C1D [DA0A]                  		dw ATRCURDIR
  2893 00000C1F [FE0A]                  		dw NOTSAMDEV
  2894 00000C21 [0E0B]                  		dw NOMOREFIL
  2895 00000C23 [2F07]                  		dw CRMSG0
  2896 00000C25 [4307]                  		dw CRMSG1
  2897 00000C27 [5007]                  		dw CRMSG2
  2898 00000C29 [5A07]                  		dw CRMSG3
  2899 00000C2B [7107]                  		dw CRMSG4
  2900 00000C2D [7C07]                  		dw CRMSG5
  2901 00000C2F [9E07]                  		dw CRMSG6
  2902 00000C31 [A907]                  		dw CRMSG7
  2903 00000C33 [BC07]                  		dw CRMSG8
  2904 00000C35 [CD07]                  		dw CRMSG9
  2905 00000C37 [E807]                  		dw CRMSG10
  2906 00000C39 [FA07]                  		dw CRMSG11
  2907 00000C3B [0B08]                  		dw CRMSG12
  2908 00000C3D [1B08]                  		dw CRMSG13
  2909 00000C3F [2D08]                  		dw CRMSG14
  2910 00000C41 [3C08]                  		dw CRMSG15
  2911 00000C43 [5008]                  		dw CRMSG16
  2912 00000C45 [6008]                  		dw CRMSG17
  2913 00000C47 [7A08]                  		dw CRMSG18
  2914 00000C49 [8D08]                  		dw CRMSG19
  2915 00000C4B [9A08]                  		dw CRMSG20
  2916 00000C4D 0000<rep 28h>           		times 40 dw 0	; db 80 dup(0)
  2917 00000C9D [1C0B]                  		dw FILEXISTS
  2918 00000C9F 0000                    		dw 0
  2919 00000CA1 [280B]                  		dw CANTMKDIR
  2920 00000CA3 [440B]                  		dw FAILINT24
  2921 00000CA5 [530B]                  		dw TOOMANYRD
  2922 00000CA7 [690B]                  		dw DUPLREDIR
  2923 00000CA9 [7F0B]                  		dw INVPASSWD
  2924 00000CAB [900B]                  		dw INVLDPARM
  2925 00000CAD [A20B]                  		dw NETDATFAU
  2926 00000CAF [B50B]                  		dw FNOSUPNET
  2927 00000CB1 [D70B]                  		dw RSCNOTINS
  2928                                  ; ----------------------------------------------------------------------------
  2929                                  	; 17/04/2023
  2930                                  ExtMsgEnd:
  2931                                  
  2932                                  ; 21/04/2023
  2933                                  NUMEXTMSGS equ ($-EXTMSGPTRS)>>1 ; 14/01/2023
  2934                                  
  2935                                  ; ----------------------------------------------------------------------------
  2936                                  
  2937                                  ; 20/04/2023
  2938                                  
  2939 00000CB3 90<rep Dh>              align 16
  2940                                  
  2941                                  ; ----------------------------------------------------------------------------
  2942                                  
  2943                                  ; 10/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2944                                  ;; MSDOS 5.0 COMMAND.COM - RESGROUP:0D40h (CODERES:0000h)
  2945                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  2946                                  ; MSDOS 6.22 COMMAND.COM - RESGROUP:0E50h (CODERES:0000h)
  2947                                  
  2948                                  ; ----------------------------------------------------------------------------
  2949                                  ; SEGMENT - CODERES
  2950                                  ; ----------------------------------------------------------------------------
  2951                                  
  2952                                  ; 11/01/2023
  2953                                  RCODE_START:	
  2954                                  
  2955                                  ; ----------------------------------------------------------------------------
  2956                                  ;***	EXEC error handling
  2957                                  ;
  2958                                  ;	COMMAND has issued an EXEC system call and it has returned an error.
  2959                                  ;	We examine the error code and select an appropriate message.
  2960                                  ; --------------------------
  2961                                  ;	Bugbug:	optimize reg usage in following code? Careful of DX!
  2962                                  ;	Condense the error scan?
  2963                                  ;	RBADNAM is checked by transient, no need here?
  2964                                  ;	Move below Ext_Exec.
  2965                                  ; ----------------------------------------------------------------------------
  2966                                  
  2967                                  Exec_Err:
  2968                                  ;SR;
  2969                                  ; ds,es are setup when the transient jumps to Ext_Exec. So segment regs are
  2970                                  ; in order here
  2971                                  
  2972                                  ;	Bugbug:	can we use byte compares here?
  2973                                  ;	Might be able to use byte msg#s, too.
  2974                                  
  2975                                  ;	Store errors in a 3 or 4 byte table. Msg #s in another.
  2976                                  ;	Speed not high priority here.
  2977                                  
  2978                                  ;	Move this to transient.
  2979                                  
  2980                                  	; 10/01/2023
  2981                                  
  2982                                  	;mov	bx,RBADNAM	; offset DATARES:RBadNam
  2983 00000CC0 BA[5D06]                	mov	dx,RBADNAM
  2984 00000CC3 3C02                    	cmp	al,ERROR_FILE_NOT_FOUND ; 2
  2985 00000CC5 741B                    	je	short GotExecEMes		; bad command
  2986                                  	;mov	bx,TOOBIG	; offset DATARES:TooBig
  2987 00000CC7 BA[2306]                	mov	dx,TOOBIG
  2988 00000CCA 3C08                    	cmp	al,ERROR_NOT_ENOUGH_MEMORY ; 8
  2989 00000CCC 7414                    	je	short GotExecEMes		; file not found
  2990                                  	;mov	bx,EXEBAD	; offset DATARES:ExeBad
  2991 00000CCE BA[0F06]                	mov	dx,EXEBAD
  2992 00000CD1 3C0B                    	cmp	al,ERROR_BAD_FORMAT ; 11 ; 0Bh
  2993 00000CD3 740D                    	je	short GotExecEMes		; bad exe file
  2994                                  	;mov	bx,ACCDEN	; offset DATARES:AccDen
  2995 00000CD5 BA[7806]                	mov	dx,ACCDEN
  2996 00000CD8 3C05                    	cmp	al,ERROR_ACCESS_DENIED ; 5
  2997 00000CDA 7406                    	je	short GotExecEMes		; access denied
  2998                                  
  2999                                  Default_Message:
  3000                                  	;mov	bx,EXECEMES	; offset DATARES:ExecEMes
  3001 00000CDC BA[FB05]                	mov	dx,EXECEMES
  3002                                  						; default message
  3003 00000CDF BE[CE01]                	mov	si,ExecErrSubst ; offset DATARES:ExecErrSubst
  3004                                  						; get address of subst block
  3005                                  GotExecEMes:
  3006                                  	;mov	dx,bx				; DX = ptr to msg
  3007 00000CE2 E85106                  	call	RPrint ; invoke	RPrint
  3008 00000CE5 EB09                    	jmp	short NoExec
  3009                                  
  3010                                  ; ----------------------------------------------------------------------------
  3011                                  ;***	EXEC call
  3012                                  ;
  3013                                  ;	The transient has set up everything for an EXEC system call.
  3014                                  ;	For cleanliness, we issue the EXEC here in the resident 
  3015                                  ;	so that we may be able to recover cleanly upon success.
  3016                                  ;
  3017                                  ;	CS,DS,ES,SS = DATARES seg addr
  3018                                  ; ----------------------------------------------------------------------------
  3019                                  
  3020                                  Ext_Exec:
  3021                                  ;SR;
  3022                                  ; The words put on the stack by the stub will be popped off when we finally
  3023                                  ;jump to LodCom (by LodCom).
  3024                                  
  3025                                  	; 10/01/2023
  3026                                  	;int	21h			; do the exec
  3027                                  	; 10/01/2023 - MSDOS 5.0 COMMAND.COM - RESGROUP:0D69h (CODERES:0029h)
  3028                                  Exec_Ret:
  3029 00000CE7 72D7                    	jc	short Exec_Err		; exec failed
  3030                                  
  3031                                  ;	The exec has completed. Retrieve the exit code.
  3032                                  
  3033                                  Exec_Wait:
  3034 00000CE9 B44D                    	mov	ah,4Dh
  3035                                  	;mov	ah,WAITPROCESS ; 4Dh	; get errorlevel
  3036 00000CEB CD21                    	int	21h			; get the return code
  3037                                  	;mov	[cs:RetCode],ax
  3038                                  	; 11/01/2023
  3039 00000CED A3[3802]                	mov	[RetCode],ax
  3040                                  
  3041                                  ;	See if we can reload the transient. The external command
  3042                                  ;	may have overwritten part of the transient.
  3043                                  
  3044                                  NoExec:
  3045                                  ;SR;
  3046                                  ; ds = es = ss = DATARES when we jump to LodCom
  3047                                  ;
  3048 00000CF0 E97801                  	jmp	LodCom
  3049                                  
  3050                                  ; ----------------------------------------------------------------------------
  3051                                  ;***	Int 23 (ctrl-c) handler
  3052                                  ;
  3053                                  ;	This is the default system INT 23 handler. All processes
  3054                                  ;	(including COMMAND) get it by default. There are some
  3055                                  ;	games that are played: We ignore ^C during most of the
  3056                                  ;	INIT code. This is because we may perform an ALLOC and
  3057                                  ;	diddle the header! Also, if we are prompting for date/time
  3058                                  ;	in the init code, we are to treat ^C as empty responses.
  3059                                  ; ---------------------------
  3060                                  ;	Bugbug:	put init ctrl-c handling in init module.
  3061                                  ; ----------------------------------------------------------------------------
  3062                                  
  3063                                  ;SR;
  3064                                  ;The stub has pushed the previous ds and DATARES onto the stack. We get
  3065                                  ;both these values off the stack now
  3066                                  ;
  3067                                  ;ContC	proc	far
  3068                                  
  3069                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  3070                                  
  3071                                  	; 11/01/2023 - Retro DOS v5.40 COMMAND.COM
  3072                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:0D75h (CODERES:0035h)
  3073                                  ContC:
  3074 00000CF3 1F                      	pop	ds			; ds = DATARES
  3075                                  ;	assume	ds:DATARES
  3076                                  ;;	pop	word [OldDS]		; OldDS = old ds
  3077                                  
  3078 00000CF4 F606[B402]01            	test	byte [InitFlag],INITINIT ; 1
  3079                                  	;test	byte [cs:INITFLAG],INITINIT ; 1	; in initialization?
  3080 00000CF9 740D                    	jz	short NotAtInit		; no
  3081 00000CFB F606[B402]02            	test	byte [InitFlag],INITSPECIAL ; 2 
  3082                                  	;test	byte [cs:INITFLAG],INITSPECIAL ; 2 ; doing special stuff?
  3083 00000D00 7404                    	jz	short CmdIret		; no, ignore ^C
  3084 00000D02 1F                      	pop	ds			; restore before jumping; M021
  3085                                  	;jmp	RESGROUP:Init_ContC_SpecialCase ; Yes, go handle it
  3086 00000D03 E92F0E                  	jmp	init_contc_specialcase
  3087                                  CmdIret:
  3088                                  ;SR;
  3089                                  ; Restore ds to its previous value
  3090                                  ;
  3091                                  
  3092                                  ;;	mov	ds,[OLdDS]		;
  3093 00000D06 1F                      	pop	ds
  3094 00000D07 CF                      	iret				; yes, ignore the ^C
  3095                                  
  3096                                  NotAtInit:
  3097 00000D08 F606[B402]04            	test	byte [InitFlag],INITCTRLC ; 4
  3098                                  	;test	byte [cs:INITFLAG],INITCTRLC ; 4 ; are we already in a ^C?
  3099 00000D0D 7411                    	jz	short NotInit 		; nope too.
  3100                                  
  3101                                  ;*	We are interrupting ourselves in this ^C handler. We need
  3102                                  ;	to set carry and return to the user sans flags only if the
  3103                                  ;	system call was a 1-12 one. Otherwise, we ignore the ^C.
  3104                                  
  3105                                  	;cmp	ah,1
  3106                                  	;jb	short CmdIret
  3107                                  	; 19/07/2024
  3108 00000D0F 84E4                    	test	ah,ah
  3109 00000D11 74F3                    	jz	short CmdIret
  3110                                  
  3111 00000D13 80FC0C                  	cmp	ah,12
  3112 00000D16 77EE                    	ja	short CmdIret
  3113                                  
  3114 00000D18 1F                      	pop	ds			;restore ds to old value
  3115 00000D19 83C406                  	add	sp,6			; remove int frame
  3116 00000D1C F9                      	stc
  3117                                  
  3118                                  ;;	mov	ds,[OldDS]		;restore ds to its old value
  3119 00000D1D CA0200                  	retf	2			; remove those flags...
  3120                                  
  3121                                  NotInit:
  3122                                  
  3123                                  ;*	We have now received a ^C for some process (maybe ourselves
  3124                                  ;	but not at INIT).
  3125                                  ;	
  3126                                  ;	Note that we are running on the user's stack!!! Bad news if
  3127                                  ;	any of the system calls below go and issue another INT
  3128                                  ;	24... Massive stack overflow! Another bad point is that
  3129                                  ;	SavHand will save an already saved handle, thus losing a
  3130                                  ;	possible redirection...
  3131                                  ;	
  3132                                  ;	All we need to do is set the flag to indicate nested ^C. 
  3133                                  ;	The above code will correctly flag the ^C diring the
  3134                                  ;	message output and prompting while ignoring the ^C the rest
  3135                                  ;	of the time.
  3136                                  ;	
  3137                                  ;	Clean up: flush disk. If we are in the middle of a batch
  3138                                  ;	file, we ask if he wants to terminate it. If he does, then
  3139                                  ;	we turn off all internal flags and let the DOS abort.
  3140                                  
  3141 00000D20 800E[B402]04            	or	byte [InitFlag],INITCTRLC ; 4
  3142                                  	;or	byte [cs:INITFLAG],INITCTRLC ; 4 ; nested ^c is on
  3143 00000D25 FB                      	sti
  3144                                  
  3145                                  ;	push	cs			; el yucko! change the user's ds!!
  3146                                  ;	pop	ds
  3147                                  
  3148                                  ;	assume	ds:RESGROUP
  3149                                  
  3150 00000D26 58                      	pop	ax			; discard the old ds value
  3151                                  
  3152 00000D27 A1[4302]                	mov	ax,[SingleCom]
  3153 00000D2A 09C0                    	or	ax,ax
  3154 00000D2C 7506                    	jnz	short NoReset
  3155 00000D2E 50                      	push	ax
  3156 00000D2F B40D                    	mov	ah,DISK_RESET ; 0Dh
  3157 00000D31 CD21                    	int	21h			; reset disks in case files were open
  3158 00000D33 58                      	pop	ax
  3159                                  
  3160                                  NoReset:
  3161                                  
  3162                                  ;	In the generalized version of FOR, PIPE and BATCH, we would
  3163                                  ;	walk the entire active list and free each segment. Here,
  3164                                  ;	we just free the single batch segment.
  3165                                  
  3166 00000D34 F706[E701]FFFF          	test	word [Batch],-1 ; 0FFFFh
  3167 00000D3A 7452                    	jz	short ContCTerm
  3168 00000D3C 09C0                    	or	ax,ax
  3169 00000D3E 754E                    	jnz	short ContCTerm
  3170 00000D40 E88502                  	call	SavHand
  3171 00000D43 E89303                  	call	AskEnd			; ask if user wants to end batch
  3172                                  
  3173                                  ;	If the carry flag is clear, we do NOT free up the batch file
  3174                                  
  3175 00000D46 7340                    	jnc	short ContBatch
  3176 00000D48 8A0E[3B02]              	mov	cl,[EchoFlag]		; get current echo flag
  3177 00000D4C 53                      	push	bx
  3178                                  
  3179                                  ClearBatch:
  3180 00000D4D 8E06[E701]              	mov	es,[Batch]		; get batch segment
  3181                                  	;mov	di,20h
  3182 00000D51 8B3E2000                	mov	di,[BATCHSEGMENT.BatFile] ; get offset of batch file name
  3183                                  	; MSDOS 5.0 & MSDOS 6.0 (ES:5)
  3184                                  	;mov	bx,es:BatForPtr		; get old FOR segment
  3185 00000D55 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
  3186                                  	; MSDOS 3.3 ([ES:4])
  3187                                  	;mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:4] ; get old FOR segment
  3188                                  	;
  3189                                  	; 19/07/2024
  3190                                  	;cmp	bx,0			; is a FOR in progress
  3191                                  	;je	short No_Bat_For	; no - don't deallocate
  3192 00000D5A 85DB                    	test	bx,bx
  3193 00000D5C 7408                    	jz	short No_Bat_For
  3194                                  
  3195 00000D5E 06                      	push	es			;
  3196 00000D5F 8EC3                    	mov	es,bx			; yes - free it up...
  3197 00000D61 B449                    	mov	ah,49h
  3198                                  	;mov	ah,DEALLOC ; 49h	;
  3199 00000D63 CD21                    	int	21h			;
  3200 00000D65 07                      	pop	es			; restore to batch segment
  3201                                  
  3202                                  No_Bat_For:
  3203                                  	;mov	cl,[es:1]
  3204 00000D66 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag] ; get old echo flag
  3205                                  	;mov	bx,[es:3]
  3206 00000D6B 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast] ; get old batch segment
  3207 00000D70 B449                    	mov	ah,49h
  3208                                  	;mov	ah,DEALLOC ; 49h	; free it up...
  3209 00000D72 CD21                    	int	21h
  3210 00000D74 891E[E701]              	mov	[Batch],bx		; get ready to deallocate next batch
  3211 00000D78 FF0E[4C02]              	dec	word [Nest]		; is there another batch file?
  3212 00000D7C 75CF                    	jnz	short ClearBatch	; keep going until no batch file
  3213                                  
  3214                                  ;	We are terminating a batch file; restore the echo status
  3215                                  
  3216                                  ;Shell_Bat_Cont: 			; continue batch for SHELL
  3217 00000D7E 5B                      	pop	bx
  3218 00000D7F 880E[3B02]              	mov	[EchoFlag],cl		; reset echo status
  3219                                  	; 29/05/2018
  3220 00000D83 C606[B502]00            	mov	byte [PipeFlag],0	; turn off pipeflag
  3221                                  
  3222                                  ContBatch:
  3223 00000D88 E8A805                  	call	crlf			; print out crlf before returning
  3224 00000D8B E86302                  	call	RestHand
  3225                                  
  3226                                  ;	Yes, we are terminating. Turn off flags and allow the DOS to abort.
  3227                                  
  3228                                  ContCTerm:
  3229 00000D8E 31C0                    	xor	ax,ax			; indicate no read
  3230 00000D90 89C5                    	mov	bp,ax
  3231                                  
  3232                                  ;	The following resetting of the state flags is good for the
  3233                                  ;	generalized batch processing.
  3234                                  
  3235 00000D92 A2[4802]                	mov	[IfFlag],al		; turn off iffing
  3236 00000D95 A2[4902]                	mov	[ForFlag],al		; turn off for processing
  3237 00000D98 E81C00                  	call	ResPipeOff
  3238 00000D9B 3906[4302]              	cmp	[SingleCom],ax		; see if we need to set SingleCom
  3239 00000D9F 7406                    	jz	short NoSetSing
  3240 00000DA1 C706[4302]FFFF          	mov	word [SingleCom],-1	; cause termination on 
  3241                                  					;  pipe, batch, for
  3242                                  NoSetSing:
  3243                                  
  3244                                  ;	If we are doing an internal command, go through the reload process.
  3245                                  ;	If we are doing an external, let DOS abort the process.
  3246                                  ;	In both cases, we are now done with the ^C processing.
  3247                                  
  3248 00000DA7 8026[B402]FB            	and	byte [InitFlag],~INITCTRLC ; 0FBh
  3249 00000DAC 3806[3702]              	cmp	[ExtCom],al
  3250 00000DB0 7503                    	jnz	short DoDAb		; internal ^c
  3251 00000DB2 E94501                  	jmp	LodCom1
  3252                                  DoDAb:
  3253 00000DB5 F9                      	stc				; tell dos to abort
  3254                                  
  3255                                  ;SR;
  3256                                  ;We dont need to restore ds here because we are forcing DOS to do an abort
  3257                                  ;by setting carry and leaving flags on the stack
  3258                                  
  3259 00000DB6 CB                      	retf				; Leave flags on stack
  3260                                  
  3261                                  ;ContC	endp
  3262                                  
  3263                                  ;SR;
  3264                                  ;ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
  3265                                  ;both have ds = DATARES
  3266                                  
  3267                                  	; 11/01/2023
  3268                                  ResPipeOff:
  3269 00000DB7 50                      	push	ax
  3270 00000DB8 31C0                    	xor	ax,ax
  3271                                  	;xchg	al,[cs:PIPEFLAG]
  3272 00000DBA 8606[B502]              	xchg	al,[PipeFlag]
  3273 00000DBE 08C0                    	or	al,al
  3274 00000DC0 7404                    	jz	short NoPipePop
  3275                                  	;shr	byte [cs:ECHOFLAG],1
  3276 00000DC2 D02E[3B02]              	shr	byte [EchoFlag],1
  3277                                  NoPipePop:
  3278 00000DC6 58                      	pop	ax
  3279 00000DC7 C3                      	retn
  3280                                  
  3281                                  ;CODERES ends
  3282                                  
  3283                                  ;=============================================================================
  3284                                  ; COMMAND2.ASM, MSDOS 6.0, 1991
  3285                                  ;=============================================================================
  3286                                  ; 21/09/2018 - Retro DOS v3.0
  3287                                  
  3288                                  ;	title	COMMAND2 - resident code for COMMAND.COM part II
  3289                                  ;	name	COMMAND2
  3290                                  
  3291                                  ;/*
  3292                                  ; *                      Microsoft Confidential
  3293                                  ; *                      Copyright (C) Microsoft Corporation 1991
  3294                                  ; *                      All Rights Reserved.
  3295                                  ; */
  3296                                  
  3297                                  ;
  3298                                  ;	Revision History
  3299                                  ;	================
  3300                                  ;
  3301                                  ; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
  3302                                  ;			reserve memory by changing int 12h and then give it
  3303                                  ;			back to DOS by changing arenas in autoexec.bat.
  3304                                  ;			This makes command.com reload transient and this
  3305                                  ;			cannot be done at this stage.
  3306                                  ;
  3307                                  
  3308                                  ;CODERES segment public byte
  3309                                  
  3310                                  ;*	If we cannot allocate enough memory for the transient or there
  3311                                  ;	was some other allocation error, we display a message and
  3312                                  ;	then die.
  3313                                  
  3314                                  ;SR;
  3315                                  ; We will have to make sure that at this entry point and at FatalC, 
  3316                                  ;ds = DATARES. All jumps to these points are made from only within this file
  3317                                  ;and so we should be able to do this
  3318                                  
  3319                                  ; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3320                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0E4Bh (CODERES:010Bh)
  3321                                  
  3322                                  	;assume	ds:DATARES
  3323                                  BadMemErr:
  3324 00000DC8 BA[8606]                	mov	dx,BMEMMES			; DX = ptr to msg
  3325                                  FatalC:
  3326                                  	; 12/01/2023
  3327                                  ;;	push	cs
  3328                                  ;;	pop	ds
  3329                                  ;;	assume	ds:ResGroup
  3330                                  ;	invoke	RPrint
  3331                                  
  3332                                  	; 12/01/2023
  3333                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  3334 00000DCB E86805                  	call	RPrint
  3335                                  
  3336                                  	; MSDOS 3.3
  3337                                  	;call	RDISPMSG
  3338                                  
  3339                                  ;	If this is NOT a permanent (top-level) COMMAND, then we exit;
  3340                                  ;	we can't do anything else!
  3341                                  
  3342 00000DCE 803E[4002]00            	cmp	byte [PermCom],0
  3343 00000DD3 7410                    	je	short FatalRet
  3344                                  
  3345                                  ;	We are a permanent command. If we are in the process of the
  3346                                  ;	magic interrupt (Singlecom) then exit too.
  3347                                  
  3348 00000DD5 833E[4302]00            	cmp	word [SingleCom],0		; if PermCom and SingleCom
  3349 00000DDA 7509                    	jne	short FatalRet			; must take int_2e exit
  3350                                  
  3351                                  ;	Permanent command. We can't do ANYthing except halt.
  3352                                  
  3353 00000DDC BA[A006]                	mov	dx,HALTMES			; DX = ptr to msg
  3354                                  	;invoke	RPrint
  3355                                  	; 12/01/2023	
  3356                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  3357 00000DDF E85405                  	call	RPrint	
  3358                                  	; MSDOS 3.3
  3359                                  	;call	RDISPMSG
  3360 00000DE2 FB                      	sti
  3361                                  Stall:
  3362 00000DE3 EBFE                    	jmp	short Stall			; crash the system nicely
  3363                                  
  3364                                  FatalRet:
  3365 00000DE5 BA[C706]                	mov	dx,FRETMES			; DX = ptr to msg
  3366                                  	;call	RDISPMSG
  3367                                  	; 12/01/2023	
  3368 00000DE8 E84B05                  	call	RPrint	
  3369                                  FatalRet2:
  3370 00000DEB 803E[4002]00            	cmp	byte [PermCom],0		; if we get here and PermCom,
  3371 00000DF0 7517                    	jne	short Ret_2e			; must be int_2e
  3372                                  
  3373                                  ;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
  3374                                  ;	were a non-permanent COMMAND that had hooked it! (Just in 
  3375                                  ;	case we decide to do that.)
  3376                                  
  3377 00000DF2 A1[DC01]                	mov	ax,[Parent]
  3378                                  	;mov	[16h],ax
  3379 00000DF5 A31600                  	mov	[PDB.PARENT_PID],ax	; mov [cs:16h],ax
  3380 00000DF8 A1[DE01]                	mov	ax,[OldTerm]
  3381                                  	;mov	[0Ah],ax
  3382 00000DFB A30A00                  	mov	[PDB.EXIT],ax		; mov [cs:0Ah],ax
  3383 00000DFE A1[E001]                	mov	ax,[OldTerm+2]
  3384                                  	;mov	[0Ch],ax
  3385 00000E01 A30C00                  	mov	[PDB.EXIT+2],ax 	; mov [cs:0Ch],ax
  3386 00000E04 B8004C                  	mov	ax,4C00h
  3387                                  	;mov	ax,(EXIT<<8) ; 4C00h		; return to lower level
  3388 00000E07 CD21                    	int	21h
  3389                                  Ret_2e:
  3390                                  ;SR;
  3391                                  ; We will ensure that ds = DATARES for all entries to this place
  3392                                  ;
  3393                                  
  3394                                  ;;	push	cs
  3395                                  ;;	pop	ds
  3396                                  ;;	assume	ds:resgroup,es:nothing,ss:nothing
  3397                                    	
  3398                                  ;	assume	ds:DATARES
  3399                                  
  3400                                  	;PUSH	CS
  3401                                  	;POP	DS
  3402                                  
  3403 00000E09 C706[4302]0000          	mov	word [SingleCom],0	; turn off SingleCom
  3404 00000E0F 8E06[FC03]              	mov	es,[Res_Tpa]
  3405                                  	;mov	ah,49h	; 12/01/2023
  3406 00000E13 B449                    	mov	ah,DEALLOC
  3407 00000E15 CD21                    	int	21h			; free up space used by transient
  3408 00000E17 8B1E[DA01]              	mov	bx,[Save_Pdb]
  3409 00000E1B B450                    	mov	ah,50h
  3410                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  3411 00000E1D CD21                    	int	21h			; current process is user
  3412 00000E1F A1[3802]                	mov	ax,[RetCode]
  3413 00000E22 803E[3702]00            	cmp	byte [ExtCom],0
  3414 00000E27 7502                    	jne	short GotECode
  3415 00000E29 31C0                    	xor	ax,ax			; internals always return 0
  3416                                  GotECode:
  3417 00000E2B C606[3702]01            	mov	byte [ExtCom],1		; force external
  3418                                  
  3419                                  ;SR; This is actually returning to the caller. However, the old code had
  3420                                  ;ds = RESGROUP so I guess we can keep ds = DATARES for us.
  3421                                  ;Yes, int 2eh can corrupt all registers so we are ok.
  3422                                  
  3423                                  	; 12/01/2023
  3424 00000E30 FF2E[D601]              	jmp	far [Int_2e_Ret]	; "iret"
  3425                                  
  3426                                  ;***	Int_2e, magic command executer
  3427                                  
  3428                                  Int_2e:
  3429                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  3430                                  ;SR;
  3431                                  ;We are going to come here from the stub with the old ds and DATARES value
  3432                                  ;pushed on the stack in that order. Pick up this stuff off the stack
  3433                                  
  3434                                  	; 12/01/2023 - Retro DOS v4.0 COMMAND.COM
  3435                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0EB7h (CODERES:0177h)
  3436                                  
  3437 00000E34 1F                      	pop	ds			; ds = DATARES
  3438                                  	;assume	ds:DATARES
  3439 00000E35 58                      	pop	ax
  3440                                  ;	;pop	ds:OldDS 		; Save old value of ds
  3441                                  
  3442                                  	;pop	word [cs:Int_2e_Ret]
  3443                                  	;pop	word [cs:Int_2e_Ret+2]	; store return address
  3444                                  	;pop	ax			; chuck flags
  3445 00000E36 8F06[D601]              	pop	word [Int_2e_Ret]
  3446 00000E3A 8F06[D801]              	pop	word [Int_2e_Ret+2]
  3447                                  	
  3448 00000E3E 83C402                  	add	sp,2
  3449                                  
  3450                                  ;;	push	cs
  3451                                  ;;	pop	es
  3452                                  
  3453 00000E41 1E                      	push	ds
  3454 00000E42 07                      	pop	es			; es = DATARES
  3455                                  ;	;mov	ds,OldDS
  3456 00000E43 8ED8                    	mov	ds,ax
  3457                                  	;assume	ds:nothing		; ds = old value
  3458                                  
  3459 00000E45 BF8000                  	mov	di,80h
  3460 00000E48 B94000                  	mov	cx,64
  3461                                  ;	Bugbug:	cld
  3462 00000E4B F3A5                    	rep	movsw
  3463 00000E4D B451                    	mov	ah,51h
  3464                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3465 00000E4F CD21                    	int	21h			; get user's header
  3466                                  	; 12/01/2023
  3467 00000E51 26891E[DA01]            	mov	[es:Save_Pdb],bx
  3468                                  	;mov	[cs:Save_Pdb],bx
  3469 00000E56 B450                    	mov	ah,50h
  3470                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  3471                                  
  3472                                  ;;	mov	bx,cs
  3473                                  ;SR;
  3474                                  ;Set ds = DATARES because BadMemErr expects this
  3475                                  
  3476                                  	; 12/01/2023
  3477 00000E58 06                      	push	es
  3478 00000E59 1F                      	pop	ds
  3479                                  	;assume	ds:DATARES
  3480                                  
  3481 00000E5A 8CDB                    	mov	bx,ds			; es = our PSP now
  3482                                  	;mov	bx,cs
  3483                                  
  3484 00000E5C CD21                    	int	21h			; current process is me
  3485                                  	;mov	word [cs:SingleCom],81h
  3486                                  	;mov	byte [cs:ExtCom],1	; make sure this case forced
  3487                                  	; 12/01/2023
  3488 00000E5E C706[4302]8100          	mov	word [SingleCom],81h
  3489 00000E64 C606[3702]01            	mov	byte [ExtCom],1		; make sure this case forced
  3490                                  
  3491                                  ;SR;
  3492                                  ;We can enter LodCom directly after a command shell is terminated or we
  3493                                  ;can fall thru from above. When we enter directly from the stub, the stack
  3494                                  ;has the old ds value and the data seg value on the stack, so that ds can
  3495                                  ;be properly set. To fake this, we push dummy values here.
  3496                                  
  3497                                  	; 12/01/2023
  3498 00000E69 1E                      	push	ds			; old value of ds
  3499 00000E6A 1E                      	push	ds			; data seg value, ds = DATARES
  3500                                  LodCom: 				; termination handler
  3501 00000E6B 1F                      	pop	ds			; ds = DATARES
  3502                                  	;assume	ds:DATARES
  3503 00000E6C 83C402                  	add	sp,2
  3504                                  ;	;pop	OldDS			; store old ds
  3505                                  	;cmp	ExtCom,0
  3506 00000E6F 803E[3702]00            	cmp	byte [ExtCom],0
  3507                                  	;cmp	byte [cs:ExtCom],0
  3508                                  	;jne	short @f	 	; internal cmd - memory allocated
  3509                                  	; 16/04/2023
  3510 00000E74 7503                    	jne	short LodCom0 ; 24/09/2018
  3511 00000E76 E98100                  	jmp	LodCom1
  3512                                  	;je	short LodCom1 ; 25/09/2018	
  3513                                  ;@@:
  3514                                  LodCom0: ; 24/09/2018
  3515 00000E79 BBFFFF                  	mov	bx,0FFFFh
  3516 00000E7C B448                    	mov	ah,48h	; 12/01/2023
  3517                                  	;mov	ah,ALLOC ; 48h	
  3518 00000E7E CD21                    	int	21h		; DOS - 2+ - ALLOCATE MEMORY
  3519                                  				; BX = number of 16-byte paragraphs desired
  3520 00000E80 E80A00                  	call	SetSize
  3521 00000E83 83C020                  	add	ax,20h
  3522 00000E86 39C3                    	cmp	bx,ax
  3523 00000E88 730B                    	jnb	short MemOk		; > 512 byte buffer - good enough
  3524                                  BadMemErrJ:
  3525 00000E8A E93BFF                  	jmp	BadMemErr		; not enough memory
  3526                                  
  3527                                  ;***	SetSize - get transient size in paragraphs
  3528                                  
  3529                                  SetSize:
  3530                                  	; 12/01/2023
  3531                                  	;;;mov	ax,offset TRANGROUP:TranSpaceEnd + 15
  3532                                  	;;mov	ax,98D4h		; MSDOS 5.0 COMMAND.COM
  3533                                  	; 05/06/2023
  3534                                  	;mov	ax,0AFA4h		; MSDOS 6.22 COMMAND.COM
  3535 00000E8D B836AA                  	mov	ax,TRANSPACEEND+15	; mov AX,4D6Bh ; MSDOS 3.3
  3536 00000E90 B104                    	mov	cl,4
  3537 00000E92 D3E8                    	shr	ax,cl
  3538 00000E94 C3                      	retn
  3539                                  
  3540                                  MemOk:
  3541                                  	;assume	ds:DATARES		;we have set ds = DATARES 
  3542                                  
  3543 00000E95 B448                    	mov	ah,48h
  3544                                  	;mov	ah,ALLOC  ; 48h
  3545 00000E97 CD21                    	int	21h
  3546 00000E99 72EF                    	jc	short BadMemErrJ	; memory arenas probably trashed
  3547                                  	;mov	byte [cs:ExtCom],0
  3548                                  	;mov	[cs:Res_Tpa],ax
  3549                                  	; 12/01/2023
  3550 00000E9B C606[3702]00            	mov	byte [ExtCom],0		; flag not to alloc again
  3551 00000EA0 A3[FC03]                	mov	[Res_Tpa],ax		; save current tpa segment
  3552                                  
  3553 00000EA3 2500F0                  	and	ax,0F000h
  3554 00000EA6 050010                  	add	ax,1000h		; round up to next 64k boundary
  3555 00000EA9 7212                    	jc	short Bad_Tpa		; memory wrap if carry set
  3556                                  
  3557                                  ;	Make sure that new boundary is within allocated range
  3558                                  
  3559                                  	;mov	dx,[cs:Res_Tpa]
  3560                                  	; 12/01/2023
  3561 00000EAB 8B16[FC03]              	mov	dx,[Res_Tpa]
  3562 00000EAF 01DA                    	add	dx,bx			; compute maximum address
  3563 00000EB1 39C2                    	cmp	dx,ax			; is 64k address out of range?
  3564 00000EB3 7608                    	jbe	short Bad_Tpa
  3565                                  
  3566                                  ;	Must have 64K of usable space.
  3567                                  
  3568 00000EB5 29C2                    	sub	dx,ax			; compute the usable space
  3569 00000EB7 81FA0010                	cmp	dx,1000h		; is space >= 64k ?
  3570 00000EBB 7303                    	jae	short LTpaSet
  3571                                  Bad_Tpa:
  3572                                  	;mov	ax,[cs:Res_Tpa]
  3573                                  	; 12/01/2023
  3574 00000EBD A1[FC03]                	mov	ax,[Res_Tpa]
  3575                                  LTpaSet:
  3576                                  	;mov	[cs:LTPA],ax
  3577                                  	;mov	ax,[cs:Res_Tpa]
  3578                                  	; 12/01/2023
  3579 00000EC0 A3[EE03]                	mov	[LTpa],ax		; usable tpa is 64k buffer aligned
  3580 00000EC3 A1[FC03]                	mov	ax,[Res_Tpa]		; actual tpa is buffer allocated
  3581 00000EC6 01C3                    	add	bx,ax
  3582                                  	;mov	[cs:MemSiz],bx
  3583 00000EC8 891E[3302]              	mov	[MemSiz],bx
  3584 00000ECC E8BEFF                  	call	SetSize
  3585 00000ECF 29C3                    	sub	bx,ax
  3586                                  
  3587                                  	; MSDOS 6.0
  3588                                  
  3589                                  ;M038; Start of changes
  3590                                  ;Changes for Novell RPL. These guys reserve memory for themselves by
  3591                                  ;reducing int 12h size and add this memory to the system at autoexec time by
  3592                                  ;running a program that changes arenas. This changes the largest block that
  3593                                  ;command.com gets and so changes the transient segment. So, command.com does
  3594                                  ;a checksum at the wrong address and thinks that the transient is destroyed
  3595                                  ;and tries to reload it. At this point, no Comspec is defined and so the
  3596                                  ;reload fails, hanging the system. To get around this we just copy the
  3597                                  ;transient from the previous address to the new address(if changed) and
  3598                                  ;then let command.com do the checksum. So, if the transient area is not
  3599                                  ;corrupted, there will not be any reload. In Novell's case, the transient
  3600                                  ;is not really corrupted and so this should work.
  3601                                  
  3602                                  	; 12/01/2023
  3603                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0F5Ah (CODERES:021Ah)
  3604                                  
  3605 00000ED1 3B1E[2D02]              	cmp	bx,[TrnSeg]		; Segment still the same?
  3606 00000ED5 7423                    	je	short LodCom1		; yes, dont copy
  3607                                  
  3608                                  ;Check if the new segment is above or below the current move. If the new
  3609                                  ;segment is above (i.e new block is larger than previous block), then we
  3610                                  ;have to move in the reverse direction
  3611                                  
  3612                                  	;;mov	cx,98C5h
  3613                                  	; 05/06/2023
  3614                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:106Ah (CODERES:021Ah)
  3615                                  	;mov	cx,0AF95h
  3616 00000ED7 B927AA                  	mov	cx,TRANSPACEEND		; cx = length to move
  3617 00000EDA 7707                    	ja	short mov_down		; new seg > old seg, reverse move
  3618 00000EDC 31F6                    	xor	si,si			; normal move
  3619 00000EDE 89F7                    	mov	di,si
  3620 00000EE0 FC                      	cld
  3621 00000EE1 EB06                    	jmp	short copy_trans
  3622                                  mov_down:
  3623 00000EE3 89CE                    	mov	si,cx			; reverse move, start from end
  3624 00000EE5 4E                      	dec	si
  3625 00000EE6 89F7                    	mov	di,si
  3626 00000EE8 FD                      	std
  3627                                  copy_trans:
  3628 00000EE9 1E                      	push	ds
  3629 00000EEA 06                      	push	es
  3630 00000EEB 8EC3                    	mov	es,bx			; dest segment
  3631 00000EED 8E1E[2D02]              	mov	ds,[TrnSeg]		; source segment
  3632                                  	;assume	ds:nothing
  3633                                  
  3634 00000EF1 F3A4                    	rep	movsb			; copy transient
  3635 00000EF3 FC                      	cld
  3636 00000EF4 07                      	pop	es
  3637 00000EF5 1F                      	pop	ds
  3638                                  	;assume	ds:DATARES
  3639                                  
  3640                                  ;M038; End of changes
  3641                                  
  3642                                  	;mov	[cs:TrnSeg],bx		; new location of transient
  3643                                  	; 12/01/2023
  3644 00000EF6 891E[2D02]              	mov	[TrnSeg],bx
  3645                                  
  3646                                  LodCom1:
  3647                                  ;;	mov	ax,cs
  3648                                  ;;	mov	ss,ax
  3649                                  ;SR; At this point ds = DATARES which is where the stack is located
  3650                                  
  3651                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3652                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  3653 00000EFA 8CD8                    	mov	ax,ds
  3654 00000EFC 8ED0                    	mov	ss,ax
  3655                                  	;assume	ss:DATARES
  3656                                  	;;;mov	sp,offset DATARES:RStack
  3657                                  	;;mov	sp,53Eh
  3658                                  	; 05/06/2023
  3659                                  	;mov	sp,60Ah ; MSDOS 6.22 COMMAND.COM
  3660 00000EFE BC[D604]                	mov	sp,RStack
  3661                                  
  3662                                  ;;	mov	ds,ax
  3663                                  
  3664                                  	;assume	ds:DATARES
  3665                                  	
  3666                                  	; MSDOS 3.3
  3667                                  	;mov	ax,cs
  3668                                  	;mov	ss,ax
  3669                                  	;mov	sp,RSTACK
  3670                                  	;mov	ds,ax
  3671                                  
  3672 00000F01 E87B00                  	call	HeadFix			; close files, restore stdin, stdout
  3673 00000F04 31ED                    	xor	bp,bp			; flag command ok
  3674 00000F06 B8FFFF                  	mov	ax,-1
  3675 00000F09 8706[4502]              	xchg	ax,[VerVal]
  3676 00000F0D 83F8FF                  	cmp	ax,-1
  3677 00000F10 7404                    	je	short NoSetVer
  3678 00000F12 B42E                    	mov	ah,2Eh
  3679                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh ; AL has correct value
  3680 00000F14 CD21                    	int	21h 		; DOS - SET VERIFY FLAG
  3681                                  				; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
  3682                                  NoSetVer:
  3683 00000F16 833E[4302]FF            	cmp	word [SingleCom],-1
  3684 00000F1B 7503                    	jne	short NoSng
  3685 00000F1D E9CBFE                  	jmp	FatalRet2		; we have finished the single command
  3686                                  NoSng:
  3687 00000F20 E87201                  	call	ChkSum			; check the transient
  3688                                  	;cmp	dx,[Sum]
  3689                                  	;je	short HavCom		; transient ok
  3690                                  	; 12/01/2023
  3691 00000F23 7412                    	jz	short HavCom
  3692                                  Bogus_Com:
  3693 00000F25 C606[E601]01            	mov	byte [Loading],1	; flag DskErr routine
  3694 00000F2A E81E01                  	call	LoadCom
  3695                                  ChkSame:
  3696 00000F2D E86501                  	call	ChkSum
  3697                                  	;cmp	dx,[Sum]
  3698                                  	;je	short HavCom		; same command
  3699                                  	; 12/01/2023
  3700 00000F30 7405                    	jz	short HavCom
  3701                                  Also_Bogus:
  3702 00000F32 E85801                  	call	WrongCom
  3703 00000F35 EBF6                    	jmp	short ChkSame
  3704                                  
  3705                                  	; 12/01/2023
  3706                                  ;HavCom:
  3707                                  ;	; 25/09/2018
  3708                                  ;	mov     ax,(CHAR_OPER*256) ; 3700h
  3709                                  ;	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  3710                                  ;			; Return: AL = FFh unsupported subfunction
  3711                                  ;			; DL = current switch character
  3712                                  ;	mov     [RSWITCHAR],dl
  3713                                  ;	cmp     dl,'/'
  3714                                  ;	jnz     short USESLASH
  3715                                  ;	;mov	cl,'\'
  3716                                  ;	;mov	[RDIRCHAR],cl
  3717                                  ;	mov	byte [RDIRCHAR],'\'
  3718                                  ;USESLASH:
  3719                                  
  3720                                  HavCom:
  3721                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
  3722 00000F37 C606[E601]00            	mov	byte [Loading],0		; flag to DskErr
  3723                                  	;;;mov	si,offset DATARES:TranVars
  3724                                  	;;mov	si,453h		; MSDOS 5.0 COMMAND.COM
  3725                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  3726                                  	;mov	si,51Dh		; MSDOS 6.22 COMMAND.COM
  3727 00000F3C BE[EA03]                	mov	si,TranVars
  3728                                  	;;;mov	di,offset TRANGROUP:HeadCall
  3729                                  	;;mov	di,8D75h	; MSDOS 5.0 COMMAND.COM
  3730                                  	; 05/06/2023
  3731                                  	;mov	di,0A303h	; MSDOS 6.22 COMMAND.COM
  3732 00000F3F BF[139E]                	mov	di,HEADCALL
  3733 00000F42 8E06[2D02]              	mov	es,[TrnSeg]
  3734 00000F46 FC                      	cld
  3735                                  	;;mov	cx,467h		; MSDOS 5.0 COMMAND.COM	
  3736                                  	;mov	cx,533h		; MSDOS 6.22 COMMAND.COM	
  3737 00000F47 B9[0004]                	mov	cx,TranVarEnd
  3738 00000F4A 29F1                    	sub	cx,si
  3739 00000F4C F3A4                    	rep	movsb			; transfer info to transient
  3740 00000F4E A1[3302]                	mov	ax,[MemSiz]
  3741 00000F51 A30200                  	mov	[PDB.BLOCK_LEN],ax ; mov [ds:2],ax ; adjust my own header
  3742                                  
  3743                                  ;***	TJmp - jump-off to transient
  3744                                  ;
  3745                                  ;	Public label so debugger can find this spot.
  3746                                  
  3747                                  TJmp:	; 12/01/2023
  3748 00000F54 FF2E[2B02]              	jmp	far [Trans]		; jmp dword ptr Trans
  3749                                  
  3750                                  ;***	TRemCheck - far version of RemCheck for transient
  3751                                  
  3752                                  TRemCheck:
  3753                                  	; 12/01/2023
  3754 00000F58 1F                      	pop	ds			; ds = DATARES
  3755 00000F59 83C402                  	add	sp,2			; discard old value of ds
  3756                                  
  3757 00000F5C E80100                  	call	RemCheck
  3758 00000F5F CB                      	retf
  3759                                  
  3760                                  ;***	RemCheck
  3761                                  ;
  3762                                  ;	ENTRY	AL = drive (0=default, 1=A, ...)
  3763                                  ;
  3764                                  ;	EXIT	ZR set if removeable media
  3765                                  ;		ZR clear if fixed media
  3766                                  ;
  3767                                  ;	USED	none
  3768                                  
  3769                                  	; 12/01/2023
  3770                                  RemCheck:
  3771 00000F60 50                      	push	ax
  3772 00000F61 53                      	push	bx
  3773 00000F62 89C3                    	mov	bx,ax
  3774 00000F64 B80844                  	mov	ax,4408h
  3775                                  	;mov	ax,(IOCTL<<8)+8 ; 4408h
  3776 00000F67 CD21                    	int	21h		; DOS - 2+ - IOCTL -
  3777 00000F69 7304                    	jnc	short rcCont		
  3778                                  
  3779                                  ;	If an error occurred, assume the media is non-removable.
  3780                                  ;	AX contains the non-zero error code from the int 21, so
  3781                                  ;	'or ax,ax; sets non-zero. This behavior makes network drives
  3782                                  ;	appear to be non-removable.				
  3783                                  					
  3784 00000F6B 09C0                    	or	ax,ax			
  3785 00000F6D EB05                    	jmp	short ResRegs
  3786                                  rcCont:
  3787 00000F6F 83E001                  	and	ax,1
  3788 00000F72 F7D0                    	not	ax
  3789                                  ResRegs:
  3790 00000F74 5B                      	pop	bx
  3791 00000F75 58                      	pop	ax
  3792 00000F76 C3                      	retn
  3793                                  
  3794                                  ;***	THeadFix
  3795                                  ;
  3796                                  ;	Far version of HeadFix, called from transient.
  3797                                  
  3798                                  THeadFix:
  3799                                  	; 12/01/2023
  3800 00000F77 1F                      	pop	ds			; ds = DATARES
  3801 00000F78 83C402                  	add	sp,2			; discard old ds value on stack
  3802                                  
  3803 00000F7B E80100                  	call	HeadFix
  3804 00000F7E CB                      	retf
  3805                                  
  3806                                  ;***	HeadFix
  3807                                  
  3808                                  	; 12/01/2023
  3809                                  HeadFix:
  3810 00000F7F E83101                  	call	SetVect			; set vectors to our values
  3811                                  
  3812                                  ;	Clean up header
  3813                                  
  3814                                  ;	Bugbug:	optimize:
  3815                                  ;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes
  3816                                  
  3817 00000F82 31DB                    	xor	bx,bx			; BX = handle = 0
  3818 00000F84 8B0E[3D02]              	mov	cx,[Io_Save]		; CX = original stdin, stdout
  3819                                  	;mov	dx,[18h] 
  3820 00000F88 8B161800                	mov	dx,[PDB.JFN_TABLE]	; DX = current stdin, stdout
  3821 00000F8C 38D1                    	cmp	cl,dl
  3822 00000F8E 7408                    	je	short Chk1		; stdin matches
  3823 00000F90 B43E                    	mov	ah,3Eh
  3824                                  	;mov	ah,CLOSE  ; 3Eh
  3825 00000F92 CD21                    	int	21h			; close stdin
  3826                                  	;mov	[18h],cl
  3827 00000F94 880E1800                	mov	[PDB.JFN_TABLE],cl	; restore stdin
  3828                                  Chk1:
  3829 00000F98 43                      	inc	bx			; BX = handle = 1
  3830 00000F99 38F5                    	cmp	ch,dh			
  3831 00000F9B 7408                    	je	short ChkOtherHand	; stdout matches
  3832 00000F9D B43E                    	mov	ah,3Eh
  3833                                  	;mov	ah,CLOSE
  3834 00000F9F CD21                    	int	21h			; close stdout
  3835                                  	;mov	[19h],ch
  3836 00000FA1 882E1900                	mov	[PDB.JFN_TABLE+1],ch	; restore stdout
  3837                                  ChkOtherHand:
  3838 00000FA5 83C304                  	add	bx,4			; skip handles 2,3,4
  3839 00000FA8 B90F00                  	mov	cx,FILPERPROC-5	; 15	; CX = # handles to close
  3840                                  					; (handles 0-4 already done)
  3841                                  CloseLoop:
  3842 00000FAB B43E                    	mov	ah,3Eh
  3843                                  	;mov	ah,CLOSE ; 3Eh
  3844 00000FAD CD21                    	int	21h			; close each handle
  3845 00000FAF 43                      	inc	bx			; BX = next handle
  3846 00000FB0 E2F9                    	loop	CloseLoop
  3847                                  
  3848                                  	; MSDOS 6.0
  3849                                  ;	Bugbug:	since this is for transient code, move it there
  3850                                  	
  3851                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3852                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:103Dh)
  3853                                  
  3854                                  ;	M012: remove this CS -> DS. Must've been missed during
  3855                                  ;	purification.
  3856                                  ;;	push	ds			; save data segment
  3857                                  ;;	push	cs			; get local segment into DS
  3858                                  ;;	pop	ds			;
  3859 00000FB2 803E[6202]FF            	cmp	byte [Append_Flag],-1	; do we need to reset APPEND?
  3860 00000FB7 750E                    	jne	short Append_Fix_End	; no - just exit
  3861 00000FB9 B807B7                  	mov	ax,0B707h
  3862                                  	;mov	ax,AppendSetState	; set the state of Append
  3863 00000FBC 8B1E[6002]              	mov	bx,[Append_State] 	; back to the original state
  3864 00000FC0 CD2F                    	int	2Fh			;
  3865 00000FC2 C606[6202]00            	mov	byte [Append_Flag],0	; set append flag to invalid
  3866                                  Append_Fix_End: 			;
  3867                                  ;;	pop	ds			; get data segment back
  3868 00000FC7 C3                      	retn
  3869                                  
  3870                                  	; MSDOS 3.3
  3871                                  	;retn
  3872                                  
  3873                                  ;***	SavHand - save current program's stdin/out & set to our stderr
  3874                                  ;
  3875                                  ;	ENTRY	nothing
  3876                                  ;
  3877                                  ;	EXIT	nothing
  3878                                  ;
  3879                                  ;	USED	flags
  3880                                  ;
  3881                                  ;	EFFECTS
  3882                                  ;	  Handle01 = current program's stdin,stdout JFN entries
  3883                                  ;	  current program's stdin,stdout set to our stderr
  3884                                  ;
  3885                                  
  3886                                  ;SR;
  3887                                  ; Changed ds = DATARES. We need it to access our JFN_Table
  3888                                  ; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
  3889                                  
  3890                                  SavHand:
  3891                                  	;assume	ds:DATARES,es:NOTHING,ss:NOTHING
  3892                                  
  3893                                  	; 12/01/2023
  3894                                  	;push	ds ; MSDOS 3.3
  3895                                  
  3896 00000FC8 53                      	push	bx			;preserve registers
  3897 00000FC9 50                      	push	ax
  3898                                  	; 12/01/2023
  3899 00000FCA 06                      	push	es
  3900 00000FCB 1E                      	push	ds			; save DATARES value
  3901                                  
  3902 00000FCC B451                    	mov	ah,51h
  3903                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3904 00000FCE CD21                    	int	21h			; BX = user's header seg addr
  3905 00000FD0 8EDB                    	mov	ds,bx			; DS = user's header seg addr
  3906                                  	;lds	bx,[34h]	
  3907 00000FD2 C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to JFN table
  3908 00000FD6 8B07                    	mov	ax,[bx]			; AX = stdin,stdout JFN's
  3909                                  	; 12/01/2023
  3910 00000FD8 07                      	pop	es			; es = DATARES
  3911 00000FD9 06                      	push	es			; save it back on stack
  3912 00000FDA 26A3[E401]              	mov	[es:Handle01],ax	; save user's stdin, stdout
  3913                                  	;mov	[cs:HANDLE01],ax
  3914                                  
  3915                                  ;SR;
  3916                                  ; Use es to address Handle01 & our JFN_Table
  3917                                  
  3918                                  	; 12/01/2023
  3919                                  	;mov	al,[es:1Ah]
  3920 00000FDE 26A01A00                	mov	al,[es:PDB.JFN_TABLE+2] ; AL = COMMAND stderr
  3921                                  	;mov	al,[cs:PDB.JFN_TABLE+2] ; mov al,[cs:1Ah]
  3922 00000FE2 88C4                    	mov	ah,al			; AH = COMMAND stderr
  3923 00000FE4 8907                    	mov	[bx],ax			; set user's stdin/out to our stderr
  3924                                  	; 12/01/2023
  3925 00000FE6 1F                      	pop	ds			; restore registers
  3926 00000FE7 07                      	pop	es
  3927 00000FE8 58                      	pop	ax
  3928 00000FE9 5B                      	pop	bx
  3929                                  	;pop	ds ; MSDOS 3.3
  3930 00000FEA C3                      	retn
  3931                                  
  3932                                  	;assume	ds:DATARES
  3933                                  GetComDsk2:
  3934 00000FEB E81F00                  	call	GetComDsk
  3935 00000FEE E909FF                  	jmp	LodCom1			; memory already allocated
  3936                                  
  3937                                  RestHand:
  3938 00000FF1 1E                      	push	ds
  3939 00000FF2 53                      	push	bx			; restore stdin, stdout to user
  3940 00000FF3 50                      	push	ax
  3941                                  	; 12/01/2023
  3942 00000FF4 B451                    	mov	ah,51h
  3943                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3944 00000FF6 CD21                    	int	21h			; point to user's header
  3945 00000FF8 A1[E401]                	mov	ax,[Handle01]
  3946 00000FFB 8EDB                    	mov	ds,bx
  3947                                  	;assume ds:NOTHING
  3948                                  	;lds	bx,[34h] 
  3949 00000FFD C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to jfn table
  3950 00001001 8907                    	mov	[bx],ax			; stuff his old 0 and 1
  3951 00001003 58                      	pop	ax
  3952 00001004 5B                      	pop	bx
  3953 00001005 1F                      	pop	ds
  3954 00001006 C3                      	retn
  3955                                  
  3956                                  	;assume ds:DATARES,ss:DATARES
  3957                                  Hopeless:
  3958 00001007 BA[8405]                	mov	dx,COMBAD
  3959 0000100A E9BEFD                  	jmp	FatalC
  3960                                  
  3961                                  GetComDsk:
  3962 0000100D A0[3202]                	mov	al,[ComDrv]
  3963 00001010 E84DFF                  	call	RemCheck
  3964 00001013 75F2                    	jnz	short Hopeless		; non-removable media
  3965                                  GetComDsk3:
  3966 00001015 81FA[8405]              	cmp	dx,COMBAD		; cmp dx,offset DATARES:ComBad
  3967 00001019 7503                    	jne	short GetComDsk4
  3968                                  	;;mov	dx,offset DATARES:ComBad ; DX = ptr to msg
  3969                                  	; 12/01/2023
  3970                                  	;;mov	dx,COMBAD ; (MSDOS 5.0 COMMAND.COM - RESGROUP:10A6h)
  3971                                  	; 05/06/2023
  3972                                  	;mov	dx,COMBAD ; (MSDOS 6.22 COMMAND.COM - RESGROUP:11B6h)
  3973                                  	;invoke	RPrint			; say COMMAND is invalid
  3974 0000101B E81803                  	call	RPrint
  3975                                  	;call	RDISPMSG
  3976                                  
  3977                                  GetComDsk4:
  3978                                  
  3979                                  ;	Bugbug:	there's always a drive here? No need to check?
  3980                                  
  3981 0000101E 803E[CD01]00            	cmp	byte [PutBackDrv],0	; is there a drive in the comspec?
  3982 00001023 7509                    	jne	short Users_Drive	; yes - use it
  3983 00001025 B419                    	mov	ah,19h
  3984                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h ; use default drive
  3985 00001027 CD21                    	int	21h
  3986 00001029 0441                    	add	al,"A"                  ; convert to ascii
  3987 0000102B A2[CD01]                	mov	[PutBackDrv],al		; put in message to print out
  3988                                  
  3989                                  Users_Drive:
  3990                                  	; 12/01/2023
  3991                                  	; MSDOS 6.0
  3992 0000102E BA[9A05]                	mov	dx,PUTBACKMSG		; prompt for diskette
  3993                                  	;mov	si,offset DATARES:PutBackSubst
  3994                                  	;invoke	RPrint
  3995 00001031 BE[C701]                	mov	si,PutBackSubst		; containing COMMAND
  3996 00001034 E8FF02                  	call	RPrint
  3997                                  	;mov	dx,offset DATARES:Prompt
  3998                                  	;invoke	RPrint
  3999 00001037 BA[BC05]                	mov	dx,PROMPT		; "Press any key"
  4000 0000103A E8F902                  	call	RPrint
  4001                                  
  4002                                  	; MSDOS 3.3
  4003                                  	;mov	dx,PUTBACKMSG		; prompt for diskette
  4004                                  	;call	RDISPMSG
  4005                                  	;mov	dx,[PUTBACKSUBSTPTR]
  4006                                  	;mov	si,[COMSPEC_END]
  4007                                  	;mov	byte [si+1],'$'
  4008                                  	;call	RDISPMSG
  4009                                  	;mov	byte [si+1],0
  4010                                  	;mov	dx,PROMPT
  4011                                  	;call	RDISPMSG
  4012                                  
  4013                                  	;call	GetRawFlushedByte
  4014                                  	;retn
  4015                                  	; 12/01/2023
  4016                                  	;jmp	short GetRawFlushedByte
  4017                                  
  4018                                  ;***	GetRawFlushedByte - flush world and get raw input
  4019                                  
  4020                                  GetRawFlushedByte:
  4021                                  	; 12/01/2023
  4022 0000103D B8070C                  	mov	ax,0C07h
  4023                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) | RAW_CON_INPUT ; 0C07h
  4024 00001040 CD21                    	int	21h			; get char without testing or echo
  4025 00001042 B8000C                  	mov	ax,0C00h
  4026                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + 0 ; 0C00h
  4027 00001045 CD21                    	int	21h
  4028                                  
  4029                                  ;	Bugbug:	get rid of this return and the following retz.
  4030                                  
  4031                                  LoadCom_retn:
  4032 00001047 C3                      	retn
  4033                                  
  4034                                  	; 21/04/2023
  4035                                  TryDoOpen:
  4036 00001048 E8C2FF                  	call	GetComDsk
  4037                                  	;jmp	short LoadCom
  4038                                  
  4039                                  ;***	LoadCom - load in transient
  4040                                  
  4041                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4042                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:10DAh - CODERES:039Ah)
  4043                                  
  4044                                  LoadCom:
  4045                                  	;assume	ds:DATARES
  4046                                  	
  4047 0000104B 45                      	inc	bp				; flag command read
  4048                                  
  4049 0000104C BA[E901]                	mov	dx,ComSpec
  4050 0000104F B8003D                  	mov	ax,3D00h
  4051                                  	;mov	ax,OPEN<<8	; 3D00h
  4052 00001052 CD21                    	int	21h				; open command.com
  4053 00001054 730B                    	jnc	short ReadCom
  4054                                  	;cmp	ax,4
  4055 00001056 83F804                  	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
  4056 00001059 75ED                    	jnz	short TryDoOpen
  4057 0000105B BA[4606]                	mov	dx,NOHANDMES
  4058 0000105E E96AFD                  	jmp	FatalC				; will never find a handle
  4059                                  
  4060                                  	; 21/04/2023
  4061                                  ;TryDoOpen:
  4062                                  	;call	GetComDsk
  4063                                  	;jmp	short LoadCom
  4064                                  
  4065                                  ReadCom:
  4066 00001061 89C3                    	mov	bx,ax				; BX = handle
  4067                                  	;mov	dx,offset RESGROUP:TranStart
  4068                                  	; 05/06/2023
  4069                                  	;mov	dx,26E0h ; MSDOS 6.22 COMMAND.COM
  4070 00001063 BA5025                  	mov	dx,TRANSTART
  4071 00001066 31C9                    	xor	cx,cx				; CX:DX = seek loc
  4072 00001068 B80042                  	mov	ax,4200h
  4073                                  	;mov	ax,LSEEK<<8	; 4200h
  4074 0000106B CD21                    	int	21h
  4075 0000106D 7210                    	jc	short WrongCom1
  4076                                  	; 12/01/2023
  4077                                  	;;mov	cx,offset TRANGROUP:TranSpaceEnd - 100h
  4078                                  	;mov	cx,97C5h		 ; MSDOS 5.0 COMMAND.COM
  4079                                  	; 05/06/2023
  4080                                  	;mov	cx,0AE95h		 ; MSDOS 6.22 COMMAND.COM
  4081 0000106F B927A9                  	mov	cx,TRANSPACEEND-100h ; 4C5Ch (for original MSDOS 3.3!)
  4082 00001072 1E                      	push	ds
  4083 00001073 8E1E[2D02]              	mov	ds,[TrnSeg]
  4084                                  	;assume	ds:NOTHING
  4085 00001077 BA0001                  	mov	dx,100h
  4086 0000107A B43F                    	mov	ah,3Fh
  4087                                  	;mov	ah,READ	; 3Fh	
  4088 0000107C CD21                    	int     21h	; DOS - 2+ - READ FROM FILE WITH HANDLE
  4089                                  			; BX = file handle, CX = number of bytes to read
  4090                                  			; DS:DX -> buffer
  4091 0000107E 1F                      	pop	ds
  4092                                  	;assume	ds:DATARES
  4093                                  WrongCom1:
  4094 0000107F 9C                      	pushf
  4095 00001080 50                      	push	ax
  4096 00001081 B43E                    	mov	ah,3Eh
  4097                                  	;mov	ah,CLOSE ; 3Eh
  4098 00001083 CD21                    	int	21h			; close command.com
  4099 00001085 58                      	pop	ax
  4100 00001086 9D                      	popf
  4101 00001087 7204                    	jc	short WrongCom		; error on read
  4102 00001089 39C8                    	cmp	ax,cx
  4103                                  	;retz				; size matched
  4104 0000108B 74BA                    	jz	short LoadCom_retn
  4105                                  WrongCom:
  4106 0000108D BA[8405]                	mov	dx,COMBAD
  4107 00001090 E87AFF                  	call	GetComDsk
  4108 00001093 EBB6                    	jmp	short LoadCom		; try again
  4109                                  
  4110                                  ;***	ChkSum - compute transient checksum
  4111                                  
  4112                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4113                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1129h
  4114                                  	
  4115                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  4116                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1239h
  4117                                  ChkSum:
  4118 00001095 1E                      	push	ds
  4119 00001096 8E1E[2D02]              	mov	ds,[TrnSeg]
  4120 0000109A BE0001                  	mov	si,100h
  4121                                  	;;;mov	cx,offset TRANGROUP:TranDataEnd - 100h
  4122                                  	;;mov	cx,87C2h ; MSDOS 5.0
  4123                                  	; 05/06/2023
  4124                                  	;mov	cx,9D53h ; MSDOS 6.22
  4125 0000109D B9[6398]                	mov	cx,TRANDATAEND-100h	; 3E44h (for original MSDOS 3.3!)
  4126                                  Check_Sum:
  4127 000010A0 FC                      	cld
  4128 000010A1 D1E9                    	shr	cx,1
  4129 000010A3 31D2                    	xor	dx,dx
  4130                                  Chk:
  4131 000010A5 AD                      	lodsw
  4132 000010A6 01C2                    	add	dx,ax
  4133 000010A8 83D200                  	adc	dx,0
  4134 000010AB E2F8                    	loop	Chk
  4135                                  
  4136                                  	; 04/05/2023
  4137 000010AD 1F                      	pop	ds
  4138                                  
  4139                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4140 000010AE 3B16[3502]              	cmp	dx,[Sum]
  4141                                  
  4142                                  	;pop	ds ; 04/05/2023
  4143 000010B2 C3                      	retn
  4144                                  
  4145                                  ;***	SetVect - set interrupt vectors
  4146                                  
  4147                                  SetVect:
  4148                                  	;mov	dx,offset DATARES:LodCom_Trap 
  4149                                  	; 12/01/2023
  4150 000010B3 BA[7E00]                	mov	dx,LodCom_Trap
  4151                                  	;mov	dx,LODCOM ; MSDOS 3.3
  4152 000010B6 B82225                  	mov	ax,2522h
  4153                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8) | 22h  ; 2522h
  4154 000010B9 89160A00                	mov	[PDB.EXIT],dx	; mov ds:0Ah,dx
  4155 000010BD 8C1E0C00                	mov	[PDB.EXIT+2],ds ; mov ds:0Ch,ds
  4156 000010C1 CD21                    	int	21h
  4157                                  	;mov	dx,offset DATARES:Ctrlc_Trap
  4158 000010C3 BA[4A00]                	mov	dx,Ctrlc_Trap
  4159                                  	;mov	dx,CONTC ; MSDOS 3.3
  4160 000010C6 FEC0                    	inc	al	; 23h
  4161 000010C8 CD21                    	int	21h
  4162                                  	;mov	dx,offset DATARES:CritErr_Trap
  4163 000010CA BA[5500]                	mov	dx,CritErr_Trap
  4164                                  	;mov	dx,CRITERR ; MSDOS 3.3
  4165 000010CD FEC0                    	inc	al	; 24h
  4166 000010CF CD21                    	int	21h
  4167 000010D1 C3                      	retn
  4168                                  
  4169                                  ; ---------------------------
  4170                                  
  4171                                  	; MSDOS 6.0
  4172                                  ;;SR;
  4173                                  ;We have this to take care of the extra values pushed on the stack by
  4174                                  ;the stub before jumping to LodCom1. We set up ds here and then jump to
  4175                                  ;Lodcom1
  4176                                  
  4177                                  ;public	TrnLodCom1
  4178                                  	; 12/01/2023
  4179                                  TrnLodCom1:
  4180 000010D2 1F                      	pop	ds			; ds = DATARES
  4181 000010D3 83C402                  	add	sp,2
  4182                                  ;	pop	ds:OldDS
  4183 000010D6 E921FE                  	jmp	LodCom1
  4184                                  
  4185                                  ;=============================================================================
  4186                                  ; RUCODE.ASM, MSDOS 6.0, 1991
  4187                                  ;=============================================================================
  4188                                  ; 22/09/2018 - Retro DOS v3.0
  4189                                  
  4190                                  ;	title	Localizable code for resident COMMAND
  4191                                  
  4192                                  	;assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  4193                                  
  4194                                  ; ----------------------------------------------------------------------------
  4195                                  ;***	AskEnd - ask user to confirm batch file termination
  4196                                  ;
  4197                                  ;	Confirm with user before freeing batch ...
  4198                                  ;
  4199                                  ;	ENTRY	nothing
  4200                                  ;
  4201                                  ;	EXIT	CY = set if batch termination is confirmed
  4202                                  ;
  4203                                  ;		CY = clear if batch should continue
  4204                                  ;
  4205                                  ;	USED	AX,DX,...
  4206                                  ;
  4207                                  ;	Bugbug:	move this to transient, copy to batch segment.
  4208                                  ;	Bugbug:	or move it to command1 1st.
  4209                                  ;
  4210                                  ;	Bugbug: No_Char and Yes_Char should be constants.
  4211                                  ; ----------------------------------------------------------------------------
  4212                                  
  4213                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4214                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1169h (CODERES:0429h)
  4215                                  
  4216                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  4217                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1279h (CODERES:0429h)
  4218                                  AskEnd:
  4219                                  	;assume	ds:DATARES
  4220                                  
  4221 000010D9 BA[DE05]                	mov	dx,ENDBATMES			; DX = message #
  4222 000010DC E85702                  	call	RPrint
  4223                                  	;call	RDISPMSG  ; MSDOS 3.3
  4224 000010DF B8010C                  	mov	ax,0C01h
  4225                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT  ;0C01h
  4226 000010E2 CD21                    	int     21h             ; DOS - CLEAR KEYBOARD BUFFER
  4227                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
  4228 000010E4 E8E802                  	call	CharToUpper			; change to upper case
  4229 000010E7 3A06[E504]              	cmp	al,[NO_CHAR]
  4230 000010EB 7407                    	je	short aeRet			; answer is no (CY is clear)
  4231 000010ED 3A06[E404]              	cmp	al,[YES_CHAR]
  4232 000010F1 75E6                    	jne	short AskEnd			; invalid response, try again
  4233 000010F3 F9                      	stc					; answer is yes
  4234                                  aeRet:	
  4235 000010F4 C3                      	retn
  4236                                  
  4237                                  ; ----------------------------------------------------------------------------
  4238                                  ;***	DskErr - critical error handler
  4239                                  ;
  4240                                  ;	Default critical error handler unless user intercepts int 24h.
  4241                                  ;
  4242                                  ;	ENTRY	int 24h
  4243                                  ;
  4244                                  ;	EXIT
  4245                                  ;
  4246                                  ;	USED
  4247                                  ;
  4248                                  ;	EFFECTS
  4249                                  ; ----------------------------------------------------------------------------
  4250                                  
  4251                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4252                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1185h (CODERES:0445h)
  4253                                  
  4254                                  ;SR; 
  4255                                  ;The stub is going to push the old ds value and the resident data segment
  4256                                  ;onto the stack in that order. Get it off the stack
  4257                                  
  4258                                  ;DskErr	proc	far
  4259                                  DSKERR:
  4260                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  4261                                  	; 12/01/2023
  4262 000010F5 1F                      	pop	ds			; ds = DATARES
  4263                                  	;assume ds:DATARES
  4264 000010F6 8F06[D604]              	pop	word [OldDS]		; save old ds value
  4265                                  
  4266                                  ;CRITERR: ; MSDOS 3.3
  4267 000010FA FB                      	sti
  4268                                  	; 12/01/2023
  4269                                  	;push	ds ; 25/09/2018
  4270 000010FB 06                      	push	es
  4271 000010FC 56                      	push	si
  4272 000010FD 51                      	push	cx
  4273 000010FE 57                      	push	di
  4274 000010FF 51                      	push	cx
  4275 00001100 50                      	push	ax
  4276                                  
  4277 00001101 1E                      	push	ds			;save our data segment
  4278                                  	;push	cs ; 25/09/2018
  4279 00001102 07                      	pop	es			;es = DATARES
  4280                                  
  4281 00001103 8EDD                    	mov	ds,bp
  4282                                  	;assume	ds:nothing
  4283                                  
  4284                                  	;mov	ax,[si].SDEVATT
  4285 00001105 8B4404                  	mov	ax,[si+SYSDEV.ATT] ; mov ax,[si+4]	
  4286 00001108 268826[C301]            	mov	[es:CDevAt],ah
  4287                                  
  4288                                  	;push	cs
  4289                                  	;pop	es
  4290                                  
  4291 0000110D BF[B601]                	mov	di,DevName
  4292 00001110 B90800                  	mov	cx,8
  4293                                  	;add	si,SDEVNAME  ; add si,10
  4294 00001113 83C60A                  	add	si,SYSDEV.NAME	; save device name (even for block device)
  4295                                  				
  4296 00001116 FC                      	cld
  4297 00001117 F3A4                    	rep	movsb
  4298 00001119 58                      	pop	ax
  4299 0000111A 59                      	pop	cx
  4300 0000111B 5F                      	pop	di
  4301                                  
  4302                                  ;	Stack still contains DS and ES.
  4303                                  
  4304                                  ;SR;
  4305                                  ;We need ds = DATARES for SavHand
  4306                                  
  4307                                  	 ;12/01/2023
  4308 0000111C 06                      	push	es
  4309 0000111D 1F                      	pop	ds
  4310                                  	;assume	ds:DATARES
  4311                                  
  4312                                  	;invoke	SavHand		; save user's stdin/out, set to our stderr
  4313 0000111E E8A7FE                  	call	SavHand
  4314                                  
  4315                                  	; 12/01/2023
  4316                                  	; 25/09/2018
  4317                                  	;;push	cs
  4318                                  	;push	es
  4319                                  	;pop	ds		; set up local data segment
  4320                                  	;assume	ds:resgroup
  4321                                  
  4322 00001121 52                      	push	dx
  4323 00001122 E80E02                  	call	crlf
  4324 00001125 5A                      	pop	dx
  4325                                  
  4326                                  ;	Bugbug:	rename Crit_Err_Info to CritErrAH?
  4327                                  
  4328 00001126 8826[3A02]              	mov	[Crit_Err_Info],ah	; save critical error flags
  4329                                  
  4330                                  ;	Compute and save ASCII drive letter (nonsense for char devices)
  4331                                  
  4332 0000112A 0441                    	add	al,'A'
  4333 0000112C A2[A301]                	mov	[DrvLet],al
  4334                                  
  4335                                  ;	Bugbug:	These labels are awful. Change, especially 'NoHardE'.
  4336                                  
  4337 0000112F F6C480                  	test	ah,80h
  4338 00001132 740A                    	jz	short NoHardE		; it's a disk-device error
  4339 00001134 F606[C301]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4340 00001139 7503                    	jnz	short NoHardE		; it's a character device
  4341 0000113B E9E801                  	jmp	FatErr			; it's a FAT error
  4342                                  
  4343                                  NoHardE:
  4344 0000113E BE[0605]                	mov	si,MREAD		; SI = "read" msg #
  4345 00001141 F6C401                  	test	ah,1
  4346 00001144 7403                    	jz	short SavMes		; it's a read error
  4347 00001146 BE[0F05]                	mov	si,MWRITE		; SI = "write" msg #
  4348                                  SavMes:
  4349 00001149 893E[0004]              	mov	[OldErrNo],di		; save critical error code
  4350                                  
  4351                                  ;	Bugbug:	don't need to save/restore all here?
  4352                                  
  4353 0000114D 06                      	push	es
  4354                                  	; 19/07/2024 - PCDOS 7.1 COMMAND.COM
  4355                                  	;push	ds			; GetExtendedError likes to STOMP
  4356                                  	; 12/01/2023
  4357                                  	; (all registers are changed -in dos service- except bp) *
  4358                                  	;push	bp
  4359                                  	; 19/07/2024
  4360                                  	;push	si
  4361                                  	;push	dx
  4362 0000114E 51                      	push	cx
  4363 0000114F 53                      	push	bx
  4364                                  	; 05/06/2023
  4365 00001150 B459                    	mov	ah,59h ; *
  4366                                  	;mov	ah,GetExtendedError ; 59h ; get extended error info
  4367 00001152 CD21                    	int	21h
  4368 00001154 5B                      	pop	bx
  4369 00001155 59                      	pop	cx
  4370                                  	; 19/07/2024
  4371                                  	;pop	dx
  4372                                  	;pop	si
  4373                                  	; 12/01/2023
  4374                                  	;pop	bp
  4375                                  	; 19/07/2024
  4376                                  	;pop	ds
  4377 00001156 893E[D101]              	mov	[NeedVol],di		; save possible ptr to volume label
  4378 0000115A 8C06[D301]              	mov	[NeedVol+2],es
  4379 0000115E 07                      	pop	es
  4380                                  
  4381                                  ;	Bugbug:	AX has extended error code, so no need to zero AH?
  4382                                  
  4383                                  	; 19/07/2024 - PCDOS 7.1 COMMAND.COM
  4384                                  	;xor	ah,ah
  4385 0000115F 89C7                    	mov	di,ax			; DI = error code
  4386                                  
  4387                                  ; Bugbug: somewhat obsolete documentation?
  4388                                  ;
  4389                                  ; DI is now the correct error code. Classify things to see what we are
  4390                                  ; allowed to report. We convert DI into a 0-based index into a message table.
  4391                                  ; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
  4392                                  ; the like) are contiguous.
  4393                                  
  4394                                  ;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
  4395                                  ;	Check use of ErrCd_24, though.
  4396                                  
  4397 00001161 83EF13                  	sub	di,ERROR_WRITE_PROTECT ; 13h
  4398 00001164 7303                    	jae	short HavCod
  4399                                  
  4400                                  ;	Bugbug:	wouldn't it be better to display the original error msg,
  4401                                  ;	even though it's not a critical error?
  4402                                  
  4403 00001166 BF0C00                  	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT ; mov di,0Ch
  4404                                  
  4405                                  ; DI now has the mapped error code. Old style errors are:
  4406                                  ;   FOOBAR <read|writ>ing drive ZZ.
  4407                                  ; New style errors are:
  4408                                  ;   FOOBAR
  4409                                  ; We need to figure out which the particular error belongs to.
  4410                                  
  4411                                  HavCod:
  4412 00001169 C606[D501]00            	mov	byte [ErrType],0	; assume old style
  4413 0000116E 83FF10                  	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT  ; cmp di,10h
  4414 00001171 7405                    	je	short SetStyle
  4415 00001173 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4416 00001176 7504                    	jne	short GotStyle
  4417                                  
  4418                                  SetStyle:
  4419                                  ;	Bugbug:	use INC
  4420                                  	;mov	byte [ErrType],1		; must be new type
  4421 00001178 FE06[D501]              	inc	byte [ErrType] ; Retro DOS v3.0 COMMAND.COM - 22/09/2018
  4422                                  
  4423                                  GotStyle:
  4424 0000117C 893E[E201]              	mov	[ErrCd_24],di
  4425                                  	; 12/01/2023
  4426                                  	; 25/09/2018
  4427                                  	; MSDOS 6.0
  4428 00001180 83FF14                  	cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT ; cmp di,14h
  4429                                  	; MSDOS 3.3
  4430                                  	;cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4431                                  
  4432                                  						; If the error message is unknown
  4433 00001183 7641                    	jbe	short NormalError		;  redirector, continue. Otherwise,
  4434                                  
  4435                                  ; We do not know how to handle this error. Ask IFSFUNC if she knows
  4436                                  ; how to handle things
  4437                                  
  4438                                  ;input to IFSFUNC:    AL=1
  4439                                  ;		      BX=extended error number
  4440                                  ;
  4441                                  ;output from IFSFUNC: AL=error type (0 or 1)
  4442                                  ;			 0=<message> error (read/writ)ing (drive/device) xxx
  4443                                  ;			   Abort, Retry, Ignore
  4444                                  ;			 1=<message>
  4445                                  ;			   Abort, Retry, Ignore
  4446                                  ;		      ES:DI=pointer to message text
  4447                                  ;		      carry set=>no message
  4448                                  
  4449 00001185 89C7                    	mov	di,ax			; retrieve correct extended error...
  4450 00001187 B80005                  	mov	ax,0500h		; is the redir there?
  4451 0000118A CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
  4452                                  			; Return: AL = 00h not installed, OK to install
  4453                                  			; 01h not installed, can't install
  4454                                  			; FFh installed
  4455 0000118C 3CFF                    	cmp	al,0FFh
  4456 0000118E 7529                    	jne	short NoHandler		; no, go to NoHandler
  4457                                  
  4458                                  	; 12/01/2023
  4459                                  	; MSDOS 6.0
  4460 00001190 53                      	push	bx
  4461 00001191 89FB                    	mov	bx,di			; get ErrType and ptr to error msg
  4462 00001193 B80105                  	mov	ax,0501h
  4463 00001196 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4464 00001198 5B                      	pop	bx 
  4465 00001199 721E                    	jc	short NoHandler
  4466                                  	
  4467                                  	; MSDOS 3.3
  4468                                  	;mov     ax,di
  4469                                  	;mov     ah,5
  4470                                  	;int     2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4471                                  	;jc      short NOHANDLER
  4472                                  
  4473                                  ;	Bugbug:	need to record error type?
  4474                                  
  4475 0000119B A2[D501]                	mov	[ErrType],al
  4476                                  
  4477 0000119E 1E                      	push	ds
  4478 0000119F 06                      	push	es
  4479 000011A0 1F                      	pop	ds
  4480 000011A1 89FA                    	mov	dx,di
  4481 000011A3 B9FFFF                  	mov	cx,-1			; find end of msg
  4482 000011A6 30C0                    	xor	al,al
  4483                                  
  4484 000011A8 FC                      	cld
  4485 000011A9 F2AE                    	repnz	scasb
  4486                                  
  4487                                  ;	Bugbug:	we can do better than this.
  4488                                  
  4489                                  	;mov	byte [di-1],'$'
  4490                                  	; 19/07/2024
  4491 000011AB 4F                      	dec	di
  4492 000011AC C60524                  	mov	byte [di],'$'
  4493                                  	
  4494                                  	;CALL	RDISPMSG ; MSDOS 3.3
  4495                                  	
  4496 000011AF B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9	; print the message
  4497 000011B1 CD21                    	int	21h
  4498                                  
  4499                                  	;mov	byte [di-1],0			; restore terminal byte
  4500                                  	; 19/07/2024
  4501 000011B3 C60500                  	mov	byte [di],0
  4502                                  
  4503 000011B6 1F                      	pop	ds				; clean up and continue
  4504 000011B7 EB15                    	jmp	short CheckErrType
  4505                                  
  4506                                  ;*	Redir isn't available or doesn't recognize the error.
  4507                                  ;	Restore regs to unextended error.
  4508                                  
  4509                                  NoHandler:
  4510 000011B9 C606[D501]00            	mov	byte [ErrType],0
  4511                                  ;	Bugbug:	won't this break, since we add error_write_protect back in?
  4512 000011BE 8B3E[0004]              	mov	di,[OldErrNo]
  4513 000011C2 893E[E201]              	mov	[ErrCd_24],di
  4514                                  
  4515                                  NormalError:
  4516                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4517                                  	; MSDOS 6.0
  4518 000011C6 83C713                  	add	di,ERROR_WRITE_PROTECT
  4519 000011C9 87FA                    	xchg	di,dx			; may need dx later
  4520 000011CB E88101                  	call	RPrintCrit		; print error type
  4521                                  
  4522                                  	; MSDOS 3.3
  4523                                  	;shl     di,1
  4524                                  	;mov     di,[CRMSGTBL+di]
  4525                                  	;xchg    di,dx
  4526                                  	;call    RDISPMSG
  4527                                  
  4528                                  CheckErrType:
  4529 000011CE 803E[D501]00            	cmp	byte [ErrType],0	; Check error style...
  4530 000011D3 7405                    	je	short ContOld
  4531 000011D5 E85B01                  	call	crlf			; if new style then done printing
  4532 000011D8 EB31                    	jmp	short Ask
  4533                                  
  4534                                  ContOld:
  4535                                  	; 12/01/2023
  4536                                  	; MSDOS 6.0
  4537 000011DA 46                      	inc	si			; DS:SI = ptr to asciiz string
  4538                                  
  4539                                  ;	Bugbug:	combine some of the following two sections?
  4540                                  
  4541                                  	; 12/01/2023
  4542 000011DB F606[C301]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4543                                  	;test	byte [CDevAt],DEVTYP shr 8 ; 80h
  4544 000011E0 740F                    	jz	short BlkErr
  4545                                  	;;mov	dx,offset DATARES:CharDevErr	; DX = ptr to device message
  4546                                  	;mov	dx,ChardevErr
  4547 000011E2 BA[2705]                	mov	dx,MDEVICE
  4548                                  	;mov	[CharDevErrRw.SubstPtr],si	; point to read/write string
  4549 000011E5 8936[A501]              	mov	[CharDevErrRw],si
  4550                                  	;mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block
  4551 000011E9 BE[A401]                	mov	si,CharDevErrSubst
  4552                                  
  4553 000011EC E84701                  	call	RPrint				; print the message
  4554 000011EF EB1A                    	jmp	short Ask			; don't ralph on command
  4555                                  
  4556                                  	; 12/01/2023
  4557                                  	; MSDOS 3.3
  4558                                  	;mov	dx,ERRMES
  4559                                  	;call	RDISPMSG
  4560                                  	;mov	dx,si
  4561                                  	;call	RDISPMSG
  4562                                  	;
  4563                                  	;test	byte [CDevAt],80h
  4564                                  	;jz	short BLKERR
  4565                                  	;mov	dx,CHARDEVERR	; " device "
  4566                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4567                                  	;int	21h		; DOS - PRINT STRING
  4568                                  	;			; DS:DX -> string terminated by "$"
  4569                                  	;jmp	short ASK
  4570                                  
  4571                                  BlkErr:
  4572                                  	; 12/01/2023
  4573                                  	; MSDOS 6.0
  4574                                  	;;mov	dx,offset DATARES:BlkDevErr	; DX = error msg #
  4575                                  	;mov	dx,BlkDevErr
  4576 000011F1 BA[1805]                	mov	dx,MDRIVE
  4577                                  	;mov	[BlkDevErrRw.SubstPtr],si	; "reading","writing" ptr
  4578 000011F4 8936[9E01]              	mov	[BlkDevErrRw],si
  4579                                  	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
  4580 000011F8 BE[9D01]                	mov	si,BlkDevErrSubst
  4581 000011FB E83801                  	call	RPrint
  4582                                  
  4583                                  	; MSDOS 3.3
  4584                                  	;mov	dx,BLKDEVERR
  4585                                  	;call	RDISPMSG
  4586                                  
  4587 000011FE 803E[E601]00            	cmp	byte [Loading],0
  4588 00001203 7406                    	jz	short Ask
  4589 00001205 E8E9FD                  	call	RestHand
  4590 00001208 E9E0FD                  	jmp	GetComDsk2		; if error loading COMMAND, re-prompt
  4591                                  Ask:
  4592 0000120B 833E[E201]0F            	cmp	word [ErrCd_24],15	; error 15 has an extra message
  4593 00001210 751E                    	jne	short Not15		; not error 15
  4594                                  
  4595                                  ;*	For error 15, tell the user which volume/serial # are needed.
  4596                                  
  4597 00001212 51                      	push	cx
  4598                                  
  4599                                  ;	Bugbug:	does this push/pop need to be done?
  4600                                  
  4601 00001213 1E                      	push	ds
  4602 00001214 07                      	pop	es
  4603 00001215 C536[D101]              	lds	si,[NeedVol]
  4604                                  	;assume	ds:NOTHING
  4605 00001219 57                      	push	di
  4606 0000121A BF[B301]                	mov	di,VolName
  4607                                  	; 12/01/2023
  4608                                  	; MSDOS 6.0
  4609 0000121D B91000                  	mov	cx,16			; copy volume name & serial #
  4610                                  	; MSDOS 3.3
  4611                                  	;mov	cx,11			; copy volume name
  4612 00001220 FC                      	cld
  4613 00001221 F3A4                    	rep	movsb
  4614 00001223 5F                      	pop	di
  4615 00001224 06                      	push	es
  4616 00001225 1F                      	pop	ds
  4617 00001226 59                      	pop	cx
  4618                                  	;assume	ds:DATARES
  4619                                  	; 12/01/2023
  4620                                  	; MSDOS 6.0
  4621                                  	;mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
  4622                                  	;mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
  4623                                  	;mov	dx,NeedVolMsg
  4624 00001227 BA[3705]                	mov	dx,MVOLSERIAL
  4625 0000122A BE[AA01]                	mov	si,NeedVolSubst
  4626 0000122D E80601                  	call	RPrint
  4627                                  
  4628                                  	; MSDOS 3.3
  4629                                  	;mov	dx,NEEDVOLMSG
  4630                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4631                                  	;int	21h		; DOS - PRINT STRING
  4632                                  	;			; DS:DX -> string terminated by "$"
  4633                                  Not15:
  4634                                  ;*	Print abort, retry, ignore, fail message.
  4635                                  ;	Print only options that are valid.
  4636                                  
  4637                                  ;	Bugbug:	sizzle this.
  4638                                  
  4639                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4640 00001230 BA[E604]                	mov	dx,REQ_ABORT
  4641 00001233 E80001                  	call	RPrint
  4642                                  	;call	RDISPMSG
  4643 00001236 F606[3A02]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED  ; 10h
  4644 0000123B 7406                    	jz	short Try_Ignore
  4645 0000123D BA[EC04]                	mov	dx,REQ_RETRY
  4646 00001240 E8F300                  	call	RPrint
  4647                                  	;call	RDISPMSG
  4648                                  Try_Ignore:
  4649 00001243 F606[3A02]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h
  4650 00001248 7406                    	jz	short Try_Fail
  4651 0000124A BA[F404]                	mov	dx,REQ_IGNORE
  4652 0000124D E8E600                  	call	RPrint
  4653                                  	;call	RDISPMSG
  4654                                  Try_Fail:
  4655 00001250 F606[3A02]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED   ; 08h
  4656 00001255 7406                    	jz	short Term_Question
  4657 00001257 BA[FD04]                	mov	dx,REQ_FAIL
  4658 0000125A E8D900                  	call	RPrint
  4659                                  	;call	RDISPMSG
  4660                                  Term_Question:
  4661 0000125D BA[0405]                	mov	dx,REQ_END
  4662 00001260 E8D300                  	call	RPrint
  4663                                  	;call	RDISPMSG
  4664                                  
  4665                                  ;	If the /f switch was given, we fail all requests.
  4666                                  
  4667 00001263 F606[4702]FF            	test	byte [fFail],-1
  4668 00001268 741B                    	jz	short DoPrompt
  4669 0000126A B403                    	mov	ah,3				; signal fail
  4670 0000126C E9A800                  	jmp	EExit
  4671                                  
  4672                                  	; 16/04/2023
  4673                                  Abort_Process:
  4674 0000126F F606[B402]01            	test	byte [InitFlag],INITINIT ; 1	; COMMAND init interrupted?
  4675 00001274 745D                    	jz	short AbortCont			; no, handle it normally
  4676 00001276 803E[4002]00            	cmp	byte [PermCom],0		; are we top level process?
  4677 0000127B 744B                    	jz	short JustExit			; yes, just exit
  4678                                  
  4679 0000127D BA[E906]                	mov	dx,PATRICIDE			; no, load ptr to error msg
  4680                                  	; 12/01/2023
  4681 00001280 E8B300                  	call	RPrint				; print it
  4682                                  	;call	RDISPMSG
  4683                                  DeadInTheWater:
  4684 00001283 EBFE                    	jmp	short DeadInTheWater		; loop until the user reboots
  4685                                  
  4686                                  DoPrompt:
  4687                                  	; 12/01/2023
  4688 00001285 B8010C                  	mov	ax,0C01h
  4689                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT ; 0C01h
  4690 00001288 CD21                    	int	21h				; get response
  4691                                  
  4692 0000128A E8A600                  	call	crlf
  4693 0000128D E83F01                  	call	CharToUpper			; convert to upper case
  4694 00001290 B400                    	mov	ah,0				; return code for ignore
  4695 00001292 F606[3A02]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h ; is ignore allowed?
  4696 00001297 7406                    	jz	short User_Retry
  4697 00001299 3A06[E204]              	cmp	al,[IGNORE_CHAR]		; ignore?
  4698                                  	;jz	short EExitJ
  4699                                  	; 16/04/2023
  4700 0000129D 7478                    	jz	short EExit
  4701                                  
  4702                                  ;	Bugbug:	optimize following code.
  4703                                  
  4704                                  User_Retry:
  4705 0000129F FEC4                    	inc	ah				; return code for retry
  4706 000012A1 F606[3A02]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED ; 10h ; is retry allowed?
  4707 000012A6 7406                    	jz	short User_Abort
  4708 000012A8 3A06[E104]              	cmp	al,[RETRY_CHAR]			; retry?
  4709                                  	;jz	short EExitJ
  4710                                  	; 16/04/2023
  4711 000012AC 7469                    	jz	short EExit
  4712                                  User_Abort:
  4713 000012AE FEC4                    	inc	ah				; return code for abort
  4714                                  						;  (abort always allowed)
  4715 000012B0 3A06[E004]              	cmp	al,[ABORT_CHAR]			; abort?
  4716 000012B4 74B9                    	jz	short Abort_Process		; exit user program
  4717 000012B6 FEC4                    	inc	ah				; return code for fail
  4718 000012B8 F606[3A02]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED ; 08h ; is fail allowed?
  4719 000012BD 7406                    	jz	short AskJ
  4720 000012BF 3A06[E304]              	cmp	al,[FAIL_CHAR]			; fail?
  4721                                  	;jz	short EExitJ
  4722                                  	; 16/04/2023
  4723 000012C3 7452                    	jz	short EExit
  4724                                  AskJ:
  4725 000012C5 E943FF                  	jmp	Ask
  4726                                  
  4727                                  	; 12/01/2023
  4728                                  ;EExitJ:
  4729                                  	;jmp	short EExit
  4730                                  
  4731                                  JustExit:
  4732                                  	;assume	ds:DATARES
  4733                                  	; 12/01/2023
  4734 000012C8 A1[DC01]                	mov	ax,[Parent]			; load real parent pid
  4735                                  	;mov	[16h],ax
  4736 000012CB A31600                  	mov	[PDB.PARENT_PID],ax		; put it back where it belongs
  4737 000012CE B8FF4C                  	mov	ax,4CFFh
  4738                                  	;mov	ax,(EXIT<<8) | 255 ; 4CFFh
  4739 000012D1 CD21                    	int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
  4740                                  				; AL = exit code
  4741                                  AbortCont:
  4742 000012D3 F606[3002]FF            	test	byte [In_Batch],-1		; Are we accessing a batch file?
  4743 000012D8 7405                    	jz	short Not_Batch_Abort
  4744 000012DA C606[3102]01            	mov	byte [Batch_Abort],1		; set flag for abort
  4745                                  
  4746                                  Not_Batch_Abort:
  4747 000012DF 8A16[B502]              	mov	dl,[PipeFlag]
  4748 000012E3 E8D1FA                  	call	ResPipeOff
  4749 000012E6 08D2                    	or	dl,dl
  4750 000012E8 740D                    	je	short CheckForA
  4751 000012EA 833E[4302]00            	cmp	word [SingleCom],0
  4752 000012EF 7406                    	je	short CheckForA
  4753 000012F1 C706[4302]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4754                                  
  4755                                  CheckForA:
  4756 000012F7 833E[E201]00            	cmp	word [ErrCd_24],0		; write protect?
  4757 000012FC 7407                    	je	short abortfor
  4758 000012FE 833E[E201]02            	cmp	word [ErrCd_24],2		; drive not ready?
  4759 00001303 7512                    	jne	short EExit			; don't abort the FOR
  4760                                  
  4761                                  abortfor:
  4762 00001305 C606[4902]00            	mov	byte [ForFlag],0		; abort a FOR in progress
  4763 0000130A 833E[4302]00            	cmp	word [SingleCom],0
  4764 0000130F 7406                    	je	short EExit
  4765 00001311 C706[4302]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4766                                  
  4767                                  EExit:
  4768 00001317 88E0                    	mov	al,ah
  4769 00001319 89FA                    	mov	dx,di
  4770                                  RestHd:
  4771 0000131B E8D3FC                  	call    RestHand
  4772 0000131E 59                      	pop	cx
  4773 0000131F 5E                      	pop	si				; restore registers
  4774 00001320 07                      	pop	es
  4775                                  
  4776                                  	; 12/01/2023	
  4777                                  	; MSDOS 6.0
  4778                                  ;;	pop	ds
  4779                                  ;SR;
  4780                                  ;ds has to be got from the variable we saved it in
  4781                                  
  4782 00001321 8E1E[D604]               	mov	ds,[OldDS]			; restore old value of ds
  4783                                  
  4784                                  ;	pop	ds
  4785                                  ;	assume	ds:nothing
  4786                                  
  4787                                  	; MSDOS 3.3
  4788                                  	;pop	ds
  4789                                  
  4790 00001325 CF                      	iret
  4791                                  
  4792                                  FatErr:
  4793                                  	; 12/01/2023
  4794                                  	; MSDOS 6.0
  4795                                  	;mov	dx,offset DATARES:BadFatMsg
  4796                                  	;mov	si,offset DATARES:BadFatSubst
  4797 00001326 BA[5E05]                	mov	dx,BADFATMSG
  4798 00001329 BE[C401]                	mov	si,BadFatSubst
  4799 0000132C E80700                  	call	RPrint
  4800                                  
  4801                                  	; MSDOS 3.3
  4802                                  	;mov	dx,BADFATMSG
  4803                                  	;call	RDISPMSG
  4804                                  	;mov	dx,BLKDEVERR
  4805                                  	;call	RDISPMSG
  4806                                  
  4807 0000132F B002                    	mov	al,2				; abort
  4808 00001331 EBE8                    	jmp	short RestHd
  4809                                  
  4810                                  ;DskErr	endp
  4811                                  
  4812                                  	; MSDOS 6.0
  4813                                  ; ----------------------------------------------------------------------------
  4814                                  ;***	RPrint - print message
  4815                                  ;***	Crlf - display cr/lf
  4816                                  ;
  4817                                  ;	ENTRY	DS:DX = ptr to count byte, followed by message text
  4818                                  ;		DS:SI = ptr to 1st substitution block for this msg, if any
  4819                                  ;		variable fields related to substitution blocks are set
  4820                                  ;
  4821                                  ;	EXIT	nothing
  4822                                  ;
  4823                                  ;	USED	flags
  4824                                  ;
  4825                                  ;	EFFECTS
  4826                                  ;	  Message is displayed on stdout.
  4827                                  ;
  4828                                  ;	NOTE
  4829                                  ;	  Number of substitutions (%1, %2,...) in message text must not
  4830                                  ;	  be greater than number of substition blocks present.
  4831                                  ; ----------------------------------------------------------------------------
  4832                                  
  4833                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4834                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:13D1h (CODERES:0691h)
  4835                                  
  4836                                  crlf: 
  4837                                  	;mov	dx,offset DATARES:Newlin ; cheap newline
  4838                                  	; 14/01/2023
  4839 00001333 BA[1807]                	mov	dx,NEWLINE
  4840                                  
  4841                                  ;RPrint	proc
  4842                                  ;
  4843                                  ;	assume	ds:DATARES,ss:DATARES
  4844                                  ;
  4845                                  	; 14/01/2023
  4846                                  RPrint:
  4847                                  
  4848                                  ;	Bugbug:	do we need to save all reg's?
  4849                                  
  4850 00001336 56                      	push	si			; preserve registers
  4851 00001337 50                      	push	ax
  4852 00001338 53                      	push	bx
  4853 00001339 51                      	push	cx
  4854 0000133A 52                      	push	dx
  4855                                  
  4856 0000133B 89F3                    	mov	bx,si			; DS:BX = ptr to subst block
  4857 0000133D 89D6                    	mov	si,dx			; DS:SI = ptr to count byte
  4858 0000133F AC                      	lodsb				; AL = message length
  4859                                  					; DS:SI = ptr to message text
  4860 00001340 31C9                    	xor	cx,cx
  4861 00001342 88C1                    	mov	cl,al			; CX = message length
  4862 00001344 E303                    	jcxz	rpRet
  4863                                  
  4864 00001346 E81900                  	call	RDispMsg
  4865                                  
  4866 00001349 5A                      rpRet:	pop	dx
  4867 0000134A 59                      	pop	cx
  4868 0000134B 5B                      	pop	bx
  4869 0000134C 58                      	pop	ax
  4870 0000134D 5E                      	pop	si
  4871 0000134E C3                      	retn
  4872                                  
  4873                                  ;RPrint	endp
  4874                                  
  4875                                  	; 14/01/2023
  4876                                  ;	; MSDOS 3.3
  4877                                  ;CRLF:
  4878                                  ;	mov     dx,NEWLIN
  4879                                  ;
  4880                                  ;RDISPMSG: ; Display message/text
  4881                                  ;	; DS:DX = ($ terminated) Message/Text address 
  4882                                  ;	push    ax
  4883                                  ;	mov     ah,STD_CON_STRING_OUTPUT ; 9
  4884                                  ;	clc
  4885                                  ;	int     21h             ; DOS - PRINT STRING
  4886                                  ;				; DS:DX -> string terminated by "$"
  4887                                  ;	pop     ax
  4888                                  ;	retn
  4889                                  
  4890                                  
  4891                                  	; MSDOS 6.0
  4892                                  ; ----------------------------------------------------------------------------
  4893                                  ;***	RPrintCrit - print critical error message
  4894                                  ;
  4895                                  ;	ENTRY	DX = extended error # (19-39)
  4896                                  ;
  4897                                  ;	EXIT	nothing
  4898                                  ;
  4899                                  ;	USED	flags
  4900                                  ;
  4901                                  ;	EFFECTS
  4902                                  ;	  Message is displayed on stdout
  4903                                  ; ----------------------------------------------------------------------------
  4904                                  
  4905                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4906                                  
  4907                                  ;RPrintCrit	proc
  4908                                  ;	assume	ds:DATARES,ss:DATARES
  4909                                  
  4910                                  	; 14/01/2023
  4911                                  RPrintCrit:
  4912 0000134F 52                      	push	dx			; preserve DX
  4913 00001350 87DA                    	xchg	bx,dx			; BX = extended error #
  4914                                  					; DX = saved BX
  4915 00001352 83EB13                  	sub	bx,19			; BX = critical error index, from 0
  4916 00001355 D1E3                    	shl	bx,1			; BX = offset in word table
  4917 00001357 8B9F[B208]              	mov	bx,[bx+CRITMSGPTRS]	; BX = ptr to error msg
  4918 0000135B 87DA                    	xchg	bx,dx			; DX = ptr to error msg
  4919                                  					; BX = restored
  4920 0000135D E8D6FF                  	call	RPrint			; print the message
  4921 00001360 5A                      	pop	dx			; restore DX
  4922 00001361 C3                      	retn
  4923                                  
  4924                                  ;RPrintCrit	endp
  4925                                  
  4926                                  ; ----------------------------------------------------------------------------
  4927                                  ;***	RDispMsg - display message
  4928                                  ;
  4929                                  ;	Display message, with substitutions, for RPrint.
  4930                                  ;
  4931                                  ;	ENTRY	DS:SI = ptr to message text
  4932                                  ;		CX = message length
  4933                                  ;		DS:BX = ptr to substitution block, if any
  4934                                  ;
  4935                                  ;	EXIT	nothing
  4936                                  ;
  4937                                  ;	USED	AX,CX,DX,SI
  4938                                  ; ----------------------------------------------------------------------------
  4939                                  
  4940                                  ;RDispMsg	proc
  4941                                  ;	assume	ds:DATARES,ss:DATARES
  4942                                  
  4943                                  RDispMsg:
  4944                                  	; 14/01/2023
  4945                                  rdNextChar:
  4946 00001362 AC                      	lodsb				; AL = next char
  4947 00001363 3C25                    	cmp	al,'%'
  4948 00001365 7511                    	jne	short rdOutChar		; not a substitution
  4949 00001367 8A14                    	mov	dl,[si]			; DL = possible '1' - '9'
  4950 00001369 80EA31                  	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
  4951 0000136C 80FA09                  	cmp	dl,9
  4952 0000136F 7307                    	jae	short rdOutChar		; not a substitution
  4953                                  
  4954                                  ;*	A substitution code %1 - %9 has been encountered.
  4955                                  ;	DL = 0-8, indicating %1-%9
  4956                                  ;	DS:BX = ptr to substitution block
  4957                                  
  4958 00001371 E80D00                  	call	SubstMsg		; display the substitution
  4959 00001374 46                      	inc	si			; SI = ptr past %n
  4960 00001375 49                      	dec	cx			; count extra character in %n
  4961 00001376 EB06                    	jmp	short rdCharDone
  4962                                  
  4963                                  ;*	Normal character output.
  4964                                  
  4965                                  rdOutChar:
  4966 00001378 88C2                    	mov	dl,al			; DL = char
  4967 0000137A B402                    	mov	ah,2			; AH = DOS Character Output code
  4968 0000137C CD21                    	int	21h			; call DOS
  4969                                  rdCharDone:
  4970 0000137E E2E2                    	loop	rdNextChar
  4971 00001380 C3                      	retn
  4972                                  
  4973                                  ;RDispMsg	endp
  4974                                  
  4975                                  ; ----------------------------------------------------------------------------
  4976                                  ;***	SubstMsg - display message substitution
  4977                                  ;
  4978                                  ;	Display a substitution string within a message.
  4979                                  ;	Substitution can be a char, an ASCIIZ string, or
  4980                                  ;	a word to be displayed as hex digits.
  4981                                  ;
  4982                                  ;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
  4983                                  ;		DS:BX = ptr to substitution block
  4984                                  ;
  4985                                  ;	EXIT	nothing
  4986                                  ;
  4987                                  ;	USED	AX,DX
  4988                                  ; ----------------------------------------------------------------------------
  4989                                  
  4990                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4991                                  
  4992                                  ;SubstMsg	proc
  4993                                  ;	assume	ds:DATARES,ss:DATARES
  4994                                  	
  4995                                  	; 14/01/2023
  4996                                  SubstMsg:
  4997 00001381 53                      	push	bx			; preserve BX
  4998 00001382 51                      	push	cx			; preserve CX
  4999                                  
  5000                                  	;mov	al,size SUBST		; AL = size of substitution block
  5001 00001383 B003                    	mov	al,3
  5002 00001385 F6E2                    	mul	dl			; AX = offset of desired subst block
  5003 00001387 01C3                    	add	bx,ax			; DS:BX = ptr to desired subst block
  5004                                  
  5005                                  	;mov	al,[bx].SubstType	; AX = substitution type flag
  5006 00001389 8A07                    	mov	al,[bx]
  5007                                  	;mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value
  5008 0000138B 8B5F01                  	mov	bx,[bx+1]
  5009                                  
  5010                                  ;	AL = 1, 2, or 3 for char, string, or hex type
  5011                                  
  5012 0000138E FEC8                    	dec	al
  5013 00001390 7428                    	jz	short smChar
  5014 00001392 FEC8                    	dec	al
  5015 00001394 742C                    	jz	short smStr
  5016                                  
  5017                                  ;*	Hex number substitution.
  5018                                  
  5019                                  	;mov	ax,ds:[bx]		; AX = word value
  5020 00001396 8B07                    	mov	ax,[bx]
  5021 00001398 B90400                  	mov	cx,4			; CX = # digits to display
  5022                                  smDigit:
  5023 0000139B D1C0                    	rol	ax,1
  5024 0000139D D1C0                    	rol	ax,1
  5025 0000139F D1C0                    	rol	ax,1
  5026 000013A1 D1C0                    	rol	ax,1			; AL<3:0> = next digit
  5027                                  
  5028 000013A3 50                      	push	ax			; save other digits
  5029 000013A4 240F                    	and	al,0Fh			; AL = binary digit
  5030 000013A6 0430                    	add	al,'0'			; AL = ascii digit if 0-9
  5031 000013A8 3C39                    	cmp	al,'9'
  5032 000013AA 7602                    	jbe	short smDigit09		; it's 0-9
  5033                                  	;add	al,7
  5034 000013AC 0407                    	add	al,('A' - '0') - 10	; AL = ascii digit A-F
  5035                                  smDigit09:
  5036 000013AE 88C2                    	mov	dl,al			; DL = ascii digit
  5037 000013B0 B402                    	mov	ah,2
  5038 000013B2 CD21                    	int	21h			; output the ascii digit
  5039 000013B4 58                      	pop	ax			; restore all digits
  5040                                  
  5041 000013B5 E2E4                    	loop	smDigit
  5042                                  	;jmp	short smRet
  5043                                  	; 14/01/2023
  5044                                  smRet:	
  5045 000013B7 59                      	pop	cx
  5046 000013B8 5B                      	pop	bx
  5047 000013B9 C3                      	retn
  5048                                  
  5049                                  ;*	Char substitution.
  5050                                  
  5051                                  smChar:
  5052                                  	;mov	dl,ds:[bx]		; DL = char to output
  5053 000013BA 8A17                    	mov	dl,[bx]
  5054 000013BC B402                    	mov	ah,2
  5055 000013BE CD21                    	int	21h
  5056 000013C0 EBF5                    	jmp	short smRet
  5057                                  
  5058                                  ;*	String substitution.
  5059                                  
  5060                                  smStr:
  5061                                  	;mov	dl,ds:[bx]		; DL = next char
  5062 000013C2 8A17                    	mov	dl,[bx]
  5063 000013C4 08D2                    	or	dl,dl
  5064 000013C6 74EF                    	jz	short smRet		; null char - we're done
  5065 000013C8 B402                    	mov	ah,2
  5066 000013CA CD21                    	int	21h			; display char
  5067 000013CC 43                      	inc	bx			; DS:BX = ptr to next char
  5068 000013CD EBF3                    	jmp	short smStr
  5069                                  
  5070                                  ;smRet:	pop	cx
  5071                                  ;	pop	bx
  5072                                  ;	retn
  5073                                  
  5074                                  ;SubstMsg	endp
  5075                                  
  5076                                  	; MSDOS 6.0
  5077                                  ; ----------------------------------------------------------------------------
  5078                                  ;***	CharToUpper - convert character to uppercase
  5079                                  ;
  5080                                  ;	ENTRY	AL = char
  5081                                  ;
  5082                                  ;	EXIT	AL = uppercase char
  5083                                  ;
  5084                                  ;	USED	AX
  5085                                  ; ----------------------------------------------------------------------------
  5086                                  
  5087                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5088                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  5089                                  
  5090                                  ;CharToUpper	proc
  5091                                  ;	assume	ds:DATARES
  5092                                  CharToUpper:
  5093 000013CF 50                      	push	ax		; put char on stack as arg to int 2F
  5094 000013D0 B81312                  	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
  5095 000013D3 CD2F                    	int	2Fh
  5096 000013D5 44                      	inc	sp		; throw away old char on stack
  5097 000013D6 44                      	inc	sp
  5098 000013D7 C3                      	retn
  5099                                  
  5100                                  ;CharToUpper	endp
  5101                                  
  5102                                  	; 14/01/2023
  5103                                  ;	; MSDOS 3.3
  5104                                  ;CHARTOUPPER:
  5105                                  ;	cmp	al,80h
  5106                                  ;	jb	short CHARTOUPPER1
  5107                                  ;	sub	al,80h
  5108                                  ;	push	ds
  5109                                  ;	push	bx
  5110                                  ;	lds	bx,[UPPERCASETBL]
  5111                                  ;	add	bx,2
  5112                                  ;	xlat
  5113                                  ;	pop	bx
  5114                                  ;	pop	ds
  5115                                  ;	jmp	short CHARTOUPPER_RETN
  5116                                  ;CHARTOUPPER1:
  5117                                  ;	cmp	al,'a'
  5118                                  ;	jb	short CHARTOUPPER_RETN
  5119                                  ;	cmp	al,'z'
  5120                                  ;	ja	short CHARTOUPPER_RETN
  5121                                  ;	sub	al,20h
  5122                                  ;CHARTOUPPER_RETN:
  5123                                  ;	retn
  5124                                  
  5125                                  ;public	EndCode
  5126                                  ;EndCode label byte
  5127                                  
  5128                                  	; MSDOS 6.0
  5129                                  ; ----------------------------------------------------------------------------
  5130                                  ;***	MsgInt2fHandler - int 2f handler for message retrieval
  5131                                  ;
  5132                                  ;	ENTRY	If we handle it -
  5133                                  ;		  AX = ((MULTDOS shl 8) or MESSAGE_2F) = 122Eh
  5134                                  ;		  DL = operation =
  5135                                  ;		     0 = get extended error messages
  5136                                  ;		     1 = set extended error messages
  5137                                  ;		     2 = get parse error messages
  5138                                  ;		     3 = set parse error messages
  5139                                  ;		     4 = get critical error messages
  5140                                  ;		     5 = set critical error messages
  5141                                  ;		     6 = get file system error messages
  5142                                  ;		     7 = set file system error messages
  5143                                  ;		     8 = get disk retriever routine
  5144                                  ;		     9 = set disk retriever routine
  5145                                  ;		  ES:DI = address for 'set' operations
  5146                                  ;
  5147                                  ;	EXIT	ES:DI = ptr to list of message ptrs, for 'get' operations
  5148                                  ;
  5149                                  ;	NOTE
  5150                                  ;	  This handler replaces the one that used to reside in DOS.
  5151                                  ;	  'Set' operations are ignored.
  5152                                  ;	  'File system error messages' are not supported.
  5153                                  ; ----------------------------------------------------------------------------
  5154                                  
  5155                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5156                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1478h (CODERES:0738h)
  5157                                  
  5158                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  5159                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1588h (CODERES:0738h)
  5160                                  
  5161                                  ;SR;
  5162                                  ;At the int 2fh entry point we push the old ds value and the resident data
  5163                                  ;segment address. Get them off the stack
  5164                                  
  5165                                  ;MsgInt2fHandler proc	far
  5166                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  5167                                  
  5168                                  	; 14/01/2023
  5169                                  MsgInt2fHandler:
  5170 000013D8 1F                      	pop	ds			; ds = DATARES
  5171                                  	;assume	ds:DATARES
  5172                                  ;	pop	word [OldDS]		; save old value of ds
  5173                                  
  5174 000013D9 3D2E12                  	cmp	ax,122Eh
  5175                                  	;cmp	ax,(MULTDOS<<8)|MESSAGE_2F
  5176                                  	;;cmp	ax,(MULTDOS shl 8) or MESSAGE_2F
  5177 000013DC 742A                    	je	short miOurs		; it's ours
  5178                                  
  5179                                  ;ifndef ROMDOS
  5180                                  	;cmp	ax,5500h
  5181 000013DE 3D0055                  	cmp	ax,GET_COMMAND_STATE	; is it first COMMAND query?
  5182                                  ;else
  5183                                  ;	cmp	ax,GET_ROMCOMMAND_STATE	; is it first ROM COMMAND query?
  5184                                  ;endif	;ROMDOS
  5185 000013E1 741C                    	je	short fcOurs
  5186                                  
  5187                                  ;SR;
  5188                                  ;We cannot do a far jump any more because cs cannot be used. Push the cs:ip
  5189                                  ;onto the stack and do a far return to jump to the next 2fh handler. 
  5190                                  ;Our old ds is on the stack. We need to restore it but we cannot lose the
  5191                                  ;current value of ds as it points at the data segment. So we do some kinky
  5192                                  ;stack manipulations.
  5193                                  
  5194 000013E3 50                      	push	ax
  5195 000013E4 50                      	push	ax			; create 2 words on stack for retf
  5196                                  
  5197 000013E5 55                      	push	bp
  5198 000013E6 50                      	push	ax
  5199                                  
  5200 000013E7 89E5                    	mov	bp,sp			; bp can be used to address stack
  5201                                  
  5202                                  ;Swap the old ds value with the second dummy word on the stack. Now, we can
  5203                                  ;do a 'pop ds' at the end to restore our ds
  5204                                  
  5205 000013E9 8B4608                  	mov	ax,[bp+8]		; ax = old ds value
  5206 000013EC 894604                  	mov	[bp+4],ax
  5207                                  	
  5208                                  	;mov	ax,word ptr ds:Int2fHandler+2
  5209 000013EF A1[5404]                	mov	ax,[Int2fHandler+2]
  5210 000013F2 894608                  	mov	[bp+8],ax		; put segment address
  5211                                  	;mov	ax,word ptr ds:Int2fHandler
  5212 000013F5 A1[5204]                	mov	ax,[Int2fHandler]
  5213 000013F8 894606                  	mov	[bp+6],ax		; put offset address
  5214                                  
  5215 000013FB 58                      	pop	ax
  5216 000013FC 5D                      	pop	bp
  5217 000013FD 1F                      	pop	ds
  5218                                  
  5219 000013FE CB                      	retf				; chain on to next handler
  5220                                  
  5221                                  ;;	jmp	Int2fHandler		; hand off to next 2f handler
  5222                                  
  5223                                  fcOurs:
  5224                                  
  5225                                  ;We have to clear ax, and return in ds:si a pointer to the stub jump table
  5226                                  
  5227 000013FF 58                      	pop	ax			; discard ds currently on stack
  5228 00001400 1E                      	push	ds			; store our data segment
  5229                                  
  5230                                  	;mov	si,offset DATARES:Int2f_Entry ; start of table
  5231 00001401 BE[0400]                	mov	si,Int2f_Entry
  5232                                  
  5233 00001404 31C0                    	xor	ax,ax			; indicate COMMAND present
  5234 00001406 EB11                    	jmp	short miRet		; return to caller
  5235                                  
  5236                                  miOurs:
  5237 00001408 F6C201                  	test	dl,1
  5238 0000140B 750C                    	jnz	short miRet		; ignore 'set' operations
  5239                                  
  5240 0000140D 53                      	push	bx			; preserve BX
  5241 0000140E 89D3                    	mov	bx,dx
  5242 00001410 30FF                    	xor	bh,bh			; BX = index in word table
  5243 00001412 D1E3                    	shl	bx,1			; BX = index in dword table
  5244                                  	;les	di,MsgPtrLists[bx]	; ES:DI = ptr to msg ptr list
  5245 00001414 C4BF[1B07]              	les	di,[bx+MsgPtrLists]
  5246 00001418 5B                      	pop	bx			; restore BX
  5247                                  miRet:
  5248                                  ;	mov	ds,[OldDS]		; restore ds
  5249 00001419 1F                      	pop	ds
  5250                                  	;assume	ds:nothing
  5251                                  
  5252 0000141A CF                      	iret
  5253                                  
  5254                                  ;MsgInt2fHandler endp
  5255                                  
  5256                                  	; MSDOS 6.0
  5257                                  ; ----------------------------------------------------------------------------
  5258                                  ;***	MsgRetriever - message retrieval routine for utilities
  5259                                  ;
  5260                                  ;	Address of this routine is passed to utility programs via 
  5261                                  ;	message services int 2f. We try to find the desired message
  5262                                  ;	in memory or in our disk image.
  5263                                  ;
  5264                                  ;	ENTRY	AX = message #
  5265                                  ;		DI = offset in RESGROUP of msg ptr list
  5266                                  ;		ComSpec = asciiz pathname to our disk image
  5267                                  ;
  5268                                  ;	EXIT	CY clear for success
  5269                                  ;		ES:DI = ptr to count byte, followed by message text
  5270                                  ;
  5271                                  ;		CY set for failure
  5272                                  ;		ES,DI undefined
  5273                                  ;
  5274                                  ;	USED	flags
  5275                                  ;
  5276                                  ;	NOTE
  5277                                  ;	  The message # in AX is used to compute an offset into
  5278                                  ;	  the message ptr list pointed to by DI. The lists must
  5279                                  ;	  start with message # 1 and proceed through consecutive
  5280                                  ;	  message #'s.  
  5281                                  ;
  5282                                  ;	  It is assumed that the msg ptr list is either ParsMsgPtrs or
  5283                                  ;	  ExtMsgPtrs. We use NUMPARSEMSGS and NUMEXTMSGS to check for
  5284                                  ;	  valid message #.  ;M033
  5285                                  ;
  5286                                  ;	  List positions with no corresponding message text are
  5287                                  ;	  indicated by null pointers, which this routine detects.
  5288                                  ; ----------------------------------------------------------------------------
  5289                                  
  5290                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5291                                  
  5292                                  ;SR; This routine will be called directly by the utilities. So, we have
  5293                                  ; trap for it in the stub. The stub pushes the old value of ds and the 
  5294                                  ; DATARES value on the stack. We get them off the stack to setup ds here
  5295                                  
  5296                                  ;MsgRetriever	proc	far
  5297                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  5298                                  
  5299                                  	; 14/01/2023
  5300                                  MsgRetriever:
  5301 0000141B 1F                      	pop	ds			; ds = DATARES
  5302                                  	;assume	ds:DATARES
  5303                                  ;	pop	word [OldDS]		; save old ds
  5304                                  
  5305 0000141C 50                      	push	ax			; preserve registers
  5306 0000141D 53                      	push	bx
  5307 0000141E 51                      	push	cx
  5308 0000141F 52                      	push	dx
  5309 00001420 56                      	push	si
  5310                                  
  5311                                  ;;	push	ds
  5312                                  ;;	push	cs
  5313                                  ;;	pop	ds			; DS = DATARES seg addr
  5314                                  ;;	assume	ds:RESGROUP
  5315                                  ;;	push	cs
  5316                                  
  5317 00001421 1E                      	push	ds			; get es from ds
  5318 00001422 07                      	pop	es			; ES = DATARES seg addr
  5319                                  
  5320                                  ;	Begin modification M033.
  5321                                  
  5322                                  ;	Make sure msg # is valid.
  5323                                  ;	Assume msg ptr list is either ParsMsgPtrs or ExtMsgPtrs.
  5324                                  
  5325                                  	;mov	bx,11
  5326 00001423 BB0B00                  	mov	bx,NUMPARSMSGS		; BX = # parse error msgs in list
  5327                                  	;cmp	di,offset DATARES:ParsMsgPtrs
  5328 00001426 81FF[BA09]              	cmp	di,PARSMSGPTRS
  5329 0000142A 7403                    	je	short chkmsgnum		; it's ParsMsgPtrs
  5330                                  	;mov	bx,90
  5331 0000142C BB5A00                  	mov	bx,NUMEXTMSGS		; BX = # extended error msgs in list
  5332                                  chkmsgnum:
  5333 0000142F 39C3                    	cmp	bx,ax
  5334 00001431 725A                    	jc	short mrRet		; msg # too high, return carry
  5335                                  
  5336                                  ;	Msg # is valid.
  5337                                  
  5338                                  ;	End modification M033.
  5339                                  
  5340 00001433 48                      	dec	ax
  5341 00001434 D1E0                    	shl	ax,1			; AX = offset into msg ptr list
  5342 00001436 01C7                    	add	di,ax			; DI = ptr to msg ptr
  5343                                  
  5344 00001438 81FF[5604]              	cmp	di,ResMsgEnd
  5345 0000143C 7247                    	jb	short mrInMem		; ptr (and message) in memory
  5346                                  
  5347                                  ;*	Retrieve message from disk (or ROM) image.
  5348                                  ;	Read once to get the ptr to the message, then again for the message.
  5349                                  
  5350                                  ;ifndef	ROMDOS
  5351                                  	; 14/01/2023
  5352                                  	;mov	si,offset DATARES:ComSpec	; DS:SI = ptr to pathname
  5353 0000143E BE[E901]                	mov	si,ComSpec
  5354 00001441 BA0100                  	mov	dx,1 ; EXT_EXISTS_OPEN		; DX = 'open existing file'
  5355 00001444 BB0020                  	mov	bx,2000h ; INT_24_ERROR		; BX = 'fail on crit error'
  5356 00001447 B8006C                  	mov	ax,6C00h
  5357                                  	;mov	ax,ExtOpen shl 8		; AX = 'Extended Open File'
  5358 0000144A CD21                    	int	21h				; call DOS
  5359 0000144C 723F                    	jc	short mrRet			; return failure
  5360                                  
  5361 0000144E 89C3                    	mov	bx,ax				; BX = file handle
  5362 00001450 89FA                    	mov	dx,di				; DX = ptr to msg ptr
  5363 00001452 31F6                    	xor	si,si				; SI = read count
  5364                                  mrRead:
  5365 00001454 81EA0001                	sub	dx,100h				; DX = LSW of file offset
  5366 00001458 31C9                    	xor	cx,cx				; CX = MSW of file offset
  5367 0000145A B80042                  	mov	ax,4200h
  5368                                  	;mov	ax,LSEEK shl 8			; AX = 'Set File Pointer'
  5369 0000145D CD21                    	int	21h				; call DOS
  5370 0000145F 721A                    	jc	short mrCloseFile		; handle error
  5371                                  
  5372                                  	;mov	dx,offset DATARES:MsgBuffer	; DS:DX = input buffer
  5373 00001461 BA[0204]                	mov	dx,MsgBuffer
  5374 00001464 B94000                  	mov	cx,64				; CX = # bytes to read
  5375 00001467 B43F                    	mov	ah,3Fh
  5376                                  	;mov	ah,READ				; AH = 'Read File'
  5377 00001469 CD21                    	int	21h				; call DOS
  5378 0000146B 720E                    	jc	short mrCloseFile		; handle error
  5379                                  
  5380 0000146D 09F6                    	or	si,si				; (CY cleared)
  5381 0000146F 750A                    	jnz	short mrCloseFile		; 2nd time thru - we're done
  5382 00001471 46                      	inc	si				; mark one read done
  5383 00001472 8B16[0204]              	mov	dx,[MsgBuffer]			; DX = ptr to message
  5384 00001476 09D2                    	or	dx,dx
  5385 00001478 75DA                    	jnz	short mrRead			; go read the message
  5386 0000147A F9                      	stc					; null ptr found- no msg
  5387                                  
  5388                                  mrCloseFile:
  5389 0000147B 9C                      	pushf				; save success/failure (CY)
  5390 0000147C B43E                    	mov	ah,3Eh
  5391                                  	;mov	ah,CLOSE		; AH = 'Close File'
  5392 0000147E CD21                    	int	21h			; call DOS
  5393                                  ;	Bugbug: should we avoid this popf?
  5394 00001480 9D                      	popf				; CY = success/failure
  5395 00001481 89D7                    	mov	di,dx			; ES:DI = ptr to msg, if successful
  5396 00001483 EB08                    	jmp	short mrRet		; we're done
  5397                                  
  5398                                  ;else	;ROMDOS
  5399                                  ;
  5400                                  ;;	DI = ptr to msg ptr
  5401                                  ;
  5402                                  ;	mov	si,di			; SI = ptr to msg ptr
  5403                                  ;	sub	si,100h			; SI = offset into image of msg ptr
  5404                                  ;	mov	cx,2			; CX = # bytes to copy from image
  5405                                  ;
  5406                                  ;;	ASSUME ES:NOTHING is still in effect.
  5407                                  ;
  5408                                  ;	push	ds
  5409                                  ;	pop	es				; ES = DATARES seg addr
  5410                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to buffer
  5411                                  ;	invoke	LoadFromROM			; copy msg ptr from ROM
  5412                                  ;	mov	si,word ptr MsgBuffer		; SI = ptr to message
  5413                                  ;	or	si,si
  5414                                  ;	jz	mrNoMsg			; null ptr- no message text
  5415                                  ;
  5416                                  ;	sub	si,100h			; SI = offset into image of msg
  5417                                  ;	mov	cx,64			; CX = # bytes to copy from image
  5418                                  ;	mov	di,offset DATARES:MsgBuffer
  5419                                  ;	invoke	LoadFromROM
  5420                                  ;	clc					; success
  5421                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to msg
  5422                                  ;	jmp	short mrRet
  5423                                  ;
  5424                                  ;mrNoMsg:
  5425                                  ;	stc
  5426                                  ;	jmp	short mrRet
  5427                                  ;
  5428                                  ;;;	mov	ax,COMMAND_SEG-10h	; AX = seg addr of COMMAND image
  5429                                  ;;;	mov	es,ax			; ES:DI = ptr to msg ptr in image
  5430                                  ;	assume	es:NOTHING
  5431                                  ;
  5432                                  ;endif	;ROMDOS
  5433                                  
  5434                                  ;*	Message ptr is in memory.
  5435                                  ;	If ptr is in memory, assume message is in memory (/msg).
  5436                                  
  5437                                  mrInMem:
  5438                                  	; 14/01/2023
  5439 00001485 268B3D                  	mov	di,[es:di]		; ES:DI = ptr to msg
  5440 00001488 09FF                    	or	di,di			; (CY cleared)
  5441 0000148A 7501                    	jnz	short mrRet		; found message
  5442 0000148C F9                      	stc				; null ptr found - no message
  5443                                  mrRet:	
  5444 0000148D 5E                      	pop	si			; restore all registers
  5445 0000148E 5A                      	pop	dx
  5446 0000148F 59                      	pop	cx
  5447 00001490 5B                      	pop	bx
  5448 00001491 58                      	pop	ax
  5449                                  
  5450                                  ;	mov	ds,[OldDS]		; restore ds
  5451 00001492 1F                      	pop	ds
  5452                                  	;assume	ds:nothing
  5453                                  
  5454 00001493 CB                      	retf	; 21/04/2023
  5455                                  
  5456                                  ;MsgRetriever endp
  5457                                  
  5458                                  ; M003; Start of changes for UMB support
  5459                                  
  5460                                  ; ----------------------------------------------------------------------------
  5461                                  ;***	Lh_OffUnlink -- Restore allocation strat and link state
  5462                                  ;
  5463                                  ;	ENTRY	al = Saved alloc strat and link state
  5464                                  ;			b0 = 1 if alloc strat to restore is HighFirst
  5465                                  ;			b1 = 1 if link state to restore is Linked
  5466                                  ;
  5467                                  ;	EXIT	None
  5468                                  ;
  5469                                  ;	USED	ax, bx, cx
  5470                                  ; ----------------------------------------------------------------------------
  5471                                  
  5472                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5473                                  
  5474                                  ;public	Lh_OffUnlink
  5475                                  Lh_OffUnlink:	; proc	far
  5476                                  	; 14/01/2023
  5477 00001494 88C5                    	mov	ch,al
  5478 00001496 88C1                    	mov	cl,al
  5479                                  	;;mov	ax,(ALLOCOPER shl 8) OR 0
  5480                                  	;mov	ax,(ALLOCOPER<<8)
  5481 00001498 B80058                  	mov	ax,5800h
  5482 0000149B CD21                    	int	21h
  5483 0000149D 89C3                    	mov	bx,ax
  5484 0000149F D0C9                    	ror	cl,1				; b7 = HighFirst bit
  5485 000014A1 80E180                  	and	cl,80h				; mask off b6-b0
  5486 000014A4 80E37F                  	and	bl,7fh				; mask off HighFirst bit
  5487 000014A7 08CB                    	or	bl,cl				; set HighFirst bit state
  5488                                  	;;mov	ax,(ALLOCOPER shl 8) OR 1
  5489                                  	;mov	ax,(ALLOCOPER<<8)|1
  5490 000014A9 B80158                  	mov	ax,5801h
  5491 000014AC CD21                    	int	21h				; set alloc strat
  5492                                  
  5493 000014AE 88EB                    	mov	bl,ch
  5494 000014B0 D0EB                    	shr	bl,1
  5495 000014B2 30FF                    	xor	bh,bh				; bx = linkstate
  5496                                  	;mov	ax,(ALLOCOPER shl 8) OR 3
  5497                                  	;mov	ax,(ALLOCOPER<<8)|3
  5498 000014B4 B80358                  	mov	ax,5803h
  5499 000014B7 CD21                    	int	21h				; set linkstate
  5500                                  
  5501 000014B9 CB                      	retf
  5502                                  
  5503                                  ;Lh_OffUnlink endp
  5504                                  
  5505                                  ; M003; End of changes for UMB support
  5506                                  ;public	EndCode
  5507                                  ; 14/01/2023
  5508                                  ;EndCode: ; label byte
  5509                                  ; 06/06/2023
  5510                                  ; 16/04/2023
  5511                                  EndCode equ ($-StartCode)+100h
  5512                                  ; 06/06/2023
  5513                                  ;EndCode equ $-StartCode
  5514                                  
  5515                                  ;CODERES ends
  5516                                  ;	end
  5517                                  
  5518                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5519                                  
  5520 000014BA 00<rep 6h>              	times	(((EndCode+15)>>4)<<4)-EndCode db 0
  5521                                  
  5522                                  ;align 16
  5523                                  
  5524                                  ;=============================================================================
  5525                                  ; INIT.ASM, MSDOS 6.0 (COMMAND.COM), 1991
  5526                                  ;=============================================================================
  5527                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  5528                                  
  5529                                  ; INIT.ASM (MSDOS 2.11 COMMAND.COM, Retro DOS v2.0, 30/04/2018)
  5530                                  
  5531                                  ;TITLE   COMMAND Initialization
  5532                                  
  5533                                  ;ENVIRONSIZ EQU  0A0H		; Must agree with values in ENVIRONMENT segment
  5534                                  ;ENVIRONSIZ2 EQU 092H
  5535                                  ;MAX_COMSPEC EQU ENVIRONSIZ2 ; = 146  ; 22/09/2018
  5536                                  
  5537                                  ; UINIT.ASM, MSDOS 6.0, 1991
  5538                                  ; 23/09/2018
  5539                                  ENVBIG	EQU 32768		;AN000; maximum environment size
  5540                                  ; 14/01/2023
  5541                                  ;ENVSML	EQU 160			;AN000; minimum environment size
  5542                                  
  5543                                  ; ----------------------------------------------------------------------------
  5544                                  
  5545                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5546                                  
  5547                                  ; 06/06/2023
  5548                                  ; (MSDOS 5.0 COMMAND.COM -initial- Environment Structure size)
  5549                                  ;ENVIRONSIZ equ 160
  5550                                  
  5551                                  ENVSML	equ 256	; minimum environment size
  5552                                  ;MAX_COMSPEC equ ENVIRONSIZ - Env_ComSpec
  5553                                  MAX_COMSPEC equ 146
  5554                                  ECOMSPEC equ 14
  5555                                  
  5556                                  ; 14/01/2023
  5557                                  TAB_CHAR equ 09h
  5558                                  SPACE_CHAR equ 20h	
  5559                                  
  5560                                  ; 06/06/2023
  5561                                  ; (MSDOS 6.22 COMMAND.COM -initial- Environment Structure size)
  5562                                  ENVIRONSIZ equ 180	; SIZE Environment 
  5563                                  
  5564                                  ;----------------------------------------------------
  5565                                  ; MSDOS 6.0 - ENVDATA.ASM - 1991
  5566                                  ;----------------------------------------------------
  5567                                  ;Environment Struc	; Default COMMAND environment
  5568                                  ;
  5569                                  ;Env_PathString  db	"path="
  5570                                  ;Env_PathSpec	 db	"c:\msdos"
  5571                                  ;                db	0
  5572                                  ;Env_PrmptString db	"prompt="
  5573                                  ;Env_PrmptSpec   db	"$p$g"
  5574                                  ;                db	0
  5575                                  ;Env_ComString   db	"comspec="
  5576                                  ;Env_ComSpec     db	"\command.com"
  5577                                  ;		 db	134 dup (0)
  5578                                  ;
  5579                                  ;Environment ends
  5580                                  ;----------------------------------------------------
  5581                                  
  5582                                  ;-----------------------------------------------------------------------------
  5583                                  
  5584                                  ;-----------------------------------------------------------------------------
  5585                                  ; START OF INIT PORTION
  5586                                  ; This code is deallocated after initialization.
  5587                                  ;-----------------------------------------------------------------------------
  5588                                  
  5589                                  ;INIT	SEGMENT PUBLIC PARA
  5590                                  
  5591                                  ; 	EXTRN   HEADER:BYTE
  5592                                  ;	EXTRN   BADCOMLKMES:BYTE
  5593                                  
  5594                                  ;	PUBLIC  CONPROC
  5595                                  
  5596                                  ;ASSUME  CS:RESGROUP,DS:RESGROUP,ES:RESGROUP,SS:RESGROUP
  5597                                  
  5598                                          ;ORG 0
  5599                                  ;ZERO = $
  5600                                  	; 23/09/2018
  5601                                  ZERO equ $	; Offset 0E30h for original MSDOS 3.3 COMMAND.COM
  5602                                  
  5603                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5604                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1560h (CODERES:0820h)
  5605                                  
  5606                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  5607                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1670h (CODERES:0820h)
  5608                                  ConProc:
  5609                                  	;mov	sp,offset ResGroup:RStack	; must be first instruction
  5610 000014C0 BC[D604]                	mov	sp,RStack
  5611                                  
  5612                                  ; We need to set the PSP to us right at start because Carousel needs
  5613                                  ; to be lied to and it does not set PSP when it transfers control to
  5614                                  ; us after loading us as an overlay. By setting PSP, we ensure that
  5615                                  ; command.com is also not lied to.
  5616                                  
  5617                                  	; 14/01/2023
  5618                                  	; MSDOS 6.0
  5619 000014C3 B450                            mov	ah,50h
  5620                                  	;mov	ah,SET_CURRENT_PDB
  5621 000014C5 8CC3                            mov	bx,es
  5622 000014C7 CD21                            int	21h
  5623                                  
  5624                                  	; 14/01/2023
  5625                                  	;mov	ah,30h 
  5626                                  	;;mov	ax,GET_VERSION<<8 ; 3000h
  5627                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5628 000014C9 B80030                  	mov	ax,3000h
  5629 000014CC CD21                    	int	21h
  5630                                  	;;;cmp	ax,EXPECTED_VERSION ; 1E03h
  5631                                  	;;cmp	ax,5
  5632                                  	;cmp	ax,EXPECTED_VERSION ; 0005h
  5633                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5634 000014CE 3D0616                  	cmp	ax,EXPECTED_VERSION ; 1606h
  5635 000014D1 7411                    	je	short okdos			; DOS version is ok
  5636                                  
  5637 000014D3 BA[8C1F]                	mov	dx,BADVERMSG			; DX = ptr to msg
  5638 000014D6 E85DFE                  	call	RPrint
  5639                                  
  5640                                  	; MSDOS 3.3
  5641                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  5642                                  	;int	21h             ; DOS - PRINT STRING
  5643                                  				; DS:DX -> string terminated by "$"
  5644 000014D9 8CC0                    	mov	ax,es
  5645 000014DB 2639061600              	cmp	[es:PDB.PARENT_PID],ax
  5646                                  	;cmp	[es:16h],ax			; if COMMAND is own parent,
  5647                                  Here:	
  5648 000014E0 74FE                    	jz	short Here			;  loop forever
  5649                                  	
  5650 000014E2 CD20                    	int	20h				; otherwise, exit
  5651                                  okdos:
  5652                                  	; 23/09/2018
  5653                                  
  5654                                  ;  Calculate and save the end of the INIT segment (which is also
  5655                                  ;  the beginning of TRANGROUP).
  5656                                  
  5657                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5658                                  	; MSDOS 3.3
  5659                                  	;mov	ah,65h
  5660                                  	;mov	al,2
  5661                                  	;mov	dx,-1
  5662                                  	;mov	bx,-1
  5663                                  	;mov	cx,5
  5664                                  	;mov	di,UCASE_ADDR
  5665                                  	;int	21h	; AH = 65h : GET EXTENDED COUNTRY INFORMATION (DOS 3.3+)
  5666                                  	;		; AL = 02h : Get pointer to character translation table
  5667                                  	;		; BX = code page (-1 = current global code page)
  5668                                  	;		; DX = country ID (-1 = current country)
  5669                                  	;		; CX = amount of data to return
  5670                                  	;; ES:DI = pointer to output buffer
  5671                                  	;; Buffer offset :
  5672                                  	;;	00h -  byte,  country Id
  5673                                  	;;  	01h -  dword, pointer to uppercase table	
  5674                                  
  5675                                  	; 14/01/2023
  5676                                  	; MSDOS 6.0 (& MSDOS 3.3)
  5677                                    	;mov	dx,232Fh     ; MSDOS 5.0 COMMAND.COM
  5678                                  	; 06/06/2023
  5679                                  	;mov	dx,26EFh     ; MSDOS 6.22 COMMAND.COM       	
  5680 000014E4 BA5F25                  	mov	dx,TRANSTART+15			; get end of init code
  5681                                  	; 27/09/2018
  5682                                  	;mov	dx,TRANSTART ; (paragraph aligned address)
  5683 000014E7 B104                    	mov	cl,4				; change to paragraphs
  5684 000014E9 D3EA                            shr	dx,cl				;
  5685 000014EB 8CC8                            mov     ax,cs                           ; get current segment
  5686 000014ED 01D0                            add     ax,dx                           ; calculate segment of end of init
  5687 000014EF A3[D41E]                        mov     [initend],ax			; save this
  5688                                  
  5689                                  	; 14/01/2023
  5690                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1591h 
  5691                                  
  5692                                  ;  Check for /? on the command line. If found, display help text and exit.
  5693                                  ;  NOTE: this routine may terminate the program, never returning.
  5694                                  
  5695 000014F2 E8B006                  	call	CheckHelp
  5696                                  
  5697                                  ; We have to patch the segment values for the various interrupt entry points.
  5698                                  ; This is because we need to have the default addresses of the handlers in our
  5699                                  ; stub before the relocation is done. These values will then be changed once
  5700                                  ; the resident is relocated
  5701                                  
  5702 000014F5 E81E09                  	call	patch_segs
  5703                                  
  5704                                  ;  Turn APPEND off during initialization processing
  5705                                  
  5706                                  	; 14/01/2023
  5707 000014F8 B800B7                  	mov     ax,0B700h
  5708                                  	;mov	ax,APPENDINSTALL                ; see if append installed
  5709 000014FB CD2F                    	int	2Fh				;
  5710                                  	;cmp	al,0				; append installed?
  5711 000014FD 08C0                    	or	al,al
  5712 000014FF 7418                    	jz	short set_msg_addr		; no - continue
  5713                                  	
  5714 00001501 B802B7                  	mov	ax,0B702h
  5715                                  	;mov	ax,APPENDDOS			; see if append DOS version right
  5716 00001504 CD2F                    	int	2Fh				;
  5717                                  	;cmp	ax,-1				; append version correct?
  5718                                  	;jne	short set_msg_addr		; no - continue
  5719 00001506 40                      	inc	ax ; -1 -> 0
  5720 00001507 7510                    	jnz	short set_msg_addr        
  5721                                  	
  5722 00001509 B806B7                  	mov     ax,0B706h
  5723                                  	;mov	ax,APPENDGETSTATE               ; Get the state of Append
  5724 0000150C CD2F                    	int	2Fh				;
  5725 0000150E 891E[6002]                      mov     [Append_State],bx		; save append state
  5726                                         
  5727 00001512 31DB                    	xor	bx,bx                           ; clear out state
  5728 00001514 B807B7                  	mov	ax,0B707h
  5729                                  	;mov	ax,APPENDSETSTATE               ; Set the state of Append
  5730 00001517 CD2F                    	int	2Fh				; set everything off
  5731                                  
  5732                                  set_msg_addr:
  5733                                  	; 14/01/2023
  5734                                  	;;mov	di,offset resgroup:DataresEnd 	; get address of resident end
  5735                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:15BAh) 
  5736                                  	;mov	di,093Eh  ; mov di,PAERRMSG0 ; MSDOS 5.0 COMMAND.COM
  5737                                  	; 06/06/2023
  5738                                  	; (MSDOS 6.22 COMMAND.COM - RESGROUP:16CBh) 
  5739                                  	;mov	di,0A41h  ; mov di,PAERRMSG0 ; MSDOS 6.22 COMMAND.COM
  5740 00001519 BF[DC08]                	mov	di,DataresEnd
  5741 0000151C 893E[5604]              	mov	[ResMsgEnd],di			; save it
  5742                                  
  5743 00001520 E80509                          call    get_XMMAddr                     ; get XMM call address
  5744                                  
  5745                                  ; Check if this is the first instance of command.com. If not, we just exit
  5746                                  ; this routine without moving any code.
  5747                                  ; After the int 2fh, ds:si points at the resident jump table in the previous
  5748                                  ; stub. We just have to copy this over
  5749                                  	
  5750                                  ;ifndef ROMDOS
  5751 00001523 B80055                  	mov	ax,5500h
  5752                                  	;mov	ax,GET_COMMAND_STATE	
  5753                                  ;else
  5754                                  ;	mov	ax,GET_ROMCOMMAND_STATE	
  5755                                  ;endif ; ROMDOS
  5756                                  
  5757 00001526 CD2F                    	int	2Fh	;  (Int 2Fh/AX=5500h - DOS 5+ - COMMAND.COM INTERFACE)
  5758                                  	;assume	ds:nothing
  5759                                  
  5760                                  	; 03/05/2023
  5761                                  	; Return:
  5762                                  	;   AX = 0000h if an instance of COMMAND.COM is already running
  5763                                  	;   DS:SI -> entry point table
  5764                                  
  5765                                  	; (si = offset Int2f_Entry)  ; (('MsgInt2fHandler:', 'fcOurs:'))
  5766                                  
  5767 00001528 09C0                    	or	ax,ax
  5768 0000152A 750C                    	jnz	short first_com			; this is the first instance
  5769                                  
  5770                                  	; 14/01/2023
  5771 0000152C 268936[1024]            	mov	[es:ResJmpTable],si		; save old stub jump table
  5772 00001531 268C1E[1224]            	mov	[es:ResJmpTable+2],ds
  5773 00001536 EB06                    	jmp	short init_cntry
  5774                                  
  5775                                  first_com:
  5776 00001538 26C606[1424]01          	mov	byte [es:FirstCom],1		; indicate first command.com
  5777                                  
  5778                                  init_cntry:
  5779                                  	; 14/01/2023
  5780 0000153E 06                      	push	es
  5781 0000153F 1F                      	pop	ds
  5782                                  	;assume	ds:RESGROUP
  5783                                  
  5784 00001540 B465                    	mov	ah,65h
  5785                                  	;mov	ah,GETEXTCNTRY			; get extended country info
  5786 00001542 B004                    	mov	al,4				; get file ucase table
  5787 00001544 BAFFFF                  	mov	dx,-1				;
  5788                                  	;mov	bx,-1				;
  5789 00001547 89D3                    	mov	bx,dx
  5790 00001549 B90500                  	mov	cx,5				; number of bytes we want
  5791                                  	;mov	di,offset resgroup:FUCase_Addr	; buffer for address
  5792 0000154C BF[5302]                	mov	di,FUCase_Addr
  5793 0000154F CD21                    	int	21h
  5794                                  		; DOS - 4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
  5795                                  		; AL = function -
  5796                                  
  5797                                  ;	Bugbug:	conditionalize dbcs_vector stuff?
  5798                                  
  5799 00001551 1E                      	push	ds				;
  5800 00001552 B80063                  	mov	ax,6300h
  5801                                  	;mov	ax,(ECS_CALL shl 8) or GETLEADBTBL ;
  5802 00001555 CD21                    	int	21h				;
  5803                                  		; DOS - 3.2+ only - GET DOUBLE BYTE CHARACTER SET LEAD TABLE
  5804                                  			
  5805 00001557 8CDB                    	mov	bx,ds				; get segment to bx
  5806 00001559 1F                      	pop	ds				;
  5807 0000155A 8936[5C02]              	mov	[Dbcs_Vector_Addr],si		; save address of
  5808 0000155E 891E[5E02]              	mov	[Dbcs_Vector_Addr+2],bx		; dbcs vector
  5809                                  
  5810                                  	;mov	ax,[16h]
  5811 00001562 A11600                  	mov	ax,[PDB.PARENT_PID]
  5812                                  				; mov ax,ds:16h	; Init PARENT so we can exit
  5813 00001565 A3[DC01]                	mov	[Parent],ax			;  correctly.
  5814 00001568 A10A00                  	mov	ax,[PDB.EXIT]   ; mov ax,ds:0Ah
  5815 0000156B A3[DE01]                	mov	[OldTerm],ax
  5816 0000156E A10C00                  	mov	ax,[PDB.EXIT+2] ; mov ax,ds:0Ch
  5817 00001571 A3[E001]                	mov	[OldTerm+2],ax
  5818                                  
  5819                                  	; 14/01/2023
  5820                                  	;;;mov	ax,offset ResGroup:EndCode + 15
  5821                                  	;;mov	ax,1569h	; MSDOS 5.0 COMMAND.COM
  5822                                  	; 06/06/2023
  5823                                  	;mov	ax,1679h	; MSDOS 6.22 COMMAND.COM
  5824                                  	;mov	ax,EndCode+15
  5825                                  	;;mov	ax,INITSTART+15 ; 24/09/2018
  5826                                  	; 14/01/2023
  5827                                  	;mov	cl,4				; ax = size of resident part of
  5828                                  	;shr	ax,cl				;  command in paragraphs. Add
  5829                                  	;mov	cx,cs				;  this to CS and you get the
  5830                                  	;add	ax,cx				;  segment of the TPA.
  5831                                  
  5832 00001574 8CC8                    	mov	ax,cs
  5833 00001576 055C01                  	add	ax,(EndCode+15)>>4
  5834                                  	
  5835 00001579 A3[FC03]                	mov     [Res_Tpa],ax			; Temporarily save the TPA segment
  5836 0000157C 2500F0                  	and     ax,0F000h
  5837 0000157F 050010                  	add     ax,1000h			; Round up to next 64K boundary
  5838 00001582 7303                    	jnc     short TpaSet			; Memory wrap if carry set
  5839 00001584 A1[FC03]                	mov     ax,[Res_Tpa]
  5840                                  TpaSet:
  5841 00001587 A3[EE03]                	mov	[LTpa],ax			; Good enough for the moment
  5842                                  	;mov	ax,[2]
  5843 0000158A A10200                  	mov	ax,[PDB.BLOCK_LEN]		; ax = # of paras given to command
  5844                                  
  5845 0000158D 8C1E[F403]              	mov	[MySeg1],ds			; These 3 variables are used as part of
  5846 00001591 8C1E[F803]              	mov	[MySeg2],ds			;  3 long ptrs that the transient will
  5847 00001595 8C1E[EC03]              	mov	[MySeg],ds			;  use to call resident routines.
  5848                                  	; 19/04/2023
  5849                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1641h
  5850 00001599 8C1E[2D07]              	mov	[MySeg3],ds			; segment of msg retriever routine 
  5851                                  
  5852 0000159D A3[3302]                	mov	[MemSiz],ax			; Needed for execing other programs
  5853                                  
  5854                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5855                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1648h
  5856                                  
  5857                                  ; First reallocate the COMMAND size to its memory image
  5858                                  	
  5859 000015A0 50                      	push	ax    
  5860                                    	;;;mov	bx,2320h  ; MSDOS 5.0 COMMAND.COM
  5861                                  	;;mov	bx,offset RESGROUP:TranStart    ;
  5862                                  	;mov	bx,TRANSTART
  5863                                  	;;add	bx,98C5h  ; MSDOS 5.0 COMMAND.COM
  5864                                          ;add	bx,offset TRANGROUP:TranSpaceEnd;
  5865                                  	;add	bx,15 ; *			; round up the size
  5866                                  	; 06/06/2023
  5867                                  	;mov	bx,26E0h  ; MSDOS 6.22 COMMAND.COM ; mov bx,offset RESGROUP:TranStart
  5868                                  	;add	bx,0AF95h ; MSDOS 6.22 COMMAND.COM ; add bx,offset TRANGROUP:TranSpaceEnd
  5869                                  	;add	bx,15 ; *			; round up the size
  5870                                  
  5871                                  	; 03/05/2023
  5872                                  	;mov	bx,TRANSTART+15 ; * ; 14/01/2023
  5873                                  	;add	bx,TRANSPACEEND
  5874                                  	; 06/06/2023
  5875                                  	;mov	bx,TRANSTART+TRANSPACEEND+15 
  5876                                          ;mov	cl,4				;
  5877                                          ;shr	bx,cl				; size of command.com
  5878 000015A1 BBF80C                  	mov	bx,(TRANSTART+TRANSPACEEND+15)>>4	
  5879                                  
  5880 000015A4 B44A                    	mov	ah,4Ah
  5881                                  	;mov	ah,SETBLOCK			; free all memory above pgm
  5882 000015A6 CD21                            int     21h				;
  5883 000015A8 58                              pop     ax				;
  5884                                  	
  5885                                  ; Compute maximum size of environment
  5886                                  
  5887                                  	;;mov	word [ENVMAX],69 ; = (160/16)+(973/16)-1 ; (11EEh-0E30h+0Fh/10h) = 3Ch
  5888                                          ;mov	word [ENVMAX],((ENVIRONSIZ+15)/16) + ((ENVMAXIMUM-ZERO+15)/16) - 1
  5889                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5890                                  	;mov	word [EnvMax],81	; 10+72-1  ; MSDOS 5.0 COMMAND.COM
  5891                                  	;mov	word [EndMax],90	; 12+79-1  ; MSDOS 6.22 COMMAND.COM	
  5892 000015A9 C706[C81E]5300          	mov	word [EnvMax],((ENVIRONSIZ+15)/16) + ((EnvMaximum-ZERO+15)/16) - 1
  5893                                  					; 12+(((1B53h-1670h)+15)/16)-1 = 90	
  5894                                  ;
  5895                                  ; Compute minimum size of environment
  5896                                  ;
  5897                                  	;;mov	word [EnvSiz],10 ; = 160/16	; MSDOS 3.3 COMMAND.COM
  5898                                  	;mov	word [EnvSiz],16 ; = 256/16	; MSDOS 5.0 COMMAND.COM
  5899 000015AF C706[C61E]1000          	mov	word [EnvSiz],ENVSML/16 ; 256/16
  5900                                  
  5901                                  	;;;mov	dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
  5902                                  	;;mov	dx,98D4h	; MSDOS 5.0 COMMAND.COM
  5903                                  	; 06/06/2023
  5904                                  	;;mov	dx,0AFA4h	; MSDOS 6.22 COMMAND.COM
  5905                                  	;mov	dx,TRANSPACEEND+15 ; 4D5Ch+0Fh (for MSDOS 3.3 COMMAND.COM)
  5906                                  	;mov	cl,4				;  in paragraphs.
  5907                                  	;shr	dx,cl
  5908 000015B5 BAA30A                  	mov	dx,(TRANSPACEEND+15)>>4
  5909                                  
  5910 000015B8 8916[D61E]                      mov     [TrnSize],dx			; save size of transient in paragraphs
  5911                                  
  5912 000015BC 29D0                    	sub	ax,dx				; max seg addr - # para's needed for transient
  5913 000015BE A3[2D02]                	mov	[TrnSeg],ax			;  = seg addr to load the transient at.
  5914                                  	;mov	ax,[2Ch]
  5915 000015C1 A12C00                  	mov	ax,[PDB.ENVIRON]		; ax = environment segment
  5916                                  
  5917                                  	; 14/01/2023
  5918                                          ; MSDOS 6.0
  5919                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5920 000015C4 A3[DC03]                	mov	[EnvirSeg],ax
  5921                                          
  5922                                  	; 21/01/2023
  5923 000015C7 09C0                    	or	ax,ax				; if there is no environment segment,
  5924 000015C9 7407                    	jz	short buildenv			; make one
  5925                                    
  5926                                  	; 21/01/2023
  5927                                  	; MSDOS 3.3 & MSDOS 5.0
  5928                                  	;;inc	byte [CHUCKENV]
  5929                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5930                                  	;inc	byte [AllocedEnv]		; Flag - old environment segment
  5931                                  	
  5932                                  	; MSDOS 3.3 & MSDOS 5.0
  5933                                  	; 06/06/2023
  5934                                  	;jmp	short environpassed
  5935                                  	
  5936                                  	; MSDOS 6.0
  5937                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM	
  5938 000015CB 803E[1424]00            	cmp	byte [FirstCom],0		; if this is the first command.com,
  5939 000015D0 7403                    	je	short environpassed		; do a merge job (make sure COMSPEC exists)
  5940                                  
  5941                                  	; MSDOS 6.0
  5942                                  
  5943                                  ; We allocate a buffer here just large enough to hold the 'PATH=' and
  5944                                  ; the COMSPEC. After parsing, we will allocate an environment of the right
  5945                                  ; size and free this buffer. We need this buffer because we no longer have an
  5946                                  ; ENVIRONMENT segment but need a place to store the COMSPEC which can be
  5947                                  ; given on the command line before we know the environment size. This routine
  5948                                  ; will not return in case of an allocation error. It will either exit or hang
  5949                                  ; depending on whether or not this is the first COMMAND.COM or not.
  5950                                  
  5951                                  	; 14/01/2023
  5952                                  buildenv:
  5953 000015D2 E8BC06                  	call	alloc_env                       ; try to allocate buffer
  5954                                  environpassed:
  5955                                  	; 14/01/2023 - MSDOS 5.0 COMMAND.COM
  5956                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5957                                  	;mov	[EnvirSeg],ax
  5958                                  	;
  5959 000015D5 8EC0                    	mov	es,ax                           ; and it load into es.
  5960                                  	;assume	es:nothing
  5961                                  
  5962                                  gottheenvir:
  5963                                  
  5964                                  ; Initialize the command drive
  5965                                  
  5966                                  	; 14/01/2023
  5967                                  	; MSDOS 3.3 & MSDOS 6.0
  5968 000015D7 B419                    	mov	ah,19h
  5969                                  	;mov	ah,GET_DEFAULT_DRIVE	; 19h
  5970 000015D9 CD21                    	int	21h
  5971 000015DB FEC0                    	inc	al
  5972 000015DD A2[3202]                	mov	[ComDrv],al
  5973                                  
  5974                                          ;mov	al,byte ptr ds:[FCB]	; al = default drive number for command
  5975 000015E0 A05C00                          mov	al,[FCB]
  5976 000015E3 08C0                    	or	al,al
  5977 000015E5 7433                    	jz	short nocomdrv		; no drive specified
  5978                                  
  5979 000015E7 B43A                    	mov	ah,':'
  5980 000015E9 A2[3202]                	mov	[ComDrv],al
  5981 000015EC 0440                    	add	al,40h			; convert number to uppercase character
  5982                                  
  5983 000015EE FD                      	std
  5984                                  
  5985                                  	; MSDOS 6.0
  5986                                  	; 06/06/2023
  5987                                  	; MSDOS 6.22 - COMMAND.COM - RESGROUP:17B7h
  5988 000015EF 803E[8C1E]00            	cmp	byte [AllocedEnv],0	; if a new environment is being built,
  5989 000015F4 7420                    	je	short notwidenv		;  move the default comspec string in it
  5990                                  	; 14/01/2023
  5991                                  	; MSDOS 5.0 COMMAND.COM
  5992 000015F6 8B3E[AF1E]              	mov	di,[ComspOffset]
  5993 000015FA 26807D013A                      cmp	byte [es:di+1],':'	; drive specifier already exist?
  5994 000015FF 7415                            je	short notwidenv		; yes, must have been inherited that way
  5995                                  
  5996                                  	; 06/06/2023
  5997                                  	; MSDOS 3.3
  5998                                  	;;cmp	byte [CHUCKENV],0
  5999                                  	;;jne	short NOTWIDENV
  6000                                  	; 21/01/2021
  6001                                  	; MSDOS 5.0 - COMMAND.COM - RESGROUP:16A5h
  6002                                   	;cmp	byte [AllocedEnv],0
  6003                                  	;ja	short notwidenv
  6004                                  
  6005 00001601 1E                        	push	ds			;  2 bytes to make room for a drivespec.
  6006 00001602 06                      	push	es			;  the drivespec is in ax and is copied
  6007 00001603 1F                      	pop	ds			;  on to the front of the string.
  6008                                  
  6009                                  ; 06/06/2023
  6010                                  %if 0
  6011                                  	; 21/01/2023
  6012                                  	; 14/01/2023
  6013                                  	; MSDOS 5.0 COMMAND.COM
  6014                                  	; MSDOS 3.3
  6015                                  	; 23/09/2018
  6016                                  	; 30/04/2018
  6017                                  	;mov	di,159
  6018                                  	;;MOV	DI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-1-10H
  6019                                  	;mov	di,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-1 ; mov di,9Fh
  6020                                  	mov	di,ENVIRONSIZ-1 ; 21/01/2023
  6021                                  	;mov	si,157
  6022                                  	;;MOV	SI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-3-10H
  6023                                          ;mov	si,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-3 ; mov si,9Dh 
  6024                                  	mov	si,ENVIRONSIZ-3 ; 21/01/2023 	
  6025                                  	;MOV	CX,ENVIRONSIZ2-2 ; mov cx,90h
  6026                                  	mov	cx,MAX_COMSPEC-2 ; 144
  6027                                  %endif
  6028                                  
  6029                                  	; MSDOS 6.0
  6030                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM - RESGROUP:17CCh
  6031 00001604 8DB58F00                        lea	si,[di+MAX_COMSPEC-3]	; lea si,[di+143]
  6032 00001608 8DBD9100                        lea	di,[di+MAX_COMSPEC-1]	; lea di,[di+145]
  6033                                  
  6034 0000160C B99000                          mov	cx,MAX_COMSPEC-2 ; 144
  6035                                  
  6036 0000160F F3A4                    	rep	movsb
  6037 00001611 1F                      	pop	ds
  6038                                  
  6039                                  	; MSDOS 6.0
  6040                                  	; 06/06/2023
  6041 00001612 268945FF                	mov	[es:di-1],ax
  6042                                  
  6043                                  	; MSDOS 3.3
  6044                                  	;mov	[es:0Eh],ax
  6045                                  	;;;MOV	WORD PTR ES:[ECOMSPEC-10H],AX
  6046                                  	;;MOV	[es:(ECOMSPEC-ENVIRONMENT)],ax	; mov [es:0Eh],ax
  6047                                  	; 14/01/2023
  6048                                  	; 06/06/2023
  6049                                  	;mov	[es:ECOMSPEC],ax ; mov [es:0Eh],ax
  6050                                  
  6051                                  	; MSDOS 3.3 & MSDOS 6.0
  6052                                  notwidenv:
  6053 00001616 FC                      	cld
  6054 00001617 A3[6E1E]                	mov	[AUTOBAT],ax ; db 0,":\AUTOEXEC.BAT"
  6055                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6056                                  	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C3h)
  6057                                  	
  6058                                  	; 22/07/2024
  6059                                  	; 06/06/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6060                                  	;mov	[KAUTOBAT],ax ; db 0,":\AUTOEXEC.BAT"
  6061                                  
  6062                                  nocomdrv:
  6063 0000161A E896FA                  	call	SetVect        ; Set the vectors
  6064                                  
  6065                                  ; parsing starts here
  6066                                  
  6067                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6068                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:16C9h - CODERES:0989h)
  6069                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6070                                  	; (MSDOS 6.22 COMMAND.COM - RESGROUP:17E8h - CODERES:0998h)
  6071                                  	; MSDOS 6.0
  6072 0000161D 0E                      	push	cs
  6073 0000161E 0E                      	push	cs
  6074 0000161F 1F                      	pop	ds
  6075 00001620 07                      	pop	es
  6076                                  	;assume ds:ResGroup,es:ResGroup
  6077                                  
  6078 00001621 BE8000                  	mov	si,80h				; get command line
  6079 00001624 AC                      	lodsb					; get length of line
  6080 00001625 89F7                    	mov	di,si				; get line position in di
  6081 00001627 30E4                    	xor	ah,ah				; ax = length of command line
  6082                                  
  6083                                  ; insure that the command line correctly ends with a cr
  6084                                  
  6085 00001629 01C7                    	add	di,ax				; go to end of command line
  6086 0000162B C6050D                          mov	byte [di],0Dh			; insert a carriage return
  6087 0000162E 31C9                    	xor	cx,cx				; clear cx
  6088 00001630 890E[881F]                      mov	[num_positionals],cx		; initialize positionals
  6089                                  
  6090                                  ; Scan the command line looking for the parameters
  6091                                  
  6092                                  Parse_command_line:
  6093                                  	;mov	di,offset ResGroup:Parse_Command; Get address of parse_command
  6094 00001634 BF[DE1E]                	mov	di,PARSE_COMMAND
  6095 00001637 8B0E[881F]              	mov	cx,[num_positionals]		; Get number of positionals
  6096 0000163B 31D2                    	xor	dx,dx				; clear dx
  6097 0000163D 8936[8A1F]                      mov	[old_parse_ptr],si		; save position before calling parser
  6098                                  	;call	dword ptr Init_Parse
  6099 00001641 FF1E[D21E]              	call	far [Init_Parse]		; call parser
  6100 00001645 890E[881F]                      mov     [num_positionals],cx		; Save number of positionals
  6101                                  	; 29/01/2023
  6102                                  	;;cmp	ax,END_OF_LINE ; 0FFFFh ; -1 	; are we at end of line?
  6103                                          ;cmp	ax,-1
  6104                                  	;jne	short t1
  6105                                  	; 10/06/2023
  6106 00001649 40                      	inc	ax	 ; cmp ax,-1
  6107 0000164A 7503                    	jnz	short t1 ; 0FFFFh -> 0
  6108                                  	; ax = 0
  6109 0000164C E93202                  	jmp     ArgsDone                        ; yes - exit
  6110                                  t1:	
  6111                                  	;;cmp	ax,RESULT_NO_ERROR ; 0		; did an error occur
  6112                                  	;;cmp	ax,0
  6113                                  	;and	ax,ax
  6114                                  	; 10/06/2023
  6115 0000164F 48                      	dec	ax  ; cmp ax,0
  6116 00001650 7450                    	jz	short parse_cont  ; 1 -> 0	; no - continue
  6117                                  
  6118                                  ; Before issuing error message - make sure switch is not /C
  6119                                  
  6120                                  parse_line_error:
  6121                                  	; 14/01/2023
  6122                                  	;push	si				; save line position
  6123                                  	;push	ax				; save error number
  6124                                  	;cmp	ax,3
  6125 00001652 83F803                  	cmp	ax,BadSwt_Ptr ; 3		; Was error invalid switch?
  6126                                          ;jnz	short parse_line_error_disp	; No - just issue message
  6127 00001655 7533                    	jne	short parse_line_error_disp2
  6128 00001657 56                      	push	si ; **				; save line position
  6129 00001658 50                      	push	ax ; *				; save error number
  6130 00001659 89F7                    	mov	di,si				; Get terminating pointer in DI
  6131 0000165B 8B36[8A1F]                      mov     si,[old_parse_ptr]		; Get starting pointer in SI
  6132                                  
  6133                                  init_chk_delim:
  6134 0000165F 39FE                    	cmp	si,di				; at end of parsed parameter?
  6135 00001661 7425                            je	short parse_line_error_disp	; Yes - just display message
  6136 00001663 AC                      	lodsb					;
  6137 00001664 3C20                    	cmp	al,20h ; ' ' ; 16/04/2023
  6138                                  	;cmp	al,space_chr ; 14/01/2023
  6139                                  	;;cmp	al,[space]			; Skip blank spaces
  6140 00001666 74F7                    	je	short init_chk_delim		;
  6141                                  	;cmp	al,9
  6142 00001668 3C09                    	cmp	al,tab_chr ; 9			; Skip tab characters
  6143 0000166A 74F3                    	je	short init_chk_delim		;
  6144                                  
  6145 0000166C 3A06[F003]              	cmp	al,[RSwitChar]	; '/'		; Switch?
  6146 00001670 7516                            jne	short parse_line_error_disp	; No - just issue message
  6147 00001672 AC                      	lodsb					; Get the char after the switch
  6148                                  
  6149 00001673 E8A004                  	call	iupconv 			; upper case it
  6150                                  
  6151                                  	;cmp	al,[scswitch]	; 'C'		; it is /C?
  6152                                          ;jne	short check_k_too ; MSDOS 6.0	;
  6153                                  	; 16/04/2023
  6154 00001676 3C43                    	cmp	al,'C' ; scswitch
  6155                                  	;jne	short parse_line_error_disp  ; MSDOS 5.0 COMMAND.COM
  6156                                  	; 06/06/2023
  6157                                  	; MSDOS 6.22 COMMAND.COM
  6158 00001678 7505                    	jne	short check_k_too
  6159 0000167A 5A                      	pop	dx ; *				; even up stack
  6160 0000167B 5A                      	pop	dx ; **				; even up stack
  6161 0000167C E9B100                  	jmp	SetSSwitch			; Yes - go set COMMAND /C
  6162                                  
  6163                                  	; MSDOS 6.0
  6164                                  	; 06/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  6165                                  check_k_too:
  6166                                  	;cmp	al,[skswitch]	; 'K'		; it is /K?
  6167                                          ;jne	short parse_line_error_disp	;
  6168                                  	; 06/06/2023
  6169 0000167F 3C4B                    	cmp	al,'K'
  6170 00001681 7505                    	jne	short parse_line_error_disp
  6171 00001683 5A                      	pop	dx ; *				; even up stack
  6172 00001684 5A                      	pop	dx ; **				; even up stack
  6173 00001685 E9A100                          jmp	SetKSwitch			; Yes - go set COMMAND /K
  6174                                  
  6175                                  parse_line_error_disp:
  6176                                  	; 14/01/2023
  6177 00001688 58                      	pop	ax ; *				; restore error number
  6178 00001689 5E                      	pop	si ; **				; restore line position
  6179                                  parse_line_error_disp2:
  6180 0000168A 89C2                    	mov	dx,ax				; get message number
  6181 0000168C E82B04                  	call	RPrintParse
  6182 0000168F E8A1FC                  	call	crlf
  6183 00001692 EBA0                            jmp     short Parse_command_line        ; continue parsing
  6184                                  
  6185                                  ; 16/04/2023
  6186                                  %if 1
  6187                                  SetMSwitch:
  6188                                          ;cmp	byte [ext_msg],1
  6189 00001694 803E[D91E]01            	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  6190                                  	; 16/04/2023
  6191                                  	;jnz	short setMswitchok		; no - set it
  6192                                  	;;mov	ax,1
  6193                                  	;mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  6194                                  	;jmp	parse_line_error                ; go issue error message
  6195                                  	; 16/04/2023
  6196 00001699 7458                    	je	short parse_line_error_j
  6197                                  setMswitchok:
  6198                                          ;mov	byte [ext_msg],1
  6199 0000169B C606[D91E]01            	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  6200                                  	; 06/06/2023
  6201 000016A0 EB92                    	jmp	short Parse_command_line	; keep parsing
  6202                                  %endif
  6203                                  
  6204                                  parse_cont:
  6205                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6206                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:173Ch - CODERES:09FCh)
  6207                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6208                                  	; (MSDOS 6.22 COMMAND.COM - RESGROUP:1869h - CODERES:0A19h)
  6209                                  
  6210                                  	; MSDOS 6.0
  6211                                  
  6212                                  ; See if a switch was entered
  6213                                  ;
  6214                                  ; Bugbug: See if Comnd1_Syn can be moved into a reg. before the compare
  6215                                  
  6216 000016A2 813E[811F][191F]        	cmp	word [COMND1_SYN],COMMAND_F_SYN ; was /F entered?
  6217 000016A8 7433                    	je	short SetFSwitch		; yes go set fail switch
  6218 000016AA 813E[811F][0D1F]        	cmp	word [COMND1_SYN],COMMAND_P_SYN ; was /P entered?
  6219 000016B0 743A                    	je	short SetPSwitch		; yes go set up PERMCOM
  6220 000016B2 813E[811F][251F]        	cmp	word [COMND1_SYN],COMMAND_D_SYN ; was /D entered?
  6221 000016B8 745C                    	je	short SetDSwitch		; yes go set date switch
  6222 000016BA 813E[811F][4A1F]        	cmp	word [COMND1_SYN],COMMAND_C_SYN ; was /C entered?
  6223 000016C0 746E                    	je	short SetSSwitch		; yes go set up SINGLECOM
  6224                                  	; 06/06/2023
  6225                                  	; MSDOS 6.0 only!
  6226 000016C2 813E[811F][701F]        	cmp	word [COMND1_SYN],COMMAND_K_SYN ; was /K entered?
  6227 000016C8 745F                            je	short SetKSwitch		; yes go set up SINGLECOM
  6228                                  	;
  6229 000016CA 813E[811F][311F]        	cmp	word [COMND1_SYN],COMMAND_E_SYN ; was /E entered?
  6230 000016D0 746F                    	je	short SetESwitch		; yes go set up environment
  6231 000016D2 813E[811F][561F]        	cmp	word [COMND1_SYN],COMMAND_M_SYN	; was /MSG entered?
  6232                                  	;je	short SetMSwitchjmp		; yes go set up message flag
  6233                                  	; 15/01/2023
  6234 000016D8 74BA                    	je	short SetMSwitch 
  6235 000016DA E98200                  	jmp	ChkOtherArgs		; Must be something else
  6236                                  
  6237                                  	; MSDOS 6.0
  6238                                  ;SetMSwitchjmp:
  6239                                  	;jmp	SetMSwitch
  6240                                  	
  6241                                  	; MSDOS 6.0
  6242                                  SetFSwitch:
  6243 000016DD 803E[4702]FF            	cmp	byte [fFail],-1		; has fail switch been set?
  6244                                  	; 16/04/2023
  6245                                  	;jne	short failok		; no - set it
  6246                                  	;;mov	ax,1
  6247                                  	;mov	ax,MoreArgs_Ptr         ; set up too many arguments
  6248                                          ;jmp	parse_line_error        ; go issue error 
  6249                                  	; 16/04/2023
  6250 000016E2 740F                    	je	short parse_line_error_j
  6251                                  
  6252                                  	; MSDOS 3.3 & MSDOS 6.0
  6253                                  failok:
  6254 000016E4 C606[4702]FF            	mov	byte [fFail],-1		; fail all INT 24s.
  6255                                  	; MSDOS 3.3
  6256                                  	;jmp	short CHKARG
  6257                                  	; MSDOS 6.0
  6258 000016E9 E948FF                  	jmp	Parse_command_line
  6259                                  
  6260                                  ;CHECKPSWITCH:
  6261                                  	;;cmp	al,'p'			; Permanent COMMAND switch
  6262                                  	;cmp	al,[letter_p]
  6263                                          ;jnz	short CHECKDSWITCH
  6264                                  
  6265                                  SetPSwitch:
  6266                                  
  6267                                  ; We have a permanent COMMAND switch /P. Flag this and stash the
  6268                                  ; termination address.
  6269                                  
  6270                                  	; MSDOS 6.0
  6271 000016EC 803E[4002]00            	cmp	byte [PermCom],0	; has /p switch been set?
  6272 000016F1 7406                    	jz	short permcomok		; no - set it
  6273                                  	; 16/04/2023
  6274                                  parse_line_error_j:
  6275                                          ;mov	ax,1
  6276 000016F3 B80100                  	mov	ax,MoreArgs_Ptr		; set up too many arguments
  6277 000016F6 E959FF                          jmp	parse_line_error	; go issue error 
  6278                                  
  6279                                  permcomok:
  6280                                  	; MSDOS 3.3 & MSDOS 6.0
  6281 000016F9 FE06[4002]              	inc	byte [PermCom]
  6282                                  	;mov	word [OLDTERM],LODCOM
  6283 000016FD C706[DE01][7E00]        	mov	word [OldTerm],LodCom_Trap
  6284                                  	;mov	[OLDTERM+2],ds
  6285 00001703 8C1E[E001]              	mov	[OldTerm+2],ds
  6286                                  
  6287                                  ; make sure that we display the date and time. if the flag was not
  6288                                  ; initialized, set it to indicate yes, do prompt.
  6289                                  
  6290                                  	; MSDOS 3.3
  6291                                  	;cmp	byte [PRDATTM],-1
  6292                                  	;jnz	short CHKARG
  6293                                  	;mov	byte [PRDATTM],0
  6294                                  	;jmp	short CHKARG
  6295                                  
  6296                                  	; MSDOS 6.0
  6297 00001707 803E[7F1E]FF            	cmp	byte [PRDATTM],-1
  6298 0000170C 7505                    	jne	short Parse_command_line_jmp
  6299 0000170E C606[7F1E]00            	mov	byte [PRDATTM],0
  6300                                  Parse_command_line_jmp:
  6301 00001713 E91EFF                  	jmp     Parse_command_line	; keep parsing
  6302                                  
  6303                                  ;COMRETURNSJ:
  6304                                  ;	; MSDOS 3.3
  6305                                  ;	JMP	ARGSDONE
  6306                                  
  6307                                  ;CHECKDSWITCH:
  6308                                  	;;cmp	al,'d'
  6309                                          ;cmp	al,[letter_d]
  6310                                  	;jnz	short CHECKCSWITCH
  6311                                  
  6312                                  SetDSwitch:
  6313                                  
  6314                                  ; Flag no date/time prompting.
  6315                                  
  6316                                  	; MSDOS 6.0
  6317 00001716 803E[DB1E]00            	cmp	byte [dswitch],0	; has /D switch been set?
  6318                                  	; 16/04/2023
  6319                                  	;jz	short setdateok		; no - set it
  6320                                          ;;mov	ax,1
  6321                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6322                                          ;jmp	parse_line_error	; go issue error message
  6323                                  	; 16/04/2023
  6324 0000171B 75D6                    	jnz	short parse_line_error_j
  6325                                  setdateok:
  6326 0000171D FE06[DB1E]              	inc	byte  [dswitch]		; indicate /D entered
  6327                                  
  6328                                  	; MSDOS 3.3 & MSDOS 6.0
  6329 00001721 C606[7F1E]01                    mov	byte [PRDATTM],1	; User explicitly says no date time
  6330                                  	; MSDOS 3.3
  6331                                  	;jmp	short CHKARG
  6332                                  	; MSDOS 6.0
  6333 00001726 E90BFF                  	jmp     Parse_command_line	; continue parsing
  6334                                  
  6335                                  	; 15/01/2023
  6336                                  	; MSDOS 6.0 
  6337                                  	; 06/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  6338                                  SetKSwitch:
  6339 00001729 C606[4102]00            	mov	byte [SemiPermCom],0
  6340 0000172E EB05                    	jmp	short SetSorKSwitch
  6341                                  
  6342                                  ;CHECKCSWITCH:
  6343                                  	;;cmp	al,'c'
  6344                                  	;cmp	al,[letter_c]
  6345                                          ;jnz	short CHECKESWITCH
  6346                                  
  6347                                  SetSSwitch:
  6348                                  ;SETCSWITCH:
  6349                                  
  6350                                  ; Set up pointer to command line, flag no date/time and turn off SingleCom.
  6351                                  
  6352 00001730 C606[4002]00            	mov	byte [PermCom],0	; A SingleCom must not be a PermCom
  6353                                  SetSorKSwitch:	; 06/06/2023
  6354 00001735 8936[4302]              	mov	[SingleCom],si		; Point to the rest of the command line
  6355 00001739 C606[7F1E]01            	mov	byte [PRDATTM],1	; no date or time either, explicit
  6356                                  ;COMRETURNSJ: ; 24/09/2018
  6357 0000173E E94001                  	jmp     ArgsDone
  6358                                  
  6359                                  ;CHECKESWITCH:
  6360                                  	;cmp	al,'e'
  6361                                  	;jnz	short CHKARG
  6362                                  
  6363                                  ; Look for environment-size setting switch
  6364                                  
  6365                                  ; The environment size is represented in decimal bytes and is
  6366                                  ; converted into paragraphs (rounded up to the next paragraph).
  6367                                  
  6368                                  SetESwitch:
  6369                                  	; MSDOS 6.0
  6370 00001741 803E[DA1E]00            	cmp	byte [eswitch],0	; has environment size switch been set?
  6371                                  	; 16/04/2023
  6372                                  	;jz	short eswitchok		; no - set it
  6373                                  	;;mov	ax,1
  6374                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6375                                          ;jmp	parse_line_error	; go issue error message
  6376                                  	; 16/04/2023
  6377 00001746 75AB                    	jnz	short parse_line_error_j
  6378                                  eswitchok:
  6379 00001748 FE06[DA1E]              	inc	byte [eswitch]		; indicate /E entered 	
  6380                                  
  6381                                  	; 06/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  6382                                  	; 15/01/2023 - Retro DOS v4.1 (& v4.1) - MSDOS 5.0 COMMAND.COM
  6383                                  	; MSDOS 6.0
  6384                                  	;mov	di,offset ResGroup:Comnd1_Addr	; get number returned
  6385 0000174C BF[831F]                        mov	di,COMND1_ADDR
  6386 0000174F 8B1D                    	mov     bx,[di]				; into bx
  6387                                  
  6388 00001751 83C30F                  	add	bx,0Fh				; Round up to next paragraph
  6389 00001754 B104                    	mov	cl,4				; convert to pargraphs
  6390 00001756 D3EB                    	shr	bx,cl				; by right 4
  6391                                  
  6392 00001758 891E[C61E]              	mov	[EnvSiz],bx			; EnvSiz is in paragraphs
  6393 0000175C E9D5FE                  	jmp	Parse_command_line		; continue parsing command line
  6394                                  
  6395                                  ; 16/04/2023
  6396                                  %if 0
  6397                                  SetMSwitch:
  6398                                          ;cmp	byte [ext_msg],1
  6399                                  	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  6400                                  	jnz	short setMswitchok		; no - set it
  6401                                  	;mov	ax,1
  6402                                  	mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  6403                                  	jmp	parse_line_error                ; go issue error message
  6404                                  setMswitchok:
  6405                                          ;mov	byte [ext_msg],1
  6406                                  	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  6407                                  	jmp	Parse_command_line              ; keep parsing
  6408                                  %endif
  6409                                  
  6410                                  ;ArgsDoneJ:
  6411                                  	;jmp	ArgsDone
  6412                                  
  6413                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6414                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:181Dh - CODERES:0ADDh)
  6415                                  
  6416                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6417                                  	; (MSDOS 6.22 COMMAND.COM - RESGROUP:196Dh - CODERES:0B1Dh)
  6418                                  ChkOtherArgs:
  6419                                  
  6420                                  ; We have a non-switch character here.
  6421                                  
  6422                                  	; MSDOS 6.0
  6423 0000175F 1E                      	push	ds ; ****			;
  6424 00001760 56                      	push	si ; *** 			; save place in command line
  6425 00001761 C536[831F]              	lds	si,[COMND1_ADDR]		; get address of filespec
  6426                                  	;assume	ds:nothing			;
  6427                                  
  6428 00001765 89F2                    	mov	dx,si				; put in dx also
  6429 00001767 B8023D                  	mov	ax,3D02h
  6430                                  	;mov	ax,(OPEN shl 8) or 2            ; Read and write
  6431 0000176A CD21                    	int	21h
  6432 0000176C 7260                    	jc	short ChkSrchSpec		; Wasn't a file
  6433 0000176E 89C3                    	mov	bx,ax
  6434 00001770 B80044                  	mov	ax,4400h
  6435                                  	;mov	ax,IOCTL shl 8
  6436 00001773 CD21                    	int	21h
  6437 00001775 F6C280                  	test	dl,80h
  6438 00001778 7506                    	jnz	short IsaDevice
  6439                                  BadSetCon:
  6440 0000177A B43E                    	mov	ah,3Eh
  6441                                  	;mov	ah,CLOSE		; Close initial handle, wasn't a device
  6442 0000177C CD21                    	int	21h
  6443 0000177E EB4E                    	jmp	short ChkSrchSpec
  6444                                  
  6445                                  	; 15/01/2023
  6446                                  IsaDevice:
  6447                                  	; MSDOS 3.3 & MSDOS 6.0
  6448 00001780 30F6                    	xor	dh,dh
  6449 00001782 80CA03                  	or	dl,3				; Make sure has CON attributes
  6450                                  	;mov	ax,(IOCTL shl 8) or 1
  6451 00001785 B80144                  	mov	ax,(IOCTL*256)|1 ; 4401h
  6452 00001788 CD21                    	int	21h
  6453                                  	;
  6454                                  	; 15/01/2023
  6455 0000178A 72EE                    	jc	short BadSetCon	; MSDOS 6.0 (& 5.0)
  6456                                  	; 25/09/2018
  6457                                  	;pop	dx ; *
  6458                                  	;pop	dx ; **
  6459                                  	;
  6460                                  	;jc	short BADSETCON	; MSDOS 6.0	; Can't set attributes - quit
  6461                                  	
  6462 0000178C 89DA                    	mov	dx,bx				; Save new handle
  6463                                  
  6464                                  	; MSDOS 6.0
  6465 0000178E 26803E[1524]01          	cmp	byte [es:DevFlag],1
  6466 00001794 742A                    	jz	short DevErr
  6467                                  
  6468                                  	; MSDOS 3.3
  6469                                          ;pop	bx ; *				; Throw away saved SI
  6470                                          ;pop	bx ; **				; Throw away saved CX
  6471                                  
  6472                                  	; MSDOS 3.3 & MSDOS 6.0
  6473 00001796 51                      	push	cx ; **
  6474 00001797 B90300                  	mov	cx,3
  6475 0000179A 31DB                    	xor	bx,bx
  6476                                  
  6477                                  	; 15/01/2023
  6478                                  rcclloop:
  6479 0000179C B43E                    	mov	ah,3Eh
  6480                                  	;mov	ah,CLOSE ; 3Eh
  6481 0000179E CD21                    	int	21h
  6482 000017A0 43                      	inc	bx
  6483 000017A1 E2F9                    	loop	rcclloop
  6484                                  
  6485 000017A3 89D3                    	mov	bx,dx				; New device handle
  6486 000017A5 B445                    	mov	ah,45h
  6487                                  	;mov	ah,XDUP ; 45h
  6488 000017A7 CD21                    	int	21h				; Dup to 0
  6489 000017A9 B445                    	mov	ah,45h
  6490                                  	;mov	ah,XDUP
  6491 000017AB CD21                    	int	21h				; Dup to 1
  6492 000017AD B445                    	mov	ah,45h
  6493                                  	;mov	ah,XDUP
  6494 000017AF CD21                    	int	21h				; Dup to 2
  6495 000017B1 B43E                    	mov	ah,3Eh
  6496                                  	;mov	ah,CLOSE
  6497 000017B3 CD21                    	int	21h				; Close initial handle
  6498                                  	
  6499 000017B5 59                      	pop	cx ; **
  6500                                  	
  6501                                  	; MSDOS 6.0
  6502 000017B6 5E                      	pop	si ; ***			; restore position of command line
  6503 000017B7 1F                      	pop	ds ; ****			;
  6504                                  
  6505                                  ; Register the fact that we already have redirected the output
  6506                                  ; and can not do it again
  6507                                  
  6508 000017B8 26FE06[1524]            	inc	byte [es:DevFlag]		
  6509 000017BD E974FE                  	jmp	Parse_command_line		; continue parsing
  6510                                  
  6511                                  	; MSDOS 3.3
  6512                                  	;jcxz	ARGSDONEJ2
  6513                                  	;jmp	CHKARG
  6514                                  
  6515                                  	; MSDOS 6.0
  6516                                  DevErr:
  6517 000017C0 5E                      	pop	si ; ***
  6518 000017C1 1F                      	pop	ds ; ****
  6519 000017C2 BA0100                  	mov	dx,1
  6520 000017C5 E8F202                          call	RPrintParse                     ; "Too many parameters"
  6521 000017C8 E868FB                          call	crlf
  6522 000017CB E966FE                  	jmp	Parse_command_line
  6523                                  
  6524                                  ChkSrchSpec:				; Not a device, so must be directory spec
  6525                                  	; MSDOS 6.0
  6526 000017CE 26803E[1624]01                  cmp	byte [es:PathFlag],1		; already set COMSPEC?
  6527 000017D4 74EA                            jz	short DevErr			; yes, error
  6528                                  	
  6529 000017D6 26FE06[1624]                    inc	byte [es:PathFlag]		; mark that we have a path
  6530                                  
  6531                                  ; We have to override the passed environment. Allocate a buffer for use now.
  6532                                  ; This buffer will later be replaced by a proper environment
  6533                                  
  6534                                  	; 15/01/2023 - Retro DOS v4.0 COMMAND.COM
  6535                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1899h
  6536                                  	; 06/06/2023
  6537                                  	;mov	ax,[ss:EnvirSeg]
  6538                                  	
  6539                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6540                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:19E9h
  6541                                  	;
  6542                                  	; MSDOS 6.0
  6543 000017DB E8B304                  	call	alloc_env                       ; environment buffer
  6544                                  
  6545                                  ; 06/06/2023
  6546                                  %if 0
  6547                                  	; 15/01/2023
  6548                                  	; MSDOS 5.0
  6549                                  	cmp	byte [ss:AllocedEnv],1
  6550                                  	mov	byte [ss:AllocedEnv],0
  6551                                  	jne     short env_alloced
  6552                                  	call	alloc_env
  6553                                  	mov	[ss:EnvirSeg],ax
  6554                                  %endif
  6555                                  
  6556                                  env_alloced:
  6557                                  	; MSDOS 5.0 & MSDOS 6.0
  6558 000017DE 8EC0                    	mov	es,ax
  6559                                  	;assume	es:nothing
  6560 000017E0 56                      	push	si ; **				; remember location of file
  6561 000017E1 31C9                    	xor	cx,cx				; clear cx for counting
  6562                                  	
  6563                                  	; 15/01/2023
  6564                                  countloop:
  6565 000017E3 AC                      	lodsb					; get a character
  6566 000017E4 41                      	inc	cx				; increment counter
  6567                                          ;;cmp	al,0
  6568                                  	;cmp	al,END_OF_LINE_OUT              ; are we at end of line?
  6569                                  	;jne	short countloop			; no - keep counting
  6570 000017E5 08C0                    	or	al,al	
  6571 000017E7 75FA                    	jnz	short countloop
  6572                                  	; 06/03/2023
  6573                                  	; al = 0 ; (*) 
  6574                                  
  6575                                  	;;;;mov	al,[Space]
  6576                                  	;;;mov	al,[ss:Space] ; 15/01/2023 - MSDOS 5.0 COMMAND.COM
  6577                                  	;;mov	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6578                                  	; 16/04/2023
  6579                                  	;mov	al,20h ; ' ' 
  6580 000017E9 4E                      	dec	si				; move back one
  6581                                          ;mov	[si],al				; put a space at end of line
  6582 000017EA C60420                  	mov	byte [si],20h ; ' ' ; space_chr
  6583                                  
  6584                                  ; We now know how long the new pathspec for command.com is. Time to
  6585                                  ; figure out how long the current COMSPEC setting is, and then to move
  6586                                  ; all the environment data up, throwing that COMSPEC setting away, and
  6587                                  ; preparing to append the new COMSPEC. ComspOffset (the offset of
  6588                                  ; where the filespec exists in the environment) is updated as well.
  6589                                  
  6590                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6591                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:19FEh
  6592                                  
  6593                                  	; MSDOS 6.0
  6594 000017ED 51                      	push	cx ; * 				;
  6595 000017EE B90080                          mov	cx,ENVBIG ; 32768		;
  6596 000017F1 368B3E[AF1E]                    mov	di,[ss:ComspOffset]		; get location of COMSPEC
  6597                                          ;mov	al,0                            ;
  6598                                  	; 06/06/2023
  6599                                  	; al = 0 ; (*)
  6600 000017F6 F2AE                    	repne	scasb                           ; find the end of COMSPEC
  6601 000017F8 89FE                            mov	si,di                           ;
  6602                                  comp_endenv:					;
  6603 000017FA AE                      	scasb					; end of env?
  6604 000017FB 7404                    	je	short got_endenv		; yes
  6605 000017FD F2AE                    	repne	scasb				;
  6606 000017FF EBF9                    	jmp	short comp_endenv		;
  6607                                  got_endenv:					;
  6608 00001801 89F9                    	mov	cx,di				;
  6609 00001803 29F1                    	sub	cx,si				;
  6610 00001805 368B3E[AF1E]            	mov	di,[ss:ComspOffset]		;
  6611 0000180A 83EF08                  	sub	di,ComspStrLen	; sub di,8	;
  6612 0000180D 1E                      	push	ds ; +				;
  6613 0000180E 06                      	push	es				;
  6614 0000180F 1F                      	pop	ds				;
  6615 00001810 F3A4                    	rep	movsb				;
  6616 00001812 4F                      	dec	di				; copy in new COMSPEC=
  6617 00001813 0E                      	push	cs				;
  6618 00001814 1F                      	pop	ds				;
  6619                                          ;assume ds:RESGROUP			;
  6620                                  	;mov    si,offset RESGROUP:ComspString	;
  6621 00001815 BE[B11E]                	mov	si,ComspString			; "COMSPEC=\COMMAND.COM"
  6622                                  	;mov	cx,ComspStrLen	; mov cx,8	;
  6623 00001818 B108                            mov	cl,ComspStrLen	; mov cl,8
  6624 0000181A F3A4                    	rep	movsb				;
  6625 0000181C 893E[AF1E]              	mov	[ComspOffset],di		;
  6626 00001820 1F                      	pop	ds ; + 				;
  6627                                          ;assume ds:nothing			;
  6628 00001821 59                      	pop	cx ; *				;
  6629                                  	;
  6630 00001822 5E                      	pop	si ; **				; get new comspec location back
  6631                                  
  6632                                  	;; MSDOS 3.3 COMMAND.COM
  6633                                  	;;mov	byte [CHUCKENV],0		; If search specified -- no inheritance
  6634                                  	;;mov	ax,PATHSTRING	; "PATH="	; Figure environment pointer
  6635                                  	;;mov	cl,4
  6636                                  	;;shr	ax,cl
  6637                                  	;;mov	dx,ds
  6638                                  	;;add	ax,dx
  6639                                  	;;mov	[ENVIRSEG],ax
  6640                                  	;;mov	es,ax
  6641                                  	;;;mov	al,' '
  6642                                  	;;mov	al,[SPACE_CHR]
  6643                                  	;;mov	[si-1],al
  6644                                  	;;pop	si ; **				; Remember location
  6645                                  	;;pop	cx ; *				; and count
  6646                                  	;;;mov	di,[ECOMLOC]
  6647                                  	;;mov	di,[COMSPOFFSET]
  6648                                  
  6649                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6650                                  	;; 15/01/2023
  6651                                  	;; MSDOS 5.0 COMMAND.COM
  6652                                  	;pop	si ; **
  6653                                  	;;mov	di,14
  6654                                  	;mov	di,ECOMSPEC ; mov di,0Eh
  6655                                  
  6656                                  ComtrLoop:
  6657                                  	; MSDOS 3.3 & MSDOS 6.0
  6658 00001823 AC                      	lodsb
  6659 00001824 49                      	dec	cx
  6660                                  	;;;;cmp	al,' '
  6661                                  	;;;cmp	al,[space_chr]
  6662                                  	;;cmp	al,[ss:Space] ;  MSDOS 5.0 COMMAND.COM
  6663                                  	;cmp	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6664                                  	; 16/04/2023
  6665 00001825 3C20                    	cmp	al,20h ; ' ' ; space_chr
  6666 00001827 7405                    	je	short SetComsr
  6667                                  	; MSDOS 3.3
  6668                                  	;cmp	al,9
  6669                                  	;je	short SetComsr
  6670                                  	; MSDOS 3.3 & MSDOS 6.0
  6671 00001829 AA                      	stosb
  6672 0000182A E302                    	jcxz	SetComsr
  6673 0000182C EBF5                    	jmp	short ComtrLoop
  6674                                  
  6675                                  SetComsr:
  6676                                  	; 15/01/2023
  6677                                  	; MSDOS 6.0
  6678 0000182E 51                      	push	cx ; **
  6679 0000182F 0E                      	push	cs				; Get local segment
  6680 00001830 1F                      	pop	ds				;
  6681                                  	;assume	ds:ResGroup			;
  6682 00001831 1E                      	push	ds ; *
  6683                                  	;mov	si,offset ResGroup:ComSpect
  6684 00001832 BE[601E]                	mov	si,COMSPECT ; "\COMMAND.COM"
  6685 00001835 B90E00                  	mov	cx,14
  6686 00001838 268A45FF                	mov	al,[es:di-1]
  6687 0000183C 3A06[F103]              	cmp	al,[RDirChar]
  6688 00001840 7502                    	jne	short iNotRoot
  6689 00001842 46                      	inc	si				; Don't make a double /
  6690 00001843 49                      	dec	cx
  6691                                  	
  6692                                  	; MSDOS 3.3
  6693                                  	;push	si
  6694                                  	;push	cx
  6695                                  	;push	ds
  6696                                  	;mov	si,COMSPECT ; "/COMMAND.COM"
  6697                                  	;mov	cx,14
  6698                                  	;mov	al,[es:di-1]
  6699                                  	;call	PATHCHRCMPR
  6700                                  	;jnz	short INOTROOT			
  6701                                  	;inc	si				; Don't make a double /
  6702                                  	;dec	cx
  6703                                  
  6704                                  iNotRoot:
  6705                                  	; MSDOS 3.3 & MSDOS 6.0
  6706 00001844 F3A4                    	rep	movsb
  6707                                  
  6708                                  	;;mov	dx,[ECOMLOC]			; Now lets make sure its good!
  6709                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6710                                  	; MSDOS 6.0 
  6711 00001846 8B16[AF1E]              	mov	dx,[ComspOffset] ; [COMSPOFFSET]
  6712                                  	; 15/01/2023
  6713                                  	;;mov	dx,14
  6714                                  	;mov	dx,ECOMSPEC ; mov dx,0Eh ; MSDOS 5.0 COMMAND.COM
  6715                                  
  6716 0000184A 06                      	push	es
  6717 0000184B 1F                      	pop	ds
  6718                                  	;;mov	ax,OPEN shl 8
  6719                                  	;mov	ax,OPEN*256 ; 3D00h
  6720 0000184C B8003D                  	mov	ax,3D00h ; 15/01/2023
  6721 0000184F CD21                    	int	21h				; Open COMMAND.COM
  6722 00001851 1F                      	pop	ds ; *
  6723 00001852 720E                    	jc	short SetComsrBad		; No COMMAND.COM here
  6724 00001854 89C3                    	mov	bx,ax				; Handle
  6725 00001856 B43E                    	mov	ah,3Eh ; 15/01/2023
  6726                                  	;mov	ah,CLOSE ; 3Eh
  6727 00001858 CD21                    	int	21h				; Close COMMAND.COM
  6728                                  SetComsrRet:
  6729                                  	; 15/01/2023
  6730 0000185A 59                      	pop	cx ; **
  6731 0000185B 5E                      	pop	si ; ***
  6732                                  
  6733                                  	; MSDOS 6.0
  6734 0000185C 1F                      	pop	ds ; ****			;
  6735                                  	;assume	ds:ResGroup			;
  6736                                  	;
  6737 0000185D 0E                      	push	cs				; Make sure local ES is
  6738 0000185E 07                      	pop	es				;  restored
  6739 0000185F E9D2FD                  	jmp	Parse_command_line		; continue parsing command line
  6740                                  
  6741                                  	; MSDOS 3.3
  6742                                  ;ARGSDONEJ2:
  6743                                  	;jcxz	ARGSDONE
  6744                                  	;jmp	CHKARG
  6745                                  
  6746                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6747                                  SetComsrBad:
  6748                                  	; MSDOS 3.3 & MSDOS 6.0
  6749                                  	;mov	dx,offset ResGroup:BadComlkMsg	; dx = ptr to msg
  6750 00001862 BA[1E20]                	mov	dx,BADCOMLKMES
  6751                                  
  6752                                  ;	Note: we're about to make a near call to TriageError, which
  6753                                  ;	lives in a different segment and group. Some linkers will
  6754                                  ;	generate a warning like "Possible fix-up overflow". We're
  6755                                  ;	ok, though, because we all fit in 64 KB and, at init time,
  6756                                  ;	we're still all together.
  6757                                  
  6758                                  	; 16/01/2023
  6759                                  	;TRIAGEERROR equ TRANSTART+TriageError
  6760                                  	;(MSDOS 5.0 COMMAND.COM, 2320h+2D92h)
  6761                                  
  6762                                  	; 06/06/2023
  6763                                  	TRIAGEERROR equ TRANSTART+TriageError
  6764                                  	;(MSDOS 6.22 COMMAND.COM, 26E0h+333Ch)
  6765                                  
  6766                                  	;;call	50B2h ; MSDOS 5.0 COMMAND.COM
  6767                                  	;call	5A1Ch ; MSDOS 6.22 COMMAND.COM
  6768 00001865 E8(1A57)                	call	TRIAGEERROR	; TRIAGEERROR procedure is at offset 354Eh
  6769                                  				; in original MSDOS 3.3 COMMAND.COM
  6770                                  
  6771                                  			; TriageError procedure is at offset 50B2h
  6772                                  			; in original MSDOS 5.0 COMMAND.COM	
  6773 00001868 83F841                  	cmp	ax,65
  6774 0000186B 7503                    	jne	short doprt
  6775                                  	;mov	dx,offset ResGroup:BadComaccMsg	; dx = ptr to msg
  6776 0000186D BA[4720]                	mov	dx,BADCOMACCMSG
  6777                                  doprt:
  6778 00001870 E8C3FA                  	call	RPrint
  6779                                  	;mov	si,offset ResGroup:ComSpect
  6780 00001873 BE[601E]                	mov     si,COMSPECT ; "\COMMAND.COM"
  6781                                  	;;mov	di,[ECOMLOC]
  6782                                  	; 06/06/2023
  6783 00001876 8B3E[AF1E]              	mov	di,[ComspOffset] ; MSDOS 6.22 COMMAND.COM
  6784                                  	; 16/01/2023
  6785                                  	;mov	di,ECOMSPEC ; mov di,0Eh ; MSDOS 5.0 COMMAND.COM
  6786 0000187A B90E00                  	mov	cx,14
  6787 0000187D F3A4                    	rep	movsb				; get my default back
  6788                                  
  6789 0000187F EBD9                    	jmp	short SetComsrRet
  6790                                  
  6791                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6792                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1927h (CODERES:0BE7h)
  6793                                  
  6794                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6795                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1A99h (CODERES:0C49h)
  6796                                  ArgsDone:
  6797                                  	; MSDOS 6.0
  6798 00001881 8E06[DC03]              	mov	es,[EnvirSeg]			; get environment back
  6799                                  	;assume	es:nothing			;
  6800                                  
  6801                                  	; MSDOS 3.3 & MSDOS 6.0
  6802 00001885 803E[4002]00                    cmp	byte [PermCom],0
  6803 0000188A 742E                            jz	short ComReturns
  6804                                  
  6805 0000188C 06                      	push	es				; Save environment pointer
  6806 0000188D B450                    	mov	ah,50h
  6807                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  6808 0000188F 8CDB                    	mov	bx,ds
  6809 00001891 8EC3                    	mov	es,bx
  6810 00001893 CD21                    	int	21h				; current process is me
  6811 00001895 BF0A00                  	mov	di,PDB.EXIT ; mov di,0Ah	; Diddle the addresses in my header
  6812                                  	;;mov	ax,offset RESGROUP:LODCOM
  6813                                  	;mov	ax,LODCOM
  6814                                  	; 16/01/2023
  6815 00001898 B8[7E00]                	mov	ax,LodCom_Trap
  6816 0000189B AB                              stosw
  6817 0000189C 8CD8                            mov	ax,ds
  6818 0000189E AB                              stosw
  6819                                  	;;mov	ax,offset RESGROUP:CONTC
  6820                                  	;mov	ax,CONTC
  6821                                  	; 16/01/2023
  6822 0000189F B8[4A00]                	mov	ax,Ctrlc_Trap
  6823 000018A2 AB                              stosw
  6824 000018A3 8CD8                            mov	ax,ds
  6825 000018A5 AB                              stosw
  6826                                  	;;mov	ax,offset DATARES:CritErr_Trap  ; MSDOS 6.0
  6827                                  	;mov	ax,CRITERR
  6828                                  	; 16/01/2023
  6829 000018A6 B8[5500]                	mov	ax,CritErr_Trap
  6830 000018A9 AB                      	stosw
  6831 000018AA 8CD8                    	mov     ax,ds
  6832 000018AC AB                      	stosw
  6833                                  	;;mov	word ptr ds:16h,ds
  6834                                  	;mov	word ptr ds:[Pdb_Parent_Pid],ds ; Parent is me forever
  6835 000018AD 8C1E1600                	mov	[PDB.PARENT_PID],ds
  6836                                          ;;mov	dx,offset RESGROUP:Int_2e
  6837                                  	;mov	dx,Int_2e
  6838                                          ; 16/01/2023
  6839 000018B1 BA[3F00]                	mov	dx,Int2e_Trap
  6840 000018B4 B82E25                  	mov	ax,252Eh
  6841                                  	;;mov	ax,(SET_INTERRUPT_VECTOR SHL 8) OR 2Eh
  6842                                  	;mov	ax,(SET_INTERRUPT_VECTOR*256) | 2Eh ; 252Eh
  6843 000018B7 CD21                    	int     21h	; DOS - SET INTERRUPT VECTOR
  6844                                  			; AL = interrupt number
  6845                                  			; DS:DX = new vector to be used for specified interrupt
  6846 000018B9 07                              pop	es				; Remember environment
  6847                                  	
  6848                                  ComReturns:
  6849                                          ;mov	ax,word ptr ds:Pdb_Parent_Pid
  6850 000018BA A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h
  6851                                  	; 16/01/2023
  6852 000018BD A3[DC01]                	mov	[Parent],ax			; Save parent
  6853                                          ;mov	word ptr ds:Pdb_Parent_Pid,ds 	; Parent is me
  6854 000018C0 8C1E1600                        mov	[PDB.PARENT_PID],ds ; mov word ptr ds:16h,ds
  6855                                          ;mov	ax,word ptr ds:PDB_Jfn_Table
  6856 000018C4 A11800                          mov	ax,[PDB.JFN_TABLE] ; mov ax,ds:18h
  6857 000018C7 A3[3D02]                        mov	[Io_Save],ax		; Get the default stdin and out
  6858 000018CA 8C1E[E003]                      mov	[Com_Ptr+2],ds		; Set all these to resident
  6859 000018CE 8C1E[E403]                      mov	[Com_Fcb1+2],ds
  6860 000018D2 8C1E[E803]              	mov	[Com_Fcb2+2],ds
  6861                                          ;mov	di,offset ResGroup:ComSpec
  6862 000018D6 BF[E901]                        mov	di,ComSpec
  6863                                  
  6864                                  	;;mov	si,[ECOMLOC]
  6865                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  6866 000018D9 8B36[AF1E]              	mov	si,[ComspOffset]
  6867                                  	; 16/01/2023 - MSDOS 5.0 COMMAND.COM
  6868                                  	;mov	si,ECOMSPEC ; mov si,0Eh
  6869                                  
  6870 000018DD 803E[8C1E]00            	cmp	byte [AllocedEnv],0 ; MSDOS 6.0
  6871                                          ;cmp	byte [CHUCKENV],0 ; MSDOS 3.3
  6872                                  	
  6873 000018E2 8CD8                    	mov	ax,ds				; Xchg es,ds
  6874 000018E4 06                      	push	es
  6875 000018E5 1F                      	pop	ds
  6876 000018E6 8EC0                    	mov	es,ax
  6877                                  
  6878                                  	; 06/06/2023
  6879 000018E8 7517                    	jne	short CopyComsp ; MSDOS 6.0
  6880                                  	; 16/01/2023	
  6881                                  	;je	short CopyComsp ; MSDOS 5.0
  6882                                  	;;je	short COPYCOMSP	; MSDOS 3.3	; All set up for copy
  6883                                  
  6884 000018EA 0E                              push	cs
  6885 000018EB 1F                              pop	ds
  6886                                  
  6887                                          ;mov	si,offset ResGroup:ComspString
  6888 000018EC BE[B11E]                	mov	si,ComspString ; "COMSPEC=\COMMAND.COM"
  6889 000018EF 06                      	push	es
  6890 000018F0 57                      	push	di
  6891 000018F1 E8D701                  	call	IfindE
  6892 000018F4 89FE                    	mov	si,di
  6893 000018F6 06                      	push	es
  6894 000018F7 1F                      	pop	ds
  6895 000018F8 5F                      	pop	di
  6896 000018F9 07                      	pop	es
  6897 000018FA 7305                            jnc	short CopyComsp
  6898                                  
  6899                                  	; 06/06/2023
  6900                                  	; MSDOS 6.0
  6901                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1B04h
  6902                                  ComSpecNofnd:
  6903                                  	;;mov	si,offset ResGroup:ComspString
  6904                                  	;mov	si,ComspString ; "COMSPEC=\COMMAND.COM"
  6905                                  	;add	si,ComspStrLen ; add si,8
  6906 000018FC BE[B91E]                	mov	si,ComspString+ComspStrLen
  6907                                  	
  6908                                  	;; 21/01/2023
  6909                                  	;; MSDOS 5.0 COMMAND.COM - RESGROUP:19A1h
  6910                                  	;;mov	si,0Eh
  6911                                  	;mov	si,ECOMSPEC
  6912                                  	
  6913 000018FF 0E                      	push	cs
  6914 00001900 1F                      	pop	ds	
  6915                                  
  6916                                  	; 21/01/2023
  6917                                  ;COMSPECNOFND:
  6918                                  	; MSDOS 3.3
  6919                                          ;;mov	si,[es:ECOMLOC]
  6920                                          ;mov	si,[es:COMSPOFFSET]
  6921                                  	;;add	si,offset RESGROUP:PATHSTRING
  6922                                          ;add	si,PATHSTRING ; "PATH="
  6923                                  	;push	cs
  6924                                  	;pop	ds
  6925                                  
  6926                                  CopyComsp:
  6927                                  	; 21/01/2023
  6928                                  ;COPYCOMSP:
  6929                                  	; MSDOS 3.3 & MSDOS 6.0
  6930                                  	;;mov	es:PutBackComSpec.SubstPtr,di
  6931                                  	;mov	[es:PUTBACKSUBSTPTR],di		; Save ptr to beginning of comspec path
  6932 00001901 26893E[C801]            	mov	[es:PutBackComSpec],di
  6933 00001906 807C013A                	cmp	byte [si+1],':'			; Is there a drive specifier in comspec
  6934 0000190A 7506                    	jne	short CopyComspLoop		; If not, do not skip over first 2 bytes
  6935                                  	;;add	es:PutBackComSpec.SubstPtr,2
  6936                                  	;add	word [es:PUTBACKSUBSTPTR],2
  6937 0000190C 268306[C801]02          	add	word [es:PutBackComSpec],2
  6938                                  CopyComspLoop:
  6939 00001912 AC                      	lodsb
  6940 00001913 AA                      	stosb
  6941 00001914 08C0                    	or	al,al
  6942 00001916 75FA                    	jnz	short CopyComspLoop
  6943                                  
  6944 00001918 26893E[2902]            	mov	[es:ComSpec_End],di		; Save ptr to end of comspec path
  6945 0000191D 26FF0E[2902]            	dec	word [es:ComSpec_End]
  6946 00001922 268A26[3202]            	mov	ah,[es:ComDrv]
  6947 00001927 80C440                  	add	ah,'A'-1 ; 40h
  6948 0000192A 268826[CD01]            	mov	[es:PutBackDrv],ah		; save drive letter
  6949                                  
  6950                                  	; 21/01/2023 - Retrro DOS v4.0 (& v4.1) COMMAND.COM
  6951                                  	
  6952                                  	; MSDOS 6.0
  6953 0000192F E81002                  	call	setup_for_messages		; set up parse and extended error messages
  6954                                  
  6955                                  ; The routine below sets up the exact resident size of COMMAND. If this is not
  6956                                  ; the first COMMAND, then the resident code is not duplicated and the resident
  6957                                  ; size is just the data. If we are the first COMMAND, it checks if we are to
  6958                                  ; be loaded into HIMEM. If not, then the resident size includes the code and
  6959                                  ; the data otherwise it is just the data.
  6960                                   
  6961 00001932 E8AF02                  	call	Setup_res_end			; put resident size in ResSize
  6962                                  
  6963 00001935 0E                      	push	cs
  6964 00001936 1F                      	pop	ds
  6965                                  	;assume	ds:RESGROUP
  6966                                  
  6967                                  ;Public EnvMaximum
  6968                                          ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6969                                  EnvMaximum:	; MSDOS 5.0 COMMAND.COM - RESGROUP:19DCh
  6970                                          ; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6971                                  		; MSDOS 6.22 COMMAND.COM - RESGROUP:1B53h
  6972                                  
  6973                                  	; 21/01/2023
  6974                                  	; MSDOS 6.0
  6975                                  	;;mov	si,offset RESGROUP:TranStart
  6976                                  	;;mov	si,2320h	; MSDOS 5.0 COMMAND.COM
  6977                                  	; 06/06/2023
  6978                                  	;;mov	si,26E0h	; MSDOS 6.22 COMMAND.COM
  6979                                  	;mov	si,TRANSTART
  6980                                  	;add	si,100h
  6981                                  	; 23/04/2023
  6982 00001937 BE5026                  	mov	si,TRANSTART+100h
  6983                                  
  6984                                  	;;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  6985                                  	;;mov	cx,87C2h	; MSDOS 5.0 COMMAND.COM
  6986                                  	; 06/06/2023
  6987                                  	;;mov	cx,9D53h	; MSDOS 6.22 COMMAND.COM	
  6988 0000193A B9[6398]                	mov	cx,TRANDATAEND-100h
  6989                                  
  6990 0000193D FC                      	cld
  6991 0000193E D1E9                    	shr	cx,1
  6992 00001940 31D2                    	xor	dx,dx
  6993                                  Ichksum:
  6994 00001942 AD                      	lodsw
  6995 00001943 01C2                    	add	dx,ax
  6996 00001945 83D200                  	adc	dx,0
  6997 00001948 E2F8                    	loop	Ichksum
  6998                                  
  6999 0000194A 8916[3502]                      mov	[Sum],dx			; store checksum
  7000                                  
  7001 0000194E 803E[7F1E]00                    cmp     byte [PRDATTM],0
  7002 00001953 750C                            jne	short NoBatchSeg		; don't do autoexec or date time
  7003                                  	
  7004                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  7005                                  
  7006                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16
  7007                                  	; 21/01/2023
  7008                                  	;mov	bx,4
  7009 00001955 BB0400                          mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  7010 00001958 B448                    	mov	ah,48h
  7011                                  	;mov	ah,ALLOC                        ;
  7012 0000195A CD21                            int	21h                             ;
  7013 0000195C 7203                    	jc	short NoBatchSeg		; didn't allocate - pretend no batch
  7014 0000195E A3[E701]                        mov	[Batch],ax			; save batch segment
  7015                                  
  7016                                  NoBatchSeg:
  7017                                  	; 21/01/2023
  7018                                  	; MSDOS 6.0 (& MSDOS 5.0)
  7019 00001961 8B1E[DC03]              	mov	bx,[EnvirSeg]			; get old environment segment
  7020 00001965 891E[CA1E]              	mov	[OldEnv],bx			; save it
  7021 00001969 C706[CC1E]0000          	mov	word [UsedEnv],0		; initialize env size counter
  7022 0000196F 8EDB                    	mov	ds,bx
  7023                                  	;assume	ds:nothing
  7024                                  	
  7025 00001971 31F6                    	xor	si,si
  7026 00001973 89F7                    	mov	di,si
  7027                                  
  7028                                  ; This is the maximum allowed size for the environment
  7029                                  
  7030                                  	; 21/01/2023
  7031                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1A1Eh
  7032                                  	;mov	bx,4096 - 1 ; 0FFFh		; max. allowed env. size
  7033                                  	;;mov	[ss:EnvMax],bx
  7034                                  	;shl	bx,1
  7035                                  	;shl	bx,1
  7036                                  	;shl	bx,1
  7037                                  	;shl	bx,1
  7038 00001975 BBF0FF                  	mov	bx,(4096-1)<<4 ; mov bx,0FFF0h
  7039 00001978 36891E[C81E]            	mov	[ss:EnvMax], bx			; convert envmax to bytes
  7040 0000197D 4B                      	dec	bx				; dec by one to leave room for double 0
  7041 0000197E 31D2                    	xor	dx,dx				; use dx to indicate that there was
  7042                                  						; no environment size error.
  7043                                  ;public NxtStr
  7044                                  NxtStr:
  7045 00001980 E81E01                  	call	GetStrLen			; get the size of the current env string
  7046                                  
  7047                                  ;Bugbug: Can use ss here to address UsedEnv
  7048                                  
  7049 00001983 1E                      	push	ds                              ; get addressability to environment
  7050 00001984 0E                              push	cs                              ;                       counter
  7051 00001985 1F                              pop	ds                              ;
  7052                                  	;assume	ds:ResGroup
  7053 00001986 010E[CC1E]                      add	[UsedEnv],cx			; add the string length to env size
  7054 0000198A 1F                      	pop	ds                              ;
  7055                                  	;assume	ds:nothing
  7056                                  	
  7057 0000198B 83F901                  	cmp	cx,1				; end of environment was encountered.
  7058 0000198E 7405                    	je	short EnvExit
  7059 00001990 29CB                    	sub	bx,cx
  7060                                  	;jae	short OkCpyStr			; can't fit in all of enviroment.
  7061                                  	; 21/01/2023
  7062 00001992 73EC                    	jae	short NxtStr
  7063 00001994 42                      	inc	dx				; out of env space msg must be displayed
  7064                                  	;jmp	short EnvExit
  7065                                  
  7066                                  ;OkCpyStr:
  7067                                  	;jmp	short NxtStr
  7068                                  
  7069                                  EnvExit:
  7070 00001995 0E                      	push	cs
  7071 00001996 1F                      	pop	ds
  7072                                  	;assume	ds:ResGroup
  7073 00001997 09D2                    	or	dx,dx				; dx will be non-zero if error
  7074 00001999 7406                    	jz	short EnvNoErr
  7075                                  	;mov	dx,offset ResGroup:OutEnvMsg	; dx = ptr to msg
  7076 0000199B BA[A41F]                	mov	dx,OUTENVMSG
  7077 0000199E E895F9                  	call 	RPrint
  7078                                  EnvNoErr:
  7079 000019A1 A1[C61E]                	mov	ax,[EnvSiz]			; env size previously set
  7080 000019A4 B104                    	mov	cl,4
  7081 000019A6 D3E0                    	shl	ax,cl				; get size in bytes
  7082 000019A8 3B06[CC1E]              	cmp	ax,[UsedEnv]			; is it a new env?
  7083 000019AC 7706                    	ja	short st_envsize		; yes, store the size
  7084 000019AE A1[CC1E]                	mov	ax,[UsedEnv]
  7085 000019B1 83C00F                  	add	ax,15				; round up
  7086                                  st_envsize:	
  7087 000019B4 D3E8                    	shr	ax,cl
  7088 000019B6 A3[C61E]                	mov	[EnvSiz],ax			; store env size needed(paras)
  7089                                  
  7090                                  ;if MSVER
  7091                                  	;cmp	SingleCom,0
  7092                                  	;jnz	nophead 			; don't print header if SingleCom
  7093                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7094                                  	;call	RPrint
  7095                                  ;nophead:
  7096                                  ;endif
  7097                                  	; 21/01/2023
  7098                                  
  7099                                  	; MSDOS 3.3 & 6.0
  7100 000019B9 833E[E701]00            	cmp     word [Batch],0		; did we set up a batch segment?
  7101 000019BE 7503                    	jnz     short DoDate		; yes - go initialize it
  7102 000019C0 E99300                  	jmp     NoDttm			; don't do autoexec or date time
  7103                                  
  7104                                  DoDate:
  7105                                  
  7106                                  ; allocate batch segment for d:/autoexec.bat + no arguments
  7107                                  
  7108 000019C3 A1[E701]                	mov	ax,[Batch]		; get batch segment
  7109 000019C6 C606[3B02]03            	mov	byte [EchoFlag],3	; set batch echo
  7110 000019CB C706[4C02]0100          	mov	word [Nest],1		; set nest flag to 1 batch
  7111 000019D1 8EC0                    	mov	es,ax
  7112                                  
  7113                                  ; initialize the segment
  7114                                  
  7115 000019D3 31FF                    	xor	di,di
  7116                                  	;;mov	al,0
  7117                                  	;mov	al,BATCHTYPE ; 0
  7118                                  	; 06/06/2023
  7119 000019D5 31C0                    	xor	ax,ax
  7120 000019D7 AA                      	stosb
  7121                                  	;mov	al,1			; initialize echo for batch exit
  7122                                  	;inc	al
  7123                                  	; 22/07/2024
  7124 000019D8 40                      	inc	ax
  7125 000019D9 AA                      	stosb
  7126                                  
  7127                                  ; Hosebag! This guy does not use the struct fields to init the BatchSegment
  7128                                  
  7129                                  	;xor	ax,ax			; initialize to zero
  7130                                  	; 06/06/2023
  7131                                  	;dec	al ; ax = 0
  7132                                  	; 22/07/2024
  7133 000019DA 48                      	dec	ax
  7134                                  
  7135                                  	; 21/01/2023
  7136 000019DB AA                      	stosb	; MSDOS 6.0 		; clear out BatchEOF
  7137                                  
  7138 000019DC AB                      	stosw				; batch segment of last job - batlast
  7139 000019DD AB                      	stosw				; segment for FOR
  7140 000019DE AA                      	stosb				; FOR flag
  7141 000019DF AB                      	stosw				; position in file - batseek
  7142 000019E0 AB                      	stosw
  7143                                  
  7144                                  ; clean out the parameters
  7145                                  
  7146                                  	;mov	ax,-1			; initialize to no parameters
  7147                                  	; 06/06/2023
  7148 000019E1 48                      	dec	ax ; ax = -1
  7149                                  
  7150 000019E2 B90A00                  	mov	cx,10
  7151 000019E5 F3AB                    	rep	stosw
  7152                                  
  7153                                  ; decide whether we should grab the default drive
  7154                                  
  7155 000019E7 803E[6E1E]00            	cmp	byte [AUTOBAT],0 ; ":\AUTOEXEC.BAT"
  7156 000019EC 7509                    	jne	short NoAutSet
  7157 000019EE B419                    	mov	ah,19h	; 21/01/2023
  7158                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  7159 000019F0 CD21                    	int	21h
  7160                                  	;;add	al,'A'
  7161                                  	;add	al,[letter_A] ; Ucasea
  7162                                  	;add	al,[ucasea] ; 21/01/2023
  7163                                  	; 21/01/2023
  7164 000019F2 0441                    	add	al,'A'
  7165 000019F4 A2[6E1E]                	mov	[AUTOBAT],al
  7166                                  	; 22/07/2024
  7167                                  	; 21/01/2023
  7168                                  	; 06/06/2023
  7169                                  	;mov	[KAUTOBAT],al
  7170                                  NoAutSet:
  7171                                  
  7172                                  ; copy in the batch file name (including nul)
  7173                                  
  7174                                  	;mov	si,offset ResGroup:AutoBat
  7175 000019F7 BE[6E1E]                	mov	si,AUTOBAT
  7176 000019FA B90800                  	mov	cx,8
  7177 000019FD F3A5                    	rep	movsw
  7178                                  	; 23/04/2023
  7179 000019FF A4                      	movsb	; MSDOS 6.0		; move in carriage return to terminate string
  7180                                  
  7181                                  	;mov	dx,offset ResGroup:AutoBat
  7182 00001A00 BA[6E1E]                	mov     dx,AUTOBAT ; ":\AUTOEXEC.BAT"
  7183                                  
  7184                                  	;;mov	ax,OPEN shl 8
  7185 00001A03 B8003D                  	mov	ax,3D00h ; 21/01/2023
  7186                                  	;mov	ax,OPEN*256 ; 3D00h	; open for read
  7187 00001A06 CD21                    	int	21h			; see if autoexec.bat exists
  7188 00001A08 7208                    	jc	short noabat
  7189 00001A0A 89C3                    	mov	bx,ax
  7190 00001A0C B43E                    	mov	ah,3Eh ; 21/01/2023
  7191                                  	;mov	ah,CLOSE  ; 3Eh
  7192 00001A0E CD21                    	int	21h
  7193                                  	;jmp	Drv0			; go process autoexec
  7194                                  	; 22/07/2024
  7195 00001A10 EB51                    	jmp	short Drv0
  7196                                  
  7197                                  noabat:
  7198 00001A12 50                      	push	ax
  7199 00001A13 E89400                  	call	Setup_Seg
  7200 00001A16 A3[8A1E]                	mov	[triage_add+2],ax
  7201 00001A19 58                      	pop	ax
  7202 00001A1A FF1E[881E]              	call	far [triage_add]	; get extended error
  7203 00001A1E 83F841                  	cmp	ax,65			; network access denied?
  7204                                  	;jne	short OPENERR		; no - go deallocate batch
  7205                                  	; 21/01/2023
  7206                                  	;;je	short AccDenErr
  7207                                  	; 22/07/2024
  7208 00001A21 7506                    	jne	short OpenErr 
  7209                                  	; 06/06/2023
  7210                                  	;je	short AccDenErr
  7211                                  
  7212                                  	; 21/01/2023
  7213                                  ;_ACCDENERROR:					; yes - put out message
  7214                                  ;	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7215                                  ;	mov	dx,ACCDENERR
  7216                                  ;	call	RPRINT
  7217                                  
  7218                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7219                                  
  7220                                  	; MSDOS 6.0 (& MSDOS 5.0)
  7221                                  
  7222                                  ; 22/07/2024
  7223                                  ; 06/06/2023
  7224                                  ; 21/01/2023
  7225                                  %if 0
  7226                                  
  7227                                  ; If AUTOEXEC.BAT is not found, then check for KAUTOEXE.BAT. Changed
  7228                                  ; by Ellen to check only when in Korea. The country information
  7229                                  ; returned will overlay the old parse data area, but we don't care
  7230                                  ; since we won't need the parse information or country information.
  7231                                  ; We only care about the country code returned in BX.
  7232                                  
  7233                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1AE7h
  7234                                  	; 06/06/2023
  7235                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1C5Eh
  7236                                  
  7237                                  	;mov	dx,offset ResGroup:Internat_Info ; set up internat vars
  7238                                  	mov	dx,INTERNAT_INFO
  7239                                  	mov	ax,3800h
  7240                                  	;mov	ax,INTERNATIONAL<<8
  7241                                  	;;mov	ax,INTERNATIONAL shl 8		; get country dependent info
  7242                                  	int	21h				;
  7243                                  	jc	short NoKabat 			; error - don't bother with it
  7244                                  	cmp	bx,52h
  7245                                  	;cmp	bx,KOREA_COUNTRY_CODE		; are we speaking korean?
  7246                                  	jne	short OpenErr 			; no, don't check for kautoexe
  7247                                  
  7248                                  	;mov	di,BatFile			; 3/3/kk
  7249                                  	mov	di,20h
  7250                                  	;mov	si,offset ResGroup:KautoBat	; another trial to do	3/3/kk
  7251                                  	mov	si,KAUTOBAT
  7252                                  	mov	cx,8				; auto execution for the 3/3/kk
  7253                                  	rep	movsw				; non-english country	3/3/kk
  7254                                  	movsb					; move in carraige return to terminate string
  7255                                  	;mov	dx,offset ResGroup:KautoBat	; 3/3/kk
  7256                                  	mov	dx,KAUTOBAT
  7257                                  	mov	ax,3D00h
  7258                                  	;mov	ax,OPEN<<8
  7259                                  	;;mov	ax,OPEN shl 8			; 3/3/kk
  7260                                  	int	21h				; see if kautoexe.bat exists  3/3/kk
  7261                                  	jc	short NoKabat 			; 3/3/kk
  7262                                  	mov	bx,ax				; 3/3/kk
  7263                                  	mov	ah,3Eh
  7264                                  	;mov	ah,CLOSE			; 3/3/kk
  7265                                  	int	21h				; 3/3/kk
  7266                                  	jmp	short Drv0			; 3/3/kk
  7267                                  
  7268                                  NoKabat:					; 3/3/kk
  7269                                  	call	far [triage_add]		; get extended error
  7270                                  	cmp	ax,65				; network access denied?
  7271                                  	jnz	short OpenErr 			; no - go deallocate batch
  7272                                  
  7273                                  	; 22/07/2024
  7274                                  %endif	; 06/06/2023 - Retro DOS 4.2 COMMAND.COM
  7275                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7276                                  
  7277                                  AccDenErr:					; yes - put out message
  7278                                  	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7279 00001A23 BA[7806]                	mov	dx,ACCDEN
  7280 00001A26 E80DF9                  	call	RPrint
  7281                                  OpenErr:
  7282                                  ;OPENERR:
  7283 00001A29 8E06[E701]              	mov	es,[Batch]		; not found--turn off batch job
  7284 00001A2D B449                    	mov	ah,49h
  7285                                  	;mov	ah,DEALLOC ; 49h
  7286 00001A2F CD21                    	int	21h
  7287 00001A31 C706[E701]0000          	mov	word [Batch],0		; after dealloc in case of ^c
  7288 00001A37 C606[3B02]01            	mov	byte [EchoFlag],1
  7289 00001A3C C706[4C02]0000          	mov	word [Nest],0		; indicate no batch in progress
  7290                                  ;DoDttm:
  7291                                  	;mov	ax,offset TranGroup:Datinit
  7292 00001A42 B8[B133]                	mov	ax,DATINIT
  7293 00001A45 A3[801E]                	mov	[INITADD],ax
  7294                                  
  7295                                  	; MSDOS 6.0
  7296                                  ;;M004;;mov	ax,TrnSeg	
  7297                                  ;
  7298                                  ; M004; We cant use TrnSeg now because it is not initialized. We now that
  7299                                  ; M004; the transient starts on a para boundary at the label TranStart.
  7300                                  ; M004; We use TranStart to get the start of the transient segment.
  7301                                  
  7302                                  	; 21/01/2023
  7303                                  	;mov	ax,offset RESGROUP:TranStart	; M004
  7304                                  	;;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7305                                  	; 06/06/2023
  7306                                  	;mov	ax,26E0h ; MSDOS 6.22 COMMAND.COM
  7307                                  	;
  7308                                  	;mov	ax,TRANSTART
  7309                                  	;mov	cl,4				; M004
  7310                                  	;shr	ax,cl				; get relative seg ; M004
  7311                                  	; 06/06/2023
  7312 00001A48 B85502                  	mov	ax,TRANSTART>>4	
  7313                                  
  7314 00001A4B 8CC9                    	mov	cx,cs
  7315 00001A4D 01C8                    	add	ax,cx				; ax = transient seg ; M004
  7316                                  
  7317                                  	; 21/01/2023
  7318                                  	; MSDOS 3.3
  7319                                  	; 25/09/2018
  7320                                  	;mov     ax,[TrnSeg]	; COMMAND.COM (MSDOS 3.3) - Offset 1387h
  7321                                  
  7322                                  	; MSDOS 3.3 & MSDOS 6.0
  7323 00001A4F A3[821E]                	mov	[INITADD+2],ax
  7324                                  	;call	dword ptr InitAdd
  7325 00001A52 FF1E[801E]              	call	far [INITADD]
  7326                                  
  7327                                  NoDttm:
  7328                                  	; MSDOS 6.0
  7329                                  	; 21/01/2023
  7330                                  ;Copyright:
  7331                                  	;public	Copyright
  7332                                  ;	Bugbug:	remove Copyright label.
  7333                                  
  7334                                  ;if IBMVER
  7335 00001A56 833E[4302]00            	cmp	word [SingleCom],0
  7336 00001A5B 7506                    	jnz	short Drv0			; don't print header if SingleCom
  7337                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7338 00001A5D BA[BF1F]                	mov	dx,COPYRIGHTMSG
  7339 00001A60 E8D3F8                  	call	RPrint
  7340                                  ;endif
  7341                                  	; 21/01/2023
  7342                                  	; MSDOS 3.3
  7343                                  	;cmp	word [SingleCom],0	; don't print header if SingleCom
  7344                                  	;jnz	short DRV0
  7345                                  	;mov	dx,HEADERPTR	; dx = ptr to msg
  7346                                  	;call	RPRINT
  7347                                  ;DRV0:
  7348                                  	; MSDOS 3.3
  7349                                  	;mov	byte [INITFLAG],0
  7350                                  	;jmp	ENDINIT
  7351                                  
  7352                                  	; 21/01/2023
  7353                                  	; MSDOS 6.0
  7354                                  Drv0:						; Reset APPEND state
  7355 00001A63 1E                      	push	ds				; save data segment
  7356 00001A64 0E                      	push	cs				; Get local segment into DS
  7357 00001A65 1F                      	pop	ds				;
  7358 00001A66 B807B7                  	mov	ax,0B707h ; 21/01/2023
  7359                                  	;mov	ax,APPENDSETSTATE		; Set the state of Append
  7360 00001A69 8B1E[6002]              	mov	bx,[Append_State] 		;  back to the original state
  7361 00001A6D CD2F                    	int	2Fh				;
  7362 00001A6F 1F                      	pop	ds				; get data segment back
  7363                                  
  7364                                  ;Check FirstCom set previously to see if this is the first instance of
  7365                                  ;command.com. If not, we do not move command.com. Instead, we copy over the
  7366                                  ;jump table from the previous stub to the current stub.
  7367                                  
  7368 00001A70 803E[1424]01            	cmp	byte [FirstCom],1		; first command.com?
  7369 00001A75 7424                    	jz	short move_code			; yes, move it
  7370                                  
  7371 00001A77 06                      	push	es
  7372 00001A78 1E                      	push	ds
  7373                                  
  7374 00001A79 1E                      	push	ds
  7375 00001A7A 07                      	pop	es
  7376                                  	;mov	di,offset DATARES:Int2f_Entry
  7377 00001A7B BF[0400]                	mov	di,Int2f_Entry	
  7378                                  
  7379                                  	;mov	ds,[es:ResJmpTable+2]		; get segment address
  7380                                  	;mov	si,[es:ResJmpTable]		; get offset address
  7381                                  	; 22/07/2024 - PCDOS 7.1 COMMAND.COM
  7382 00001A7E 26C536[1024]            	lds	si,[es:ResJmpTable]
  7383                                  
  7384                                  	;mov	cx,11
  7385                                  	;;mov 	cx,NUM_RELOC_ENTRIES 		; number of dword ptrs
  7386                                  	;shl	cx,1
  7387                                  	;shl	cx,1				; size of table in bytes
  7388                                  	; 21/01/2023
  7389 00001A83 B92C00                  	mov	cx,44				; size of table in bytes
  7390                                  
  7391 00001A86 FC                      	cld
  7392 00001A87 F3A4                    	rep	movsb				; copy the jump table
  7393                                  
  7394                                  ;Check if the resident code is in HMA. We assume that it is in HMA if its 
  7395                                  ;code segment > 0f000h. If in HMA, we set the ComInHMA flag
  7396                                  
  7397 00001A89 26817DFE00F0            	cmp	word [es:di-2],0F000h		; is resident code in HMA?
  7398 00001A8F 7206                    	jb	short res_low			; no, dont set flag
  7399                                  
  7400 00001A91 26C606[3400]01          	mov	byte [es:ComInHMA],1		; indicate code in HMA
  7401                                  res_low:
  7402 00001A97 1F                      	pop	ds
  7403 00001A98 07                      	pop	es
  7404 00001A99 EB03                    	jmp	short finish_init
  7405                                  
  7406                                  ;Now, we can move the resident code to its final location, either to HIMEM
  7407                                  ;or to overlay the messages in the data segment if the user has not used the
  7408                                  ;/msg switch.
  7409                                  
  7410                                  move_code:
  7411 00001A9B E88D01                  	call	Move_res_code			; move the code
  7412                                  
  7413                                  finish_init:
  7414                                  	;jmp	RESGROUP:EndInit 		; finish initializing
  7415 00001A9E E916E8                  	jmp	EndInit
  7416                                  
  7417                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7418                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1BA8h (CODERES:0E68h)
  7419                                  
  7420                                  GetStrLen:
  7421                                  ;	Get length of string pointed to by DS:SI. Length includes NULL.
  7422                                  ;	Length is returned in CX
  7423                                  
  7424                                  	; MSDOS 3.3 & MSDOS 6.0
  7425 00001AA1 31C9                    	xor	cx,cx
  7426                                  NxtChar:
  7427 00001AA3 AC                      	lodsb
  7428 00001AA4 41                      	inc	cx
  7429 00001AA5 08C0                    	or	al,al
  7430 00001AA7 75FA                    	jnz	short NxtChar
  7431 00001AA9 C3                      	retn
  7432                                  
  7433                                  	; 29/01/2023
  7434                                  Setup_Seg:
  7435                                  
  7436                                  ; If the transient has been loaded in TranSeg, then we need to use that
  7437                                  ; segment for calls to routines in the transient area. Otherwise, the current
  7438                                  ; code segment is used
  7439                                  ; Segment returned in AX.
  7440                                  
  7441                                  	; MSDOS 3.3 & MSDOS 6.0
  7442 00001AAA A1[2D02]                	mov	ax,[TrnSeg]
  7443 00001AAD 803E[2F02]01            	cmp	byte [TrnMvFlg],1	; Has transient portion been moved
  7444 00001AB2 7405                    	je	short setup_end
  7445                                  
  7446                                  ;06/06/2023
  7447                                  %if 0
  7448                                  	push	bx
  7449                                  	mov	bx,cs
  7450                                  	;mov	ax,offset ResGroup:TranStart
  7451                                  	;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7452                                  	; 06/06/2023
  7453                                  	;mov	ax,26E0h ; MSDOS 6.22 COMMAND.COM
  7454                                  	;mov	ax,TRANSTART
  7455                                  	;shr	ax,1
  7456                                  	;shr	ax,1
  7457                                  	;shr	ax,1
  7458                                  	;shr	ax,1
  7459                                  	; 29/01/2023
  7460                                  	mov	ax,TRANSTART>>4
  7461                                  	add	ax,bx
  7462                                  	pop	bx
  7463                                  %endif
  7464                                  	; 06/06/2023
  7465 00001AB4 8CC8                    	mov	ax,cs
  7466 00001AB6 055502                  	add	ax,TRANSTART>>4
  7467                                  
  7468                                  setup_end:
  7469 00001AB9 C3                      	retn
  7470                                  
  7471                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7472                                  ;RPRINT:
  7473                                  	; MSDOS 3.3
  7474                                  	;push	ax
  7475                                  	;call	SETUP_SEG
  7476                                  	;mov	[PRINTADD+2], ax
  7477                                  	;;call	dword ptr PRINTADD
  7478                                  	;call	far [PRINTADD]
  7479                                  	;pop	ax
  7480                                  	;retn
  7481                                  
  7482                                  	; 29/01/2023
  7483                                  	; MSDOS 6.0
  7484                                  ;***	RPrintParse - display parse error message
  7485                                  ;
  7486                                  ;	ENTRY	DX = parse error #
  7487                                  ;
  7488                                  ;	EXIT	nothing
  7489                                  ;
  7490                                  ;	USED	flags
  7491                                  ;
  7492                                  ;	EFFECTS
  7493                                  ;	  Message is displayed on stdout.
  7494                                  
  7495                                  RPrintParse:	;proc
  7496                                  	;assume	ds:ResGroup,ss:ResGroup
  7497                                  
  7498 00001ABA 52                      	push	dx				; preserve DX
  7499 00001ABB 87DA                    	xchg	bx,dx				; bx = parse error #
  7500                                  						; dx = saved BX
  7501 00001ABD 4B                      	dec	bx				; bx = parse error index, from 0
  7502 00001ABE D1E3                    	shl	bx,1				; bx = offset in word table
  7503                                  	;mov	bx,ParsMsgPtrs[bx]		; bx = ptr to error msg
  7504 00001AC0 8B9F[BA09]              	mov	bx,[bx+PARSMSGPTRS]
  7505 00001AC4 87DA                    	xchg	bx,dx				; dx = ptr to error msg
  7506                                  						; bx = restored
  7507 00001AC6 E86DF8                  	call	RPrint				; print the message
  7508 00001AC9 5A                      	pop	dx				; restore DX
  7509 00001ACA C3                      	retn
  7510                                  
  7511                                  ;RPrintParse	endp
  7512                                  
  7513                                  	; 29/01/2023
  7514                                  ;PATHCHRCMPR:
  7515                                  	; MSDOS 3.3
  7516                                  	;push	dx
  7517                                  	;mov	dl,[slash_chr]
  7518                                  	;;cmp	byte [RSWITCHAR],'/'
  7519                                          ;cmp	[RSWITCHAR],dl
  7520                                  	;je	short RNOSLASHT
  7521                                  	;;cmp	al,'/'
  7522                                  	;cmp	al,dl
  7523                                  	;je	short RET41 ; zf = 1 
  7524                                  ;RNOSLASHT:
  7525                                          ;;cmp	al,'\'
  7526                                  	;cmp	al,[bslash_chr]
  7527                                  ;RET41:
  7528                                  	;pop	dx
  7529                                  	;retn
  7530                                  
  7531                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7532                                  IfindE:
  7533                                  	; MSDOS 3.3 & MSDOS 6.0
  7534 00001ACB E80300                  	call	ifind				; find the name
  7535                                  	;jc	short ifind2			; carry means not found
  7536                                  	;jmp	short Iscasb1 			; scan for = sign
  7537                                  	; 29/01/2023
  7538 00001ACE 733A                    	jnc	short Iscasb1
  7539                                  ifind2:
  7540 00001AD0 C3                      	retn
  7541                                  
  7542                                  	; 29/01/2023
  7543                                  
  7544                                  ; on return of find1, es:di points to beginning of name
  7545                                  
  7546                                  ifind:
  7547 00001AD1 FC                      	cld
  7548 00001AD2 E82700                  	call	Icount0				; cx = length of name
  7549 00001AD5 8E06[DC03]              	mov	es,[EnvirSeg]
  7550 00001AD9 31FF                    	xor	di,di
  7551                                  ifind1:
  7552 00001ADB 51                      	push	cx
  7553 00001ADC 56                      	push	si
  7554 00001ADD 57                      	push	di
  7555                                  ifind11:
  7556 00001ADE AC                      	lodsb
  7557 00001ADF E83400                  	call	iupconv
  7558 00001AE2 47                      	inc	di
  7559 00001AE3 263A45FF                	cmp	al,[es:di-1]
  7560 00001AE7 7502                    	jnz	short ifind12
  7561 00001AE9 E2F3                    	loop	ifind11
  7562                                  ifind12:
  7563 00001AEB 5F                      	pop	di
  7564 00001AEC 5E                      	pop	si
  7565 00001AED 59                      	pop	cx
  7566 00001AEE 74E0                    	jz	short ifind2
  7567 00001AF0 51                      	push	cx
  7568 00001AF1 E81A00                  	call	Iscasb2 			; scan for a nul
  7569 00001AF4 59                      	pop	cx
  7570                                  	;cmp	byte [es:di],0
  7571                                  	;jnz	short ifind1
  7572                                  	;stc					; indicate not found
  7573 00001AF5 26803D01                	cmp	byte [es:di],1
  7574 00001AF9 73E0                    	jnb	short ifind1
  7575                                  	; cf=1					; indicate not found
  7576                                  ;ifind2:
  7577 00001AFB C3                      	retn
  7578                                  
  7579                                  	; 29/01/2023
  7580                                  Icount0:
  7581 00001AFC 1E                      	push	ds
  7582 00001AFD 07                      	pop	es
  7583 00001AFE 89F7                    	mov	di,si
  7584                                  
  7585 00001B00 57                      	push	di				; count number of chars until "="
  7586 00001B01 E80600                  	call	Iscasb1
  7587                                  	; 25/09/2018
  7588                                  	;jmp	short Icountx
  7589                                  	;push	di				; count number of chars until nul
  7590                                  	;call	Iscasb2
  7591                                  ;Icountx:
  7592 00001B04 59                      	pop	cx
  7593 00001B05 29CF                    	sub	di,cx
  7594 00001B07 87F9                    	xchg	di,cx
  7595 00001B09 C3                      	retn
  7596                                  
  7597                                  Iscasb1:
  7598                                  	; 29/01/2023
  7599 00001B0A B03D                    	mov	al,"="
  7600                                  	;mov	al,[equalsign] ; [equal_sign]	; scan for an =
  7601 00001B0C EB02                    	jmp	short Iscasbx
  7602                                  Iscasb2:
  7603 00001B0E 30C0                    	xor	al,al				; scan for a nul
  7604                                  Iscasbx:
  7605 00001B10 B90001                  	mov	cx,256 ; 100h
  7606 00001B13 F2AE                    	repnz	scasb
  7607 00001B15 C3                      	retn
  7608                                  
  7609                                  	; 29/01/2023
  7610                                  ;IUPCONV:
  7611                                  	; MSDOS 3.3
  7612                                          ;;cmp	al,"a"
  7613                                  	;cmp	al,[letter_a]
  7614                                          ;jb	short IRET22
  7615                                          ;;cmp	al,"z"
  7616                                          ;cmp	al,[letter_z]
  7617                                  	;ja	short IRET22
  7618                                          ;sub	al,20h			; Lower-case changed to upper-case
  7619                                  ;IRET22:
  7620                                  	;retn
  7621                                  
  7622                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7623                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C32h
  7624                                  
  7625                                  	; MSDOS 6.0
  7626                                  ; *****************************************************************
  7627                                  ; *
  7628                                  ; * ROUTINE:	 IUPCONV    (ADDED BY EMG 4.00)
  7629                                  ; *
  7630                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7631                                  ; *		 the character in AL from the file upper case table
  7632                                  ; *		 in DOS if character if above ascii 128, else
  7633                                  ; *		 subtracts 20H if between "a" and "z".
  7634                                  ; *
  7635                                  ; * INPUT:	 DS	      set to resident
  7636                                  ; *		 AL	      char to be upper cased
  7637                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7638                                  ; *
  7639                                  ; * OUTPUT:	 AL	      upper cased character
  7640                                  ; *
  7641                                  ; *****************************************************************
  7642                                  
  7643                                  iupconv:	;proc	near				
  7644                                  	;assume	ds:ResGroup			;
  7645                                  
  7646 00001B16 3C80                    	cmp	al,80h				; see if char is > ascii 128
  7647 00001B18 7210                    	jb	short other_fucase		; no - upper case math
  7648 00001B1A 2C80                    	sub	al,80h				; only upper 128 chars in table
  7649 00001B1C 1E                      	push	ds				;
  7650 00001B1D 53                      	push	bx				;
  7651                                  	;lds	bx,dword ptr FUCase_Addr+1	; get table address
  7652 00001B1E C51E[5402]              	lds     bx,[FUCase_Addr+1]
  7653 00001B22 83C302                  	add	bx,2				; skip over first word
  7654                                  	;xlat	ds:byte ptr [bx]		; convert to upper case
  7655 00001B25 D7                      	xlat
  7656 00001B26 5B                      	pop	bx				;
  7657 00001B27 1F                      	pop	ds				;
  7658 00001B28 EB0A                    	jmp	short iupconv_end		; we finished - exit
  7659                                  
  7660                                  other_fucase:					;
  7661                                  	;cmp	al,[lcasea] ; [letter_a]	; if between "a" and "z",
  7662 00001B2A 3C61                    	cmp	al,'a'
  7663 00001B2C 7206                    	jb	short iupconv_end		;     subtract 20h to get
  7664                                  	;cmp	al,[lcasez] ; [letter_z]	; upper case equivalent.
  7665 00001B2E 3C7A                    	cmp	al,'z'
  7666 00001B30 7702                    	ja	short iupconv_end		;
  7667 00001B32 2C20                    	sub	al,20h				; Change lower-case to upper
  7668                                  iupconv_end:					;
  7669 00001B34 C3                      	retn
  7670                                  
  7671                                  ;iupConv endp
  7672                                  
  7673                                  	; 29/01/2023
  7674                                  init_contc_specialcase:
  7675                                  	; MSDOS 3.3 & MSDOS 6.0
  7676                                  						; This routine is called if control-C
  7677 00001B35 83C406                  	add	sp,6				;  is type during the date/time prompt
  7678 00001B38 56                      	push	si				;  at initialization time.  The desired
  7679 00001B39 89D6                    	mov	si,dx				;  response is to make it look like the
  7680 00001B3B C74401000D              	mov	word [si+1],0D00h		;  user typed <CR> by "popping" the
  7681 00001B40 5E                      	pop	si				;  INT 21h stuff off the stack, putting
  7682 00001B41 CF                      	iret					;  a <CR> in the user's buffer, and
  7683                                  						;  returning directly to the user.
  7684                                  						; In this case the user is TCODE.
  7685                                  
  7686                                  ; ----------------------------------------------------------------------------
  7687                                  
  7688                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7689                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C62h (CODERES:0F22h)
  7690                                  
  7691                                  	; MSDOS 6.0
  7692                                  ; ****************************************************************
  7693                                  ; *
  7694                                  ; * ROUTINE:	 Setup_for_messages
  7695                                  ; *
  7696                                  ; * FUNCTION:	 Sets up system for PARSE and EXTENDED ERROR
  7697                                  ; *		 messages as follows:
  7698                                  ; *
  7699                                  ; *		 IF /P and /MSG are entered
  7700                                  ; *		    keep PARSE and EXTENDED ERRORS in memory
  7701                                  ; *		 ELSE IF /P is entered
  7702                                  ; *		    use PARSE and EXTENDED ERRORS on disk
  7703                                  ; *		    remove PARSE ERRORS from memory
  7704                                  ; *		 ELSE
  7705                                  ; *		    remove PARSE ERRORS from memory
  7706                                  ; *		 ENDIF
  7707                                  ; *
  7708                                  ; * INPUT:	 PERMCOM	Set up with user input
  7709                                  ; *		 EXT_MSG	Set up with user input
  7710                                  ; *		 System set up to retain PARSE ERRORS
  7711                                  ; *
  7712                                  ; * OUTPUT:	 registers unchanged
  7713                                  ; *
  7714                                  ; ****************************************************************
  7715                                  
  7716                                  setup_for_messages: ;proc near		
  7717                                  
  7718 00001B42 53                      	push	bx
  7719 00001B43 1E                      	push	ds				; save data segment
  7720 00001B44 06                      	push	es				; save environment segment
  7721 00001B45 50                      	push	ax				;
  7722 00001B46 52                      	push	dx				;
  7723 00001B47 57                      	push	di				;
  7724 00001B48 8CC8                    	mov	ax,cs				; get local segment to ES and DS
  7725 00001B4A 8ED8                    	mov	ds,ax				;
  7726 00001B4C 8EC0                    	mov	es,ax				;
  7727                                  
  7728 00001B4E 803E[4002]00            	cmp	byte [PermCom],0		; was permcom set?
  7729 00001B53 743C                    	jz	short no_permcom		; No - don't worry about messages
  7730                                  
  7731                                  ;*	We're permanent. Install our message services int 2f handler.
  7732                                  
  7733 00001B55 06                      	push	es
  7734                                  	;mov	ax,(GET_INTERRUPT_VECTOR shl 8) or 2Fh
  7735 00001B56 B82F35                  	mov	ax,352Fh
  7736 00001B59 CD21                    	int	21h
  7737                                  			; DOS - 2+ - GET INTERRUPT VECTOR
  7738                                  			; AL = interrupt number
  7739                                  			; Return: ES:BX = value of interrupt vector
  7740 00001B5B 891E[5204]              	mov	[Int2fHandler],bx
  7741 00001B5F 8C06[5404]              	mov	[Int2fHandler+2],es
  7742 00001B63 07                      	pop	es
  7743                                  
  7744                                  ;	DS = RESGROUP seg addr
  7745                                  
  7746                                  ; M005; We will not hook int 2fh on any command.com other than the first.
  7747                                  ; M005; Carousel loads as a permanent command.com and when we exit Carousel,
  7748                                  ; M005; it just wipes our arena out. So, int 2fh is still hooked and the
  7749                                  ; M005; first int 2fh call after exit from Carousel (from the DOS terminate
  7750                                  ; M005; call) goes off into space.
  7751                                  
  7752 00001B64 803E[1424]00            	cmp	byte [FirstCom],0		; M005
  7753 00001B69 7416                    	je	short no_msg_hook		; M005
  7754                                  ;
  7755                                  ; M005; !!!SLIMIEST CAROUSEL HACK OFF ALL!!!
  7756                                  ; M005; Carousel plays around with the interrupt vector tables. He saves it
  7757                                  ; M005; before loading a new command.com. Then, it takes hold of the current
  7758                                  ; M005; command.com's PSP and then looks at all interrupt vectors whose
  7759                                  ; M005; segment matches the command.com PSP and then updates these segments
  7760                                  ; M005; to the new command.com's PSP in his saved vector table. Whenever we
  7761                                  ; M005; we pop into his menu, he puts this saved table into the vector table.
  7762                                  ; M005; If we now quit, Carousel just wipes out command.com's arena and then
  7763                                  ; M005; issues a terminate. Unfortunately, the int 2fh vector is pointing at
  7764                                  ; M005; the command.com that was wiped out and so the next int 2fh call will
  7765                                  ; M005; bomb. To prevent Carousel from doing this clever(1**$$#) patching, we
  7766                                  ; M005; renormalize our int 2fh pointer so that its cs is not the same as the
  7767                                  ; M005; command.com PSP. Now, he does no such patching and our int 2fh vector
  7768                                  ; M005; remains nice and happy. The renormalized pointer points at a far 
  7769                                  ; M005; jump to the actual int 2fh entry point.
  7770                                  ;
  7771 00001B6B 1E                      	push	ds				; M005
  7772                                  	;mov	dx,offset DATARES:Carousel_i2f_Hook ; M005
  7773 00001B6C BA[C300]                	mov     dx,Carousel_i2f_Hook
  7774 00001B6F 83EA10                  	sub	dx,10h				; renormalize offset; M005
  7775 00001B72 8CD8                    	mov	ax,ds				; M005
  7776 00001B74 40                      	inc	ax				; Relocated cs ; M005
  7777 00001B75 8ED8                    	mov	ds,ax				; M005
  7778                                  	;mov	ax,(SET_INTERRUPT_VECTOR shl 8) or 2Fh
  7779 00001B77 B82F25                  	mov	ax,252Fh
  7780 00001B7A CD21                    	int	21h
  7781                                  			; DOS - SET INTERRUPT VECTOR
  7782                                  			; AL = interrupt number
  7783                                  			; DS:DX = new vector to be used for specified interrupt
  7784 00001B7C 1F                      	pop	ds				; M005
  7785                                  	;mov	word ptr Carousel_i2f_Hook+3,ds	; M005
  7786 00001B7D 8C1E[C600]              	mov	[Carousel_i2f_Hook+3],ds
  7787                                  						; patch in the cs for jump
  7788                                  no_msg_hook:					; M005
  7789 00001B81 803E[D91E]01            	cmp	byte [ext_msg],1 ; SET_EXTENDED_MSG
  7790 00001B86 7516                    	jne	short permcom_end		; no /msg - exit
  7791                                  
  7792                                  permcom_slash_msg:				; Keep messages in memory
  7793                                  	;mov	di,offset ResGroup:ExtMsgEnd 	; get address of resident end
  7794 00001B88 BF[B30C]                	mov     di,ExtMsgEnd
  7795 00001B8B 893E[5604]              	mov	[ResMsgEnd],di			; save it
  7796 00001B8F EB0D                    	jmp	short permcom_end		; exit
  7797                                  
  7798                                  no_permcom:					
  7799                                  	;cmp	byte [ext_msg],SET_EXTENDED_MSG	; was /msg specified?
  7800 00001B91 803E[D91E]01            	cmp	byte [ext_msg],1
  7801 00001B96 7506                    	jne	short permcom_end		; no - no error
  7802                                  	;mov	dx,LessArgs_Ptr			; get message number for "Required parameter missing"
  7803 00001B98 BA0200                  	mov	dx,2
  7804 00001B9B E81CFF                  	call	RPrintParse
  7805                                  
  7806                                  permcom_end:
  7807 00001B9E 5F                      	pop	di				;
  7808 00001B9F 5A                      	pop	dx				;
  7809 00001BA0 58                      	pop	ax				;
  7810 00001BA1 07                      	pop	es				; get environment back
  7811 00001BA2 1F                      	pop	ds				;
  7812 00001BA3 5B                      	pop	bx
  7813                                  
  7814 00001BA4 C3                      	retn					;
  7815                                  
  7816                                  ;setup_for_messages	endp
  7817                                  
  7818                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7819                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1CC5h
  7820                                  
  7821                                  	; MSDOS 6.0
  7822                                  
  7823                                  ;***	CheckHelp - print help text and exit if /? is on command line
  7824                                  ;
  7825                                  ;	ENTRY	command-line tail at 81h
  7826                                  ;
  7827                                  ;	EXIT	return if /? not found
  7828                                  ;		terminate if /? found
  7829                                  ;
  7830                                  ;	USED	AX,BX,CX,DX,SI,DI
  7831                                  ;
  7832                                  ;	EFFECTS	Help text displayed if /? found on command line
  7833                                  
  7834                                  CheckHelp:	; proc
  7835                                  	;assume	cs:RESGROUP,ds:RESGROUP,es:RESGROUP,ss:RESGROUP
  7836                                  
  7837 00001BA5 BE8100                  	mov	si,81h			; DS:SI = ptr to command-line tail
  7838                                  	;mov	di,offset RESGROUP:Parse_Command
  7839 00001BA8 BF[DE1E]                	mov	di,PARSE_COMMAND
  7840                                  					; ES:DI = ptr to primary parse block
  7841 00001BAB 31C9                    	xor	cx,cx			; CX = # positional param's found
  7842 00001BAD 31D2                    	xor	dx,dx			; DX will be ptr to result buffer
  7843                                  chParse:
  7844                                  	;call	dword ptr Init_Parse
  7845 00001BAF FF1E[D21E]              	call	far [Init_Parse]	; call system parser
  7846                                  
  7847                                  	;;cmp	ax,END_OF_LINE
  7848                                  	;cmp	ax,-1 ; 0FFFFh	
  7849                                  	;je	short chRet		; end of command line, no /? found
  7850                                  	;;cmp	ax,RESULT_NO_ERROR
  7851                                  	;;cmp	ax,0
  7852                                  	;;je	short chWhich		; valid syntax element found
  7853                                  	;;jmp	short chParse		; go parse more
  7854                                  	;and	ax,ax ; cmp ax,0
  7855                                  	;jnz	short chParse ; jne
  7856                                  	; 10/06/2023
  7857 00001BB3 40                      	inc	ax	; cmp ax,-1
  7858 00001BB4 741B                    	jz	short chRet   ; 0FFFFh -> 0
  7859 00001BB6 48                      	dec	ax	; cmp ax,0
  7860 00001BB7 75F6                    	jnz	short chParse ; 1 -> 0
  7861                                  	; ax = 0
  7862                                  chWhich:
  7863                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_?_Syn
  7864 00001BB9 813E[811F][641F]        	cmp     word [COMND1_SYN],COMMAND_?_SYN ; "/?"
  7865 00001BBF 7411                    	je	short chHelp		; /? found - display help & exit
  7866                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_C_Syn
  7867 00001BC1 813E[811F][4A1F]        	cmp     word [COMND1_SYN],COMMAND_C_SYN ; "/C"
  7868                                  	; 06/06/2023
  7869 00001BC7 7408                    	je	short chRet		; /c found - ignore rest of line
  7870                                  	; 29/01/2023
  7871                                  	;jne	short chParse
  7872                                  	; 06/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  7873                                  	; MSDOS 6.0
  7874                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_K_Syn
  7875 00001BC9 813E[811F][701F]        	cmp	word [COMND1_SYN],COMMAND_K_SYN ; "/K"
  7876                                  	;je	short chRet		; /k found - ignore rest of line
  7877                                  	;jmp	short chParse		; anything else - ignore, keep looking
  7878                                  	; 06/06/2023
  7879 00001BCF 75DE                    	jne	short chParse
  7880                                  chRet:
  7881 00001BD1 C3                      	retn
  7882                                  chHelp:
  7883                                  	;mov	si,offset RESGROUP:HelpMsgs	; SI = ptr to msg ptr list
  7884 00001BD2 BE[DE23]                	mov	si,HelpMsgs
  7885                                  chHelpNext:
  7886 00001BD5 AD                      	lodsw					; AX = ptr to msg
  7887 00001BD6 09C0                    	or	ax,ax
  7888 00001BD8 7407                    	jz	short chHelpDone		; end of list - all done
  7889 00001BDA 89C2                    	mov	dx,ax				; DX = ptr to msg
  7890 00001BDC E857F7                  	call	RPrint				; display msg
  7891 00001BDF EBF4                    	jmp	short chHelpNext		; go do next msg
  7892                                  
  7893                                  chHelpDone:
  7894 00001BE1 CD20                    	int	20h				; terminate program
  7895                                  ;chRet:
  7896 00001BE3 C3                      	retn
  7897                                  
  7898                                  ;CheckHelp	endp
  7899                                  
  7900                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7901                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D03h
  7902                                  
  7903                                  	; MSDOS 6.0
  7904                                  
  7905                                  ;***** Setup_res_end -- This routine determines the resident size of COMMAND.
  7906                                  ;
  7907                                  ; It determines based on 2 factors:
  7908                                  ;	1. Is this is the first COMMAND?
  7909                                  ;	2. Is COMMAND to be loaded into HIMEM?
  7910                                  ;   The strategy works as follows:
  7911                                  ;
  7912                                  ;	if (First COMMAND)
  7913                                  ;	then if (COMMAND in HIMEM)
  7914                                  ;		ResSize = resident_data;
  7915                                  ;	     else
  7916                                  ;		ResSize = resident_data + resident_code;
  7917                                  ;	else
  7918                                  ;	   ResSize = resident_data;
  7919                                  ;
  7920                                  ; Int 2fh calls have been added to determine whether or not we are the first
  7921                                  ; COMMAND and whether DOS is in HIMEM.
  7922                                  ;
  7923                                  ;	ENTRY: ResMsgEnd = resident size of data in paras
  7924                                  ;
  7925                                  ;	EXIT:  ResSize = resident size in low memory
  7926                                  ;
  7927                                  ;	REGISTERS AFFECTED: ax,cx,dx
  7928                                  ;
  7929                                  
  7930                                  GET_HMA_ADDR	equ	4A02h
  7931                                  
  7932                                  Setup_res_end:	;proc near
  7933                                  	
  7934 00001BE4 1E                      	push	ds
  7935 00001BE5 8CC8                    	mov	ax,cs
  7936 00001BE7 8ED8                    	mov	ds,ax				;ds = RESGROUP
  7937                                  	;assume	ds:RESGROUP
  7938                                  
  7939 00001BE9 8B0E[5604]              	mov	cx,[ResMsgEnd]			;set resident size = data
  7940                                  
  7941                                  ;ifndef	ROMDOS
  7942                                  
  7943                                  ;M042 -- Begin changes
  7944                                  ;If messages are to be kept behind, we need to round up the messages to
  7945                                  ;the next para boundary. This is because we have a dummy segment between the
  7946                                  ;data and the resident code segment so that the code segment starts on a
  7947                                  ;para boundary
  7948                                  
  7949                                  	;cmp	cx,offset RESGROUP:ExtMsgEnd	;messages to be resident?
  7950 00001BED 81F9[B30C]              	cmp	cx,ExtMsgEnd
  7951 00001BF1 7506                    	jne	short calc_res			;no, continue
  7952 00001BF3 83C10F                  	add	cx,15				;round up
  7953 00001BF6 83E1F0                  	and	cx,0FFF0h
  7954                                  calc_res:
  7955                                  
  7956                                  ;M042 -- End changes
  7957                                  
  7958                                  	; 18/07/2024
  7959                                  	;xor	ax,ax
  7960                                         	
  7961 00001BF9 803E[1424]01            	cmp	byte [FirstCom],1		;is it first command.com?
  7962                                  	;jne	short not_first			;no, do not keep code
  7963                                  	; 06/06/2023
  7964 00001BFE 751A                    	jne	short not_first2
  7965                                  
  7966                                  ;We issue a version check call with al=01 to detect if DOS is in HMA. If so,
  7967                                  ;bit 4 of dh is set
  7968                                  
  7969 00001C00 53                      	push	bx
  7970 00001C01 51                      	push	cx
  7971                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ;is DOS in HIMEM? ;M013
  7972 00001C02 B80633                  	mov	ax,3306h
  7973 00001C05 CD21                    	int	21h
  7974                                  		; DOS - 5+ Get TRUE Version Number
  7975                                  		; (BL major, BH minor, DL revision, DH flags)
  7976 00001C07 59                      	pop	cx
  7977                                  
  7978                                  ;bugbug: remove version check after testing
  7979                                  
  7980 00001C08 80FB05                  	cmp	bl,5				;bl has true version ; M013
  7981 00001C0B 7207                    	jb	short oldver
  7982                                  
  7983 00001C0D 31C0                    	xor	ax,ax
  7984 00001C0F 80E610                  	and	dh,10h				;is DOS in HMA ; M013
  7985                                  	;pop	bx
  7986                                  	;jnz	short not_first			;DOS in HIMEM, code not
  7987                                  						;	resident
  7988                                  	; 29/01/2023
  7989 00001C12 7503                    	jnz	short not_first_pop
  7990                                  oldver:
  7991                                  	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  7992                                  	; 06/06/2023
  7993                                  	;;mov	ax,81Ah ; MSDOS 5.0 and MSDOS 6.22 COMMAND.COM
  7994                                  	; 06/06/2023
  7995                                  	; 29/01/2023
  7996                                  	;mov	ax,EndCode-(RCODE_START+100h) ; 23/04/2023
  7997                                  	; 03/05/2023
  7998 00001C14 B8(FA08)                	mov	ax,EndCode-RCODE_START	; 06/06/2023
  7999                                  
  8000                                  not_first_pop:
  8001                                  	; 29/01/2023
  8002 00001C17 5B                      	pop	bx
  8003                                  
  8004                                  not_first:
  8005                                  
  8006                                  ;Note that ax = 0 (side effect of int 2fh), if the code is not to be retained
  8007                                  
  8008 00001C18 01C1                    	add	cx,ax
  8009                                  
  8010                                  not_first2:	; 06/06/2023
  8011                                  
  8012                                  ;endif	;not ROMDOS
  8013                                  
  8014 00001C1A 83C10F                  	add	cx,15				;round up to next para
  8015 00001C1D D1E9                    	shr	cx,1
  8016 00001C1F D1E9                    	shr	cx,1
  8017 00001C21 D1E9                    	shr	cx,1
  8018 00001C23 D1E9                    	shr	cx,1				;ax = para size of res code
  8019 00001C25 890E[5804]              	mov	[ResSize],cx			;store resident size
  8020                                  
  8021 00001C29 1F                      	pop	ds
  8022                                  	;assume	ds:nothing
  8023 00001C2A C3                      	retn
  8024                                  
  8025                                  ;ifndef	ROMDOS
  8026                                  
  8027                                  ;bugbug: remove this code (for version independent COMMAND) after testing
  8028                                  
  8029                                  	; 29/01/2023
  8030                                  ;oldver:
  8031                                  ;	pop	bx
  8032                                  ;	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8033                                  ;	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8034                                  ;	; 29/01/2023
  8035                                  ;	mov	ax,EndCode-RCODE_START
  8036                                  ;	jmp	short not_first
  8037                                  
  8038                                  ;endif	;not ROMDOS
  8039                                  
  8040                                  ;setup_res_end	endp
  8041                                  
  8042                                  ;ifndef	ROMDOS
  8043                                  
  8044                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8045                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8046                                  
  8047                                  	; MSDOS 6.0
  8048                                  ;*** Move_res_code -- This routine moves the resident code to its final 
  8049                                  ; location. We check if DOS is in HIMEM. If so, we try to load ourselves
  8050                                  ; in HIMEM. If we fail, then we remain low and update ResSize to reflect
  8051                                  ; the correct resident size. When remaining low, we have to check if we 
  8052                                  ; need to overlay the messages part of the data segment which is determined
  8053                                  ; by the /msg switch.
  8054                                  ;
  8055                                  ;	ENTRY: ResMsgEnd = end of resident data
  8056                                  ;
  8057                                  ;	EXIT:  The resident code is either up high or in its final location
  8058                                  ;		down low.
  8059                                  ;
  8060                                  ;	REGISTERS AFFECTED: ax,bx,cx,dx,si,di
  8061                                  	
  8062                                  Move_res_code:	;proc near
  8063                                  
  8064 00001C2B 1E                      	push	ds
  8065 00001C2C 06                      	push	es
  8066                                  
  8067 00001C2D 8CC8                    	mov	ax,cs
  8068 00001C2F 8ED8                    	mov	ds,ax
  8069                                  	;assume	ds:RESGROUP
  8070                                  
  8071                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ; M013
  8072 00001C31 B80633                  	mov	ax,3306h
  8073 00001C34 CD21                    	int	21h				;DOS in HIMEM?
  8074                                  		; DOS - 5+ Get TRUE Version Number
  8075                                  		; (BL major, BH minor, DL revision, DH flags)
  8076                                  
  8077 00001C36 80E610                  	and	dh,10h				; M013
  8078 00001C39 750E                    	jnz	short move_high			;yes, move code high
  8079                                  
  8080                                  ;Check if messages have been discarded or not
  8081                                  
  8082                                  load_low:
  8083 00001C3B 1E                      	push	ds
  8084 00001C3C 07                      	pop	es				;es = RESGROUP
  8085 00001C3D 8B3E[5604]              	mov	di,[ResMsgEnd]			;end offset in DATARES
  8086                                  	;;mov	bx,offset RESGROUP:ExtMsgEnd	;end offset of messages
  8087                                  	;mov	bx,ExtMsgEnd
  8088                                  	; 29/01/2023
  8089 00001C41 81FF[B30C]              	cmp	di,ExtMsgEnd
  8090                                  	;cmp	di,bx				;are messages to be kept?
  8091 00001C45 7431                    	je	short no_move			;yes, dont move code
  8092                                  
  8093 00001C47 EB37                    	jmp	short setup_move		;es:di points at dest.
  8094                                  
  8095                                  move_high:
  8096                                  
  8097                                  ;We have to call DOS to get the load address in HIMEM for COMMAND
  8098                                  ;We pass in bx the number of bytes we need
  8099                                  
  8100                                  	;mov	bx,offset CODERES:EndCode
  8101                                  	; 29/01/2023
  8102                                  	;;mov	bx,81Ah ; MSDOS 5.0 & MSDOS 6.22 COMMAND.COM
  8103                                  	; 06/06/2023
  8104                                  	;mov	bx,EndCode-(RCODE_START+100h) ; 23/04/2023 ; 06/06/2023
  8105                                  	; 03/05/2023
  8106 00001C49 BB(FA08)                	mov	bx,EndCode-RCODE_START ; 06/06/2023
  8107                                  
  8108                                  ;M030;
  8109                                  ; Set di=0ffffh so that we load low in case no one answers this int 2fh
  8110                                  
  8111 00001C4C BFFFFF                  	mov	di,0FFFFh			;DT - in case no-one handles
  8112                                  						;this ; M030
  8113 00001C4F B8024A                  	mov	ax,GET_HMA_ADDR ; 4A02h
  8114 00001C52 CD2F                    	int	2Fh
  8115                                  
  8116                                  ;If the offset = 0xffff, then no HMA available
  8117                                  
  8118 00001C54 83FFFF                  	cmp	di,0FFFFh			;HMA available?
  8119 00001C57 C606[3400]01            	mov	byte [ComInHMA],1		;assume command.com in HMA
  8120 00001C5C 7522                    	jne	short setup_move		;no error, es:di = memory
  8121                                  
  8122                                  	;mov	byte [ComInHMA],0		;could not load in HMA
  8123                                  	; 29/01/2023	
  8124 00001C5E FE0E[3400]              	dec	byte [ComInHMA] ; 1 -> 0
  8125                                  
  8126                                  ;Zero means that we do not have enough HIMEM. Remain low and update
  8127                                  ;ResSize to reflect this
  8128                                  
  8129 00001C62 8B0E[5604]              	mov	cx,[ResMsgEnd]			;size of data in bytes
  8130                                  	;;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8131                                  	;;mov	ax,81Ah ; MSDOS 5.0 & MSDOS 6.22 COMMAND.COM
  8132                                  	;mov	ax,EndCode-RCODE_START
  8133                                  	;add	cx,ax
  8134                                  	; 06/06/2023
  8135                                  	; 29/01/2023
  8136                                  	;add	cx,(EndCode-(RCODE_START+100h))+15 ; 23/04/2023 ; 06/06/2023
  8137                                  	;add	cx,15				;round up to next para
  8138                                  	; 03/05/2023
  8139 00001C66 81C1(0909)              	add	cx,(EndCode-RCODE_START)+15 ; 06/06/2023
  8140 00001C6A D1E9                    	shr	cx,1
  8141 00001C6C D1E9                    	shr	cx,1
  8142 00001C6E D1E9                    	shr	cx,1
  8143 00001C70 D1E9                    	shr	cx,1				;ax = para size of res code
  8144 00001C72 890E[5804]              	mov	[ResSize],cx			;store resident size
  8145 00001C76 EBC3                    	jmp	short load_low			;let code remain low
  8146                                  
  8147                                  no_move:
  8148                                  	; 05/05/2023
  8149                                  	;mov	cl,4
  8150 00001C78 83C70F                  	add	di,0Fh
  8151 00001C7B 83E7F0                  	and	di,0FFF0h			;round it to a para offset
  8152 00001C7E EB0B                    	jmp	short patch_up
  8153                                  
  8154                                  setup_move:
  8155                                  	;mov	si,offset RESGROUP:StartCode
  8156                                  	; 03/05/2023
  8157 00001C80 BE[C00C]                	mov	si,RCODE_START  ; Start addr of Resident Code (CODERES segment)
  8158                                  				; 0D40h for MSDOS 5.0 COMMAND.COM
  8159                                  	;mov	cx,offset CODERES:EndCode	;cx = bytes to move
  8160                                  	;mov	cx,81Ah ; MSDOS 5.0 & MSDOS 6.22 COMMAND.COM
  8161                                  	; 06/06/2023
  8162                                  	;mov	cx,EndCode-(RCODE_START+100h) ; 23/04/2023
  8163                                  	; 03/05/2023
  8164 00001C83 B9(FA08)                	mov	cx,EndCode-RCODE_START	; 06/06/2023
  8165                                  
  8166 00001C86 FC                      	cld
  8167 00001C87 57                      	push	di				;need di for patching offset
  8168 00001C88 F3A4                    	rep	movsb
  8169 00001C8A 5F                      	pop	di
  8170                                  
  8171                                  patch_up:
  8172 00001C8B E86D01                  	call	patch_stub
  8173 00001C8E 07                      	pop	es
  8174 00001C8F 1F                      	pop	ds
  8175                                  	;assume	ds:nothing
  8176 00001C90 C3                      	retn
  8177                                  
  8178                                  ;Move_res_code endp
  8179                                  
  8180                                  ;else	;ROMDOS
  8181                                  ;
  8182                                  ;;***	Move_res_code - ROMDOS version - locate ROM resident
  8183                                  ;
  8184                                  ;Move_res_code	proc
  8185                                  ;
  8186                                  ;	push	es
  8187                                  ;
  8188                                  ;	invoke	FindROMRes		; ES:DI = ptr to ROM resident code
  8189                                  ;	call	patch_stub
  8190                                  ;
  8191                                  ;	pop	es
  8192                                  ;	ret
  8193                                  ;
  8194                                  ;Move_res_code	endp
  8195                                  ;
  8196                                  ;	assume	ds:NOTHING		; to match ending assume above
  8197                                  ;
  8198                                  ;endif	;ROMDOS
  8199                                  
  8200                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8201                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8202                                  
  8203                                  	; MSDOS 6.0
  8204                                  ;*** Alloc_env -- This routine allocates the temporary environment for the
  8205                                  ; Init code to initialize the COMSPEC. This is not a complete environment. 
  8206                                  ; Later on, at EndInit time, a proper sized environment is allocated and
  8207                                  ; the contents of this temporary environment are copied to it. This routine
  8208                                  ; will not be called in case a valid environment is passed to command.com
  8209                                  ;
  8210                                  ;       ENTRY:  FirstCom and initial EnvirSeg set
  8211                                  ;
  8212                                  ;       EXIT:   ax = EnvirSeg = segment of newly allocated environment segment
  8213                                  ;
  8214                                  ;       REGISTERS AFFECTED: ax,bx,cx,dx
  8215                                  
  8216                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8217                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1F3Fh
  8218                                  
  8219                                  alloc_env:	;proc near
  8220                                  	;assume ds:nothing
  8221                                  	
  8222 00001C91 1E                              push    ds
  8223 00001C92 06                      	push	es
  8224 00001C93 56                      	push	si
  8225 00001C94 57                      	push	di
  8226                                  
  8227                                  ; 07/06/2023
  8228                                  ; 29/01/2023 - MSDOS 6.0 COMMAND.COM
  8229                                  ;%if 0
  8230                                  %if 1 
  8231 00001C95 16                              push    ss
  8232 00001C96 1F                              pop     ds
  8233                                  	;assume ds:RESGROUP
  8234                                  
  8235 00001C97 A1[DC03]                        mov     ax,[EnvirSeg]
  8236                                  
  8237 00001C9A 803E[8C1E]00                    cmp	byte [AllocedEnv],0
  8238 00001C9F 7403                            je	short alloc_cont
  8239 00001CA1 E94C01                          jmp     alloc_done
  8240                                  
  8241                                  alloc_cont:
  8242 00001CA4 29FF                            sub     di,di                           ; default start
  8243                                          ;mov	bx,SIZE Environment             ; default size needed
  8244                                  	; 29/01/2023
  8245 00001CA6 BBB400                  	mov	bx,ENVIRONSIZ	; mov bx,180 ; 07/06/2023
  8246                                  
  8247 00001CA9 803E[1424]00                    cmp	byte [FirstCom],0		; first COMMAND.COM?
  8248 00001CAE 747E                            je	short alloc_seg			; no
  8249                                  
  8250                                  ;   Check EnvirSeg; if non-zero, then scan it for PATH and COMSPEC;
  8251                                  ;   Record their respective locations and do not add the default vars.
  8252                                  
  8253 00001CB0 09C0                    	or      ax,ax
  8254 00001CB2 7476                    	jz	short alloc_new			; no previous environment
  8255                                  
  8256 00001CB4 8EC0                            mov     es,ax
  8257                                  	;assume es:nothing
  8258                                  
  8259                                  _find_path:
  8260 00001CB6 B000                            mov     al,0
  8261 00001CB8 29FF                            sub     di,di
  8262                                  comp_path:
  8263 00001CBA AE                              scasb                                   ; end of env?
  8264 00001CBB 7417                    	je	short _find_prompt		; yes
  8265 00001CBD 4F                              dec     di
  8266 00001CBE B90500                          mov     cx,PathStrLen ; mov cx,5 ; "PATH="
  8267                                          ;mov	si,offset RESGROUP:PathString
  8268 00001CC1 BE[8D1E]                	mov	si,PathString	; "PATH="
  8269 00001CC4 F3A6                            repe    cmpsb
  8270 00001CC6 7407                            je	short got_path
  8271 00001CC8 B90001                          mov	cx,256
  8272 00001CCB F2AE                            repne   scasb                           ; find next NULL
  8273 00001CCD EBEB                            jmp     short comp_path
  8274                                  
  8275                                  got_path:
  8276 00001CCF C606[8D1E]00                    mov	byte [PathString],0		; don't add it
  8277                                  
  8278                                  _find_prompt:
  8279 00001CD4 29FF                            sub     di,di
  8280                                  comp_prompt:
  8281 00001CD6 AE                      	scasb                                   ; end of env?
  8282 00001CD7 7417                    	je	short find_comspec		; yes
  8283 00001CD9 4F                      	dec     di
  8284 00001CDA B90700                  	mov     cx,PrmptStrLen2	; mov cx,7
  8285                                  	;mov	si,offset RESGROUP:PrmptString
  8286 00001CDD BE[A31E]                	mov	si,PrmptString	; "PROMPT=$P$G"   
  8287 00001CE0 F3A6                            repe    cmpsb
  8288 00001CE2 7407                            je	short got_prompt
  8289 00001CE4 B90001                          mov     cx,256
  8290 00001CE7 F2AE                            repne   scasb                           ; find next NULL
  8291 00001CE9 EBEB                            jmp	short comp_prompt
  8292                                  
  8293                                  got_prompt:
  8294 00001CEB C606[A31E]00            	mov	byte [PrmptString],0		; don't add it
  8295                                  
  8296                                  find_comspec:
  8297 00001CF0 29FF                            sub     di,di
  8298                                  comp_comspec:
  8299 00001CF2 AE                              scasb                                   ; end of env?
  8300 00001CF3 7423                            je	short got_envend		; yes
  8301 00001CF5 4F                              dec     di
  8302 00001CF6 B90800                          mov	cx,ComspStrLen	; mov cx,8
  8303                                  	;mov	si,offset RESGROUP:ComspString
  8304 00001CF9 BE[B11E]                	mov	si,ComspString	; "COMSPEC=\COMMAND.COM"
  8305 00001CFC F3A6                            repe    cmpsb
  8306 00001CFE 7407                            je	short got_comspec
  8307 00001D00 B90001                          mov     cx,256
  8308 00001D03 F2AE                            repne   scasb                           ; find next NULL
  8309 00001D05 EBEB                            jmp	short comp_comspec
  8310                                  
  8311                                  got_comspec:
  8312 00001D07 893E[AF1E]                      mov     [ComspOffset],di
  8313                                  
  8314                                  find_envend:
  8315 00001D0B 29FF                            sub     di,di
  8316 00001D0D B90080                          mov     cx,ENVBIG	; 32768		; max env size
  8317                                  comp_envend:
  8318 00001D10 49                              dec     cx                              ;
  8319 00001D11 AE                              scasb                                   ; end of env?
  8320 00001D12 7404                            je	short got_envend		; yes
  8321 00001D14 F2AE                            repne   scasb
  8322 00001D16 EBF8                            jmp	short comp_envend
  8323                                  
  8324                                  got_envend:
  8325 00001D18 4F                              dec     di
  8326                                  	; 07/06/2023
  8327 00001D19 8D9DB400                	lea     bx,[di+ENVIRONSIZ]		; add room for the basics
  8328                                  
  8329                                  ;   We want to fall through to alloc_new and set up default
  8330                                  ;   path and prompt ONLY IF this is the first process;  in all other
  8331                                  ;   cases, we assume it is a bad idea to try editing the user's environment
  8332                                  
  8333 00001D1D 1E                              push    ds
  8334                                          ;mov	ds,ds:[PDB_Parent_Pid]
  8335 00001D1E 8E1E1600                        mov	ds,[PDB.PARENT_PID]
  8336                                  	;cmp	ds:[PDB_Parent_Pid],0           ; is parent's parent pid field 0?
  8337 00001D22 833E160000              	cmp	word [PDB.PARENT_PID],0
  8338 00001D27 1F                      	pop     ds
  8339 00001D28 7504                            jne	short alloc_seg			; no, we're not the first process
  8340                                                                                  ; so don't muck with the env.
  8341                                  alloc_new:
  8342 00001D2A FE06[8C1E]              	inc	byte [AllocedEnv]		; note we have virgin env.
  8343                                  
  8344                                  alloc_seg:
  8345                                  
  8346                                  ; Allocate default environment size
  8347                                  
  8348 00001D2E 89D9                            mov     cx,bx                           ; save byte-granular size in CX
  8349 00001D30 83C30F                          add     bx,15
  8350 00001D33 D1EB                            shr     bx,1
  8351 00001D35 D1EB                            shr     bx,1
  8352 00001D37 D1EB                            shr     bx,1
  8353 00001D39 D1EB                            shr     bx,1                            ; BX = # paras
  8354 00001D3B B448                    	mov	ah,ALLOC ; 48h
  8355 00001D3D CD21                    	int	21h
  8356 00001D3F 7303                            jnc	short init_ok
  8357 00001D41 E9B100                          jmp     init_nomem                      ; insufficient memory, error
  8358                                  
  8359                                  ; If a previous environment existed (ie, DI != 0), then copy it into
  8360                                  ; the new buffer
  8361                                  
  8362                                  init_ok:
  8363 00001D44 8EC0                    	mov	es,ax
  8364                                  	;assume	es:nothing                      ; es = temp env segment
  8365                                  
  8366 00001D46 09FF                    	or      di,di
  8367 00001D48 7412                            jz	short copy_path
  8368                                  
  8369 00001D4A 51                              push    cx
  8370 00001D4B 1E                              push    ds
  8371 00001D4C 8E1E[DC03]                      mov     ds,[EnvirSeg]
  8372                                          ;assume ds:nothing
  8373 00001D50 29F6                            sub     si,si
  8374 00001D52 89F9                            mov     cx,di
  8375 00001D54 29FF                            sub     di,di
  8376 00001D56 F3A4                            rep     movsb
  8377 00001D58 1F                              pop     ds
  8378                                          ;assume ds:RESGROUP
  8379 00001D59 59                              pop     cx
  8380 00001D5A 29F9                            sub     cx,di
  8381                                  
  8382                                  copy_path:
  8383                                  
  8384                                  ; First clear out (the rest of) the buffer
  8385                                  
  8386 00001D5C 57                              push    di
  8387 00001D5D 29C0                            sub     ax,ax
  8388 00001D5F F3AA                            rep     stosb
  8389 00001D61 5F                              pop     di
  8390                                  
  8391                                  ; Initialize the path string (PATH=) first
  8392                                  
  8393                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8394 00001D62 BE[8D1E]                	mov	si,PathString
  8395 00001D65 3804                            cmp     byte [si],al			; add it?
  8396 00001D67 7450                            je	short init_prompt		; no
  8397                                  	;mov	cx,PathStrLen+1                 ;
  8398 00001D69 B90600                  	mov	cx,6 ; db "PATH=",0
  8399 00001D6C F3A4                            rep     movsb                           ;
  8400 00001D6E 3806[8C1E]                      cmp     [AllocedEnv],al			; virgin env?
  8401 00001D72 7445                            je	short init_prompt		; no
  8402                                  
  8403                                  ; Establish a more reasonable default for the PATH
  8404                                  
  8405                                  	;mov	ah,GET_DEFAULT_DRIVE
  8406 00001D74 B419                    	mov	ah,19h
  8407 00001D76 CD21                    	int	21h
  8408 00001D78 0441                            add     al,'A'                          ; convert to letter
  8409 00001D7A A2[931E]                        mov     [DefPathString],al              ;
  8410 00001D7D A2[9C1E]                        mov     [DefPath2String],al             ; now our default paths are complete
  8411                                  
  8412 00001D80 B200                            mov     dl,0                            ; get dir for default drive
  8413 00001D82 1E                              push    ds                              ;
  8414 00001D83 06                              push    es                              ;
  8415 00001D84 1F                              pop     ds                              ;
  8416 00001D85 C6055C                          mov     byte [di],'\'			;
  8417 00001D88 8D7501                          lea     si,[di+1]                       ; set DS:SI -> available space
  8418                                  	;mov	ah,Current_Dir                  ;
  8419 00001D8B B447                            mov	ah,47h
  8420 00001D8D CD21                    	int     21h                             ;
  8421 00001D8F 1F                              pop     ds                              ;
  8422                                  
  8423                                  	;mov	cx,DefPathStrLen+1              ;
  8424 00001D90 B90900                  	mov	cx,9 ; db "C:\MSDOS",0
  8425                                  	;mov	dx,offset RESGROUP:DefPathString
  8426 00001D93 BA[931E]                	mov	dx,DefPathString	; "C:\MSDOS"
  8427 00001D96 89D6                    	mov	si,dx                           ;
  8428                                          ;mov	ah,CHDir                        ;
  8429 00001D98 B43B                            mov	ah,3Bh
  8430 00001D9A CD21                    	int     21h                             ;
  8431 00001D9C 730E                            jnc	short init_setpath		; DefPathString exists!
  8432                                  
  8433                                  	;mov	cx,DefPath2StrLen+1		;
  8434 00001D9E B90700                          mov	cx,7 ; db "C:\DOS",0
  8435                                  	;mov	dx,offset RESGROUP:DefPath2String
  8436 00001DA1 BA[9C1E]                	mov	dx,DefPath2String	; "C:\DOS"
  8437 00001DA4 89D6                            mov     si,dx                           ;
  8438                                          ;mov	ah,CHDir                        ;
  8439 00001DA6 B43B                            mov	ah,3Bh
  8440 00001DA8 CD21                            int     21h                             ;
  8441 00001DAA 720D                            jc	short init_prompt		; DefPath2String doesn't exist
  8442                                  
  8443                                  init_setpath:
  8444 00001DAC 89FA                            mov     dx,di                           ; success
  8445 00001DAE 1E                              push    ds                              ; so restore prev dir
  8446 00001DAF 06                              push    es                              ;
  8447 00001DB0 1F                              pop     ds                              ; DS:DX -> prev dir
  8448                                          ;mov	ah,CHDir                        ;
  8449 00001DB1 B43B                            mov	ah,3Bh			
  8450 00001DB3 CD21                            int     21h                             ;
  8451 00001DB5 1F                              pop     ds                              ;
  8452                                  
  8453 00001DB6 4F                              dec     di                              ; then copy in DefPathString
  8454 00001DB7 F3A4                            rep     movsb                           ; DS:SI -> "C:\\DOS\0"
  8455                                  
  8456                                  ; Initialize the default prompt
  8457                                  
  8458                                  init_prompt:
  8459 00001DB9 57                              push    di                              ;
  8460 00001DBA 29C0                            sub     ax,ax                           ;
  8461 00001DBC B94000                          mov     cx,64                           ; insure any data read in
  8462 00001DBF F3AA                            rep     stosb                           ; from Current_Dir is zapped
  8463 00001DC1 5F                              pop     di                              ;
  8464                                  
  8465 00001DC2 3806[8C1E]              	cmp	[AllocedEnv],al			; virgin env?
  8466 00001DC6 740B                            je	short init_comspec		; no
  8467                                          ;mov	si,offset RESGROUP:PrmptString  ; DS:SI -> "PROMPT=$P$G\0"
  8468 00001DC8 BE[A31E]                        mov	si,PrmptString
  8469 00001DCB 3804                    	cmp     [si],al				; add it?
  8470 00001DCD 7404                            je      short init_comspec		; no
  8471                                  	;mov	cx,PrmptStrLen+1                ;
  8472 00001DCF B10C                            mov	cl,12  ; db "PROMPT=$P$G",0
  8473 00001DD1 F3A4                    	rep     movsb                           ;
  8474                                  
  8475                                  ; Initialize the Comspec string
  8476                                  
  8477                                  init_comspec:
  8478 00001DD3 3906[AF1E]                      cmp	[ComspOffset],ax		; add it?
  8479 00001DD7 750E                            jne	short init_done			; no
  8480                                          ;lea	ax,[di+8]
  8481 00001DD9 8D4508                  	lea     ax,[di+ComspStrLen]             ;
  8482 00001DDC A3[AF1E]                        mov	[ComspOffset],ax		;
  8483                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8484 00001DDF BE[B11E]                        mov	si,ComspString
  8485                                  	;mov	cx,ComspStrLen2+1               ;
  8486 00001DE2 B91500                          mov	cx,21 ; db "COMSPEC=\COMMAND.COM",0
  8487 00001DE5 F3A4                    	rep     movsb                           ;
  8488                                  
  8489                                  init_done:
  8490 00001DE7 8CC0                            mov     ax,es                           ; return env seg in ax
  8491 00001DE9 A3[DC03]                        mov     [EnvirSeg],ax			; save env seg
  8492 00001DEC FE06[8C1E]                      inc	byte [AllocedEnv]		; remember that *we* alloced it
  8493                                  %endif
  8494                                  
  8495                                  ; 07/06/2023
  8496                                  ; 29/01/2023 - MSDOS 5.0 COMMAND.COM (RESGROUP:1DC4h)
  8497                                  ;%if 1
  8498                                  %if 0
  8499                                  	;mov	bx,10
  8500                                  	mov	bx,ENVIRONSIZ>>4 ; 160/16
  8501                                  	mov	ah,48h
  8502                                  	int	21h    	; DOS - 2+ - ALLOCATE MEMORY
  8503                                  			; BX = number of 16-byte paragraphs desired
  8504                                  	jc	short init_nomem
  8505                                  
  8506                                  init_ok:
  8507                                  	mov	es,ax
  8508                                  	;assume	es:nothing                      ; es = temp env segment
  8509                                  
  8510                                  	xor	di,di
  8511                                  	mov	ax,di
  8512                                  	;mov	cx,160	
  8513                                          mov     cx,ENVIRONSIZ
  8514                                          rep	stosb
  8515                                  
  8516                                  init_pathstr:
  8517                                  
  8518                                  ; Initialize the path string (PATH=) first
  8519                                  
  8520                                  	push	ss
  8521                                  	pop	ds
  8522                                  
  8523                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8524                                  	mov	si,PathString
  8525                                  	mov	di,0
  8526                                  init_cp_pathstr:
  8527                                  	lodsb
  8528                                  	stosb
  8529                                  	or	al,al
  8530                                  	jnz	short init_cp_pathstr
  8531                                  
  8532                                  ; Initialize the Comspec string
  8533                                  
  8534                                  init_comspec:
  8535                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8536                                          mov	si,ComspString
  8537                                  	; 05/05/2023
  8538                                  	mov	di,6
  8539                                  init_cp_compstr:
  8540                                  	lodsb
  8541                                  	stosb
  8542                                  	or	al,al
  8543                                  	jnz	short init_cp_compstr
  8544                                  
  8545                                  init_done:
  8546                                          mov     ax,es                           ; return env seg in ax
  8547                                          ;mov	[EnvirSeg],ax			; save env seg
  8548                                          ;inc	byte [AllocedEnv]		; remember that *we* alloced it
  8549                                  %endif	
  8550                                  
  8551                                  	; 29/01/2023
  8552                                  alloc_done:
  8553 00001DF0 5F                      	pop	di
  8554 00001DF1 5E                      	pop	si
  8555 00001DF2 07                      	pop	es
  8556 00001DF3 1F                              pop     ds
  8557                                  	;assume	ds:nothing
  8558 00001DF4 C3                      	retn
  8559                                  
  8560                                  	; 29/01/2023
  8561                                  init_nomem:
  8562                                  
  8563                                  ;We call the error routine from here. This routine never returns. It either
  8564                                  ;terminates COMMAND with error( if it is not the first invocation ) or hangs
  8565                                  ;the system ( if it is the first COMMAND.COM ).
  8566                                  
  8567 00001DF5 E80000                  	call	Alloc_error
  8568                                  
  8569                                  ;Alloc_env	endp
  8570                                  
  8571                                  ;*** Alloc_error: This routine just jumps to the actual label where we 
  8572                                  ; check if this is a permanent or secondary command.com and take the 
  8573                                  ; appropriate action.
  8574                                  ;
  8575                                  ;	ENTRY:	ds = RESGROUP = DATARES
  8576                                  ;
  8577                                  ;	EXIT:	None - does not return
  8578                                  ;
  8579                                  ;	REGISTERS AFFECTED: Does not matter
  8580                                  ;
  8581                                  
  8582                                  ;public Alloc_error
  8583                                  Alloc_error:	;proc	near
  8584                                  
  8585                                  	;jmp	RESGROUP:BadMemErr
  8586                                  	; 29/01/2023
  8587 00001DF8 E9CDEF                  	jmp	BadMemErr	
  8588                                  	
  8589                                  ;Alloc_error	endp
  8590                                  
  8591                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8592                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1DFFh
  8593                                  
  8594                                  	; MSDOS 6.0
  8595                                  ;*** Patch_stub -- This routine patches in the segment and offset values in
  8596                                  ; the stub table of the various entry points in the resident code segment.
  8597                                  ; Some of them are interrupt entry points and some of them are entries from
  8598                                  ; the transient to the resident code segment.
  8599                                  ;
  8600                                  ;	ENTRY:	ds = RESGROUP
  8601                                  ;		es:di = segment:offset of final location of resident code
  8602                                  ;
  8603                                  ;	EXIT:	All segments and offsets patched into the stub table
  8604                                  ;
  8605                                  ;	REGISTERS AFFECTED: ax, bx, cx, dx, si, di
  8606                                  
  8607                                  patch_stub:	;proc near
  8608                                  	;assume	ds:RESGROUP
  8609                                  	
  8610 00001DFB 06                      	push	es
  8611                                  
  8612 00001DFC 8CC3                    	mov	bx,es			;bx = resident code segment
  8613 00001DFE 89FA                    	mov	dx,di
  8614                                  	;mov	di,offset DATARES:Int2f_Entry
  8615 00001E00 BF[0400]                	mov	di,Int2f_Entry
  8616                                  	;mov	si,offset RESGROUP:Reloc_Table
  8617 00001E03 BE[FA23]                	mov	si,Reloc_Table
  8618 00001E06 1E                      	push	ds
  8619 00001E07 07                      	pop	es			;es = RESGROUP = DATARES
  8620                                  
  8621                                  ;bx:dx = segment:offset of resident code segment
  8622                                  ;es:di = entry point table in stub
  8623                                  ;ds:si = offset table in INIT segment -- offsets of code entry points now
  8624                                  
  8625                                  	;mov	cx,NUM_RELOC_ENTRIES	;number of entry points
  8626 00001E08 B90B00                  	mov	cx,11 ; MSDOS 5.0 COMMAND.COM
  8627                                  patchlp:
  8628 00001E0B AD                      	lodsw				;get current offset
  8629 00001E0C 01D0                    	add	ax,dx			;offset it by code seg location 
  8630 00001E0E AB                      	stosw				;store offset
  8631 00001E0F 89D8                    	mov	ax,bx			
  8632 00001E11 AB                      	stosw				;store segment 
  8633 00001E12 E2F7                    	loop	patchlp
  8634                                  
  8635 00001E14 07                      	pop	es
  8636 00001E15 C3                      	retn
  8637                                  
  8638                                  ;Patch_stub	endp
  8639                                  
  8640                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8641                                  
  8642                                  	; MSDOS 6.0
  8643                                  ;*** Patch_segs -- This routine patches the segment values in the dword 
  8644                                  ; pointers that the stub uses to jump to the actual handler. These values 
  8645                                  ; are temporarily needed to handle these interrupts if they occur before
  8646                                  ; the resident is relocated to its final position and all the addresses of
  8647                                  ; the handlers have been updated.
  8648                                  ;
  8649                                  ;	ENTRY:	es = PSP segment = code segment
  8650                                  ;
  8651                                  ;	EXIT:	Current segment values patched into the jump table in the
  8652                                  ;		stub.
  8653                                  ;
  8654                                  ;	REGISTERS AFFECTED: ax, cx, di
  8655                                  
  8656                                  patch_segs:	;proc near
  8657                                  
  8658                                  	;mov	di,offset RESGROUP:Int2f_Entry
  8659 00001E16 BF[0400]                	mov	di,Int2f_Entry 
  8660 00001E19 B90400                  	mov	cx,4			;we have to patch 4 handlers
  8661 00001E1C 83C702                  	add	di,2
  8662 00001E1F 8CC0                    	mov	ax,es
  8663                                  pseglp:
  8664 00001E21 AB                      	stosw				;store the segment value
  8665 00001E22 83C702                  	add	di,2			;skip the next offset value
  8666 00001E25 E2FA                    	loop	pseglp
  8667                                  
  8668 00001E27 C3                      	retn
  8669                                  
  8670                                  ;Patch_segs	endp
  8671                                  
  8672                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8673                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E2Ch
  8674                                  
  8675                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8676                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:20D8h
  8677                                  
  8678                                  	; MSDOS 6.0
  8679                                  ;*** get_XMMAddr -- This routine gets the call address for the XMM driver
  8680                                  ; by issuing the appropriate int 2fh. This is stored in a stub variable 
  8681                                  ; and is used by the stub when we have to jump to the resident in HMA
  8682                                  ;
  8683                                  ;	ENTRY:	ds = RESGROUP
  8684                                  ;
  8685                                  ;	EXIT:	XMMCallAddr = XMM driver far call address
  8686                                  ;
  8687                                  ;	REGISTERS AFFECTED:
  8688                                  ;
  8689                                  
  8690                                  get_XMMAddr:	;proc near
  8691                                  	;assume	ds:RESGROUP
  8692                                  
  8693 00001E28 06                      	push	es
  8694                                  
  8695                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
  8696 00001E29 B80043                  	mov	ax,4300h
  8697 00001E2C CD2F                    	int	2Fh
  8698                                  		; - Multiplex - XMS - INSTALLATION CHECK
  8699                                  		; Return: AL = 80h XMS driver installed
  8700                                  		; AL <> 80h no driver
  8701 00001E2E 3C80                    	cmp	al,80h			; Q: installed
  8702 00001E30 750D                    	jne	short cXMMexit		; N: set error, quit
  8703                                  ;
  8704                                  ; get the XMM control functions entry point, save it, we
  8705                                  ; need to call it later.
  8706                                  ;
  8707                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
  8708 00001E32 B81043                  	mov	ax,4310h
  8709 00001E35 CD2F                    	int	2Fh
  8710                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
  8711                                  		; Return: ES:BX -> driver entry point
  8712                                  
  8713 00001E37 891E[3000]              	mov	[XMMCallAddr], bx
  8714 00001E3B 8C06[3200]              	mov	[XMMCallAddr+2],es
  8715                                  cXMMexit:
  8716 00001E3F 07                      	pop	es
  8717 00001E40 C3                      	retn				; done
  8718                                  
  8719                                  ;get_XMMAddr	endp
  8720                                  
  8721                                  ;=============================================================================
  8722                                  ; UNINIT.ASM, MSDOS 6.0, 1991
  8723                                  ;=============================================================================
  8724                                  ; 24/09/2018 - Retro DOS v3.0
  8725                                  
  8726                                  ; (30/04/2018 - Retro DOS v2.0, MSDOS 2.11 COMMAND.COM)
  8727                                  
  8728                                  ; TITLE	COMMAND Initialization messages
  8729                                  
  8730                                  ;INIT	SEGMENT PUBLIC PARA
  8731                                  
  8732                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8733                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8734                                  
  8735                                  	; 25/09/2018
  8736                                  	; (15 bytes filler)
  8737 00001E41 00                      	db 0
  8738                                  	;db "25/9/2018 ETAN"
  8739                                  	; 30/01/2023
  8740                                  	;db "30/1/2023 ETAN"	
  8741                                  	; 19/06/2023
  8742                                  	;db "19/6/2023 ETAN"
  8743                                  	; 31/07/2024
  8744 00001E42 33312F372F32303234-     	db "31/7/2024 ETAN"	
  8744 00001E4B 204554414E         
  8745 00001E50 00                      	db 0
  8746                                  
  8747                                  ; 30/01/2023
  8748                                  %if 0
  8749                                  	; MSDOS 3.3 COMMAND.COM - offset 145Eh
  8750                                  	;dw 0
  8751                                  COPYRIGHTMSG:	; MSDOS 3.3 COMMAND.COM - offset 1460h
  8752                                  	db 0Dh,0Ah
  8753                                  	db 0Dh,0Ah
  8754                                  	db 'Microsoft(R) MS-DOS(R)  Version 3.30'
  8755                                  	db 0Dh,0Ah
  8756                                  	db '             (C)Copyright Microsoft Corp 1981-1987               '
  8757                                  	db ' ',0Dh,0Ah
  8758                                  	db '                                                   ',
  8759                                  	db 0Dh,0Ah,0
  8760                                  
  8761                                  	times	43 db 20h
  8762                                  
  8763                                  _152Fh:	db 'Specified COMMAND search directory bad',0Dh,0Ah,0
  8764                                  BADCOMLKMES:
  8765                                  	dw _152Fh
  8766                                  
  8767                                  _155Ah:	db 'Specified COMMAND search directory bad access denied',0Dh,0Ah,0
  8768                                  BADCOMACCMSG:
  8769                                  	dw _155Ah
  8770                                  
  8771                                  _1593h:	db 'Access denied',0Dh,0Ah,0
  8772                                  ACCDENERR:
  8773                                  	dw _1593h
  8774                                  
  8775                                  _15A5h:	db 'Out of environment space',0Dh,0Ah,0
  8776                                  OUTENVMSG:
  8777                                  	dw _15A5h
  8778                                  
  8779                                  BADVERMSG:
  8780                                  	db 'Incorrect DOS version',0Dh,0Ah,'$'
  8781                                  
  8782                                  BADENVSIZMSG:
  8783                                  	db 'Invalid environment size specified',0Dh,0Ah,'$'
  8784                                  
  8785                                  HEADERPTR:
  8786                                  	dw COPYRIGHTMSG
  8787                                  %endif
  8788                                  
  8789                                  ; 30/01/2023
  8790                                  ;align 16
  8791                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8792                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E50h 
  8793                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8794                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:2100h 
  8795                                  ICONDEV:
  8796 00001E51 2F4445562F                      db '/DEV/'
  8797 00001E56 434F4E000000000000      	db 'CON',0,0,0,0,0,0	; Room for 8 char device	
  8798                                  BADCSPFL:
  8799 00001E5F 00                      	db 0
  8800                                  COMSPECT:
  8801 00001E60 5C434F4D4D414E442E-     	db '\COMMAND.COM',0
  8801 00001E69 434F4D00           
  8802 00001E6D 00                      	db 0
  8803                                  AUTOBAT:
  8804 00001E6E 003A5C4155544F4558-     	db 0,':\AUTOEXEC.BAT',0,0Dh
  8804 00001E77 45432E424154000D   
  8805                                  
  8806                                  ; 22/07/2024
  8807                                  ; 07/06/2023
  8808                                  ;KAUTOBAT:
  8809                                  ;	db 0,':\KAUTOEXEC.BAT',0,0Dh
  8810                                   
  8811                                  PRDATTM:
  8812 00001E7F FF                      	db -1 ; 0FFh		; Init not to prompt for date time
  8813                                  INITADD:
  8814 00001E80 00000000                	dd 0
  8815                                  print_add:
  8816 00001E84 [1B55]                  	dw Printf_Init
  8817 00001E86 0000                    	dw 0
  8818                                  triage_add:
  8819 00001E88 [F131]                  	dw Triage_Init
  8820 00001E8A 0000                    	dw 0
  8821                                  ;CHUCKENV:
  8822                                  AllocedEnv:
  8823 00001E8C 00                      	db 0
  8824                                  
  8825                                  ; 30/01/2023 - MSDOS 3.3
  8826                                  ;COMSPOFFSET:
  8827                                  ;ECOMLOC:
  8828                                  ;	;dw 0Eh
  8829                                  ;	;dw offset ENVIRONMENT:ECOMSPEC-10h
  8830                                  ;	dw ECOMSPEC-ENVIRONMENT ; 30/04/2018	
  8831                                  ;COMSPSTRING:
  8832                                  ;	db 'COMSPEC='
  8833                                  
  8834                                  ; 30/01/2023 - MSDOS 5.0 & MSDOS 6.0
  8835                                  PathString:
  8836 00001E8D 504154483D00            	db 'PATH=',0
  8837                                  PathStrLen equ $-PathString-1
  8838                                  ;;;
  8839                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8840                                  ; MSDOS 6.0
  8841                                  DefPathString:
  8842 00001E93 433A5C4D53444F5300      	db 'C:\MSDOS',0
  8843                                  DefPathStrLen equ $-DefPathString-1
  8844                                  DefPath2String:
  8845 00001E9C 433A5C444F5300          	db 'C:\DOS',0
  8846                                  DefPath2StrLen equ $-DefPath2String-1
  8847                                  
  8848                                  PrmptString:
  8849 00001EA3 50524F4D50543D2450-     	db 'PROMPT=$P$G',0
  8849 00001EAC 244700             
  8850                                  PrmptStrLen equ $-PrmptString-1
  8851                                  PrmptStrLen2 equ 7		; length of PROMPT=
  8852                                  ComspOffset:
  8853 00001EAF 0000                    	dw 0
  8854                                  ;;;
  8855                                  ComspString:
  8856 00001EB1 434F4D535045433D5C-     	db 'COMSPEC=\COMMAND.COM',0
  8856 00001EBA 434F4D4D414E442E43-
  8856 00001EC3 4F4D00             
  8857                                  ComspStrLen equ 8		; length of COMSPEC=
  8858                                  ComspStrLen2 equ $-ComspString-1
  8859                                  				; length of full COMSPEC
  8860                                  	; 29/01/2023
  8861                                  ;equal_sign:
  8862                                  ;equalsign:
  8863                                  ;	db '='
  8864                                  ;letter_a:
  8865                                  ;lcasea:
  8866                                  ;	db 'a'
  8867                                  ;letter_z:
  8868                                  ;lcasez:
  8869                                  ;	db 'z'
  8870                                  	; 30/01/2023
  8871                                  ;;slash_chr:
  8872                                  ;;	db '/'
  8873                                  ;;bslash_chr:
  8874                                  ;;	db '\'
  8875                                  ;space_chr:
  8876                                  ;;space:
  8877                                  ;	db 20h
  8878                                  ;;letter_p:
  8879                                  ;;	db 'p'
  8880                                  ;;letter_d:
  8881                                  ;;	db 'd'
  8882                                  ;;letter_c:
  8883                                  ;;	db 'c'
  8884                                  	; 16/04/2023
  8885                                  ; MSDOS 5.0 & MSDOS 6.0
  8886                                  ;scswitch:
  8887                                  ;	db 'C'		; Single command
  8888                                  ;;skswitch:
  8889                                  ;	db 'K' ; MSDOS 6.0
  8890                                  ;;letter_A:
  8891                                  ;ucasea: ; 21/01/2023 
  8892                                  ;	db 'A'
  8893                                  
  8894                                  	; 30/01/2023
  8895                                  EnvSiz:
  8896 00001EC6 0000                    	dw 0		; size user wants to allocate
  8897                                  EnvMax:
  8898 00001EC8 0000                    	dw 0		; maximum size allowed
  8899                                  OldEnv:
  8900 00001ECA 0000                    	dw 0		; envirseg at initialization
  8901                                  UsedEnv:
  8902 00001ECC 0000                    	dw 0		; amount of envirseg used
  8903                                  	; MSDOS 5.0 & MSDOS 6.0
  8904                                  PARS_MSG_OFF:
  8905 00001ECE 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE OFFSET
  8906                                  PARS_MSG_SEG:
  8907 00001ED0 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE SEGMENT
  8908                                  
  8909                                  ;Do not separate the following two words. Used to call transient PARSE routine
  8910                                  
  8911                                  Init_Parse:
  8912                                  	;dw 4FFBh	; MSDOS 5.0 COMMAND.COM (TRANGROUP:APPEND_PARSE)
  8913                                  init_p:
  8914 00001ED2 [1755]                  	dw append_parse
  8915                                  initend:
  8916 00001ED4 0000                    	dw 0		; segment address of end of init
  8917                                  TrnSize:
  8918 00001ED6 0000                    	dw 0		; size of transient in paragraphs
  8919                                  
  8920                                  ; 23/07/2024 - Retro DOS v4.2 COMMAND.COM
  8921                                  ;%if 0
  8922                                  resetenv:
  8923                                  	;dw 0		; set if we need to setblck env at endinit
  8924                                  	; 23/07/2024
  8925 00001ED8 00                      	db 0
  8926                                  ;%endif
  8927                                  
  8928                                  ext_msg:
  8929 00001ED9 00                      	db 0		; set if /MSG switch entered
  8930                                  eswitch:
  8931 00001EDA 00                      	db 0		; set if /e was entered
  8932                                  dswitch:
  8933 00001EDB 00                      	db 0		; set if /d was entered
  8934                                  parsemes_ptr:
  8935 00001EDC 0000                    	dw 0		; word to store parse error number
  8936                                  
  8937                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8938                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1ED6h
  8939                                  
  8940                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8941                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:21A5h 
  8942                                  
  8943                                  	; MSDOS 6.0 (UINIT.ASM, 1991)
  8944                                  ;  The following parse control block is used for COMMAND. This block is
  8945                                  ;  used for parsing during initialization. The syntax for COMMAND is:
  8946                                  ;  COMMAND [/?] [d:][path][/P][/F][/D][/E:xxxxx][/MSG][/C executable]
  8947                                  ;
  8948                                  ;  Anything on the command line after the /C switch will be passed to the
  8949                                  ;  executable command, so if /C is used, it must be specified last. The
  8950                                  ;  /MSG switch can only be specified if the /P switch is specified.
  8951                                  ;
  8952                                  ;  The /? switch causes help text to be displayed. Any other options
  8953                                  ;  on the command line are ignored. Command.com will not load if /?
  8954                                  ;  is specified.
  8955                                  
  8956                                  INTERNAT_INFO:		; used for country info after parsing is completed
  8957                                  PARSE_COMMAND:
  8958 00001EDE [E11E]                  	dw COMMAND_PARMS
  8959 00001EE0 00                      	db 0			; no extra delimiter
  8960                                  COMMAND_PARMS:
  8961 00001EE1 0002                    	db 0,2			; 1 positional parm
  8962 00001EE3 [FB1E]                  	dw COMMAND_FILE
  8963 00001EE5 [FB1E]                  	dw COMMAND_FILE
  8964                                          ; MSDOS 5.0
  8965                                  	;db 7			; 7 switches
  8966                                  	; MSDOS 6.0
  8967                                  	;db 8 			; 8 switches
  8968                                  	; 07/06/2023
  8969                                  	; MSDOS 6.22
  8970 00001EE7 09                      	db 9			; 9 switches
  8971 00001EE8 [041F]                  	dw COMMAND_SWITCH1
  8972 00001EEA [101F]                  	dw COMMAND_SWITCH2
  8973 00001EEC [1C1F]                  	dw COMMAND_SWITCH3
  8974 00001EEE [281F]                  	dw COMMAND_SWITCH4
  8975 00001EF0 [411F]                  	dw COMMAND_SWITCH5
  8976 00001EF2 [4D1F]                  	dw COMMAND_SWITCH6
  8977 00001EF4 [5B1F]                  	dw COMMAND_SWITCH7
  8978                                  	; 07/06/2023
  8979 00001EF6 [671F]                  	dw COMMAND_SWITCH8 ; MSDOS 6.0
  8980 00001EF8 [731F]                  	dw COMMAND_SWITCH9 ; MSDOS 6.22
  8981 00001EFA 00                      	db 0			; no keywords
  8982                                  
  8983                                  COMMAND_FILE:
  8984 00001EFB 0102                    	dw 0201h		; filespec - optional
  8985 00001EFD 0100                    	dw 1			; capitalize - file table
  8986 00001EFF [7F1F]                  	dw COMND1_OUTPUT	; result buffer
  8987 00001F01 [871F]                  	dw NO_VAL 		;
  8988 00001F03 00                      	db 0			; no keywords
  8989                                  
  8990                                  COMMAND_SWITCH1:
  8991 00001F04 0000                    	dw 0			; no match flags
  8992 00001F06 0200                    	dw 2			; capitalize by char table
  8993 00001F08 [7F1F]                  	dw COMND1_OUTPUT	; result buffer
  8994 00001F0A [871F]                  	dw NO_VAL 		;
  8995 00001F0C 01                      	db 1			; 1 keyword
  8996                                  COMMAND_P_SYN:
  8997 00001F0D 2F5000                  	db '/P',0		; /P switch
  8998                                  
  8999                                  COMMAND_SWITCH2:
  9000 00001F10 0000                    	dw 0			; no match flags
  9001 00001F12 0200                    	dw 2			; capitalize by char table
  9002 00001F14 [7F1F]                  	dw COMND1_OUTPUT	; result buffer
  9003 00001F16 [871F]                  	dw NO_VAL 		;
  9004 00001F18 01                      	db 1			; 1 keyword
  9005                                  COMMAND_F_SYN:
  9006 00001F19 2F4600                  	db '/F',0		; /F switch
  9007                                  
  9008                                  COMMAND_SWITCH3:
  9009 00001F1C 0000                    	dw 0			; no match flags
  9010 00001F1E 0200                    	dw 2			; capitalize by char table
  9011 00001F20 [7F1F]                  	dw COMND1_OUTPUT	; result buffer
  9012 00001F22 [871F]                  	dw NO_VAL 		;
  9013 00001F24 01                      	db 1			; 1 keyword
  9014                                  COMMAND_D_SYN:
  9015 00001F25 2F4400                  	db '/D',0		; /D switch
  9016                                  
  9017                                  COMMAND_SWITCH4:
  9018 00001F28 0080                    	dw 8000h		; numeric value - required
  9019 00001F2A 0000                    	dw 0			; no function flags
  9020 00001F2C [7F1F]                  	dw COMND1_OUTPUT	; result buffer
  9021 00001F2E [341F]                  	dw COMMAND_E_VAL	; pointer to value list
  9022 00001F30 01                      	db 1			; 1 keyword
  9023                                  COMMAND_E_SYN:
  9024 00001F31 2F4500                  	db '/E',0		; /E switch
  9025                                  
  9026                                  COMMAND_E_VAL:
  9027 00001F34 01                      	db 1			;
  9028 00001F35 01                      	db 1			; 1 range
  9029 00001F36 01                      	db 1			; returned if result
  9030                                  	;dd ENVSML,ENVBIG	; minimum & maximum value
  9031                                  	; MSDOS 5.0 COMMAND.COM
  9032                                  	; (RESGROUP:1F2Bh)
  9033 00001F37 A0000000                	dd 160	 ; ENVSML
  9034 00001F3B 00800000                	dd 32768 ; ENVBIG
  9035 00001F3F 00                      	db 0			; no numeric values
  9036 00001F40 00                      	db 0			; no string values
  9037                                  
  9038                                  COMMAND_SWITCH5:
  9039 00001F41 0000                    	dw 0			; no match flags
  9040 00001F43 0200                    	dw 2			; capitalize by char table
  9041 00001F45 [7F1F]                  	dw COMND1_OUTPUT	; result buffer
  9042 00001F47 [871F]                  	dw NO_VAL 		;
  9043 00001F49 01                      	db 1			; 1 keyword
  9044                                  COMMAND_C_SYN:
  9045 00001F4A 2F4300                  	db '/C',0		; /C switch
  9046                                  
  9047                                  COMMAND_SWITCH6:
  9048 00001F4D 0000                    	dw 0			; no match flags
  9049 00001F4F 0200                    	dw 2			; capitalize by char table
  9050 00001F51 [7F1F]                  	dw COMND1_OUTPUT	; result buffer
  9051 00001F53 [871F]                  	dw NO_VAL 		;
  9052 00001F55 01                      	db 1			; 1 keyword
  9053                                  COMMAND_M_SYN:
  9054 00001F56 2F4D534700              	db '/MSG',0		; /MSG switch
  9055                                  
  9056                                  COMMAND_SWITCH7:
  9057 00001F5B 0000                    	dw 0			; no match flags
  9058 00001F5D 0200                    	dw 2			; capitalize by char table
  9059 00001F5F [7F1F]                  	dw COMND1_OUTPUT	; result buffer
  9060 00001F61 [871F]                  	dw NO_VAL 		;
  9061 00001F63 01                      	db 1			; 1 keyword
  9062                                  COMMAND_?_SYN:
  9063 00001F64 2F3F00                  	db '/?',0 		; /? switch
  9064                                  
  9065                                  	; 07/06/2023
  9066                                  	; MSDOS 6.0
  9067                                  COMMAND_SWITCH8:
  9068 00001F67 0000                    	dw 0			; no match flags
  9069 00001F69 0200                    	dw 2			; capitalize by char table
  9070 00001F6B [7F1F]                  	dw COMND1_OUTPUT	; result buffer
  9071 00001F6D [871F]                  	dw NO_VAL 		;
  9072 00001F6F 01                      	db 1			; 1 keyword
  9073                                  COMMAND_K_SYN:
  9074 00001F70 2F4B00                  	db '/K',0		; /K switch
  9075                                  
  9076                                  	; 07/06/2023
  9077                                  	; MSDOS 6.22
  9078                                  COMMAND_SWITCH9:
  9079 00001F73 0000                    	dw 0			; no match flags
  9080 00001F75 0200                    	dw 2			; capitalize by char table
  9081 00001F77 [7F1F]                  	dw COMND1_OUTPUT	; result buffer
  9082 00001F79 [871F]                  	dw NO_VAL 		;
  9083 00001F7B 01                      	db 1			; 1 keyword
  9084                                  COMMAND_Y_SYN:
  9085 00001F7C 2F5900                  	db '/Y',0		; /Y switch
  9086                                  
  9087                                  COMND1_OUTPUT:
  9088                                  COMND1_TYPE:
  9089 00001F7F 00                      	db 0			; type
  9090                                  COMND1_CODE:
  9091 00001F80 00                      	db 0			; return value
  9092                                  COMND1_SYN:
  9093 00001F81 0000                    	dw 0			; synonym pointer
  9094                                  COMND1_ADDR:
  9095 00001F83 00000000                	dd 0			; numeric value / address
  9096                                  				; of string value
  9097                                  NO_VAL:
  9098 00001F87 00                      	db 0			; no values
  9099                                  num_positionals:
  9100 00001F88 0000                    	dw 0			; counter for positionals
  9101                                  old_parse_ptr:
  9102 00001F8A 0000                    	dw 0			; SI position before calling parser
  9103                                  
  9104                                  	; 30/01/2023
  9105                                  ;***	INITIALIZATION MESSAGES
  9106                                  ;	-------------------------
  9107                                  ;	include	comimsg.inc	;M00
  9108                                  ;-----------------------------------------------------------------------------	
  9109                                  
  9110                                  BADVERMSG:
  9111 00001F8C 17                      	db 23
  9112 00001F8D 496E636F7272656374-     	db 'Incorrect DOS version',0Dh,0Ah
  9112 00001F96 20444F532076657273-
  9112 00001F9F 696F6E0D0A         
  9113                                  OUTENVMSG:
  9114 00001FA4 1A                      	db 26
  9115 00001FA5 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
  9115 00001FAE 7669726F6E6D656E74-
  9115 00001FB7 2073706163650D0A   
  9116                                  
  9117                                  ; 07/06/2023
  9118                                  ;COPYRIGHTMSG:
  9119                                  ;	db 94
  9120                                  ;	db 0Dh,0Ah
  9121                                  ;	db 0Dh,0Ah
  9122                                  ;	db 'Microsoft(R) MS-DOS(R) Version 5.00',0Dh,0Ah
  9123                                  ;	db '             (C)Copyright Microsoft Corp 1981-1991.',0Dh,0Ah
  9124                                  
  9125                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9126                                  ; MSDOS 6.22 COMMAND.COM - RESGROUP:2286h
  9127                                  COPYRIGHTMSG:
  9128 00001FBF 5E                      	db 94
  9129 00001FC0 0D0A                    	db 0Dh,0Ah
  9130 00001FC2 0D0A                    	db 0Dh,0Ah
  9131 00001FC4 4D6963726F736F6674-     	db 'Microsoft(R) MS-DOS(R) Version 6.22',0Dh,0Ah
  9131 00001FCD 285229204D532D444F-
  9131 00001FD6 532852292056657273-
  9131 00001FDF 696F6E20362E32320D-
  9131 00001FE8 0A                 
  9132 00001FE9 202020202020202020-     	db '             (C)Copyright Microsoft Corp 1981-1994.',0Dh,0Ah
  9132 00001FF2 20202020284329436F-
  9132 00001FFB 70797269676874204D-
  9132 00002004 6963726F736F667420-
  9132 0000200D 436F72702031393831-
  9132 00002016 2D313939342E0D0A   
  9133                                  
  9134                                  BADCOMLKMES:
  9135 0000201E 28                      	db 40
  9136 0000201F 537065636966696564-     	db 'Specified COMMAND search directory bad',0Dh,0Ah
  9136 00002028 20434F4D4D414E4420-
  9136 00002031 736561726368206469-
  9136 0000203A 726563746F72792062-
  9136 00002043 61640D0A           
  9137                                  	; 07/06/2023
  9138                                  BADCOMACCMSG:
  9139 00002047 37                      	db 55
  9140 00002048 537065636966696564-     	db 'Specified COMMAND search directory bad, access denied',0Dh,0Ah
  9140 00002051 20434F4D4D414E4420-
  9140 0000205A 736561726368206469-
  9140 00002063 726563746F72792062-
  9140 0000206C 61642C206163636573-
  9140 00002075 732064656E6965640D-
  9140 0000207E 0A                 
  9141                                  HELPMSG1:
  9142 0000207F 38                      	db 56
  9143 00002080 537461727473206120-     	db 'Starts a new copy of the MS-DOS command interpreter.',0Dh,0Ah
  9143 00002089 6E657720636F707920-
  9143 00002092 6F6620746865204D53-
  9143 0000209B 2D444F5320636F6D6D-
  9143 000020A4 616E6420696E746572-
  9143 000020AD 7072657465722E0D0A 
  9144 000020B6 0D0A                    	db 0Dh,0Ah
  9145                                  
  9146                                  ;HELPMSG2:
  9147                                  ;	db 70
  9148                                  ;	db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]'
  9149                                  ;	db 0Dh,0Ah
  9150                                  ;	db 0Dh,0Ah
  9151                                  	; 07/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  9152                                  HELPMSG2:
  9153 000020B8 38                      	db 56
  9154 000020B9 434F4D4D414E44205B-     	db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P [/MSG]]',0Dh,0Ah
  9154 000020C2 5B64726976653A5D70-
  9154 000020CB 6174685D205B646576-
  9154 000020D4 6963655D205B2F453A-
  9154 000020DD 6E6E6E6E6E5D205B2F-
  9154 000020E6 50205B2F4D53475D5D-
  9154 000020EF 0D0A               
  9155                                  HELPMSG3:
  9156 000020F1 2A                      	db 42
  9157 000020F2 20202020202020205B-     	db '        [/Y [/C command | /K command]]',0Dh,0Ah
  9157 000020FB 2F59205B2F4320636F-
  9157 00002104 6D6D616E64207C202F-
  9157 0000210D 4B20636F6D6D616E64-
  9157 00002116 5D5D0D0A           
  9158 0000211A 0D0A                    	db 0Dh,0Ah
  9159                                  
  9160                                  ;HELPMSG3:
  9161                                  HELPMSG4:
  9162 0000211C 48                              db 72
  9163 0000211D 20205B64726976653A-     	db '  [drive:]path    Specifies the directory containing COMMAND.COM '
  9163 00002126 5D7061746820202020-
  9163 0000212F 537065636966696573-
  9163 00002138 207468652064697265-
  9163 00002141 63746F727920636F6E-
  9163 0000214A 7461696E696E672043-
  9163 00002153 4F4D4D414E442E434F-
  9163 0000215C 4D20               
  9164 0000215E 66696C652E0D0A          	db 'file.',0Dh,0Ah
  9165                                  ;HELPMSG4:
  9166                                  HELPMSG5:
  9167 00002165 4D                      	db 77
  9168 00002166 202064657669636520-     	db '  device          Specifies the device to use for command input and '
  9168 0000216F 202020202020202020-
  9168 00002178 537065636966696573-
  9168 00002181 207468652064657669-
  9168 0000218A 636520746F20757365-
  9168 00002193 20666F7220636F6D6D-
  9168 0000219C 616E6420696E707574-
  9168 000021A5 20616E6420         
  9169 000021AA 6F75747075742E0D0A      	db 'output.',0Dh,0Ah
  9170                                  ;HELPMSG5:
  9171                                  HELPMSG6:
  9172 000021B3 45                      	db 69
  9173 000021B4 20202F453A6E6E6E6E-     	db '  /E:nnnnn        Sets the initial environment size to nnnnn bytes.'
  9173 000021BD 6E2020202020202020-
  9173 000021C6 536574732074686520-
  9173 000021CF 696E697469616C2065-
  9173 000021D8 6E7669726F6E6D656E-
  9173 000021E1 742073697A6520746F-
  9173 000021EA 206E6E6E6E6E206279-
  9173 000021F3 7465732E           
  9174 000021F7 0D0A                    	db 0Dh,0Ah
  9175                                  ;HELPMSG6:
  9176                                  HELPMSG7:
  9177 000021F9 4D                      	db 77
  9178 000021FA 20202F502020202020-     	db '  /P              Makes the new Command Interpreter permanent '
  9178 00002203 202020202020202020-
  9178 0000220C 4D616B657320746865-
  9178 00002215 206E657720436F6D6D-
  9178 0000221E 616E6420496E746572-
  9178 00002227 707265746572207065-
  9178 00002230 726D616E656E7420   
  9179 00002238 2863616E2774206578-     	db '(can',27h,'t exit).',0Dh,0Ah
  9179 00002241 6974292E0D0A       
  9180                                  ;HELPMSG7:
  9181                                  HELPMSG8:
  9182                                  	;db 80
  9183                                  	;db '  /C string       Carries out the command specified by string, and '
  9184                                  	;db 'then stops.',0Dh,0Ah
  9185                                  	; 07/06/2023
  9186 00002247 46                      	db 70
  9187 00002248 20202F4D5347202020-     	db '  /MSG            Stores all error messages in memory (requires /P).'
  9187 00002251 202020202020202020-
  9187 0000225A 53746F72657320616C-
  9187 00002263 6C206572726F72206D-
  9187 0000226C 657373616765732069-
  9187 00002275 6E206D656D6F727920-
  9187 0000227E 287265717569726573-
  9187 00002287 202F50292E         
  9188 0000228C 0D0A                    	db 0Dh,0Ah
  9189                                  ;HELPMSG8:
  9190                                  HELPMSG9:
  9191                                  	;db 78
  9192                                  	;db '  /MSG            Specifies that all error messages be stored in '
  9193                                  	;db 'memory. You',0Dh,0Ah
  9194                                  ;HELPMSG9:
  9195                                  	;db 56
  9196                                  	;db '                  need to specify /P with this switch.',0Dh,0Ah
  9197 0000228E 4A                      	db 74
  9198 0000228F 20202F592020202020-     	db '  /Y              Steps through the batch program specified by /C'
  9198 00002298 202020202020202020-
  9198 000022A1 537465707320746872-
  9198 000022AA 6F7567682074686520-
  9198 000022B3 62617463682070726F-
  9198 000022BC 6772616D2073706563-
  9198 000022C5 696669656420627920-
  9198 000022CE 2F43               
  9199 000022D0 206F72202F4B2E0D0A      	db ' or /K.',0Dh,0Ah
  9200                                  
  9201                                  	; 07/06/2023
  9202                                  HELPMSG10:
  9203 000022D9 3F                      	db 63
  9204 000022DA 20202F4320636F6D6D-     	db '  /C command      Executes the specified command and returns.',0Dh,0Ah
  9204 000022E3 616E64202020202020-
  9204 000022EC 457865637574657320-
  9204 000022F5 746865207370656369-
  9204 000022FE 6669656420636F6D6D-
  9204 00002307 616E6420616E642072-
  9204 00002310 657475726E732E0D0A 
  9205                                  HELPMSG11:
  9206 00002319 4B                      	db 75
  9207 0000231A 20202F4B20636F6D6D-     	db '  /K command      Executes the specified command and continues running.'
  9207 00002323 616E64202020202020-
  9207 0000232C 457865637574657320-
  9207 00002335 746865207370656369-
  9207 0000233E 6669656420636F6D6D-
  9207 00002347 616E6420616E642063-
  9207 00002350 6F6E74696E75657320-
  9207 00002359 72756E6E696E672E   
  9208 00002361 0D0A                    	db 0Dh,0Ah
  9209 00002363 0D0A                    	db 0Dh,0Ah
  9210                                  HELPMSG12:
  9211 00002365 4C                      	db 76
  9212 00002366 546865202F5020616E-     	db 'The /P and /MSG switches may be used only when COMMAND is started'
  9212 0000236F 64202F4D5347207377-
  9212 00002378 697463686573206D61-
  9212 00002381 792062652075736564-
  9212 0000238A 206F6E6C7920776865-
  9212 00002393 6E20434F4D4D414E44-
  9212 0000239C 206973207374617274-
  9212 000023A5 6564               
  9213 000023A7 206279207573696E67-     	db ' by using',0Dh,0Ah
  9213 000023B0 0D0A               
  9214                                  HELPMSG13:
  9215 000023B2 2B                      	db 43
  9216 000023B3 746865205348454C4C-     	db 'the SHELL command in the CONFIG.SYS file.',0Dh,0Ah
  9216 000023BC 20636F6D6D616E6420-
  9216 000023C5 696E2074686520434F-
  9216 000023CE 4E4649472E53595320-
  9216 000023D7 66696C652E0D0A     
  9217                                  
  9218                                  HelpMsgs:
  9219 000023DE [7F20]                          dw HELPMSG1
  9220 000023E0 [B820]                  	dw HELPMSG2
  9221 000023E2 [F120]                  	dw HELPMSG3
  9222 000023E4 [1C21]                  	dw HELPMSG4
  9223 000023E6 [6521]                  	dw HELPMSG5
  9224 000023E8 [B321]                  	dw HELPMSG6
  9225 000023EA [F921]                  	dw HELPMSG7
  9226 000023EC [4722]                  	dw HELPMSG8
  9227 000023EE [8E22]                  	dw HELPMSG9
  9228                                  
  9229                                  	; 07/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  9230 000023F0 [D922]                  	dw HELPMSG10
  9231 000023F2 [1923]                  	dw HELPMSG11
  9232 000023F4 [6523]                  	dw HELPMSG12
  9233 000023F6 [B223]                  	dw HELPMSG13
  9234                                  
  9235                                  	; 23/04/2023
  9236 000023F8 0000                    	dw 0
  9237                                  
  9238                                  ;-----------------------------------------------------------------------------
  9239                                  
  9240                                  ;SR;
  9241                                  ; This table of offsets is used by the init code to calculate the new offsets
  9242                                  ;for these labels after the resident code has been relocated
  9243                                  
  9244                                  ;Reloc_Table:
  9245                                  	;dw offset CODERES:MsgInt2fHandler
  9246                                  	;dw offset CODERES:Int_2e
  9247                                  	;dw offset CODERES:ContC
  9248                                  	;dw offset CODERES:DskErr
  9249                                  	;dw offset CODERES:Exec_Ret
  9250                                  	;dw offset CODERES:TRemCheck
  9251                                  	;dw offset CODERES:TrnLodCom1
  9252                                  	;dw offset CODERES:LodCom
  9253                                  	;dw offset CODERES:MsgRetriever
  9254                                  	;dw offset CODERES:THeadFix
  9255                                  	;dw offset CODERES:Lh_OffUnlink	; M003
  9256                                  
  9257                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9258                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:22F6h
  9259                                  
  9260                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9261                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:26C1h
  9262                                  
  9263                                  Reloc_Table:			          ; MSDOS 5.0 - 6.22 CODERES address
  9264 000023FA 1807                    	dw MsgInt2fHandler - RCODE_START  ; 738h (RESGROUP:738h+X) *
  9265 000023FC 7401                    	dw Int_2e - RCODE_START		  ; 177h (RESGROUP:177h+X) *	
  9266 000023FE 3300                    	dw ContC - RCODE_START		  ; 035h (RESGROUP:035h+X) *
  9267 00002400 3504                    	dw DSKERR - RCODE_START		  ; 445h (RESGROUP:445h+X) *
  9268 00002402 2700                    	dw Exec_Ret - RCODE_START	  ; 029h (RESGROUP:029h+X) *
  9269 00002404 9802                    	dw TRemCheck - RCODE_START	  ; 2A3h (RESGROUP:2A3h+X) *
  9270 00002406 1204                    	dw TrnLodCom1 - RCODE_START	  ; 422h (RESGROUP:422h+X) *
  9271 00002408 AB01                    	dw LodCom - RCODE_START		  ; 1AEh (RESGROUP:1AEh+X) *
  9272 0000240A 5B07                    	dw MsgRetriever - RCODE_START	  ; 77Bh (RESGROUP:77Bh+X) *
  9273 0000240C B702                    	dw THeadFix - RCODE_START	  ; 2C2h (RESGROUP:2C2h+X) *
  9274 0000240E D407                    	dw Lh_OffUnlink - RCODE_START	  ; 7F4h (RESGROUP:7F4h+X) *
  9275                                  
  9276                                  	; 07/06/2023
  9277                                  	; X = 0D40h for MSDOS 5.0 COMMAND.COM
  9278                                  	; X = 0E50h for MSDOS 6.22 COMMAND.COM
  9279                                  	;; example:
  9280                                  	;;	MsgIn2FHandler is at RESGROUP:1588h or at CODERES:0738h
  9281                                  	;;				(in MSDOS 6.22 COMMAND.COM)
  9282                                  
  9283                                  NUM_RELOC_ENTRIES equ ($-Reloc_Table)/2
  9284                                  
  9285                                  ResJmpTable:
  9286 00002410 00000000                	dd 0			; stores prev stub jump table addr
  9287                                  FirstCom:
  9288 00002414 00                      	db 0			; flag set if first command.com
  9289                                  DevFlag:
  9290 00002415 00                      	db 0
  9291                                  PathFlag:
  9292 00002416 00                      	db 0
  9293                                  
  9294                                  	;; MSDOS 5.0 COMMAND.COM - RESGROUP:2313h
  9295                                  	;;times 13 db 0
  9296                                  
  9297                                  	; 07/06/2023
  9298                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:26DEh
  9299                                  	;times 2 db 0
  9300                                  
  9301                                  ; 30/01/2023
  9302                                  coderes_end equ $
  9303                                  
  9304                                  ;INIT	ENDS
  9305                                  
  9306                                  ;	END
  9307                                  
  9308                                  ;-----------------------------------------------------------------------------
  9309                                  ; 14/10/2018 (Retro DOS v3.0 COMMAND.COM Signature)
  9310                                  ;-----------------------------------------------------------------------------
  9311                                  
  9312                                  ;db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018]"
  9313                                  	; 30/01/2023
  9314 00002417 00                      db	0
  9315                                  ;db	"Retro DOS v4.0 COMMAND.COM by Erdogan Tan [2023]"		
  9316                                  	; 07/06/2023
  9317                                  ;db	"Retro DOS v4.2 COMMAND.COM by Erdogan Tan [2023]"
  9318 00002418 526574726F20444F53-     db	"Retro DOS v4.2 COMMAND.COM by Erdogan Tan [2024]" ; 21/07/2024
  9318 00002421 2076342E3220434F4D-
  9318 0000242A 4D414E442E434F4D20-
  9318 00002433 6279204572646F6761-
  9318 0000243C 6E2054616E205B3230-
  9318 00002445 32345D             
  9319 00002448 00                      db	0
  9320                                  
  9321                                  ;-----------------------------------------------------------------------------
  9322                                  ; 24/09/2018 (Retro DOS v3.0 COMMAND)
  9323                                  ;-----------------------------------------------------------------------------
  9324                                  
  9325                                  ;TAIL    SEGMENT PUBLIC PARA
  9326                                  ;        ORG     0
  9327                                  ;TRANSTART LABEL WORD
  9328                                  ;TAIL    ENDS
  9329                                  
  9330                                  ;ALIGN 16  ; 25/09/2018
  9331                                  
  9332                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9333                                  
  9334                                  numbertodiv equ ($-StartCode)+100h ; 16/04/2023
  9335                                  numbertomod equ (numbertodiv % 16)
  9336                                  
  9337                                  %if numbertomod>0 & numbertomod<16
  9338 00002449 00<rep 7h>              	times (16-numbertomod) db 0
  9339                                  %endif
  9340                                  
  9341                                  ; 30/01/2023
  9342                                  ;TRANSTART:
  9343                                  
  9344                                  ; 21/04/2018 (Retro DOS v2.0 COMMAND)
  9345                                  ;	times	128 db 0	
  9346                                  
  9347                                  ;-----------------------------------------------------------------------------
  9348                                  ; SEGMENT - TRANSCODE
  9349                                  ;-----------------------------------------------------------------------------
  9350                                  
  9351                                  ;TRANGROUP: ; 21/04/2018
  9352                                  
  9353                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9354                                  ;-----------------------------------------------------------------------------
  9355                                  
  9356                                  ; MSDOS 3.3 COMMAND.COM Transient Portion Addresses
  9357                                  
  9358                                  ; 21/04/2018 - Retro DOS v2.0
  9359                                  ; transcom.s (COMMAND.COM source file 2 of 2) code/data addresses 
  9360                                  ; (these values must be changed when transcom.s source code is changed
  9361                                  ; and data offsets are changed)
  9362                                  ;
  9363                                  ; 30/04/2018
  9364                                  ; 29/04/2018
  9365                                  
  9366                                  ; 24/09/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9367                                  ;COMMAND      EQU  012CH
  9368                                  ;DATINIT      EQU  2091H
  9369                                  ;HEADCALL     EQU  428FH
  9370                                  ;TRANSPACEEND EQU  4D5CH
  9371                                  ;TRANDATAEND  EQU  3F44H
  9372                                  
  9373                                  ; 29/04/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9374                                  ;TRIAGE_INIT  EQU  1F15H
  9375                                  ;PRINTF_INIT  EQU  34E0H 
  9376                                  
  9377                                  ;GETEXTERRNUM EQU  1EEEH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr	
  9378                                  
  9379                                  ;TPA	EQU  4293H
  9380                                  ;TRNLEN	EQU  04D6H
  9381                                  
  9382                                  ; 20/10/2018 - Retro DOS v3.0 COMMAND.COM transient portion addresses
  9383                                  ;COMMAND      EQU  012CH
  9384                                  ;DATINIT      EQU  206FH
  9385                                  ;HEADCALL     EQU  426FH
  9386                                  ; 09/01/2023
  9387                                  ;TRANSPACEEND EQU  4D3CH
  9388                                  ;TRANDATAEND  EQU  3F24H
  9389                                  ;TRIAGE_INIT  EQU  1EF3H
  9390                                  ;PRINTF_INIT  EQU  34BFH 
  9391                                  ;
  9392                                  ;GETEXTERRNUM EQU  1ECCH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr
  9393                                  
  9394                                  ;-----------------------------------------------------------------------------
  9395                                  ; ARENA.INC, MSDOS 6.0, 1991
  9396                                  ;-----------------------------------------------------------------------------
  9397                                  ; 13/10/2018 - Retro DOS 3.0
  9398                                  ; 17/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9399                                  
  9400                                  ;BREAK <Memory arena structure>
  9401                                  
  9402                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  9403                                  
  9404                                  ; arena item
  9405                                  
  9406                                  struc ARENA
  9407 00000000 ??                        .signature:	resb 1		; 4D for valid item, 5A for last item
  9408 00000001 ????                      .owner:	resw 1		; owner of arena item
  9409 00000003 ????                      .size:	resw 1		; size in paragraphs of item
  9410                                  endstruc
  9411                                  
  9412                                  ;-----------------------------------------------------------------------------
  9413                                  ;START OF TRANSIENT PORTION
  9414                                  ;This code is loaded at the end of memory and may be overwritten by
  9415                                  ;memory-intensive user programs.
  9416                                  ;-----------------------------------------------------------------------------
  9417                                  
  9418                                  ; 16/04/2023
  9419                                  TRANSTART EQU ($-StartCode)+100h ; 18/04/2023
  9420                                  ; 29/09/2018
  9421                                  ; 31/01/2023 
  9422                                  ;TRANSTART:	; Offset 1660h in original MSDOS 3.3 COMMAND.COM
  9423                                  			
  9424                                  		; 09/01/2023
  9425                                  		; Offset 2320h in original MSDOS 5.0 COMMAND.COM
  9426                                  			
  9427                                  		; 07/06/2023
  9428                                  		; Offset 26E0h in original MSDOS 6.22 COMMAND.COM
  9429                                  
  9430                                  ; 25/09/2018
  9431                                  ; (original MSDOS 3.3 COMMAND.COM TRIAGEERROR offset address)
  9432                                  ;
  9433                                  ; 'GET_EXT_ERR_NUMBER' ('TRIAGEERROR') procedure is at offset 354Eh 
  9434                                  ; in MSDOS 3.3 COMMAND.COM (It is at offset 1EEEh in transient porsion).	 	
  9435                                  ;
  9436                                  ;TRIAGEERROR EQU TRANSTART+GETEXTERRNUM-100H
  9437                                  ;
  9438                                  ;
  9439                                  ;COMTRANS:
  9440                                  ;
  9441                                  ; 20/10/2018 - Retro DOS v3.0	
  9442                                  ;INCBIN	"TRANCOM3.BIN"
  9443                                  ;
  9444                                  ;COMLEN	EQU $-COMTRANS ; End of COMMAND load.
  9445                                  ;
  9446                                  ; 29/04/2018
  9447                                  ;BSS_SIZE EQU TRANSPACEEND-TRANDATAEND	
  9448                                  ;
  9449                                  ;TIMES BSS_SIZE db 0
  9450                                  ;
  9451                                  ;COMLEN	EQU $-COMTRANS ; 30/04/2018
  9452                                  
  9453                                  ;COMMANDCOMSIZE equ $ - 100h
  9454                                  
  9455                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9456                                  ; ============================================================================
  9457                                  ; --- ('trancom5.s', 31/01/2023 - modified from 'trancom3.s', 20/10/2018) ----
  9458                                  ; ============================================================================
  9459                                  
  9460                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM (MSDOS 6.22 COMMAND.COM)
  9461                                  
  9462                                  ; ----------------------------------------------------------------------------
  9463                                  ; START OF TRANSIENT PORTION
  9464                                  ; ----------------------------------------------------------------------------
  9465                                  ; SEGMENT - TRANSCODE
  9466                                  ; ----------------------------------------------------------------------------
  9467                                  
  9468                                  ; 18/04/2023
  9469                                  section .TRANGROUP  vstart=0  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) 
  9470                                  
  9471                                  ; 18/04/2023
  9472                                  ;-----------------------------------------------------------------------------
  9473                                  ; TRANSCODE segment offset 0
  9474                                  TRANSIENTSTART:
  9475                                  
  9476                                  	; 31/01/2023
  9477 00000000 00<rep 100h>            	times 256 db 0		; Allow for 100H parameter area
  9478                                  
  9479                                  ;============================================================================
  9480                                  ; TCODE.ASM, MSDOS 6.0, 1991
  9481                                  ;============================================================================
  9482                                  ; 12/10/2018 - Retro DOS v3.0
  9483                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1)
  9484                                  
  9485                                  ;[ORG 100h]
  9486                                  
  9487                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  9488                                  
  9489                                  ; ---------------------------------------------------------------------------
  9490                                  		
  9491                                  	; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9492                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:0100h)
  9493                                  
  9494                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9495                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:0100h)
  9496                                  SETDRV:
  9497 00000100 B40E                    	mov	ah,0Eh
  9498                                  	;mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  9499 00000102 CD21                    	int	21h	; DOS -	SELECT DISK
  9500                                  			; DL = new default drive number
  9501                                  			;		(0 = A, 1 = B, ..)
  9502                                  			; Return: AL = number of logical drives
  9503                                  
  9504                                  ; ---------------------------------------------------------------------------
  9505                                  
  9506                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  9507                                  ; No registers (CS:IP) no flags, nothing.
  9508                                  
  9509                                  TCOMMAND:
  9510 00000104 2E8E1E[159E]            	mov	ds,[cs:RESSEG]
  9511 00000109 B8FFFF                  	mov	ax,-1
  9512 0000010C 8706[4502]              	xchg	ax,[VerVal]
  9513 00000110 83F8FF                  	cmp	ax,-1
  9514 00000113 7404                    	je	short NOSETVER2
  9515 00000115 B42E                    	mov	ah,2Eh
  9516                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  9517 00000117 CD21                    	int	21h	; DOS -	SET VERIFY FLAG
  9518                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  9519                                  NOSETVER2:
  9520 00000119 2EFF1E[139E]            	call	far [cs:HEADCALL]   ; Make sure header fixed
  9521 0000011E 31ED                    	xor	bp,bp		    ; Flag transient not read
  9522 00000120 833E[4302]FF            	cmp	word [SingleCom],-1
  9523 00000125 7505                    	jne	short COMMAND
  9524                                  _$EXITPREP:
  9525 00000127 0E                      	push	cs
  9526 00000128 1F                      	pop	ds
  9527 00000129 E97025                  	jmp	_$EXIT		; Have finished the single command
  9528                                  
  9529                                  ; ---------------------------------------------------------------------------
  9530                                  ;
  9531                                  ; Main entry point from resident portion.
  9532                                  ;
  9533                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  9534                                  ;   just beginning the processing of another command.
  9535                                  ;
  9536                                  ; ---------------------------------------------------------------------------
  9537                                  
  9538                                  ; We are not always sure of the state of the world at this time. We presume
  9539                                  ; worst case and initialize the relevant registers: segments and stack.
  9540                                  
  9541                                  COMMAND:
  9542 0000012C FC                      	cld
  9543 0000012D 8CC8                    	mov	ax,cs
  9544 0000012F FA                      	cli
  9545 00000130 8ED0                    	mov	ss,ax
  9546                                  	;mov	sp,offset TRANGROUP:STACK
  9547                                  				; 07/06/2023
  9548 00000132 BC[B6A9]                	mov	sp,STACK	; 0AF24h for MSDOS 6.22 COMMAND.COM
  9549                                  				; 09854h for MSDOS 5.0 COMMAND.COM
  9550 00000135 FB                      	sti
  9551                                  		
  9552 00000136 8EC0                    	mov	es,ax
  9553                                  		
  9554                                  	; MSDOS 6.0
  9555 00000138 8ED8                    	mov	ds,ax		;AN000; set DS to transient
  9556                                  	;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  9557                                  	;invoke	TSYSLOADMSG	;AN000; preload messages
  9558                                  	; 31/01/2023
  9559 0000013A E8CF54                  	call	TSYSLOADMSG
  9560 0000013D C606[4DA2]00            	mov	byte [append_exec],0 ;AN041; set internal append state off
  9561                                  
  9562                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9563                                  	;mov	ds,[ss:RESSEG]
  9564                                  	; 31/01/2023
  9565 00000142 8E1E[159E]              	mov	ds,[RESSEG]
  9566 00000146 36C606[F19B]80          	mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  9567 0000014C 36C606[749C]80          	mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  9568                                  
  9569                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  9570                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  9571                                  ; I guess not: the only circumstances in which we reload the command processor
  9572                                  ; is after a transient program execution. In this case, we let the current
  9573                                  ; directory lie where it may.
  9574                                  
  9575 00000152 09ED                    	or	bp,bp		; See if just read
  9576 00000154 7409                    	jz	short TESTRDIR	; Not read, check user directory
  9577 00000156 36C706[F29B]010D        	mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  9578 0000015D EB17                    	jmp	short NOSETBUF
  9579                                  TESTRDIR:
  9580 0000015F 803E[3F02]00            	cmp	byte [RestDir],0
  9581 00000164 7410                    	jz	short NOSETBUF	; User directory OK
  9582 00000166 1E                      	push	ds
  9583                                  
  9584                                  ; We have an unusual situation to handle. The user *may* have changed his
  9585                                  ; directory as a result of an internal command that got aborted. Restoring it
  9586                                  ; twice may not help us: the problem may never go away. We just attempt it
  9587                                  ; once and give up.
  9588                                  
  9589 00000167 C606[3F02]00            	mov	byte [RestDir],0 ; Flag users dirs OK
  9590                                  
  9591                                  	; Restore users directory
  9592 0000016C 0E                      	push	cs
  9593 0000016D 1F                      	pop	ds
  9594 0000016E BA[F79C]                	mov	dx,USERDIR1
  9595 00000171 B43B                    	mov	ah,3Bh
  9596                                  	;mov	ah,CHDir ; 3Bh
  9597 00000173 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  9598                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
  9599 00000175 1F                      	pop	ds
  9600                                  NOSETBUF:
  9601 00000176 803E[B602]00            	cmp	byte [PipeFiles],0
  9602 0000017B 740A                    	jz	short NOPCLOSE	; Don't bother if they don't exist
  9603 0000017D 803E[B502]00            	cmp	byte [PipeFlag],0
  9604 00000182 7503                    	jnz	short NOPCLOSE	; Don't del if still piping
  9605 00000184 E8B630                  	call	PIPEDEL
  9606                                  NOPCLOSE:
  9607                                  	;mov	byte [0BE9h],0	; MSDOS 3.3
  9608                                  	; 31/01/2023
  9609 00000187 C606[3702]00            	mov	byte [ExtCom],0 ; Flag internal command
  9610 0000018C 8CC8                    	mov	ax,cs		; Get segment we're in
  9611 0000018E 8ED8                    	mov	ds,ax
  9612 00000190 50                      	push	ax
  9613                                  			; 07/06/2023 (INTERNATVARS addr = STACK addr)
  9614 00000191 BA[B6A9]                	mov	dx,INTERNATVARS ; 0AF24h for MSDOS 6.22 COMMAND.COM
  9615                                  				; 09854h for MSDOS 5.0 COMMAND.COM
  9616 00000194 B80038                  	mov	ax,3800h
  9617                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
  9618 00000197 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  9619                                  			; get current-country info
  9620                                  			; DS:DX	-> buffer for returned info
  9621 00000199 58                      	pop	ax
  9622 0000019A 2B06[179E]              	sub	ax,[TPA]	; AX=size of TPA in paragraphs
  9623 0000019E 53                      	push	bx
  9624 0000019F BB1000                  	mov	bx,16
  9625 000001A2 F7E3                    	mul	bx		; DX:AX=size of TPA in bytes
  9626 000001A4 5B                      	pop	bx
  9627 000001A5 09D2                    	or	dx,dx		; See if over 64K
  9628 000001A7 7403                    	jz	short SAVSIZ	; OK if not
  9629 000001A9 B8FFFF                  	mov	ax,-1		; If so, limit to 65535 bytes
  9630                                  SAVSIZ:
  9631                                  
  9632                                  ; AX is the number of bytes free in the buffer between the resident and the
  9633                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  9634                                  
  9635 000001AC 3D0002                  	cmp	ax,512
  9636 000001AF 7603                    	jbe	short GOTSIZE
  9637                                  	;and	ax,~1FFh
  9638 000001B1 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FF
  9639                                  GOTSIZE:
  9640 000001B4 A3[369E]                	mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  9641 000001B7 8E1E[159E]              	mov	ds,[RESSEG]	; All batch work must use resident seg.
  9642                                  
  9643 000001BB F606[3B02]01            	test	byte [EchoFlag],1 
  9644 000001C0 741E                    	jz	short GETCOM	; Don't do the CRLF
  9645 000001C2 E85730                  	call	SINGLETEST
  9646 000001C5 7219                    	jb	short GETCOM
  9647 000001C7 F606[B502]FF            	test	byte [PipeFlag],0FFh ; -1
  9648 000001CC 7512                    	jnz	short GETCOM
  9649                                  				; G  Don't print prompt in FOR
  9650 000001CE F606[4902]FF            	test	byte [ForFlag],0FFh ; -1
  9651 000001D3 750B                    	jnz	short GETCOM
  9652                                  				; G  Don't print prompt if in batch
  9653 000001D5 F706[E701]FFFF          	test	word [Batch],0FFFFh ; -1
  9654 000001DB 7503                    	jnz	short GETCOM
  9655 000001DD E84129                  	call	CRLF2
  9656                                  
  9657                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9658                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:01E0h
  9659                                  GETCOM:
  9660 000001E0 833E[4302]00            	cmp     word [SingleCom],0
  9661 000001E5 750D                    	jnz     short GETCOM2
  9662 000001E7 F706[E701]FFFF          	test    word [Batch],0FFFFh
  9663 000001ED 7505                    	jnz     short GETCOM2
  9664 000001EF 8026[FE03]EF            	and     byte [Y_Flag],0EFh ; Y/N question overwrite flag ; ~10h
  9665                                  
  9666                                  ;GETCOM:	; MSDOS 5.0 COMMAND.COM
  9667                                  GETCOM2:
  9668 000001F4 C606[4E02]00            	mov	byte [Call_Flag],0 ; G Reset call flags
  9669 000001F9 C606[4F02]00            	mov	byte [Call_Batch_Flag],0
  9670 000001FE B419                    	mov	ah,19h
  9671                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  9672 00000200 CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
  9673 00000202 36A2[299E]              	mov	[ss:CURDRV],al
  9674 00000206 F606[B502]FF            	test	byte [PipeFlag],0FFh ; -1 ; Pipe has highest presedence
  9675 0000020B 7403                    	jz	short NOPIPE
  9676 0000020D E9F830                  	jmp	PIPEPROC	; Continue the pipeline
  9677                                  NOPIPE:
  9678 00000210 F606[3B02]01            	test	byte [EchoFlag],1
  9679 00000215 7417                    	jz	short NOPDRV	; No prompt if echo off
  9680 00000217 E80230                  	call	SINGLETEST
  9681 0000021A 7212                    	jb	short NOPDRV
  9682 0000021C F606[4902]FF            	test	byte [ForFlag],0FFh ; G  Don't print prompt in FOR	
  9683 00000221 750B                    	jnz	short NOPDRV
  9684 00000223 F706[E701]FFFF          	test	word [Batch],0FFFFh ; G  Don't print prompt if in batch
  9685 00000229 750D                    	jnz	short TESTFORBAT
  9686 0000022B E8B520                  	call	PRINT_PROMPT	; Prompt the user
  9687                                  NOPDRV:
  9688 0000022E F606[4902]FF            	test	byte [ForFlag],0FFh ; FOR has next highest precedence
  9689 00000233 7403                    	jz	short TESTFORBAT
  9690 00000235 E9760C                  	jmp	FORPROC		; Continue the FOR
  9691                                  
  9692                                  TESTFORBAT:
  9693 00000238 36C606[C09D]00          	mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  9694 0000023E C606[6402]00            	mov	byte [Re_OutStr],0  ; [0C09h] for MSDOS 3.3 
  9695 00000243 C606[6302]00            	mov	byte [Re_Out_App],0 ; [0C08h] for MSDOS 3.3
  9696 00000248 C606[4802]00            	mov	byte [IfFlag],0	; no more ifs...
  9697 0000024D F706[E701]FFFF          	test	word [Batch],0FFFFh ; Batch has lowest precedence
  9698 00000253 7441                    	jz	short ISNOBAT
  9699                                  
  9700                                  	; 31/01/2023
  9701                                  
  9702                                  	; MSDOS 6.0
  9703                                  
  9704                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  9705                                  
  9706 00000255 06                      	push	es			;AN000; save ES
  9707 00000256 1E                      	push	ds			;AN000; save DS
  9708                                  	;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  9709                                  	; 05/02/2023
  9710 00000257 B80219                  	mov	ax,1902h
  9711 0000025A 8E06[E701]              	mov	es,[Batch]		;AN000; get batch segment
  9712                                  	;mov	di,20h
  9713 0000025E BF2000                  	mov	di,BATCHSEGMENT.BatFile	;AN000; get batch file name
  9714 00000261 0E                      	push	cs			;AN000; get local segment to DS
  9715 00000262 1F                      	pop	ds			;AN000;
  9716                                  	;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  9717 00000263 BA[749C]                	mov	dx,COMBUF
  9718 00000266 CD2F                    	int	2Fh			;AN000; call the shell
  9719                                  		; - Multiplex - DOS 4.x only SHELLB.COM - COMMAND.COM INTERFACE
  9720                                  		; ES:DI -> ASCIZ full filename of current batch file, with at least the
  9721                                  		; final filename element uppercased
  9722                                  		; DS:DX -> buffer for results
  9723                                  	;cmp	al,0FFh
  9724 00000268 3CFF                    	cmp	al,shell_action		;AN000; does shell have a commmand?
  9725 0000026A 1F                      	pop	ds			;AN000; restore DS
  9726 0000026B 07                      	pop	es			;AN000; restore ES
  9727 0000026C 7424                    	jz	short JDOCOM1		;AN000; yes - go process command
  9728                                  
  9729                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9730 0000026E 1E                      	push	ds
  9731 0000026F E8D503                  	call	READBAT			; Continue BATCH
  9732 00000272 1F                      	pop	ds
  9733 00000273 C606[5202]00            	mov	byte [NullFlag],0	;G reset no command flag
  9734 00000278 F706[E701]FFFF          	test	word [Batch],0FFFFh
  9735 0000027E 7512                    	jnz	short JDOCOM1		;G if batch still in progress continue
  9736 00000280 8B1E[5002]              	mov	bx,[Next_Batch]
  9737                                  	; 31/01/2023
  9738 00000284 09DB                    	or	bx,bx
  9739                                  	;cmp	bx,0			;G see if there is a new batch file
  9740 00000286 740A                    	jz	short JDOCOM1		;G no - go do command
  9741 00000288 891E[E701]              	mov	[Batch],bx		;G get segment of next batch file
  9742 0000028C C706[5002]0000          	mov	word [Next_Batch],0	;G reset next batch
  9743                                  JDOCOM1:
  9744 00000292 0E                      	push	cs
  9745 00000293 1F                      	pop	ds
  9746                                  	;jmp	short DOCOM1
  9747                                  	; 07/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  9748 00000294 EB5D                    	jmp	short DOCOM0
  9749                                  ISNOBAT:
  9750 00000296 833E[4302]00            	cmp	word [SingleCom],0
  9751 0000029B 741D                    	jz	short REGCOM
  9752                                  	; 07/06/2023 - MSDOS 6.22 COMMAND.COM
  9753 0000029D 8B36[4102]              	mov	si,[SemiPermCom] ;  MSDOS 6.0
  9754                                  	;mov	si,0FFFFh 	 ;  MSDOS 3.3 & MSDOS 5.0
  9755 000002A1 8736[4302]              	xchg	si,[SingleCom]
  9756 000002A5 BF[769C]                	mov	di,COMBUF+2
  9757 000002A8 31C9                    	xor	cx,cx
  9758                                  SINGLELOOP:
  9759 000002AA AC                      	lodsb
  9760 000002AB AA                      	stosb
  9761 000002AC 41                      	inc	cx
  9762 000002AD 3C0D                    	cmp	al,0Dh
  9763 000002AF 75F9                    	jnz	short SINGLELOOP
  9764 000002B1 49                      	dec	cx
  9765 000002B2 0E                      	push	cs
  9766 000002B3 1F                      	pop	ds
  9767 000002B4 880E[759C]              	mov	[COMBUF+1],cl
  9768                                  
  9769                                  ; do NOT issue a trailing CRLF...
  9770                                  
  9771                                  	;jmp	short DOCOM1
  9772                                  	; 07/06/2023
  9773                                  	; MSDOS 6.22 COMMAND.COM
  9774 000002B8 EB39                    	jmp	short DOCOM0
  9775                                  
  9776                                  	;nop
  9777                                  
  9778                                  	; 31/01/2023 - Retro DOS v4.0 COMMAND.COM
  9779                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:02A6h
  9780                                  
  9781                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9782                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:02BBh
  9783                                  
  9784                                  ; We have a normal command.  
  9785                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  9786                                  ; sometimes they aren't. At this point, we automatically close all spool
  9787                                  ; files and turn on truncation mode.
  9788                                  
  9789                                  REGCOM:
  9790                                  	;mov	ax,(ServerCall shl 8) + 9
  9791                                  	; 31/01/2023
  9792 000002BA B8095D                  	mov	ax,5D09h
  9793                                  	;mov	ax,(SERVERCALL<<8)+9
  9794 000002BD CD21                    	int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  9795                                  	;mov	ax,(ServerCall shl 8) + 8
  9796 000002BF B8085D                  	mov	ax,5D08h
  9797                                  	;mov	ax,(SERVERCALL<<8)+8
  9798 000002C2 B201                    	mov	dl,1
  9799 000002C4 CD21                    	int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  9800                                  			; DL = 00h redirected output is	combined
  9801                                  			;      01h redirected output placed in separate	jobs
  9802                                  			; start	new print job now
  9803 000002C6 0E                      	push	cs
  9804 000002C7 1F                      	pop	ds	; Need local segment to point to buffer
  9805 000002C8 BA[F19B]                	mov	dx,UCOMBUF
  9806                                  
  9807                                  	; MSDOS 6.0
  9808                                  ;	Try to read interactive command line via DOSKey.
  9809                                  ;	If that fails, use DOS Buffered Keyboard Input.
  9810                                  
  9811                                  	; 31/01/2023
  9812 000002CB B81048                  	mov	ax,4810h	; AX = DOSKey Read Line function
  9813 000002CE CD2F                    	int	2Fh
  9814 000002D0 09C0                    	or	ax,ax
  9815 000002D2 7404                    	jz	short GOTCOM	; DOSKey gave us a command line
  9816                                  
  9817 000002D4 B40A                    	mov	ah,0Ah
  9818                                  	;mov	ah,Std_Con_String_Input	; AH = DOS Buffered Keyboard Input
  9819 000002D6 CD21                    	int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  9820                                  			; DS:DX	-> buffer
  9821                                  GOTCOM:
  9822 000002D8 8A0E[F19B]              	mov	cl,[UCOMBUF]
  9823 000002DC 30ED                    	xor	ch,ch
  9824 000002DE 83C103                  	add	cx,3
  9825 000002E1 BE[F19B]                	mov	si,UCOMBUF
  9826 000002E4 BF[749C]                	mov	di,COMBUF
  9827 000002E7 F3A4                    	rep	movsb		; Transfer it to the cooked buffer
  9828                                  
  9829                                  	; -------------
  9830                                  
  9831                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9832                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:02EDh
  9833                                  
  9834 000002E9 E83528                  	call	CRLF2
  9835 000002EC 31C0                    	xor	ax,ax
  9836 000002EE EB06                    	jmp	short DOCOM2
  9837                                  	; -------------
  9838                                  
  9839                                  DOCOM:
  9840 000002F0 E82E28                  	call	CRLF2
  9841                                  
  9842                                  	; -------------
  9843                                  
  9844                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9845                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:02F4h
  9846                                  DOCOM0:
  9847 000002F3 B80100                  	mov	ax,1
  9848                                  DOCOM2:
  9849 000002F6 1E                      	push	ds
  9850 000002F7 8E1E[159E]              	mov     ds,[RESSEG]
  9851 000002FB A3[9B01]                	mov	[cox_Y_option],ax
  9852 000002FE 1F                      	pop	ds
  9853 000002FF BE[749C]                	mov	si,COMBUF
  9854 00000302 8A4C01                  	mov	cl,[si+1]
  9855 00000305 30ED                    	xor	ch,ch
  9856 00000307 83C602                  	add	si,2
  9857 0000030A E82501                  	call	get_cox_y_n_opt
  9858 0000030D 7303                    	jnc	short DOCOM1    ; YES answer
  9859                                  	; 07/06/2023
  9860                                  NULLCOMJ:
  9861 0000030F E90201                  	jmp	NULLCOM         ; NO answer
  9862                                  	; -------------
  9863                                  
  9864                                  	; MSDOS 5.0 & MSDOS 6.0 COMMAND.COM
  9865                                  DOCOM1:
  9866 00000312 E8932B                  	call	PRESCAN		; Cook the input buffer
  9867 00000315 7403                    	jz	short NOPIPEPROC
  9868 00000317 E96D2F                  	jmp	PIPEPROCSTRT	; Fire up the pipe
  9869                                  
  9870                                  	; 07/06/2023
  9871                                  ;NULLCOMJ:
  9872                                  	;jmp	NULLCOM
  9873                                  
  9874                                  NOPIPEPROC:
  9875 0000031A E86832                  	call	PARSELINE
  9876 0000031D 730B                    	jnb	short OKPARSE	; user error? or maybe we goofed?
  9877                                  BADPARSE:
  9878 0000031F 0E                      	push	cs
  9879 00000320 1F                      	pop	ds
  9880 00000321 BA[1692]                	mov	dx,BADNAM_PTR	; 31/01/2023
  9881 00000324 E8FE51                  	call	std_eprintf
  9882 00000327 E9DAFD                  	jmp	TCOMMAND
  9883                                  
  9884                                  OKPARSE:
  9885                                  	;test	byte [ARGV0_ARG_FLAGS],2
  9886                                  	;test	byte [ARG+ARGV_ELE.argflags],2 ; wildcard
  9887                                  	; 01/02/2023
  9888 0000032A F606[69A2]02            	test	byte [ARG+ARGV_ELE.argflags],2
  9889 0000032F 75EE                    	jnz	short BADPARSE	; ambiguous commands not allowed
  9890                                  	;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  9891 00000331 833E[27A5]00            	cmp	word [ARG+ARG_UNIT.argvcnt],0
  9892 00000336 74D7                    	jz	short NULLCOMJ
  9893                                  	;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  9894 00000338 833E[6CA2]00            	cmp	word [ARG+ARGV_ELE.arglen],0
  9895 0000033D 74D0                    	jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  9896                                  
  9897 0000033F BE[769C]                	mov	si,COMBUF+2
  9898 00000342 BF[D19F]                	mov	di,IDLEN
  9899                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9900                                  				; Make FCB with blank scan-off
  9901                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9902 00000345 B80129                  	mov	ax,2901h
  9903 00000348 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9904                                  			; DS:SI	-> string to parse
  9905                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9906                                  			; AL = bit mask	to control parsing
  9907                                  	;mov	bx,[ARG_ARGV]
  9908 0000034A 8B1E[67A2]              	mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  9909 0000034E 807F013A                	cmp	byte [bx+1],':'	; was a drive specified?
  9910 00000352 751B                    	jne	short DRVGD	; no, use default of zero...
  9911 00000354 8A17                    	mov	dl,[bx]		; pick-up drive letter
  9912                                  	;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  9913                                  	;and	dl,~20h
  9914 00000356 80E2DF                  	and	dl,0DFh		; uppercase the sucker
  9915                                  	;sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  9916                                  	; 31/01/2023
  9917 00000359 80EA41                  	sub	dl,'A'
  9918 0000035C 3CFF                    	cmp	al,-1		; See what PARSE said about our drive letter.
  9919 0000035E 740C                    	je	short DRVBADJ	; It was invalid.
  9920                                  	;mov	di,[ARGV0_ARGSTARTEL]
  9921 00000360 8B3E[6AA2]              	mov	di,[ARG+ARGV_ELE.argstartel]
  9922 00000364 803D00                  	cmp	byte [di],0	; is there actually a command there?
  9923 00000367 7506                    	jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  9924 00000369 E994FD                  	jmp	SETDRV		; and set drive to new drive spec
  9925                                  DRVBADJ:
  9926 0000036C E93B2A                  	jmp	DRVBAD
  9927                                  DRVGD:
  9928 0000036F 8A05                    	mov	al,[di]
  9929 00000371 A2[359E]                	mov	[SPECDRV],al
  9930 00000374 B020                    	mov	al,' '
  9931 00000376 B90900                  	mov	cx,9
  9932 00000379 47                      	inc	di
  9933 0000037A F2AE                    	repne	scasb		; Count number of letters in command name
  9934 0000037C B008                    	mov	al,8
  9935 0000037E 28C8                    	sub	al,cl
  9936 00000380 A2[D19F]                	mov	[IDLEN],al	; IDLEN is truly the length
  9937 00000383 BF8100                  	mov	di,81h
  9938 00000386 56                      	push	si
  9939 00000387 BE[769C]                	mov	si,COMBUF+2	; Skip over all leading delims
  9940 0000038A E8A127                  	call	scanoff
  9941                                  
  9942                                  	; 01/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9943                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0356h
  9944                                  
  9945                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9946                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0391h
  9947                                  
  9948                                  	; MSDOS 6.0
  9949                                  ;SR;
  9950                                  ; We are going to skip over the first char always. The logic is that the
  9951                                  ;command tail can never start from the first character. The code below is 
  9952                                  ;trying to figure out the command tail and copy it to the command line 
  9953                                  ;buffer in the PSP. However, if the first character happens to be a switch
  9954                                  ;character and the user given command line is a full 128 bytes, we try to
  9955                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  9956                                  ;char overwrites the code and leads to a crash on future commands.
  9957                                  
  9958 0000038D 46                      	inc	si ;  MSDOS 6.0
  9959                                  
  9960                                  DO_SKIPCOM:
  9961 0000038E AC                      	lodsb			; move command line pointer over
  9962 0000038F E8A427                  	call	DELIM		; pathname -- have to do it ourselves
  9963 00000392 740A                    	jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  9964 00000394 3C0D                    	cmp	al,0Dh		; can't always depend on argv[0].arglen
  9965 00000396 7406                    	jz	short DO_SKIPPED ; to be the same length as the user-
  9966 00000398 3A06[199E]              	cmp	al,[SWITCHAR]	; specified command string
  9967 0000039C 75F0                    	jnz	short DO_SKIPCOM 
  9968                                  DO_SKIPPED:
  9969 0000039E 4E                      	dec	si
  9970 0000039F 31C9                    	xor	cx,cx
  9971                                  COMTAIL:
  9972 000003A1 AC                      	lodsb
  9973 000003A2 AA                      	stosb			; Move command tail to 80h
  9974 000003A3 3C0D                    	cmp	al,0Dh
  9975 000003A5 E0FA                    	loopne	COMTAIL
  9976 000003A7 4F                      	dec	di
  9977 000003A8 89FD                    	mov	bp,di
  9978 000003AA F6D1                    	not	cl
  9979 000003AC 880E8000                	mov	[80h],cl
  9980 000003B0 5E                      	pop	si
  9981                                  ;-----
  9982                                  ; Some of these comments are sadly at odds with this brave new code.
  9983                                  ;-----
  9984                                  ; If the command has 0 parameters must check here for
  9985                                  ; any switches that might be present.
  9986                                  ; SI -> first character after the command.
  9987                                  
  9988                                  	;mov	di,arg.argv[0].argsw_word
  9989                                  	;mov	di,[ARGV0_ARGSW_WORD]
  9990 000003B1 8B3E[6EA2]              	mov	di,[ARG+ARGV_ELE.argsw_word]
  9991 000003B5 893E[2C9E]              	mov	[COMSW],di	; ah yes, the old addressing mode problem...
  9992                                  	;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
  9993                                  				; s = argv[1];
  9994                                  	;mov	si,[ARGV1_ARGPOINTER]
  9995 000003B9 8B36[72A2]              	mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
  9996 000003BD 09F6                    	or	si,si		;   if (s == NULL)
  9997 000003BF 7502                    	jnz	short DOPARSE	;	s = bp; (buffer end)
  9998 000003C1 89EE                    	mov	si,bp
  9999                                  DOPARSE:
 10000 000003C3 BF5C00                  	mov	di,FCB ; 5Ch
 10001                                  	;mov	ax,(Parse_File_Descriptor shl 8) or 01h
 10002                                  	; 01/02/2023
 10003 000003C6 B80129                  	mov	ax,2901h
 10004                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
 10005 000003C9 CD21                    	int	21h	; DOS -	PARSE FILENAME
 10006                                  			; DS:SI	-> string to parse
 10007                                  			; ES:DI	-> buffer to fill with unopened	FCB
 10008                                  			; AL = bit mask	to control parsing
 10009 000003CB A2[2A9E]                	mov	[PARM1],al	; Save result of parse
 10010                                  	;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
 10011                                  	;mov	di,[ARGV1_ARGSW_WORD]
 10012 000003CE 8B3E[79A2]              	mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
 10013 000003D2 893E[2E9E]              	mov	[ARG1S],di
 10014                                  	;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
 10015                                  				; s = argv[2];
 10016                                  	;mov	si,[ARGV2_ARGPOINTER]
 10017 000003D6 8B36[7DA2]              	mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
 10018 000003DA 09F6                    	or	si,si		; if (s == NULL)
 10019 000003DC 7502                    	jnz	short DOPARSE2
 10020 000003DE 89EE                    	mov	si,bp		;     s = bp; (buffer end)
 10021                                  DOPARSE2:			
 10022 000003E0 BF6C00                  	mov	di,FCB+10h ; 6Ch
 10023                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
 10024 000003E3 B80129                  	mov	ax,2901h
 10025                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
 10026 000003E6 CD21                    	int	21h	; DOS -	PARSE FILENAME
 10027                                  			; DS:SI	-> string to parse
 10028                                  			; ES:DI	-> buffer to fill with unopened	FCB
 10029                                  			; AL = bit mask	to control parsing
 10030 000003E8 A2[2B9E]                	mov	[PARM2],al	; Save result
 10031                                  	;mov	di,[ARGV2_ARGSW_WORD]
 10032                                  	;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
 10033 000003EB 8B3E[84A2]              	mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
 10034 000003EF 893E[309E]              	mov	[ARG2S],di
 10035                                  	;mov	di,[ARGV0_ARGSW_WORD]
 10036                                  	;mov	di,arg.argv[0].argsw_word
 10037 000003F3 8B3E[6EA2]              	mov	di,[ARG+ARGV_ELE.argsw_word]
 10038 000003F7 F7D7                    	not	di		; ARGTS doesn't include the flags
 10039                                  	;and	di,[ARG_ARGSWINFO] ; from COMSW...
 10040                                  	;and	di,arg.argswinfo	
 10041 000003F9 233E[29A5]              	and	di,[ARG+ARG_UNIT.argswinfo]
 10042 000003FD 893E[329E]              	mov	[ARGTS],di
 10043                                  
 10044 00000401 A0[D19F]                	mov	al,[IDLEN]
 10045 00000404 8A16[359E]              	mov	dl,[SPECDRV]
 10046 00000408 08D2                    	or	dl,dl		; if a drive was specified...
 10047 0000040A 7505                    	jnz	short EXTERNALJ1 ; it MUST be external, by this time
 10048 0000040C FEC8                    	dec	al		; (I don't know why -- old code did it)
 10049 0000040E E9EC28                  	jmp	FNDCOM		; otherwise, check internal com table
 10050                                  EXTERNALJ1:
 10051 00000411 E9EE29                  	jmp	EXTERNAL
 10052                                  NULLCOM:
 10053 00000414 8E1E[159E]              	mov	ds,[RESSEG]
 10054 00000418 F706[E701]FFFF          	test	word [Batch],0FFFFh ; -1 ;G Are we in a batch file?
 10055 0000041E 7405                    	jz	short NOSETFLAG	  ;G only set flag if in batch
 10056 00000420 C606[5202]01            	mov	byte [NullFlag],1 ;G set flag to indicate no command
 10057                                  	;mov	byte [NullFlag],nullcommand ; 1
 10058                                  NOSETFLAG:
 10059 00000425 833E[4302]FF            	cmp	word [SingleCom],0FFFFh ; -1
 10060 0000042A 7403                    	je	short EXITJ
 10061 0000042C E9B1FD                  	jmp	GETCOM
 10062                                  EXITJ:
 10063 0000042F E9F5FC                  	jmp	_$EXITPREP
 10064                                  
 10065                                  ; 07/06/2023
 10066                                  ; ---------------------------------------------------------------------------
 10067                                  ; MSDOS 6.2(2) COMMAND.COM procedure only !
 10068                                  ; -----------------------------------------
 10069                                  ; Hex-Rays IDA / disassembled source code ! modified for NASM by Erdogan Tan
 10070                                  ; ---------------------------------------------------------------------------
 10071                                  
 10072                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 10073                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0436h
 10074                                  
 10075                                  get_cox_y_n_opt:
 10076 00000432 E339                    	jcxz	ccydp4		; empty	input buffer
 10077                                  ccydp0:
 10078 00000434 803C0D                  	cmp	byte [si],0Dh
 10079 00000437 7434                    	je	short ccydp4
 10080 00000439 803C0A                  	cmp	byte [si],0Ah
 10081 0000043C 742F                    	je	short ccydp4
 10082 0000043E 06                      	push	es
 10083 0000043F 8E06[159E]              	mov	es,[RESSEG]
 10084 00000443 26A0[FE03]              	mov	al,[es:Y_Flag]
 10085 00000447 A810                    	test	al,10h		; bit 1	= 1 -> Y/N answer is needed
 10086 00000449 7421                    	jz	short ccydp3 ; cf=0 ; 07/06/2023
 10087 0000044B 26803E[4F02]01          	cmp	byte [es:Call_Batch_Flag],1 ; (in) Batch file ?
 10088 00000451 7419                    	je	short ccydp3	; yes, don't check for ESCAPE
 10089 00000453 A840                    	test	al,40h		; ESCAPE status
 10090                                  				; (bit 4 is zero if Y/N	is escaped)
 10091 00000455 7417                    	jz	short ccydp5
 10092                                  ccydp1:
 10093 00000457 26F706[E701]FFFF        	test	word [es:Batch],0FFFFh
 10094 0000045E 740B                    	jz	short ccydp2
 10095 00000460 268E06[E701]            	mov	es,[es:Batch]
 10096                                  	;mov	byte [es:2],1 ; [es:BATCHSEGMENT.BatchEOF]
 10097 00000465 26C606020001            	mov	byte [es:BATCHSEGMENT.BatchEOF],1
 10098                                  ccydp2:
 10099 0000046B F9                      	stc
 10100                                  ccydp3:		; 07/06/2023 ; cf = 0
 10101 0000046C 07                      	pop	es
 10102                                  ccydp4:		; 07/06/2023 ; cf = 0
 10103 0000046D C3                      	retn
 10104                                  
 10105                                  ;ccydp3:
 10106                                  ;	pop	es
 10107                                  ;ccydp4:
 10108                                  ;	clc
 10109                                  ;	retn
 10110                                  
 10111                                  ccydp5:
 10112 0000046E 89F2                    	mov	dx,si
 10113 00000470 BB0200                  	mov	bx,2
 10114 00000473 B440                    	mov	ah,40h
 10115 00000475 CD21                    	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 10116                                  			; BX = file handle, CX = number	of bytes to write
 10117                                  			; DS:DX -> buffer
 10118 00000477 BA[3894]                	mov	dx,cox_Y_quest_ptr ; msg number	pointer	of ' [Y/N]?'
 10119                                  				   ; (is 1082)
 10120 0000047A E8A850                  	call	std_eprintf
 10121 0000047D 1E                      	push	ds
 10122 0000047E B83B04                  	mov	ax,1083	; cox_Y_answer number (overwrite Y/N answer letter)
 10123 00000481 B6FF                    	mov	dh,0FFh		; utility_msg_class
 10124 00000483 E88C51                  	call	TSYSGETMSG
 10125                                  	;mov	cx,'NY' ; MASM word format
 10126                                  	; NASM word format
 10127 00000486 B9594E                  	mov	cx,'YN'        ; 'YN' Yes/No (CL=Y)
 10128 00000489 7202                    	jc	short ccydp6
 10129 0000048B 8B0C                    	mov	cx,[si]
 10130                                  ccydp6:
 10131 0000048D 1F                      	pop	ds
 10132                                  ccydp7:
 10133 0000048E B408                    	mov	ah,8
 10134 00000490 CD21                    	int	21h	; DOS -	KEYBOARD INPUT,	NO ECHO
 10135                                  			; Return: AL = character
 10136 00000492 84C0                    	test	al,al
 10137 00000494 7510                    	jnz	short ccydp8
 10138 00000496 B408                    	mov	ah,8
 10139 00000498 CD21                    	int	21h	; DOS -	KEYBOARD INPUT,	NO ECHO
 10140                                  			; Return: AL = character
 10141 0000049A 3C3F                    	cmp	al,'?'
 10142 0000049C 75F0                    	jne	short ccydp7
 10143 0000049E 26800E[FE03]40          	or	byte [es:Y_Flag],40h ; bit 4, question flag
 10144 000004A4 EBB1                    	jmp	short ccydp1
 10145                                  ccydp8:
 10146 000004A6 3C1B                    	cmp	al,1Bh		; ESCAPE ?
 10147 000004A8 7509                    	jne	short ccydp9
 10148 000004AA 268026[FE03]EF          	and	byte [es:Y_Flag],0EFh ; (ESCAPE) Clear bit 4 ; ~10h
 10149                                  	;jmp	short ccydp12
 10150                                  	; 07/06/2023
 10151 000004B0 9C                      	pushf
 10152 000004B1 EB14                    	jmp	short ccydp12
 10153                                  ccydp9:
 10154 000004B3 24DF                    	and	al,0DFh		; uppercase
 10155 000004B5 38E8                    	cmp	al,ch		; NO character (N)
 10156 000004B7 7503                    	jne	short ccydp10
 10157 000004B9 F9                      	stc
 10158 000004BA EB04                    	jmp	short ccydp11	; cf = 1 -> overwrite NO answer
 10159                                  ccydp10:
 10160 000004BC 38C8                    	cmp	al,cl		; YES character	(Y)
 10161 000004BE 75CE                    	jne	short ccydp7
 10162                                  ccydp11:
 10163 000004C0 9C                      	pushf			; cf = 0 -> overwrite YES answer
 10164 000004C1 88C2                    	mov	dl,al
 10165 000004C3 B402                    	mov	ah,2
 10166 000004C5 CD21                    	int	21h	; DOS -	DISPLAY	OUTPUT
 10167                                  			; DL = character to send to standard output
 10168                                  	; 07/06/2023
 10169                                  	;popf
 10170                                  ccydp12:
 10171                                  	;pushf
 10172 000004C7 E85726                  	call	CRLF2
 10173 000004CA 9D                      	popf
 10174 000004CB 07                      	pop	es
 10175 000004CC C3                      	retn
 10176                                  
 10177                                  ;============================================================================
 10178                                  ; MSHALO.ASM, MSDOS 6.0, 1991
 10179                                  ;============================================================================
 10180                                  ; 12/10/2018 - Retro DOS v3.0
 10181                                  
 10182                                  ; 05/02/2023 - Retro DOS v5.0 (& v4.1) COMMAND.COM
 10183                                  
 10184                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
 10185                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
 10186                                  ;   there is a header that describes a block of rom program.  This header
 10187                                  ;   contains information needed to initialize a module and to provide PCDOS
 10188                                  ;   with a set of reserved names for execution.
 10189                                  ;
 10190                                  ;   This header has the following format:
 10191                                  ;
 10192                                  ;   rom_header	STRUC
 10193                                  ;	Signature1  DB	55h
 10194                                  ;	Signature2  DB	AAh
 10195                                  ;	rom_length  DB	?		; number of 512 byte pieces
 10196                                  ;	init_jmp    DB	3 dup (?)
 10197                                  ;	name_list   name_struc <>
 10198                                  ;   rom_header	ENDS
 10199                                  ;
 10200                                  ;   name_struc	STRUC
 10201                                  ;	name_len    DB	?
 10202                                  ;	name_text   DB	? DUP (?)
 10203                                  ;	name_jmp    DB	3 DUP (?)
 10204                                  ;   name_struc	ENDS
 10205                                  ;
 10206                                  ;   The name list is a list of names that are reserved by a particular section
 10207                                  ;   of a module.  This list of names is terminated by a null name (length
 10208                                  ;   is zero).
 10209                                  ;
 10210                                  ;   Consider now, the PCDOS action when a user enters a command:
 10211                                  ;
 10212                                  ;	COMMAND.COM has control.
 10213                                  ;	o   If location FFFFEh has FDh then
 10214                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
 10215                                  ;		    by AAh, stop scan if we get above or = F0000H
 10216                                  ;	o	When we've found one, compare the name entered by the user
 10217                                  ;		    with the one found in the rom.  If we have a match, then
 10218                                  ;		    set up the environment for execution and do a long jump
 10219                                  ;		    to the near jump after the found name.
 10220                                  ;	o	If no more names in the list, then continue scanning the module
 10221                                  ;		    for more 55h followed by AAh.
 10222                                  ;	o   We get to this point only if there is no matching name in the
 10223                                  ;		rom.  We now look on disk for the command.
 10224                                  ;
 10225                                  ;   This gives us the flexibility to execute any rom cartridge without having
 10226                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
 10227                                  ;   want to be invisible to the DOS should not have any names in their lists
 10228                                  ;   (i.e. they have a single null name).
 10229                                  ;
 10230                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
 10231                                  ;   Clearly this version will be available on disk.  How does a user actually
 10232                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
 10233                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
 10234                                  ;   solution:
 10235                                  ;
 10236                                  ;   o	Keep things consistent and force the user to have his software named
 10237                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
 10238                                  
 10239                                  struc ROM_HEADER
 10240 00000000 ??                          .signature1: resb 1
 10241 00000001 ??                          .signature2: resb 1
 10242 00000002 ??                          .rom_length: resb 1
 10243 00000003 ??????                      .init_jmp:	 resb 3
 10244 00000006 ??                          .name_list:	 resb 1
 10245                                      .size:
 10246                                  endstruc
 10247                                  
 10248                                  struc NAME_STRUC
 10249 00000000 ??                          .name_len:	resb 1
 10250 00000001 ??                          .name_text:	resb 1
 10251 00000002 ??????                      .name_jmp:	resb 3
 10252                                      .size:	
 10253                                  endstruc
 10254                                  
 10255                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
 10256                                  
 10257                                  ; =============== S U B	R O U T	I N E =======================================
 10258                                  
 10259                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
 10260                                  
 10261                                  ; 05/02/2023
 10262                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:03FBh
 10263                                  
 10264                                  ; 07/06/2023
 10265                                  ; MSDOS 6.22 COMMAND.COM - TRANGROUP:04D5h
 10266                                  
 10267                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
 10268                                  
 10269                                  ROM_SCAN:
 10270 000004CD 06                      	push	es
 10271 000004CE 56                      	push	si
 10272 000004CF 57                      	push	di
 10273 000004D0 51                      	push	cx
 10274 000004D1 50                      	push	ax
 10275 000004D2 53                      	push	bx
 10276                                  
 10277                                  	; check for PC Jr signature in rom
 10278                                  
 10279 000004D3 B800F0                  	mov	ax,0F000h
 10280 000004D6 8EC0                    	mov	es,ax
 10281 000004D8 26803EFEFFFD            	cmp	byte [es:0FFFEh],0FDh
 10282 000004DE 7408                    	je	short SCAN_IT
 10283                                  NO_ROM:
 10284 000004E0 F8                      	clc
 10285                                  ROM_RET:
 10286 000004E1 5B                      	pop	bx
 10287 000004E2 58                      	pop	ax
 10288 000004E3 59                      	pop	cx
 10289 000004E4 5F                      	pop	di
 10290 000004E5 5E                      	pop	si
 10291 000004E6 07                      	pop	es
 10292 000004E7 C3                      	retn
 10293                                  
 10294                                  	; start scanning at C000h
 10295                                  SCAN_IT:
 10296 000004E8 B800C0                  	mov	ax,0C000h
 10297                                  SCAN_ONE:
 10298 000004EB 8EC0                    	mov	es,ax
 10299 000004ED 31FF                    	xor	di,di
 10300                                  
 10301                                  	; check for a valid header
 10302                                  SCAN_MODULE:
 10303 000004EF 26813D55AA              	cmp	word [es:di],0AA55h
 10304 000004F4 740A                    	je	short SCAN_LIST
 10305 000004F6 058000                  	add	ax,80h
 10306                                  SCAN_END:
 10307 000004F9 3D00F0                  	cmp	ax,0F000h
 10308 000004FC 72ED                    	jb	short SCAN_ONE
 10309 000004FE EBE0                    	jmp	short NO_ROM
 10310                                  
 10311                                  	; trundle down list of names
 10312                                  SCAN_LIST:
 10313                                  	;mov	bl,[es:di+2]	; number of 512-byte jobbers
 10314 00000500 268A5D02                	mov	bl,[es:di+ROM_HEADER.rom_length]
 10315 00000504 30FF                    	xor	bh,bh		; nothing in the high byte
 10316 00000506 D1E3                    	shl	bx,1
 10317 00000508 D1E3                    	shl	bx,1		; number of paragraphs
 10318 0000050A 83C37F                  	add	bx,7Fh
 10319 0000050D 83E380                  	and	bx,0FF80h	; round to 2k
 10320                                  	;mov	di,6
 10321                                  	; 05/05/2023
 10322 00000510 BF0600                  	mov	di,ROM_HEADER.name_list
 10323                                  	;nop
 10324                                  SCAN_NAME:
 10325 00000513 268A0D                  	mov	cl,[es:di]	; length of name
 10326 00000516 47                      	inc	di		; point to name
 10327 00000517 30ED                    	xor	ch,ch
 10328 00000519 09C9                    	or	cx,cx		; zero length name
 10329 0000051B 7504                    	jnz	short SCAN_TEST	; nope... compare
 10330 0000051D 01D8                    	add	ax,bx		; yep, skip to next block
 10331 0000051F EBD8                    	jmp	short SCAN_END
 10332                                  
 10333                                  	; compare a single name
 10334                                  SCAN_TEST:
 10335 00000521 89D6                    	mov	si,dx
 10336 00000523 46                      	inc	si
 10337 00000524 F3A6                    	repe	cmpsb		 ; compare name
 10338 00000526 7407                    	jz	short SCAN_FOUND ; success!
 10339                                  SCAN_NEXT:
 10340 00000528 01CF                    	add	di,cx		; failure, next name piece
 10341 0000052A 83C703                  	add	di,3
 10342 0000052D EBE4                    	jmp	short SCAN_NAME
 10343                                  
 10344                                  	; found a name. save entry location
 10345                                  SCAN_FOUND:	
 10346 0000052F 803C3F                  	cmp	byte [si],'?'
 10347 00000532 7405                    	je	short SCAN_SAVE
 10348 00000534 803C20                  	cmp	byte [si],' '
 10349 00000537 75EF                    	jne	short SCAN_NEXT
 10350                                  SCAN_SAVE:
 10351 00000539 2E8C06[CEA0]            	mov	[cs:ROM_CS],es
 10352 0000053E 2E893E[CCA0]            	mov	[cs:ROM_IP],di
 10353 00000543 F9                      	stc
 10354 00000544 EB9B                    	jmp	short ROM_RET
 10355                                  
 10356                                  ; ---------------------------------------------------------------------------
 10357                                  
 10358                                  ; execute a rom-placed body of code. allocate largest block
 10359                                  
 10360                                  ROM_EXEC:
 10361 00000546 BBFFFF                  	mov	bx,0FFFFh
 10362                                  	; 05/02/2023
 10363 00000549 B448                    	mov	ah,48h
 10364                                  	;mov	ah,ALLOC ; 48h
 10365 0000054B CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10366                                  			; BX = number of 16-byte paragraphs desired
 10367 0000054D B448                    	mov	ah,48h
 10368                                  	;mov	ah,ALLOC ; 48h
 10369 0000054F CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10370                                  			; BX = number of 16-byte paragraphs desired
 10371 00000551 53                      	push	bx
 10372 00000552 50                      	push	ax
 10373                                  
 10374                                  	; set terminate addresses
 10375                                  
 10376 00000553 B82225                  	mov	ax,2522h
 10377                                  	;;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
 10378                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
 10379 00000556 1E                      	push	ds
 10380 00000557 2E8E1E[159E]            	mov	ds,[cs:RESSEG]
 10381                                  	;mov	dx,offset RESGROUP:EXEC_WAIT
 10382                                  	;mov	dx,131h ; MSDOS 3.3
 10383                                  	; 05/02/2023
 10384                                  	;mov	dx,0D6Bh ; MSDOS 5.0
 10385 0000055C BA[E90C]                	mov	dx,Exec_Wait
 10386 0000055F CD21                    	int	21h	; DOS -	SET INTERRUPT VECTOR
 10387                                  			; AL = interrupt number
 10388                                  			; DS:DX	= new vector to	be used	for specified interrupt
 10389 00000561 8CDA                    	mov	dx,ds
 10390 00000563 8EC2                    	mov	es,dx
 10391 00000565 1F                      	pop	ds
 10392                                  		
 10393                                  	; and create program header and dup all jfn's
 10394                                  
 10395 00000566 5A                      	pop	dx
 10396 00000567 B455                    	mov	ah,55h
 10397                                  	;mov	ah,DUP_PDB ; 55h
 10398 00000569 CD21                    	int	21h	; DOS -	2+ internal - CREATE PSP
 10399                                  			; DX = segment number at which to set up PSP
 10400                                  			; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
 10401                                  		
 10402                                  	; set up dma address
 10403                                  
 10404 0000056B 8EDA                    	mov	ds,dx
 10405 0000056D BA8000                  	mov	dx,80h
 10406 00000570 B41A                    	mov	ah,1Ah
 10407                                  	;mov	ah,Set_DMA ; 1Ah
 10408 00000572 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 10409                                  			; DS:DX	-> disk	transfer buffer
 10410                                  
 10411                                  	; copy in environment info
 10412                                  
 10413 00000574 26A1[DC03]              	mov	ax,[es:EnvirSeg]
 10414                                  	;mov	[2Ch],ax
 10415 00000578 A32C00                  	mov	[PDB.ENVIRON],ax
 10416                                  
 10417                                  	; set up correct size of block
 10418                                  
 10419 0000057B 5B                      	pop	bx		; BX has size, DS has segment
 10420 0000057C 8CDA                    	mov	dx,ds
 10421 0000057E 01DA                    	add	dx,bx
 10422                                  	;mov	[2],dx
 10423 00000580 89160200                	mov	[PDB.BLOCK_LEN],dx
 10424                                  
 10425                                  	; change ownership of block
 10426                                  
 10427 00000584 8CDA                    	mov	dx,ds
 10428 00000586 4A                      	dec	dx
 10429 00000587 8EDA                    	mov	ds,dx
 10430 00000589 42                      	inc	dx	
 10431                                  	;mov	[1],dx
 10432 0000058A 89160100                	mov	[ARENA.owner],dx
 10433 0000058E 8EDA                    	mov	ds,dx
 10434                                  
 10435                                  	; set up correct stack
 10436                                  
 10437 00000590 81FB0010                	cmp	bx,1000h
 10438 00000594 7202                    	jb	short GOT_STACK
 10439 00000596 31DB                    	xor	bx,bx
 10440                                  GOT_STACK:
 10441 00000598 B104                    	mov	cl,4
 10442 0000059A D3E3                    	shl	bx,cl
 10443 0000059C 8CDA                    	mov	dx,ds
 10444 0000059E 8ED2                    	mov	ss,dx
 10445 000005A0 89DC                    	mov	sp,bx
 10446 000005A2 31C0                    	xor	ax,ax
 10447 000005A4 50                      	push	ax
 10448                                  
 10449                                  	; set up initial registers and go to the guy
 10450                                  
 10451 000005A5 F7D0                    	not	ax
 10452 000005A7 2EFF36[CEA0]            	push	word [cs:ROM_CS]
 10453 000005AC 2EFF36[CCA0]            	push	word [cs:ROM_IP]
 10454 000005B1 8EC2                    	mov	es,dx
 10455 000005B3 CB                      	retf	; far return
 10456                                  
 10457                                  ;============================================================================
 10458                                  ; TBATCH.ASM, MSDOS 6.0, 1991
 10459                                  ;============================================================================
 10460                                  ; 12/10/2018 - Retro DOS v3.0
 10461                                  
 10462                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
 10463                                  
 10464                                  ; =============== S U B	R O U T	I N E =======================================
 10465                                  
 10466                                  ;Break	<PromptBat - Open or wait for batch file>
 10467                                  
 10468                                  ; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10469                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:04E2h
 10470                                  
 10471                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 10472                                  ; MSDOS 6.22 COMMAND.COM - TRANGROUP:05BCh
 10473                                  
 10474                                  ; Open the batch file. If we cannot find the batch file. If the media is
 10475                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
 10476                                  ; file. Leave segment registers alone.
 10477                                  
 10478                                  PROMPTBAT:
 10479 000005B4 E84808                  	call	BATOPEN
 10480 000005B7 7201                    	jc	short PROMPTBAT1
 10481 000005B9 C3                      	retn
 10482                                  PROMPTBAT1:
 10483                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10484                                  	; MSDOS 6.0 COMMAND.COM
 10485 000005BA 83FA02                  	cmp	dx,ERROR_FILE_NOT_FOUND ;AN022; Ask for diskette if file not found
 10486 000005BD 740A                    	je	short BAT_REMCHECK	;AN022;
 10487 000005BF 83FA03                  	cmp	dx,ERROR_PATH_NOT_FOUND ;AN022; Ask for diskette if path not found
 10488 000005C2 7405                    	je	short BAT_REMCHECK	;AN022; Otherwise, issue message and exit
 10489                                  	;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
 10490 000005C4 E83500                  	call	output_batch_name
 10491 000005C7 EB13                    	jmp	short BATDIE		;AN022;
 10492                                  
 10493                                  	; 05/02/2023
 10494                                  	; MSDOS 3.3 COMMAND.COM
 10495                                  	;cmp	dx,ACCDENPTR
 10496                                  	;jz	short BATDIE
 10497                                  
 10498                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10499                                  BAT_REMCHECK:				;AN022; Go see if media is removable
 10500 000005C9 2EFF1E[1F9E]            	call	far [cs:RCH_ADDR]	; DX has error number
 10501 000005CE 7417                    	jz	short ASKFORBAT		; Media is removable
 10502                                  
 10503                                  ; The media is not changeable. Turn everything off.
 10504                                  
 10505 000005D0 E83D0B                  	call	FOROFF
 10506 000005D3 E8E22E                  	call	PipeOff
 10507 000005D6 A2[4802]                	mov	[IfFlag],al	; No If in progress.	
 10508 000005D9 BA[1092]                	mov	dx,BADBAT_PTR
 10509                                  BATDIE:
 10510 000005DC E8F003                  	call	BATCHOFF
 10511 000005DF 0E                      	push	cs
 10512 000005E0 1F                      	pop	ds
 10513                                  	;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
 10514                                  	; 05/02/2023
 10515 000005E1 E8414F                  	call	std_eprintf	; MSDOS 6.0
 10516                                  	;call	STD_PRINTF	; MSDOS 3.3
 10517                                  
 10518                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
 10519                                  
 10520 000005E4 E91DFB                  	jmp	TCOMMAND
 10521                                  
 10522                                  ; Ask the user to reinsert the batch file
 10523                                  
 10524                                  ASKFORBAT:
 10525 000005E7 1E                      	push	ds
 10526 000005E8 0E                      	push	cs
 10527 000005E9 1F                      	pop	ds
 10528                                  
 10529                                  	; MSDOS 6.0
 10530                                  	;mov	dx,offset TRANGROUP:NEEDBAT_ptr  ;AN022;
 10531 000005EA BA[1392]                	mov	dx,NEEDBAT_PTR
 10532                                  	;invoke	std_eprintf	 	;Prompt for batch file on stderr
 10533                                  	; 05/02/2023
 10534 000005ED E8354F                  	call	std_eprintf
 10535                                  	;mov	dx,offset trangroup:pausemes_ptr
 10536 000005F0 BA[8592]                	mov	dx,PAUSEMES_PTR
 10537                                  	;invoke std_eprintf		;AN000; get second part of message
 10538 000005F3 E82F4F                  	call	std_eprintf
 10539                                  					;AN000; print it to stderr
 10540                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10541                                  	;call	STD_EPRINTF
 10542 000005F6 E82E00                  	call	GETKEYSTROKE
 10543 000005F9 1F                      	pop	ds
 10544 000005FA EBB8                    	jmp	short PROMPTBAT
 10545                                  
 10546                                  
 10547                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10548                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:052Ah
 10549                                  
 10550                                  	; MSDOS 6.0
 10551                                  ;****************************************************************
 10552                                  ;*
 10553                                  ;* ROUTINE:	Output_batch_name
 10554                                  ;*
 10555                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
 10556                                  ;*
 10557                                  ;* INPUT:	DX - extended error number
 10558                                  ;*
 10559                                  ;* OUTPUT:	Ready to call print routine
 10560                                  ;*
 10561                                  ;****************************************************************
 10562                                  ;
 10563                                  ;public	output_batch_name		;AN022;
 10564                                  
 10565                                  output_batch_name:	;proc near	;AN022;
 10566                                  
 10567 000005FC 1E                      	push	ds			;AN022; save resident segment
 10568 000005FD 8E1E[E701]              	mov	ds,[Batch]		;AN022; get batch file segment
 10569                                  	;assume	DS:nothing		;AN022;
 10570                                  	;;mov	SI,BatFile		;AN022; get offset of batch file
 10571                                  	; 05/02/2023
 10572                                  	;mov	si,20h
 10573                                  	; 24/04/2023
 10574 00000601 BE2000                  	mov	si,BATCHSEGMENT.BatFile
 10575                                  	;invoke	dstrlen 		;AN022; get length of string
 10576 00000604 E8B52B                  	call	dstrlen
 10577                                  	;mov	di,offset Trangroup:bwdbuf
 10578                                  					;AN022; target for batch name
 10579 00000607 BF[50A0]                	mov	di,BWDBUF
 10580 0000060A F3A4                    	rep	movsb			;AN022; move the name
 10581                                  
 10582 0000060C 0E                      	push	cs			;AN022; get local segment
 10583 0000060D 1F                      	pop	ds			;AN022;
 10584                                  	;assume	DS:trangroup		;AN022;
 10585                                  	; 05/02/2023
 10586 0000060E 8916[F391]              	mov	[extend_buf_ptr],dx	;AN022; put message number in block
 10587                                  	;mov	byte [msg_disp_class],1
 10588 00000612 C606[F191]01            	mov	byte [msg_disp_class],ext_msg_class
 10589                                  					;AN022; set up extended error msg class
 10590                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 10591 00000617 BA[F391]                	mov	dx,extend_buf_ptr	
 10592                                  					;AN022; get extended message pointer
 10593                                  	;mov	string_ptr_2,offset trangroup:bwdbuf 
 10594 0000061A C706[B7A0][50A0]        	mov	word [string_ptr_2],BWDBUF	
 10595                                  					;AN022; point to substitution
 10596                                  	;mov	byte [extend_buf_sub],1
 10597 00000620 C606[F591]01            	mov	byte [extend_buf_sub],one_subst
 10598                                  					;AN022; set up for one subst
 10599 00000625 1F                      	pop	ds			;AN022; restore data segment
 10600 00000626 C3                      	retn				;AN022; return
 10601                                  
 10602                                  ;output_batch_name    endp		;AN022;
 10603                                  
 10604                                  
 10605                                  ; =============== S U B	R O U T	I N E =======================================
 10606                                  
 10607                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
 10608                                  
 10609                                  ; Read the next keystroke. Since there may be several characters in the queue
 10610                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
 10611                                  ; AFTER waiting.
 10612                                  
 10613                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10614                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0555h
 10615                                  
 10616                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 10617                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:062Fh
 10618                                  
 10619                                  GETKEYSTROKE:
 10620                                  	; 05/02/2023
 10621                                  	; MSDOS 3.3
 10622                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
 10623                                  	;;mov	ax,0C08h
 10624                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
 10625                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10626                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10627                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10628                                  	;;mov	ax,0C00h
 10629                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
 10630                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10631                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10632                                  	;retn
 10633                                  
 10634                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10635                                  	; MSDOS 6.0
 10636 00000627 52                      	push	dx			;AN000;  3/3/KK
 10637                                  	;mov	ax,(ECS_call SHL 8) OR GetInterimMode
 10638                                  					;AN000;  3/3/KK
 10639 00000628 B80263                  	mov	ax,6302h
 10640 0000062B CD21                    	int	21h			;AN000;  3/3/KK
 10641                                  		; DOS - 3.2+ only - GET KOREAN (HONGEUL) INPUT MODE
 10642                                  	
 10643 0000062D 52                      	push	dx			;AN000;  save interim state 3/3/KK
 10644                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10645                                  					;AN000;  3/3/KK
 10646 0000062E B80163                  	mov	ax,6301h
 10647 00000631 B201                    	mov	dl,1
 10648                                  	;mov	dl,InterimMode		;AN000;  3/3/KK
 10649 00000633 CD21                    	int	21h			;AN000;  3/3/KK
 10650                                  		; DOS - 3.2+ only - SET KOREAN (HONGEUL) INPUT MODE
 10651                                  		; DL = new mode
 10652                                  		; 00h return only full characters on DOS keyboard input functions
 10653                                  		; 01h return partially-formed characters also
 10654                                  	
 10655                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
 10656 00000635 B8080C                  	mov	ax,0C08h
 10657 00000638 CD21                    	int	21h			; Get character with KB buffer flush
 10658                                  		; DOS - CLEAR KEYBOARD BUFFER
 10659                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10660                                  
 10661                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10662 0000063A B8000C                  	mov	ax,0C00h
 10663 0000063D CD21                    	int	21h
 10664                                  		; DOS - CLEAR KEYBOARD BUFFER
 10665                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10666                                  
 10667                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10668                                  					;AN000;  3/3/KK
 10669 0000063F B80163                  	mov	ax,6301h
 10670 00000642 5A                      	pop	dx			;AN000;  restore interim state 3/3/KK
 10671 00000643 CD21                    	int	21h			;AN000;  3/3/KK
 10672 00000645 5A                      	pop	dx			;AN000;  3/3/KK
 10673                                  	
 10674 00000646 C3                      	retn
 10675                                  
 10676                                  ; =============== S U B	R O U T	I N E =======================================
 10677                                  
 10678                                  ; Break	<ReadBat - read 1 line from batch file>
 10679                                  
 10680                                  ; ReadBat - read a single line from the batch file. 
 10681                                  ; Perform all substitutions as appropriate.
 10682                                  
 10683                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10684                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0575h
 10685                                  
 10686                                  READBAT:
 10687                                  	;ASSUME	DS:ResGroup,ES:TranGroup
 10688                                  		
 10689                                  	;mov	byte [Suppress],1
 10690                                  				; initialize line suppress status
 10691 00000647 C606[3C02]01            	mov	byte [Suppress],YES_ECHO
 10692 0000064C F606[3102]FF            	test	byte [Batch_Abort],-1 ; 0FFh
 10693 00000651 751F                    	jnz	short TRYING_TO_ABORT
 10694 00000653 C606[3002]01            	mov	byte [In_Batch],1 ; set flag to indicate batch job
 10695                                  
 10696                                  	; MSDOS 6.0
 10697                                  
 10698                                  ;M037; Start of changes
 10699                                  ; We check here if we have set the flag indicating that the batchfile is at
 10700                                  ;EOF. In this case, we do not want to continue with the normal processing.
 10701                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
 10702                                  ;batch file gets closed etc. and then return as if everything is done.
 10703                                  
 10704                                  	; 05/02/2023
 10705 00000658 1E                      	push	ds
 10706 00000659 8E1E[E701]              	mov	ds,[Batch]
 10707                                  	;cmp	byte [2],0
 10708 0000065D 803E020000              	cmp	byte [BATCHSEGMENT.BatchEOF],0
 10709                                  				; are we at EOF in batchfile
 10710 00000662 1F                      	pop	ds
 10711 00000663 740A                    	jz	short CONTBAT	; no, continue normal processing
 10712                                  	;invoke	GetBatByt	; frees up batchseg
 10713 00000665 E8D303                  	call	GETBATBYT
 10714 00000668 26A2[769C]              	mov	[es:COMBUF+2],al
 10715                                  				; stuff CR into command buffer
 10716                                  				; as a dummy command
 10717                                  	;;invoke CrLf2		; print a CR-LF
 10718                                  	;call	CRLF2
 10719                                  	;;return		; done batch processing
 10720                                  	;retn
 10721                                  	; 24/04/2023
 10722 0000066C E9B224                  	jmp	CRLF2
 10723                                  
 10724                                  ;M037; End of changes
 10725                                  		
 10726                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10727                                  CONTBAT:
 10728 0000066F E842FF                  	call	PROMPTBAT
 10729                                  
 10730                                  TRYING_TO_ABORT:
 10731 00000672 BF[769C]                	mov	di,COMBUF+2
 10732                                  
 10733                                  ; Save position and try to scan for first non delimiter.
 10734                                  
 10735                                  TESTNOP:
 10736 00000675 8CD8                    	mov	ax,ds
 10737 00000677 8E1E[E701]              	mov	ds,[Batch]
 10738 0000067B FF360800                	push	word [BATCHSEGMENT.BatSeek]
 10739 0000067F FF360A00                	push	word [BATCHSEGMENT.BatSeek+2]
 10740                                  				; save current location.
 10741 00000683 8ED8                    	mov	ds,ax
 10742 00000685 E84B06                  	call	SKIPDELIM	; skip to first non-delim
 10743                                  
 10744                                  ; If the first non-delimiter is not a : (label), we reseek back to the
 10745                                  ; beginning and read the line.
 10746                                  
 10747 00000688 3C3A                    	cmp	al,':'		; is it a label?
 10748 0000068A 59                      	pop	cx
 10749 0000068B 5A                      	pop	dx		; restore position in bat file
 10750 0000068C 7431                    	jz	short NOPLINE	; yes, resync everything.
 10751 0000068E F706[E701]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10752 00000694 7438                    	jz	short RDBAT	; no, go read batch file
 10753                                  
 10754                                  	;cmp	al,'@'
 10755 00000696 3C40                    	cmp	al,No_Echo_Char	; see if user wants to suppress line
 10756 00000698 7507                    	jne	short SET_BAT_POS ; no - go and set batch file position
 10757                                  	;mov	byte [Suppress],0
 10758 0000069A C606[3C02]00            	mov	byte [Suppress],NO_ECHO ; yes set flag to indicate
 10759 0000069F EB2D                    	jmp	short RDBAT	; go read batch file
 10760                                  	;nop
 10761                                  SET_BAT_POS:
 10762 000006A1 1E                      	push	ds
 10763 000006A2 8E1E[E701]              	mov	ds,[Batch]
 10764                                  	;mov	[8],dx
 10765 000006A6 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
 10766                                  	;mov	[10],cx
 10767 000006AA 890E0A00                	mov	[BATCHSEGMENT.BatSeek+2],cx
 10768 000006AE 1F                      	pop	ds
 10769                                  	;;mov	ax,(LSEEK SHL 8) + 0
 10770                                  	; 05/02/2023
 10771 000006AF B80042                  	mov	ax,4200h
 10772                                  	;mov	ax,(LSEEK*256) ; 4200h ; seek back
 10773 000006B2 CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 10774                                  			; AL = method: offset from beginning of	file
 10775                                  	;mov	word [cs:BATBUFPOS],0FFFFh
 10776                                  	; 24/04/2023
 10777                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:05E3h
 10778 000006B4 26C706[DFA9]FFFF        	mov	word [es:BATBUFPOS],-1; 0FFFFh
 10779                                  	;mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
 10780 000006BB 31C9                    	xor	cx,cx		; Initialize line length to zero
 10781 000006BD EB0F                    	jmp	short RDBAT
 10782                                  
 10783                                  	;nop
 10784                                  
 10785                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
 10786                                  ; We eat characters until a CR is seen.
 10787                                  
 10788                                  NOPLINE:
 10789 000006BF E80501                  	call	SKIPTOEOL
 10790 000006C2 E87603                  	call	GETBATBYT	; eat trailing LF
 10791                                  	;test	word [Batch],0FFFFh
 10792 000006C5 F706[E701]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10793 000006CB 75A8                    	jnz	short TESTNOP	; no, go get another line
 10794                                  READBAT_RETN:			; Hit EOF
 10795 000006CD C3                      	retn
 10796                                  
 10797                                  ; ---------------------------------------------------------------------------
 10798                                  
 10799                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
 10800                                  ; input, we are to consider two special cases:
 10801                                  ;
 10802                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
 10803                                  ;   %sym%	This is a symbol from the environment
 10804                                  
 10805                                  RDBAT:
 10806 000006CE E86A03                  	call	GETBATBYT
 10807 000006D1 41                      	inc	cx		; Inc the line length
 10808                                  
 10809                                  	; 05/02/2023
 10810                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0601h
 10811 000006D2 E83A22                  	call	testkanj
 10812 000006D5 740C                    	jz	short RDBAT1
 10813                                  	;cmp	cx,127
 10814 000006D7 83F97F                  	cmp	cx,COMBUFLEN-1
 10815 000006DA 7350                    	jnb	short TOOLONG
 10816 000006DC AA                      	stosb
 10817 000006DD E85B03                  	call    GETBATBYT
 10818 000006E0 41                      	inc	cx
 10819 000006E1 EB0A                    	jmp	short SAVBATBYT
 10820                                  RDBAT1:
 10821 000006E3 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10822 000006E7 7343                    	jnb	short TOOLONG	   ; Yes - handle it, handle it
 10823                                  
 10824                                  ; See if we have a parameter character.
 10825                                  
 10826 000006E9 3C25                    	cmp	al,'%'		; Check for parameter
 10827 000006EB 7449                    	je	short NEEDPARM
 10828                                  
 10829                                  ; no parameter character. Store it as usual and see if we are done.
 10830                                  
 10831                                  SAVBATBYT:
 10832 000006ED AA                      	stosb			; End of line found?
 10833 000006EE 3C0D                    	cmp	al,0Dh
 10834 000006F0 75DC                    	jne	short RDBAT	; no, go for more
 10835                                  
 10836                                  ; We have read in an entire line. 
 10837                                  ; Decide whether we should echo the command line or not.
 10838                                  
 10839                                  FOUND_EOL:
 10840 000006F2 81EF[779C]              	sub	di,COMBUF+3
 10841 000006F6 89F8                    	mov	ax,di		; remember that we've not counted the CR
 10842 000006F8 26A2[759C]              	mov	[es:COMBUF+1],al
 10843                                  				; Set length of line
 10844 000006FC E83C03                  	call	GETBATBYT	; Eat linefeed
 10845 000006FF E8E906                  	call	BATCLOSE
 10846 00000702 803E[3C02]00            	cmp	byte [Suppress],NO_ECHO ; 0
 10847 00000707 7407                    	jz	short RESET
 10848 00000709 F606[3B02]01            	test	byte [EchoFlag],1  ; To echo or not to echo, that is the
 10849 0000070E 7504                    	jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
 10850                                  RESET:
 10851 00000710 0E                      	push	cs
 10852 00000711 1F                      	pop	ds		; Go back to local segment
 10853 00000712 74B9                    	jz	short READBAT_RETN ; no echoing here...
 10854                                  TRY_NEXTFLAG:
 10855 00000714 803E[5202]01            	cmp	byte [NullFlag],nullcommand ; 1
 10856                                  				;G was there a command last time?
 10857 00000719 7403                    	jz	short NO_CRLF_PRINT
 10858                                  				;G no - don't print crlf
 10859 0000071B E80324                  	call	CRLF2		;G Print out prompt
 10860                                  NO_CRLF_PRINT:
 10861 0000071E E8C21B                  	call	PRINT_PROMPT
 10862 00000721 0E                      	push	cs		;G change data segment
 10863 00000722 1F                      	pop	ds
 10864 00000723 BA[769C]                	mov	dx,COMBUF+2	; get command line for echoing
 10865 00000726 E85124                  	call	CRPRINT
 10866                                  	;call	CRLF2
 10867                                  	;retn
 10868                                  	; 06/02/2023
 10869 00000729 E9F523                  	jmp	CRLF2
 10870                                  
 10871                                  ; The line was too long. Eat remainder of input text up until the CR
 10872                                  
 10873                                  TOOLONG:
 10874 0000072C 3C0D                    	cmp	al,0Dh		; Has the end of the line been reached?
 10875 0000072E 7403                    	jz	short LTLCONT	; Yes, continue
 10876 00000730 E89400                  	call	SKIPTOEOL	; Eat remainder of line	
 10877                                  LTLCONT:
 10878 00000733 AA                      	stosb			; Terminate the command
 10879 00000734 EBBC                    	jmp	short FOUND_EOL	; Go process the valid part of the line
 10880                                  
 10881                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
 10882                                  
 10883                                  NEEDPARM:
 10884 00000736 E80203                  	call	GETBATBYT	; get next character
 10885 00000739 3C25                    	cmp	al,'%'		; Check for two consecutive %
 10886 0000073B 74B0                    	je	short SAVBATBYT	; if so, replace with a single %
 10887 0000073D 3C0D                    	cmp	al,0Dh		; Check for end-of-line
 10888 0000073F 74AC                    	je	short SAVBATBYT	; yes, treat it normally
 10889                                  
 10890                                  ; We have found %<something>. If the <something> is in the range 0-9, we
 10891                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
 10892                                  ; see if the <something> has a terminating % and then look up the contents
 10893                                  ; in the environment.
 10894                                  
 10895                                  PAROK:
 10896 00000741 2C30                    	sub	al,'0'
 10897 00000743 7239                    	jb	short NEEDENV	; look for parameter in the environment
 10898 00000745 3C09                    	cmp	al,9
 10899 00000747 7735                    	ja	short NEEDENV
 10900                                  
 10901                                  ; We have found %<number>. This is taken from the parameters in the
 10902                                  ; allocated batch area.
 10903                                  
 10904 00000749 98                      	cbw
 10905 0000074A 89C3                    	mov	bx,ax		; move index into AX
 10906 0000074C D1E3                    	shl	bx,1		; convert word index into byte ptr
 10907 0000074E 06                      	push	es
 10908 0000074F 8E06[E701]              	mov	es,[Batch]
 10909                                  
 10910                                  ; The structure of the batch area is:
 10911                                  ;
 10912                                  ;   BYTE    type of segment
 10913                                  ;   DWORD   offset for next line
 10914                                  ;   10 WORD pointers to parameters. -1 is empty parameter
 10915                                  ;   ASCIZ   file name (with . and ..)
 10916                                  ;   BYTES   CR-terminated parameters
 10917                                  ;   BYTE    0 flag to indicate end of parameters
 10918                                  ;
 10919                                  ; Get pointer to BX'th argument
 10920                                  
 10921                                  	;;mov	si,[es:bx+0Bh]
 10922                                  	; 05/02/2023
 10923                                  	;mov	si,[es:bx+0Ch] 	; MSDOS 5.0 COMMAND.COM
 10924 00000753 268B770C                	mov	si,[es:bx+BATCHSEGMENT.BatParm]
 10925 00000757 07                      	pop	es
 10926                                  
 10927                                  ; Is there a parameter here?
 10928                                  
 10929 00000758 83FEFF                  	cmp	si,-1		; Check if parameter exists
 10930 0000075B 7503                    	jnz	short YES_THERE_IS ; Yes go get it
 10931 0000075D E96EFF                  	jmp	RDBAT		; Ignore if it doesn't
 10932                                  
 10933                                  ; Copy in the found parameter from batch segment
 10934                                  
 10935                                  YES_THERE_IS:
 10936 00000760 1E                      	push	ds
 10937 00000761 8E1E[E701]              	mov	ds,[Batch]
 10938 00000765 49                      	dec	cx		; Don't count '%' in line length
 10939                                  COPYPARM:
 10940 00000766 AC                      	lodsb			; From resident segment
 10941 00000767 3C0D                    	cmp	al,0Dh		; Check for end of parameter
 10942 00000769 740F                    	je	short ENDPARAM
 10943 0000076B 41                      	inc	cx		; Inc the line length
 10944 0000076C 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10945 00000770 7303                    	jnb	short LINETOOL	; Yes - handle it, handle it
 10946 00000772 AA                      	stosb
 10947 00000773 EBF1                    	jmp	short COPYPARM
 10948                                  
 10949                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
 10950                                  ; line. We need to make sure that the tooLong code isn't fooled into
 10951                                  ; believing that we are at EOL. Clobber AL too.
 10952                                  
 10953                                  LINETOOL:
 10954 00000775 30C0                    	xor	al,al
 10955 00000777 1F                      	pop	ds
 10956 00000778 EBB2                    	jmp	short TOOLONG
 10957                                  
 10958                                  ; We have copied in an entire parameter. Go back for more
 10959                                  
 10960                                  ENDPARAM:
 10961 0000077A 1F                      	pop	ds
 10962 0000077B E950FF                  	jmp	RDBAT
 10963                                  
 10964                                  ; We have found % followed by something other than 0-9. We presume that there
 10965                                  ; will be a following % character. In between is an environment variable that
 10966                                  ; we will fetch and replace in the batch line with its value.
 10967                                  
 10968                                  NEEDENV:
 10969                                  	; MSDOS 6.0 COMMAND.COM
 10970                                  	; 05/02/2023 
 10971 0000077E 49                      	dec     cx 		;AN070; Don't count "%"
 10972                                  
 10973                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10974 0000077F 1E                      	push	ds
 10975 00000780 57                      	push	di
 10976                                  				; temp spot for name
 10977 00000781 BF[D29F]                	mov	di,ID
 10978 00000784 0430                    	add	al,'0'		; reconvert character
 10979 00000786 AA                      	stosb			; store it in appropriate place
 10980                                  
 10981                                  ; loop getting characters until the next % is found or until EOL
 10982                                  
 10983                                  GETENV1:
 10984 00000787 E8B102                  	call	GETBATBYT	; get the byte
 10985 0000078A AA                      	stosb			; store it
 10986 0000078B 3C0D                    	cmp	al,0Dh		; EOL?
 10987 0000078D 7514                    	jne	short GETENV15	; no, see if it the term char
 10988                                  
 10989                                  ; The user entered a string with a % but no trailing %. We copy the string.
 10990                                  
 10991 0000078F 26C645FF00              	mov	byte [es:di-1],0 ; nul terminate the string
 10992 00000794 BE[D29F]                	mov	si,ID 		; point to buffer
 10993 00000797 5F                      	pop	di		; point to line buffer
 10994 00000798 0E                      	push	cs
 10995 00000799 1F                      	pop	ds
 10996 0000079A E88B02                  	call	STRCPY
 10997                                  	; 05/02/2023
 10998 0000079D 72D6                    	jc	short LINETOOL	;  MSDOS 6.0 COMMAND.COM
 10999                                  	; 24/04/2023
 11000                                  	;dec	di  		;  MSDOS 3.3 COMMAND.COM	
 11001 0000079F 1F                      	pop	ds
 11002 000007A0 E94AFF                  	jmp	SAVBATBYT
 11003                                  GETENV15:
 11004 000007A3 3C25                    	cmp	al,'%'		; terminating %?
 11005 000007A5 75E0                    	jne	short GETENV1	; no, go suck out more characters
 11006                                  
 11007                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
 11008                                  ; This was the source of bug #1.
 11009                                  ;	dec	cx		;AN070; Don't count "%"
 11010                                  
 11011 000007A7 B03D                    	mov	al,'='		; terminate  with =
 11012 000007A9 268845FF                	mov	[es:di-1],al
 11013                                  
 11014                                  ; ID now either has a =-terminated string which we are to find in the
 11015                                  ; environment or a non =-terminated string which will not be found in the
 11016                                  ; environment.
 11017                                  
 11018                                  GETENV2:
 11019 000007AD BE[D29F]                	mov	si,ID
 11020 000007B0 0E                      	push	cs
 11021 000007B1 1F                      	pop	ds		; DS:SI points to name
 11022 000007B2 51                      	push	cx
 11023 000007B3 E8AF20                  	call	find_name_in_environment
 11024 000007B6 59                      	pop	cx
 11025 000007B7 06                      	push	es
 11026 000007B8 1F                      	pop	ds
 11027 000007B9 0E                      	push	cs
 11028 000007BA 07                      	pop	es
 11029 000007BB 89FE                    	mov	si,di
 11030 000007BD 5F                      	pop	di		; get back pointer to command line
 11031                                  
 11032                                  ; If the parameter was not found, there is no need to perform any replacement.
 11033                                  ; We merely pretend that we've copied the parameter.
 11034                                  
 11035 000007BE 7203                    	jc	short GETENV6
 11036                                  
 11037                                  ; ES:DI points to command line being built
 11038                                  ; DS:SI points either to nul-terminated environment object AFTER =
 11039                                  
 11040 000007C0 E86502                  	call	STRCPY		; (let RdBat handle overflow)
 11041                                  	; 24/04/2022
 11042                                  	;dec	di 		; MSDOS 3.3 COMMAND.COM
 11043                                  GETENV6:
 11044 000007C3 1F                      	pop	ds
 11045 000007C4 E907FF                  	jmp	RDBAT		; go back to batch file
 11046                                  
 11047                                  ; =============== S U B	R O U T	I N E =======================================
 11048                                  
 11049                                  ;   SkipToEOL - read from batch file until end of line
 11050                                  
 11051                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11052                                  SKIPTOEOL:
 11053 000007C7 F706[E701]FFFF          	test	word [Batch],-1 ; 0FFFFh
 11054                                  	;jnz	short SKIPTOEOL1  	
 11055                                  	;retn			; no batch file in effect
 11056                                  	
 11057 000007CD 7407                    	jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
 11058                                  SKIPTOEOL1:
 11059 000007CF E86902                  	call	GETBATBYT
 11060 000007D2 3C0D                    	cmp	al,0Dh		; eol character?
 11061 000007D4 75F1                    	jnz	short SKIPTOEOL	; no, go eat another
 11062                                  SKIPTOEOL2:
 11063 000007D6 C3                      	retn
 11064                                  
 11065                                  ; =============== S U B	R O U T	I N E =======================================
 11066                                  
 11067                                  ;Break	<Allocate and deallocate the transient portion>
 11068                                  
 11069                                  ; Free Transient. Modify ES,AX,flags
 11070                                  
 11071                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11072                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0708h
 11073                                  FREE_TPA:
 11074 000007D7 06                      	push	es
 11075 000007D8 8E06[159E]              	mov	es,[RESSEG]
 11076 000007DC 268E06[FC03]            	mov	es,[es:Res_Tpa]
 11077 000007E1 B449                    	mov	ah,49h
 11078                                  	;mov	ah,DEALLOC ; 49h
 11079 000007E3 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11080                                  			; ES = segment address of area to be freed
 11081 000007E5 07                      	pop	es
 11082 000007E6 C3                      	retn
 11083                                  
 11084                                  ; =============== S U B	R O U T	I N E =======================================
 11085                                  
 11086                                  ; Allocate transient. Modify AX,BX,DX,flags
 11087                                  
 11088                                  	; 06/02/2023
 11089                                  ALLOC_TPA:
 11090 000007E7 06                      	push	es
 11091 000007E8 8E06[159E]              	mov	es,[RESSEG]
 11092 000007EC BBFFFF                  	mov	bx,0FFFFh 	; Re-allocate the transient	
 11093 000007EF B448                    	mov	ah,48h
 11094                                  	;mov	ah,ALLOC ; 48h
 11095 000007F1 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 11096                                  			; BX = number of 16-byte paragraphs desired
 11097 000007F3 53                      	push	bx	  	; Save size of block
 11098 000007F4 B448                    	mov	ah,48h
 11099                                  	;mov	ah,ALLOC ; 48h
 11100 000007F6 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 11101                                  			; BX = number of 16-byte paragraphs desired
 11102                                  
 11103                                  ; Attempt to align TPA on 64K boundary
 11104                                  
 11105 000007F8 5B                      	pop	bx		; Restore size of block
 11106 000007F9 26A3[FC03]              	mov	[es:Res_Tpa],ax
 11107                                  				; Save segment to beginning of block
 11108 000007FD A3[259E]                	mov	[TRAN_TPA],ax
 11109                                  
 11110                                  ; Is the segment already aligned on a 64K boundary
 11111                                  
 11112 00000800 89C2                    	mov	dx,ax		; Save segment
 11113 00000802 25FF0F                  	and	ax,0FFFh	; Test if above boundary
 11114 00000805 7507                    	jnz	short CALC_TPA
 11115 00000807 89D0                    	mov	ax,dx
 11116 00000809 2500F0                  	and	ax,0F000h	; Test if multiple of 64K
 11117 0000080C 7523                    	jnz	short NOROUND
 11118                                  CALC_TPA:
 11119 0000080E 89D0                    	mov	ax,dx
 11120 00000810 2500F0                  	and	ax,0F000h
 11121 00000813 050010                  	add	ax,1000h	; Round up to next 64K boundary
 11122 00000816 7219                    	jc	short NOROUND	; Memory wrap if carry set
 11123                                  
 11124                                  ; Make sure that new boundary is within allocated range
 11125                                  
 11126 00000818 268B16[FC03]            	mov	dx,[es:Res_Tpa]
 11127 0000081D 01DA                    	add	dx,bx		; Compute maximum address
 11128 0000081F 39C2                    	cmp	dx,ax		; Is 64K address out of range?
 11129 00000821 720E                    	jb	short NOROUND
 11130                                  
 11131                                  ; Make sure that we won't overwrite the transient
 11132                                  
 11133 00000823 8CCB                    	mov	bx,cs		; CS is beginning of transient
 11134 00000825 39C3                    	cmp	bx,ax
 11135 00000827 7208                    	jb	short NOROUND
 11136                                  
 11137                                  ; The area from the 64K boundary to the beginning of the transient must
 11138                                  ; be at least 64K.
 11139                                  
 11140 00000829 29C3                    	sub	bx,ax
 11141                                  	;cmp	bx,4096
 11142 0000082B 81FB0010                	cmp	bx,1000h	; Size greater than 64K?	
 11143 0000082F 7304                    	jnb	short ROUNDDONE
 11144                                  NOROUND:
 11145 00000831 26A1[FC03]              	mov	ax,[es:Res_Tpa]
 11146                                  ROUNDDONE:
 11147 00000835 26A3[EE03]              	mov	[es:LTpa],ax	; Re-compute everything
 11148 00000839 A3[179E]                	mov	[TPA],ax
 11149 0000083C 89C3                    	mov	bx,ax
 11150 0000083E 8CC8                    	mov	ax,cs
 11151 00000840 29D8                    	sub	ax,bx
 11152 00000842 53                      	push	bx
 11153 00000843 BB1000                  	mov	bx,16
 11154 00000846 F7E3                    	mul	bx
 11155 00000848 5B                      	pop	bx
 11156 00000849 09D2                    	or	dx,dx
 11157 0000084B 7403                    	jz	short SAVSIZ2
 11158 0000084D B8FFFF                  	mov	ax,-1
 11159                                  SAVSIZ2:
 11160                                  
 11161                                  ; AX is the number of bytes free in the buffer between the resident and the
 11162                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
 11163                                  
 11164 00000850 3D0002                  	cmp	ax,512
 11165 00000853 7603                    	jbe	short GOTSIZE2
 11166                                  	;and	ax,~1FFh
 11167 00000855 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FFh
 11168                                  GOTSIZE2:
 11169 00000858 A3[369E]                	mov	[BYTCNT],ax
 11170 0000085B 07                      	pop	es
 11171 0000085C C3                      	retn
 11172                                  
 11173                                  ; =============== S U B	R O U T	I N E =======================================
 11174                                  
 11175                                  ;Break	<BatCom - enter a batch file>
 11176                                  
 11177                                  ; The exec search has determined that the user has requested a batch file for
 11178                                  ; execution. We parse the arguments, create the batch segment, and signal
 11179                                  ; batch processing.
 11180                                  
 11181                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11182                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:078Eh
 11183                                  
 11184                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 11185                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0868h
 11186                                  BATCOM:	
 11187                                  
 11188                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
 11189                                  
 11190                                  ; Batch parameters are read with ES set to segment of resident part
 11191                                  
 11192                                  	; MSDOS 6.0
 11193 0000085D 8E06[159E]              	mov	es,[RESSEG]
 11194                                  	;ASSUME	ES:RESGROUP
 11195                                  	;cmp	byte [es:Call_Batch_Flag],1
 11196 00000861 26803E[4F02]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11197                                  					;AN043; If in CALL,
 11198 00000867 7403                    	jz	short skip_ioset	;AN043; redirection was already set up
 11199                                  	;invoke	IOSET			; Set up any redirection
 11200 00000869 E86128                  	call	IOSET
 11201                                  skip_ioset:				;AN043;
 11202 0000086C E868FF                  	call	FREE_TPA		; G
 11203                                  	;cmp	byte [es:Call_Batch_Flag],1
 11204 0000086F 26803E[4F02]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11205 00000875 7403                    	jz	short GETECHO 		; G if we're in a call, don't execute
 11206                                  
 11207                                  	; 12/02/2023
 11208                                  	; MSDOS 3.3
 11209                                  	;call	IOSET
 11210                                  	;mov	es,[RESSEG]
 11211                                  	;call	FREE_TPA
 11212                                  	;;cmp	byte [es:CALL_BATCH_FLAG],1
 11213                                  	;cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
 11214                                  	;jz	short GETECHO		; G if we're in a call, don't execute
 11215                                  
 11216                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11217                                  
 11218                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
 11219                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
 11220                                  ; Don't execute if in call
 11221                                  
 11222 00000877 E89608                  	call	FOROFF
 11223                                  GETECHO:
 11224 0000087A E83B2C                  	call	PipeOff
 11225 0000087D 26A0[3B02]              	mov	al,[es:EchoFlag]	; preserve echo state for chaining
 11226 00000881 2401                    	and	al,1			; Save current echo state
 11227                                  
 11228 00000883 50                      	push	ax
 11229 00000884 31C0                    	xor	ax,ax
 11230 00000886 26F706[E701]FFFF        	test	word [es:Batch],-1 	; Are we in a batch file?
 11231 0000088D 7414                    	jz	short LEAVEBAT	   	; No, nothing to save
 11232 0000088F 26A1[E701]              	mov	ax,[es:Batch] 		; Get current batch segment
 11233                                  	;cmp	byte [es:Call_Batch_Flag],1
 11234 00000893 26803E[4F02]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11235 00000899 7408                    	jz	short LEAVEBAT
 11236                                  
 11237                                  ;  We are in a chained batch file, save batlast from previous batch segment
 11238                                  ;  so that if we're in a CALL, we will return to the correct batch file.
 11239                                  
 11240 0000089B 06                      	push	es
 11241 0000089C 8EC0                    	mov	es,ax		; Get current batch segment
 11242                                  	;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
 11243                                  				; Get previous batch segment
 11244                                  	; 12/02/2023
 11245                                  	;mov	ax,[es:03h] ; MSDOS 6.0 (&5.0) COMMAND.COM	
 11246 0000089E 26A10300                	mov	ax,[es:BATCHSEGMENT.BatLast]
 11247 000008A2 07                      	pop	es
 11248                                  LEAVEBAT:
 11249 000008A3 50                      	push	ax		; Keep segment until new one created
 11250                                  	;cmp	byte [es:Call_Batch_Flag],1
 11251 000008A4 26803E[4F02]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11252 000008AA 7403                    	jz	short STARTBAT
 11253 000008AC E82001                  	call	BATCHOFF
 11254                                  
 11255                                  ; Find length of batch file
 11256                                  
 11257                                  STARTBAT:
 11258 000008AF 26C606[4F02]00          	mov	byte [es:Call_Batch_Flag],0 ; Reset call flag
 11259 000008B5 BE[3D9D]                	mov	si,EXECPATH
 11260                                  
 11261                                  	; 12/02/2023
 11262                                  	; MSDOS 6.0
 11263 000008B8 B811B7                  	mov	ax,0B711h
 11264                                  	;mov	ax,AppendTruename
 11265                                  				;AN042; Get the real path where the batch file
 11266 000008BB CD2F                    	int	2Fh		;AN042;    was found with APPEND
 11267 000008BD B44E                    	mov	ah,4Eh
 11268                                  	;mov	ah,Find_First	;AN042; The find_first will return it
 11269 000008BF 89F2                    	mov	dx,si		;AN042; Get the string
 11270 000008C1 B91300                  	mov	cx,13h
 11271                                  	;mov	cx,search_attr	;AN042; filetypes to search for
 11272 000008C4 CD21                    	int	21h		;AN042;
 11273                                  
 11274                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11275 000008C6 E8F328                  	call	dstrlen
 11276                                  ;
 11277                                  ; Allocate batch area:
 11278                                  ;   BYTE    type of segment
 11279                                  ;   WORD    segment of last batch file
 11280                                  ;   WORD    segment for FOR command
 11281                                  ;   BYTE    FOR flag state on entry to batch file
 11282                                  ;   DWORD   offset for next line
 11283                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
 11284                                  ;   ASCIZ   file name (with . and ..)
 11285                                  ;   BYTES   CR-terminated parameters
 11286                                  ;   BYTE    0 flag to indicate end of parameters
 11287                                  ;
 11288                                  ; We allocate the maximum size for the command line and use setblock to shrink
 11289                                  ; later when we've squeezed out the extra
 11290                                  ;
 11291 000008C9 89CB                    	mov	bx,cx		; length of file name.
 11292                                  	;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
 11293                                  	; 12/02/2023
 11294                                  	;add	bx,191	; MSDOS 6.0 (BATCHSEGMENT struc size = 33) 
 11295                                  	; 25/04/2023
 11296 000008CB 81C3BF00                	add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
 11297                                  					; structure + max len + round up
 11298 000008CF 51                      	push	cx
 11299 000008D0 B104                    	mov	cl,4
 11300 000008D2 D3EB                    	shr	bx,cl		; convert to paragraphs
 11301 000008D4 53                      	push	bx		; Save size of batch segment
 11302 000008D5 B448                    	mov	ah,48h
 11303                                  	;mov	ah,ALLOC ; 48h ; Allocate batch segment
 11304 000008D7 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 11305                                  				; BX = number of 16-byte paragraphs desired
 11306 000008D9 5B                      	pop	bx		; Get size of batch segment
 11307                                  
 11308                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
 11309                                  ; the batch segment. This may not be true, however, in a multitasking system.
 11310                                  ; G This error will occur with nesting of batch files. We also need to
 11311                                  ; G make sure that we don't overlay the transient.
 11312                                  
 11313 000008DA 7221                    	jc	short MEM_ERROR	;G not enough memory - exit
 11314                                  
 11315 000008DC 50                      	push	ax		;G save batch segment
 11316 000008DD 01D8                    	add	ax,bx		;G get end of batch segment
 11317 000008DF 83C020                  	add	ax,20h		;G add some tpa work area
 11318 000008E2 8CCB                    	mov	bx,cs		;G get the transient segment
 11319                                  
 11320                                  	; MSDOS 6.0
 11321                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
 11322                                  ; M006; batchseg is always above the transient. We need to change this code
 11323                                  ; M006; to only check for an overlap
 11324                                  
 11325                                  	;;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
 11326                                  	; 12/02/2023
 11327                                  	;;mov	dx,98C5h ; MSDOS 5.0 COMMAND.COM
 11328                                  	;mov	dx,TRANSPACEEND		
 11329                                  	;add	dx,15		;round up para; M006
 11330 000008E4 BA36AA                  	mov	dx,TRANSPACEEND+15
 11331                                  
 11332 000008E7 D3EA                    	shr	dx,cl		;para size of transient; M006
 11333 000008E9 01DA                    	add	dx,bx		;dx = top of transient; M006
 11334                                  
 11335 000008EB 39D8                    	cmp	ax,bx		; M006
 11336 000008ED 7211                    	jb	short ENOUGH_MEM
 11337                                  				; Batchseg below transient
 11338                                  				; enough memory ; M006
 11339 000008EF 39D0                    	cmp	ax,dx		; M006
 11340 000008F1 770D                    	ja	short ENOUGH_MEM	
 11341                                  				; Batchseg above transient
 11342                                  				; enough memory ; M006
 11343                                  
 11344                                  ; M006; Batchseg overlaps transient -- insufficient memory
 11345                                  
 11346 000008F3 58                      	pop	ax		; restore ax; M006
 11347                                  
 11348                                  	; 12/02/2023
 11349                                  	; MSDOS 3.3
 11350                                  ; M006;	cmp	ax,bx		;G do we end before the transient
 11351                                  ; M006;	pop	ax		;G get batch segment back
 11352                                  ; M006;	jb	short ENOUGH_MEM ;G we have enough memory - continue
 11353                                  
 11354                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11355 000008F4 06                      	push	es		;G no we're hitting the transient
 11356 000008F5 8EC0                    	mov	es,ax
 11357 000008F7 B80049                  	mov	ax,4900h
 11358                                  	;mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
 11359 000008FA CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11360                                  			; ES = segment address of area to be freed
 11361 000008FC 07                      	pop	es
 11362                                  MEM_ERROR:
 11363 000008FD E9B800                  	jmp	NO_MEMORY	;G Set up for message and exit
 11364                                  
 11365                                  ENOUGH_MEM:
 11366                                  	; 12/02/2023 - Retro DOS v4.0 COMMAND.COM
 11367                                  	; MSDOS 6.0
 11368 00000900 58                      	pop	ax		; restore ax; M006
 11369                                  
 11370                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11371 00000901 26A3[E701]              	mov	[es:Batch],ax
 11372 00000905 E8DFFE                  	call	ALLOC_TPA
 11373                                  
 11374                                  ; Initialize batch segment
 11375                                  
 11376 00000908 5A                      	pop	dx		; length of name
 11377 00000909 58                      	pop	ax		;G get saved batch segment back
 11378 0000090A 26FF06[4C02]            	inc	word [es:Nest]	;G increment # batch files in progress
 11379 0000090F 06                      	push	es
 11380 00000910 268E06[E701]            	mov	es,[es:Batch]
 11381                                  	;mov	byte [ES:0],0
 11382                                  				; signal batch file type
 11383 00000915 26C606000000            	mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
 11384                                  	;;mov	[es:2],ax	; MSDOS 3.3
 11385                                  				;G save segment of last batch file
 11386                                  	;mov	[es:3],ax	; MSDOS 6.0
 11387 0000091B 26A30300                	mov	[es:BATCHSEGMENT.BatLast],ax
 11388 0000091F 1E                      	push	ds
 11389 00000920 8E1E[159E]              	mov	ds,[RESSEG]	;G set to resident data
 11390                                  
 11391 00000924 31C0                    	xor	ax,ax
 11392 00000926 8A1E[4902]              	mov	bl,[ForFlag]	;G get the current FOR state
 11393                                  	;;mov	[es:6],bl	; MSDOS 3.3
 11394                                  				;G save it in the batch segment
 11395                                  	;mov	[es:7],bl	; MSDOS 6.0 	
 11396 0000092A 26881E0700              	mov	[es:BATCHSEGMENT.BatForFlag],bl
 11397 0000092F F6C3FF                  	test	bl,-1 ; 0FFh	;G are we in a FOR?
 11398 00000932 7406                    	jz	short FOR_NOT_ON ;G no, for segment set to 0	
 11399                                  	;mov	ax,[ForPtr]	;G yes, get current FOR segment	
 11400                                  	;mov	byte [ForFlag],0 ;G reset forflag
 11401                                  	; 26/07/2024
 11402 00000934 A2[4902]                	mov	[ForFlag],al ; 0
 11403 00000937 A1[4A02]                	mov	ax,[ForPtr]	;G yes, get current FOR segment	
 11404                                  FOR_NOT_ON:
 11405                                  	;;mov	[es:4],ax	; MSDOS 3.3
 11406                                  				;G save FOR segment in batch segment
 11407                                  	;mov	[es:5],ax	; MSDOS 6.0		
 11408 0000093A 26A30500                	mov	[es:BATCHSEGMENT.BatForPtr],ax	
 11409 0000093E 31C0                    	xor	ax,ax
 11410 00000940 A3[4A02]                	mov	[ForPtr],ax	;G make sure for segment is not active
 11411 00000943 8A1E[3B02]              	mov	bl,[EchoFlag]
 11412 00000947 1F                      	pop	ds
 11413                                  	;mov	[es:1],bl 
 11414                                  				 ;G save echo state of parent
 11415 00000948 26881E0100              	mov	[es:BATCHSEGMENT.BatEchoFlag],bl
 11416                                  ;SR;
 11417                                  ; Initialize the new BatchEOF flag we have added to 0
 11418                                  
 11419                                  	; MSDOS 6.0
 11420                                  	;mov	byte [es:2],0
 11421 0000094D 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 11422                                  
 11423                                  	;mov	[es:08h],ax  ; MSDOS 6.0
 11424 00000953 26A30800                	mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
 11425                                  	;mov	[es:0Ah],ax  ; MSDOS 6.0	
 11426 00000957 26A30A00                	mov	[es:BATCHSEGMENT.BatSeek+2],ax
 11427                                  
 11428                                  ; Initialize pointers
 11429                                  
 11430 0000095B 48                      	dec	ax		; put -1 into AX
 11431                                  	;;mov	di,0Bh  ; MSDOS 3.3
 11432                                  				; point to parm area
 11433                                  	;mov	di,0Ch	; MSDOS 6.0
 11434 0000095C BF0C00                  	mov	di,BATCHSEGMENT.BatParm
 11435 0000095F 89FB                    	mov	bx,di
 11436 00000961 B90A00                  	mov	cx,10
 11437 00000964 F3AB                    	rep stosw		; Init to no parms
 11438                                  
 11439                                  ; Move in batch file name
 11440                                  
 11441 00000966 89D1                    	mov	cx,dx
 11442 00000968 F3A4                    	rep	movsb
 11443                                  
 11444                                  ; Now copy the command line into batch segment, parsing the arguments along
 11445                                  ; the way. Segment will look like this:
 11446                                  ;
 11447                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
 11448                                  ;
 11449                                  ; or, in the case of fewer arguments:
 11450                                  ;
 11451                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
 11452                                  
 11453 0000096A BE[769C]                	mov	si,COMBUF+2
 11454                                  	;mov	cx,10		; at most 10 arguments
 11455                                  	; 07/06/2023
 11456 0000096D B10A                    	mov	cl,10
 11457                                  EACHPARM:
 11458 0000096F E8BC21                  	call	scanoff		; skip to argument
 11459                                  
 11460                                  ; AL is first non-delimiter. DS:SI points to char = AL
 11461                                  
 11462 00000972 3C0D                    	cmp	al,0Dh		; end of road?
 11463 00000974 741D                    	jz	short HAVPARM	; yes, no more arguments
 11464                                  
 11465                                  ; If CX = 0 then we have stored the most parm we can. Skip store
 11466                                  
 11467 00000976 E306                    	jcxz	MOVPARM		; Only first 10 parms get pointers
 11468                                  
 11469                                  ; Go into allocated piece and stick in new argument pointer.
 11470                                  
 11471 00000978 26893F                  	mov	[es:bx],di	; store batch pointer
 11472 0000097B 83C302                  	add	bx,2		; advance arg counter
 11473                                  
 11474                                  ; Move the parameter into batch segment
 11475                                  
 11476                                  MOVPARM:
 11477 0000097E AC                      	lodsb			; get byte
 11478 0000097F E8B421                  	call	DELIM		; if delimiter
 11479 00000982 7407                    	jz	short ENDPARM	; then done with parm
 11480 00000984 AA                      	stosb			; store byte
 11481 00000985 3C0D                    	cmp	al,0Dh		; if CR then not delimiter
 11482 00000987 740A                    	jz	short HAVPARM	; but end of parm list, finish
 11483 00000989 EBF3                    	jmp	short MOVPARM
 11484                                  
 11485                                  ; We have copied a parameter up until the first separator.
 11486                                  ; Terminate it with CR.
 11487                                  
 11488                                  ENDPARM:
 11489 0000098B B00D                    	mov	al,0Dh
 11490 0000098D AA                      	stosb
 11491 0000098E E3DF                    	jcxz	EACHPARM	; if no parameters, don't dec
 11492 00000990 49                      	dec	cx		; remember that we've seen one.	
 11493 00000991 EBDC                    	jmp	short EACHPARM
 11494                                  
 11495                                  ; We have parsed the entire line. Terminate the arg list
 11496                                  
 11497                                  HAVPARM:
 11498 00000993 30C0                    	xor	al,al		; Nul terminate the parms
 11499 00000995 AA                      	stosb
 11500                                  
 11501                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
 11502                                  ; into paragraphs and setblock to the appropriate size
 11503                                  
 11504 00000996 8D5D0F                  	lea	bx,[di+15]
 11505 00000999 B104                    	mov	cl,4
 11506 0000099B D3EB                    	shr	bx,cl
 11507 0000099D B44A                    	mov	ah,4Ah
 11508                                  	;mov	ah,SETBLOCK ; 4Ah
 11509 0000099F CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 11510                                  			; ES = segment address of block	to change
 11511                                  			; BX = new size	in paragraphs
 11512 000009A1 07                      	pop	es
 11513 000009A2 06                      	push	es
 11514 000009A3 1F                      	pop	ds		; Simply batch FCB setup
 11515 000009A4 833E[4302]FF            	cmp	word [SingleCom],-1 ; 0FFFFh
 11516 000009A9 7506                    	jne	short NOBATSING
 11517 000009AB C706[4302]F0FF          	mov	word [SingleCom],0FFF0h ; Flag single command BATCH job
 11518                                  
 11519                                  NOBATSING:
 11520                                  
 11521                                  ; Enter the batch file with the current echo state
 11522                                  
 11523 000009B1 58                      	pop	ax		; Get original echo state
 11524 000009B2 A2[3B02]                	mov	[EchoFlag],al	; restore it
 11525 000009B5 E94CF7                  	jmp	TCOMMAND
 11526                                  
 11527                                  ; The following is executed if there isn't enough memory for batch segment
 11528                                  
 11529                                  NO_MEMORY:
 11530 000009B8 5A                      	pop	dx		; even up our stack 
 11531 000009B9 58                      	pop	ax
 11532 000009BA 58                      	pop	ax
 11533 000009BB E829FE                  	call	ALLOC_TPA	; reallocate memory
 11534                                  
 11535                                  	; 12/02/2023
 11536                                  	; MSDOS 3.3
 11537                                  	;mov	dx,INSFMEMMESPTR
 11538                                  	;jmp	CERROR
 11539                                  
 11540                                  	; MSDOS 6.0
 11541                                  	;mov	byte [msg_disp_class],1
 11542 000009BE C606[F191]01            	mov	byte [msg_disp_class],ext_msg_class
 11543                                  				;AN000; set up extended error msg class
 11544                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 11545 000009C3 BA[F391]                	mov	dx,extend_buf_ptr
 11546                                  	;			;AC000; get extended message pointer
 11547                                  	;mov	word [extend_buf_ptr],8
 11548 000009C6 C706[F391]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 11549                                  				;AN000; get message number in control block
 11550 000009CC E9D324                  	jmp	cerror		;g print error message and go...
 11551                                  
 11552                                  ; =============== S U B	R O U T	I N E =======================================
 11553                                  
 11554                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11555                                  BATCHOFF:
 11556 000009CF 50                      	push	ax
 11557 000009D0 06                      	push	es
 11558 000009D1 1E                      	push	ds
 11559 000009D2 53                      	push	bx
 11560                                  
 11561 000009D3 2E8E06[159E]            	mov	es,[cs:RESSEG]
 11562                                  	;mov	ds,[cs:RESSEG]
 11563                                  	; 26/07/2024
 11564 000009D8 06                      	push	es
 11565 000009D9 1F                      	pop	ds
 11566                                  
 11567 000009DA A1[E701]                	mov	ax,[Batch]	; Free the batch segment
 11568 000009DD 09C0                    	or	ax,ax
 11569 000009DF 7442                    	jz	short NOTFREE
 11570                                  
 11571 000009E1 06                      	push	es
 11572 000009E2 8EC0                    	mov	es,ax
 11573 000009E4 F606[3B02]01            	test	byte [EchoFlag],1
 11574                                  				;G Is echo on?
 11575 000009E9 7505                    	jnz	short ECHO_LAST_LINE
 11576                                  				;G Yes - echo last line in file
 11577                                  	;mov	byte [SUPPRESS],0
 11578 000009EB C606[3C02]00            	mov	byte [Suppress],NO_ECHO
 11579                                  				;G no - don't echo last line in file	
 11580                                  ECHO_LAST_LINE:
 11581                                  	;mov	bl,[es:1]
 11582 000009F0 268A1E0100              	mov	bl,[es:BATCHSEGMENT.BatEchoFlag]
 11583                                  				; G get echo state
 11584 000009F5 881E[3B02]              	mov	[EchoFlag],bl
 11585                                  				; G  and restore it
 11586                                  	;;mov	bx,[es:4]  ; MSDOS 3.3
 11587                                  	;mov	bx,[es:5]  ; MSDOS 6.0
 11588 000009F9 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr]
 11589                                  				;G Get FOR segment
 11590 000009FE 891E[4A02]              	mov	[ForPtr],bx	;G  and restore it
 11591                                  	;;mov	bl,[es:6]  ; MSDOS 3.3
 11592                                  	;mov	bl,[es:7]  ; MSDOS 6.0	
 11593 00000A02 268A1E0700              	mov	bl,[es:BATCHSEGMENT.BatForFlag]
 11594                                  				;G Get FOR flag
 11595 00000A07 881E[4902]              	mov	[ForFlag],bl
 11596                                  				;G  and restore it
 11597                                  	;;mov	bx,[es:2] ; MSDOS 3.3
 11598                                  	;mov	bx,[es:3] ; MSDOS 6.0	
 11599 00000A0B 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 11600                                  				;G  Get old batch segment
 11601                                  
 11602 00000A10 B449                    	mov	ah,49h
 11603                                  	;mov	ah,DEALLOC ; 49h
 11604 00000A12 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11605                                  			; ES = segment address of area to be freed
 11606 00000A14 07                      	pop	es
 11607 00000A15 891E[5002]              	mov	[Next_Batch],bx	;G reset batch segment	
 11608 00000A19 26FF0E[4C02]            	dec	word [es:Nest]
 11609 00000A1E 31C0                    	xor	ax,ax
 11610 00000A20 A3[E701]                	mov	[Batch],ax	; No batch in progress
 11611                                  NOTFREE:
 11612 00000A23 5B                      	pop	bx
 11613 00000A24 1F                      	pop	ds
 11614 00000A25 07                      	pop	es
 11615 00000A26 58                      	pop	ax
 11616 00000A27 C3                      	retn
 11617                                  
 11618                                  ; =============== S U B	R O U T	I N E =======================================
 11619                                  
 11620                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11621                                  
 11622                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
 11623                                  ;	Entry : DS:SI ==> source string
 11624                                  ;		ES:DI ==> destination string
 11625                                  ;		CX = current length of destination string
 11626                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
 11627                                  
 11628                                  	; 12/02/2023	
 11629                                  	; MSDOS 3.3
 11630                                  ;STRCPY:
 11631                                  	;push	ax
 11632                                  ;CCYCLE:
 11633                                  	;lodsb
 11634                                  	;stosb
 11635                                  	;or	al,al
 11636                                  	;jnz	short CCYCLE
 11637                                  	;pop	ax
 11638                                  	;retn
 11639                                  
 11640                                  ;Procedure StrCpy,NEAR
 11641                                  
 11642                                  	; 12/02/2023
 11643                                  	; MSDOS 6.0
 11644                                  STRCPY:
 11645 00000A28 50                      	push	ax
 11646                                  ccycle:
 11647 00000A29 AC                      	lodsb
 11648 00000A2A 41                      	inc	cx
 11649                                  	;cmp	cx,128
 11650 00000A2B 81F98000                	cmp	cx,COMBUFLEN
 11651                                  	;jb	short ccopy
 11652                                  	;stc			; set carry to signal error
 11653                                  	;jmp	short ccend
 11654                                  	; 12/02/2023
 11655 00000A2F F5                      	cmc
 11656 00000A30 7205                    	jc	short ccend
 11657                                  ccopy:
 11658 00000A32 AA                      	stosb
 11659 00000A33 08C0                    	or	al,al
 11660 00000A35 75F2                    	jnz	short ccycle
 11661                                  ccend:
 11662 00000A37 49                      	dec	cx		; discount extra byte
 11663 00000A38 4F                      	dec	di		; back up pointer
 11664 00000A39 58                      	pop	ax
 11665 00000A3A C3                      	retn			; return carry clear
 11666                                  
 11667                                  ;EndProc StrCpy
 11668                                  
 11669                                  ;============================================================================
 11670                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
 11671                                  ;============================================================================
 11672                                  ; 12/10/2018 - Retro DOS v3.0
 11673                                  
 11674                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
 11675                                  
 11676                                  ; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11677                                  
 11678                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 0977h
 11679                                  
 11680                                  ; =============== S U B	R O U T	I N E =======================================
 11681                                  
 11682                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
 11683                                  
 11684                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
 11685                                  ; <CR> and ends batch mode. DS must be set to resident segment.
 11686                                  ; AH, DX destroyed.
 11687                                  
 11688                                  GETBATBYT:
 11689 00000A3B 53                      	push	bx
 11690 00000A3C 51                      	push	cx
 11691 00000A3D 1E                      	push	ds
 11692 00000A3E F606[3102]FF            	test	byte [Batch_Abort],-1
 11693                                  	;jnz	short BATEOF
 11694                                  	; 14/02/2023
 11695 00000A43 7403                    	jz	short getbatbyt1
 11696 00000A45 E9D100                  	jmp	BATEOF
 11697                                  getbatbyt1:
 11698 00000A48 F706[E701]FFFF          	test	word [Batch],-1
 11699                                  	;jz	short BATEOF
 11700                                  	; 14/02/2023
 11701 00000A4E 7503                    	jnz	short getbatbyt2
 11702 00000A50 E9C600                  	jmp	BATEOF
 11703                                  getbatbyt2:
 11704 00000A53 06                      	push	es
 11705 00000A54 8E06[E701]              	mov	es,[Batch]
 11706                                  
 11707                                  	; MSDOS 6.0
 11708                                  ;M020;
 11709                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
 11710                                  ;try to read from the batchfile again.
 11711                                  
 11712                                  	;cmp	byte [es:2],0
 11713 00000A58 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11714                                  				;already reached EOF?	;M020
 11715 00000A5E 7403                    	jz	short not_eof	;no, read batch file	;M020
 11716 00000A60 E99C00                  	jmp	At_EOF		;yes, no more reads	;M020
 11717                                  not_eof:						;M020
 11718                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11719                                  	;add	word [es:8],1	; MSDOS 6.0
 11720 00000A63 268306080001            	add	word [es:BATCHSEGMENT.BatSeek],1
 11721                                  	;adc	word [es:10],0	; MSDOS 6.0
 11722 00000A69 2683160A0000            	adc	word [es:BATCHSEGMENT.BatSeek+2],0
 11723 00000A6F 07                      	pop	es
 11724                                  
 11725                                  ; See if we have bytes buffered...
 11726                                  
 11727 00000A70 8CC8                    	mov	ax,cs
 11728 00000A72 8ED8                    	mov	ds,ax
 11729 00000A74 8B1E[DFA9]              	mov	bx,[BATBUFPOS]
 11730 00000A78 83FBFF                  	cmp	bx,-1
 11731 00000A7B 7540                    	jnz	short UNBUF
 11732                                  
 11733                                  ; There are no bytes in the buffer. Let's try to fill it up.
 11734                                  
 11735 00000A7D BA[E1A9]                	mov	dx,BATBUF
 11736 00000A80 8B0E[9797]              	mov	cx,[BATBUFLEN] ; max to read.
 11737 00000A84 8B1E[0BA2]              	mov	bx,[BATHAND]
 11738                                  	; 14/02/2023
 11739 00000A88 B43F                    	mov	ah,3Fh
 11740                                  	;mov	ah,READ ; 3Fh	; Get one more byte from batch file
 11741 00000A8A CD21                    	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
 11742                                  			; BX = file handle,CX = number	of bytes to read
 11743                                  			; DS:DX	-> buffer
 11744                                  	; MSDOS 6.0
 11745 00000A8C 7321                    	jnc	short bat_read_ok	;AN022; if no error - continue
 11746                                  	;invoke	get_ext_error_number	;AN022; get the error
 11747 00000A8E E8B117                  	call	get_ext_error_number
 11748 00000A91 1E                      	push	ds			;AN022; save local segment
 11749 00000A92 8E1E[159E]              	mov	ds,[RESSEG]		;AN022; get resident segment
 11750                                  	;assume ds:resgroup		;AN022;
 11751 00000A96 89C2                    	mov	dx,ax			;AN022; put error in DX
 11752                                  	;invoke	output_batch_name	;AN022; set up to print the error
 11753 00000A98 E861FB                  	call	output_batch_name
 11754 00000A9B 1F                      	pop	ds			;AN022;
 11755                                  	;assume	ds:trangroup		;AN022;
 11756                                  	;invoke	std_eprintf		;AN022; print out the error
 11757 00000A9C E8864A                  	call	std_eprintf
 11758                                  	;mov	byte ptr combuf+2,end_of_line_in
 11759 00000A9F C606[769C]0D            	mov	byte [COMBUF+2],END_OF_LINE_IN ; 0Dh
 11760                                  	;				;AN022; terminate the batch line for parsing
 11761                                  	;mov	byte ptr combuf+3,end_of_line_out 
 11762 00000AA4 C606[779C]00            	mov	byte [COMBUF+3],END_OF_LINE_OUT ; 0
 11763                                  	;				;AN022; terminate the batch line for output
 11764                                  ;M020;
 11765                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
 11766                                  ;error is never hit (and it shouldn't be)
 11767                                  
 11768 00000AA9 8E1E[159E]              	mov	ds,[RESSEG]		; ds = RESGROUP ; M020
 11769 00000AAD EB6A                    	jmp	short BATEOF		;AN022; terminate the batch file
 11770                                  bat_read_ok:				;AN022;
 11771                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11772 00000AAF 89C1                    	mov	cx,ax
 11773                                  	;jcxz	TURN_OFF ; MSDOS 3.3
 11774                                  	; 14/02/2023
 11775 00000AB1 E320                    	jcxz	BATEOFDS ; MSDOS 6.0
 11776 00000AB3 890E[01AA]              	mov	[BATBUFEND],cx
 11777 00000AB7 31DB                    	xor	bx,bx
 11778 00000AB9 891E[DFA9]              	mov	[BATBUFPOS],bx
 11779                                  
 11780                                  	; Buffered bytes!
 11781                                  UNBUF:
 11782 00000ABD 8A87[E1A9]              	mov	al,[BATBUF+bx]		; get next byte
 11783 00000AC1 43                      	inc	bx
 11784 00000AC2 3B1E[01AA]              	cmp	bx,[BATBUFEND]		; beyond end of buffer?
 11785 00000AC6 7203                    	jb	short SETBUFPOS
 11786 00000AC8 BBFFFF                  	mov	bx,-1
 11787                                  SETBUFPOS:
 11788 00000ACB 891E[DFA9]              	mov	[BATBUFPOS],bx
 11789 00000ACF 3C1A                    	cmp	al,1Ah			; ^Z for termination?
 11790 00000AD1 7575                    	jne	short GETBYTEDONE
 11791                                  
 11792                                  ;We get here only when we hit an EOF
 11793                                  	
 11794                                  	; MSDOS 6.0
 11795                                  BATEOFDS:
 11796                                  ;SR;
 11797                                  ; HACK!!! A massive hack being put in here to get batch processing to work
 11798                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
 11799                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
 11800                                  ;batch processing is turned off before the last line is processed and so 
 11801                                  ;this line would never be executed. 
 11802                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
 11803                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
 11804                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
 11805                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
 11806                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
 11807                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
 11808                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
 11809                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
 11810                                  ;during this call, and there was a CR-LF previously, we are going to fake
 11811                                  ;another redundant CR-LF. There is no work-around I can think of.
 11812                                  ; 	I would love to restructure this entire routine and its caller to
 11813                                  ;make the flow really easy to understand but I guess this will have to wait.
 11814                                  ;
 11815 00000AD3 06                      	push	es
 11816 00000AD4 8E06[159E]              	mov	es,[RESSEG]
 11817                                  ;SR;
 11818                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
 11819                                  ;or BatchEOF == 1 now), then do not do the LF check.
 11820                                  ;
 11821 00000AD8 268E06[E701]            	mov	es,[es:Batch]
 11822                                  	;cmp	byte [es:2],0
 11823 00000ADD 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11824 00000AE3 7516                    	jnz	short crpresent
 11825                                  
 11826                                  	;inc	byte [es:2]
 11827 00000AE5 26FE060200              	inc	byte [es:BATCHSEGMENT.BatchEOF]
 11828                                  					;match the dec following
 11829 00000AEA 8B1E[01AA]              	mov	bx,[BATBUFEND]
 11830 00000AEE 80BF[E0A9]0A            	cmp	byte [bx+BATBUF-1],0Ah	;was a LF present?
 11831 00000AF3 7406                    	je	short crpresent		;yes, no need to fake it
 11832                                  
 11833                                  	;add	byte [es:2],3
 11834 00000AF5 268006020003            	add	byte [es:BATCHSEGMENT.BatchEOF],3
 11835                                  					;BatchEOF == 4 to fake CR-LF
 11836                                  crpresent:
 11837                                  ;;	;pop	es
 11838                                  
 11839                                  	;ASSUME	DS:TranGroup
 11840                                  	; 14/02/2023
 11841 00000AFB 8E1E[159E]              	mov	ds,[RESSEG]
 11842                                  	;ASSUME	DS:ResGroup
 11843                                  ;SR;
 11844                                  ; The shift operation is done here to replace the decrement. This is because
 11845                                  ;we can jump to this label directly from above when bogus calls are made to
 11846                                  ;this routine even after batch processing is turned off. The shift ensures
 11847                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
 11848                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
 11849                                  ;calls.
 11850                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
 11851                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
 11852                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
 11853                                  ;turning batch processing off.
 11854                                  
 11855                                  At_EOF:					;new label added ;M020
 11856                                  	;shr	byte [es:2],1
 11857 00000AFF 26D02E0200              	shr	byte [es:BATCHSEGMENT.BatchEOF],1
 11858                                  					;decrement the flag
 11859 00000B04 7412                    	jz	short turn_off		;zero,turn batch off
 11860                                  	;cmp	byte [es:2],1
 11861 00000B06 26803E020001            	cmp	byte [es:BATCHSEGMENT.BatchEOF],1				
 11862 00000B0C 7405                    	jz	short ret_lf		;BatchEOF was 2, return LF
 11863                                  ;
 11864                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
 11865                                  ;
 11866 00000B0E B00D                    	mov	al,0Dh			;return fake CR.
 11867 00000B10 07                      	pop	es
 11868 00000B11 EB35                    	jmp	short GETBYTEDONE
 11869                                  ret_lf:
 11870 00000B13 B00A                    	mov	al,0Ah			;return fake LF
 11871 00000B15 07                      	pop	es
 11872 00000B16 EB30                    	jmp	short GETBYTEDONE		
 11873                                  turn_off:
 11874 00000B18 07                      	pop	es
 11875                                  ;BATEOF:
 11876                                  	; MSDOS 3.3
 11877                                  ;TURN_OFF:
 11878                                  	;mov	ds,[RESSEG]
 11879                                  
 11880                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11881                                  BATEOF:
 11882 00000B19 E8B3FE                  	call	BATCHOFF
 11883 00000B1C E8CC02                  	call	BATCLOSE
 11884                                  
 11885                                  ;;;	mov	BatchEOF,0	;make sure BatchEOF = 0
 11886                                  
 11887                                  ;SR; BugBug
 11888                                  ; There is a good reason why this carriage return is being returned here. 
 11889                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
 11890                                  ;of the way the caller is structured, a fake CR has to be returned again on
 11891                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
 11892                                  ;results in an extra linefeed after the batchfile is run if the last line of
 11893                                  ;the batchfile already had a CR-LF. 
 11894                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
 11895                                  ;the end-of-line. This CR is to mark the end-of-file.
 11896                                  
 11897 00000B1F B00D                    	mov	al,0Dh			; If end-of-file, then end of line
 11898 00000B21 F606[3102]FF            	test	byte [Batch_Abort],-1
 11899 00000B26 C606[3102]00            	mov	byte [Batch_Abort],0
 11900 00000B2B 7407                    	jz	short CONT_GET_BYT
 11901 00000B2D BF[769C]                	mov	di,COMBUF+2		; reset pointer to beginning of buffer
 11902 00000B30 31C9                    	xor	cx,cx			; zero line length
 11903 00000B32 EB14                    	jmp	short GETBYTEDONE
 11904                                  CONT_GET_BYT:
 11905 00000B34 833E[4302]F0            	cmp	word [SingleCom],0FFF0h ; See if we need to set SINGLECOM
 11906 00000B39 750D                    	jne	short GETBYTEDONE
 11907 00000B3B 833E[4C02]00            	cmp	word [Nest],0		;G See if we have nested batch files
 11908 00000B40 7506                    	jnz	short GETBYTEDONE	;G Yes - don't exit just yet
 11909 00000B42 C706[4302]FFFF          	mov	word [SingleCom],0FFFFh	; -1 ; Cause termination
 11910                                  GETBYTEDONE:
 11911 00000B48 1F                      	pop	ds
 11912 00000B49 59                      	pop	cx
 11913 00000B4A 5B                      	pop	bx
 11914 00000B4B C3                      	retn
 11915                                  
 11916                                  ; ---------------------------------------------------------------------------
 11917                                  
 11918                                  ;break	<$If - conditional execution>
 11919                                  
 11920                                  	; 17/04/2023
 11921                                  ;IFERRORP:
 11922                                  ;	pop	ax
 11923                                  ;IFERROR:
 11924                                  ;	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11925                                  ;FORERROR:
 11926                                  ;	mov	dx,SYNTMES_PTR
 11927                                  ;	jmp	cerror
 11928                                  
 11929                                  ; ---------------------------------------------------------------------------
 11930                                  
 11931                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11932                                  	;
 11933                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 11934                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0B69h
 11935                                  _$IF:
 11936                                  	; MSDOS 6.0
 11937                                  ; Turn off any pipes in progress.
 11938 00000B4C 1E                      	push	ds			;AN004; save local DS
 11939 00000B4D 8E1E[159E]              	mov	ds,[RESSEG]		;AN004; get resident segment
 11940                                  	;assume	ds:resgroup		;AN004;
 11941 00000B51 803E[B602]00            	cmp	byte [PipeFiles],0	;AN004; Only turn off if present.
 11942 00000B56 7403                    	jz	short IFNoPipe		;AN004; no pipe - continue
 11943                                  	;invoke	PipeDel 		;AN004; turn off piping
 11944 00000B58 E8E226                  	call	PIPEDEL	
 11945                                  IFNoPipe:				;AN004;
 11946 00000B5B 1F                      	pop	ds			;AN004; get local DS back
 11947                                  	;assume	ds:trangroup		;AN004;
 11948                                  
 11949                                  	; MSDOS 3.3 (&MSDOS 6.0)
 11950 00000B5C C606[289E]00            	mov	byte [IFNOTFLAG],0
 11951 00000B61 C706[B3A8]0000          	mov	word [IF_NOT_COUNT],0
 11952 00000B67 BE8100                  	mov	si,81h
 11953                                  IFREENT:
 11954 00000B6A E8C11F                  	call	scanoff
 11955 00000B6D 3C0D                    	cmp	al,0Dh
 11956 00000B6F 743C                    	je	short IFERROR
 11957 00000B71 89F5                    	mov	bp,si
 11958 00000B73 BF[E595]                	mov	di,IFTAB		; Prepare to search if table	
 11959                                  	;mov	ch,0
 11960                                  	; 17/04/2023
 11961 00000B76 30ED                    	xor	ch,ch
 11962                                  IFINDCOM:
 11963 00000B78 89EE                    	mov	si,bp
 11964 00000B7A 8A0D                    	mov	cl,[di]
 11965 00000B7C 47                      	inc	di
 11966 00000B7D E33E                    	jcxz	IFSTRING
 11967 00000B7F EB02                    	jmp	short FIRSTCOMP
 11968                                  IFCOMP:
 11969 00000B81 7510                    	jnz	short IF_DIF
 11970                                  FIRSTCOMP:
 11971 00000B83 AC                      	lodsb
 11972 00000B84 268A25                  	mov	ah,[es:di]
 11973 00000B87 47                      	inc	di
 11974 00000B88 38E0                    	cmp	al,ah
 11975 00000B8A 7405                    	je	short IFLP
 11976 00000B8C 80CC20                  	or	ah,20h			; Try lower case
 11977 00000B8F 38E0                    	cmp	al,ah
 11978                                  IFLP:
 11979 00000B91 E2EE                    	loop	IFCOMP
 11980                                  IF_DIF:
 11981 00000B93 9F                      	lahf
 11982 00000B94 01CF                    	add	di,cx			; Bump to next position without affecting flags
 11983 00000B96 8B1D                    	mov	bx,[di]			; Get handler address
 11984 00000B98 47                      	inc	di
 11985 00000B99 47                      	inc	di
 11986 00000B9A 9E                      	sahf
 11987 00000B9B 75DB                    	jnz	short IFINDCOM
 11988 00000B9D AC                      	lodsb
 11989 00000B9E 3C0D                    	cmp	al,0Dh
 11990                                  IFERRJ:
 11991 00000BA0 740B                    	jz	short IFERROR
 11992 00000BA2 E8911F                  	call	DELIM
 11993 00000BA5 75D1                    	jnz	short IFINDCOM
 11994 00000BA7 E8841F                  	call	scanoff
 11995 00000BAA FFE3                    	jmp	bx
 11996                                  
 11997                                  	; 17/04/2023
 11998                                  IFERRORP:
 11999 00000BAC 58                      	pop	ax
 12000                                  IFERROR:
 12001                                  	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 12002                                  FORERROR:
 12003 00000BAD BA[8B92]                	mov	dx,SYNTMES_PTR
 12004 00000BB0 E9EF22                  	jmp	cerror
 12005                                  
 12006                                  IFNOT:
 12007 00000BB3 F616[289E]              	not	byte [IFNOTFLAG]
 12008 00000BB7 FF06[B3A8]              	inc	word [IF_NOT_COUNT]
 12009 00000BBB EBAD                    	jmp	short IFREENT
 12010                                  
 12011                                  ; We are comparing two strings for equality. First, find the end of the
 12012                                  ; first string.
 12013                                  
 12014                                  IFSTRING:
 12015 00000BBD 56                      	push	si			; save away pointer for later compare
 12016 00000BBE 31C9                    	xor	cx,cx			; count of chars in first string
 12017                                  FIRST_STRING:
 12018 00000BC0 AC                      	lodsb				; get character
 12019 00000BC1 3C0D                    	cmp	al,0Dh			; end of line?
 12020 00000BC3 74E7                    	jz	short IFERRORP		; yes => error
 12021 00000BC5 E86E1F                  	call	DELIM			; is it a delimiter?
 12022 00000BC8 7403                    	jz	short EQUAL_CHECK 	; yes, go find equal sign
 12023 00000BCA 41                      	inc	cx			; remember 1 byte for the length
 12024 00000BCB EBF3                    	jmp	short FIRST_STRING 	; go back for more
 12025                                  EQUAL_CHECK:
 12026 00000BCD 3C3D                    	cmp	al,'='			; is char we have an = sign?
 12027 00000BCF 7407                    	je	short EQUAL_CHECK2 	; yes, go find second one.
 12028 00000BD1 3C0D                    	cmp	al,0Dh			; end of line?
 12029 00000BD3 74D7                    	je	short IFERRORP		; yes, syntax error
 12030 00000BD5 AC                      	lodsb				; get next char
 12031 00000BD6 EBF5                    	jmp	short EQUAL_CHECK
 12032                                  
 12033                                  ; The first = has been found. The next char had better be an = too.
 12034                                  
 12035                                  EQUAL_CHECK2:
 12036 00000BD8 AC                      	lodsb				; get potential = char
 12037 00000BD9 3C3D                    	cmp	al,'='			; is it good?	
 12038                                  	;jnz	short IFERRPJ		; no, error
 12039                                  	; 17/04/2023
 12040 00000BDB 75CF                    	jne	short IFERRORP
 12041                                  
 12042                                  ; Find beginning of second string.
 12043                                  
 12044 00000BDD E84E1F                  	call	scanoff
 12045 00000BE0 3C0D                    	cmp	al,0Dh
 12046                                  	;jz	short IFERRPJ
 12047                                  	; 17/04/2023
 12048 00000BE2 74C8                    	je	short IFERRORP
 12049 00000BE4 5F                      	pop	di
 12050                                  
 12051                                  ; DS:SI points to second string
 12052                                  ; CX has number of chars in first string
 12053                                  ; ES:DI points to first string
 12054                                  
 12055 00000BE5 F3A6                    	repe	cmpsb
 12056 00000BE7 7414                    	jz	short MATCH		; match found!
 12057                                  
 12058                                  ; No match. Let's find out what was wrong. The character that did not match
 12059                                  ; has been advanced over. Let's back up to it.
 12060                                  
 12061 00000BE9 4E                      	dec	si
 12062                                  
 12063                                  ; If it is EOL, then syntax error
 12064                                  
 12065 00000BEA 803C0D                  	cmp	byte [si],0Dh
 12066                                  	;jz	short IFERRJ
 12067                                  	; 17/04/2023
 12068 00000BED 74BE                    	je	short IFERROR
 12069                                  
 12070                                  ; Advance pointer over remainder of unmatched text to next delimiter
 12071                                  
 12072                                  SKIPSTRINGEND:
 12073 00000BEF AC                      	lodsb
 12074                                  NOTMATCH:
 12075 00000BF0 3C0D                    	cmp	al,0Dh
 12076                                  IFERRORJ2:
 12077                                  	;jz	short IFERRJ
 12078                                  	; 17/04/2023
 12079 00000BF2 74B9                    	jz	short IFERROR
 12080 00000BF4 E83F1F                  	call	DELIM
 12081 00000BF7 75F6                    	jnz	short SKIPSTRINGEND
 12082                                  
 12083                                  ; Signal that we did NOT have a match
 12084                                  
 12085 00000BF9 B0FF                    	mov	al,-1	 ; 0FFh
 12086 00000BFB EB37                    	jmp	short IFRET
 12087                                  
 12088                                  	; 17/04/2023
 12089                                  ;IFERRPJ:
 12090                                  	;jmp	IFERRORP
 12091                                  
 12092                                  ; The compare succeeded. Was the second string longer than the first?
 12093                                  ; We do this by seeing if the next char is a delimiter.
 12094                                  
 12095                                  MATCH:
 12096 00000BFD AC                      	lodsb
 12097 00000BFE E8351F                  	call	DELIM
 12098 00000C01 75ED                    	jnz	short NOTMATCH ; not same.
 12099 00000C03 30C0                    	xor	al,al
 12100 00000C05 EB2D                    	jmp	short IFRET
 12101                                  
 12102                                  ; ---------------------------------------------------------------------------
 12103                                  
 12104                                  IFEXISTS:
 12105                                  
 12106                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
 12107                                  
 12108                                  ;MOREDELIM:
 12109 00000C07 AC                      	lodsb
 12110 00000C08 E82B1F                  	call	DELIM
 12111 00000C0B 75FA                    	jnz	short IFEXISTS
 12112                                  	;jnz	short MOREDELIM
 12113                                  
 12114 00000C0D BA[50A0]                	mov	dx,DIRBUF
 12115 00000C10 B8001A                  	mov	ax,1A00h
 12116                                  	;mov	ax,Set_DMA*256 ; 1A00h
 12117 00000C13 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 12118                                  			; DS:DX	-> disk	transfer buffer
 12119 00000C15 BB0200                  	mov	bx,2	; if(0) [|not](|1) exist[1|2] file(2|3)
 12120 00000C18 031E[B3A8]              	add	bx,[IF_NOT_COUNT]
 12121                                  	;mov	ax,ARG_ARGV
 12122                                  	;mov	ax,ARG+ARG_UNIT.argv
 12123 00000C1C B8[67A2]                	mov	ax,ARG
 12124 00000C1F E87C2A                  	call	argv_calc		; convert arg index to pointer
 12125 00000C22 8B17                    	mov	dx,[bx]
 12126                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 12127                                  	;mov	cx,6
 12128 00000C24 B90600                  	mov	cx,IFEXIST_ATTR ; filetypes to search for
 12129 00000C27 B8004E                  	mov	ax,4E00h
 12130                                  	;mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 12131 00000C2A CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 12132                                  			; CX = search attributes
 12133                                  			; DS:DX	-> ASCIZ filespec
 12134                                  			; (drive,path, and wildcards allowed)
 12135 00000C2C 7204                    	jc	short IF_EX_C ; carry is how to determine error
 12136 00000C2E 30C0                    	xor	al,al
 12137 00000C30 EB02                    	jmp	short IFRET
 12138                                  
 12139                                  	;nop
 12140                                  IF_EX_C:
 12141 00000C32 B0FF                    	mov	al,-1	; 0FFh	; false 'n' fall through...
 12142                                  IFRET:
 12143 00000C34 F606[289E]FF            	test	byte [IFNOTFLAG],-1 ; 0FFh
 12144 00000C39 7402                    	jz	short REALTEST
 12145 00000C3B F6D0                    	not	al
 12146                                  REALTEST:
 12147 00000C3D 08C0                    	or	al,al
 12148 00000C3F 7403                    	jz	short IFTRUE
 12149 00000C41 E9C0F4                  	jmp	TCOMMAND
 12150                                  
 12151                                  IFTRUE:
 12152 00000C44 E8E71E                  	call	scanoff
 12153 00000C47 89F1                    	mov	cx,si
 12154 00000C49 81E98100                	sub	cx,81h
 12155 00000C4D 280E8000                	sub	[80h],cl
 12156 00000C51 8A0E8000                	mov	cl,[80h]
 12157 00000C55 880E[759C]              	mov	[COMBUF+1],cl
 12158 00000C59 BF[769C]                	mov	di,COMBUF+2
 12159 00000C5C FC                      	cld
 12160 00000C5D F3A4                    	rep	movsb
 12161 00000C5F B00D                    	mov	al,0Dh
 12162 00000C61 AA                      	stosb
 12163                                  
 12164                                  ; Signal that an IF was done. 
 12165                                  ; This prevents the redirections from getting lost.
 12166                                  
 12167 00000C62 1E                      	push	ds
 12168 00000C63 8E1E[159E]              	mov	ds,[RESSEG]
 12169 00000C67 C606[4802]FF            	mov	byte [IfFlag],-1
 12170 00000C6C 1F                      	pop	ds
 12171                                  
 12172                                  ; Go do the command
 12173                                  
 12174                                  	;jmp	DOCOM1 ; MSDOS 5.0 COMMAND.COM
 12175                                  	; 07/06/2023
 12176                                  	; Retro DOS v4.2 COMMAND.COM
 12177 00000C6D E983F6                  	jmp	DOCOM0 ; MSDOS 6.22 COMMAND.COM
 12178                                  
 12179                                  ; ---------------------------------------------------------------------------
 12180                                  
 12181                                  IFERRORJ3:
 12182 00000C70 EB80                    	jmp	IFERRORJ2
 12183                                  
 12184                                  IFERLEV:
 12185 00000C72 B70A                    	mov	bh,10
 12186 00000C74 30DB                    	xor	bl,bl
 12187                                  GETNUMLP:
 12188 00000C76 AC                      	lodsb
 12189 00000C77 3C0D                    	cmp	al,0Dh
 12190 00000C79 74F5                    	je	short IFERRORJ3
 12191 00000C7B E8B81E                  	call	DELIM
 12192 00000C7E 740C                    	jz	short GOTNUM
 12193 00000C80 2C30                    	sub	al,'0'
 12194 00000C82 86C3                    	xchg	al,bl
 12195 00000C84 F6E7                    	mul	bh
 12196 00000C86 00D8                    	add	al,bl
 12197 00000C88 86C3                    	xchg	al,bl
 12198 00000C8A EBEA                    	jmp	short GETNUMLP
 12199                                  GOTNUM:
 12200 00000C8C 1E                      	push	ds
 12201 00000C8D 8E1E[159E]              	mov	ds,[RESSEG]
 12202 00000C91 8A26[3802]              	mov	ah,[RetCode]
 12203 00000C95 1F                      	pop	ds
 12204 00000C96 30C0                    	xor	al,al
 12205 00000C98 38DC                    	cmp	ah,bl
 12206 00000C9A 7398                    	jnb	short IFRET
 12207 00000C9C FEC8                    	dec	al
 12208 00000C9E EB94                    	jmp	short IFRET
 12209                                  
 12210                                  ; ---------------------------------------------------------------------------
 12211                                  
 12212                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
 12213                                  ; This is a NOP if no batch in progress.
 12214                                  
 12215                                  _SHIFT:
 12216 00000CA0 8E1E[159E]              	mov	ds,[RESSEG]
 12217 00000CA4 A1[E701]                	mov	ax,[Batch]		; get batch pointer
 12218 00000CA7 09C0                    	or	ax,ax			; in batch mode?
 12219 00000CA9 7501                    	jnz	short SHIFT1		; yes, operate in batch segment	
 12220                                  SHIFT_RETN:				; no, done.
 12221 00000CAB C3                      	retn
 12222                                  SHIFT1:
 12223 00000CAC 8EC0                    	mov	es,ax
 12224 00000CAE 8ED8                    	mov	ds,ax
 12225                                  
 12226                                  ; Now move the batch args down by 1 word
 12227                                  
 12228                                  	;;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
 12229                                  	;mov	di,0Ch ; MSDOS 5.0 COMMAND.COM
 12230 00000CB0 BF0C00                  	mov	di,BATCHSEGMENT.BatParm ; point to parm table
 12231 00000CB3 8D7502                  	lea	si,[di+2]		; make source = dest + 2
 12232 00000CB6 B90900                  	mov	cx,9			; move 9 parameters
 12233 00000CB9 F3A5                    	rep	movsw			; SHIFT down
 12234                                  
 12235                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
 12236                                  ; We have copied it into the previous position.
 12237                                  
 12238 00000CBB 833DFF                  	cmp	word [di],-1	; if last one was not in use then
 12239 00000CBE 74EB                    	je	short SHIFT_RETN ; No new parm
 12240                                  
 12241                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
 12242                                  ; Assume, first, that there is no next argument.
 12243                                   
 12244 00000CC0 8B35                    	mov	si,[di]
 12245 00000CC2 C705FFFF                	mov	word [di],-1		; Assume no parm
 12246                                  
 12247                                  ; The parameters are CR separated. Scan for end of this parm.
 12248                                  
 12249                                  SKIPCRLP:
 12250 00000CC6 AC                      	lodsb
 12251 00000CC7 3C0D                    	cmp	al,0Dh
 12252 00000CC9 75FB                    	jne	short SKIPCRLP
 12253                                  
 12254                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
 12255                                  ; are finished. There are no more parms and the pointer has been previously
 12256                                  ; initialized to indicate it.
 12257                                  
 12258 00000CCB 803C00                  	cmp	byte [si],0
 12259 00000CCE 74DB                    	jz	short SHIFT_RETN 	; End of parms
 12260 00000CD0 8935                    	mov	[di],si			; Pointer to next parm as %9
 12261 00000CD2 C3                      	retn
 12262                                  
 12263                                  ; =============== S U B	R O U T	I N E =======================================
 12264                                  
 12265                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
 12266                                  ; returns char in AL, carry set -> eof
 12267                                  
 12268                                  SKIPDELIM:
 12269 00000CD3 F706[E701]FFFF          	test	word [Batch],-1		; batch file empty. OOPS!
 12270 00000CD9 740A                    	jz	short SKIPERR
 12271 00000CDB E85DFD                  	call	GETBATBYT		; get a char
 12272 00000CDE E8551E                  	call	DELIM			; check for ignoreable chars
 12273 00000CE1 74F0                    	jz	short SKIPDELIM		; ignore this char.
 12274 00000CE3 F8                      	clc
 12275 00000CE4 C3                      	retn
 12276                                  SKIPERR:
 12277 00000CE5 F9                      	stc
 12278                                  GOTO_RETN:
 12279 00000CE6 C3                      	retn
 12280                                  
 12281                                  ; ---------------------------------------------------------------------------
 12282                                  
 12283                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
 12284                                  ;  .com file. This routine strips the CALL off the command line, sets
 12285                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
 12286                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
 12287                                  ;  being CALLed.
 12288                                  
 12289                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12290                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0C27h
 12291                                  
 12292                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 12293                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0D01h
 12294                                  _$CALL:
 12295                                  
 12296                                  ;  strip off CALL from command line
 12297                                  
 12298                                  	;ASSUME DS:trangroup,ES:trangroup
 12299                                  
 12300 00000CE7 56                      	push	si
 12301 00000CE8 57                      	push	di
 12302 00000CE9 50                      	push	ax
 12303 00000CEA 51                      	push	cx
 12304 00000CEB BE[769C]                	mov	si,COMBUF+2
 12305 00000CEE E83D1E                  	call	scanoff			;get to first non-delimeter
 12306                                  	;add	si,4
 12307 00000CF1 83C604                  	add	si,length_call		;point to char past CALL
 12308 00000CF4 BF[769C]                	mov	di,COMBUF+2
 12309                                  	;mov	cx,124		
 12310 00000CF7 B97C00                  	mov	cx,COMBUFLEN-length_call 
 12311                                  					;get length of buffer
 12312 00000CFA F3A4                    	rep	movsb			;move it
 12313 00000CFC 59                      	pop	cx
 12314 00000CFD 58                      	pop	ax
 12315 00000CFE 5F                      	pop	di
 12316 00000CFF 5E                      	pop	si
 12317                                  
 12318                                  ;  set call flag to indicate call in progress
 12319                                  
 12320 00000D00 1E                      	push	ds
 12321 00000D01 8E1E[159E]              	mov	ds,[RESSEG]
 12322 00000D05 C606[4E02]01            	mov	byte [Call_Flag],call_in_progress ; 1
 12323 00000D0A C606[4F02]01            	mov	byte [Call_Batch_Flag],call_in_progress ; 1
 12324                                  
 12325                                  ; Turn off any pipes in progress.
 12326                                  
 12327 00000D0F 803E[B602]00            	cmp	byte [PipeFiles],0 	; Only turn off if present.
 12328 00000D14 7403                    	jz	short _NOPIPE
 12329 00000D16 E82425                  	call	PIPEDEL
 12330                                  _NOPIPE:
 12331 00000D19 1F                      	pop	ds
 12332 00000D1A C3                      	retn
 12333                                  
 12334                                  ; ---------------------------------------------------------------------------
 12335                                  
 12336                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12337                                  _GOTO:
 12338 00000D1B 8E1E[159E]              	mov	ds,[RESSEG]
 12339 00000D1F F706[E701]FFFF          	test	word [Batch],-1	; If not in batch mode, a nop
 12340 00000D25 74BF                    	jz	short GOTO_RETN
 12341 00000D27 31D2                    	xor	dx,dx
 12342 00000D29 1E                      	push	ds
 12343 00000D2A 8E1E[E701]              	mov	ds,[Batch]
 12344                                  	;mov	[8],dx	; MSDOS 5.0 COMMAND.COM
 12345 00000D2E 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
 12346                                  	;mov	[10],dx	; MSDOS 5.0 COMMAND.COM
 12347 00000D32 89160A00                	mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
 12348                                  
 12349                                  	; MSDOS 6.0
 12350                                  ;M037
 12351                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
 12352                                  ;
 12353 00000D36 C606020000              	mov	byte [BATCHSEGMENT.BatchEOF],0
 12354                                  					; clear eof indicator ;M037
 12355                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12356 00000D3B 1F                      	pop	ds
 12357                                  GOTOOPEN:
 12358 00000D3C E875F8                  	call	PROMPTBAT
 12359                                  	;mov	di,5Dh
 12360 00000D3F BF5D00                  	mov	di,FCB+1		; Get the label
 12361 00000D42 B90B00                  	mov	cx,11
 12362 00000D45 B020                    	mov	al,' '
 12363 00000D47 F2AE                    	repne	scasb
 12364 00000D49 7501                    	jnz	short NOINC
 12365 00000D4B 41                      	inc	cx
 12366                                  NOINC:
 12367 00000D4C 83E90B                  	sub	cx,11
 12368 00000D4F F7D9                    	neg	cx
 12369                                  	;mov	[cs:GOTOLEN],cx
 12370                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12371 00000D51 26890E[50A0]            	mov	[es:GOTOLEN],cx	; MSDOS 5.0 (& 6.0)
 12372                                  
 12373                                  ; At beginning of file. Skip to first non-delimiter char
 12374                                  
 12375 00000D56 E87AFF                  	call	SKIPDELIM
 12376 00000D59 721C                    	jb	short BADGOTO
 12377 00000D5B 3C3A                    	cmp	al,':'
 12378 00000D5D 7426                    	jz	short CHKLABEL
 12379                                  LABLKLP:				; Look for the label
 12380 00000D5F E8D9FC                  	call	GETBATBYT
 12381 00000D62 3C0A                    	cmp	al,0Ah
 12382 00000D64 7509                    	jne	short LABLKTST
 12383                                  
 12384                                  ; At beginning of line. Skip to first non-delimiter char
 12385                                  
 12386 00000D66 E86AFF                  	call	SKIPDELIM
 12387 00000D69 720C                    	jb	short BADGOTO
 12388 00000D6B 3C3A                    	cmp	al,':'
 12389 00000D6D 7416                    	je	short CHKLABEL
 12390                                  LABLKTST:
 12391 00000D6F F706[E701]FFFF          	test	word [Batch],0FFFFh ; -1
 12392 00000D75 75E8                    	jnz	short LABLKLP
 12393                                  BADGOTO:
 12394 00000D77 E87100                  	call	BATCLOSE
 12395                                  
 12396                                  	; MSDOS 6.0
 12397                                  ;SR;
 12398                                  ; At this point we are terminating without freeing up any nested batch 
 12399                                  ;segments i.e if the error occurred within a called batch file. This routine
 12400                                  ;will traverse the linked list of batch segments and free all of them.
 12401                                  ;
 12402 00000D7A E8BB00                  	call	free_batch		; free up nested batch segments
 12403                                  
 12404                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12405 00000D7D 0E                      	push	cs
 12406 00000D7E 1F                      	pop	ds
 12407 00000D7F BA[8892]                	mov	dx,BADLAB_PTR
 12408 00000D82 E91D21                  	jmp	cerror
 12409                                  
 12410                                  ; Found the :.	Skip to first non-delimiter char
 12411                                  
 12412                                  CHKLABEL:
 12413 00000D85 E84BFF                  	call	SKIPDELIM
 12414 00000D88 72ED                    	jb	short BADGOTO
 12415 00000D8A BF5D00                  	mov	di,FCB+1 ; 5Dh
 12416                                  	;mov	cx,[cs:GOTOLEN]
 12417                                  	; 14/02/2023
 12418 00000D8D 268B0E[50A0]            	mov	cx,[es:GOTOLEN]	 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12419 00000D92 EB05                    	jmp	short GOTBYTE
 12420                                  
 12421                                  NEXTCHRLP:
 12422 00000D94 51                      	push	cx
 12423 00000D95 E8A3FC                  	call	GETBATBYT
 12424 00000D98 59                      	pop	cx
 12425                                  GOTBYTE:
 12426                                  	; 18/03/2023
 12427                                  	; 14/02/2023
 12428                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CD9h
 12429 00000D99 E8731B                  	call	testkanj
 12430 00000D9C 7413                    	jz	short NOTKANJ1
 12431 00000D9E 263A05                  	cmp	al,[es:di]
 12432 00000DA1 75CC                    	jne	short LABLKTST
 12433 00000DA3 47                      	inc	di
 12434 00000DA4 49                      	dec	cx
 12435 00000DA5 E3C8                    	jcxz	LABLKTST
 12436 00000DA7 51                      	push	cx
 12437 00000DA8 E890FC                  	call	GETBATBYT
 12438 00000DAB 59                      	pop	cx
 12439 00000DAC 263A05                  	cmp	al,[es:di]
 12440 00000DAF EB0C                    	jmp	short KNEXTLABCHR
 12441                                  NOTKANJ1:
 12442                                  	; 14/02/2023
 12443                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CF1h
 12444 00000DB1 0C20                    	or	al,20h
 12445 00000DB3 263A05                  	cmp	al,[es:di]
 12446                                  	;jne	short TRYUPPER
 12447                                  	;jmp	short NEXTLABCHR
 12448                                  	; 25/04/2023
 12449 00000DB6 7407                    	je	short NEXTLABCHR 
 12450                                  TRYUPPER:
 12451 00000DB8 2C20                    	sub	al,20h
 12452 00000DBA 263A05                  	cmp	al,[es:di]
 12453                                  KNEXTLABCHR:
 12454 00000DBD 75B0                    	jnz	short LABLKTST
 12455                                  NEXTLABCHR:
 12456 00000DBF 47                      	inc	di
 12457 00000DC0 E2D2                    	loop	NEXTCHRLP
 12458 00000DC2 E876FC                  	call	GETBATBYT
 12459                                  	; 14/02/2023
 12460 00000DC5 26833E[50A0]08          	cmp	word [es:GOTOLEN],8 ;  MSDOS 5.0 (& 6.0) COMMAND.COM
 12461                                  	;cmp	word [cs:GOTOLEN],8 ; Is the label at least 8 chars long?
 12462 00000DCB 7D04                    	jge	short GOTOCONT	; Yes, then the next char doesn't matter
 12463 00000DCD 3C20                    	cmp	al,' '
 12464 00000DCF 779E                    	ja	short LABLKTST
 12465                                  GOTOCONT:
 12466 00000DD1 3C0D                    	cmp	al,0Dh
 12467 00000DD3 7407                    	je	short SKIPLFEED
 12468                                  TONEXTBATLIN:
 12469 00000DD5 E863FC                  	call	GETBATBYT
 12470 00000DD8 3C0D                    	cmp	al,0Dh
 12471 00000DDA 75F9                    	jne	short TONEXTBATLIN
 12472                                  SKIPLFEED:
 12473 00000DDC E85CFC                  	call	GETBATBYT
 12474                                  
 12475                                  	; MSDOS 6.0
 12476                                  ;SR;
 12477                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
 12478                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
 12479                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
 12480                                  ;to get the EOF has not been made yet because we encountered the Goto. On
 12481                                  ;all other cases, EOF will be hit while trying to read the next line and
 12482                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
 12483                                  ;
 12484 00000DDF 06                      	push	es
 12485 00000DE0 8E06[E701]              	mov	es,[Batch]
 12486 00000DE4 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 12487                                  					;invalidate fake CR-LF flag
 12488 00000DEA 07                      	pop	es
 12489                                  
 12490                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12491                                  	;call	BATCLOSE
 12492                                  	;retn
 12493                                  	; 14/02/2023
 12494                                  	;jmp	short BATCLOSE
 12495                                  
 12496                                  ; =============== S U B	R O U T	I N E =======================================
 12497                                  
 12498                                  BATCLOSE:
 12499 00000DEB 2E8B1E[0BA2]            	mov	bx,[cs:BATHAND]
 12500 00000DF0 83FB05                  	cmp	bx,5
 12501 00000DF3 7204                    	jb	short CLOSERETURN
 12502                                  	; 14/02/2023
 12503 00000DF5 B43E                    	mov	ah,3Eh
 12504                                  	;mov	ah,CLOSE ; 3Eh
 12505 00000DF7 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 12506                                  			; BX = file handle
 12507                                  CLOSERETURN:
 12508 00000DF9 C606[3002]00            	mov	byte [In_Batch],0 ; reset flag	
 12509 00000DFE C3                      	retn
 12510                                  
 12511                                  ; =============== S U B	R O U T	I N E =======================================
 12512                                  
 12513                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
 12514                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
 12515                                  
 12516                                  	; 14/02/2023
 12517                                  BATOPEN:
 12518 00000DFF 1E                      	push	ds
 12519 00000E00 8E1E[E701]              	mov	ds,[Batch]
 12520                                  	;;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
 12521                                  	;mov	dx,20h	; MSDOS 5.0 COMMAND.COM
 12522 00000E04 BA2000                  	mov	dx,BATCHSEGMENT.BatFile
 12523 00000E07 B8003D                  	mov	ax,3D00h
 12524                                  	;mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
 12525 00000E0A CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 12526                                  			; DS:DX	-> ASCIZ filename
 12527                                  			; AL = access mode
 12528                                  			; 0 - read
 12529 00000E0C 721C                    	jc	short SETERRDL
 12530                                  	;mov	dx,[8]
 12531 00000E0E 8B160800                	mov	dx,[BATCHSEGMENT.BatSeek]
 12532                                  	;mov	cx,[10]
 12533 00000E12 8B0E0A00                	mov	cx,[BATCHSEGMENT.BatSeek+2]
 12534 00000E16 1F                      	pop	ds
 12535                                  	;mov	[cs:BATHAND],ax
 12536 00000E17 26A3[0BA2]              	mov	[es:BATHAND],ax ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12537 00000E1B 89C3                    	mov	bx,ax
 12538 00000E1D B80042                  	mov	ax,4200h
 12539                                  	;mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
 12540 00000E20 CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 12541                                  			; AL = method: offset from beginning of	file
 12542                                  
 12543                                  	;mov	word [cs:BATBUFPOS],-1 ; 0FFFFh
 12544                                  					; nuke batch buffer position
 12545 00000E22 26C706[DFA9]FFFF        	mov	word [es:BATBUFPOS],-1 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12546                                  BATOPEN_RETN:
 12547 00000E29 C3                      	retn
 12548                                  
 12549                                  SETERRDL:
 12550 00000E2A 89D3                    	mov	bx,dx
 12551                                  	; MSDOS 6.0
 12552                                  	;invoke	get_ext_error_number 	;AN022; get the extended error
 12553                                  	; 14/02/2023
 12554 00000E2C E81314                  	call	get_ext_error_number
 12555 00000E2F 89C2                    	mov	dx,ax		     	;AN022; save extended error in DX
 12556                                  
 12557                                  	; MSDOS 3.3
 12558                                  	;mov	dx,INSERTDSKPTR
 12559                                  	;call	GET_EXT_ERR_NUMBER
 12560                                  
 12561                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12562 00000E31 8A07                    	mov	al,[bx]			; Get drive spec
 12563 00000E33 2C40                    	sub	al,'@'	; sub al,40h	; A = 1
 12564 00000E35 1F                      	pop	ds
 12565 00000E36 F9                      	stc				; SUB mucked over carry
 12566 00000E37 C3                      	retn
 12567                                  
 12568                                  ; =============== S U B	R O U T	I N E =======================================
 12569                                  
 12570                                  ;Free_batch : This routine traverses the linked batch segments freeing all
 12571                                  ;the batch and FOR segments until all of them are freed. It also restores
 12572                                  ;the old state of the EchoFlag.
 12573                                  ;
 12574                                  ;	ENTRY:	ds = RESGROUP
 12575                                  ;
 12576                                  ;	EXIT: 	All batch & FOR segments freed.
 12577                                  ;		EchoFlag restored to old state before batch process.
 12578                                  ;
 12579                                  ;	REGISTERS AFFECTED: bx, cx
 12580                                  
 12581                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12582                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0D7Eh
 12583                                  
 12584                                  free_batch: ;proc near
 12585                                  	;assume	ds:RESGROUP,es:nothing
 12586                                  
 12587 00000E38 06                      	push	es
 12588 00000E39 8B1E[5002]              	mov	bx,[Next_Batch]
 12589 00000E3D 09DB                    	or	bx,bx
 12590 00000E3F 7431                    	jz	short fb_ret
 12591                                  _ClearBatch:
 12592 00000E41 8EC3                    	mov	es,bx			; get batch segment
 12593                                  	;mov	bx,es:BatForPtr		; get old FOR segment
 12594 00000E43 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
 12595                                  	;cmp	bx,0			; is a FOR in progress
 12596                                  	; 27/07/2024
 12597 00000E48 21DB                    	and	bx,bx
 12598 00000E4A 7408                    	jz	short no_bat_for	; no - don't deallocate
 12599 00000E4C 06                      	push	es			;
 12600 00000E4D 8EC3                    	mov	es,bx			; yes - free it up...
 12601 00000E4F B449                    	mov	ah,49h
 12602                                  	;mov	ah,DEALLOC		;
 12603 00000E51 CD21                    	int	21h			;
 12604 00000E53 07                      	pop	es			; restore to batch segment
 12605                                  no_bat_for:
 12606                                  	;mov	cl,[es:1]
 12607 00000E54 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag]
 12608                                  					; get old echo flag
 12609                                  	;mov	bx,[es:3]
 12610 00000E59 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 12611                                  					; get old batch segment
 12612 00000E5E B449                    	mov	ah,49h
 12613                                  	;mov	ah,DEALLOC		; free it up...
 12614 00000E60 CD21                    	int	21h
 12615                                  	; 14/02/2023
 12616                                  	;mov	[Batch],bx		; get ready to deallocate next batch
 12617 00000E62 FF0E[4C02]              	dec	word [Nest]		; is there another batch file?
 12618 00000E66 75D9                    	jnz	short _ClearBatch	; keep going until no batch file
 12619                                  	
 12620 00000E68 880E[3B02]              	mov	[EchoFlag],cl		;restore echo status
 12621 00000E6C C706[E701]0000          	mov	word [Batch],0		;no batch process in progress
 12622                                  fb_ret:
 12623 00000E72 07                      	pop	es
 12624 00000E73 C3                      	ret
 12625                                  
 12626                                  ;free_batch endp
 12627                                  
 12628                                  ;============================================================================
 12629                                  ; TFOR.ASM, MSDOS 6.0, 1991
 12630                                  ;============================================================================
 12631                                  ; 10/10/2018 - Retro DOS v3.0
 12632                                  
 12633                                  ; All batch proccessing has DS set to segment of resident portion
 12634                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
 12635                                  
 12636                                  ; MSDOS 3.3 COMMAND.COM, transient portion/segment offset 0BE9h
 12637                                  
 12638                                  ; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12639                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:0DBFh
 12640                                  
 12641                                  ; ---------------------------------------------------------------------------
 12642                                  
 12643                                  	; 15/02/2023
 12644                                  FORTERM:
 12645                                  	; MSDOS 6.0
 12646 00000E74 0E                      	push	cs			;AN037; Get local segment into
 12647 00000E75 1F                      	pop	ds			;AN037;  DS, ES
 12648 00000E76 0E                      	push	cs			;AN037;
 12649 00000E77 07                      	pop	es			;AN037;
 12650                                  
 12651                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12652 00000E78 E89502                  	call	FOROFF
 12653                                  	;mov	ds,[cs:RESSEG]
 12654 00000E7B 268E1E[159E]            	mov	ds,[es:RESSEG] ; 15/02/2023 - MSDOS 5.0
 12655 00000E80 813E[4302]00FF          	cmp	word [SingleCom],0FF00h
 12656 00000E86 750F                    	jne	short BAT_CRLF
 12657 00000E88 833E[4C02]00            	cmp	word [Nest],0		;See if we have nested batch files
 12658 00000E8D 7508                    	jne	short BAT_CRLF		;Yes - don't exit just yet
 12659 00000E8F C706[4302]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause a terminate
 12660 00000E95 EB12                    	jmp	short NOFORP2
 12661                                  BAT_CRLF:
 12662 00000E97 F606[3B02]01            	test	byte [EchoFlag],1 	; Is echo on?
 12663 00000E9C 740B                    	jz	short NOFORP2		; no - exit
 12664 00000E9E F706[E701]FFFF          	test	word [Batch],-1 ; 0FFFFh
 12665                                  					; print CRLF if in batch
 12666 00000EA4 7403                    	jz	short NOFORP2
 12667 00000EA6 E8781C                  	call	CRLF2
 12668                                  NOFORP2:
 12669 00000EA9 E958F2                  	jmp	TCOMMAND
 12670                                  
 12671                                  ; ---------------------------------------------------------------------------
 12672                                  
 12673                                  ;------
 12674                                  ;   For-loop processing. For loops are of the form:
 12675                                  ;	    for %<loop-variable> in (<list>) do <command>
 12676                                  ; where <command> may contain references of the form %<variable>, which are
 12677                                  ; later substituted with the items in <list>. The for-loop structure is
 12678                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
 12679                                  ; <command> once for each item in <list>. All of the information needed for
 12680                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
 12681                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
 12682                                  ; a complete copy of the original command-line structure as parsed by
 12683                                  ; 'parseline', loop control variables, and a dma buffer for the
 12684                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
 12685                                  ; processing has completed, this chunk of memory is returned to the system.
 12686                                  ;
 12687                                  ;   All of the previously defined variables, in 'datares', used for loop
 12688                                  ; processing may be erased. Only one, (DW) ForPtr, need be allocated.
 12689                                  ;
 12690                                  ;   The error message, 'for_alloc_mes', should be moved into the file
 12691                                  ; containing all of the other error messages.
 12692                                  ;
 12693                                  ;   Referencing the allocated for-loop structure is a little tricky.
 12694                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
 12695                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
 12696                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
 12697                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
 12698                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
 12699                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
 12700                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
 12701                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
 12702                                  ; instead of
 12703                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
 12704                                  ; By using 'f', we pretend that we are actually referencing an allocated
 12705                                  ; structure, and the assembler coughs up the code we want. Notice that it
 12706                                  ; doesn't matter whether we put brackets around the location or not -- the
 12707                                  ; assembler is "smart" enough to know that we want an address instead of the
 12708                                  ; contents of that location.
 12709                                  ;
 12710                                  ;   Finally, there now exists the potential to easily implement nested loops.
 12711                                  ; One method would be to have a link field in each for-structure pointing to
 12712                                  ; its parent.  Variable references that couldn't be resolved in the local
 12713                                  ; frame would cause a search of prior frames. For-structures would still be
 12714                                  ; allocated and released in exactly the same fashion. The only limit on the
 12715                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
 12716                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
 12717                                  ; maintained in the resident data area. This structure would be an array of
 12718                                  ; control-variable names and pointers to for-structure blocks. This would
 12719                                  ; greatly speed up the resolution of non-local variable references. However,
 12720                                  ; since space in the resident is precious, we would have to compromise on a
 12721                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
 12722                                  ; allocation and de-allocation would have to be modified slightly to take this
 12723                                  ; new structure into account.
 12724                                  ;
 12725                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
 12726                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
 12727                                  ; it may be easier to allocate it as part of 'for_segment'.
 12728                                  ;------
 12729                                  		; include fordata.asm
 12730                                  
 12731                                  ; Data structure definitions included by tfor.asm
 12732                                  
 12733                                  struc FOR_INFO
 12734 00000000 <res 444h>                .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
 12735 00000444 ??                        .FOR_COM_START: resb  1		; beginning of <command>
 12736 00000445 ????                      .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
 12737 00000447 ????                      .FOR_MINARG:	  resw  1		; beginning of <list>
 12738 00000449 ????                      .FOR_MAXARG:	  resw  1		; end of <list>
 12739 0000044B <res 80h>                 .FORBUF:	  resw  64		; temporary buffer
 12740 000004CB <res 80h>                 .FORDMA:	  resw  64		; FindFirst/Next buffer
 12741 0000054B ??                        .FOR_VAR:	  resb  1		; loop control variable
 12742                                    .size:
 12743                                  endstruc
 12744                                  					; ARG_UNIT.SIZE = 1348 (544h)
 12745                                  					; ARG_UNIT.SIZE = 1092 ; 27/07/2024
 12746                                  _$FOR_EXIT:
 12747 00000EAC EBC6                    	jmp	short FORTERM		; exceeding maxarg means all done
 12748                                  
 12749                                  ; ---------------------------------------------------------------------------
 12750                                  
 12751                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12752                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 12753                                  	;	     & Retro DOS v4.2 COMMAND.COM (2024 modification)
 12754                                  FORPROC:
 12755 00000EAE A1[4A02]                	mov	ax,[ForPtr]
 12756 00000EB1 8ED8                    	mov	ds,ax
 12757 00000EB3 8EC0                    	mov	es,ax			; operate in for-info area
 12758                                  	;;mov	dx,5CBh	; MSDOS 5.0 & 6.22
 12759                                  	;mov	dx,4CBh ; PCDOS 7.1 ; 27/07/2024
 12760 00000EB5 BACB04                  	mov	dx,FOR_INFO.FORDMA	; 1348+1+2+2+2+128 = 1483 = 5CBh
 12761                                  		; PCDOS 7.1 COMMAND.COM ; 1092+1+2+2+2+128 = 1227 = 4CBh
 12762 00000EB8 B8001A                  	mov	ax,1A00h
 12763                                  	;mov	ax,Set_DMA*256 ; 1A00h
 12764 00000EBB CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 12765                                  			; DS:DX	-> disk	transfer buffer
 12766                                  FOR_BEGIN:
 12767                                  	;;cmp	word [545h],0
 12768                                  	;cmp	word [445h] ; 27/07/2024
 12769 00000EBD 833E450400              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12770 00000EC2 7404                    	jz	short FOR_BEGIN1
 12771                                  					; non-zero for_expand equals FALSE
 12772                                  	;;inc	word [547h]
 12773                                  	;inc	word [447h] ; 27/07/2024
 12774 00000EC4 FF064704                	inc	word [FOR_INFO.FOR_MINARG]
 12775                                  FOR_BEGIN1:
 12776                                  	;mov	bx,[447h] ; 27/07/2024
 12777 00000EC8 8B1E4704                	mov	bx,[FOR_INFO.FOR_MINARG] ; current item in <list> to examine
 12778                                  	;cmp	bx,[449h] ; 27/07/2024
 12779 00000ECC 3B1E4904                	cmp	bx,[FOR_INFO.FOR_MAXARG]
 12780 00000ED0 7FDA                     	jg	short _$FOR_EXIT	; exceeding maxarg means all done
 12781                                  	;mov	ax,0
 12782 00000ED2 B80000                  	mov	ax,FOR_INFO.FOR_ARGS ; 0 
 12783 00000ED5 E8C627                  	call	argv_calc		; compute argv[x] address
 12784                                  	;mov	cx,[bx+3]
 12785 00000ED8 8B4F03                  	mov	cx,[bx+ARGV_ELE.argstartel]
 12786 00000EDB 8B17                    	mov	dx,[bx]
 12787                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 12788                                  	;test	byte [bx+2],4		; Is there a path separator in this arg?
 12789 00000EDD F6470204                	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 12790 00000EE1 7512                    	jnz	short FORSUB		; Yes, argstartel should be correct
 12791 00000EE3 8B37                    	mov	si,[bx]
 12792                                  	;mov	si,[bx+ARGV_ELE.argpointer]
 12793                                  
 12794                                  	;mov	al,[cs:LPAREN]
 12795                                  	; 15/02/2023
 12796                                  	; MSDOS 6.0 (& 5.0) COMMAND.com
 12797                                  	;mov	al,'('	; mov al,lparen
 12798                                  	;cmp	[si-1],	al		; If the current token is the first
 12799                                  	; 27/07/2024
 12800 00000EE5 807CFF28                	cmp	byte [si-1],'('
 12801 00000EE9 750A                    	jne	short FORSUB		;  one in the list and originally had
 12802 00000EEB 41                      	inc	cx			;  the opening paren as its first char,
 12803                                  					;  the argstartel ptr needs to be
 12804                                  					;  advanced passed it before the prefix
 12805                                  					;  length is computed.
 12806                                  	;mov	al,':'
 12807                                  	;cmp	[si+1],	al		; If the token begins with "(d:",
 12808                                  	; 27/07/2024
 12809 00000EEC 807C013A                	cmp	byte [si+1],':'
 12810 00000EF0 7503                    	jne	short FORSUB		;  argstartel has to be moved over the
 12811 00000EF2 83C102                  	add	cx,2			;  rest of the prefix as well.
 12812                                  FORSUB:
 12813 00000EF5 29D1                    	sub	cx,dx			; compute length of pathname prefix
 12814                                  	;;cmp	word [545h],0
 12815                                  	;cmp	word [445h],0 ; 27/07/2024
 12816 00000EF7 833E450400              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12817                                  					; are we still expanding a name?
 12818 00000EFC 7416                    	jz	short FOR_FIND_NEXT
 12819                                  					; if so, get next matching filename
 12820                                  	;test	byte [bx+2],2
 12821 00000EFE F6470202                	test	byte [bx+ARGV_ELE.argflags],2 ; wildcard
 12822 00000F02 7505                    	jnz	short FOR_FIND_FIRST
 12823                                  					; should we expand THIS (new) arg?
 12824                                  	;mov	cx,[bx+5]
 12825                                  					; else, just copy all of it directly
 12826 00000F04 8B4F05                  	mov	cx,[bx+ARGV_ELE.arglen]
 12827 00000F07 EB1D                    	jmp	short FOR_SMOOSH
 12828                                  
 12829                                  	;nop
 12830                                  	; 15/02/2023
 12831                                  FOR_FIND_FIRST:
 12832 00000F09 51                      	push	cx
 12833 00000F0A 31C9                    	xor	cx,cx
 12834 00000F0C B8004E                  	mov	ax,4E00h
 12835                                  	;mov	ax,Find_First*256 ; 4E00h
 12836 00000F0F CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 12837                                  			; CX = search attributes
 12838                                  			; DS:DX	-> ASCIZ filespec
 12839                                  			; (drive,path, and wildcards allowed)
 12840 00000F11 59                      	pop	cx
 12841 00000F12 EB05                    	jmp	short FOR_RESULT
 12842                                  
 12843                                  	;nop
 12844                                  FOR_FIND_NEXT:
 12845 00000F14 B8004F                  	mov	ax,4F00h
 12846                                  	;mov	ax,Find_Next*256 ;4F00h
 12847 00000F17 CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 12848                                  			; [DTA]	= data block from
 12849                                  			; last AH = 4Eh/4Fh call
 12850                                  FOR_RESULT:
 12851 00000F19 B8FFFF                  	mov	ax,-1 ; 0FFFFh		; assume worst case
 12852 00000F1C 7201                    	jc	short FOR_CHECK
 12853                                  	; 15/02/2023
 12854 00000F1E 40                      	inc	ax ; ax = 0
 12855                                  	;mov	ax,0			; Find* returns 0 for SUCCESS
 12856                                  FOR_CHECK:				; record success of findfirst/next
 12857                                  	;;mov	[545h],ax
 12858                                  	;mov	[445h],ax ; 27/07/2024
 12859 00000F1F A34504                  	mov	[FOR_INFO.FOR_EXPAND],ax
 12860 00000F22 09C0                    	or	ax,ax			; anything out there?
 12861 00000F24 7597                    	jnz	short FOR_BEGIN		; if not, try next arg
 12862                                  FOR_SMOOSH:
 12863                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 12864 00000F26 8B37                    	mov	si,[bx] 		; copy argv[arg][0,CX] into destbuf
 12865                                  	;;mov	di,54Bh	; MSDOS 5.0 & 6.22 COMMAND.COM
 12866                                  	;mov	di,44Bh ; 27/07/2024 ; PCDOS 7.1 COMMAND.COM
 12867 00000F28 BF4B04                  	mov	di,FOR_INFO.FORBUF	; some days this will be the entire
 12868 00000F2B F3A4                    	rep	movsb			; arg, some days just the path prefix
 12869                                  					
 12870 00000F2D 833E450400              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12871                                  					; if we're not expanding, we can
 12872 00000F32 7509                    	jnz	short FOR_MAKE_COM 	; skip the following
 12873                                  	; 15/02/2023
 12874                                  	;;mov	si,05E9h ; MSDOS 3.3 & 5.0 & 6.22 COMMAND.COM ; 27/07/2024
 12875                                  	; 27/07/2024
 12876                                  	;mov	si,04E9h ; PCDOS 7.1 COMMAND.COM
 12877 00000F34 BEE904                  	mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
 12878                                  FOR_MORE:
 12879                                  	;cmp	byte [si],0		; tack on matching filename
 12880                                  	;jz	short FOR_MAKE_COM
 12881                                  	;movsb
 12882                                  	;jnz	short FOR_MORE
 12883                                  	; 25/04/2023
 12884 00000F37 AC                      	lodsb
 12885 00000F38 AA                      	stosb
 12886 00000F39 08C0                    	or	al,al
 12887 00000F3B 75FA                    	jnz	short FOR_MORE
 12888                                  FOR_MAKE_COM:
 12889                                  	; 25/04/2023
 12890                                  	;xor	al,al			; tack a null byte onto the end
 12891                                  	;stosb				; of the substitute string
 12892 00000F3D 31C9                    	xor	cx,cx			; character count for command line
 12893 00000F3F F7D1                    	not	cx			; negate it -- take advantage of loopnz
 12894 00000F41 31DB                    	xor	bx,bx			; argpointer
 12895 00000F43 BF[769C]                	mov	di,COMBUF+2
 12896                                  	; 15/02/2023
 12897                                  	;;mov	bl,[544h] ; MSDOS 5.0-6.22 ; 27/07/2024
 12898                                  	; 27/07/2024
 12899                                  	;mov	bl,[444h] ; PCDOS 7.1 COMMAND.COM 
 12900 00000F46 8A1E4404                	mov	bl,[FOR_INFO.FOR_COM_START] ; argindex
 12901                                  	;;mov	dh,[64Bh]
 12902                                  	;mov	dh,[54Bh] ; 27/07/2024 ; PCDOS 7.1 COMMAND.COM
 12903 00000F4A 8A364B05                	mov	dh,[FOR_INFO.FOR_VAR]
 12904                                  					; %<for-var> is replaced by [forbuf]
 12905 00000F4E 0E                      	push	cs			; time to form the <command> string
 12906 00000F4F 07                      	pop	es
 12907                                  	;assume ES:trangroup
 12908                                  	;mov	ax,FOR_INFO.FOR_ARGS
 12909 00000F50 B80000                  	mov	ax,0			; translate offset to pointer
 12910 00000F53 E84827                  	call	argv_calc
 12911                                  	;mov	si,[bx+9]
 12912 00000F56 8B7709                  	mov	si,[bx+ARGV_ELE.arg_ocomptr]
 12913                                  					; mov ptr passed beginning space
 12914 00000F59 46                      	inc	si
 12915                                  FOR_MAKE_LOOP:
 12916 00000F5A 8A04                    	mov	al,[si]			; the <command> arg, byte by byte
 12917 00000F5C 46                      	inc	si
 12918 00000F5D 3C25                    	cmp	al,'%'			; looking for %<control-variable>
 12919 00000F5F 7514                    	jne	short FOR_STOSB 	; no % ... add byte to string
 12920 00000F61 3834                    	cmp	[si],dh			; got the right <variable>?
 12921 00000F63 7510                    	jnz	short FOR_STOSB		; got a %, but wrong <variable>
 12922 00000F65 46                      	inc	si			; skip over <for-variable>
 12923                                  
 12924 00000F66 56                      	push	si
 12925                                  	; 15/02/2023
 12926                                  	;;mov	si,54Bh	; MSDOS 5.0-6.22 ; 27/07/2024
 12927                                  	; 27/07/2024
 12928                                  	;mov	si,44Bh ; PCDOS 7.1 COMMAND.COM
 12929 00000F67 BE4B04                  	mov	si,FOR_INFO.FORBUF
 12930                                  					; substitute the <item> for <variable>
 12931                                  					; to make a final <command> to execute
 12932                                  SLOOP:					
 12933 00000F6A AC                      	lodsb				; grab all those <item> bytes, and
 12934 00000F6B AA                      	stosb				; add 'em to the <command> string,
 12935 00000F6C 08C0                    	or	al,al			; until we run into a null
 12936 00000F6E E0FA                    	loopne	SLOOP
 12937 00000F70 4F                      	dec	di			; adjust length and <command> pointer
 12938 00000F71 41                      	inc	cx			; so we can overwrite the null
 12939 00000F72 5E                      	pop	si
 12940 00000F73 EBE5                    	jmp	short FOR_MAKE_LOOP
 12941                                  					; got back for more <command> bytes
 12942                                  FOR_STOSB:
 12943 00000F75 AA                      	stosb				; take a byte from the <command> arg
 12944 00000F76 49                      	dec	cx			; and put it into the <command> to be
 12945                                  					; executed (and note length, too)
 12946 00000F77 3C0D                    	cmp	al,0Dh
 12947 00000F79 75DF                    	jne	short FOR_MAKE_LOOP	; If not done, loop.
 12948                                  FOR_MADE_COM:
 12949 00000F7B F6D1                    	not	cl
 12950                                  	;mov	[cs:COMBUF+1],cl
 12951                                  	;mov	ds,[cs:RESSEG]
 12952                                  	; 15/02/2023 - Retro DOS v4.0 COMMAND.COM
 12953                                  	; MSDOS 5.0 COMMAND.COM
 12954 00000F7D 26880E[759C]            	mov	[es:COMBUF+1],cl
 12955 00000F82 268E1E[159E]            	mov	ds,[es:RESSEG]
 12956                                  	;assume DS:resgroup
 12957 00000F87 F606[3B02]01            	test	byte [EchoFlag],1 	; shall we echo this <command>, dearie?
 12958 00000F8C 742F                    	jz	short NOECHO3
 12959                                  	;cmp	byte [NullFlag],nullcommand
 12960 00000F8E 803E[5202]01            	cmp	byte [NullFlag],1 	;G was there a command last time?
 12961 00000F93 7403                    	jz	short NO_CRLF_PR  	;G no - don't print crlf
 12962                                  
 12963 00000F95 E8891B                  	call	CRLF2		  	;G Print out prompt
 12964                                  NO_CRLF_PR:
 12965 00000F98 C606[5202]00            	mov	byte [NullFlag],0 	;G reset no command flag
 12966 00000F9D 0E                      	push	cs
 12967 00000F9E 1F                      	pop	ds
 12968 00000F9F 57                      	push	di
 12969 00000FA0 E84013                  	call	PRINT_PROMPT	  	;G Prompt the user
 12970 00000FA3 5F                      	pop	di
 12971                                  
 12972 00000FA4 26C645FF00              	mov	byte [es:di-1],0  	; yeah, PRINT it out...	
 12973 00000FA9 C706[B7A0][769C]        	mov	word [string_ptr_2],COMBUF+2
 12974                                  	; 17/04/2023
 12975 00000FAF BA[BA93]                	mov	dx,string_buf_ptr
 12976 00000FB2 E87845                  	call	std_printf
 12977 00000FB5 26C645FF0D              	mov	byte [es:di-1],0Dh
 12978 00000FBA E933F3                  	jmp	DOCOM		  	; run silent, run deep...
 12979                                  NOECHO3:
 12980 00000FBD C606[5202]00            	mov	byte [NullFlag],0
 12981 00000FC2 0E                      	push	cs
 12982 00000FC3 1F                      	pop	ds
 12983                                  	;jmp	DOCOM1
 12984                                  	; 07/06/2023
 12985                                  	; Retro DOS v4.2 COMMAND.COM
 12986 00000FC4 E92CF3                  	jmp	DOCOM0 ; MSDOS 6.22 COMMAND.COM
 12987                                  
 12988                                  FORNESTERRJ:				; no multi-loop processing... yet!
 12989 00000FC7 E84601                  	call	FOROFF
 12990 00000FCA E92901                  	jmp	FORNESTERR
 12991                                  
 12992                                  ; ---------------------------------------------------------------------------
 12993                                  
 12994                                  FORERRORJ:
 12995 00000FCD E9DDFB                  	jmp	FORERROR
 12996                                  
 12997                                  ; ---------------------------------------------------------------------------
 12998                                  
 12999                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F24h
 13000                                  
 13001                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 13002                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0FFEh
 13003                                  
 13004                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 13005                                  	; PCDOS 7.1 COMMAND.COM - TRANGROUP:1040h
 13006                                  _$FOR:
 13007 00000FD0 8E06[159E]              	mov	es,[RESSEG]
 13008 00000FD4 26803E[4902]00          	cmp	byte [es:ForFlag],0 ; is another one already running?
 13009 00000FDA 75EB                    	jnz	short FORNESTERRJ   ; if flag is set.... boom!
 13010                                  
 13011                                  ; Turn off any pipes in progress.
 13012                                  
 13013 00000FDC 26803E[B602]00          	cmp	byte [es:PipeFiles],0 ; Only turn off if present.
 13014 00000FE2 7403                    	jz	short NO_PIPE
 13015 00000FE4 E85622                  	call	PIPEDEL
 13016                                  NO_PIPE:
 13017 00000FE7 31D2                    	xor	dx,dx			; counter (0 <= DX < argvcnt)
 13018 00000FE9 E8F400                  	call	NEXTARG			; move to next argv[n]
 13019 00000FEC 72DF                    	jc	short FORERRORJ		; no more args -- bad forloop
 13020 00000FEE 3C25                    	cmp	al,'%'			; next arg MUST start with '%'...
 13021 00000FF0 75DB                    	jne	short FORERRORJ
 13022 00000FF2 89C5                    	mov	bp,ax			; save forloop variable
 13023 00000FF4 AC                      	lodsb
 13024 00000FF5 08C0                    	or	al,al			; and MUST end immediately...
 13025 00000FF7 75D4                    	jnz	short FORERRORJ
 13026 00000FF9 E8E400                  	call	NEXTARG			; let's make sure the next arg is 'in'
 13027 00000FFC 72CF                    	jb	short FORERRORJ
 13028                                  	;and	ax,0DFDFh
 13029 00000FFE 25DFDF                  	and	ax,~2020h		; uppercase the letters
 13030                                  	; 15/02/2023
 13031                                  	;cmp	ax,4E49h  	; MSDOS 5.0
 13032                                  	;cmp	ax,[IN_WORD] 	; MSDOS 3.3
 13033                                  	;cmp	ax,in_word	; MSDOS 5.0
 13034 00001001 3D494E                  	cmp	ax,'IN'
 13035 00001004 75C7                    	jnz	short FORERRORJ
 13036 00001006 AC                      	lodsb
 13037                                  
 13038                                  	; 15/02/2023
 13039                                  	; MSDOS 3.3
 13040                                  	;or	al,al			; it, too, must end right away
 13041                                  	;jz	short CHECKLPAREN
 13042                                  	;cmp	al,[LPAREN]
 13043                                  	;jnz	short FORERRORJ
 13044                                  	;;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
 13045                                  	;add	word [bx],2
 13046                                  	;;add	word [bx+9],2
 13047                                  	;add	word [bx+ARGV_ELE.arg_ocomptr],2
 13048                                  	;;sub	word [bx+5],2
 13049                                  	;sub	word [bx+ARGV_ELE.arglen],2
 13050                                  	;mov	ax,[si-1]
 13051                                  	;jmp	short LPCHECK
 13052                                  
 13053                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13054                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Bh
 13055                                  
 13056                                  	; MSDOS 6.0
 13057                                  ; Compaq bug fix -- exit from this loop on error
 13058                                  
 13059 00001007 08C0                    	or	al,al
 13060 00001009 75C2                    	jne	short FORERRORJ		; jump on error
 13061                                  
 13062                                  ;	je	short CHECKLPAREN
 13063                                  ;
 13064                                  ; Not null. Perhaps there are no spaces between this and the (:
 13065                                  ;   FOR %i in(foo bar...
 13066                                  ; Check for the Lparen here
 13067                                  ;
 13068                                  ;;	cmp	al,lparen
 13069                                  ;;	jnz	short FORERRORJ
 13070                                  ;
 13071                                  ; The token was in(... We strip off the "in" part to simulate a separator
 13072                                  ; being there in the first place.
 13073                                  ;
 13074                                  ;;	add	word [bx+ARGV_ELE.argpointer],2 ; advance source pointer
 13075                                  ;;	add	word [bx+ARGV_ELE.arg_ocomptr],2
 13076                                  ;;						; advance original string
 13077                                  ;;	sub	word [bx+ARGV_ELE.arglen],2 	; decrement the appropriate length
 13078                                  ;
 13079                                  ; SI now points past the in(.  Simulate a nextarg call that results in the
 13080                                  ; current value.
 13081                                  ;
 13082                                  ;;	mov	ax,[si-1]		; get lparen and next char
 13083                                  ;;	jmp	short LPCHECK
 13084                                  ;
 13085                                  ; end of Compaq bug fix
 13086                                  
 13087                                  ; ---------------------------------------------------------------------------
 13088                                  
 13089                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13090                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Fh
 13091                                  
 13092                                  	; MSDOS 3.3 (& MSDOS 6.0)
 13093                                  CHECKLPAREN:
 13094 0000100B E8D200                  	call	NEXTARG			; lparen delimits beginning of <list>
 13095 0000100E 72BD                    	jc	short FORERRORJ
 13096                                  LPCHECK:
 13097                                  	; 15/02/2023
 13098                                  	; MSDOS 5.0 (% MSDOS 6.0)
 13099                                  	;;cmp	al,[LPAREN]
 13100                                  	;cmp	al,lparen
 13101 00001010 3C28                    	cmp	al,'('
 13102 00001012 75B9                    	jne	short FORERRORJ
 13103 00001014 80FC00                  	cmp	ah,0
 13104 00001017 7410                    	je	short FOR_PAREN_TOKEN
 13105                                  	;;cmp	ah,[RPAREN]		; special case:  null list
 13106                                  	;cmp	ah,rparen
 13107 00001019 80FC29                  	cmp	ah,')'
 13108 0000101C 7503                    	jne	short FOR_LIST_NOT_EMPTY
 13109 0000101E E953FE                  	jmp	FORTERM
 13110                                  FOR_LIST_NOT_EMPTY:
 13111                                  	;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
 13112 00001021 FF07                    	inc	word [bx]		; Advance ptr past "("
 13113                                  	;dec	word [bx+5]		; Adjust the rest of this argv entry
 13114 00001023 FF4F05                  	dec	word [bx+ARGV_ELE.arglen] ; to agree.
 13115 00001026 46                      	inc	si			; Inc si so check for ")" works
 13116 00001027 EB0D                    	jmp	short FOR_LIST
 13117                                  
 13118                                  	;nop
 13119                                  FOR_PAREN_TOKEN:
 13120 00001029 E8B400                  	call	NEXTARG			; what have we in our <list>?
 13121 0000102C 729F                    	jc	short FORERRORJ
 13122                                  	; 15/02/2023
 13123                                  	;;;cmp	ax,[RPAREN+1]
 13124                                  	;;cmp	ax,[NULLRPAREN]		; special case:  null list
 13125                                  	;cmp	ax,nullrparen
 13126 0000102E 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 13127 00001031 7503                    	jne	short FOR_LIST
 13128 00001033 E93EFE                  	jmp	FORTERM
 13129                                  
 13130                                  ;FORERORJJ:
 13131                                  	;jmp	FORERROR
 13132                                  
 13133                                  FOR_LIST:				; skip over rest of <list>
 13134 00001036 89D1                    	mov	cx,dx			; first arg of <list>
 13135                                  
 13136                                  SKIP_LIST:
 13137                                  	;add	si,[bx+5]
 13138 00001038 037705                  	add	si,[bx+ARGV_ELE.arglen]
 13139 0000103B 83EE03                  	sub	si,3			; si = ptr to last char of token
 13140                                  	; 15/02/2023
 13141                                  	;;mov	al,[RPAREN]
 13142                                  	;mov	al,rparen
 13143 0000103E B029                    	mov	al,')'
 13144 00001040 3804                    	cmp	[si],al			; Is this the last element in <list>
 13145 00001042 7408                    	je	short FOR_END_LIST 	; Yes, exit loop.
 13146 00001044 E89900                  	call	NEXTARG			; No, get next arg <list>
 13147                                  	;jc	short FORERORJJ		; If no more and no rparen, error.
 13148                                  	;jmp	short SKIP_LIST
 13149                                  	; 15/02/2023
 13150 00001047 73EF                    	jnc	short SKIP_LIST
 13151                                  
 13152                                  	; 15/02/2023
 13153                                  FORERORJJ:
 13154 00001049 E961FB                  	jmp	FORERROR
 13155                                  
 13156                                  FOR_END_LIST:
 13157 0000104C 89D7                    	mov	di,dx			; record position of last arg in <list>
 13158 0000104E C60400                  	mov	byte [si],0		; Zap the rparen
 13159                                  	; 15/02/2023
 13160                                  	;;;cmp	ax,[RPAREN+1]
 13161                                  	;;cmp	ax,[NULLRPAREN] 	; Was this token only a rparen
 13162                                  	;cmp	ax,nullparen
 13163 00001051 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 13164 00001054 7401                    	je	short FOR_DO		; Yes, continue
 13165 00001056 47                      	inc	di			; No, inc position of last arg
 13166                                  FOR_DO:
 13167 00001057 E88600                  	call	NEXTARG			; now we had BETTER find a 'do'...
 13168 0000105A 72ED                    	jc	short FORERORJJ
 13169                                  	;and	ax,0DFDFh
 13170 0000105C 25DFDF                  	and	ax,~2020h		; uppercase the letters
 13171                                  	; 15/02/2023
 13172                                  	;;cmp	ax,[DO_WORD]
 13173                                  	;cmp	ax,do_word ; 4F44h
 13174 0000105F 3D444F                  	cmp	ax,'DO'	 ; 4F44h
 13175 00001062 75E5                    	jne	short FORERORJJ
 13176 00001064 AC                      	lodsb
 13177 00001065 08C0                    	or	al,al			; and it had BETTER be ONLY a 'do'...
 13178 00001067 75E0                    	jnz	short FORERORJJ
 13179                                  		
 13180 00001069 E87400                  	call	NEXTARG			; on to the beginning of <command>
 13181 0000106C 72DB                    	jc	short FORERORJJ		; null <command> not legal
 13182                                  
 13183 0000106E 50                      	push	ax
 13184 0000106F 53                      	push	bx
 13185 00001070 51                      	push	cx
 13186 00001071 52                      	push	dx			; preserve registers against disaster
 13187 00001072 57                      	push	di
 13188 00001073 56                      	push	si
 13189 00001074 55                      	push	bp
 13190 00001075 E85FF7                  	call	FREE_TPA		; need to make free memory, first
 13191 00001078 E89500                  	call	FOROFF
 13192                                  	;mov	bx,264
 13193 0000107B BB0801                  	mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
 13194 0000107E E84229                  	call	SAVE_ARGS		; extra bytes needed for for-info
 13195 00001081 9C                      	pushf
 13196 00001082 26A3[4A02]              	mov	[es:ForPtr],ax
 13197 00001086 E85EF7                  	call	ALLOC_TPA		; ALLOC_TPA clobbers registers...
 13198 00001089 9D                      	popf
 13199 0000108A 5D                      	pop	bp
 13200 0000108B 5E                      	pop	si
 13201 0000108C 5F                      	pop	di
 13202 0000108D 5A                      	pop	dx
 13203 0000108E 59                      	pop	cx
 13204 0000108F 5B                      	pop	bx
 13205 00001090 58                      	pop	ax
 13206 00001091 723C                    	jc	short FOR_ALLOC_ERR
 13207                                  
 13208 00001093 06                      	push	es			; save resgroup seg...
 13209 00001094 26FF36[4A02]            	push	word [es:ForPtr]
 13210 00001099 07                      	pop	es
 13211                                  	;assume es:for_segment
 13212 0000109A 49                      	dec	cx			; forproc wants min pointing before
 13213 0000109B 4F                      	dec	di			; first arg, max right at last one
 13214                                  	; 15/02/2023
 13215                                  	;;mov	[547h],cx
 13216                                  	; 27/07/2024
 13217                                  	;mov	[447h],cx ; PCDOS 7.1 COMMAND.COM
 13218 0000109C 26890E4704              	mov	[es:FOR_INFO.FOR_MINARG],cx
 13219                                  	;;mov	[549h],di
 13220                                  	;mov	[449h],di ; PCDOS 7.1 COMMAND.COM ; 27/07/2024
 13221 000010A1 26893E4904              	mov	[es:FOR_INFO.FOR_MAXARG],di
 13222                                  	;;mov	[544h],dl
 13223                                  	;mov	[444h],dl ; PCDOS 7.1 COMMAND.COM ; 27/07/2024
 13224 000010A6 2688164404              	mov	[es:FOR_INFO.FOR_COM_START],dl
 13225                                  	;;mov	word [545h],0FFFFh ; -1
 13226                                  	;mov	[445h],0FFFFh ; PCDOS 7.1 COMMAND.COM ; 27/07/2024
 13227 000010AB 26C7064504FFFF          	mov	word [es:FOR_INFO.FOR_EXPAND],-1
 13228                                  					; non-zero means FALSE
 13229 000010B2 89E8                    	mov	ax,bp
 13230                                  	;;mov	[64Bh],ah
 13231                                  	;mov	[54Bh],ah ; 27/07/2024 ; PCDOS 7.1 COMMAND.COM
 13232 000010B4 2688264B05              	mov	[es:FOR_INFO.FOR_VAR],ah
 13233 000010B9 07                      	pop	es
 13234                                  	;assume es:resgroup
 13235 000010BA 26FE06[4902]            	inc	byte [es:ForFlag]
 13236 000010BF 26833E[4302]FF          	cmp	word [es:SingleCom],-1
 13237 000010C5 7507                    	jne	short FOR_RET
 13238 000010C7 26C706[4302]00FF        	mov	word [es:SingleCom],0FF00h
 13239                                  FOR_RET:
 13240 000010CE C3                      	retn
 13241                                  
 13242                                  FOR_ALLOC_ERR:
 13243                                  	; 15/02/2023
 13244                                  	; MSDOS 3.3
 13245                                  	;mov	dx,INSFMEMMESPTR
 13246                                  	;jmp	CERROR
 13247                                  
 13248                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13249                                  	; MSDOS 6.0
 13250                                  	;mov	byte [msg_disp_class],1
 13251 000010CF C606[F191]01            	mov	byte [msg_disp_class],ext_msg_class
 13252                                  					;AN000; set up extended error msg class
 13253                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 13254 000010D4 BA[F391]                	mov	dx,extend_buf_ptr
 13255                                  					;AC000; get extended message pointer
 13256                                  	;mov	word [extend_buf_ptr],8
 13257 000010D7 C706[F391]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 13258                                  					;AN000; get message number in control block
 13259 000010DD E9C21D                  	jmp	cerror
 13260                                  
 13261                                  
 13262                                  ; =============== S U B	R O U T	I N E =======================================
 13263                                  
 13264                                  NEXTARG:
 13265 000010E0 42                      	inc	dx			; next argv[n]
 13266                                  	;cmp	dx,[ARG_ARGVCNT]
 13267 000010E1 3B16[27A5]              	cmp	dx,[ARG+ARG_UNIT.argvcnt]
 13268                                  					; make sure we don't run off end
 13269 000010E5 7D0D                    	jge	short NEXTARG_ERR 	;  of argv[]...	
 13270 000010E7 89D3                    	mov	bx,dx
 13271                                  	;mov	ax,ARG_ARGV
 13272                                  	;mov	ax,ARG+ARG_UNIT.argv
 13273 000010E9 B8[67A2]                	mov	ax,ARG
 13274 000010EC E8AF25                  	call	argv_calc		; convert array index to pointer
 13275 000010EF 8B37                    	mov	si,[bx]			; load pointer to argstring
 13276                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 13277 000010F1 AD                      	lodsw				; and load first two chars
 13278 000010F2 F8                      	clc
 13279 000010F3 C3                      	retn
 13280                                  NEXTARG_ERR:
 13281 000010F4 F9                      	stc
 13282 000010F5 C3                      	retn
 13283                                  
 13284                                  ; ---------------------------------------------------------------------------
 13285                                  
 13286                                  FORNESTERR:
 13287 000010F6 1E                      	push	ds
 13288 000010F7 8E1E[159E]              	mov	ds,[RESSEG]
 13289                                  	;ASSUME DS:RESGROUP
 13290 000010FB BA[5193]                	mov	dx,FORNESTMES_PTR
 13291 000010FE 813E[4302]00FF          	cmp	word [SingleCom],0FF00h
 13292 00001104 7506                    	jne	short NOFORP3
 13293 00001106 C706[4302]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause termination
 13294                                  NOFORP3:
 13295 0000110C 1F                      	pop	ds
 13296 0000110D E9921D                  	jmp	cerror
 13297                                  
 13298                                  ; =============== S U B	R O U T	I N E =======================================
 13299                                  
 13300                                  ; General routine called to free the for segment. We also clear the forflag
 13301                                  ; too. Change no registers.
 13302                                  
 13303                                  FOROFF:
 13304 00001110 50                      	push	ax
 13305 00001111 06                      	push	es
 13306 00001112 2E8E06[159E]            	mov	es,[cs:RESSEG]
 13307 00001117 26A1[4A02]              	mov	ax,[es:ForPtr]
 13308 0000111B 09C0                    	or	ax,ax
 13309 0000111D 7408                    	jz	short FREEDONE
 13310 0000111F 06                      	push	es
 13311 00001120 8EC0                    	mov	es,ax
 13312                                  	; 15/02/2023
 13313 00001122 B449                    	mov	ah,49h
 13314                                  	;mov	ah,DEALLOC ; 49h
 13315 00001124 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 13316                                  			; ES = segment address of area to be freed
 13317 00001126 07                      	pop	es
 13318                                  FREEDONE:
 13319 00001127 26C706[4A02]0000        	mov	word [es:ForPtr],0
 13320 0000112E 26C606[4902]00          	mov	byte [es:ForFlag],0
 13321 00001134 07                      	pop	es
 13322 00001135 58                      	pop	ax
 13323 00001136 C3                      	retn
 13324                                  
 13325                                  ;============================================================================
 13326                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
 13327                                  ;============================================================================
 13328                                  ; 09/10/2018 - Retro DOS v3.0
 13329                                  
 13330                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
 13331                                  
 13332                                  ; ---------------------------------------------------------------------------
 13333                                  
 13334                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13335                                  
 13336                                  %if 0
 13337                                  
 13338                                  ; The DIR command displays the contents of a directory.
 13339                                  ;
 13340                                  ; ****************************************************************
 13341                                  ; *
 13342                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
 13343                                  ; *
 13344                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
 13345                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
 13346                                  ; *		 If an error occurs issue and error message and
 13347                                  ; *		 transfer control to CERROR.
 13348                                  ; *
 13349                                  ; * INPUT:	 command line at offset 81H
 13350                                  ; *
 13351                                  ; * OUTPUT:	 none
 13352                                  ; *
 13353                                  ; ****************************************************************
 13354                                  
 13355                                  CATALOG:
 13356                                  	; MSDOS 3.3
 13357                                  
 13358                                  	;mov	ax,ARG_ARGV
 13359                                  	;mov	ax,ARG+ARG_UNIT.argv
 13360                                  	mov	ax,ARG
 13361                                  	mov	dx,0FFFFh
 13362                                  	xor	cx,cx
 13363                                  	xor	si,si
 13364                                  DIR1:
 13365                                  	;cmp	cx,[ARG_ARGVCNT]
 13366                                  	cmp	cx,[ARG+ARG_UNIT.argvcnt]
 13367                                  	jnb	short DIR6 ; No more arguments
 13368                                  	mov	bx,cx
 13369                                  	call	ARGV_CALC
 13370                                  	;or	si,[bx+7]
 13371                                  	or	si,[bx+ARGV_ELE.argsw_word]
 13372                                  	test	si,7FFCh  ; test si,~8003
 13373                                  	jnz	short DIR2  ; /A,/B,/V switches (are invalid)
 13374                                  	;test	byte [bx+2],1
 13375                                  	test	byte [bx+ARGV_ELE.argflags],sw_flag  ; 1
 13376                                  	jz	short DIR3
 13377                                  	jmp	short DIR5
 13378                                  DIR2:
 13379                                  	mov	dx,BADPARMPTR
 13380                                  	jmp	CERROR
 13381                                  DIR3:
 13382                                  	or	cx,cx
 13383                                  	jnz	short DIR4	
 13384                                  	;cmp	word [bx+5],3
 13385                                  	cmp	word [bx+ARGV_ELE.arglen],3
 13386                                  	jz	short DIR5
 13387                                  	;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
 13388                                  	add	word [bx],3
 13389                                  	;add	word [bx+9],3
 13390                                  	add	word [bx+ARGV_ELE.arg_ocomptr],3
 13391                                  	;add	word [bx+3],3
 13392                                  	add	word [bx+ARGV_ELE.argstartel],3
 13393                                  	;sub	word [bx+5],3
 13394                                  	sub	word [bx+ARGV_ELE.arglen],3
 13395                                  DIR4:
 13396                                  	cmp	dx,0FFFFh
 13397                                  	jnz	short DIR2
 13398                                  	mov	dx,bx
 13399                                  DIR5:
 13400                                  	inc	cx
 13401                                  	jmp	short DIR1
 13402                                  DIR6:
 13403                                  	mov	[COMSW],si
 13404                                  	push	dx
 13405                                  	xor	al,al
 13406                                  	cmp	dx,0FFFFh
 13407                                  	jz	short DIR7
 13408                                  	mov	bx,dx
 13409                                  	;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
 13410                                  	mov	di,[bx]
 13411                                  	cmp	byte [di+1],':'
 13412                                  	jnz	short DIR7
 13413                                  	mov	al,[di]
 13414                                  	or	al,20h		; Lowercase drive name	
 13415                                  	sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
 13416                                  DIR7:
 13417                                  	;mov	[5CH],al
 13418                                  	mov	[FCB],al
 13419                                  	call	OKVOLARG
 13420                                  	mov	al,'?'		; *.* is default file spec.
 13421                                  	;mov	di,5Dh
 13422                                  	mov	di,FCB+1
 13423                                  	mov	cx,11
 13424                                  	rep stosb
 13425                                  
 13426                                  ; Begin by processing any switches that may have been specified.
 13427                                  ; BITS will contain any information about switches that was
 13428                                  ; found when the command line was parsed.
 13429                                  
 13430                                  	mov	ax,[COMSW]	; Get switches from command
 13431                                  	mov	[_BITS],ax	; initialize switches
 13432                                  	mov	word [COMSW],0	; initialize flags
 13433                                  	mov	byte [LINPERPAG],23 ; Set default for lines per page
 13434                                  	;test	al,1
 13435                                  	test	al,SWITCHW	; /W ?
 13436                                  	;mov	al,1
 13437                                  	mov	al,NORMPERLIN
 13438                                  	jz	short DIR8
 13439                                  	;mov	al,5
 13440                                  	mov	al,WIDEPERLIN
 13441                                  DIR8:
 13442                                  	mov	[LINLEN],al	; Set number of entries per line
 13443                                  	mov	[LINCNT],al
 13444                                  	mov	word [FILECNT],0 ; Keep track of how many files found
 13445                                  	mov	dx,DIRBUF
 13446                                  	mov	ah,Set_DMA ; 1Ah
 13447                                  	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13448                                  			; DS:DX	-> disk	transfer buffer
 13449                                  	;mov	dl,[5Ch]
 13450                                  	mov	dl,[FCB]
 13451                                  	call	SAVUDIR
 13452                                  	pop	bx
 13453                                  	cmp	bx,0FFFFh
 13454                                  	jz	short DIR9
 13455                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 13456                                  	mov	dx,[bx]
 13457                                  
 13458                                  ; The user may have specified a device. Search for the path and see if the
 13459                                  ; attributes indicate a device.
 13460                                  
 13461                                  	mov	ah,Find_First ; 4Eh
 13462                                  	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 13463                                  			; CX = search attributes
 13464                                  			; DS:DX	-> ASCIZ filespec
 13465                                  			; (drive,path, and wildcards allowed)
 13466                                  	jc	short DIR10
 13467                                  			; Check device atrribute..
 13468                                  	;test	byte [DIRBUF_ATTRIB2],40h
 13469                                  	;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
 13470                                  	; 14/10/2018
 13471                                  	;test	byte [DIRBUF+21],40h
 13472                                  	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 13473                                  	jz	short DIR10	; no, go do normal operation
 13474                                  	mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
 13475                                  DIR9:
 13476                                  	jmp	short DOHEADER
 13477                                  DIR10:
 13478                                  	;mov	dx,[bx+ARGV_ELE.argpointer]
 13479                                  	mov	dx,[bx]
 13480                                  	mov	ah,CHDir ; 3Bh
 13481                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13482                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13483                                  	jnc	short DOHEADER
 13484                                  	;mov	si,[bx+3]
 13485                                  	mov	si,[bx+ARGV_ELE.argstartel]
 13486                                  	cmp	dx,si
 13487                                  	jz	short DIR_NO_DRIVE
 13488                                  	xor	cl,cl
 13489                                  	xchg	cl,[si]
 13490                                  	mov	ah,CHDir ; 3Bh
 13491                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13492                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13493                                  	xchg	cl,[si]
 13494                                  	jnc	short DIR_NO_DRIVE
 13495                                  	mov	al,[si-1]
 13496                                  	call	PATHCHRCMP
 13497                                  	jnz	short DIR11
 13498                                  	mov	al,[si-2]
 13499                                  	call	PATHCHRCMP
 13500                                  	jz	short DIR12
 13501                                  	xchg	cl,[si-1]
 13502                                  	mov	ah,CHDir ; 3Bh
 13503                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13504                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13505                                  	xchg	cl,[si-1]
 13506                                  	jnc	short DIR_NO_DRIVE
 13507                                  DIR11:
 13508                                  	mov	ch,':'
 13509                                  	cmp	ch,[si-1]
 13510                                  	jnz	short DIR12
 13511                                  	;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
 13512                                  	mov	cx,[bx]
 13513                                  	xchg	cx,si
 13514                                  	sub	cx,si
 13515                                  	cmp	cx,2
 13516                                  	jz	short DIR_NO_DRIVE
 13517                                  DIR12:
 13518                                  	mov	dx,BADCDPTR
 13519                                  	;test	byte [bx+2],4
 13520                                  	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 13521                                  	jnz	short DIRERROR
 13522                                  DIRNF:
 13523                                  	mov	dx,FNOTFOUNDPTR
 13524                                  DIRERROR:
 13525                                  	jmp	CERROR
 13526                                  DIR_NO_DRIVE:
 13527                                  	cmp	word [si],'..'
 13528                                  	jnz	short DOREALPARSE
 13529                                  	cmp	byte [si+2],0
 13530                                  	jnz	short DOREALPARSE
 13531                                  	inc	word [COMSW]
 13532                                  	jmp	short DOHEADER
 13533                                  DOREALPARSE:
 13534                                  	mov	di,FCB ; 5Ch	
 13535                                  	;mov	ax,290Eh
 13536                                  	mov	ax,(Parse_File_Descriptor<<8)|0Eh
 13537                                  	int	21h	; DOS -	PARSE FILENAME
 13538                                  			; DS:SI	-> string to parse
 13539                                  			; ES:DI	-> buffer to fill with unopened	FCB
 13540                                  			; AL = bit mask	to control parsing
 13541                                  	cmp	byte [si],0
 13542                                  	jz	short DOHEADER
 13543                                  	dec	word [COMSW]
 13544                                  DOHEADER:
 13545                                  		
 13546                                  ; Display the header
 13547                                  
 13548                                  	push	bx
 13549                                  	call	BUILD_DIR_STRING
 13550                                  	mov	dx,DIRBUF
 13551                                  	mov	[VOL_DIR],dx
 13552                                  	mov	dx,DIRHEADPTR
 13553                                  	call	PRINTF_CRLF
 13554                                  	pop	bx
 13555                                  	cmp	bx,0FFFFh
 13556                                  	jz	short DOSEARCH
 13557                                  
 13558                                  ; If there were chars left after parse or device, then invalid file name
 13559                                  
 13560                                  	cmp	word [COMSW],0
 13561                                  	jz	short DOSEARCH	; nothing left; good parse
 13562                                  	jl	short DIRNFFIX	; not .. => error file not found
 13563                                  	call	RESTUDIR
 13564                                  	mov	dx,BADCDPTR
 13565                                  	jmp	CERROR		; was .. => error directory not found
 13566                                  DIRNFFIX:
 13567                                  	call	RESTUDIR
 13568                                  	jmp	short DIRNF
 13569                                  
 13570                                  ; We are assured that everything is correct. Let's go and search. Use
 13571                                  ; attributes that will include finding directories. Perform the first search
 13572                                  ; and reset our directory afterward.
 13573                                  
 13574                                  DOSEARCH:
 13575                                  	;mov	byte [55h],0FFh
 13576                                  	mov	byte [FCB-7],0FFh
 13577                                  	;mov	byte [5Bh],10h
 13578                                  	mov	byte [FCB-1],10h
 13579                                  
 13580                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
 13581                                  ; the directory information as an extended FCB. We must bias all fetches into
 13582                                  ; DIRBUF by 8 (Extended FCB part + drive)
 13583                                  
 13584                                  	mov	ah,Dir_Search_First ; 11h
 13585                                  	mov	dx,FCB-7 ; 55h
 13586                                  	int	21h	; DOS -	SEARCH FIRST USING FCB
 13587                                  			; DS:DX	-> FCB
 13588                                  
 13589                                  ; Restore the user's directory. We preserve, though, the return from the
 13590                                  ; previous system call for later checking.
 13591                                  
 13592                                  FOUND_FIRST_FILE:
 13593                                  	push	ax		; save return state
 13594                                  	call	RESTUDIR	; restore user's dir	
 13595                                  	pop	ax		; get return state back
 13596                                  
 13597                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
 13598                                  ; no more.
 13599                                  
 13600                                  DIRSTART:
 13601                                  	inc	al		; 0FFh = file not found
 13602                                  	jnz	short DISPLAY	; Either an error or we are finished
 13603                                  	jmp	CHKCNT
 13604                                  DISPLAY:
 13605                                  	inc	word [FILECNT]	; Keep track of how many we find
 13606                                  	mov	si,DIRBUF+8	; SI -> information returned by sys call
 13607                                  	;call	SHONAME
 13608                                  	call	DISPLAYNAME
 13609                                  	;test	byte [_BITS],1
 13610                                  	test	byte [_BITS],SWITCHW ; W switch set?
 13611                                  	jz	short DIRTEST	; If so, no size, date, or time
 13612                                  	jmp	NEXENT
 13613                                  DIRTEST:
 13614                                  	;test	byte [DIRBUF_ATTRIB1],10h
 13615                                  	; 14/10/2018
 13616                                  	;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
 13617                                  	;test	byte [DIRBUF+19],10h
 13618                                  	test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
 13619                                  	jz	short FILEENT
 13620                                  	mov	dx,DMESPTR
 13621                                  	call	STD_PRINTF
 13622                                  	jmp	short NOFSIZ
 13623                                  FILEENT:
 13624                                  	;mov	dx,[DIRBUF_FSIZ_L]
 13625                                  	;mov	dx,[DIRBUF+36]
 13626                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
 13627                                  	mov	[FILESIZE_L],dx
 13628                                  	;mov	dx,[DIRBUF_FSIZ_H]
 13629                                  	;mov	dx,[DIRBUF+38]
 13630                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
 13631                                  	mov	[FILESIZE_H],dx
 13632                                  	mov	dx,FSIZEMESPTR
 13633                                  	call	STD_PRINTF	; Print size of file
 13634                                  NOFSIZ:
 13635                                  	;mov	ax,[DIRBUF_FDATE]  ; Get date
 13636                                  	;mov	ax,[DIRBUF+32]
 13637                                  	mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
 13638                                  	or	ax,ax
 13639                                  	jz	short NEXENT	; Skip if no date
 13640                                  	mov	di,CHARBUF
 13641                                  	push	ax
 13642                                  	mov	ax,'  '
 13643                                  	stosw
 13644                                  	pop	ax
 13645                                  	mov	bx,ax
 13646                                  	and	ax,1Fh		; Get day
 13647                                  	mov	dl,al
 13648                                  	mov	ax,bx
 13649                                  	mov	cl,5
 13650                                  	shr	ax,cl		; Align month
 13651                                  	and	al,0Fh		; Get month
 13652                                  	mov	dh,al
 13653                                  	mov	cl,bh
 13654                                  	shr	cl,1		; Align year
 13655                                  	xor	ch,ch
 13656                                  	add	cx,80		; Relative 1980
 13657                                  	cmp	cl,100
 13658                                  	jb	short MILLENIUM
 13659                                  	sub	cl,100
 13660                                  MILLENIUM:
 13661                                  	call	DATE_CXDX
 13662                                  	;mov	cx,[DIRBUF_FTIME]
 13663                                  	;mov	cx,[DIRBUF+30]
 13664                                  	mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
 13665                                  	jcxz	PRBUF		; Time field present?
 13666                                  	mov	ax,2020h
 13667                                  	stosw
 13668                                  	shr	cx,1
 13669                                  	shr	cx,1
 13670                                  	shr	cx,1
 13671                                  	shr	cl,1
 13672                                  	shr	cl,1		; Hours in CH, minutes in CL
 13673                                  	mov	bl,[TIME_24]
 13674                                  	or	bl,80h		; Tell P_TIME called from DIR
 13675                                  	call	P_TIME		; Don't care about DX, never used with DIR
 13676                                  PRBUF:
 13677                                  	xor	ax,ax
 13678                                  	stosb
 13679                                  	mov	dx,CHARBUF
 13680                                  	mov	[STRING_PTR_2],dx
 13681                                  	mov	dx,STRINGBUF2PTR
 13682                                  	call	STD_PRINTF
 13683                                  NEXENT:
 13684                                  	dec	byte [LINCNT]
 13685                                  	jnz	short SAMLIN
 13686                                  NEXLIN:
 13687                                  	mov	al,[LINLEN]
 13688                                  	mov	[LINCNT],al
 13689                                  	call	CRLF2
 13690                                  	dec	byte [LINPERPAG]
 13691                                  	jnz	short SCROLL
 13692                                  	;test	byte [_BITS],2
 13693                                  	test	byte [_BITS],SWITCHP ; P switch present?
 13694                                  	jz	short SCROLL	; If not, just continue
 13695                                  	mov	byte [LINPERPAG],23
 13696                                  	call	PAUSE
 13697                                  	jmp	short SCROLL
 13698                                  SAMLIN:
 13699                                  	mov	dx,TABPTR	; Output a tab
 13700                                  	call	STD_PRINTF
 13701                                  SCROLL:
 13702                                  	mov	ah,Dir_Search_Next ; 12h
 13703                                  	;mov	dx,55h
 13704                                  	mov	dx,FCB-7	; DX -> Unopened FCB
 13705                                  	int	21h	; DOS -	SEARCH NEXT USING FCB
 13706                                  			; DS:DX	-> FCB
 13707                                  			; Return: AL = status
 13708                                  	jmp	DIRSTART
 13709                                  CHKCNT:
 13710                                  	test	word [FILECNT],0FFFFh ; -1
 13711                                  	jnz	short TRAILER
 13712                                  	jmp	DIRNF
 13713                                  TRAILER:
 13714                                  	mov	al,[LINLEN]
 13715                                  	cmp	al,[LINCNT]
 13716                                  	jz	short MMESSAGE
 13717                                  	call	CRLF2
 13718                                  MMESSAGE:
 13719                                  	mov	dx,DIRMESPTR
 13720                                  	mov	si,[FILECNT]
 13721                                  	mov	[DIR_NUM],si
 13722                                  	call	STD_PRINTF
 13723                                  DTFREE:
 13724                                  	mov	ah,GET_DRIVE_FREESPACE ; 36h
 13725                                  	;mov	dl,[5Ch]
 13726                                  	mov	dl,[FCB]
 13727                                  	int	21h	; DOS -	2+ - GET DISK SPACE
 13728                                  			; DL = drive code (0 = default,	1 = A,2 = B,etc.)
 13729                                  	cmp	ax,-1
 13730                                  	jnz	short DTFREE1
 13731                                  DTRET:
 13732                                  	retn
 13733                                  DTFREE1:
 13734                                  	mul	cx
 13735                                  	mul	bx
 13736                                  	mov	[BYTES_FREE],ax
 13737                                  	mov	[BYTES_FREE+2],dx
 13738                                  	mov	dx,BYTEMESPTR
 13739                                  	jmp	STD_PRINTF
 13740                                  
 13741                                  ; =============== S U B	R O U T	I N E =======================================
 13742                                  
 13743                                  SHONAME:
 13744                                  DISPLAYNAME:
 13745                                  	; MSDOS 3.3
 13746                                  	mov	di,CHARBUF
 13747                                  	mov	cx,8
 13748                                  	rep	movsb
 13749                                  	mov	al,' '
 13750                                  	stosb
 13751                                  	mov	cx,3
 13752                                  	rep	movsb
 13753                                  	xor	ax,ax
 13754                                  	stosb
 13755                                  	push	dx
 13756                                  	mov	dx,CHARBUF
 13757                                  	mov	[STRING_PTR_2],dx
 13758                                  	mov	dx,STRINGBUF2PTR
 13759                                  	call	STD_PRINTF
 13760                                  	pop	dx
 13761                                  	retn
 13762                                  
 13763                                  %endif
 13764                                  
 13765                                  ;============================================================================
 13766                                  ; DIR.ASM, MSDOS 6.0, 1991
 13767                                  ;============================================================================
 13768                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13769                                  
 13770                                  	; MSDOS 6.0
 13771                                  %if 0
 13772                                  
 13773                                  ;***	DIR.ASM - DIR internal command
 13774                                  
 13775                                  comment	% =================================================================
 13776                                  
 13777                                  This module replaces TCMD1A.ASM.  The old module was titled 
 13778                                  "PART4 COMMAND Transient routines".
 13779                                  
 13780                                  From residual documentation, I surmise that TCMD.ASM originally
 13781                                  contained the internal commands DIR, PAUSE, ERASE, TYPE, VOL, and
 13782                                  VER.  The file seems to have been successively split:
 13783                                  
 13784                                    TCMD -> TCMD1,TCMD2 -> TCMD1A,TCMD1B,TCMD2A,TCMD2B
 13785                                  
 13786                                  TCMD1A.ASM contained only the DIR command.
 13787                                  
 13788                                  Usage:
 13789                                  ------
 13790                                  
 13791                                  DIR <filespec> /w /p /b /s /l /c /o<sortorder> /a<attriblist>
 13792                                  
 13793                                  DIR /?
 13794                                  
 13795                                  
 13796                                  <filespec> may include any or none of:  drive; directory path;
 13797                                             wildcarded filename.  If drive or directory path are
 13798                                  	   omitted, the current defaults are used.  If the
 13799                                  	   file name or extension is omitted, wildcards are
 13800                                  	   assumed.
 13801                                  
 13802                                  /w	Wide listing format.  Files are displayed in compressed
 13803                                  	'name.ext' format.  Subdirectory files are enclosed in
 13804                                  	brackets, '[dirname]'.
 13805                                  
 13806                                  /p	Paged, or prompted listing.  A screenful is displayed
 13807                                  	at a time.  The name of the directory being listed appears
 13808                                  	at the top of each page.
 13809                                  
 13810                                  	Bugbug:  pages nead to be uniform length..?
 13811                                  
 13812                                  /b	Bare listing format.  Turns off /w or /p.  Files are 
 13813                                  	listed in compressed 'name.ext' format, one per line,
 13814                                  	without additional information.  Good for making batch
 13815                                  	files or for piping.  When used with /s, complete
 13816                                  	pathnames are listed.
 13817                                  
 13818                                  /s	Descend subdirectory tree.  Performs command on current
 13819                                  	or specified directory, then for each subdirectory below
 13820                                  	that directory.  Directory header and footer is displayed
 13821                                  	for each directory where matching files are found, unless
 13822                                  	used with /b.  /b suppresses headers and footers.
 13823                                  
 13824                                  	Tree is explored depth first, alphabetically within the
 13825                                  	same level.
 13826                                  
 13827                                  	Bugbug:  hidden directories aren't searched.
 13828                                  
 13829                                  /l	Display file names, extensions and paths in lowercase.	;M010
 13830                                  
 13831                                  /c	Display file compression ratio, if the file is on a MagicDrv
 13832                                  	compressed volume.
 13833                                  
 13834                                  /o	Sort order.  /o alone sorts by default order (dirs-first, name,
 13835                                  	extension).  A sort order may be specified after /o.  Any of
 13836                                  	the following characters may be used: nedsgc (name, extension,
 13837                                  	date/time, size, group-dirs-first, compression ratio).	Placing
 13838                                  	a '-' before any letter causes a downward sort on that field.
 13839                                  	E.g., /oe-d means sort first by extension in alphabetical order,
 13840                                  	then within each extension sort by date and time in reverse
 13841                                  	chronological order.
 13842                                  
 13843                                  /a	Attribute selection.  Without /a, hidden and system files
 13844                                  	are suppressed from the listing.  With /a alone, all files
 13845                                  	are listed.  An attribute list may follow /a, consisting of
 13846                                  	any of the following characters:  hsdar (hidden, system,
 13847                                  	directory, archive, read-only).  A '-' before any letter
 13848                                  	means 'not' that attribute.  E.g., /ar-d means files that
 13849                                  	are marked read-only and are not directory files.  Note
 13850                                  	that hidden or system files may be included in the listing.
 13851                                  	They are suppressed without /a but are treated like any other
 13852                                  	attribute with /a.
 13853                                  
 13854                                  /?	Help listing.  Display DIR useage information.	;M008;Handled externally
 13855                                  
 13856                                  /h has been removed.					;M008
 13857                                  
 13858                                  DIRCMD	An environment variable named DIRCMD is parsed before the
 13859                                  	DIR command line.  Any command line options may be specified
 13860                                  	in DIRCMD, and become defaults.  /? will be ignored in DIRCMD.
 13861                                  	A filespec may be specified in DIRCMD and will be used unless
 13862                                  	a filespec is specified on the command line.  Any switch
 13863                                  	specified in DIRCMD may be overridden on the command line.
 13864                                  	If the original DIR default action is desired for a particular
 13865                                  	switch, the switch letter may be preceded by a '-' on the
 13866                                  	command line.  E.g.,
 13867                                  
 13868                                  	  /-w	use long listing format
 13869                                  	  /-p	don't page the listing
 13870                                  	  /-b	don't use bare format
 13871                                  	  /-s	don't descend subdirectory tree
 13872                                  	  /-o	display files in disk order
 13873                                  	  /-a	suppress hidden and system files
 13874                                  
 13875                                  Notes:
 13876                                  ------
 13877                                  
 13878                                  For sorted listings, file entries are loaded into the TPA buffer, which
 13879                                  is usually about 64K in size.  This allows sorts of up to 3000 files at
 13880                                  a time.  Each entry takes up 21 bytes in the buffer (see EntryStruc below).
 13881                                  The byte after the last entry is 0FFh.  The first byte of each entry is
 13882                                  a flag byte which is made zero when the entry is loaded, and made one
 13883                                  when the entry is used.
 13884                                  
 13885                                  Revision History
 13886                                  ================
 13887                                  M01	md	7/13/90 	Use ROM BIOS data area to obtain screen height
 13888                                  				in the absence of ANSI.SYS
 13889                                  
 13890                                  M007	sa	8/1/90		Allow /p/b combination
 13891                                  
 13892                                  M008	sa	8/1/90		Remove /h parameter.  Eliminate code used
 13893                                  				to internally handle /? message.
 13894                                  
 13895                                  M010	sa	8/5/90		Add support for /l (lowercase) option.
 13896                                  
 13897                                  M011	sa	8/5/90		Patch up bug where MS-DOS does not load the
 13898                                  				first FCB with the drive number when the drive
 13899                                  				letter in the command line is preceded by a
 13900                                  				switch.  Now dir manually loads the drive
 13901                                  				number after parsing.
 13902                                  
 13903                                  M018	md	8/12/90 	Increment the screen height by 1 when obtained
 13904                                  				from the ROM BIOS.
 13905                                  
 13906                                  M023	sa	8/31/90		Prevent DIR from failing if it encounters
 13907                                  				a subdirectory having len(pathname)>MAXPATH.
 13908                                  				Just skip over that subdirectory.
 13909                                  
 13910                                  M028	dbo	9/24/90		When country=US, sort by strict character
 13911                                  				byte value, rather than collating table.
 13912                                  				This to match MS-DOS Shell's sort order.
 13913                                  
 13914                                  ========================================================================= %
 13915                                  
 13916                                  %endif
 13917                                  
 13918                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM (MSDOS 6.22)
 13919                                  ;ifdef DBLSPACE_HOOKS
 13920                                  NUM_DIR_SWS	equ	16	; # of dir switch synonyms in Dir_Sw_Ptrs list
 13921                                  ;else
 13922                                  ; 16/02/2023 - Retro DOS v4.0 (v4.1) COMMAND.COM (MSDOS 5.0)
 13923                                  ;NUM_DIR_SWS	equ	14	; # of dir switch synonyms in Dir_Sw_Ptrs list
 13924                                  ;endif
 13925                                  
 13926                                  ;OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1
 13927                                  ;
 13928                                  ;		on/off bit record for /l, /b, /s, /p, /w, /c options
 13929                                  ;		(order is hard-coded; see OnOffSw)
 13930                                  ;		Inmem is set when entries are loaded in memory.
 13931                                  
 13932                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13933                                  ;mask.wide  equ 1
 13934                                  ;mask.pagd  equ 2
 13935                                  ;mask.subd  equ 4
 13936                                  ;mask.bare  equ 8
 13937                                  ;mask.lcase equ 16
 13938                                  ;mask.inmem equ 32
 13939                                  
 13940                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 13941                                  ;ifdef DBLSPACE_HOOKS
 13942                                  ;  OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1,cratio:1
 13943                                  ;else
 13944                                  ;  OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1
 13945                                  ;endif
 13946                                  mask.cratio equ 1
 13947                                  mask.wide   equ 2
 13948                                  mask.pagd   equ 4
 13949                                  mask.subd   equ 8
 13950                                  mask.bare   equ 16
 13951                                  mask.lcase  equ 32
 13952                                  mask.inmem  equ 64
 13953                                  ;
 13954                                  mask.dev    equ 1
 13955                                  mask.baddir equ 2	
 13956                                  
 13957                                  NUM_ATTR_LTRS	equ	6	; length of attribute letter list
 13958                                  
 13959                                  ; 05/06/2023
 13960                                  ;ifdef DBLSPACE_HOOKS
 13961                                  NUM_ORDER_LTRS	equ	6	; length of sort order letter list
 13962                                  CRATIO_ORDER	equ	6	; position of 'C' in ORDER_LTRS
 13963                                  ;else
 13964                                  ;NUM_ORDER_LTRS	equ	5	; length of sort order letter list
 13965                                  ;endif
 13966                                  
 13967                                  ;ResultBuffer	struc		; structure of parse result buffer
 13968                                  ;ValueType	db	?
 13969                                  ;ValueTag	db	?
 13970                                  ;SynPtr		dw	?
 13971                                  ;ValuePtr	dd	?
 13972                                  ;ResultBuffer	ends
 13973                                  
 13974                                  ;ErrorRec	record	baddir:1,dev:1
 13975                                  ;
 13976                                  ;		Error bits are:
 13977                                  ;		  Invalid directory format
 13978                                  ;		  File is device
 13979                                  
 13980                                  ;EntryStruc	struc			; our private directory entry structure
 13981                                  ;used		db	?		; =0 until entry used, then =1
 13982                                  ;filename	db	8 dup (?)	; filename
 13983                                  ;fileext	db	3 dup (?)	; extension
 13984                                  ;fileattr	db	?		; file attributes
 13985                                  ;filetime	dw	?		; file time
 13986                                  ;filedate	dw	?		; file date
 13987                                  ;filesize	dd	?		; file size
 13988                                  ; 05/06/2023
 13989                                  ;;ifdef DBLSPACE_HOOKS
 13990                                  ;compratio	db	?		; compression ratio
 13991                                  ;;endif
 13992                                  ;EntryStruc	ends
 13993                                  
 13994                                  ;shove	macro	val		; hose-bag 8086 doesn't push immediate
 13995                                  ;	mov	ax,val		; invisible, dangerous use of AX!
 13996                                  ;	push	ax
 13997                                  ;	endm
 13998                                  
 13999                                  ;	public	Catalog		; our entry point
 14000                                  ;
 14001                                  ;	break	<DIR (Catalog) principal routines>
 14002                                  ;
 14003                                  ;	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP
 14004                                  ; ---------------------------------------------------------------------------
 14005                                  ;	Bugbug:	Each routine should start with it's own ASSUME.
 14006                                  
 14007                                  ;----------------------------------------------------------------------------
 14008                                  ;----------------------------------------------------------------------------
 14009                                  
 14010                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14011                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:108Dh
 14012                                  
 14013                                  ;***	Catalog - DIR command main routine
 14014                                  ;
 14015                                  ;	ENTRY	FCB #1 in PSP has drive# from cmd-line or default
 14016                                  ;		Cmd-line tail text is at 81h, terminated by 0Dh
 14017                                  ;		CS, DS, ES, SS = TRANGROUP seg addr
 14018                                  ;		Tpa = TPA buffer seg addr
 14019                                  ;		BytCnt = # bytes in TPA buffer
 14020                                  ;
 14021                                  ;	EXIT	nothing
 14022                                  ;
 14023                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 14024                                  ;
 14025                                  ;	ERROR EXITS
 14026                                  ;
 14027                                  ;	  Errors are handled by setting up error message pointers
 14028                                  ;	   for Std_EPrintf and jumping to CError. Syntax errors in
 14029                                  ;	   the environment variable, however, are handled by printing
 14030                                  ;	   an error message and continuing.
 14031                                  ;
 14032                                  ;	EFFECTS
 14033                                  ;
 14034                                  ;	  Directory listing is displayed (on standard output).
 14035                                  ;	  APPEND is disabled. HeadFix routine is expected to
 14036                                  ;	   restore APPEND state.
 14037                                  ;	  Working directory may be changed. The user's default
 14038                                  ;	   directory is saved and flagged for restoration by RestUDir
 14039                                  ;	   during COMMAND cycle.
 14040                                  ;	  Lots of variables may be changed in TRANSPACE segment.
 14041                                  ;
 14042                                  ;	NOTES
 14043                                  ;
 14044                                  ;	  ES = TRANGROUP seg addr except when used to address the
 14045                                  ;	   the TPA buffer, where directory entries are loaded from disk.
 14046                                  
 14047                                  	; 16/02/2023
 14048                                  
 14049                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 14050                                  ;----------------------------------------------------------------------------
 14051                                  ; MSDOS 6.22 COMMAND.COM - TRANGROUP:1167h
 14052                                  
 14053                                  CATALOG:
 14054                                  	; 07/06/2023
 14055                                  	; MSDOS 6.22 COMMAND COM feature only !
 14056 00001137 E82B0A                  	call    screen_f_set	; set display parameters for video/text mode
 14057                                  	;			; (different depending on scr width/columns)
 14058 0000113A E8C900                  	call	SetDefaults
 14059 0000113D E8ED00                  	call	ParseEnvironment
 14060 00001140 E80501                  	call	ParseCmdLine
 14061 00001143 7303                    	jnc	short catalog1	; no parse error
 14062                                  	;jmp	catErr		; error msg is set up
 14063                                  	; 07/06/2023
 14064                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMANBD.COM
 14065 00001145 E9B100                  	jmp	catExtErr2 
 14066                                  catalog1:
 14067 00001148 E82E01                  	call	SetOptions
 14068 0000114B E80401                  	call	SetCollatingTable
 14069                                  
 14070                                  ;	Drive # to operate on has already been placed in FCB by
 14071                                  ;	COMMAND preprocessing. OkVolArg & PathCrunch depend on that.
 14072                                  
 14073                                  	;;;test	Bits,mask bare
 14074                                  	;;test 	word [_Bits],8
 14075                                  	;test	byte [_Bits],8
 14076                                  	; 07/06/2023
 14077 0000114E F606[A2A0]10            	test	byte [_Bits],mask.bare ; 10h ; MSDOS 6.0
 14078 00001153 750A                    	jnz	short catalog2	; don't display volume info for /b
 14079                                  	;invoke	OkVolArg	; find & display volume info
 14080 00001155 E85C10                  	call	OkVolArg
 14081                                  	;sub	byte [LeftOnpage],2
 14082 00001158 832E[419E]02            	sub	word [LeftOnPage],2
 14083                                  				; record display lines used by volume info
 14084 0000115D EB14                    	jmp	short catCrunch
 14085                                  
 14086                                  ;	OkVolArg side effects:
 14087                                  ;	APPEND is disabled;
 14088                                  ;	DTA established at DirBuf;
 14089                                  ;	Filename fields in FCB are wildcarded.
 14090                                  
 14091                                  catalog2:
 14092                                  ;	OkVolArg wasn't executed, so we have to do these ourselves.
 14093                                  
 14094                                  	;invoke	DisAppend	; disable APPEND
 14095 0000115F E81F10                  	call	DisAppend
 14096                                  
 14097                                  	;mov	dx,offset TRANGROUP:DirBuf
 14098 00001162 BA[50A0]                	mov	dx,DIRBUF
 14099 00001165 B41A                    	mov	ah,1Ah
 14100                                  	;mov	ah,Set_DMA
 14101 00001167 CD21                    	int	21h		; set DTA
 14102                                  
 14103                                  	;mov	di,FCB	; 5Ch	; ES:DI = ptr to FCB
 14104                                  	;inc	di		; ES:DI = ptr to filename field of FCB
 14105                                  	; 28/07/2024
 14106 00001169 BF5D00                  	mov	di,FCB+1 ; 5Dh
 14107 0000116C B03F                    	mov	al,'?'		; AL = wildcard character
 14108 0000116E B90B00                  	mov	cx,11
 14109 00001171 F3AA                    	rep	stosb		; wildcard filename field
 14110                                  
 14111                                  catCrunch:
 14112 00001173 E86A01                  	call	CrunchPath	; crunch pathname to get directory and filename
 14113 00001176 724B                    	jc	short catRecErr	; handle recorded or extended error
 14114                                  
 14115                                  ;	User's directory has been saved, we've changed to specified directory.
 14116                                  ;	ComSw = error bits for later use
 14117                                  ;	FCB contains parsed filename
 14118                                  
 14119                                  	;cmp	byte [COMSW],0
 14120 00001178 833E[2C9E]00            	cmp	word [COMSW],0
 14121 0000117D 7544                    	jne	short catRecErr	; handle recorded error
 14122                                  
 14123 0000117F E8B801                  	call	InstallCtrlC	; install control-C handler
 14124                                  
 14125                                  	; 07/06/2023
 14126                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 14127                                  	; MSDOS 6.0 (DBLSPACE/DRVSPACE)
 14128                                  
 14129                                   	;test	word [_Bits],1	; mask.cratio
 14130 00001182 F606[A2A0]01            	test	byte [_Bits],mask.cratio ; compression ratio wanted?
 14131 00001187 740A                    	jz      short catalog4
 14132 00001189 E8350A                  	call    OpenCVF         ; yes, try to open CVF file
 14133 0000118C 7305                    	jnc     short catalog4
 14134                                  
 14135                                  	;and	word [_Bits],0FFFEh ; not (mask cratio)
 14136 0000118E 8026[A2A0]FE            	and	byte [_Bits],~mask.cratio ; 0FEh
 14137                                  
 14138                                  catalog4:	; 07/06/2023
 14139 00001193 E89309                  	call	ZeroTotals	; zero grand totals
 14140 00001196 E88304                  	call	ListDir		; list main directory
 14141                                  	;jc	short catExtErr
 14142                                  	; 07/06/2023
 14143                                  	; MSDOS 6.22 COMMAND.COM
 14144 00001199 724E                    	jc      short catExtErr1
 14145                                  
 14146                                  	;;;test	Bits,mask subd
 14147                                  	;;test	word [_Bits],4
 14148                                  	;test	byte [_Bits],4
 14149                                  	; 07/06/2023
 14150 0000119B F606[A2A0]08            	test	byte [_Bits],mask.subd ; 8 ; MSDOS 6.0 
 14151 000011A0 7405                    	jz	short catalog3	; subdirectories option not set
 14152 000011A2 E8AD01                  	call	ListSubds	; list subdirectories
 14153                                  	;jc	short catExtErr
 14154                                  	; 07/06/2023
 14155                                  	; MSDOS 6.22 COMMAND.COM
 14156 000011A5 7242                    	jc      short catExtErr1
 14157                                  
 14158                                  catalog3:
 14159                                  ;	Check if any files were found.
 14160                                  
 14161                                  	;;;test	Bits,mask bare
 14162                                  	;;test	word [_Bits],8
 14163                                  	;test	byte [_Bits],8
 14164                                  	; 07/06/2023
 14165 000011A7 F606[A2A0]10            	test	byte [_Bits],mask.bare ; 16 ; MSDOS 6.0
 14166 000011AC 750A                    	jnz	short catRet	; don't bother for bare format
 14167                                  
 14168 000011AE A1[499E]                	mov	ax,[FileCntTotal]
 14169 000011B1 09C0                    	or	ax,ax
 14170 000011B3 7421                    	jz	short catNoFiles ; no files found
 14171                                  
 14172 000011B5 E8D202                  	call	DisplayTotals	; display trailing grand totals
 14173                                  	;jmp	short catRet	; all done
 14174                                  	; 25/04/2023
 14175                                  	; 07/06/2023
 14176                                  catRet:
 14177                                  	;retn	; MSDOS 5.0 COMMAND.COM
 14178                                  	
 14179                                  	; 07/06/2023
 14180                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 14181                                  
 14182                                  	;test	word [_Bits],1	; mask.cratio
 14183 000011B8 F606[A2A0]01            	test	byte [_Bits],mask.cratio
 14184 000011BD 7403                    	jz      short catRetn
 14185 000011BF E81C0B                  	call    CloseCVF
 14186                                  catRetn:
 14187 000011C2 C3                      	retn
 14188                                  
 14189                                  catRecErr:
 14190                                  
 14191                                  ;	ComSw may have error bit set. If not, do extended error.
 14192                                  
 14193                                  	;;;test	ComSw,mask dev
 14194                                  	;;test	word [COMSW],1
 14195                                  	;test	byte [COMSW],1
 14196 000011C3 F606[2C9E]01            	test	byte [COMSW],mask.dev
 14197 000011C8 750C                    	jnz	short catNoFiles 
 14198                                  				; filename is device, respond 'file not found'
 14199                                  	;;test	ComSw,mask baddir
 14200                                  	;;test	word [COMSW],2
 14201                                  	;test	byte [COMSW],2
 14202 000011CA F606[2C9E]02            	test	byte [COMSW],mask.baddir
 14203                                  	;jz	short catExtErr	; no ComSw error bits, must be extended error
 14204                                  	; 07/06/2023
 14205                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM 
 14206 000011CF 7418                    	jz	short catExtErr1
 14207                                  
 14208                                  	;mov	dx,offset TRANGROUP:BadCd_Ptr
 14209                                  				; invalid directory
 14210 000011D1 BA[2E93]                	mov	dx,badcd_ptr
 14211                                  	;jmp	short catErr
 14212                                  	; 07/06/2023
 14213                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 14214 000011D4 EB23                    	jmp	short catExtErr2	
 14215                                  
 14216                                  catNoFiles:
 14217                                  
 14218                                  ;	Display header and force 'file not found' message.
 14219                                  
 14220 000011D6 E89A07                  	call	DisplayHeader
 14221 000011D9 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 14222 000011DC C606[F191]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 14223 000011E1 BA[F391]                	mov	dx,extend_buf_ptr
 14224 000011E4 A3[F391]                	mov	[extend_buf_ptr],ax
 14225                                  	;jmp	short catErr
 14226                                  	; 07/06/2023
 14227                                  	; MSDOS 6.22 COMMAND.COM
 14228 000011E7 EB10                    	jmp	short catExtErr2
 14229                                  
 14230                                  catExtErr:	; Retro DOS v4.0 (MSDOS 5.0) COMMAND.COM
 14231                                  	; 07/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 14232                                  catExtErr1:
 14233                                  
 14234                                  ;	DOS has returned an error status. Get the extended error#, and
 14235                                  ;	set up an error message, changing 'No more files' error 
 14236                                  ;	to 'File not found' error.
 14237                                  
 14238 000011E9 E84610                  	call	Set_Ext_Error_Msg
 14239 000011EC 833E[F391]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 14240                                  	;jne	short catalog4  ; catErr ; MSDOS 5.0 COMMAND.COM
 14241                                  	; 07/06/2023
 14242                                  	; MSDOS 6.22 COMMAND.COM
 14243 000011F1 7506                    	jne	short catExtErr2	
 14244                                  
 14245 000011F3 C706[F391]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 14246                                  
 14247                                  ;catalog4:	; Retro DOS v4.0 (MSDOS 5.0) COMMAND.COM
 14248                                  	; 07/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 14249                                  catExtErr2:
 14250                                  	;test	word [_Bits],1	; mask.cratio
 14251 000011F9 F606[A2A0]01            	test	byte [_Bits],mask.cratio
 14252                                  				; close Compressed Volume File if cratio
 14253 000011FE 7403                    	jz      short catErr
 14254 00001200 E8DB0A                  	call    CloseCVF
 14255                                  
 14256                                  ;	Error exit. Error message information has been set up
 14257                                  ;	for Std_EPrintf.
 14258                                  
 14259                                  catErr:
 14260 00001203 E99C1C                  	jmp	cerror		; go to COMMAND error recycle point
 14261                                  
 14262                                  	; 25/04/2023
 14263                                  ;catRet:
 14264                                  	;retn
 14265                                  
 14266                                  ; ---------------------------------------------------------------------------
 14267                                  
 14268                                  ;***	SetDefaults - set default pathname, options
 14269                                  ;
 14270                                  ;	ENTRY	DS = TRANGROUP seg addr
 14271                                  ;
 14272                                  ;	EXIT	nothing
 14273                                  ;
 14274                                  ;	USED	AX,DI
 14275                                  ;
 14276                                  ;	EFFECTS
 14277                                  ;	  SrcBuf = '*',EOL - default pathname
 14278                                  ;	  PathPos = ptr to pathname
 14279                                  ;	  PathCnt = length of pathname
 14280                                  
 14281                                  	; 16/02/2023
 14282                                  SetDefaults:
 14283 00001206 BF[38A1]                	mov	di,SrcBuf		; DI = ptr to pathname buffer
 14284 00001209 893E[A6A0]              	mov	[PathPos],di		; PathPos = ptr to pathname
 14285                                  	;mov	al,STAR
 14286 0000120D B02A                    	mov	al,'*'
 14287 0000120F AA                      	stosb
 14288                                  	;mov	al,END_OF_LINE_IN
 14289 00001210 B00D                    	mov	al,0Dh ; cr
 14290 00001212 AA                      	stosb				; SrcBuf = '*',0Dh
 14291 00001213 C706[A4A0]0100          	mov	word [PathCnt],1	; PathCnt = pathname length
 14292                                  
 14293 00001219 31C0                    	xor	ax,ax			; AX = 0
 14294 0000121B A3[2C9E]                	mov	[COMSW],ax		; = no error
 14295 0000121E A3[A2A0]                	mov	[_Bits],ax		; = options off
 14296 00001221 A2[D5A0]                	mov	[DestBuf],al		; = no sort
 14297 00001224 C606[AAA0]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM ; 6
 14298 00001229 A2[ABA0]                	mov	[AttrSelect],al		; exclude hidden, system files
 14299                                  peRet:	; 25/04/2023
 14300 0000122C C3                      	retn
 14301                                  
 14302                                  ; ---------------------------------------------------------------------------
 14303                                  
 14304                                  ;***	ParseEnvironment - find and parse our environment variable
 14305                                  ;
 14306                                  ;	Find our environment variable and parse it. If a parse
 14307                                  ;	error occurs, issue an error message. The parse results
 14308                                  ;	up to the error will still have effect. Always leave
 14309                                  ;	the option variables in a useable state.
 14310                                  ;
 14311                                  ;	ENTRY	DS = TRANGROUP seg addr
 14312                                  ;
 14313                                  ;	EXIT	nothing
 14314                                  ;
 14315                                  ;	USED	AX,BX,CX,DX,SI,DI
 14316                                  ;
 14317                                  ;	EFFECTS
 14318                                  ;
 14319                                  ;	  Bits may contain new option settings.
 14320                                  ;	  DestBuf may contain new series of sort codes.
 14321                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 14322                                  ;	  SrcBuf may contain a new default pathname/filespec.
 14323                                  ;	  PathPos, PathCnt updated for new pathname.
 14324                                  ;
 14325                                  ;	  If a parse error occurred, an error message will be issued.
 14326                                  
 14327                                  	; 16/02/2023
 14328                                  ParseEnvironment:
 14329 0000122D E8A203                  	call	GetEnvValue		; get environment variable value
 14330 00001230 72FA                    	jc	short peRet		; name not found in environment
 14331                                  
 14332                                  ;	SI = ptr to value of environment variable, in TRANGROUP seg
 14333                                  
 14334 00001232 E80E05                  	call	Parse_Line		; parse environment value
 14335 00001235 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 14336                                  	;cmp	ax,END_OF_LINE
 14337 00001238 74F2                    	je	short peRet		; successful completion
 14338                                  
 14339                                  ;	Some kind of parse error occurred.
 14340                                  ;	We're set up for a Std_EPrintf call.
 14341                                  
 14342 0000123A E8E842                  	call	std_eprintf		; display the parse error
 14343                                  	;mov	byte [Msg_Disp_Class],util_msg_class ; -1
 14344                                  					; restore default msg class
 14345 0000123D C606[F191]FF            	mov	byte [msg_disp_class],0FFh ; -1
 14346                                  	;mov	dx,offset TRANGROUP:ErrParsEnv_Ptr
 14347 00001242 BA[3594]                	mov	dx,errparsenv_ptr
 14348                                  	;;invoke Printf_Crlf		; "(Error occurred in environment.."
 14349                                  	;call	Printf_Crlf
 14350                                  	; 25/04/2023
 14351                                  	;retn
 14352 00001245 E9D742                  	jmp	Printf_Crlf
 14353                                  					;M008;Internal handling of /? removed
 14354                                  ;peOk:	and	Bits,not mask help	; disallow /h in environment variable
 14355                                  	; 25/04/2023
 14356                                  ;peRet:
 14357                                  	;retn
 14358                                  
 14359                                  ; ---------------------------------------------------------------------------
 14360                                  
 14361                                  ;***	ParseCmdLine - parse and record command line parameters
 14362                                  ;
 14363                                  ;	ENTRY	PSP offset 81h is beginning of cmd line buffer
 14364                                  ;		DS, ES, CS = TRANGROUP seg addr
 14365                                  ;
 14366                                  ;	EXIT	CY = set if parse error occurred
 14367                                  ;
 14368                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 14369                                  ;		AX = system parser error code
 14370                                  ;		DX = ptr to message block
 14371                                  ;
 14372                                  ;	USED	AX,BX,CX,DX,SI,DI
 14373                                  ;
 14374                                  ;	EFFECTS
 14375                                  ;
 14376                                  ;	  Bits may contain new option settings.
 14377                                  ;	  DestBuf may contain new series of sort codes.
 14378                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 14379                                  ;	  SrcBuf may contain a new default pathname/filespec.
 14380                                  ;	  PathPos, PathCnt updated for new pathname.
 14381                                  ;
 14382                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 14383                                  ;	  Msg_Disp_Class = parse error class
 14384                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 14385                                  ;	  Message block (see DX) is set up for parse error message
 14386                                  
 14387                                  	; 16/02/2023
 14388                                  ParseCmdLine:
 14389 00001248 BE8100                  	mov	si,81h			; SI = ptr to cmd-line tail text
 14390 0000124B E8F504                  	call	Parse_Line		; parse cmd line tail
 14391 0000124E 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 14392                                  	;;cmp	ax,END_OF_LINE
 14393                                  	; 25/04/2023
 14394                                  	;je	short pcOk		; parse completed successfully
 14395                                  
 14396                                  ;	A parse error occurred. We're all set up for message output.
 14397                                  
 14398                                  	; 25/04/2023
 14399                                  	; cf = 1 (ax < 0FFFFh)
 14400                                  	;stc		   		; return failure
 14401                                  	;jmp	short pcRet
 14402                                  	; 25/04/2023
 14403                                  	;retn
 14404                                  pcOk:
 14405                                  	; 25/04/2023
 14406                                  	;cf = 0 (ax = 0FFFFh)
 14407                                  	;clc				; return success
 14408                                  pcRet:
 14409 00001251 C3                      	retn
 14410                                  
 14411                                  ; ---------------------------------------------------------------------------
 14412                                  
 14413                                  ;***	SetCollatingTable - set up character collating table for sorting
 14414                                  ;
 14415                                  ;	If country is other than USA, try to get a collating table
 14416                                  ;	for character sorting. For USA, use straight byte values.
 14417                                  ;	This is so DIR behaves like the MS-DOS Shell, which sorts
 14418                                  ;	by straight byte values in the USA for better performance.
 14419                                  ;
 14420                                  ;	ENTRY	ES = TRANGROUP seg addr
 14421                                  ;
 14422                                  ;	EXIT	nothing
 14423                                  ;
 14424                                  ;	USED	AX,BX,CX,DX,DI
 14425                                  ;
 14426                                  ;	EFFECTS
 14427                                  ;
 14428                                  ;	  If collating table is set -
 14429                                  ;	    CountryPtrId = 6.
 14430                                  ;	    CountryPtr points to collating table.
 14431                                  ;
 14432                                  ;	  Otherwise -
 14433                                  ;	    CountryPtrId = 0.
 14434                                  
 14435                                  SetCollatingTable:
 14436                                  
 14437                                  ;	Begin modification M028
 14438                                  
 14439                                  	;mov	dx,offset TRANGROUP:InternatVars
 14440                                  	;			; DS:DX = ptr to international info buffer
 14441 00001252 BA[B6A9]                	mov	dx,INTERNATVARS
 14442 00001255 B80038                  	mov	ax,3800h
 14443                                  	;mov	ax,INTERNATIONAL << 8
 14444                                  	;;mov	ax,INTERNATIONAL shl 8
 14445                                  				; AX = 'Get current country info'
 14446 00001258 CD21                    	int	21h		; call DOS
 14447 0000125A 7217                    	jc	short scNoTable	; error - so don't collate
 14448                                  
 14449                                  ;	BX = country code
 14450                                  
 14451 0000125C 83FB01                  	cmp	bx,1
 14452 0000125F 7412                    	je	short scNoTable	; we're in USA, don't collate
 14453                                  
 14454                                  ;	End modification M028
 14455                                  
 14456                                  ;*	Country code is other than USA. Try to get a collating table.
 14457                                  
 14458 00001261 B80665                  	mov	ax,6506h
 14459                                  	;mov	ax,(GETEXTCNTRY << 8) + SETCOLLATE
 14460                                  	;;mov	ax,(GETEXTCNTRY shl 8) + SETCOLLATE
 14461                                  				; AH = 'Get Extended Country Info'
 14462                                  				; AL = 'Get Pointer to Collating Table'
 14463 00001264 BBFFFF                  	mov	bx,-1		; BX = code page of interest = CON
 14464 00001267 B90500                  	mov	cx,5		; CX = length of info buffer
 14465 0000126A 89DA                    	mov	dx,bx		; DX = country ID = default
 14466                                  	;mov	di,offset TRANGROUP:CountryPtrInfo
 14467 0000126C BF[D6A9]                	mov	di,CountryPtrInfo
 14468                                  				; ES:DI = ptr to info buffer
 14469 0000126F CD21                    	int	21h		; call DOS
 14470 00001271 7305                    	jnc	short scRet	; success
 14471                                  
 14472                                  ;*	Set CountryPtrId = 0 to signal no collating table.
 14473                                  
 14474                                  scNoTable:			;M028
 14475 00001273 C606[D6A9]00            	mov	byte [CountryPtrId],0
 14476                                  scRet:
 14477 00001278 C3                      	retn
 14478                                  
 14479                                  ; ---------------------------------------------------------------------------
 14480                                  
 14481                                  ;***	SetOptions - check and set options
 14482                                  ;
 14483                                  ;	ENTRY	nothing
 14484                                  ;
 14485                                  ;	EXIT	nothing
 14486                                  ;
 14487                                  ;	USED	AX,BX,CX,DX
 14488                                  ;
 14489                                  ;	EFFECTS
 14490                                  ;
 14491                                  ;	  Bits may contain modified option settings.
 14492                                  ;	  Display_Ioctl table, including LinPerPag variable, is filled in.
 14493                                  ;	  LeftOnPage is initialized to # lines till end of page is handled.
 14494                                  ;	  PerLine is set according to /w presence.
 14495                                  
 14496                                  	; 16/02/2023
 14497                                  
 14498                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 14499                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:12BEh
 14500                                  
 14501                                  SetOptions:
 14502                                  
 14503                                  ;	If bare listing requested, cancel wide listings.
 14504                                  
 14505                                  	;;;test	Bits,mask bare
 14506                                  	;;test	word [_Bits],8
 14507                                  	;test	byte [_Bits],8
 14508                                  	; 07/06/2023
 14509 00001279 F606[A2A0]10            	test	byte [_Bits],mask.bare ; 10h ; MSDOS 6.0
 14510 0000127E 7411                    	jz	short setopts1
 14511                                  	;;;and	Bits,not mask wide	;M007;Allow /p with /b
 14512                                  	;;and	word [_Bits],0FFFEh
 14513                                  	;;and	byte [_Bits],0FEh
 14514                                  	; 07/06/2023
 14515 00001280 8026[A2A0]FD            	and	byte [_Bits],~mask.wide ; 0FDh ; MSDOS 6.0
 14516                                  
 14517                                  ;setopts1:	; MSDOS 5.0 COMMAND.COM
 14518                                  	; 07/06/2023
 14519                                   	; MSDOS 6.22 COMMAND.COM
 14520                                  setopts0:
 14521                                  	;test	word [_Bits],12h  ; (mask bare) or (mask wide)
 14522 00001285 F606[A2A0]12            	test	byte [_Bits],(mask.bare|mask.wide)
 14523 0000128A 7405                    	jz      short setopts1
 14524                                  	;and 	word [_Bits],0FFFEh ; not mask cratio
 14525 0000128C 8026[A2A0]FE            	and	byte [_Bits],~mask.cratio
 14526                                  
 14527                                  setopts1:
 14528                                  ;	Set # lines per display page.
 14529                                  
 14530                                  ;M01  Obtain screen height from ROM BIOS data area
 14531                                  ;
 14532                                  ;M01	mov	LinPerPag,LINESPERPAGE	; default value
 14533                                  
 14534 00001291 1E                      	push	ds
 14535                                  	;mov	ax,ROMBIOS_DATA 	; Get ROM Data segment
 14536 00001292 B84000                  	mov	ax,40h
 14537 00001295 8ED8                    	mov	ds,ax			;
 14538                                  	;Assume	DS:ROMBIOS_DATA
 14539                                  
 14540                                  	;mov	al,[CRT_Rows] ; [84h]	; Get max rows
 14541 00001297 A08400                  	mov	al,[84h]
 14542 0000129A 1F                      	pop	ds			;
 14543                                  	;Assume	DS:Trangroup
 14544                                  
 14545 0000129B 08C0                    	or	al,al			; If zero specified
 14546 0000129D 7502                    	jnz	short setopts2		;
 14547                                  
 14548                                  	;mov	al,LINESPERPAGE 	; assume 24 rows
 14549 0000129F B019                    	mov	al,25	; MSDOS 5.0 COMMAND.COM (TRANGROUP:11D1h)
 14550                                  setopts2:
 14551 000012A1 30E4                    	xor	ah,ah
 14552                                  setopts3:
 14553 000012A3 FEC0                    	inc	al			; height + 1 ;M018
 14554                                  
 14555 000012A5 A3[2EA2]                	mov	[LinPerPag],ax		; set the rows now
 14556                                  
 14557                                  ; Now the console driver can change the rows if it knows better (M01 end)
 14558                                  
 14559                                  	;mov	ax,(IOCTL shl 8)+GENERIC_IOCTL_HANDLE
 14560                                  					; IOCTL for handles
 14561 000012A8 B80C44                  	mov	ax,440Ch
 14562                                  	;mov	bx,STDOUT		; handle #
 14563 000012AB BB0100                  	mov	bx,1
 14564                                  	;mov	ch,IOC_SC		; screen
 14565 000012AE B503                    	mov	ch,3
 14566                                  	;mov	cl,get_generic		; get display info
 14567 000012B0 B17F                    	mov	cl,7Fh
 14568 000012B2 BA[1EA2]                	mov	dx,Display_Ioctl	; info block
 14569 000012B5 CD21                    	int	21h			; call DOS
 14570                                  
 14571 000012B7 A1[2EA2]                	mov	ax,[LinPerPag]		; AX = # lines per page
 14572 000012BA A3[419E]                	mov	[LeftOnPage],ax		; initialize # lines left on page
 14573                                  
 14574                                  ;	Set # entries per line.
 14575                                  
 14576                                  	;mov	byte [PerLine],NORMPERLIN
 14577                                  					; # entries per line without /w
 14578 000012BD C606[3E9E]01            	mov	byte [PerLine],1
 14579                                  	;;;test	Bits,mask wide
 14580                                  	;;test	word [_Bits],1
 14581                                  	;test	byte [_Bits],1
 14582                                  	; 07/06/2023
 14583 000012C2 F606[A2A0]02            	test	byte [_Bits],mask.wide ; 2 ; MSDOS 6.0
 14584 000012C7 7405                    	jz	short setopts4
 14585                                  	;mov	byte [PerLine],WIDEPERLIN
 14586                                  					; # entries per line with /w
 14587 000012C9 C606[3E9E]05            	mov	byte [PerLine],5
 14588                                  setopts4:
 14589                                  				;M011;start;The following code checks if a drive
 14590                                  				;letter has been parsed into SrcBuf, and if
 14591                                  				;so, the correct drive number is loaded into
 14592                                  				;the first FCB, at offset 5C.
 14593                                  
 14594                                  	;cmp	TRANGROUP:[SrcBuf+1],COLON_CHAR	; is this a drive letter?
 14595 000012CE 803E[39A1]3A            	cmp	byte [SrcBuf+1],':'
 14596 000012D3 750A                    	jne	short soRet
 14597                                  	;mov	al,TRANGROUP:[SrcBuf]		; load drive letter into al
 14598 000012D5 A0[38A1]                	mov	al,[SrcBuf]
 14599                                  	;and	al,not 20h			; capitalize ASCII drive letter (LowerCase-32)-->UpperCase
 14600 000012D8 24DF                    	and	al,0DFh ; ~20h ; not 20h
 14601 000012DA 2C40                    	sub	al,'@'	; 40h			; convert to 1-based number (1=A)
 14602 000012DC A25C00                  	mov	[FCB],al  ; [5Ch]		; store in first FCB
 14603                                  						;M011;end
 14604                                  soRet:
 14605 000012DF C3                      	retn
 14606                                  
 14607                                  ; ---------------------------------------------------------------------------
 14608                                  
 14609                                  ;***	CrunchPath - analyze supplied or default pathname
 14610                                  ;
 14611                                  ;	ENTRY	PathPos = ptr to pathname buffer
 14612                                  ;		PathCnt = length of pathname, not incl trailing delimiter
 14613                                  ;		Pathname in buffer must end in delimiter (like CR) and
 14614                                  ;		 must have space for another char after the delimiter.
 14615                                  ;
 14616                                  ;	EXIT	CY = clear if no error
 14617                                  ;		We are changed to directory found in pathname
 14618                                  ;		Previous directory ready to be restored via RestUDir
 14619                                  ;		FCB filename fields contain filename (possibly w/ wildcards)
 14620                                  ;
 14621                                  ;		If error occurred,
 14622                                  ;		CY = set
 14623                                  ;		ComSw = error bits (see ErrorRec)
 14624                                  ;		If ComSw not set,
 14625                                  ;		Ready for DOS Get Extended Error call
 14626                                  
 14627                                  	; 16/02/2023
 14628                                  CrunchPath:
 14629 000012E0 E80102                  	call	FileIsDevice
 14630 000012E3 7507                    	jne	short crpath1	; not a device, skip ahead
 14631                                  	;;;or	ComSw,mask dev	; signal file is device
 14632                                  	;;or	word [COMSW],1
 14633                                  	;or	byte [COMSW],1
 14634 000012E5 800E[2C9E]01            	or	byte [COMSW],mask.dev
 14635 000012EA EB2F                    	jmp	short cpErr	; return error
 14636                                  crpath1:
 14637 000012EC FF36[A6A0]              	push	word [PathPos]	; save ptr to pathname
 14638 000012F0 C606[AEA0]FF            	mov	byte [DirFlag],-1
 14639                                  				; tell PathCrunch not to parse file into FCB
 14640 000012F5 E8D218                  	call	PathCrunch	; change to directory in pathname
 14641 000012F8 C606[AEA0]00            	mov	byte [DirFlag],0
 14642                                  				; reset our little flag
 14643 000012FD 5E                      	pop	si		; SI = ptr to pathname
 14644 000012FE 7208                    	jc	short cpNoDir	; didn't find directory path
 14645 00001300 741A                    	jz	short cpRet	; found directory path w/ no filename
 14646                                  				;  - leave wildcard default in FCB and return
 14647                                  
 14648                                  ;*	We found a directory, and there was a filename attached.
 14649                                  ;	DestTail = ptr to ASCIIZ filename
 14650                                  
 14651 00001302 8B36[D2A0]              	mov	si,[DestTail]	; SI = ptr to filename
 14652 00001306 EB28                    	jmp	short cpFile	; go parse the file into FCB
 14653                                  
 14654                                  ;*	PathCrunch failed to find a directory in the pathname.
 14655                                  ;
 14656                                  ;	Msg_Numb = error code
 14657                                  ;	DestIsDir = nonzero if path delimiter char's occur in pathname
 14658                                  ;	SI = ptr to pathname (now an ASCIIZ string)
 14659                                  
 14660                                  cpNoDir:
 14661 00001308 A1[4BA2]                	mov	ax,[Msg_Numb]	  ; AX = error code from PathCrunch
 14662 0000130B 09C0                    	or	ax,ax
 14663 0000130D 750C                    	jnz	short cpErr	  ; error occurred - return it
 14664 0000130F 803E[D0A0]00            	cmp	byte [DestIsDir],0
 14665 00001314 7407                    	je	short cpMaybe	  ; no path delimiters seen, maybe it's a file
 14666                                  crpath3:
 14667                                  	;;;or	ComSw,mask baddir ; signal invalid directory name
 14668                                  	;;or	word [COMSW],2
 14669                                  	;or	byte [COMSW],2
 14670 00001316 800E[2C9E]02            	or	byte [COMSW],mask.baddir
 14671                                  	;jmp	short cpErr	  ; return error
 14672                                  	; 16/02/2023
 14673                                  cpErr:
 14674 0000131B F9                      	stc			  ; return error
 14675                                  cpRet:
 14676 0000131C C3                      	retn
 14677                                  
 14678                                  cpMaybe:
 14679                                  ;	SI = ptr to pathname
 14680                                  
 14681                                  	;cmp	byte [si+1],COLON_CHAR
 14682 0000131D 807C013A                	cmp	byte [si+1],':'
 14683 00001321 7501                    	jne	short crpath2	  ; no drive specifier, skip ahead
 14684 00001323 AD                      	lodsw			  ; SI = ptr past drive specifier "d:"
 14685                                  crpath2:
 14686 00001324 813C2E2E                	cmp	word [si],".."
 14687 00001328 7506                    	jne	short cpFile	  ; if not "..", treat as a file
 14688 0000132A 807C0200                	cmp	byte [si+2],0
 14689                                  	;jne	short cpFile	  ; or if there's more after "..", treat as file
 14690                                  	;;;;or	ComSw,mask baddir ; signal invalid directory
 14691                                  	;;;or	word [COMSW],2
 14692                                  	;;or	byte [COMSW],2
 14693                                  	;or	byte [COMSW],mask.baddir
 14694                                  	;jmp	short cpErr	  ; return error
 14695                                  	; 16/02/2023
 14696 0000132E 74E6                    	je	short crpath3
 14697                                  
 14698                                  ;	The preceding code was taken from the old DIR routine.
 14699                                  ;	It's garbage, I'm afraid. It's meant to check for ".."
 14700                                  ;	occurring when we're at the root directory. Too bad it
 14701                                  ;	doesn't handle problems with "..\..", etc.
 14702                                  
 14703                                  ;	We're ready to parse a filename into the FCB.
 14704                                  ;	SI = ptr to ASCIIZ filename
 14705                                  
 14706                                  cpFile:	
 14707 00001330 BF5C00                  	mov	di,FCB	; 5Ch	; DI = ptr to FCB
 14708 00001333 B80E29                  	mov	ax,290Eh
 14709                                  	;mov	ax,(Parse_File_Descriptor<<8)|0Eh
 14710                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 0Eh
 14711                                  				; wildcards already in FCB used as defaults
 14712 00001336 CD21                    	int	21h
 14713 00001338 F8                      	clc			; return success
 14714                                  	;jmp	short cpRet
 14715                                  	; 16/02/2023
 14716 00001339 C3                      	retn
 14717                                  
 14718                                  ;cpErr:
 14719                                  ;	stc			; return error
 14720                                  ;cpRet:
 14721                                  ;	retn
 14722                                  
 14723                                  ; ---------------------------------------------------------------------------
 14724                                  
 14725                                  ;***	InstallCtrlC - install our private control-C handler
 14726                                  ;
 14727                                  ;	Put our control-c handler in front of command.com's default
 14728                                  ;	handler, to make sure the user's default directory gets restored.
 14729                                  ;	This shouldn't be necessary, but, for now, there are situations
 14730                                  ;	where the TDATA segment is left in a modified state when a
 14731                                  ;	control-c occurs.  This means that the transient will be
 14732                                  ;	reloaded, and the user's directory cannot be restored.
 14733                                  ;
 14734                                  ;	Bugbug:  fix the wider problem?  Involves message services.  Ugly.
 14735                                  ;
 14736                                  ;	ENTRY	nothing
 14737                                  ;
 14738                                  ;	EXIT	nothing
 14739                                  ;
 14740                                  ;	USED	AX,BX,DX
 14741                                  ;
 14742                                  ;	EFFECTS
 14743                                  ;
 14744                                  ;	  CtrlCHandler address placed in int 23 vector.
 14745                                  ;
 14746                                  ;	NOTE
 14747                                  ;
 14748                                  ;	  Command.com's basic control-c handler will be restored
 14749                                  ;	  to the int 23 vector by the HeadFix routine, after DIR finishes.
 14750                                  
 14751                                  	; 16/02/2023
 14752                                  InstallCtrlC:
 14753 0000133A 06                      	push	es			; preserve ES
 14754 0000133B B82335                  	mov	ax,3523h
 14755                                  	;mov	ax,(GET_INTERRUPT_VECTOR<<8)+23h
 14756                                  	;;mov	ax,(GET_INTERRUPT_VECTOR shl 8) + 23h
 14757 0000133E CD21                    	int	21h
 14758 00001340 891E[DBA9]              	mov	[OldCtrlCHandler],bx	; save old int 23 vector
 14759 00001344 8C06[DDA9]              	mov	[OldCtrlCHandler+2],es	 
 14760 00001348 07                      	pop	es			; restore ES
 14761                                  
 14762 00001349 BA[341B]                	mov	dx,CtrlCHandler 	; DS:DX = ptr to CtrlCHandler
 14763 0000134C B82325                  	mov	ax,2523h
 14764                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+23h
 14765                                  	;;mov	ax,(SET_INTERRUPT_VECTOR shl 8) + 23h
 14766 0000134F CD21                    	int	21h
 14767 00001351 C3                      	retn
 14768                                  
 14769                                  ; ---------------------------------------------------------------------------
 14770                                  
 14771                                  ;***	ListSubds - search and list files in subdirectories
 14772                                  ;
 14773                                  ;	ENTRY	Current directory (on selected drive) is top of subdir tree
 14774                                  ;		FCB is still set up for file searches
 14775                                  ;		Bits, AttrSpecified, AttrSelect, DestBuf all still set up
 14776                                  ;
 14777                                  ;	EXIT	CY = clear if no error
 14778                                  ;		FileCnt = # files found & displayed
 14779                                  ;		FileSiz = total size of files found
 14780                                  ;
 14781                                  ;		If error,
 14782                                  ;		CY = set
 14783                                  ;		Ready for DOS Get Extended Error call
 14784                                  ;
 14785                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 14786                                  ;
 14787                                  ;	EFFECTS
 14788                                  ;
 14789                                  ;	  FileCntTotal, FileSizTotal are updated.
 14790                                  ;	  Subdirectories may be listed on standard output device.
 14791                                  ;
 14792                                  ;	NOTES
 14793                                  ;
 14794                                  ;	  ListSubds seeds the recursive entry point lsNode with a ptr
 14795                                  ;	   to a buffer where we'll stack up subdirectory filenames.
 14796                                  ;	   Each name is stored ASCIIZ.
 14797                                  
 14798                                  	; 16/02/2023
 14799                                  ListSubds:
 14800                                  	;invoke	SetRest1		; make sure user's dir gets restored
 14801 00001352 E8DC1E                  	call	SetRest1
 14802                                  
 14803 00001355 BB[92A1]                	mov	bx,ScanBuf   		; BX = ptr to child name buffer
 14804                                  lsNode:
 14805 00001358 C60700                  	mov	byte [bx],0		; start with null child name
 14806                                  lsLoop:
 14807 0000135B E81002                  	call	FindNextChild		; search for next subdirectory
 14808 0000135E 7235                    	jc	short lsErr		; search failed - examine error
 14809                                  
 14810 00001360 89DA                    	mov	dx,bx			; DX = ptr to child's name
 14811 00001362 E8A904                  	call	ChangeDir		; enter child directory
 14812                                  
 14813                                  					; M023;start
 14814 00001365 7306                    	jnc	short lstsd1		; check for error
 14815                                  	;cmp	ax,3
 14816 00001367 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND	; error due to len(pathname)>MAXPATH?
 14817 0000136A 74EF                    	je	short lsLoop		; yes, skip over this subdirectory
 14818                                  	;jmp	short lsRet		; no, other error: DIR must fail
 14819                                  	; 16/02/2023			; M023;end
 14820 0000136C C3                      	retn
 14821                                  lstsd1:	
 14822 0000136D 53                      	push	bx
 14823 0000136E E8AB02                  	call	ListDir			; list the directory
 14824 00001371 5B                      	pop	bx
 14825                                  
 14826                                  ;	Note we're ignoring errors returned here.
 14827                                  
 14828 00001372 89DF                    	mov	di,bx			; DI = ptr to child's name
 14829 00001374 B90D00                  	mov	cx,13			; CX = max name length w/ null
 14830 00001377 30C0                    	xor	al,al			; AL = zero byte to look for
 14831 00001379 F2AE                    	repne	scasb			; DI = ptr to next name pos'n in buf
 14832 0000137B 53                      	push	bx			; save ptr to child's name
 14833 0000137C 89FB                    	mov	bx,di			; BX = ptr to next name pos'n in buf
 14834 0000137E E8D7FF                  	call	lsNode			; recurse from new node
 14835 00001381 5B                      	pop	bx			; BX = ptr to child's name
 14836 00001382 9C                      	pushf				; save error condition
 14837                                  	
 14838                                  	;;shove	0
 14839                                  	;mov	ax,0
 14840 00001383 29C0                    	sub	ax,ax ; 0
 14841 00001385 50                      	push	ax
 14842                                  	;shove	".."
 14843 00001386 B82E2E                  	mov	ax,'..'  ; 2E2Eh
 14844 00001389 50                      	push	ax
 14845 0000138A 89E2                    	mov	dx,sp			; DX = ptr to "..",0 on stack
 14846 0000138C E87F04                  	call	ChangeDir		; return to parent directory
 14847 0000138F 58                      	pop	ax			; restore stack
 14848 00001390 58                      	pop	ax
 14849                                  
 14850 00001391 9D                      	popf				; restore error condition from child
 14851                                  	;jc	short lsRet		; return error
 14852                                  	;jmp	short lsLoop		; look for more children
 14853                                  	; 16/02/2023
 14854 00001392 73C7                    	jnc	short lsLoop
 14855 00001394 C3                      	retn
 14856                                  lsErr:
 14857 00001395 E8AA0E                  	call	get_ext_error_number	; AX = extended error code
 14858                                  	;cmp	ax,2
 14859 00001398 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 14860 0000139B 7406                    	je	short lsRet		; file not found, we're ok
 14861                                  	;cmp	ax,18
 14862 0000139D 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 14863 000013A0 7401                    	je	short lsRet		; no more files, we're ok
 14864 000013A2 F9                      	stc				; return other errors
 14865                                  lsRet:	
 14866 000013A3 C3                      	retn
 14867                                  
 14868                                  ; ---------------------------------------------------------------------------
 14869                                  
 14870                                  	;break	<DIR support routines>
 14871                                  
 14872                                  ;***	SUPPORT ROUTINES
 14873                                  
 14874                                  ; ----------------------
 14875                                  
 14876                                  ;***	CheckChild - check potential subdirectory name for FindNextChild
 14877                                  ;
 14878                                  ;	ENTRY	DirBuf contains DOS Find-buffer with potential child
 14879                                  ;		BX = ptr to last child's name
 14880                                  ;		BP = ptr to temp child's name
 14881                                  ;
 14882                                  ;	EXIT	nothing
 14883                                  ;
 14884                                  ;	USED	AX,CX,SI,DI
 14885                                  ;
 14886                                  ;	EFFECTS
 14887                                  ;
 14888                                  ;	  Filename pointed to by BP may be changed.
 14889                                  ;
 14890                                  ;	NOTES
 14891                                  ;
 14892                                  ;	  Potential filename replaces temp filename if:
 14893                                  ;	   it's a subdirectory file;
 14894                                  ;	   it doesn't start with a '.';
 14895                                  ;	   it's alphanumerically greater than last child's name;
 14896                                  ;	   and it's alphanumerically less than temp name.
 14897                                  
 14898                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14899                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 14900                                  CheckChild:
 14901                                  	;test	DirBuf.find_buf_attr,ATTR_DIRECTORY
 14902 000013A4 F606[65A0]10            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DIRECTORY ; 10h
 14903 000013A9 741D                    	jz	short ccRet	; not a subdirectory file- return
 14904                                  
 14905                                  	; 16/02/2023
 14906 000013AB BE[6EA0]                	mov	si,DIRBUF+FIND_BUF.PNAME
 14907 000013AE 803C2E                  	cmp	byte [si],'.'
 14908                                  	;;cmp	DirBuf.find_buf_pname,'.'
 14909                                  	;cmp	byte [DIRBUF+FIND_BUF.PNAME],'.'
 14910 000013B1 7415                    	je	short ccRet	; starts with a dot- return
 14911                                  
 14912                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14913                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14914 000013B3 89DF                    	mov	di,bx
 14915 000013B5 E86D04                  	call	CmpAscz		; compare candidate to last child's name
 14916 000013B8 760E                    	jna	short ccRet	; it's not above it- return
 14917                                  
 14918                                  	; 07/06/2023
 14919                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14920                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14921                                  	; si = DIRBUF+FIND_BUF.PNAME
 14922 000013BA 89EF                    	mov	di,bp
 14923 000013BC E86604                  	call	CmpAscz		; compare candidate to temp name
 14924 000013BF 7307                    	jnb	short ccRet	; it's not below it- return
 14925                                  
 14926                                  ;	New kid is alright. Copy to temp.
 14927                                  
 14928                                  	; 07/06/2023
 14929                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14930                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14931                                  	; si = DIRBUF+FIND_BUF.PNAME
 14932 000013C1 89EF                    	mov	di,bp
 14933 000013C3 B90D00                  	mov	cx,13
 14934 000013C6 F3A4                    	rep	movsb
 14935                                  ccRet:
 14936 000013C8 C3                      	retn
 14937                                  
 14938                                  ; ---------------------------------------------------------------------------
 14939                                  
 14940                                  ;***	CmpEntry - compare one directory entry to another in sort order
 14941                                  ;
 14942                                  ;	Compare one directory entry against another according to
 14943                                  ;	the sort codes in DestBuf. One or more comparisons
 14944                                  ;	may be made of file name, extension, time/date, and
 14945                                  ;	size.  Comparisons may be made for upward or downward
 14946                                  ;	sort order.
 14947                                  ;
 14948                                  ;	ENTRY	ES:BX = ptr to entry to compare
 14949                                  ;		ES:BP = ptr to entry to be compared against
 14950                                  ;		DestBuf contains sort codes (see DestBuf)
 14951                                  ;		DS = TRANGROUP seg addr
 14952                                  ;
 14953                                  ;	EXIT	BX = unchanged
 14954                                  ;		BP = unchanged
 14955                                  ;		Condition flags set for same, above, or below
 14956                                  ;		 comparing BX entry against BP entry.
 14957                                  ;		 'Same, above, below' translate to 'same, after, before'.
 14958                                  ;
 14959                                  ;	USED:	AX,CX,DX,SI,DI
 14960                                  
 14961                                  	; 16/02/2023
 14962                                  CmpEntry:
 14963 000013C9 BE[D5A0]                	mov	si,DestBuf	; (DS:SI) = ptr to sort codes
 14964                                  ceLoop:
 14965 000013CC 31C0                    	xor	ax,ax		; AX = 0
 14966 000013CE 8A04                    	mov	al,[si]		; AL = sort code
 14967 000013D0 08C0                    	or	al,al
 14968 000013D2 741C                    	jz	short ceDone	; sort code is zero, we're done
 14969 000013D4 46                      	inc	si		; DS:SI = ptr to next sort code
 14970 000013D5 56                      	push	si		; save ptr to next sort code
 14971 000013D6 FEC8                    	dec	al
 14972 000013D8 D0E0                    	shl	al,1
 14973                                  	;sal	al,1		; AX = index into cmp call table
 14974                                  				; CY set for downward sort order
 14975 000013DA 89C6                    	mov	si,ax		; SI = index into cmp call table
 14976 000013DC 2E8B84[F113]            	mov	ax,[cs:si+FieldCmps]
 14977                                  				; AX = addr of compare routine
 14978 000013E1 7204                    	jc	short ceDn	; downwards sort - go swap entries
 14979 000013E3 FFD0                    	call	ax 		; do upwards sort
 14980 000013E5 EB06                    	jmp	short ceNs
 14981                                  ceDn:
 14982 000013E7 87DD                    	xchg	bx,bp		; swap entry ptrs for downward sort order
 14983 000013E9 FFD0                    	call	ax		; do sort
 14984 000013EB 87DD                    	xchg	bx,bp		; swap ptrs back
 14985                                  ceNs:
 14986 000013ED 5E                      	pop	si		; SI = ptr to next sort code
 14987 000013EE 74DC                    	je	short ceLoop	; compare showed no difference, keep trying
 14988                                  ceDone:
 14989                                  
 14990                                  ;	Get here either from unequal compare or sort code = 0.
 14991                                  ;	In the latter case, condition codes indicate equality,
 14992                                  ;	which is correct.
 14993                                  
 14994 000013F0 C3                      	retn
 14995                                  
 14996                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14997                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:1339h)
 14998                                  
 14999                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 15000                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:144Eh)
 15001                                  
 15002                                  FieldCmps:		; call table of entry comparisons
 15003 000013F1 [FD13]                  	dw	CmpName
 15004 000013F3 [0814]                  	dw	CmpExt
 15005 000013F5 [4614]                  	dw	CmpTime
 15006 000013F7 [6214]                  	dw	CmpSize
 15007 000013F9 [6714]                  	dw	CmpType
 15008                                  	; 05/06/2023 - Retro DOS 4.2 COMMAND.COM
 15009 000013FB [7514]                  	dw	CmpCratio
 15010                                  
 15011                                  ; ---------------------------------------------------------------------------
 15012                                  
 15013                                  ;***	CmpName - compare file name of two entries
 15014                                  ;***	CmpExt - compare extension of two entries
 15015                                  ;
 15016                                  ;	ENTRY	ES:BX = ptr to one entry
 15017                                  ;		ES:BP = ptr to another entry
 15018                                  ;
 15019                                  ;	EXIT	BX = unchanged
 15020                                  ;		BP = unchanged
 15021                                  ;		Condition flags set for same, above, or below
 15022                                  ;		comparing BX entry to BP entry.
 15023                                  ;
 15024                                  ;	USED:	AX,CX,DX,SI,DI
 15025                                  
 15026                                  	; 16/02/2023
 15027                                  CmpName:
 15028 000013FD 89DE                    	mov	si,bx		; ES:SI = ptr to BX entry
 15029 000013FF 89EF                    	mov	di,bp		; ES:DI = ptr to BP entry
 15030                                  	;;add	si,filename	; ES:SI = ptr to BX name
 15031                                  	;add	si,1
 15032                                  	; 25/04/2023
 15033 00001401 46                      	inc	si
 15034                                  	;;add	di,filename	; ES:DI = ptr to BP name
 15035                                  	;add	di,1
 15036                                  	; 25/04/2023
 15037 00001402 47                      	inc	di
 15038                                  	;mov	cx,size filename
 15039                                  				; CX = length of name
 15040 00001403 B90800                  	mov	cx,8
 15041 00001406 EB0C                    	jmp	short CmpStr
 15042                                  
 15043                                  CmpExt:
 15044                                  	; 07/06/2023
 15045                                  	;mov	si,bx		; ES:SI = ptr to BX entry
 15046                                  	;mov	di,bp		; ES:DI = ptr to BP entry
 15047                                  	;;add	si,fileext	; ES:SI = ptr to BX extension
 15048                                  	;add	si,9
 15049                                  	;;add	di,fileext	; ES:DI = ptr to BP extension
 15050                                  	;add	di,9
 15051                                  	;
 15052 00001408 BE0900                  	mov	si,9
 15053 0000140B 89F7                    	mov	di,si ; mov di,9
 15054 0000140D 01DE                    	add	si,bx
 15055 0000140F 01EF                    	add	di,bp
 15056                                  	;
 15057                                  	;mov	cx,size fileext	; CX = length of extension field
 15058 00001411 B90300                  	mov	cx,3
 15059                                  
 15060                                  ;	Bugbug:	use symbol for subfunction code.
 15061                                  
 15062                                  CmpStr:	
 15063 00001414 803E[D6A9]06            	cmp	byte [CountryPtrId],6
 15064 00001419 7527                    	jne	short cnNoCollTable
 15065                                  				; no collating table available
 15066                                  
 15067                                  ;*	Compare strings using collating table.
 15068                                  ;
 15069                                  ;	ES:SI = ptr to 1st string
 15070                                  ;	ES:DI = ptr to 2nd string
 15071                                  ;	CX = length
 15072                                  
 15073 0000141B 55                      	push	bp		; preserve BP
 15074 0000141C 53                      	push	bx		; preserve BX
 15075 0000141D 1E                      	push	ds		; preserve DS
 15076 0000141E C51E[D7A9]              	lds	bx,[CountryPtr]	; DS:BX = ptr to collating table
 15077                                  	;assume	ds:NOTHING
 15078 00001422 8B2F                    	mov	bp,[bx]		; BP = size of collating table
 15079 00001424 43                      	inc	bx
 15080 00001425 43                      	inc	bx		; DS:BX = ptr to collating values
 15081                                  				; DS:[BX]-2 = size of table
 15082 00001426 31C0                    	xor	ax,ax		; AX = 0 for starters
 15083                                  
 15084                                  ;	Bugbug:	Investigate removing collating table length checks.
 15085                                  
 15086                                  cnNextChar:
 15087 00001428 268A05                  	mov	al,[es:di]	; AL = AX = char from 2nd string
 15088 0000142B 47                      	inc	di		; ES:DI = ptr to next char 2nd string
 15089 0000142C 39E8                    	cmp	ax,bp		; compare to collating table length
 15090 0000142E 7301                    	jae	short cn1 	; char not in table
 15091 00001430 D7                      	xlat				
 15092                                  cn1:				; AL = AX = collating value
 15093 00001431 89C2                    	mov	dx,ax		; DX = collating value from 2nd string
 15094                                  	;lods	byte ptr es:[si]
 15095 00001433 26AC                    	es	lodsb		; AL = AX = char from 1st string
 15096                                  				; ES:SI = ptr to next char 1st string
 15097 00001435 39E8                    	cmp	ax,bp		; compare to collating table length
 15098 00001437 7301                    	jae	short cn2	; char not in table
 15099 00001439 D7                      	xlat				
 15100                                  cn2:				; AL = AX = collating value
 15101 0000143A 39D0                    	cmp	ax,dx		; compare collating values
 15102 0000143C E1EA                    	loope	cnNextChar	; until unequal or no more left
 15103                                  
 15104 0000143E 1F                      	pop	ds		; restore DS
 15105                                  	;assume	ds:TRANGROUP
 15106 0000143F 5B                      	pop	bx		; restore BX
 15107 00001440 5D                      	pop	bp		; restore BP
 15108 00001441 C3                      	retn
 15109                                  
 15110                                  ;*	If no collating table is available, simply compare raw ASCII values.
 15111                                  ;	Don't we wish we could just do this all the time?  Sigh.
 15112                                  
 15113                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 15114                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:138Dh)
 15115                                  cnNoCollTable:
 15116                                  	;repe	cmps byte ptr es:[si],[di]
 15117                                  				;db 0F3h,26h,0A6h,0C3h
 15118 00001442 F3                      	repe	; 0F3h
 15119 00001443 26                      	es	; 26h
 15120 00001444 A6                      	cmpsb	; 0A6h
 15121 00001445 C3                      	retn	; 0C3h
 15122                                  
 15123                                  ; ---------------------------------------------------------------------------
 15124                                  
 15125                                  ;***	CmpTime - compare entries by date/time
 15126                                  ;
 15127                                  ;	ENTRY	ES:BX = ptr to one entry
 15128                                  ;		ES:BP = ptr to another entry
 15129                                  ;
 15130                                  ;	EXIT	BX = unchanged
 15131                                  ;		BP = unchanged
 15132                                  ;		Condition flags set for same, above, or below
 15133                                  ;		 comparing BX entry to BP entry.
 15134                                  ;
 15135                                  ;	USED:	CX,SI,DI
 15136                                  ;
 15137                                  ;	NOTE	Filetime and filedate fields in our private entry
 15138                                  ;		structure must be adjacent and in that order.
 15139                                  
 15140                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 15141                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15142                                  CmpTime:
 15143 00001446 89DE                    	mov	si,bx
 15144 00001448 89EF                    	mov	di,bp
 15145                                  	;add	si,filedate + size filedate - 1
 15146 0000144A 83C610                  	add	si,16 ; 15+2-1
 15147                                  	;add	di,filedate + size filedate - 1
 15148 0000144D 83C710                  	add	di,16 ; 15+2-1
 15149                                  	; 07/06/2023
 15150 00001450 BE1000                  	mov	si,16
 15151                                  CmpST2:		; 07/06/2023
 15152 00001453 89F7                    	mov	di,si	; mov di,16
 15153 00001455 01DE                    	add	si,bx
 15154 00001457 01EF                    	add	di,bp
 15155                                  
 15156                                  	;mov	cx,size filetime + size filedate
 15157 00001459 B90400                  	mov	cx,4 ; 2+2
 15158 0000145C FD                      	std
 15159                                  	;repe	cmps byte ptr es:[si],[di]
 15160                                  				;db 0F3h,26h,0A6h, 0FCh,0C3h
 15161 0000145D F3                      	repe	; 0F3h
 15162 0000145E 26                      	es	; 26h
 15163 0000145F A6                      	cmpsb	; 0A6h
 15164                                  	
 15165 00001460 FC                      	cld	; 0FCh
 15166 00001461 C3                      	retn	; 0C3h
 15167                                  
 15168                                  ; ---------------------------------------------------------------------------
 15169                                  
 15170                                  ;***	CmpSize - compare entries by size
 15171                                  ;
 15172                                  ;	ENTRY	ES:BX = ptr to one entry
 15173                                  ;		ES:BP = ptr to another entry
 15174                                  ;
 15175                                  ;	EXIT	BX = unchanged
 15176                                  ;		BP = unchanged
 15177                                  ;		Condition flags set for same, above, or below
 15178                                  ;		 comparing BX entry to BP entry.
 15179                                  ;
 15180                                  ;	USED:	CX,SI,DI
 15181                                  
 15182                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 15183                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15184                                  CmpSize:
 15185                                  	;mov	si,bx
 15186                                  	;mov	di,bp
 15187                                  	;;add	si,filesize + size filesize - 1
 15188                                  	;add	si,20  ; 17+4-1
 15189                                  	;;add	di,filesize + size filesize - 1
 15190                                  	;add	di,20  ; 17+4-1
 15191                                  	; 07/06/2023
 15192 00001462 BE1400                  	mov	si,20
 15193                                  	;;;
 15194 00001465 EBEC                    	jmp	short CmpST2 ; 07/06/2023
 15195                                  	;;;
 15196                                  ;CmpST2:
 15197                                  ;	mov	di,si	; mov di,20
 15198                                  ;	add	si,bx
 15199                                  ;	add	di,bp
 15200                                  ;
 15201                                  ;	;mov	cx,size filesize
 15202                                  ;	mov	cx,4
 15203                                  ;	std
 15204                                  ;	;repe	cmps byte ptr es:[si],[di]
 15205                                  ;				;db 0F3h,26h,0A6h
 15206                                  ;	repe	; 0F3h
 15207                                  ;	es	; 26h
 15208                                  ;	cmpsb	; 0A6h
 15209                                  ;
 15210                                  ;	cld
 15211                                  ;	retn
 15212                                  
 15213                                  ; ---------------------------------------------------------------------------
 15214                                  
 15215                                  ;***	CmpType - compare entries by file type (subdirectory or not)
 15216                                  ;
 15217                                  ;	ENTRY	ES:BX = ptr to one entry
 15218                                  ;		ES:BP = ptr to another entry
 15219                                  ;
 15220                                  ;	EXIT	BX = unchanged
 15221                                  ;		BP = unchanged
 15222                                  ;		Condition flags set for same, above, or below
 15223                                  ;		 comparing BX entry to BP entry.
 15224                                  ;
 15225                                  ;	USED:	AX
 15226                                  
 15227                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 15228                                  CmpType:
 15229                                  	;mov	al,es:[bx].fileattr
 15230 00001467 268A470C                	mov	al,[es:bx+12]
 15231                                  	;mov	ah,es:[bp].fileattr
 15232 0000146B 268A660C                	mov	ah,[es:bp+12]
 15233                                  	;and	ax,(ATTR_DIRECTORY shl 8) + ATTR_DIRECTORY
 15234                                  	;and	ax,1010h
 15235 0000146F 251010                  	and	ax,(ATTR_DIRECTORY<<8)+ATTR_DIRECTORY
 15236 00001472 38C4                    	cmp	ah,al
 15237 00001474 C3                      	retn
 15238                                  
 15239                                  ; ---------------------------------------------------------------------------
 15240                                  
 15241                                  ;***	CmpCratio - compare entries by compression ratio
 15242                                  ;
 15243                                  ;	ENTRY	ES:BX = ptr to one entry
 15244                                  ;		ES:BP = ptr to another entry
 15245                                  ;
 15246                                  ;	EXIT	BX = unchanged
 15247                                  ;		BP = unchanged
 15248                                  ;		Condition flags set for same, above, or below
 15249                                  ;		 comparing BX entry to BP entry.
 15250                                  ;
 15251                                  ;	USED:	AX
 15252                                  
 15253                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 15254                                  CmpCratio:
 15255                                  	;mov	al,es:[bx].compratio
 15256 00001475 268A4715                	mov	al,[es:bx+21]	
 15257                                  	;cmp	al,es:[bp].compratio
 15258 00001479 263A4615                	cmp     al,[es:bp+21]
 15259 0000147D C3                      	retn
 15260                                  
 15261                                  ; ---------------------------------------------------------------------------
 15262                                  
 15263                                  ;***	DefaultAttr - set default attribute conditions
 15264                                  ;
 15265                                  ;	ENTRY	nothing
 15266                                  ;
 15267                                  ;	EXIT	CY clear
 15268                                  ;
 15269                                  ;	USED
 15270                                  ;
 15271                                  ;	EFFECTS
 15272                                  ;
 15273                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 15274                                  
 15275                                  	; 16/02/2023
 15276                                  DefaultAttr:
 15277                                  	;mov	byte [AttrSpecified],6
 15278 0000147E C606[AAA0]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM
 15279                                  					; specify H and S
 15280 00001483 C606[ABA0]00            	mov	byte [AttrSelect],0	; H and S must be off
 15281 00001488 F8                      	clc				; return success
 15282                                  dtRet:	; 18/02/2023
 15283 00001489 C3                      	retn
 15284                                  
 15285                                  ; ---------------------------------------------------------------------------
 15286                                  
 15287                                  ;***	DisplayTotals - display grand total stats
 15288                                  ;
 15289                                  ;	If we searched subdirectories, display the total # files found
 15290                                  ;	 and total size of files found.
 15291                                  ;	Display disk space remaining.
 15292                                  ;
 15293                                  ;	ENTRY	FileCntTotal, FileSizTotal contain correct values
 15294                                  ;		Bits contains setting of /s
 15295                                  ;		FCB contains drive #
 15296                                  ;
 15297                                  ;	EXIT	nothing
 15298                                  ;
 15299                                  ;	USES	AX,DX
 15300                                  ;		FileSiz
 15301                                  
 15302                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15303                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:13D1h
 15304                                  
 15305                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15306                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:14F1h
 15307                                  
 15308                                  DisplayTotals:
 15309                                  	;;;test	Bits,mask subd
 15310                                  	;;test	word [_Bits],4
 15311                                  	;test	byte [_Bits],4
 15312                                  	; 07/06/2023
 15313 0000148A F606[A2A0]08            	test	byte [_Bits],mask.subd ; 8 ; MSDOS 6.0
 15314 0000148F 7432                    	jz	short dtFree		; no subdirectories- do bytes free
 15315                                  
 15316 00001491 E88D16                  	call	CRLF2			; start on new line
 15317 00001494 E82204                  	call	UseLine
 15318                                  
 15319 00001497 BA[3294]                	mov	dx,total_ptr
 15320 0000149A E89040                  	call	std_printf		; "Total:",cr,lf
 15321 0000149D E81904                  	call	UseLine
 15322                                  	;;;
 15323                                  	; 07/06/2023
 15324                                  	; MSDOS 6.22 COMMAND.COM
 15325                                  	;test	word [_Bits],1		; mask.cratio
 15326 000014A0 F606[A2A0]01            	test	byte [_Bits],mask.cratio
 15327 000014A5 740E                    	jz      short dtCntSize
 15328 000014A7 A1[559E]                	mov     ax,[ccluUsedTotal]
 15329 000014AA A3[539E]                	mov     [ccluUsedDir],ax
 15330 000014AD BE[5F9E]                	mov     si,csecUsedTotal
 15331 000014B0 BF[5B9E]                	mov     di,csecUsedDir
 15332 000014B3 A5                      	movsw
 15333 000014B4 A5                      	movsw
 15334                                  dtCntSize:    
 15335                                  	;;;
 15336 000014B5 A1[499E]                	mov	ax,[FileCntTotal]	; AX = # files found mod 64K
 15337 000014B8 BE[4D9E]                	mov	si,FileSizTotal
 15338 000014BB BF[459E]                	mov	di,FileSiz
 15339 000014BE A5                      	movsw
 15340 000014BF A5                      	movsw				; move total size to size variable
 15341 000014C0 E8FC05                  	call	DisplayCntSiz		; display file count & size &
 15342                                  dtFree: 				;   (maybe) compression ratio
 15343 000014C3 B436                    	mov	ah,36h
 15344                                  	;mov	ah,GET_DRIVE_FREESPACE	; AH = DOS Get Free Space function
 15345 000014C5 8A165C00                	mov	dl,[FCB] ; [5Ch]	; DL = drive#
 15346 000014C9 CD21                    	int	21h			; call DOS
 15347 000014CB 83F8FF                  	cmp	ax,-1			; check 'invalid drive' return code
 15348 000014CE 74B9                    	jz	short dtRet		; can't get drive space - return
 15349 000014D0 F7E1                    	mul	cx
 15350 000014D2 F7E3                    	mul	bx
 15351 000014D4 A3[C0A0]                	mov	[Bytes_Free],ax
 15352 000014D7 8916[C2A0]              	mov	[Bytes_Free+2],dx
 15353 000014DB BA[4192]                	mov	dx,bytmes_ptr
 15354 000014DE E84C40                  	call	std_printf		; "nnn bytes free",cr,lf
 15355                                  	;call	UseLine
 15356                                  ;dtRet:
 15357                                  	;retn
 15358                                  	; 18/02/2023
 15359 000014E1 E9D503                  	jmp	UseLine
 15360                                  
 15361                                  ; ---------------------------------------------------------------------------
 15362                                  
 15363                                  ;***	FileIsDevice - see if file looks like a device
 15364                                  ;
 15365                                  ;	ENTRY	PathPos = ptr to pathname
 15366                                  ;		PathCnt = length of pathname w/o terminating char
 15367                                  ;		DirBuf is DOS DTA
 15368                                  ;
 15369                                  ;	EXIT	ZR = set if file looks like a device
 15370                                  ;
 15371                                  ;	USED	AX,BX,CX,DX,DI
 15372                                  ;
 15373                                  ;	EFFECTS
 15374                                  ;
 15375                                  ;	  DTA buffer holds results of Find First function
 15376                                  ;
 15377                                  ;	NOTES
 15378                                  ;
 15379                                  ;	  We try to flag devices in two ways. First, we try
 15380                                  ;	  the DOS Find First function. It returns attribute bit 6
 15381                                  ;	  set on a successful find if it identifies a device name.
 15382                                  ;	  Unfortunately, it returns 'path not found' for a device
 15383                                  ;	  name terminated with colon, such as "CON:". So, we look
 15384                                  ;	  for any colon in the pathname after the 2nd character,
 15385                                  ;	  and flag the pathname as a device if we find one.
 15386                                  
 15387                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15388                                  FileIsDevice:
 15389 000014E4 8B16[A6A0]              	mov	dx,[PathPos]	 ; DX = ptr to pathname
 15390                                  
 15391 000014E8 89D7                    	mov	di,dx
 15392 000014EA 033E[A4A0]              	add	di,[PathCnt]	 ; DI = ptr to byte after pathname
 15393 000014EE 30DB                    	xor	bl,bl		 ; BL = NUL to terminate pathname with
 15394 000014F0 861D                    	xchg	bl,[di] 	 ; BL = saved pathname terminating char
 15395                                  
 15396 000014F2 31C9                    	xor	cx,cx		 ; CX = attribute mask (normal search)
 15397 000014F4 B44E                    	mov	ah,4Eh
 15398                                  	;mov	ah,Find_First	 ; AH = DOS Find First function code
 15399 000014F6 CD21                    	int	21h	 	 ; call DOS
 15400 000014F8 861D                    	xchg	bl,[di]		 ; restore pathname terminating char
 15401 000014FA 720A                    	jc	short piCol	 ; didn't find a dir entry, check for colon
 15402                                  
 15403                                  ;	Found a dir entry, see if Find First thinks it's a device.
 15404                                  
 15405                                  	;test	byte [DIRBUF+21],40h
 15406 000014FC F606[65A0]40            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 15407 00001501 7403                    	jz	short piCol	 ; device attribute not set, look for colon
 15408 00001503 31C9                    	xor	cx,cx		 ; it's a device, return ZR flag
 15409                                  	;jmp	short piRet
 15410                                  	; 25/04/2023
 15411                                  piRet:
 15412 00001505 C3                      	retn
 15413                                  
 15414                                  ;	Device attribute not returned by Find First function. But
 15415                                  ;	let's check for a colon anywhere in the pathname after the
 15416                                  ;	second byte.
 15417                                  ;
 15418                                  ;	DI = ptr to byte after pathname
 15419                                  
 15420                                  piCol:
 15421 00001506 4F                      	dec	di		 ; DI = ptr to last char in pathname
 15422 00001507 B03A                    	mov	al,':'
 15423                                  	;mov	al,COLON_CHAR	 ; AL = colon char to search for
 15424 00001509 8B0E[A4A0]              	mov	cx,[PathCnt]	 ; CX = # chars to scan
 15425 0000150D 49                      	dec	cx
 15426 0000150E 49                      	dec	cx		 ; ignore 1st two chars of pathname
 15427 0000150F 09C9                    	or	cx,cx
 15428 00001511 78F2                    	js	short piRet	 ; if < 2 chars in pathname, just return
 15429 00001513 09FF                    	or	di,di		 ; clear ZR in case CX = 0
 15430 00001515 FD                      	std			 ; scan downward
 15431 00001516 F2AE                    	repne	scasb
 15432 00001518 FC                      	cld			 ; restore default upward direction
 15433                                  
 15434                                  ;	After scanning, the ZR flag is set to indicate presence of a colon.
 15435                                  ;piRet:
 15436 00001519 C3                      	retn
 15437                                  
 15438                                  ;FileIsDevice endp
 15439                                  
 15440                                  ; ---------------------------------------------------------------------------
 15441                                  
 15442                                  ;***	FindFirst - find first directory entry to display
 15443                                  ;***	FindNext - find next directory entry to display
 15444                                  ;
 15445                                  ;	ENTRY	Bits<inmem> = set if entries are loaded in TPA
 15446                                  ;		AttrSpecified, AttrSelect are set
 15447                                  ;
 15448                                  ;	EXIT	CY = clear if successful
 15449                                  ;		BX = offset in TPA buffer of directory entry found
 15450                                  ;
 15451                                  ;		If unsuccessful,
 15452                                  ;		CY = set
 15453                                  ;		AX = DOS error code
 15454                                  ;		DOS Get Extended Error call will get error code
 15455                                  ;
 15456                                  ;		NOTE: if entries were loaded into TPA, AX contains
 15457                                  ;		ERROR_NO_MORE_FILES when no more entries are available,
 15458                                  ;		but DOS Get Extended Error call WON'T return the correct
 15459                                  ;		error. That's ok, because we'll see the value in AX
 15460                                  ;		and recognize it as a non-error condition.
 15461                                  ;
 15462                                  ;	USED	AX,CX,DX,SI,DI
 15463                                  ;
 15464                                  ;	EFFECTS
 15465                                  ;
 15466                                  ;	  Entries in memory may be marked as output.
 15467                                  ;	  If not sorted, entry is loaded at TPA.
 15468                                  ;
 15469                                  ;	NOTES
 15470                                  ;
 15471                                  ;	  If we don't find a qualifying file, we return after the final
 15472                                  ;	   DOS Find File call. A DOS Get Extended Error call will then
 15473                                  ;	   indicate an appropriate condition.
 15474                                  
 15475                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15476                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 15477                                  
 15478                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15479                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1585h
 15480                                  	
 15481                                  FindFirst:
 15482                                  	;mov	ax,offset TRANGROUP:GetFirst
 15483 0000151A B8[F115]                	mov	ax,GetFirst
 15484 0000151D EB03                    	jmp	short ffFindEntry
 15485                                  
 15486                                  	; 18/02/2023
 15487                                  FindNext:
 15488                                  	;mov	ax,offset TRANGROUP:GetNext
 15489 0000151F B8[FF15]                	mov	ax,GetNext
 15490                                  
 15491                                  ;	AX = address of correct disk get routine to use.
 15492                                  
 15493                                  ffFindEntry:
 15494 00001522 06                      	push	es			; save TRANGROUP seg addr
 15495                                  	;;;test	Bits,mask inmem
 15496                                  	;;test	word [_Bits],20h
 15497                                  	;test	byte [_Bits],20h
 15498                                  	; 07/06/2023
 15499 00001523 F606[A2A0]40            	test	byte [_Bits],mask.inmem ; 40h ; MSDOS 6.0
 15500 00001528 7405                    	jz	short ffDisk		; entries not in memory, search disk
 15501                                  
 15502                                  ;	Entries are loaded in memory to sort out. Find the first one.
 15503                                  ;	There will always be one, or LoadEntries would've failed.
 15504                                  
 15505 0000152A E81A00                  	call	FindInMem		; find first entry in TPA
 15506 0000152D EB16                    	jmp	short ffRet		; return what TPA search returns
 15507                                  
 15508                                  ;	Get entry from disk.
 15509                                  
 15510                                  ffDisk:
 15511 0000152F FFD0                    	call	ax			; get entry from disk
 15512 00001531 720E                    	jc	short ffGetErr		; get & return error
 15513 00001533 8E06[179E]              	mov	es,[TPA]		; ES = seg addr of TPA
 15514 00001537 31FF                    	xor	di,di			; ES:DI = ptr to TPA
 15515 00001539 89FB                    	mov	bx,di			; BX = offset of entry in TPA
 15516 0000153B E85F01                  	call	LoadEntry		; load entry to TPA
 15517 0000153E F8                      	clc				; return success
 15518 0000153F EB04                    	jmp	short ffRet
 15519                                  
 15520                                  ffGetErr:
 15521 00001541 E8FE0C                  	call	 get_ext_error_number	; AX = DOS error code
 15522 00001544 F9                      	stc
 15523                                  ffRet:
 15524 00001545 07                      	pop	es			; ES = TRANGROUP seg addr again
 15525 00001546 C3                      	retn
 15526                                  
 15527                                  ; ---------------------------------------------------------------------------
 15528                                  
 15529                                  ;***	FindInMem - find next directory entry in TPA buffer
 15530                                  ;
 15531                                  ;	ENTRY	TPA is loaded (see LoadEntries)
 15532                                  ;
 15533                                  ;	EXIT	BX = offset in TPA of entry found
 15534                                  ;
 15535                                  ;		If no more files,
 15536                                  ;		CY = set
 15537                                  ;		AX = DOS 'no more files' error code
 15538                                  ;
 15539                                  ;	USED	AX,BX,CX,DX,SI,DI,BP,ES
 15540                                  ;
 15541                                  ;	EFFECTS
 15542                                  ;
 15543                                  ;	  Entry found is flagged as 'used' (see EntryStruc).
 15544                                  
 15545                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15546                                  FindInMem:
 15547 00001547 8E06[179E]              	mov	es,[TPA]		; ES = TPA seg addr
 15548 0000154B 31DB                    	xor	bx,bx			; ES:BX = ptr to 1st entry in TPA
 15549 0000154D FC                      	cld				; make sure default string direction is up
 15550                                  	
 15551 0000154E E86D00                  	call	FindOneInMem		; locate an entry
 15552 00001551 720E                    	jc	short fiNoMore		; none left, set up 'no more files' error
 15553                                  
 15554                                  ;	BX = ptr to entry in TPA
 15555                                  
 15556                                  fiBest:
 15557 00001553 89DD                    	mov	bp,bx			; BP = ptr to best entry so far
 15558                                  fiNext:
 15559 00001555 E87300                  	call	FindNextInMem		; locate next entry
 15560 00001558 720C                    	jc	short fiFound		; no more, best entry so far wins
 15561                                  
 15562                                  ;	BX = ptr to next entry
 15563                                  
 15564 0000155A E86CFE                  	call	CmpEntry		; compare it to best found so far (BP)
 15565 0000155D 73F6                    	jnb	short fiNext		; it's not better, go look at next one
 15566 0000155F EBF2                    	jmp	short fiBest		; it's better, go mark it as best so far
 15567                                  
 15568                                  fiNoMore:
 15569                                  
 15570                                  ;	No more entries available in TPA. Set up 'no more files' error.
 15571                                  
 15572                                  	;mov	ax,18
 15573 00001561 B81200                  	mov	ax,ERROR_NO_MORE_FILES	; AX = 'no more files' error code
 15574 00001564 F9                      	stc				; return error
 15575                                  	;jmp	short fiRet
 15576                                  	; 18/02/2023
 15577 00001565 C3                      	retn
 15578                                  
 15579                                  fiFound:
 15580 00001566 89EB                    	mov	bx,bp			; BX = ptr to best entry found
 15581 00001568 26C60701                	mov	byte [es:bx],1		; mark entry 'used'
 15582 0000156C F8                      	clc				; return success
 15583                                  fiRet:
 15584 0000156D C3                      	retn
 15585                                  
 15586                                  ; ---------------------------------------------------------------------------
 15587                                  
 15588                                  ;***	FindNextChild - find next subdirectory in current directory
 15589                                  ;
 15590                                  ;	ENTRY	BX = ptr to last child found, ASCIIZ filename
 15591                                  ;		DirBuf is established DTA
 15592                                  ;
 15593                                  ;	EXIT	BX = ptr (same addr) to next child found, ASCIIZ filename
 15594                                  ;
 15595                                  ;		If failure,
 15596                                  ;		CY = set
 15597                                  ;		DOS Get Extended Error call will get error
 15598                                  ;
 15599                                  ;	USED	AX,CX,DX,SI,DI,BP
 15600                                  ;
 15601                                  ;	EFFECTS
 15602                                  ;
 15603                                  ;	  DirBuf is used for find first/next calls.
 15604                                  ;
 15605                                  ;	NOTES
 15606                                  ;
 15607                                  ;	  We keep on checking files until DOS returns an error. If
 15608                                  ;	  the error is 'no more files' and the temp filename is not
 15609                                  ;	  the initial high tag, copy the temp to the child's name spot
 15610                                  ;	  and return success. Otherwise, send the error back to caller.
 15611                                  ;
 15612                                  ;	  This routine depends on DS,ES,CS, & SS all being equal.
 15613                                  
 15614                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15615                                  FindNextChild:
 15616 0000156E 83EC0C                  	sub	sp,12			; make temp filename buf on stack
 15617                                  	;shove	00FFh			; temp filename = high tag
 15618 00001571 B8FF00                  	mov	ax,0FFh
 15619 00001574 50                      	push	ax
 15620 00001575 89E5                    	mov	bp,sp			; BP = ptr to temp filename buf
 15621                                  	;shove	"*"	
 15622 00001577 B02A                    	mov	al,'*'  ; ax = 002Ah
 15623 00001579 50                      	push	ax
 15624                                  	;;shove	".*" 
 15625                                  	;mov	ax,"*."
 15626                                  	;mov	ax,2E2Ah
 15627 0000157A B42E                    	mov	ah,'.'
 15628 0000157C 50                      	push	ax
 15629 0000157D E87D05                  	call	GetDriveLtr		; AX = "d:"
 15630 00001580 50                      	push	ax
 15631 00001581 89E2                    	mov	dx,sp			; DX = ptr to "d:*.*",0 on stack
 15632                                  
 15633                                  ;	See that the stack is restored properly at the end of this proc.
 15634                                  
 15635                                  	;mov	cx,10h
 15636 00001583 B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15637 00001586 B44E                    	mov	ah,4Eh
 15638                                  	;mov	ah,Find_First
 15639 00001588 CD21                    	int	21h			; DOS- Find First matching file
 15640 0000158A 722C                    	jc	short fcRet		; return error
 15641                                  
 15642 0000158C E815FE                  	call	CheckChild		; check child against last, temp
 15643                                  fcNext:	
 15644                                  	;mov	cx,10h
 15645 0000158F B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15646 00001592 B44F                    	mov	ah,4Fh
 15647                                  	;mov	ah,Find_Next
 15648 00001594 CD21                    	int	21h			; DOS- Find Next matching file
 15649 00001596 7205                    	jc	short fcErr		; examine error
 15650                                  
 15651 00001598 E809FE                  	call	CheckChild		; check child against last, temp
 15652 0000159B EBF2                    	jmp	short fcNext		; go find another child
 15653                                  
 15654                                  fcErr:
 15655 0000159D E8A20C                  	call	get_ext_error_number	; AX = extended error code
 15656                                  	;cmp	ax,18
 15657 000015A0 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	; no more files?
 15658 000015A3 7512                    	jne	short fcNope		; some other error- return it
 15659                                  
 15660                                  ;	We ran out of files. See if we qualified at least one.
 15661                                  
 15662 000015A5 807E00FF                	cmp	byte [bp],0FFh
 15663 000015A9 740C                    	je	short fcNope		; temp filename is unused- no child
 15664                                  
 15665                                  ;	Move temp filename to child name position.
 15666                                  
 15667 000015AB 89EE                    	mov	si,bp			; SI = ptr to temp filename
 15668 000015AD 89DF                    	mov	di,bx			; DI = ptr to child name pos'n
 15669                                  fcMove:
 15670 000015AF AC                      	lodsb				; AL = next byte of filename
 15671 000015B0 AA                      	stosb				; store byte
 15672 000015B1 08C0                    	or	al,al
 15673 000015B3 7403                    	jz	short fcRet		; byte was zero, return success (CY clear)
 15674 000015B5 EBF8                    	jmp	short fcMove		; go move another byte
 15675                                  fcNope:
 15676 000015B7 F9                      	stc				; return error
 15677                                  fcRet:
 15678 000015B8 9F                      	lahf
 15679 000015B9 83C414                  	add	sp,20			; restore stack
 15680 000015BC 9E                      	sahf
 15681 000015BD C3                      	retn
 15682                                  
 15683                                  ; ---------------------------------------------------------------------------
 15684                                  
 15685                                  ;***	FindOneInMem - find the first available entry in TPA
 15686                                  ;***	FindNextInMem - find the next available entry in TPA
 15687                                  ;
 15688                                  ;	ENTRY	ES = TPA seg addr
 15689                                  ;		BX = ptr to entry in TPA
 15690                                  ;
 15691                                  ;	EXIT	BX = ptr to entry found
 15692                                  ;		CY = set if no more entries available in TPA
 15693                                  ;
 15694                                  ;	USED	AL
 15695                                  
 15696                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15697                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15698                                  FindOneInMem:
 15699 000015BE 268A07                  	mov	al,[es:bx]		; examine 'used' byte of starting entry
 15700 000015C1 3C01                    	cmp	al,1
 15701 000015C3 7406                    	je	short FindNextInMem	; entry has already been used
 15702 000015C5 3CFF                    	cmp	al,0FFh
 15703 000015C7 7407                    	je	short foNoMore		; 0FFh, we're at the end of the list
 15704                                  
 15705                                  ;	BX = ptr to entry that hasn't been output yet.
 15706                                  
 15707 000015C9 F8                      	clc				; return success
 15708 000015CA C3                      	retn
 15709                                  
 15710                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15711                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:163Ah
 15712                                  FindNextInMem:
 15713                                  	; 07/06/2023
 15714                                  	;add	bx,21 ; MSDOS 5.0
 15715                                  	; 07/06/2023
 15716 000015CB 83C316                  	add	bx,22 ; MSDOS 6.0  ; size EntryStruc (22 = 21 + compratio)
 15717                                  	;add	bx,size EntryStruc	; BX = ptr to next entry
 15718 000015CE EBEE                    	jmp	short FindOneInMem	; go look at it
 15719                                  foNoMore:
 15720 000015D0 F9                      	stc				; ran out of entries, return failure
 15721 000015D1 C3                      	retn
 15722                                  
 15723                                  ; ---------------------------------------------------------------------------
 15724                                  
 15725                                  ;***	GetEnvValue - get value of our environment variable
 15726                                  ;
 15727                                  ;	ENTRY	DS, ES = TRANGROUP seg addr
 15728                                  ;
 15729                                  ;	EXIT	CY = set if environment variable not in environment
 15730                                  ;
 15731                                  ;		Otherwise:
 15732                                  ;		SI = ptr to environment variable asciiz value in TRANGROUP
 15733                                  ;
 15734                                  ;	USED	AX,BX,CX,DX,DI
 15735                                  ;		(We assume the (almost) worst, since we don't know about
 15736                                  ;		Find_Name_In_Environment.)
 15737                                  ;
 15738                                  ;	EFFECTS
 15739                                  ;
 15740                                  ;	  ScanBuf is loaded with value text
 15741                                  
 15742                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15743                                  GetEnvValue:
 15744 000015D2 06                      	push	es				; save ES
 15745                                  	;mov	si,offset TRANGROUP:DirEnvVar	; DS:SI = ptr to variable name
 15746 000015D3 BE[BE94]                	mov	si,DirEnvVar	; "DIRCMD="
 15747                                  	;invoke	Find_Name_In_Environment
 15748 000015D6 E88C12                  	call	find_name_in_environment
 15749 000015D9 7214                    	jc	short geRet			; name not found in environment
 15750                                  
 15751                                  ;	ES:DI = ptr to value of environment variable
 15752                                  ;	We're assuming DS, CS, and SS are unchanged.
 15753                                  
 15754 000015DB 1E                      	push	ds
 15755 000015DC 06                      	push	es
 15756 000015DD 1F                      	pop	ds
 15757 000015DE 07                      	pop	es
 15758                                  
 15759                                  	;assume	ds:nothing
 15760                                  
 15761                                  ;	DS = seg addr of environment variable value (in environment segment)
 15762                                  ;	ES = TRANGROUP seg addr
 15763                                  
 15764 000015DF 89FE                    	mov	si,di				; DS:SI = ptr to value string
 15765                                  	;mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to dest buffer
 15766 000015E1 BF[92A1]                	mov	di,ScanBuf
 15767                                  geLoop:
 15768                                  ;@@:	
 15769 000015E4 AC                      	lodsb
 15770 000015E5 08C0                    	or	al,al
 15771 000015E7 AA                      	stosb
 15772                                  	;loopnz	@B		; move the string, including trailing null
 15773 000015E8 E0FA                    	loopnz	geLoop
 15774                                  
 15775 000015EA 06                      	push	es
 15776 000015EB 1F                      	pop	ds		; DS = TRANGROUP seg addr again
 15777                                  	;assume	ds:TRANGROUP
 15778                                  
 15779                                  	;mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to var value
 15780 000015EC BE[92A1]                	mov	si,ScanBuf
 15781                                  geRet:
 15782 000015EF 07                      	pop	es				; restore ES
 15783 000015F0 C3                      	retn
 15784                                  
 15785                                  ; ---------------------------------------------------------------------------
 15786                                  
 15787                                  ;***	GetFirst - get first directory entry from disk
 15788                                  ;
 15789                                  ;	ENTRY	DOS DTA established at DirBuf
 15790                                  ;		FCB contains drive # and filename
 15791                                  ;		Current directory (on selected drive) is the one to search
 15792                                  ;		AttrSpecified & AttrSelect masks set
 15793                                  ;
 15794                                  ;	EXIT	CY = clear if success
 15795                                  ;		DirBuf contains extended FCB for file found
 15796                                  ;
 15797                                  ;		If unsuccessful,
 15798                                  ;		CY = set
 15799                                  ;		Ready for DOS Get Extended Error call
 15800                                  ;
 15801                                  ;	USED	AX,DX
 15802                                  ;
 15803                                  ;	EFFECTS
 15804                                  ;
 15805                                  ;	  FCB-7 = 0FFh to mark extended FCB
 15806                                  ;	  FCB-1 = attribute mask to find all files
 15807                                  ;	  These fields should remain unmodified for GetNext calls.
 15808                                  ;
 15809                                  ;***	GetNext - get next directory entry from disk
 15810                                  ;
 15811                                  ;	ENTRY	As for GetFirst, plus
 15812                                  ;		FCB-7 set up as extended FCB w/ find-all attribute byte
 15813                                  ;
 15814                                  ;	EXIT	As for GetFirst
 15815                                  ;
 15816                                  ;	USED	AX,DX
 15817                                  
 15818                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15819                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 15820                                  
 15821                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15822                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1660h
 15823                                  GetFirst:
 15824                                  	;mov	byte [55h],0FFh	; -1
 15825 000015F1 C6065500FF              	mov	byte [FCB-7],0FFh	; signal extended FCB
 15826                                  	;mov	byte [5Bh],16h
 15827 000015F6 C6065B0016              	mov	byte [FCB-1],ATTR_ALL ; 16h
 15828                                  					; find any file
 15829                                  	; 07/06/2023
 15830                                  	;mov	dx,FCB-7 ; 55h		; DX = ptr to extended FCB
 15831 000015FB B411                    	mov	ah,11h
 15832                                  	;mov	ah,Dir_Search_First	; AH = DOS Find First function code
 15833                                  	; 07/06/2023
 15834                                  	;int	21h			; call DOS
 15835                                  	;shl	al,1			; CY = set if error
 15836                                  	;jc	short gfRet		; return error
 15837                                  	;jmp	short gfFound		; go look at attr's
 15838                                  	; 07/06/2023
 15839 000015FD EB02                    	jmp	short GetFrstNxt
 15840                                  GetNext:
 15841                                  	; 07/06/2023
 15842                                  	;;mov	dx,55h
 15843                                  	;mov	dx,FCB-7		; DX = ptr to extended FCB
 15844 000015FF B412                    	mov	ah,12h
 15845                                  	;mov	ah,Dir_Search_Next	; AH = DOS Find Next function code
 15846                                  GetFrstNxt:
 15847                                  	; 07/06/2023
 15848 00001601 BA5500                  	mov	dx,FCB-7 ; mov dx,55h
 15849                                  	;
 15850 00001604 CD21                    	int	21h			; call DOS
 15851 00001606 D0E0                    	shl	al,1			; CY = set if error
 15852 00001608 7211                    	jc	short gfRet		; return error
 15853                                  
 15854                                  ;*	Found an entry. Check attributes.
 15855                                  gfFound:
 15856                                  	;;mov	al,[DirBuf+8].dir_attr	; AL = file attributes
 15857                                  	;mov	al,[DIRBUF+19]
 15858 0000160A A0[63A0]                	mov	al,[DIRBUF+8+DIR_ENTRY.DIR_ATTR]
 15859 0000160D 8A26[AAA0]              	mov	ah,[AttrSpecified]	; AH = mask of pertinent attr's
 15860 00001611 20E0                    	and	al,ah			; AL = pertinent attr's of file
 15861 00001613 2226[ABA0]              	and	ah,[AttrSelect]		; AH = attr settings to match
 15862 00001617 38E0                    	cmp	al,ah
 15863 00001619 75E4                    	jne	short GetNext		; attr's don't match, look for another
 15864                                  gfRet:
 15865 0000161B C3                      	retn
 15866                                  
 15867                                  ; ---------------------------------------------------------------------------
 15868                                  
 15869                                  ;***	ListDir - search for and list files in the current directory
 15870                                  ;
 15871                                  ;	List header, files, and trailer for current directory on selected
 15872                                  ;	drive. Header & trailer are listed if at least one file is found.
 15873                                  ;	If no qualifying files are found, no display output occurs.
 15874                                  ;
 15875                                  ;	ENTRY	Current directory (on selected drive) is the one to be listed
 15876                                  ;		FCB contains selected drive # and filename spec
 15877                                  ;		Option bits, attribute masks, and sort codes set up
 15878                                  ;
 15879                                  ;	EXIT	CY = clear if no error
 15880                                  ;		FileCnt = # files found & displayed
 15881                                  ;
 15882                                  ;		If error,
 15883                                  ;		CY = set
 15884                                  ;		Ready for DOS Get Extended Error call
 15885                                  ;
 15886                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 15887                                  ;		FileSiz
 15888                                  ;
 15889                                  ;	EFFECTS
 15890                                  ;
 15891                                  ;	  FileCntTotal, FileSizTotal are updated.
 15892                                  ;	  Files found are listed. A directory header and trailer are
 15893                                  ;	   displayed only if files are found.
 15894                                  
 15895                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15896                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:155Eh
 15897                                  
 15898                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 15899                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1694h
 15900                                  ListDir:
 15901 0000161C 31C0                    	xor	ax,ax ; 0
 15902 0000161E A3[439E]                	mov	[FileCnt],ax		; zero file count
 15903 00001621 A3[459E]                	mov	[FileSiz],ax		; zero file size accumulator
 15904 00001624 A3[479E]                	mov	[FileSiz+2],ax
 15905                                  
 15906                                  	; 08/06/2023
 15907                                  	; MSDOS 6.0
 15908                                  ;ifdef DBLSPACE_HOOKS
 15909 00001627 A3[539E]                	mov	[ccluUsedDir],ax 	; zero count clusters used
 15910 0000162A A3[5B9E]                	mov	[csecUsedDir],ax	; zero count compressed sectors used
 15911 0000162D A3[5D9E]                	mov	[csecUsedDir+2],ax
 15912                                  ;endif	
 15913                                  	;cmp	byte [DestBuf],0	; check for sort code
 15914                                  	; 31/07/2024
 15915 00001630 3806[D5A0]              	cmp	[DestBuf],al ; 0
 15916 00001634 740A                    	je	short ld1		; no sort
 15917 00001636 E83000                  	call	LoadEntries		; load entries for sorted listing
 15918 00001639 7305                    	jnc	short ld1		; no error - continue
 15919 0000163B E8040C                  	call	get_ext_error_number	; AX = DOS error code
 15920                                  	; 19/02/2023
 15921                                  	;stc
 15922 0000163E EB12                    	jmp	short ldErr		; return error
 15923                                  ld1:
 15924 00001640 E8D7FE                  	call	FindFirst		; find first file
 15925 00001643 720D                    	jc	short ldErr		; not found, return error
 15926                                  
 15927                                  ;	BX = offset in TPA buffer of entry found
 15928                                  
 15929 00001645 E82B03                  	call	DisplayHeader		; if at least one file, display header
 15930                                  ldNext:
 15931 00001648 E8F902                  	call	DisplayFile		; display the file entry
 15932                                  ;ldNext:
 15933 0000164B E8D1FE                  	call	FindNext		; find another file
 15934 0000164E 7202                    	jc	short ldErr		; not found
 15935                                  	;call	DisplayFile		; display entry
 15936                                  	;jmp	short ldNext		; go find another one
 15937                                  	; 19/02/2023
 15938 00001650 EBF6                    	jmp	short ldNext
 15939                                  ldErr:
 15940                                  	;cmp	ax,2
 15941 00001652 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 15942 00001655 7407                    	je	short ldDone		; file not found, we're done
 15943                                  	;cmp	ax,18
 15944 00001657 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 15945 0000165A 7402                    	je	short ldDone		; no more files, we're done
 15946 0000165C F9                      	stc
 15947                                  	;jmp	short ldRet
 15948                                  	; 19/02/2023
 15949 0000165D C3                      	retn
 15950                                  ldDone:
 15951 0000165E 833E[439E]00            	cmp	word [FileCnt],0
 15952                                  	;je	short ld2		; no files found, just return
 15953                                  	; 25/04/2023
 15954 00001663 7403                    	jz	short ldRet
 15955 00001665 E84704                  	call	DisplayTrailer		; display trailing info
 15956                                  	; 08/06/2023
 15957                                  	; cf=0
 15958                                  ;ld2:	
 15959                                  	;clc				; return success
 15960                                  ldRet:
 15961 00001668 C3                      	retn
 15962                                  
 15963                                  ; ---------------------------------------------------------------------------
 15964                                  
 15965                                  ;***	LoadEntries - attempt to load entries from current directory
 15966                                  ;
 15967                                  ;	Load all qualifying directory entries from the current directory
 15968                                  ;	into the TPA. If an error is returned by FindFirst/FindNext calls
 15969                                  ;	other than 'no more files', return to caller with carry flag set.
 15970                                  ;	If we run out of buffer space, display a message that we haven't
 15971                                  ;	enough memory to sort this directory, but return without error.
 15972                                  ;	Other routines know whether or not entries have been loaded by
 15973                                  ;	the 'inmem' flag bit, which we set here.
 15974                                  ;
 15975                                  ;	The TPA is usually 64K - 512 bytes long. At 20 bytes per entry,
 15976                                  ;	this allows sorting over 3000 entries in a directory.
 15977                                  ;
 15978                                  ;	ENTRY	Tpa = buffer seg addr
 15979                                  ;		BytCnt = buffer length, in bytes
 15980                                  ;		Current directory (on selected drive) is the one to load
 15981                                  ;		FCB contains drive # and filespec
 15982                                  ;		Bits, AttrSpecified, AttrSelect, & DestBuf (sort codes) are set
 15983                                  ;
 15984                                  ;	EXIT	CY = set if error
 15985                                  ;		If error, DOS Get Extended Error will get error info
 15986                                  ;
 15987                                  ;	USED	AX,CX,DX,SI,DI
 15988                                  ;
 15989                                  ;	EFFECTS
 15990                                  ;
 15991                                  ;	  Inmem bit of Bits = set if load succeeded.
 15992                                  ;	  Tpa buffer contains directory entries.
 15993                                  ;	  Byte after last entry = 0FFh.
 15994                                  
 15995                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15996                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 15997                                  LoadEntries:
 15998 00001669 06                      	push	es			; save TRANGROUP seg addr
 15999 0000166A 8E06[179E]              	mov	es,[TPA]		; ES = TPA seg addr
 16000 0000166E 31FF                    	xor	di,di			; ES:DI = destination ptr
 16001                                  	;;;and	Bits,not mask inmem	; signal entries not loaded
 16002                                  	; MSDOS 5.0
 16003                                  	;;and	word [_Bits],0FFDFh
 16004                                  	;and	byte [_Bits],0DFh	; not 20h
 16005                                  	; 08/06/2023
 16006                                  	;and	byte [_Bits],0BFh	; ~20h ; MSDOS 6.0
 16007 00001670 8026[A2A0]BF            	and	byte [_Bits],~mask.inmem ; 0BFh ; MSDOS 6.0
 16008                                  
 16009 00001675 E879FF                  	call	GetFirst		; look for first file
 16010 00001678 7221                    	jc	short leRet		; return any error
 16011 0000167A E82000                  	call	LoadEntry		; load entry into TPA
 16012                                  leNext:
 16013 0000167D E87FFF                  	call	GetNext			; get another file
 16014 00001680 720F                    	jc	short leLoaded		; assume any error is no more files
 16015 00001682 A1[369E]                	mov	ax,[BYTCNT]		; AX = size of TPA
 16016 00001685 29F8                    	sub	ax,di			; AX = bytes left in TPA
 16017                                  	; 08/06/2023
 16018                                  	;;cmp	ax,size EntryStruc+2	; insist on entry size + 2 bytes
 16019                                  	;cmp	ax,23 ; 21+2 ; MSDOS 5.0
 16020 00001687 83F818                  	cmp	ax,24 ; 22+2 ; MSDOS 6.0
 16021 0000168A 720E                    	jb	short leOk		; not enough memory left, give up
 16022 0000168C E80E00                  	call	LoadEntry		; load entry into TPA
 16023 0000168F EBEC                    	jmp	short leNext		; go get another file
 16024                                  
 16025                                  leLoaded:
 16026 00001691 26C605FF                	mov	byte [es:di],0FFh	; mark end of entry list
 16027                                  	;;;or	Bits,mask inmem		; signal entries loaded in memory
 16028                                  	; MSDOS 5.0
 16029                                  	;;or	word [_Bits],20h
 16030                                  	;or	byte [_Bits],20h
 16031                                  	; 08/06/2023
 16032                                  	;or	byte [_Bits],40h	; MSDOS 6.0
 16033 00001695 800E[A2A0]40            	or	byte [_Bits],mask.inmem ; 40h ; MSDOS 6.0 
 16034                                  	; 25/04/2023
 16035                                  	; cf = 0
 16036                                  leOk:
 16037 0000169A F8                      	clc				; return no error
 16038                                  leRet:
 16039 0000169B 07                      	pop	es			; ES = TRANGROUP seg addr again
 16040 0000169C C3                      	retn
 16041                                  
 16042                                  ; ---------------------------------------------------------------------------
 16043                                  
 16044                                  ;***	LoadEntry - load directory entry from DirBuf ext'd FCB
 16045                                  ;
 16046                                  ;	ENTRY	ES:DI = ptr to load point in TPA
 16047                                  ;		DirBuf contains extended FCB of entry to load
 16048                                  ;
 16049                                  ;	EXIT	ES:DI = ptr to next byte available in TPA
 16050                                  ;
 16051                                  ;	USED	AX,CX,SI
 16052                                  ;
 16053                                  ;	NOTES
 16054                                  ;
 16055                                  ;	  I could've used symbolic offsets and sizes of fields from
 16056                                  ;	   the dir_entry struc to do this, but this is time-critical,
 16057                                  ;	   so I hard-wired the structure of the DOS 4.x returned FCB,
 16058                                  ;	   as well as our private directory entry structure.
 16059                                  ;
 16060                                  ;	  We force a zero size for subdirectory files. A zero size is
 16061                                  ;	   ordinarily returned for subdirectories, but with Novell
 16062                                  ;	   Netware 286 or 386 loaded, we can't depend on it. Bug #1594.
 16063                                  
 16064                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16065                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:15DDh
 16066                                  	
 16067                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 16068                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:171Ch
 16069                                  LoadEntry:
 16070                                  	;mov	si,offset TRANGROUP:Dirbuf+8	; DS:SI = ptr to filename
 16071 0000169D BE[58A0]                	mov	si,DIRBUF+8
 16072 000016A0 30C0                    	xor	al,al				; AL = 0
 16073 000016A2 AA                      	stosb					; 'used' byte = false
 16074 000016A3 B90B00                  	mov	cx,11
 16075 000016A6 F3A4                    	rep	movsb				; transfer filename & extension
 16076 000016A8 AC                      	lodsb					; AL = attrib byte
 16077 000016A9 AA                      	stosb					; store attrib byte
 16078                                  	;add	si,10 ; 22-11-1
 16079                                  	;add	si,dir_time-dir_attr-1		; skip to time field
 16080 000016AA 83C60A                  	add	si,(DIR_ENTRY.DIR_TIME-DIR_ENTRY.DIR_ATTR)-1
 16081 000016AD A5                      	movsw					; transfer time
 16082 000016AE A5                      	movsw					; transfer date
 16083                                  
 16084                                  ; 08/06/2023
 16085                                  ; MSDOS 5.0
 16086                                  %if 0
 16087                                  	inc	si				; skip alloc unit
 16088                                  	inc	si
 16089                                  	;and	al,10h
 16090                                  	and	al,ATTR_DIRECTORY
 16091                                  	jnz	short leSetDirSize		; force zero size for subdir
 16092                                  	movsw
 16093                                  	movsw					; transfer size
 16094                                  	retn
 16095                                  leSetDirSize:
 16096                                  	xor	ax,ax ; 0
 16097                                  	stosw
 16098                                  	stosw					; store zero size
 16099                                  	retn
 16100                                  %endif
 16101                                  
 16102                                  ; 08/06/2023
 16103                                  ; MSDOS 6.0
 16104                                  %if 1
 16105                                  ;ifdef DBLSPACE_HOOKS
 16106 000016AF 88C1                    	mov	cl,al				; attrib to cl
 16107 000016B1 AD                      	lodsw					; allocation unit (cluster
 16108                                  	;and	cl,10h
 16109 000016B2 80E110                  	and	cl,ATTR_DIRECTORY
 16110 000016B5 751E                    	jnz	short leSetDirSize		; force zero size for subdir
 16111 000016B7 A5                      	movsw
 16112 000016B8 A5                      	movsw					; transfer size
 16113                                  	
 16114                                  	;;test	word [_Bits],1
 16115                                  	;test	word [_Bits],mask.cratio	; compression ratio report?
 16116 000016B9 F606[A2A0]01            	test	byte [_Bits],mask.cratio
 16117 000016BE 7504                    	jnz	short leCalcRatio		; yup
 16118                                  
 16119 000016C0 31C0                    	xor	ax,ax
 16120 000016C2 AA                      	stosb					; dummy compression ratio
 16121 000016C3 C3                      	retn
 16122                                  leCalcRatio:
 16123 000016C4 E83106                  	call	CalcCompRatio			; takes cluster in AX
 16124 000016C7 09C0                    	or	ax,ax				;   returns ratio in AX
 16125 000016C9 740E                    	jz	short leNoRatio			; 0 means couldn't calculate
 16126 000016CB FECC                    	dec	ah				; pack 1.0 - 16.0 comp ratio
 16127 000016CD B104                    	mov	cl,4				;   into 2 nibbles.  Store
 16128 000016CF D2E4                    	shl	ah,cl				;   1-16 as 0-15 in hi nibble,
 16129 000016D1 08E0                    	or	al,ah				;   tenths (0-9) in low nibble
 16130 000016D3 AA                      	stosb
 16131 000016D4 C3                      	retn
 16132                                  leSetDirSize:
 16133 000016D5 31C0                    	xor	ax,ax ; 0
 16134 000016D7 AB                      	stosw
 16135 000016D8 AB                      	stosw					; store zero size
 16136                                  leNoRatio:
 16137 000016D9 FEC8                    	dec	al				; al = FFh = special invalid
 16138 000016DB AA                      	stosb					; compression ratio
 16139 000016DC C3                      	retn
 16140                                  ;endif
 16141                                  %endif
 16142                                  
 16143                                  ; ---------------------------------------------------------------------------
 16144                                  
 16145                                  ;***	NoOrder - turn sorting off
 16146                                  ;
 16147                                  ;	ENTRY	nothing
 16148                                  ;
 16149                                  ;	EXIT	CY clear
 16150                                  ;
 16151                                  ;	USED	AX
 16152                                  ;
 16153                                  ;	EFFECTS
 16154                                  ;
 16155                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 16156                                  
 16157                                  	; 19/02/2023
 16158                                  NoOrder:
 16159 000016DD C606[D5A0]00            	mov	byte [DestBuf],0
 16160                                  				; no sort
 16161 000016E2 F8                      	clc			; no error
 16162 000016E3 C3                      	retn
 16163                                  
 16164                                  ; ---------------------------------------------------------------------------
 16165                                  
 16166                                  ;***	OnOffSw - record occurence of on/off option switch
 16167                                  ;
 16168                                  ;	ENTRY	DI = index into word list of switches
 16169                                  ;
 16170                                  ;	EXIT	CY clear
 16171                                  ;
 16172                                  ;	USED	AX,CX
 16173                                  ;
 16174                                  ;	EFFECTS
 16175                                  ;
 16176                                  ;	  Bits modified to indicate option state.
 16177                                  
 16178                                  	; 19/02/2023
 16179                                  OnOffSw:
 16180 000016E4 89F9                    	mov	cx,di		; CX = index into word list of options
 16181 000016E6 D1E9                    	shr	cx,1
 16182 000016E8 D1E9                    	shr	cx,1		; CX = bit position of option
 16183 000016EA B80100                  	mov	ax,1		
 16184 000016ED D3E0                    	shl	ax,cl		; AX = bit mask of option
 16185 000016EF F7C70200                	test	di,2		; check if it is a negated option
 16186 000016F3 7405                    	jz	short oo1	; it's negated
 16187                                  	;or	Bits,ax		; turn option on
 16188 000016F5 0906[A2A0]              	or	[_Bits],ax
 16189                                  	;jmp	short ooRet
 16190                                  	; 19/02/2023
 16191                                  	;cf=0
 16192 000016F9 C3                      	retn
 16193                                  oo1:	
 16194 000016FA F7D0                    	not	ax		; AX = complemented bit mask of option
 16195                                  	;and	Bits,ax		; turn option off
 16196 000016FC 2106[A2A0]              	and	[_Bits],ax
 16197                                  ooRet:
 16198                                  	; 19/02/2023
 16199                                  	;cf=0
 16200                                  	;clc			; always return success
 16201 00001700 C3                      	retn
 16202                                  
 16203                                  ; ---------------------------------------------------------------------------
 16204                                  
 16205                                  ;***	ParseAttr - parse and record /A option
 16206                                  ;
 16207                                  ;	ENTRY	BX = ptr to system parser result buffer for /A occurence
 16208                                  ;
 16209                                  ;	EXIT	CY = set if error occurs parsing attribute conditions
 16210                                  ;
 16211                                  ;		For parse error, we set up for Std_EPrintf call:
 16212                                  ;		AX = parse error code, like system parser
 16213                                  ;		DX = ptr to message block
 16214                                  ;
 16215                                  ;	USED	AX,CX,DX,DI
 16216                                  ;
 16217                                  ;	EFFECTS
 16218                                  ;
 16219                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 16220                                  ;	  If parse error occurs, attribute conditions parsed so far hold.
 16221                                  ;
 16222                                  ;	  For parse error, we set up for Std_EPrintf call:
 16223                                  ;	  Msg_Disp_Class = parse error message class
 16224                                  ;	  Message block (see DX) is set up for parse error message
 16225                                  
 16226                                  	; 19/02/2023
 16227                                  ParseAttr:
 16228 00001701 56                      	push	si			; save SI
 16229 00001702 C606[AAA0]00            	mov	byte [AttrSpecified],0	; cancel all attribute conditions
 16230                                  
 16231                                  ;	Each /A invocation starts by assuming all files are to be listed.
 16232                                  
 16233                                  	;;mov	si,word ptr [bx].ValuePtr
 16234                                  					; SI = ptr to string after /A
 16235                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 16236 00001707 8B7704                  	mov	si,[bx+4]
 16237                                  paLoop:	
 16238 0000170A BA0100                  	mov	dx,1			; DX = 1 (for un-negated attribute)
 16239 0000170D AC                      	lodsb				; AL = next char in string
 16240 0000170E 08C0                    	or	al,al
 16241                                  	;jz	short paOk		; it's terminating null, we're done
 16242                                  	; 19/02/2023
 16243 00001710 742F                    	jz	short paRet ; cf=0
 16244 00001712 3C2D                    	cmp	al,'-'
 16245 00001714 7502                    	jne	short pa1		; not '-', go look for letter
 16246 00001716 4A                      	dec	dx			; DX = 0 (for negated attribute)
 16247 00001717 AC                      	lodsb				; AL = next char
 16248                                  pa1:	
 16249                                  	;mov	di,offset TRANGROUP:AttrLtrs 
 16250                                  					; DI = ptr to attrib letter list
 16251 00001718 BF[8A97]                	mov	di,AttrLtrs ; "RHSvDA"
 16252                                  	;mov	cx,6
 16253 0000171B B90600                  	mov	cx,NUM_ATTR_LTRS ; 6	; CX = length of attrib letter list
 16254 0000171E F2AE                    	repne	scasb			; look for our letter in the list
 16255 00001720 751B                    	jne	short paErr		; not found, return error
 16256                                  
 16257 00001722 F7D1                    	not	cx
 16258                                  	;add	cx,6
 16259 00001724 83C106                  	add	cx,NUM_ATTR_LTRS	; CX = attrib bit #, 0-5
 16260                                  
 16261                                  ;	Note that we rely on AttrLtrs to be in the attribute bit order,
 16262                                  ;	starting from bit 0.
 16263                                  
 16264                                  ;	Record this attribute bit in AttrSpecified.
 16265                                  
 16266 00001727 B001                    	mov	al,1
 16267 00001729 D2E0                    	shl	al,cl			; AL = mask for our bit
 16268 0000172B 0806[AAA0]              	or	[AttrSpecified],al	; set it in the 'specified' mask
 16269                                  
 16270                                  ;	Record the selected state for this attribute in AttrSelect.
 16271                                  ;	DX = 0 or 1, the selected state for this attribute.
 16272                                  
 16273 0000172F F6D0                    	not	al			; AL = mask for all other bits
 16274 00001731 2006[ABA0]              	and	[AttrSelect],al		; clear our bit
 16275 00001735 D2E2                    	shl	dl,cl			; DL = our bit state in position
 16276 00001737 0816[ABA0]              	or	[AttrSelect],dl		; set selected attr state
 16277 0000173B EBCD                    	jmp	short paLoop		; go look at next char
 16278                                  
 16279                                  ;	The attribute letter string is invalid.
 16280                                  
 16281                                  paErr:	
 16282 0000173D E8CE03                  	call	SetupParamError		; set message up for Std_EPrintf
 16283 00001740 F9                      	stc		   		; return error
 16284                                  	; 19/02/2023
 16285                                  	;jmp	short paRet
 16286                                  ;paOk:
 16287                                  	;clc				; return success		
 16288                                  paRet:	
 16289 00001741 5E                      	pop	si			; restore SI
 16290 00001742 C3                      	retn
 16291                                  
 16292                                  ; ---------------------------------------------------------------------------
 16293                                  
 16294                                  ;***	ParseLine - parse a line of text
 16295                                  ;
 16296                                  ;	Parse text until an EOL (CR or NUL) is found, or until a parse
 16297                                  ;	error occurs.
 16298                                  ;
 16299                                  ;	ENTRY	DS:SI = ptr to text
 16300                                  ;		CS, DS, ES = TRANGROUP seg addr
 16301                                  ;
 16302                                  ;	EXIT	AX = last return code from system parser
 16303                                  ;		CX = # positional parameters (pathnames) found - 0 or 1
 16304                                  ;
 16305                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 16306                                  ;		DX = ptr to message block
 16307                                  ;
 16308                                  ;	USED	BX,CX,DX,SI,DI
 16309                                  ;
 16310                                  ;	EFFECTS
 16311                                  ;
 16312                                  ;	  Bits may contain new option settings.
 16313                                  ;	  DestBuf may contain new series of sort codes.
 16314                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 16315                                  ;	  SrcBuf may contain a new default pathname/filespec.
 16316                                  ;	  PathPos, PathCnt updated for new pathname.
 16317                                  ;
 16318                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 16319                                  ;	  Msg_Disp_Class = parse error class
 16320                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 16321                                  ;	  Message block (see DX) is set up for parse error message
 16322                                  
 16323                                  	; 19/02/2023
 16324                                  Parse_Line:
 16325                                  	; 04/05/2023
 16326 00001743 BF[5898]                	mov	di,PARSE_DIR		; ES:DI = ptr to parse block
 16327 00001746 31C9                    	xor	cx,cx			; CX = # positionals found
 16328                                  plPars:
 16329 00001748 E8BE0F                  	call	Parse_With_Msg		; call parser
 16330 0000174B 83F8FF                  	cmp	ax,-1
 16331                                  	;cmp	ax,END_OF_LINE ; 0FFFFh ; -1
 16332 0000174E 7411                    	je	short plRet		; EOL encountered, return
 16333 00001750 83F800                  	cmp	ax,RESULT_NO_ERROR ; 0
 16334 00001753 750C                    	jne	short plRet		; parse error occurred, return
 16335                                  
 16336                                  ;	Parse call succeeded. We have a filespec or a switch.
 16337                                  ;	DX = ptr to result buffer
 16338                                  
 16339 00001755 89D3                    	mov	bx,dx			; BX = ptr to parse result buffer
 16340 00001757 803F05                  	cmp	byte [bx],RESULT_FILESPEC ; 5
 16341 0000175A 7406                    	je	short plFil		; we have a filespec
 16342                                  
 16343 0000175C E87500                  	call	ParseSwitch		; else we have a switch
 16344                                  	;jc	short plRet		; error parsing switch, return
 16345                                  	;jmp	short plPars		; parse more
 16346                                  	; 19/02/2023
 16347 0000175F 73E7                    	jnc	short plPars
 16348                                  plRet:
 16349 00001761 C3                      	retn	
 16350                                  plFil:	
 16351 00001762 E8D200                  	call	CopyPathname		; copy pathname into our buffer
 16352 00001765 EBE1                    	jmp	short plPars		; parse more
 16353                                  ;plRet:
 16354                                  ;	retn
 16355                                  
 16356                                  ; ---------------------------------------------------------------------------
 16357                                  
 16358                                  ;***	ParseOrder - parse and record /O option
 16359                                  ;
 16360                                  ;	ENTRY	BX = ptr to system parser result buffer for /O occurence
 16361                                  ;
 16362                                  ;	EXIT	CY = set if error occurs parsing order
 16363                                  ;
 16364                                  ;		For parse error, we set up for Std_EPrintf call:
 16365                                  ;		AX = parse error code, like system parser
 16366                                  ;		DX = ptr to message block
 16367                                  ;
 16368                                  ;	USED	AX,CX,DX,DI
 16369                                  ;
 16370                                  ;	EFFECTS
 16371                                  ;
 16372                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 16373                                  ;
 16374                                  ;	  For parse error, we set up for Std_EPrintf call:
 16375                                  ;	  Msg_Disp_Class = parse error message class
 16376                                  ;	  Message block (see DX) is set up for parse error message
 16377                                  
 16378                                  	; 19/02/2023 - Retro DOS v4.0 COMMAND.COM
 16379                                  	;
 16380                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16381                                  	; MSDOS 6.22 COMMAND.COM
 16382                                  ParseOrder:
 16383 00001767 56                      	push	si			; save SI
 16384 00001768 53                      	push	bx			; save ptr to result buffer
 16385                                  
 16386                                  	;;mov	si,word ptr [bx].ValuePtr
 16387                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 16388 00001769 8B7704                  	mov	si,[bx+4]		; SI = ptr to order letters
 16389                                  	;mov	bx,offset TRANGROUP:DestBuf
 16390                                  	; 08/06/2023
 16391 0000176C BB[D5A0]                	mov	bx,DestBuf		; BX = ptr to sort code buffer
 16392 0000176F 8A04                    	mov	al,[si]			; AL = 1st char of order string
 16393 00001771 08C0                    	or	al,al
 16394 00001773 750E                    	jnz	short poLtr		; not NUL, go parse letters
 16395                                  
 16396                                  ;	We have /O alone. Set standard sort order.
 16397                                  ;	Note hardwired dependency on character order in OrderLtrs.
 16398                                  
 16399 00001775 C60705                  	mov	byte [bx],5		; sort 1st by group (subdirs 1st)
 16400 00001778 43                      	inc	bx
 16401 00001779 C60701                  	mov	byte [bx],1		; then by name
 16402 0000177C 43                      	inc	bx
 16403 0000177D C60702                  	mov	byte [bx],2		; then by extension
 16404 00001780 43                      	inc	bx
 16405 00001781 EB2F                    	jmp	short poOk		; return success
 16406                                  
 16407                                  ;	We have /O<something>. Parse sort order letters.
 16408                                  
 16409                                  poLtr:	
 16410 00001783 30D2                    	xor	dl,dl			; DL = 0 (upward sort)
 16411 00001785 AC                      	lodsb				; AL = next sort order letter
 16412 00001786 08C0                    	or	al,al
 16413 00001788 7428                    	jz	short poOk		; NUL found, return success
 16414                                  
 16415 0000178A 3C2D                    	cmp	al,'-'
 16416 0000178C 7503                    	jne	short po1		; not '-', go look for letter
 16417 0000178E B280                    	mov	dl,80h			; DL = downward sort mask
 16418 00001790 AC                      	lodsb				; AL = next char
 16419                                  po1:
 16420                                  	;mov	di,offset TRANGROUP:OrderLtrs
 16421                                  	; 08/06/2023
 16422 00001791 BF[9097]                	mov	di,OrderLtrs ;"NEDSGC"	; DI = ptr to list of letters
 16423                                  	; (NUM_ORDER_LTRS = 6 for MSDOS 6.22 COMMAND.COM)
 16424                                  	; ((N,E,D,S,G for MSDOS 5.0 and N,E,D,S,G,C for MSDOS 6.22)) 
 16425                                  	;mov	cx,6 ; 08/06/2023
 16426 00001794 B90600                  	mov	cx,NUM_ORDER_LTRS ; 5	; CX = length of list
 16427 00001797 F2AE                    	repne	scasb			; look for our letter in the list
 16428 00001799 7510                    	jne	short poErr		; not found, return error
 16429                                  
 16430 0000179B F7D9                    	neg	cx
 16431                                  	;add	cx,6 ; 08/06/2023
 16432 0000179D 83C106                  	add	cx,NUM_ORDER_LTRS ; 5	; CL = sort order code, 1-6
 16433                                  
 16434 000017A0 08D1                    	or	cl,dl			; CL = sort code with up/dn bit
 16435 000017A2 880F                    	mov	[bx],cl			; store sort order code in buffer
 16436 000017A4 43                      	inc	bx			; BX = ptr to next spot in buffer
 16437                                  	;cmp	bx,offset TRANGROUP:EndDestBuf
 16438 000017A5 81FB[2CA1]              	cmp	bx,EndDestBuf
 16439                                  	;jae	short poErr		; too many letters
 16440                                  	;
 16441                                  	;jmp	short poLtr		; go look at next char
 16442                                  	; 19/02/2023
 16443 000017A9 72D8                    	jb	short poLtr
 16444                                  
 16445                                  ;	The sort order string is invalid.  
 16446                                  
 16447                                  poErr:
 16448 000017AB 5B                      	pop	bx			; BX = ptr to result buffer
 16449 000017AC E85F03                  	call	SetupParamError		; set message up for Std_EPrintf
 16450 000017AF F9                      	stc				; return failure
 16451 000017B0 EB04                    	jmp	short poRet
 16452                                  poOk:	
 16453 000017B2 C60700                  	mov	byte [bx],0		; mark end of sort code list
 16454 000017B5 5B                      	pop	bx			; BX = ptr to result buffer
 16455                                  	; 19/02/2023
 16456                                  	;cf=0
 16457                                  	;clc				; return success
 16458                                  poRet:
 16459 000017B6 5E                      	pop	si			; restore SI
 16460 000017B7 C3                      	retn
 16461                                  
 16462                                  ; ---------------------------------------------------------------------------
 16463                                  ; MSDOS 6.0
 16464                                  	; 08/06/2023
 16465                                  
 16466                                  ;ifdef DBLSPACE_HOOKS
 16467                                  
 16468                                  ;***	ParseRatio - parse and record /C[H] option
 16469                                  ;
 16470                                  ;	ENTRY	BX = ptr to system parser result buffer for /C occurence
 16471                                  ;		DI = index into word list of switches
 16472                                  ;
 16473                                  ;	EXIT	CY = set if error occurs parsing order
 16474                                  ;
 16475                                  ;		For parse error, we set up for Std_EPrintf call:
 16476                                  ;		AX = parse error code, like system parser
 16477                                  ;		DX = ptr to message block
 16478                                  ;
 16479                                  ;	USED	AX,CX,DX,DI
 16480                                  ;
 16481                                  ;	EFFECTS
 16482                                  ;
 16483                                  ;	  Bits modified to indicate option state.
 16484                                  ;	  fUseHostSize is set to zero for /C, non-zero for /CH.
 16485                                  ;
 16486                                  ;	  For parse error, we set up for Std_EPrintf call:
 16487                                  ;	  Msg_Disp_Class = parse error message class
 16488                                  ;	  Message block (see DX) is set up for parse error message
 16489                                  
 16490                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16491                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:184Ch
 16492                                  
 16493                                  ParseRatio:	;proc
 16494 000017B8 E829FF                  	call	OnOffSw			; turn on option bit
 16495 000017BB 56                      	push	si			; save SI
 16496                                  	;;mov	si,word ptr [bx].ValuePtr
 16497                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 16498 000017BC 8B7704                  	mov	si,[bx+4]		; SI = ptr to possible H option
 16499 000017BF 8A04                    	mov	al,[si] 		; AL = null or 'H'
 16500 000017C1 08C0                    	or	al,al
 16501 000017C3 740A                    	jz	short prDone		; if null, no H option to check
 16502 000017C5 3C48                    	cmp	al,'H' 			; only H is allowed, make sure that's
 16503 000017C7 7406                    	je	short prDone		;   what it is
 16504 000017C9 E84203                  	call	SetupParamError		; set message up for Std_EPrintf
 16505 000017CC F9                      	stc				; return failure
 16506 000017CD EB03                    	jmp	short prRet
 16507                                  prDone:
 16508 000017CF A2[B69E]                	mov	[fUseHostSize],al	; set Host cluster size flag
 16509                                  	; 08/06/2023
 16510                                  	;clc
 16511                                  	;;cf = 0
 16512                                  prRet:	
 16513 000017D2 5E                      	pop	si
 16514 000017D3 C3                      	retn
 16515                                  
 16516                                  ;ParseRatio	;endp
 16517                                  ;endif
 16518                                  
 16519                                  ; ---------------------------------------------------------------------------
 16520                                  
 16521                                  ;***	ParseSwitch - parse a switch
 16522                                  ;
 16523                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 16524                                  ;		     a switch
 16525                                  ;
 16526                                  ;	EXIT	CY = set if parse error occurred
 16527                                  ;
 16528                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 16529                                  ;		AX = parse error code, like system parser
 16530                                  ;		DX = ptr to message block
 16531                                  ;
 16532                                  ;	USED	AX,BX,DX
 16533                                  ;
 16534                                  ;	EFFECTS
 16535                                  ;
 16536                                  ;	  Bits may contain new option settings.
 16537                                  ;	  DestBuf may contain new series of sort codes.
 16538                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 16539                                  ;
 16540                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 16541                                  ;	  Msg_Disp_Class = parse error class
 16542                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 16543                                  ;	  Message block (see DX) is set up for parse error message
 16544                                  
 16545                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16546                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16E2h
 16547                                  
 16548                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16549                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1869h
 16550                                  ParseSwitch:
 16551 000017D4 51                      	push	cx			; save CX
 16552 000017D5 57                      	push	di			; save DI
 16553                                  
 16554                                  	;;mov	ax,[bx].SynPtr		; AX = synonym ptr
 16555                                  	;mov	ax,[bx+ResultBuffer.SynPtr]
 16556 000017D6 8B4702                  	mov	ax,[bx+2]
 16557                                  	;mov	di,offset TRANGROUP:Dir_Sw_Ptrs
 16558 000017D9 BF[AF98]                	mov	di,Dir_Sw_Ptrs		; ES:DI = ptr to list of synonym ptrs
 16559                                  	; 08/06/2023
 16560                                  	; (NUM_DIR_SWS = 16 for MSDOS 6.0)
 16561                                  	;mov	cx,16
 16562 000017DC B91000                  	mov	cx,NUM_DIR_SWS ; 14	; CX = # of dir switches in list
 16563 000017DF FC                      	cld				; scan direction = upward
 16564 000017E0 F2AF                    	repne	scasw			; locate synonym ptr in list
 16565                                  	;sub	di,offset TRANGROUP:Dir_Sw_Ptrs + 2
 16566 000017E2 81EF[B198]              	sub	di,Dir_Sw_Ptrs+2
 16567                                  
 16568                                  ;	DI = index into word list of synonym ptrs
 16569                                  
 16570 000017E6 2EFF95[EE17]            	call	word [cs:di+SwHandler]	; use same index into call table
 16571                                  
 16572 000017EB 5F                      	pop	di			; restore DI
 16573 000017EC 59                      	pop	cx			; restore CX
 16574                                  
 16575 000017ED C3                      	retn
 16576                                  
 16577                                  ; ---------------------------------------------------------------------------
 16578                                  
 16579                                  ;	Order in this table must correspond to order in Dir_Sw_Ptrs list.
 16580                                  ;	Simple on/off switches must occur first in both lists, and must be
 16581                                  ;	  in order of option bits in Bits, starting with bit 0.
 16582                                  
 16583                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16584                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16FCh
 16585                                  
 16586                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16587                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1883h
 16588                                  SwHandler:
 16589                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 16590                                  		; ifdef DBLSPACE_HOOKS
 16591 000017EE [E416]                  	dw	OnOffSw 	; /-C
 16592 000017F0 [B817]                  	dw	ParseRatio	; /C[H]
 16593                                  	;	; endif	
 16594 000017F2 [E416]                  	dw	OnOffSw		; /-W
 16595 000017F4 [E416]                  	dw	OnOffSw		; /W
 16596 000017F6 [E416]                  	dw	OnOffSw		; /-P
 16597 000017F8 [E416]                  	dw	OnOffSw		; /P
 16598 000017FA [E416]                  	dw	OnOffSw		; /-S
 16599 000017FC [E416]                  	dw	OnOffSw		; /S
 16600 000017FE [E416]                  	dw	OnOffSw		; /-B
 16601 00001800 [E416]                  	dw	OnOffSw		; /B
 16602 00001802 [E416]                  	dw	OnOffSw		; /-L	;M010
 16603 00001804 [E416]                  	dw	OnOffSw		; /L	;M010
 16604 00001806 [DD16]                  	dw	NoOrder		; /-O
 16605 00001808 [6717]                  	dw	ParseOrder	; /O
 16606 0000180A [7E14]                  	dw	DefaultAttr	; /-A
 16607 0000180C [0117]                  	dw	ParseAttr	; /A
 16608                                  
 16609                                  ; ---------------------------------------------------------------------------
 16610                                  
 16611                                  	;break	<DIR utility routines>
 16612                                  
 16613                                  ;***	UTILITY ROUTINES
 16614                                  ; ---------------------- 
 16615                                  
 16616                                  ; ---------------------------------------------------------------------------
 16617                                  
 16618                                  ;***	ChangeDir - change directory on target drive
 16619                                  ;
 16620                                  ;	ENTRY	FCB contains drive #
 16621                                  ;		DS:DX = ptr to ASCIIZ string w/o drive specifier
 16622                                  ;
 16623                                  ;	EXIT	Changed current directory on drive
 16624                                  ;
 16625                                  ;		If error,
 16626                                  ;		CY = set
 16627                                  ;		DOS Get Extended Error call will get error
 16628                                  ;
 16629                                  ;	USED	AX,DX,SI,DI
 16630                                  ;
 16631                                  ;	EFFECTS
 16632                                  ;
 16633                                  ;	  DirBuf is used to build "d:string".
 16634                                  
 16635                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16636                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1718h
 16637                                  
 16638                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16639                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:18A3h
 16640                                  ChangeDir:
 16641                                  	;mov	di,offset TRANGROUP:DirBuf
 16642 0000180E BF[50A0]                	mov	di,DIRBUF
 16643 00001811 E8E902                  	call	GetDriveLtr	; AX = "d:"
 16644 00001814 AB                      	stosw			; put drive specifier in buffer
 16645 00001815 89D6                    	mov	si,dx		; SI = ptr to argument string
 16646                                  cdLoop:
 16647 00001817 AC                      	lodsb
 16648 00001818 AA                      	stosb			; move byte to buffer
 16649 00001819 08C0                    	or	al,al
 16650 0000181B 75FA                    	jne	short cdLoop	; continue until null transferred
 16651                                  
 16652                                  	;mov	dx,offset TRANGROUP:DirBuf
 16653 0000181D BA[50A0]                	mov	dx,DIRBUF	; DX = ptr to "d:string"
 16654                                  	;mov	ah,CHDir
 16655 00001820 B43B                    	mov	ah,3Bh
 16656 00001822 CD21                    	int	21h		; change directory
 16657 00001824 C3                      	retn			; return what CHDIR returns
 16658                                  
 16659                                  ; ---------------------------------------------------------------------------
 16660                                  
 16661                                  ;***	CmpAscz - compare two ASCIIZ strings alphanumerically
 16662                                  ;
 16663                                  ;	ENTRY	DS:SI = ptr to one ASCIIZ string
 16664                                  ;		ES:DI = ptr to another ASCIIZ string
 16665                                  ;
 16666                                  ;	EXIT	flags set after REPE CMPSB
 16667                                  ;
 16668                                  ;	USED	AL,CX,SI,DI
 16669                                  ;
 16670                                  ;	NOTES
 16671                                  ;
 16672                                  ;	Maximum run of comparison is length of DS:SI string.
 16673                                  ;	This ensures that two identical strings followed by
 16674                                  ;	random characters will compare correctly.
 16675                                  
 16676                                  	; 19/02/2023
 16677                                  CmpAscz:
 16678                                  	; 07/06/2023
 16679 00001825 56                      	push	si ; *
 16680                                  	;
 16681 00001826 57                      	push	di
 16682                                  
 16683 00001827 89F7                    	mov	di,si
 16684 00001829 30C0                    	xor	al,al
 16685 0000182B B9FFFF                  	mov	cx,0FFFFh
 16686 0000182E F2AE                    	repne	scasb
 16687 00001830 F7D1                    	not	cx
 16688                                  
 16689 00001832 5F                      	pop	di
 16690 00001833 F3A6                    	repe	cmpsb
 16691                                  
 16692                                  	; 07/06/2023
 16693 00001835 5E                      	pop	si ; *
 16694                                  	;
 16695 00001836 C3                      	retn
 16696                                  
 16697                                  ; ---------------------------------------------------------------------------
 16698                                  
 16699                                  ;***	CopyPathname - copy pathname to our buffer
 16700                                  ;
 16701                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 16702                                  ;		     a filespec
 16703                                  ;
 16704                                  ;	EXIT	nothing
 16705                                  ;
 16706                                  ;	USED	AX
 16707                                  ;
 16708                                  ;	EFFECTS
 16709                                  ;
 16710                                  ;	  SrcBuf may contain a new pathname/filespec.
 16711                                  ;	  PathPos, PathCnt updated for new pathname.
 16712                                  
 16713                                  	; 19/02/2023
 16714                                  CopyPathname:
 16715 00001837 56                      	push	si
 16716                                  	;;lds	si,dword ptr [bx].ValuePtr  ; load far ptr from result buffer
 16717                                  	;lds	si,[bx+ResultBuffer.ValuePtr]
 16718 00001838 C57704                  	lds	si,[bx+4]
 16719                                  	;invoke	Move_To_SrcBuf		    ; copy pathname to SrcBuf
 16720 0000183B E8B719                  	call	Move_To_SrcBuf
 16721 0000183E 5E                      	pop	si
 16722 0000183F C3                      	retn
 16723                                  
 16724                                  ; ---------------------------------------------------------------------------
 16725                                  
 16726                                  ;***	CountFile - update counters with current file
 16727                                  ;
 16728                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16729                                  ;
 16730                                  ;	EXIT	nothing
 16731                                  ;
 16732                                  ;	USED	AX,DX
 16733                                  ;
 16734                                  ;	EFFECTS
 16735                                  ;
 16736                                  ;	  FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 16737                                  
 16738                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16739                                  CountFile:
 16740 00001840 06                      	push	es			; save TRANGROUP seg addr
 16741 00001841 8E06[179E]              	mov	es,[TPA]		; ES = TPA seg addr
 16742                                  
 16743 00001845 FF06[439E]              	inc	word [FileCnt]		; # files this directory
 16744 00001849 FF06[499E]              	inc	word [FileCntTotal]	; # files total
 16745 0000184D 7504                    	jnz	short cntf1
 16746 0000184F FF06[4B9E]              	inc	word [FileCntTotal+2]
 16747                                  cntf1:
 16748                                  	;mov	ax,word ptr es:[bx].filesize
 16749                                  					; AX = low word of file size
 16750                                  	;mov	dx,word ptr es:[bx].filesize+2
 16751                                  					; DX = high word of file size
 16752 00001853 268B4711                	mov	ax,[es:bx+17] ; [es:bx+EntryStruc.filesize]
 16753 00001857 268B5713                	mov	dx,[es:bx+19] ; [es:bx+EntryStruc.filesize+2]
 16754 0000185B 0106[459E]              	add	[FileSiz],ax
 16755 0000185F 1116[479E]              	adc	[FileSiz+2],dx		; size of this directory
 16756 00001863 0106[4D9E]              	add	[FileSizTotal],ax
 16757 00001867 1116[4F9E]              	adc	[FileSizTotal+2],dx	; total size of files listed
 16758                                  
 16759 0000186B 07                      	pop	es			; ES = TRANGROUP seg addr again
 16760                                  dbRet:	; 19/02/2023
 16761 0000186C C3                      	retn
 16762                                  
 16763                                  ; ---------------------------------------------------------------------------
 16764                                  
 16765                                  ;***	DisplayBare - display filename in bare format
 16766                                  ;
 16767                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16768                                  ;
 16769                                  ;	EXIT	DX = # char's displayed, including dot
 16770                                  ;
 16771                                  ;	USED	AX,CX,SI,DI
 16772                                  ;
 16773                                  ;	EFFECTS
 16774                                  ;
 16775                                  ;	  Filename is displayed in name.ext format, followed by cr/lf.
 16776                                  ;	  If /s is on, complete pathname is displayed.
 16777                                  ;
 16778                                  ;	NOTE
 16779                                  ;
 16780                                  ;	  Directory pseudofiles . and .. and suppressed in bare listing.
 16781                                  
 16782                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16783                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1775h
 16784                                  
 16785                                  
 16786                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16787                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1900h
 16788                                  
 16789                                  DisplayBare:
 16790                                  ;	Suppress . and .. files from bare listing.
 16791                                  
 16792 0000186D 8CD9                    	mov	cx,ds			; CX = saved TRANGROUP seg addr
 16793 0000186F 8E1E[179E]              	mov	ds,[TPA]		; DS:BX = ptr to file entry
 16794                                  	;assume	ds:NOTHING
 16795                                  	;cmp	ds:[bx].filename,'.'	; check 1st char of filename
 16796 00001873 807F012E                	cmp	byte [bx+1],'.' ; [bx+EntrStruc.filename]
 16797 00001877 8ED9                    	mov	ds,cx			; DS = TRANGROUP seg addr again
 16798                                  	;assume	ds:TRANGROUP
 16799 00001879 74F1                    	je	short dbRet		; it's . or .. - don't display
 16800                                  
 16801                                  	;;;test	Bits,mask subd
 16802                                  	;;test	word [_Bits],4
 16803                                  	;test	byte [_Bits],4
 16804                                  	; 08/06/2023
 16805 0000187B F606[A2A0]08            	test	byte [_Bits],mask.subd ; 8 ; MSDOS 6.0
 16806 00001880 7431                    	jz	short dbNameExt		; not /s - display filename only
 16807                                  
 16808                                  	;invoke	Build_Dir_String
 16809 00001882 E8170B                  	call	build_dir_string
 16810                                  	;mov	di,offset TRANGROUP:BwdBuf
 16811 00001885 BF[50A0]                	mov	di,BWDBUF		; ES:DI = ptr to dir string
 16812                                     
 16813                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16814                                  	;;test	word [_Bits],10h
 16815                                  	;test	byte [_Bits],10h
 16816                                  	; 08/06/2023
 16817 00001888 F606[A2A0]20            	test	byte [_Bits],mask.lcase ; 20h ; MSDOS 6.0
 16818                                  	;jz	@F			;M010;lowercase not needed
 16819 0000188D 7405                    	jz	short dbare1
 16820 0000188F 89FE                    	mov	si,di			;M010;DS:SI --> ASCIIZ string in BwdBuf	
 16821 00001891 E8C002                  	call	LowercaseString		;M010;path string is in BwdBuf
 16822                                  dbare1:
 16823                                  ;@@:	
 16824                                  	;xor	al,al			; AL = 0
 16825                                  	; 19/02/2023
 16826 00001894 31C0                    	xor	ax,ax
 16827 00001896 B9FFFF                  	mov	cx,0FFFFh
 16828 00001899 FC                      	cld
 16829 0000189A F2AE                    	repne	scasb			; ES:DI = ptr to byte after null
 16830 0000189C 4F                      	dec	di			; ES:DI = ptr to null byte
 16831                                  
 16832 0000189D 26807DFF5C              	cmp	byte [es:di-1],'\'
 16833                                  	;je	@F
 16834 000018A2 7403                    	je	short dbare2		; already terminated w/ '\'
 16835                                  
 16836                                  	;mov	ax,'\'			; AX = '\',0
 16837 000018A4 B05C                    	mov	al,'\'
 16838 000018A6 AB                      	stosw				; add to dir string
 16839                                  ;@@:
 16840                                  dbare2:
 16841                                  	;mov	String_Ptr_2,offset TRANGROUP:BwdBuf
 16842 000018A7 C706[B7A0][50A0]        	mov	word [string_ptr_2],BWDBUF
 16843                                  	;mov	dx,offset TRANGROUP:String_Buf_Ptr
 16844 000018AD BA[BA93]                	mov	dx,string_buf_ptr
 16845                                  	;invoke	Std_Printf		; display device & directory path
 16846 000018B0 E87A3C                  	call	std_printf
 16847                                  dbNameExt:
 16848 000018B3 E82D00                  	call	DisplayDotForm		; display name.ext
 16849                                  	;invoke	CrLf2			; display cr/lf
 16850 000018B6 E86812                  	call	CRLF2
 16851                                  	; 19/02/2023
 16852                                  	;call	UseLine			;M007;Allow /p with /b
 16853                                  ;dbRet:
 16854                                  	;retn
 16855                                  
 16856                                  	; 19/02/2023
 16857                                  	;jmp	short UseLine
 16858                                  
 16859                                  ; ---------------------------------------------------------------------------
 16860                                  
 16861                                  ;***	UseLine - use a display line, start a new page if none left
 16862                                  ;
 16863                                  ;	ENTRY	nothing
 16864                                  ;
 16865                                  ;	EXIT	nothing
 16866                                  ;
 16867                                  ;	USED	flags
 16868                                  
 16869                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16870                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A04h
 16871                                  UseLine:
 16872 000018B9 FF0E[419E]              	dec	word [LeftOnPage]
 16873 000018BD 833E[419E]02            	cmp	word [LeftOnPage],2
 16874 000018C2 771E                    	ja	short ulRet
 16875                                  	; 19/02/2023
 16876                                  	;call	EndPage
 16877                                  ;ulRet:
 16878                                  	;retn
 16879                                  
 16880                                  	; 19/02/2023
 16881                                  	;jmp	short EndPage
 16882                                  
 16883                                  ; ---------------------------------------------------------------------------
 16884                                  
 16885                                  ;***	EndPage - end the current display page
 16886                                  ;
 16887                                  ;	ENTRY	LeftOnPage = # lines left on display page
 16888                                  ;		Current directory (on selected drive) is the one being listed
 16889                                  ;		Bits contains /p setting
 16890                                  ;
 16891                                  ;	EXIT	LeftOnPage = # lines left for next page
 16892                                  ;
 16893                                  ;	USED	AX,DX
 16894                                  ;
 16895                                  ;	EFFECTS
 16896                                  ;
 16897                                  ;	  Pause is invoked to display a message and wait for a keystroke.
 16898                                  ;	  BwdBuf (same as DirBuf) used to build directory string.
 16899                                  
 16900                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16901                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19B8h
 16902                                  
 16903                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16904                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1BADh
 16905                                  EndPage:
 16906                                  	;;;test	Bits,mask pagd
 16907                                  	;;test	word [_Bits],2
 16908                                  	;test	byte [_Bits],2
 16909                                  	; 08/06/2023
 16910 000018C4 F606[A2A0]04            	test	byte [_Bits],mask.pagd ; 4 ; MSDOS 6.0
 16911 000018C9 7410                    	jz	short epNew		; paged display isn't enabled
 16912                                  
 16913 000018CB 53                      	push	bx			; save BX
 16914 000018CC 51                      	push	cx			; save CX
 16915                                  
 16916                                  	;invoke	Pause			; "Press any key to continue..."
 16917 000018CD E83506                  	call	PAUSE
 16918                                  
 16919                                  	;invoke	Build_Dir_String
 16920 000018D0 E8C90A                  	call	build_dir_string
 16921                                  	;mov	dx,offset TRANGROUP:DirCont_Ptr
 16922 000018D3 BA[3E94]                	mov	dx,dircont_ptr
 16923                                  	;invoke	Printf_Crlf		; "(continuing <dir>)", cr/lf
 16924 000018D6 E8463C                  	call	Printf_Crlf
 16925                                  
 16926 000018D9 59                      	pop	cx			; restore CX
 16927 000018DA 5B                      	pop	bx			; restore BX
 16928                                  epNew:	
 16929 000018DB A1[2EA2]                	mov	ax,[LinPerPag]		; AX = # lines per page
 16930 000018DE 48                      	dec	ax			; AX = # lines till next EndPage
 16931 000018DF A3[419E]                	mov	[LeftOnPage],ax		; LeftOnPage = countdown variable
 16932                                  ulRet:	
 16933                                  	; 19/02/2023
 16934 000018E2 C3                      	retn
 16935                                  
 16936                                  ; ---------------------------------------------------------------------------
 16937                                  
 16938                                  ;***	DisplayDotForm - display filename in compressed dot format
 16939                                  ;
 16940                                  ;	Display name.ext, with no cr/lf's. Dot is displayed only
 16941                                  ;	if the filename has a nonblank extension.
 16942                                  ;
 16943                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16944                                  ;
 16945                                  ;	EXIT	DX = # char's displayed, including dot
 16946                                  ;
 16947                                  ;	USED	AX,CX,SI,DI
 16948                                  ;
 16949                                  ;	EFFECTS
 16950                                  ;
 16951                                  ;	  Filename is displayed in name.ext format.
 16952                                  ;
 16953                                  ;	NOTE
 16954                                  ;
 16955                                  ;	  We allow for bogus filenames that have blanks embedded
 16956                                  ;	  in the name or extension.
 16957                                  
 16958                                  ;	Bugbug:	might be a good performance gain if we buffered
 16959                                  ;	up the output and used DOS function 9.
 16960                                  
 16961                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16962                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:17C8h
 16963                                  
 16964                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16965                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1953h
 16966                                  DisplayDotForm:
 16967 000018E3 1E                      	push	ds			; save TRANGROUP seg addr
 16968 000018E4 06                      	push	es			; save ES
 16969 000018E5 2EA1[179E]              	mov	ax,[cs:TPA]		; AX = TPA seg addr
 16970 000018E9 8ED8                    	mov	ds,ax			; DS:BX = ptr to entry
 16971                                  	;assume	ds:nothing
 16972 000018EB 8EC0                    	mov	es,ax			; ES:BX = ptr to entry
 16973                                  
 16974                                  	; 08/06/2023
 16975                                  	;mov	di,bx			; ES:DI = ptr to entry
 16976                                  	;;;add	di,filename + size filename - 1
 16977                                  	;add	di,8 ; 1+8-1		; ES:DI = ptr to last char in name field
 16978                                  	;;mov	cx,size filename	; CX = length of name field
 16979                                  	;mov	cx,8
 16980                                  	; 08/06/2023
 16981 000018ED B90800                  	mov	cx,8
 16982 000018F0 89CF                    	mov	di,cx
 16983 000018F2 01DF                    	add	di,bx
 16984                                  
 16985 000018F4 B020                    	mov	al,' '
 16986 000018F6 FD                      	std				; scan down
 16987 000018F7 F3AE                    	repe	scasb			; scan for nonblank
 16988                                  
 16989                                  ;	Assume file name has at least one character.
 16990                                  
 16991 000018F9 41                      	inc	cx			; CX = # chars in name
 16992 000018FA 89CA                    	mov	dx,cx			; DX = # chars to be displayed
 16993                                  
 16994 000018FC 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16995                                  	;;add	si,filename		; DS:SI = ptr to name
 16996                                  	;add	si,1 
 16997                                  	;		; add si,EntryStruc.filename
 16998                                  	; 25/04/2023
 16999 000018FE 46                      	inc	si
 17000                                  NextNameChar:
 17001 000018FF FC                      	cld
 17002 00001900 AC                      	lodsb				; AL = next char
 17003                                  
 17004                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 17005                                  	;;test	word [ss:_Bits],10h
 17006                                  	;test	byte [ss:_Bits],10h
 17007                                  	; 08/06/2023
 17008 00001901 36F606[A2A0]20          	test	byte [ss:_Bits],mask.lcase ; 20h ; MSDOS 6.0
 17009                                  	;jz	short @F		;M010;lowercase not required
 17010 00001907 7403                    	jz	short ddf1
 17011 00001909 E83D02                  	call	LowerCase		;M010;filename char is in AL
 17012                                  ddf1:
 17013                                  ;@@:	
 17014                                  	;invoke	Print_Char		; display it
 17015 0000190C E83E0A                  	call	PRINT_CHAR
 17016 0000190F E2EE                    	loop	NextNameChar
 17017                                  
 17018                                  ;	Now do extension.
 17019                                  
 17020 00001911 89DF                    	mov	di,bx			; ES:DI = ptr to entry
 17021                                  	;add	di,fileext + size fileext - 1
 17022 00001913 83C70B                  	add	di,11 ; 9+3-1		; ES:DI = ptr to last char in ext field
 17023                                  	;mov	cx,size fileext		; CX = length of ext field
 17024 00001916 B90300                  	mov	cx,3
 17025 00001919 B020                    	mov	al,' '
 17026 0000191B FD                      	std				; scan down
 17027 0000191C F3AE                    	repe	scasb			; scan for nonblank
 17028 0000191E 7420                    	je	short ddDone		; no nonblank chars in ext
 17029                                  
 17030 00001920 41                      	inc	cx			; CX = # chars in ext
 17031 00001921 01CA                    	add	dx,cx			; DX = total # chars to be displayed
 17032 00001923 42                      	inc	dx			;      including dot
 17033                                  
 17034 00001924 B02E                    	mov	al,'.'
 17035 00001926 E8240A                  	call	PRINT_CHAR
 17036 00001929 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 17037                                  	;add	si,fileext		; DS:SI = ptr to ext
 17038 0000192B 83C609                  	add	si,9
 17039                                  
 17040                                  NextExtChar:
 17041 0000192E FC                      	cld
 17042 0000192F AC                      	lodsb				; AL = next char
 17043                                  
 17044                                  	;;;test	CS:Bits,mask lcase	;M010;check for lowercase option
 17045                                  	;;test	word [cs:_Bits],10h
 17046                                  	;test	byte [cs:_Bits],10h
 17047                                  	; 08/06/2023
 17048 00001930 2EF606[A2A0]20          	test	byte [cs:_Bits],mask.lcase ; 20h ; MSDOS 6.0
 17049                                  	;jz	short @F		;M010;lowercase not required
 17050 00001936 7403                    	jz	short ddf2
 17051 00001938 E80E02                  	call	LowerCase		;M010;fileext char is in AL
 17052                                  ;@@:	
 17053                                  ddf2:
 17054                                  	;invoke	Print_Char		; display it
 17055 0000193B E80F0A                  	call	PRINT_CHAR
 17056 0000193E E2EE                    	loop	NextExtChar
 17057                                  ddDone:
 17058 00001940 07                      	pop	es			; restore ES
 17059 00001941 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 17060                                  	;assume	ds:TRANGROUP
 17061 00001942 FC                      	cld				; leave direction flag = up
 17062 00001943 C3                      	retn
 17063                                  
 17064                                  ; ---------------------------------------------------------------------------
 17065                                  
 17066                                  ;***	DisplayFile - display file entry, update counters
 17067                                  ;
 17068                                  ;	ENTRY	BX = offset of entry in TPA buffer
 17069                                  ;		Bits contains /w, /p settings
 17070                                  ;
 17071                                  ;	EXIT	nothing
 17072                                  ;
 17073                                  ;	USED	AX,CX,DX,SI,DI,BP
 17074                                  ;
 17075                                  ;	EFFECTS
 17076                                  ;
 17077                                  ;	  Entry is displayed.
 17078                                  ;	  If not /b,
 17079                                  ;	    Cursor is left at end of entry on screen.
 17080                                  ;	    FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 17081                                  ;	  If /b,
 17082                                  ;	    Cursor is left at beginning of next line.
 17083                                  ;	    Cnt's and Siz's aren't updated.
 17084                                  
 17085                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17086                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:182Eh
 17087                                  	
 17088                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17089                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:19B9h
 17090                                  
 17091                                  DisplayFile:
 17092                                  	;;;test	Bits,mask bare
 17093                                  	;;test	word [_Bits],8
 17094                                  	;test	byte [_Bits],8
 17095                                  	; 08/06/2023
 17096 00001944 F606[A2A0]10            	test	byte [_Bits],mask.bare ; 16 ; MSDOS 6.0
 17097 00001949 7405                    	jz	short dfNorm		; not /b - do normal display
 17098                                  
 17099 0000194B E81FFF                  	call	DisplayBare		; display file in bare format
 17100 0000194E EB22                    	jmp	short dfRet
 17101                                  dfNorm:	
 17102 00001950 E88200                  	call	DisplayNext		; pos'n cursor for next entry
 17103                                  	;;;test	Bits,mask wide
 17104                                  	;;test	word [_Bits],1
 17105                                  	;test	byte [_Bits],1
 17106                                  	; 08/06/2023
 17107 00001953 F606[A2A0]02            	test	byte [_Bits],mask.wide ; 2 ; MSDOS 6.0
 17108 00001958 7405                    	jz	short dfFull		; full format
 17109 0000195A E87401                  	call	DisplayWide		; wide format
 17110 0000195D EB10                    	jmp	short dfCnt
 17111                                  dfFull:	
 17112 0000195F E83E00                  	call	DisplayName		; display filename & extension
 17113 00001962 E89700                  	call	DisplayTheRest		; display size, date, time
 17114                                  	
 17115                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 17116                                  	; MSDOS 6.0
 17117                                  ;ifdef DBLSPACE_HOOKS
 17118                                  	;;test	Bits,mask cratio
 17119                                  	;test	word [_Bits],1
 17120 00001965 F606[A2A0]01            	test	byte [_Bits],mask.cratio
 17121                                  					; display compression ratio
 17122 0000196A 7403                    	jz	short dfCnt
 17123 0000196C E81A01                  	call	DisplayCompRatio
 17124                                  ;endif
 17125                                  
 17126                                  dfCnt:
 17127 0000196F E8CEFE                  	call	CountFile		; update file counters
 17128                                  dfRet:
 17129                                  dhRet:	; 19/02/2023
 17130 00001972 C3                      	retn
 17131                                  
 17132                                  ; ---------------------------------------------------------------------------
 17133                                  
 17134                                  ;***	DisplayHeader - display directory header of working directory
 17135                                  ;
 17136                                  ;	ENTRY	Current directory (on selected drive) is the one to display
 17137                                  ;		LeftOnPage = # lines left on display page
 17138                                  ;
 17139                                  ;	EXIT	nothing
 17140                                  ;
 17141                                  ;	ERROR EXIT
 17142                                  ;
 17143                                  ;	  Build_Dir_String will exit through CError with "Invalid drive
 17144                                  ;	   specification" if there's a problem obtaining the current
 17145                                  ;	   directory pathname.
 17146                                  ;
 17147                                  ;	USED	AX,DX,SI,DI
 17148                                  ;
 17149                                  ;	EFFECTS
 17150                                  ;
 17151                                  ;	  BwdBuf (which is really the same buffer as DirBuf, which
 17152                                  ;	   we are using for the DTA) contains the directory string.
 17153                                  ;	  LeftOnPage is adjusted.
 17154                                  
 17155                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17156                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17157                                  
 17158                                  DisplayHeader:
 17159                                  	;;;test	Bits,mask bare
 17160                                  	;;test	word [_Bits],8
 17161                                  	;test	byte [_Bits],8
 17162                                  	; 08/06/2023
 17163 00001973 F606[A2A0]10            	test	byte [_Bits],mask.bare ; 10h ; MSDOS 6.0
 17164 00001978 75F8                    	jnz	short dhRet		; /b - don't display header
 17165                                  
 17166                                  	;;;test	Bits,mask subd
 17167                                  	;;test	word [_Bits],4
 17168                                  	;test	byte [_Bits],4
 17169                                  	; 08/06/2023
 17170 0000197A F606[A2A0]08            	test	byte [_Bits],mask.subd ; 8 ; MSDOS 6.0
 17171 0000197F 7408                    	jz	short dhNorm		; not /s
 17172                                  
 17173                                  ;	For subdirectory listings, put a blank line before the header.
 17174                                  
 17175                                  	;invoke	Crlf2			; start with a blank line
 17176 00001981 E89D11                  	call	CRLF2
 17177 00001984 E832FF                  	call	UseLine
 17178 00001987 EB05                    	jmp	short dhCom
 17179                                  dhNorm:
 17180 00001989 B020                    	mov	al,' ' ; 20h
 17181                                  	;mov	al,BLANK		; if not /s, precede by a blank
 17182 0000198B E8BF09                  	call	PRINT_CHAR		; print a leading blank
 17183                                  dhCom:
 17184 0000198E E80B0A                  	call	build_dir_string
 17185 00001991 BA[3A93]                	mov	dx,dirhead_ptr
 17186 00001994 E8963B                  	call	std_printf		; print header & cr/lf
 17187 00001997 E81FFF                  	call	UseLine
 17188 0000199A E88411                  	call	CRLF2			; another cr/lf
 17189                                  	;call	UseLine
 17190                                  ;dhRet:
 17191                                  	;retn
 17192                                  
 17193                                  	; 19/02/2023
 17194 0000199D E919FF                  	jmp	UseLine
 17195                                  
 17196                                  ; ---------------------------------------------------------------------------
 17197                                  
 17198                                  ;***	DisplayName - display file name & extension
 17199                                  ;
 17200                                  ;	ENTRY	BX = offset of entry in TPA buffer
 17201                                  ;
 17202                                  ;	EXIT	nothing
 17203                                  ;
 17204                                  ;	USED	AX,CX,DX,SI,DI
 17205                                  ;
 17206                                  ;	EFFECTS
 17207                                  ;
 17208                                  ;	  Filename & extension are displayed in spread format.
 17209                                  ;	  Cursor is left at end of extension.
 17210                                  
 17211                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17212                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17213                                  
 17214                                  DisplayName:
 17215 000019A0 1E                      	push	ds			; save TRANGROUP seg addr
 17216 000019A1 8E1E[179E]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 17217                                  	;assume	ds:nothing
 17218 000019A5 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 17219                                  	;;add	si,filename		; DS:SI = ptr to filename
 17220                                  	;add	si,1  ; EntryStruc.filename
 17221                                  	; 08/06/2023
 17222 000019A7 46                      	inc	si
 17223 000019A8 BF[819F]                	mov	di,CHARBUF		; ES:DI = ptr to CharBuf
 17224                                  
 17225 000019AB B90800                  	mov	cx,8
 17226 000019AE FC                      	cld
 17227 000019AF F3A4                    	rep	movsb			; move filename to CharBuf
 17228 000019B1 B020                    	mov	al,' '
 17229 000019B3 AA                      	stosb				; add a blank
 17230                                  	;mov	cx,3
 17231                                  	; 08/06/2023
 17232 000019B4 B103                    	mov	cl,3
 17233 000019B6 F3A4                    	rep	movsb			; add extension
 17234 000019B8 30C0                    	xor	al,al
 17235 000019BA AA                      	stosb				; add a NULL
 17236                                  
 17237 000019BB 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 17238                                  	;assume	ds:TRANGROUP
 17239                                  
 17240                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 17241                                  	;;test	word [_Bits],10h
 17242                                  	;test	byte [_Bits],10h
 17243                                  	; 08/06/2023
 17244 000019BC F606[A2A0]20            	test	byte [_Bits],mask.lcase ; 20h ; MSDOS 6.0
 17245 000019C1 7406                    	jz	short dn1		;M010;lowercase not required
 17246 000019C3 BE[819F]                	mov	si,CHARBUF		;M010;DS:SI --> ASCIIZ string
 17247 000019C6 E88B01                  	call	LowercaseString		;M010;filename.ext string is in CharBuf
 17248                                  dn1:	
 17249 000019C9 C706[B7A0][819F]        	mov	word [string_ptr_2],CHARBUF
 17250 000019CF BA[BA93]                	mov	dx,string_buf_ptr
 17251                                  	;call	std_printf		; print filename & extension
 17252                                  	;retn
 17253                                  	; 19/02/2023
 17254 000019D2 E9583B                  	jmp	std_printf
 17255                                  
 17256                                  ; ---------------------------------------------------------------------------
 17257                                  
 17258                                  ;***	DisplayNext - move display cursor to next entry position
 17259                                  ;
 17260                                  ;	ENTRY	LeftOnLine = # entries can still be printed on this line
 17261                                  ;		LeftOnPage = # lines can still be printed for this page
 17262                                  ;		FileCnt = # files in this dir displayed before this one
 17263                                  ;		Bits contains /w setting
 17264                                  ;
 17265                                  ;	EXIT	nothing
 17266                                  ;
 17267                                  ;	USED	AX,DX
 17268                                  ;
 17269                                  ;	EFFECTS
 17270                                  ;
 17271                                  ;	  LeftOnLine will be updated to reflect the entry about to be
 17272                                  ;	   displayed.
 17273                                  ;	  LeftOnPage may be updated.
 17274                                  
 17275                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17276                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17277                                  	
 17278                                  DisplayNext:
 17279 000019D5 833E[439E]00            	cmp	word [FileCnt],0
 17280 000019DA 7415                    	je	short dn1st		; 1st file in directory
 17281 000019DC 803E[3D9E]00            	cmp	byte [LeftOnLine],0
 17282 000019E1 7E08                    	jng	short dnEol	; jle	; no more room on this line
 17283                                  
 17284                                  ;	We are in wide mode (LeftOnLine is always 0 otherwise) and
 17285                                  ;	we still have room for more on this line.
 17286                                  ;	Tab to next position.
 17287                                  
 17288 000019E3 BA[C993]                	mov	dx,tab_ptr
 17289 000019E6 E8443B                  	call	std_printf
 17290 000019E9 EB0C                    	jmp	short dnDone
 17291                                  dnEol:	
 17292                                  ;	Start this entry on a new line.
 17293                                  
 17294 000019EB E83311                  	call	CRLF2		; start on new line
 17295 000019EE E8C8FE                  	call	UseLine
 17296                                  dn1st:
 17297 000019F1 A0[3E9E]                	mov	al,[PerLine]
 17298 000019F4 A2[3D9E]                	mov	[LeftOnLine],al	; reset # entries left on line
 17299                                  
 17300                                  dnDone:
 17301 000019F7 FE0E[3D9E]              	dec	byte [LeftOnLine]
 17302                                  				; reflect the entry about to be displayed
 17303 000019FB C3                      	retn
 17304                                  
 17305                                  ; ---------------------------------------------------------------------------
 17306                                  
 17307                                  ;***	DisplayTheRest - display file size/dir, date, time
 17308                                  ;
 17309                                  ;	ENTRY	BX = offset of entry in TPA buffer
 17310                                  ;		Display cursor is at end of file extension
 17311                                  ;
 17312                                  ;	EXIT	nothing
 17313                                  ;
 17314                                  ;	USED	AX,CX,DX,SI,DI,BP
 17315                                  ;
 17316                                  ;	EFFECTS
 17317                                  ;
 17318                                  ;	  File size, date, & time are displayed.
 17319                                  
 17320                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17321                                  
 17322                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17323                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1A7Ch
 17324                                  DisplayTheRest:
 17325 000019FC 06                      	push	es			; save TRANGROUP seg addr
 17326 000019FD 8E06[179E]              	mov	es,[TPA]		; ES = TPA seg addr
 17327 00001A01 89DD                    	mov	bp,bx			; BP = offset of entry in TPA
 17328                                  	;;test	es:[bp].fileattr,ATTR_DIRECTORY
 17329                                  	;test	byte [es:bp+EntryStruc.fileattr],10h
 17330 00001A03 26F6460C10              	test	byte [es:bp+12],ATTR_DIRECTORY
 17331 00001A08 7415                    	jz	short drNonDir		; not a directory file
 17332                                  
 17333                                  ;	For a directory file, display <DIR> instead of size.
 17334                                  
 17335 00001A0A BA[CC93]                	mov	dx,dmes_ptr
 17336 00001A0D E81D3B                  	call	std_printf
 17337                                  	; 08/06/2023
 17338                                  	;jmp	short drCom
 17339                                  
 17340                                  	; 08/06/2023
 17341                                  	; MSDOS 6.22 COMMAND.COM (disassembled source code)
 17342 00001A10 F606[B693]40            	test    byte [screen_f_1],40h	; 80 columns ?
 17343 00001A15 7406                    	jz      short dr_0      	; no
 17344 00001A17 BA[CF93]                	mov     dx,space_4_ptr		; 4 space chars
 17345 00001A1A E8103B                  	call    std_printf
 17346                                  dr_0:
 17347 00001A1D EB16                    	jmp	short drCom		; skip to common fields
 17348                                  
 17349                                  drNonDir:
 17350                                  ;	For a non-directory file, display file size.
 17351                                  
 17352                                  	;;mov	dx,word ptr es:[bp].filesize
 17353                                  	;mov	dx,[es:bp+EntryStruc.filesize]
 17354 00001A1F 268B5611                	mov	dx,[es:bp+17]
 17355 00001A23 8916[B3A0]              	mov	[File_Size_Low],dx
 17356                                  	;;mov	dx,word ptr es:[bp].filesize+2
 17357                                  	;mov	dx,[es:bp+EntryStruc.filesize+2]
 17358 00001A27 268B5613                	mov	dx,[es:bp+19]
 17359 00001A2B 8916[B5A0]              	mov	[File_Size_High],dx
 17360 00001A2F BA[AC93]                	mov	dx,disp_file_size_ptr
 17361 00001A32 E8F83A                  	call	std_printf
 17362                                  drCom:
 17363                                  ;	For all files, display date & time.
 17364                                  
 17365                                  	;;mov	ax,es:[bp].filedate	; AX = date word
 17366                                  	;mov	ax,[es:bp+EntryStruc.filedate]
 17367 00001A35 268B460F                	mov	ax,[es:bp+15]
 17368 00001A39 09C0                    	or	ax,ax			; test for null date (DOS 1.x)
 17369 00001A3B 7448                    	jz	short drDone		; no date, skip date/time display
 17370 00001A3D 89C3                    	mov	bx,ax			; BX = date word
 17371 00001A3F 83E01F                  	and	ax,1Fh			; AX = day of month
 17372 00001A42 88C2                    	mov	dl,al			; DL = day of month
 17373 00001A44 89D8                    	mov	ax,bx			; AX = date word
 17374 00001A46 B105                    	mov	cl,5
 17375 00001A48 D3E8                    	shr	ax,cl			; shift day out
 17376 00001A4A 240F                    	and	al,0Fh			; AL = month
 17377 00001A4C 88C6                    	mov	dh,al			; DH = month
 17378 00001A4E 88F9                    	mov	cl,bh
 17379 00001A50 D0E9                    	shr	cl,1			; CL = year - 1980
 17380 00001A52 30ED                    	xor	ch,ch			; CX = year - 1980
 17381 00001A54 83C150                  	add	cx,80			; CX = 2-digit year
 17382 00001A57 80F964                  	cmp	cl,100
 17383 00001A5A 7203                    	jb	short dr_1		; not year 2000 yet, skip ahead
 17384 00001A5C 80E964                  	sub	cl,100			; adjust for 21st century
 17385                                  dr_1:	
 17386 00001A5F 86F2                    	xchg	dh,dl			; DX = month/day
 17387 00001A61 890E[0D94]              	mov	[DirDat_Yr],cx		; move year to msg block
 17388 00001A65 8916[0F94]              	mov	[DirDat_Mo_Day],dx	; move month/day to msg block
 17389                                  	;;mov	cx,es:[bp].filetime	; CX = file time
 17390                                  	;mov	cx,[es:bp+EntryStruc.filetime]
 17391 00001A69 268B4E0D                	mov	cx,[es:bp+13]
 17392 00001A6D E310                    	jcxz	drPrint			; no time field - go print
 17393 00001A6F D1E9                    	shr	cx,1
 17394 00001A71 D1E9                    	shr	cx,1
 17395 00001A73 D1E9                    	shr	cx,1			; CH = hours
 17396 00001A75 D0E9                    	shr	cl,1
 17397 00001A77 D0E9                    	shr	cl,1			; CL = minutes
 17398 00001A79 86E9                    	xchg	ch,cl			; CX = hr/min
 17399 00001A7B 890E[1894]              	mov	[DirTim_Hr_Min],cx	; move time to msg block
 17400                                  drPrint:
 17401 00001A7F BA[0894]                	mov	dx,dirdattim_ptr
 17402 00001A82 E8A83A                  	call	std_printf		; print date & time
 17403                                  drDone:
 17404 00001A85 07                      	pop	es			; ES = TRANGROUP seg addr again	
 17405 00001A86 89EB                    	mov	bx,bp			; BX = offset of entry in TPA again
 17406                                  ;dtrRet:
 17407                                  	; 19/02/2023
 17408 00001A88 C3                      	retn
 17409                                  
 17410                                  ; ---------------------------------------------------------------------------
 17411                                  ; MSDOS 6.0
 17412                                  
 17413                                  ;ifdef DBLSPACE_HOOKS
 17414                                  
 17415                                  ;***	DisplayCompRatio - display compression ratio
 17416                                  ;
 17417                                  ;	ENTRY	BX = offset of entry in TPA buffer
 17418                                  ;
 17419                                  ;	EXIT	nothing
 17420                                  ;
 17421                                  ;	USED	AX,CX,DX
 17422                                  ;
 17423                                  ;	EFFECTS
 17424                                  ;
 17425                                  ;	  File compression ratio is displayed.
 17426                                  
 17427                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17428                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1B09h
 17429                                  
 17430                                  DisplayCompRatio:	;proc
 17431 00001A89 06                      	push	es			; save TRANGROUP seg addr
 17432 00001A8A 8E06[179E]              	mov	es,[TPA]		; ES = TPA seg addr
 17433                                  	;;mov	al,es:[bx].compratio
 17434                                  	;mov	al,[es:bx+EntryStruc.compratio]
 17435 00001A8E 268A4715                	mov	al,[es:bx+15h]
 17436 00001A92 3CFF                    	cmp	al,0FFh			; invalid/no compression ratio?
 17437 00001A94 7417                    	je	short dcrRet
 17438                                  
 17439 00001A96 88C4                    	mov	ah,al			; unpack compression ratio
 17440 00001A98 B104                    	mov	cl,4
 17441 00001A9A D2EC                    	shr	ah,cl			; isolate whole number portion
 17442 00001A9C FEC4                    	inc	ah			; 0-15 = 1-16
 17443 00001A9E 240F                    	and	al,0Fh 			; isolate tenths
 17444                                  
 17445 00001AA0 8826[BEA0]              	mov	[Dir_CRatio_1],ah
 17446 00001AA4 A2[BFA0]                	mov	[Dir_CRatio_2],al
 17447                                  	;mov	dx,offset TRANGROUP:DirCompRatio_Ptr
 17448                                  	;invoke	Std_Printf
 17449 00001AA7 BA[7894]                	mov	dx,DirCompRatio_Ptr
 17450 00001AAA E8803A                  	call	std_printf	
 17451                                  dcrRet:
 17452 00001AAD 07                      	pop	es
 17453                                  dtrRet:		; 08/06/2023
 17454 00001AAE C3                      	retn
 17455                                  
 17456                                  ;DisplayCompRatio	;endp
 17457                                  
 17458                                  ;endif
 17459                                  
 17460                                  ; ---------------------------------------------------------------------------
 17461                                  
 17462                                  ;***	DisplayTrailer - display trailing lines for directory listing
 17463                                  ;
 17464                                  ;	ENTRY	LeftOnPage = # lines left on display page
 17465                                  ;		FileCnt = # files listed
 17466                                  ;		FileSiz = total size of files listed
 17467                                  ;
 17468                                  ;	EXIT	nothing
 17469                                  ;
 17470                                  ;	USED
 17471                                  ;
 17472                                  ;	EFFECTS
 17473                                  ;
 17474                                  ;	  Trailing info lines are displayed
 17475                                  
 17476                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17477                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17478                                  
 17479                                  DisplayTrailer:
 17480                                  	;;;test	Bits,mask bare
 17481                                  	;;test	word [_Bits],8
 17482                                  	;test	byte [_Bits],8
 17483                                  	; 08/06/2023
 17484 00001AAF F606[A2A0]10            	test	byte [_Bits],mask.bare ; 10h ; MSDOS 6.0
 17485 00001AB4 75F8                    	jnz	short dtrRet		; /b - don't display trailer
 17486                                  
 17487 00001AB6 E86810                  	call	CRLF2			; start on new line
 17488 00001AB9 E8FDFD                  	call	UseLine
 17489 00001ABC A1[439E]                	mov	ax,[FileCnt]		; AX = # files found
 17490                                  
 17491                                  ;	DisplayTotals uses this entry point.
 17492                                  ;
 17493                                  DisplayCntSiz:
 17494                                  ;	AX = # files
 17495                                  ;	FileSiz = dword total size of files
 17496                                  
 17497 00001ABF A3[BCA0]                	mov	[Dir_Num],ax		; load # files
 17498 00001AC2 BA[3392]                	mov	dx,dirmes_ptr		; DX = ptr to message block
 17499 00001AC5 E8653A                  	call	std_printf		; "nnn File(s)"
 17500                                  
 17501 00001AC8 BA[2494]                	mov	dx,bytes_ptr
 17502 00001ACB E85F3A                  	call	std_printf		; "nnn bytes",cr,lf
 17503                                  	; 19/02/2023
 17504                                  	;call	UseLine
 17505                                  ;dtrRet:
 17506                                  	;retn
 17507                                  
 17508                                  	; 19/02/2023
 17509 00001ACE E9E8FD                  	jmp	UseLine
 17510                                  
 17511                                  ; ---------------------------------------------------------------------------
 17512                                  
 17513                                  ;***	DisplayWide - display filename in wide format
 17514                                  ;
 17515                                  ;	ENTRY	BX = offset of entry in TPA buffer
 17516                                  ;
 17517                                  ;	EXIT	nothing
 17518                                  ;
 17519                                  ;	USED	AX,CX,DX,SI,DI
 17520                                  ;
 17521                                  ;	EFFECTS
 17522                                  ;
 17523                                  ;	  Name.ext is displayed. Cursor left at end of field (padded
 17524                                  ;	  with blanks). Subdirectory files are displayed as [name.ext].
 17525                                  
 17526                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17527                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:198Ah
 17528                                  
 17529                                  DisplayWide:
 17530 00001AD1 1E                      	push	ds			; save TRANGROUP seg addr
 17531 00001AD2 8E1E[179E]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 17532                                  	;assume	ds:nothing
 17533                                  
 17534                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 17535                                  	;test	byte [bx+EntryStruc.fileattr],10h
 17536 00001AD6 F6470C10                	test	byte [bx+12],ATTR_DIRECTORY
 17537 00001ADA 9C                      	pushf	; 03/08/2024
 17538 00001ADB 7405                    	jz	short dw1		; not a subdirectory file
 17539 00001ADD B05B                    	mov	al,'['
 17540 00001ADF E86B08                  	call	PRINT_CHAR		; prefix subdirectory
 17541                                  dw1:	
 17542 00001AE2 E8FEFD                  	call	DisplayDotForm		; display name.ext
 17543                                  
 17544                                  ;	DX = # chars displayed in name.ext
 17545                                  
 17546                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 17547                                  	;test	byte [bx+EntryStruc.fileattr],10h
 17548                                  	; 03/08/2024
 17549                                  	;test	byte [bx+12],ATTR_DIRECTORY
 17550 00001AE5 9D                      	popf	; 03/08/2024
 17551 00001AE6 7405                    	jz	short dw2		; not a subdirectory file
 17552 00001AE8 B05D                    	mov	al,']'
 17553 00001AEA E86008                  	call	PRINT_CHAR		; postfix subdirectory
 17554                                  dw2:
 17555                                  ;	Pad field with blanks.
 17556                                  
 17557                                  	;mov	cx,size filename + size fileext + 1
 17558 00001AED B90C00                  	mov	cx,12 ; 8+3+1
 17559                                  					; CX = field size
 17560 00001AF0 29D1                    	sub	cx,dx			; CX = # pad char's
 17561 00001AF2 E307                    	jcxz	dwDone
 17562 00001AF4 B020                    	mov	al,' '
 17563                                  dw3:	
 17564 00001AF6 E85408                  	call	PRINT_CHAR
 17565 00001AF9 E2FB                    	loop	dw3
 17566                                  dwDone:	
 17567 00001AFB 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 17568                                  	;assume	ds:TRANGROUP
 17569 00001AFC C3                      	retn
 17570                                  
 17571                                  ; ---------------------------------------------------------------------------
 17572                                  
 17573                                  ;***	GetDriveLtr - get target drive letter
 17574                                  ;
 17575                                  ;	ENTRY	FCB contains drive #
 17576                                  ;
 17577                                  ;	EXIT	AX = "d:"
 17578                                  ;
 17579                                  ;	USED	nothing
 17580                                  
 17581                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17582                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19D8h
 17583                                  GetDriveLtr:
 17584 00001AFD A05C00                  	mov	al,[FCB] ; 5Ch	; AL = target drive #
 17585 00001B00 08C0                    	or	al,al
 17586 00001B02 7505                    	jnz	short gdl1	; not current drive default, skip ahead
 17587 00001B04 A0[299E]                	mov	al,[CURDRV]	; AL = current drive #
 17588 00001B07 FEC0                    	inc	al		; AL = 1-based drive #
 17589                                  gdl1:	
 17590 00001B09 0440                    	add	al,'A'-1 ; 40h	; AL = target drive letter
 17591 00001B0B B43A                    	mov	ah,':'		; AX = "d:"
 17592 00001B0D C3                      	retn
 17593                                  
 17594                                  ; ---------------------------------------------------------------------------
 17595                                  
 17596                                  ;***	SetupParamError - set up for Std_EPrintf parameter parse error message
 17597                                  ;
 17598                                  ;	Do for our /O and /A string parsers what Parse_With_Msg does
 17599                                  ;	for system parser calls. Set up a message substitution block,
 17600                                  ;	etc. for invalid value strings. I copied the procedure from
 17601                                  ;	Setup_Parse_Error_Msg.
 17602                                  ;
 17603                                  ;	ENTRY	BX = ptr to system parser result buffer (contains ptr to str)
 17604                                  ;		
 17605                                  ;
 17606                                  ;	EXIT	AX = system parser error return code for bad param format
 17607                                  ;		DX = ptr to message description block for Std_EPrintf
 17608                                  ;
 17609                                  ;	USED	SI
 17610                                  ;
 17611                                  ;	EFFECTS
 17612                                  ;
 17613                                  ;	  Msg_Disp_Class = parse error message class
 17614                                  ;	  Message block (see DX) is set up for parse error message
 17615                                  
 17616                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17617                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19E9h
 17618                                  SetupParamError:
 17619 00001B0E B80900                  	mov	ax,9			; parse error #
 17620 00001B11 C606[F191]02            	mov	byte [msg_disp_class],parse_msg_class
 17621                                  	;mov	byte [msg_disp_class],2
 17622 00001B16 A3[F391]                	mov	[extend_buf_ptr],ax
 17623                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 17624 00001B19 8B7704                  	mov	si,[bx+4]
 17625 00001B1C 8936[B7A0]              	mov	[string_ptr_2],si
 17626 00001B20 C606[F591]01            	mov	byte [extend_buf_sub],one_subst
 17627                                  	;mov	byte [extend_buf_sub],1
 17628 00001B25 BA[F391]                	mov	dx,extend_buf_ptr
 17629 00001B28 C3                      	retn
 17630                                  
 17631                                  ; ---------------------------------------------------------------------------
 17632                                  
 17633                                  ;***	ZeroTotals - zero grand total file count, size
 17634                                  ;
 17635                                  ;	ENTRY	nothing
 17636                                  ;
 17637                                  ;	EXIT	nothing
 17638                                  ;
 17639                                  ;	USED	AX
 17640                                  ;
 17641                                  ;	EFFECTS
 17642                                  ;
 17643                                  ;	  FileCntTotal & FileSizTotal are zeroed.
 17644                                  ;
 17645                                  ;	NOTES
 17646                                  ;
 17647                                  ;	  FileCntTotal throuth csecUsedTotal must be together!
 17648                                  
 17649                                  ; 05/06/2023
 17650                                  ;ifdef DBLSPACE_HOOKS
 17651                                  ;csecSIZE EQU size csecUsed + size csecUsedDir + size csecUsedTotal
 17652                                  ;ccluSIZE EQU size ccluUsed + size ccluUsedDir + size ccluUsedTotal
 17653                                  ;endif
 17654                                  
 17655                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17656                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A13h
 17657                                  
 17658                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 17659                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1C08h	
 17660                                  ZeroTotals:
 17661 00001B29 BF[499E]                	mov	di,FileCntTotal
 17662                                  
 17663                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 17664                                  	;;mov	cx,size FileCntTotal+size FileSizTotal
 17665                                  	;mov	cx,8
 17666                                  	;ifdef DBLSPACE_HOOKS
 17667                                  	;mov	cx,size FileCntTotal+size FileSizTotal+csecSIZE+ccluSIZE
 17668                                  	;endif
 17669 00001B2C B91A00                  	mov	cx,26
 17670                                  
 17671 00001B2F 30C0                    	xor	al,al
 17672 00001B31 F3AA                    	rep	stosb
 17673 00001B33 C3                      	retn	
 17674                                  
 17675                                  ; ---------------------------------------------------------------------------
 17676                                  
 17677                                  ;***	CtrlCHandler - our own control-c handler
 17678                                  ;
 17679                                  ;	Make sure user's default directory gets restored. See notes
 17680                                  ;	at InstallCtrlCHandler.
 17681                                  ;
 17682                                  ;	ENTRY	control-c
 17683                                  ;
 17684                                  ;	EXIT	to OldCtrlCHandler
 17685                                  ;
 17686                                  ;	USED	DS,flags
 17687                                  ;
 17688                                  ;	EFFECTS
 17689                                  ;
 17690                                  ;	  Restore user's default directory.
 17691                                  ;
 17692                                  ;	NOTES
 17693                                  ;
 17694                                  ;	  This handler is only installed after calling PathCrunch,
 17695                                  ;	  which sets UserDir1, so the restoration will work.
 17696                                  ;
 17697                                  ;	  The original control-c vector will be restored, whether
 17698                                  ;	  or not this one is invoked, in the HeadFix routine.
 17699                                  
 17700                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17701                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A1Eh
 17702                                  
 17703                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 17704                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1C13h ; *
 17705                                  
 17706                                  CtrlCHandler:	;proc far
 17707                                  
 17708                                  ;SR;
 17709                                  ; Save all registers used: ds, dx, ax. I know ax is being used by the 
 17710                                  ;CtrlC handler, am not sure about ds & dx. Save them to be safe
 17711                                  ;
 17712 00001B34 1E                      	push	ds
 17713 00001B35 0E                      	push	cs
 17714 00001B36 1F                      	pop	ds			; DS = TRANGROUP seg addr
 17715 00001B37 50                      	push	ax
 17716 00001B38 53                      	push	bx ; *
 17717 00001B39 52                      	push	dx
 17718 00001B3A E8A101                  	call	CloseCVF ; * 		; close CVF file if open
 17719 00001B3D E89E0E                  	call	RestUDir		; restore user's default directory
 17720 00001B40 5A                      	pop	dx
 17721 00001B41 5B                      	pop	bx ; *
 17722 00001B42 58                      	pop	ax
 17723 00001B43 1F                      	pop	ds
 17724 00001B44 2EFF2E[DBA9]            	jmp	far [cs:OldCtrlCHandler]
 17725                                  					; go to previous int 23 handler
 17726                                  
 17727                                  ; ---------------------------------------------------------------------------
 17728                                  
 17729                                  ;M010;start
 17730                                  ;***	LowerCase - convert ASCII character in AL to lowercase
 17731                                  ;
 17732                                  ;	ENTRY	AL = character to be displayed
 17733                                  ;
 17734                                  ;	EXIT	AL is lowercase
 17735                                  ;
 17736                                  ;	USED	nothing
 17737                                  
 17738                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17739                                  LowerCase:
 17740 00001B49 3C41                    	cmp	al,'A'		; ensure AL is in range 'A'-'Z'
 17741 00001B4B 7206                    	jb	short lcRet
 17742 00001B4D 3C5A                    	cmp	al,'Z'
 17743 00001B4F 7702                    	ja	short lcRet
 17744                                  
 17745 00001B51 0C20                    	or	al,20h		; convert to ASCII lowercase (UpperCase+32)-->LowerCase
 17746                                  lcRet:
 17747 00001B53 C3                      	retn
 17748                                  
 17749                                  ; ---------------------------------------------------------------------------
 17750                                  
 17751                                  ;***	LowercaseString - convert ASCIIZ string at DS:SI to lowercase
 17752                                  ;
 17753                                  ;	ENTRY	DS:SI points to start of ASCIIZ string
 17754                                  ;		ES = DS
 17755                                  ;
 17756                                  ;	EXIT	nothing
 17757                                  ;	
 17758                                  ;	USED	AL,SI
 17759                                  
 17760                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17761                                  LowercaseString:
 17762 00001B54 57                      	push	di			; save di
 17763 00001B55 89F7                    	mov	di,si			; ES:DI --> ASCIIZ string
 17764 00001B57 FC                      	cld
 17765                                  NextChar: 
 17766 00001B58 AC                      	lodsb				; get character from string into al
 17767 00001B59 08C0                    	or	al,al			; are we at end of string?
 17768 00001B5B 7406                    	jz	short EndOfString
 17769                                  
 17770 00001B5D E8E9FF                  	call	LowerCase		; convert character to lowercase
 17771 00001B60 AA                      	stosb				; store character back into buffer
 17772 00001B61 EBF5                    	jmp	short NextChar		; repeat until end of string
 17773                                  
 17774                                  EndOfString:
 17775 00001B63 5F                      	pop	di			; restore di
 17776 00001B64 C3                      	retn
 17777                                  
 17778                                  ;M010;end
 17779                                  
 17780                                  
 17781                                  ; 08/06/2023
 17782                                  ; ---------------------------------------------------------------------------
 17783                                  ; MSDOS 6.2(2) COMMAND.COM procedure only !
 17784                                  ; -----------------------------------------
 17785                                  ; Hex-Rays IDA / disassembled source code ! modified for NASM by Erdogan Tan
 17786                                  ; ---------------------------------------------------------------------------
 17787                                  
 17788                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17789                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1C44h
 17790                                  screen_f_set:
 17791                                  	; set dir display parameters depending on screen width (# of columns)
 17792 00001B65 1E                      	push	ds
 17793 00001B66 B84000                  	mov	ax,40h
 17794 00001B69 8ED8                    	mov	ds,ax
 17795 00001B6B 833E4A0028              	cmp	word [4Ah],40	; Check ROMBIOS DATA colums per row
 17796                                  				; value (80 or 40)
 17797 00001B70 1F                      	pop	ds
 17798 00001B71 7527                    	jnz	short columns_80 ; 80 columns per line (video mode 3)
 17799 00001B73 8026[B693]BF            	and	byte [screen_f_1],0BFh ; ~40h
 17800 00001B78 C706[B793]0A0A          	mov	word [screen_f_2],0A0Ah ; 10 bytes (file size field)
 17801 00001B7E 8026[3D92]BF            	and	byte [screen_f_3],0BFh
 17802 00001B83 8026[2E94]BF            	and	byte [screen_f_4],0BFh
 17803 00001B88 C706[2F94]0A0A          	mov	word [screen_f_5],0A0Ah ; 10 bytes (file size field)
 17804 00001B8E 8026[4B92]BF            	and	byte [screen_f_6],0BFh
 17805 00001B93 C706[4C92]1C1C          	mov	word [screen_f_7],1C1Ch ; 28 bytes (free bytes field)
 17806                                  	;jmp	short screen_f_set_retn
 17807 00001B99 C3                      	retn
 17808                                  columns_80:
 17809 00001B9A 800E[B693]40            	or	byte [screen_f_1],40h
 17810 00001B9F C706[B793]0E0E          	mov	word [screen_f_2],0E0Eh ; 14 bytes (file size field)
 17811 00001BA5 800E[3D92]40            	or	byte [screen_f_3],40h
 17812 00001BAA 800E[2E94]40            	or	byte [screen_f_4],40h
 17813 00001BAF C706[2F94]0E0E          	mov	word [screen_f_5],0E0Eh ; 14 bytes (file size field)
 17814 00001BB5 800E[4B92]40            	or	byte [screen_f_6],40h
 17815 00001BBA C706[4C92]2020          	mov	word [screen_f_7],2020h ; 32 bytes (free bytes field)
 17816                                  screen_f_set_retn:
 17817 00001BC0 C3                      	retn
 17818                                  
 17819                                  ;============================================================================
 17820                                  ; CRATIO.ASM, MSDOS 6.0, 1992
 17821                                  ;============================================================================
 17822                                  ; 08/06/2023 - Retro DOS v4.2
 17823                                  
 17824                                  ; The code to calculate compression ratios requires access to the drive's
 17825                                  ; (DOS) FAT and MagicDrv FAT regions.  Two buffers are used (one for each
 17826                                  ; FAT type).  pbufDOSFAT and pbufMDFAT contain the offset to the buffers,
 17827                                  ; segFATBuf contains the segment (both buffers are in the same segment).
 17828                                  ; The buffers are of variable size: cFATEntries contains the size of the
 17829                                  ; buffers in terms of the number of FAT entries they can contain.
 17830                                  
 17831                                  ; ---------------------------------------------------------------------------
 17832                                  
 17833                                  ;***	OpenCVF - open Compressed Volume File for compression ratio report
 17834                                  ;
 17835                                  ;	ENTRY
 17836                                  ;		FCB setup with drive for DIR
 17837                                  ;
 17838                                  ;	EXIT	If successful, CY clear, CVF file open, fhCVF has file handle,
 17839                                  ;		szCVF has \0 terminated CVF file name, MDBPB loaded.
 17840                                  ;
 17841                                  ;		If unsuccessful, CY set
 17842                                  ;
 17843                                  ;	USED	AX, BX, CX, DX, SI, DI
 17844                                  
 17845                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17846                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1CA1h
 17847                                  OpenCVF:
 17848 00001BC1 B8FFFF                  	mov	ax,-1
 17849 00001BC4 A3[639E]                	mov	[fhCVF],ax		;indicate CVF not open
 17850 00001BC7 A3[B99E]                	mov	[entInBuf],ax		;  and no FAT entries in buffers
 17851                                  
 17852 00001BCA 8A165C00                	mov	dl,[FCB] ; mov dl,5Ch	;target drive of DIR cmd
 17853 00001BCE 08D2                    	or	dl,dl			;default drive?
 17854 00001BD0 7404                    	jz	short ocvf_default
 17855 00001BD2 FECA                    	dec	dl			;no, from 1=A to 0=A
 17856 00001BD4 EB04                    	jmp	short ocvf_swap_info
 17857                                  
 17858                                  ocvf_default:
 17859 00001BD6 8A16[299E]              	mov	dl,[CURDRV]		;0=A, 1=B, ...
 17860                                  
 17861                                  ocvf_swap_info:
 17862 00001BDA B8114A                  	mov	ax,4A11h ; multMagicDrv	;magicdrv Int 2Fh multiplex ID
 17863 00001BDD BB0100                  	mov	bx,1	 ; MD_DRIVE_MAP	;get drive swap info
 17864 00001BE0 CD2F                    	int	2fh
 17865                                  
 17866 00001BE2 09C0                    	or	ax,ax			;0 if okay
 17867 00001BE4 7573                    	jnz	short ocvf_error
 17868                                  
 17869 00001BE6 F6C380                  	test	bl,80h 			;80h set if compressed volume
 17870 00001BE9 746E                    	jz	short ocvf_error
 17871                                  
 17872 00001BEB 80E37F                  	and	bl,7Fh 			;bl = host drive, bh = seq #
 17873                                  
 17874                                  	; The CVF may have been mounted from a swapped host drive, in which
 17875                                  	; case the host drive returned in BL is the original host (now
 17876                                  	; swapped with a CVF).	Make a second drive swap info call on the
 17877                                  	; returned host to see if it must be accessed by a different drive
 17878                                  	; letter.
 17879                                  
 17880 00001BEE 53                      	push	bx
 17881 00001BEF 52                      	push	dx			;save dl, orig drive letter
 17882                                  
 17883 00001BF0 B8114A                  	mov	ax,4A11h ; mov ax,multMagicDrv
 17884 00001BF3 88DA                    	mov	dl,bl
 17885 00001BF5 BB0100                  	mov	bx,1	 ; mov bx,MD_DRIVE_MAP
 17886 00001BF8 CD2F                    	int	2fh
 17887                                  
 17888 00001BFA 5A                      	pop	dx
 17889 00001BFB 59                      	pop	cx			;bx from 1st drive swap info call
 17890                                  
 17891 00001BFC 09C0                    	or	ax,ax			;0 if okay
 17892 00001BFE 7559                    	jnz	short ocvf_error
 17893                                  
 17894 00001C00 80E37F                  	and	bl,7Fh
 17895 00001C03 87D9                    	xchg	bx,cx			;bx = 1st, cx = 2nd swap results
 17896                                  
 17897 00001C05 38CA                    	cmp	dl,cl			;2nd swap info call return orig drive?
 17898 00001C07 7402                    	je	short ocvf_got_host	;yes, 1st swap info call returned host
 17899                                  
 17900 00001C09 88CB                    	mov	bl,cl			;no, use swapped host, orig seq #
 17901                                  ocvf_got_host:
 17902                                  	; Build the filename of the Compressed Volume File
 17903                                  
 17904                                  	;mov	di,offset TRANGROUP:szCVF
 17905                                  					;CVF name buffer
 17906 00001C0B BF[659E]                	mov	di,szCVF
 17907                                  
 17908 00001C0E 88D8                    	mov	al,bl
 17909 00001C10 0441                    	add	al,'A'
 17910 00001C12 B43A                    	mov	ah,':'
 17911 00001C14 FC                      	cld
 17912 00001C15 AB                      	stosw				; drive:
 17913                                  
 17914                                  	;mov	si,offset TRANGROUP:sCVFRoot
 17915                                  					; \name.
 17916 00001C16 BE[2699]                	mov	si,sCVFRoot	; "\DBLSPACE"
 17917                                  	;mov	cx,cbCVFRoot
 17918 00001C19 B90A00                  	mov	cx,10
 17919 00001C1C F3A4                    	rep	movsb
 17920                                  
 17921 00001C1E 83C703                  	add	di,3			; point past extension
 17922 00001C21 30C0                    	xor	al,al
 17923 00001C23 FD                      	std
 17924 00001C24 AA                      	stosb				; null terminate
 17925                                  
 17926 00001C25 88F8                    	mov	al,bh			; seq #
 17927 00001C27 B30A                    	mov	bl,10
 17928                                  	;mov	cx,3			; 3 digit ext/seq #
 17929 00001C29 B103                    	mov	cl,3
 17930                                  ;@@:
 17931 00001C2B 30E4                    ocvf_1:	xor	ah,ah			; convert seq # to ascii
 17932 00001C2D F6F3                    	div	bl			;   and store as CVF extension
 17933 00001C2F 80C430                  	add	ah,'0'
 17934 00001C32 86E0                    	xchg	ah,al
 17935 00001C34 AA                      	stosb
 17936 00001C35 88E0                    	mov	al,ah
 17937                                  	;loop	@b
 17938 00001C37 E2F2                    	loop	ocvf_1
 17939                                  
 17940 00001C39 FC                      	cld
 17941                                  
 17942                                  	; Now open the Compressed Volume File
 17943                                  
 17944                                  	; 08/06/2023
 17945                                  	; MSDOS 6.22 COMMAND.COM code only !
 17946                                  	;;;
 17947 00001C3A BF[659E]                	mov	di,szCVF ; *
 17948 00001C3D C745045256              	mov	word [di+4],5652h ; 'RV' (DRVSPACE)
 17949 00001C42 B8003D                  	mov	ax,3D00h
 17950                                  	;mov	dx,szCVF
 17951 00001C45 89FA                    	mov	dx,di ; *
 17952 00001C47 CD21                    	int	21h     ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
 17953                                  			; DS:DX -> ASCIZ filename
 17954                                  			; AL = access mode
 17955                                  			; 0 - read
 17956 00001C49 7310                    	jnb     short ocvf_2
 17957 00001C4B C74504424C              	mov	word [di+4],4C42h ; 'BL' (DBLSPACE)
 17958                                  	;;;
 17959                                  
 17960                                  	;mov	ax,(OPEN shl 8) or 00h 	;compatibility mode/read access
 17961 00001C50 B8003D                  	mov	ax,3D00h
 17962                                  	;;mov	dx,offset TRANGROUP:szCVF
 17963                                  	;mov	dx,szCVF
 17964 00001C53 89FA                    	mov	dx,di ; *
 17965 00001C55 CD21                    	int	21h
 17966                                  	;jc	short ocvf_error
 17967                                  	; 18/06/2023
 17968 00001C57 7302                    	jnc	short ocvf_2
 17969                                  ocvf_error:	; 18/06/2023
 17970 00001C59 F9                      	stc				;indicate failure
 17971 00001C5A C3                      	retn
 17972                                  ocvf_2:
 17973 00001C5B A3[639E]                	mov	[fhCVF],ax		; success, save CVF file handle
 17974                                  
 17975                                  	; Read the extended MagicDrv BPB
 17976                                  
 17977 00001C5E 89C3                    	mov	bx,ax
 17978                                  	;mov	ah,READ
 17979 00001C60 B43F                    	mov	ah,3Fh
 17980                                  	;mov	cx,size MD_BPB
 17981 00001C62 B94000                  	mov	cx,64
 17982                                  	;mov	dx,offset TRANGROUP:MDBPB
 17983 00001C65 BA[759E]                	mov	dx,MDBPB
 17984 00001C68 CD21                    	int	21h
 17985 00001C6A 7204                    	jc	short ocvf_error1
 17986                                  
 17987 00001C6C 39C8                    	cmp	ax,cx			; get it all?
 17988 00001C6E 7405                    	je	short ocvf_pick_cluster_size
 17989                                  					; yes...
 17990                                  ocvf_error1:
 17991 00001C70 E86B00                  	call	CloseCVF
 17992                                  	; 18/06/2023
 17993                                  ;ocvf_error:
 17994 00001C73 F9                      	stc				;indicate failure
 17995                                  	;jmp	short ocvf_ret
 17996 00001C74 C3                      	retn
 17997                                  
 17998                                  	; Determine the cluster size to use for ratio calculation
 17999                                  
 18000                                  ocvf_pick_cluster_size:
 18001 00001C75 803E[B69E]00            	cmp	byte [fUseHostSize],0 	; user want Host drive cluster size?
 18002 00001C7A 7411                    	je	short ovcf_use_CVF_size	; no, use CVF cluster size
 18003                                  
 18004                                  	;mov	ah,Get_Drive_Data	; get the host drive cluster size
 18005 00001C7C B41C                    	mov	ah,1Ch
 18006 00001C7E 8A16[659E]              	mov	dl,[szCVF]
 18007                                  	;sub	dl,40h	
 18008 00001C82 80EA40                  	sub	dl,'A'-1		; 1 = A, 2 = B, ...
 18009 00001C85 1E                      	push	ds
 18010 00001C86 CD21                    	int	21h
 18011 00001C88 1F                      	pop	ds
 18012                                  
 18013 00001C89 3CFF                    	cmp	al,0FFh			; host drive cluster size in AL if okay,
 18014 00001C8B 7503                    	jne	short ovcf_set_size	;   failed = 0FFh
 18015                                  
 18016                                  ovcf_use_CVF_size:
 18017                                  	;mov	al,[MDBPB.dos_bpb.csecPerClu]
 18018 00001C8D A0[829E]                	mov	al,[MDBPB+0Dh]		; using CVF cluster size
 18019                                  
 18020                                  ovcf_set_size:
 18021 00001C90 A2[B59E]                	mov	[csecPerCluster],al
 18022                                  
 18023                                  	; Lastly, setup the FAT buffers
 18024                                  ocvf_set_buf:
 18025 00001C93 A1[369E]                	mov	ax,[BYTCNT]		; if >= 32k TPA space available,
 18026 00001C96 A3[389E]                	mov	[savBytCnt],ax		;   setup larger FAT buffers
 18027 00001C99 3D0080                  	cmp	ax,32*1024  ; 8000h
 18028 00001C9C 7318                    	jae	short ocvf_big_buf
 18029                                  
 18030                                  	; small TPA, use small resident buffers
 18031                                  
 18032                                  	;mov	word ptr [cFATEntries],cRES_FAT_ENTRIES
 18033 00001C9E C706[B79E]2000          	mov	word [cFATEntries],32 ; cRES_FAT_ENTRIES
 18034 00001CA4 8C1E[BB9E]              	mov	[segFATBuf],ds
 18035                                  	;mov	word ptr [pbufDOSFAT],offset TRANGROUP:bufDOSFAT
 18036                                  	;mov	word ptr [pbufMDFAT],offset TRANGROUP:bufMDFAT
 18037 00001CA8 C706[BD9E][C19E]        	mov	word [pbufDOSFAT],bufDOSFAT
 18038 00001CAE C706[BF9E][019F]        	mov	word [pbufMDFAT],bufMDFAT
 18039                                  	;jmp	short ocvf_success
 18040                                  	; 08/06/2023
 18041                                  	; cf = 1
 18042 00001CB4 F8                      	clc
 18043 00001CB5 C3                      	retn
 18044                                  
 18045                                  ocvf_big_buf:
 18046                                  	;mov	bx,cBIG_FAT_ENTRIES
 18047 00001CB6 BB0001                  	mov	bx,256
 18048 00001CB9 891E[B79E]              	mov	[cFATEntries],bx
 18049                                  
 18050 00001CBD D1E3                    	shl	bx,1			; 6 bytes per entry (2 for DOS FAT, 4 MD FAT)
 18051 00001CBF 89D9                    	mov	cx,bx			; entries * 2
 18052 00001CC1 D1E3                    	shl	bx,1
 18053 00001CC3 01CB                    	add	bx,cx			; bx = # entries * 6
 18054                                  
 18055 00001CC5 29D8                    	sub	ax,bx			; reduce TPA size by size of FAT buffers
 18056 00001CC7 2500FE                  	and	ax,0FE00h		; init code rounds BytCnt down to multiple of
 18057 00001CCA A3[369E]                	mov	[BYTCNT],ax		;   512 bytes -- a no-op with some buf sizes.
 18058                                  
 18059 00001CCD 8B1E[179E]              	mov	bx,[TPA]		; buffers in the TPA
 18060 00001CD1 891E[BB9E]              	mov	[segFATBuf],bx
 18061 00001CD5 A3[BD9E]                	mov	[pbufDOSFAT],ax		; DOS FAT buffer offset
 18062 00001CD8 01C8                    	add	ax,cx			;   + DOS FAT buffer size
 18063 00001CDA A3[BF9E]                	mov	[pbufMDFAT],ax 		;   = MD FAT buffer offset
 18064                                  	; 08/06/2023
 18065                                  	; cf = 0
 18066                                  ;ocvf_success:
 18067                                  	;clc				;indicate success
 18068                                  ocvf_ret:
 18069 00001CDD C3                      	retn
 18070                                  
 18071                                  ; ---------------------------------------------------------------------------
 18072                                  
 18073                                  ;***	CloseCVF - close Compressed Volume File
 18074                                  ;
 18075                                  ;	ENTRY	fhCVF has file handle
 18076                                  ;
 18077                                  ;	EXIT
 18078                                  ;
 18079                                  ;	USED	AX, BX, CX, DX
 18080                                  
 18081                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18082                                  CloseCVF:
 18083 00001CDE 8B1E[639E]              	mov	bx,[fhCVF]		; -1 unless file is open
 18084 00001CE2 83FBFF                  	cmp	bx,-1 ; 0FFFFh
 18085 00001CE5 7410                    	je	short ccvf_ret
 18086                                  
 18087                                  	;mov	ah,CLOSE
 18088 00001CE7 B43E                    	mov	ah,3Eh
 18089 00001CE9 CD21                    	int	21h
 18090                                  
 18091 00001CEB C706[639E]FFFF          	mov	word [fhCVF],-1 ; 0FFFFh ; don't try to close again
 18092                                  
 18093 00001CF1 A1[389E]                	mov	ax,[savBytCnt]		; 'deallocate' DOS & MD FAT buffers
 18094 00001CF4 A3[369E]                	mov	[BYTCNT],ax		;   by restoring old TPA byte count
 18095                                  ccvf_ret:
 18096 00001CF7 C3                      	retn
 18097                                  
 18098                                  ; ---------------------------------------------------------------------------
 18099                                  
 18100                                  ;***	CalcCompRatio - calculate file compression ratio
 18101                                  ;
 18102                                  ;	ENTRY	AX = starting cluster of file to get compression ratio of
 18103                                  ;
 18104                                  ;	EXIT	AX = compression ratio.  Example: a ratio of 2.7 to 1.0
 18105                                  ;		     will return AH = 02h & AL = 07h
 18106                                  ;		ccluUsed set to # DOS clusters used by file
 18107                                  ;		csecUsed set to # compressed sectors used by file
 18108                                  ;		ccluUsedDir, ccluUsedTotal, csecUsedDir, csecUsedTotal updated
 18109                                  ;	USED	none
 18110                                  
 18111                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18112                                  CalcCompRatio:
 18113 00001CF8 53                      	push	bx
 18114 00001CF9 51                      	push	cx
 18115 00001CFA 52                      	push	dx
 18116 00001CFB 06                      	push	es
 18117 00001CFC 8E06[BB9E]              	mov	es,[segFATBuf]		; es is pointer to FAT buffers
 18118                                  	;assume	es:nothing
 18119                                  
 18120 00001D00 31DB                    	xor	bx,bx			; zero count of sectors & clusters used
 18121 00001D02 891E[519E]              	mov	[ccluUsed],bx
 18122 00001D06 891E[579E]              	mov	[csecUsed],bx
 18123 00001D0A 891E[599E]              	mov	[csecUsed+2],bx
 18124                                  ccr_next:
 18125 00001D0E 83F802                  	cmp	ax,2			; sanity check the DOS FAT value
 18126 00001D11 7250                    	jb	short ccr_screwy
 18127                                  
 18128 00001D13 83F8F0                  	cmp	ax,0FFF0h		; end of file?
 18129 00001D16 7352                    	jae	short ccr_eof
 18130                                  
 18131 00001D18 E84701                  	call	CheckFATBuffers 	; make sure buffers contain target
 18132 00001D1B 7246                    	jc	short ccr_screwy	;   FAT entries
 18133                                  
 18134 00001D1D E82901                  	call	GetMDFATEntry		; returns corresponding entry in BX:CX
 18135 00001D20 7241                    	jc	short ccr_screwy
 18136                                  
 18137 00001D22 D1E3                    	shl	bx,1			; used bit to CY
 18138 00001D24 733D                    	jnc	short ccr_screwy	; better be used!
 18139                                  
 18140 00001D26 88FD                    	mov	ch,bh			; save uncompressed count
 18141                                  
 18142 00001D28 D1E3                    	shl	bx,1			; get count into position
 18143 00001D2A 81E3000F                	and	bx,0F00h		; bh = count of compressed sectors used
 18144 00001D2E 86FB                    	xchg	bh,bl			; bx = count
 18145 00001D30 43                      	inc	bx			; 0 - 15 means 1 - 16 used
 18146                                  
 18147 00001D31 011E[579E]              	add	[csecUsed],bx
 18148 00001D35 8316[599E]00            	adc	word [csecUsed+2],0
 18149                                  
 18150 00001D3A 89C2                    	mov	dx,ax			; save cluster # in dx
 18151                                  
 18152 00001D3C 88E8                    	mov	al,ch			; uncompressed count to al
 18153 00001D3E B103                    	mov	cl,3
 18154 00001D40 D2E8                    	shr	al,cl			; get uncompressed count into position
 18155 00001D42 83E00F                  	and	ax,000Fh		; ax = uncompressed count (0 - 15)
 18156 00001D45 4B                      	dec	bx			; bx = compressed count (0 - 15)
 18157 00001D46 39D8                    	cmp	ax,bx			; if the compressed cnt > uncompressed
 18158                                  	;jae	@f			;   fudge a little and use the larger
 18159 00001D48 7302                    	jae	short ccr_1 ; jnb
 18160 00001D4A 89D8                    	mov	ax,bx
 18161                                  ;@@:	
 18162                                  ccr_1:
 18163 00001D4C 8A0E[B59E]              	mov	cl,[csecPerCluster]	; round up to the number of clusters
 18164 00001D50 30ED                    	xor	ch,ch			;   required for uncompressed
 18165 00001D52 01C8                    	add	ax,cx			;   sectors
 18166 00001D54 F6F1                    	div	cl
 18167 00001D56 30E4                    	xor	ah,ah
 18168 00001D58 0106[519E]              	add	[ccluUsed],ax
 18169                                  
 18170 00001D5C 89D0                    	mov	ax,dx			; restore cluster #
 18171 00001D5E E8A900                  	call	GetDOSFATEntry		; retuns next DOS FAT entry in AX
 18172                                  	;jc	short ccr_screwy
 18173                                  	;jmp	short ccr_next
 18174                                  	; 08/06/2023
 18175 00001D61 73AB                    	jnc	short ccr_next
 18176                                  ccr_screwy:
 18177 00001D63 31C0                    	xor	ax,ax			; something screwy happened, set
 18178                                  					;   ratio to 0.0 and exit
 18179                                  ccr_ret:
 18180 00001D65 07                      	pop	es
 18181 00001D66 5A                      	pop	dx
 18182 00001D67 59                      	pop	cx
 18183 00001D68 5B                      	pop	bx
 18184 00001D69 C3                      	retn
 18185                                  
 18186                                  	; Reached the end-of-file, now calculate the ratio as the
 18187                                  	; number of DOS sectors used / number of compressed sectors used.
 18188                                  
 18189                                  ccr_eof:
 18190 00001D6A A1[519E]                	mov	ax,[ccluUsed]
 18191 00001D6D 0106[539E]              	add	[ccluUsedDir],ax	; update cluster used totals
 18192 00001D71 0106[559E]              	add	[ccluUsedTotal],ax
 18193                                  
 18194 00001D75 8B0E[599E]              	mov	cx,[csecUsed+2]
 18195 00001D79 8B1E[579E]              	mov	bx,[csecUsed]		; cx:bx = # compressed sectors used
 18196                                  
 18197 00001D7D 011E[5B9E]              	add	[csecUsedDir],bx	; update sector used totals
 18198 00001D81 110E[5D9E]              	adc	[csecUsedDir+2],cx
 18199 00001D85 011E[5F9E]              	add	[csecUsedTotal],bx
 18200 00001D89 110E[619E]              	adc	[csecUsedTotal+2],cx
 18201                                  
 18202 00001D8D E80200                  	call	ComputeRatio		; ax=clusters used, cx:bx=sectors used
 18203                                  
 18204 00001D90 EBD3                    	jmp	short ccr_ret
 18205                                  
 18206                                  	; 08/06/2023
 18207                                  ;ccr_screwy:
 18208                                  ;	xor	ax,ax			; something screwy happened, set
 18209                                  ;					;   ratio to 0.0 and exit
 18210                                  ;ccr_ret:
 18211                                  ;	pop	es
 18212                                  ;	pop	dx
 18213                                  ;	pop	cx
 18214                                  ;	pop	bx
 18215                                  ;	retn
 18216                                  
 18217                                  ; ---------------------------------------------------------------------------
 18218                                  
 18219                                  ;***	ComputeRatio - calculate ratio of compressed sectors used to
 18220                                  ;		       (would be) DOS sectors used
 18221                                  ;
 18222                                  ;	Entry
 18223                                  ;		AX = DOS clusters used, cx:bx = compressed sectors used
 18224                                  ;	Exit
 18225                                  ;		ah = whole portion, al = tenths
 18226                                  ;
 18227                                  ;	Used	BX, CX, DX
 18228                                  
 18229                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18230                                  ComputeRatio:
 18231 00001D92 56                      	push	si
 18232 00001D93 57                      	push	di
 18233                                  
 18234 00001D94 89DE                    	mov	si,bx
 18235 00001D96 89CF                    	mov	di,cx			; save cx:bx in di:si
 18236                                  
 18237 00001D98 8A1E[B59E]              	mov	bl,[csecPerCluster]
 18238 00001D9C 30FF                    	xor	bh,bh
 18239 00001D9E F7E3                    	mul	bx			; dx:ax = # DOS sectors used
 18240 00001DA0 89F3                    	mov	bx,si			; restore bx
 18241                                  
 18242 00001DA2 E83800                  	call	Div32			; dx:ax = quotient, cx:bx = remainder
 18243                                  
 18244 00001DA5 50                      	push	ax			; save quotient
 18245                                  
 18246 00001DA6 89D8                    	mov	ax,bx			; if no remainder, tenths will be 0
 18247 00001DA8 09C8                    	or	ax,cx			;   which is in AX so skip following
 18248 00001DAA 7423                    	jz	short cr_got_tenths	;   (happens frequently)
 18249                                  
 18250                                  	; Multiply the reminder by 10, add half the divisor so result is
 18251                                  	; rounded up, and divide again to get tenths digit
 18252                                  
 18253 00001DAC 89C8                    	mov	ax,cx
 18254 00001DAE 31D2                    	xor	dx,dx
 18255 00001DB0 89D9                    	mov	cx,bx
 18256 00001DB2 BB0A00                  	mov	bx,10
 18257 00001DB5 F7E3                    	mul	bx
 18258 00001DB7 91                      	xchg	ax,cx
 18259 00001DB8 F7E3                    	mul	bx
 18260 00001DBA 01CA                    	add	dx,cx			; dx:ax = remainder * 10
 18261                                  
 18262 00001DBC 89F9                    	mov	cx,di
 18263 00001DBE 89F3                    	mov	bx,si
 18264 00001DC0 D1E9                    	shr	cx,1
 18265 00001DC2 D1DB                    	rcr	bx,1			; cx:bx = 1/2 divisor
 18266 00001DC4 01D8                    	add	ax,bx
 18267 00001DC6 11CA                    	adc	dx,cx			; dx:ax = remainder * 10 + 1/2 divisor
 18268                                  
 18269 00001DC8 89F9                    	mov	cx,di
 18270 00001DCA 89F3                    	mov	bx,si
 18271                                  
 18272 00001DCC E80E00                  	call	Div32
 18273                                  
 18274                                  cr_got_tenths:
 18275 00001DCF 5B                      	pop	bx			; original quotient
 18276 00001DD0 88DC                    	mov	ah,bl
 18277                                  
 18278 00001DD2 3C0A                    	cmp	al,10			; if the tenths rounded up to the
 18279 00001DD4 7204                    	jb	short cr_exit 		;   next whole number, adjust the
 18280                                  					;   whole number part and 0 the
 18281 00001DD6 FEC4                    	inc	ah			;   tenths  (i.e. round 1.97 to 2.0)
 18282 00001DD8 30C0                    	xor	al,al
 18283                                  cr_exit:
 18284 00001DDA 5F                      	pop	di
 18285 00001DDB 5E                      	pop	si
 18286                                  
 18287 00001DDC C3                      	retn
 18288                                  
 18289                                  ; --------------------------------------------------------------------------- 
 18290                                  
 18291                                  ;***	Div32 - 32 bit divide for computing ratios
 18292                                  ;
 18293                                  ;	Entry	DX:AX = dividend, CX:BX = divisor
 18294                                  ;
 18295                                  ;	Exit	DX:AX = quotient, CX:BX = reminder
 18296                                  
 18297                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18298                                  Div32:
 18299 00001DDD E322                    	jcxz	d32_16bit		; differently if 16bit divisor
 18300                                  
 18301 00001DDF 56                      	push	si
 18302 00001DE0 57                      	push	di
 18303                                  
 18304                                  	; Brute force divide by subtraction. This is okay because worse case
 18305                                  	; the dividend will only be 16 times greater, and typically about 2
 18306                                  	; times
 18307                                  
 18308 00001DE1 31F6                    	xor	si,si
 18309 00001DE3 89F7                    	mov	di,si			; di:si is quotient
 18310                                  ;@@:
 18311                                  div32_1:
 18312 00001DE5 29D8                    	sub	ax,bx			; subtract divisor
 18313 00001DE7 19CA                    	sbb	dx,cx
 18314 00001DE9 7208                    	jc	short d32_too_far
 18315                                  
 18316 00001DEB 83C601                  	add	si, 1			; accumulate quotient
 18317 00001DEE 83D700                  	adc	di, 0
 18318                                  	;jmp	short @b
 18319 00001DF1 EBF2                    	jmp	short div32_1
 18320                                  
 18321                                  d32_too_far:
 18322 00001DF3 01D8                    	add	ax,bx			; fix the last subtraction
 18323 00001DF5 11CA                    	adc	dx,cx
 18324                                  
 18325 00001DF7 89F9                    	mov	cx,di
 18326 00001DF9 89F3                    	mov	bx,si			; dx:ax = remainder, cx:bx = quoient
 18327                                  
 18328 00001DFB 93                      	xchg	ax,bx
 18329 00001DFC 87D1                    	xchg	dx,cx			; dx:ax = quoient, cx:bx = remainder
 18330                                  
 18331 00001DFE 5F                      	pop	di
 18332 00001DFF 5E                      	pop	si
 18333                                  
 18334 00001E00 C3                      	retn
 18335                                  
 18336                                  d32_16bit:
 18337 00001E01 F7F3                    	div	bx			; divide dx:ax by bx
 18338                                  
 18339 00001E03 89D3                    	mov	bx,dx			; remainder to cx:bx
 18340 00001E05 31D2                    	xor	dx,dx			; quotient to dx:ax
 18341 00001E07 89D1                    	mov	cx,dx
 18342 00001E09 C3                      	retn
 18343                                  
 18344                                  ; --------------------------------------------------------------------------- 
 18345                                  
 18346                                  ;***	GetDOSFATEntry - returns next cluster in file's FAT chain
 18347                                  ;
 18348                                  ;	Entry	AX = current cluster number
 18349                                  ;		ES = segment of FAT buffer
 18350                                  ;		Entry should be in FAT buffer
 18351                                  ;
 18352                                  ;	Exit	AX = next cluster number
 18353                                  ;		CY set if error
 18354                                  ;
 18355                                  ;	Uses	BX
 18356                                  
 18357                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18358                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1EF2h
 18359                                  GetDOSFATEntry:
 18360 00001E0A 2B06[B99E]              	sub	ax,[entInBuf]		; calc entry # in buffer
 18361 00001E0E 7212                    	jc	short gdf_ret 		; CY already set for error
 18362                                  
 18363 00001E10 89C3                    	mov	bx,ax
 18364                                  
 18365                                  	;cmp	MDBPB.f12BitFAT, 0	; 12 or 16 bit FAT?
 18366 00001E12 803E[B29E]00            	cmp	byte [MDBPB+3Dh],0
 18367 00001E17 750A                    	jnz	short gdf_12		; go do 12
 18368                                  
 18369 00001E19 D1E3                    	shl	bx,1			; offset = entry * 2
 18370 00001E1B 031E[BD9E]              	add	bx,[pbufDOSFAT]
 18371 00001E1F 268B07                  	mov	ax,[es:bx]
 18372                                  	; 08/06/2023
 18373                                  	; cf = 0
 18374                                  ;gdf_success:
 18375                                  	;clc				; success
 18376                                  gdf_ret:
 18377 00001E22 C3                      	retn
 18378                                  
 18379                                  gdf_12:
 18380 00001E23 D1EB                    	shr	bx,1
 18381 00001E25 01C3                    	add	bx,ax			; offset to entry = entry * 1.5
 18382 00001E27 031E[BD9E]              	add	bx,[pbufDOSFAT]
 18383                                  
 18384                                  ;	ES:BX points to the word containing the desired 12 bit FAT entry.
 18385                                  ;	For odd entries, the upper 12 bits are valid, for even entries
 18386                                  ;	the low 12 bits are valid.  odd: OOOx  even: xEEE
 18387                                  
 18388 00001E2B A801                    	test	al,1			; is current entry odd?
 18389                                  
 18390 00001E2D 268B07                  	mov	ax,[es:bx]		; word with FAT entry
 18391 00001E30 7505                    	jnz	short gdf_odd
 18392                                  
 18393 00001E32 25FF0F                  	and	ax,0FFFh		; keep low 12 bits for even
 18394 00001E35 EB08                    	jmp	short gdf_testEOF
 18395                                  
 18396                                  gdf_odd:
 18397 00001E37 89CB                    	mov	bx,cx			; (save cx in bx)
 18398 00001E39 B104                    	mov	cl,4
 18399 00001E3B D3E8                    	shr	ax,cl			; upper 12 bits for odd
 18400 00001E3D 89D9                    	mov	cx,bx			; (restore cx)
 18401                                  
 18402                                  gdf_testEOF:
 18403 00001E3F 3DF00F                  	cmp	ax,0FF0h		; valid entry?
 18404                                  	;jb	short gdf_success
 18405 00001E42 F5                      	cmc	; cf = 1 <--> cf = 0
 18406 00001E43 73DD                    	jnc	short gdf_ret	
 18407                                  
 18408 00001E45 80CCF0                  	or	ah,0F0h			; caller expects 16 bit special values
 18409                                  	;jmp	short gdf_success
 18410                                  	; cf = 0
 18411 00001E48 C3                      	retn
 18412                                  
 18413                                  ; --------------------------------------------------------------------------- 
 18414                                  
 18415                                  ;***	GetMDFATEntry - returns requested MD FAT entry
 18416                                  ;
 18417                                  ;	Entry	AX = current DOS cluster number
 18418                                  ;		ES = segment of FAT buffer
 18419                                  ;		Entry should be in FAT buffer
 18420                                  ;
 18421                                  ;	Exit	BX:CX = corresponding MD FAT entry
 18422                                  ;		CY set if error
 18423                                  ;
 18424                                  ;	Uses	None
 18425                                  
 18426                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18427                                  GetMDFATEntry:
 18428 00001E49 89C3                    	mov	bx,ax
 18429 00001E4B 2B1E[B99E]              	sub	bx,[entInBuf]		; calc entry # in buffer
 18430 00001E4F 7210                    	jc	short gmf_ret 		; CY already set for error return
 18431                                  
 18432 00001E51 D1E3                    	shl	bx,1
 18433 00001E53 D1E3                    	shl	bx,1			; * 4 bytes per MDFAT entry
 18434                                  
 18435 00001E55 031E[BF9E]              	add	bx,[pbufMDFAT]
 18436 00001E59 268B0F                  	mov	cx,[es:bx]
 18437 00001E5C 268B5F02                	mov	bx,[es:bx+2]
 18438                                  
 18439 00001E60 F8                      	clc
 18440                                  gmf_ret:
 18441 00001E61 C3                      	retn
 18442                                  
 18443                                  ; --------------------------------------------------------------------------- 
 18444                                  
 18445                                  ;***	CheckFATBuffers - check that target FAT entry is in FAT buffers.  If
 18446                                  ;			  not, fill the buffers starting with the requested
 18447                                  ;			  entry.
 18448                                  ;
 18449                                  ;	ENTRY	AX = FAT entry #
 18450                                  ;		ES = segment of FAT buffers
 18451                                  ;
 18452                                  ;	EXIT	FAT buffers contain target entry, or CY set if error
 18453                                  ;		entInBuf updated
 18454                                  ;
 18455                                  ;	USED	BX
 18456                                  
 18457                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18458                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1F4Bh
 18459                                  
 18460                                  CheckFATBuffers:
 18461 00001E62 89C3                    	mov	bx,ax
 18462 00001E64 2B1E[B99E]              	sub	bx,[entInBuf]
 18463 00001E68 7208                    	jb	short cfb_load_fat
 18464                                  
 18465 00001E6A 2B1E[B79E]              	sub	bx,[cFATEntries]
 18466 00001E6E 7302                    	jae	short cfb_load_fat ; jnb
 18467                                  
 18468 00001E70 F8                      	clc
 18469 00001E71 C3                      	retn
 18470                                  
 18471                                  	; Desired entry isn't in the FAT buffers, reload the buffers to
 18472                                  	; include it
 18473                                  
 18474                                  cfb_load_fat:
 18475 00001E72 50                      	push	ax
 18476 00001E73 51                      	push	cx
 18477 00001E74 52                      	push	dx
 18478                                  
 18479                                  	; Start with the DOS FAT buffer
 18480                                  
 18481 00001E75 31C9                    	xor	cx,cx			; zero high offset to FAT file position
 18482                                  
 18483                                  	;cmp	MDBPB.f12BitFAT, 0	; 12 or 16 bit FAT?
 18484 00001E77 803E[B29E]00            	cmp	byte [MDBPB+3Dh],0
 18485 00001E7C 7509                    	jnz	short cfb_12		; go do 12
 18486                                  
 18487 00001E7E A3[B99E]                	mov	[entInBuf],ax		; this entry is first
 18488                                  
 18489 00001E81 D1E0                    	shl	ax,1			; 2 bytes per cluster #
 18490 00001E83 D1D1                    	rcl	cx,1			; cx:ax = offset to FAT entry
 18491                                  
 18492 00001E85 EB0B                    	jmp	short cfb_common
 18493                                  
 18494                                  cfb_12:
 18495                                  	;and	al,not 1 ; 0FEh		; start with even # entry
 18496 00001E87 24FE                    	and	al,~1
 18497 00001E89 A3[B99E]                	mov	[entInBuf],ax
 18498                                  
 18499 00001E8C 89C3                    	mov	bx,ax
 18500 00001E8E D1EB                    	shr	bx,1
 18501 00001E90 01D8                    	add	ax,bx			; ax = offset to FAT entry
 18502                                  					;      (entry # * 1.5)
 18503                                  cfb_common:
 18504 00001E92 89C3                    	mov	bx,ax			; cx:bx = offset to FAT entry
 18505                                  
 18506                                  	;mov	ax,[MDBPB.csecMDReserved] ; # magicDrv reserved sectors
 18507 00001E94 A1[9C9E]                	mov	ax,[MDBPB+27h]
 18508                                  	;add	ax,[MDBPB.dos_bpb.csecReserved]
 18509 00001E97 0306[839E]              	add	ax,[MDBPB+0Eh]
 18510                                  
 18511                                  	;mul	word [MDBPB.dos_bpb.cbPerSec]
 18512 00001E9B F726[809E]              	mul	word [MDBPB+0Bh]	; DX:AX = DOS FAT file origin
 18513 00001E9F 01D8                    	add	ax,bx
 18514 00001EA1 11CA                    	adc	dx,cx			; DX:AX = file offset to read from
 18515                                  
 18516 00001EA3 8B0E[B79E]              	mov	cx,[cFATEntries]	; size to read
 18517 00001EA7 D1E1                    	shl	cx,1
 18518 00001EA9 8B1E[BD9E]              	mov	bx,[pbufDOSFAT]		; es:bx = location to read
 18519                                  
 18520 00001EAD E83500                  	call	ReadCVFile
 18521 00001EB0 722F                    	jc	short cfb_error
 18522                                  
 18523                                  	; Now read the corresponding MagicDrv FAT entries
 18524                                  
 18525                                  	;mov	ax,[MDBPB.secMDFATStart]
 18526 00001EB2 A1[999E]                	mov	ax,[MDBPB+24h]
 18527 00001EB5 40                      	inc	ax
 18528                                  	;mul	word [MDBPB.dos_bpb.cbPerSec]
 18529 00001EB6 F726[809E]              	mul	word [MDBPB+0Bh]	; DX:AX = MDFAT file offset
 18530                                  
 18531 00001EBA 8B1E[B99E]              	mov	bx,[entInBuf]
 18532 00001EBE 31C9                    	xor	cx,cx			; CX:BX = 32 bit cluster #
 18533                                  	;add	bx,[MDBPB.cluFirstData]
 18534 00001EC0 031E[A29E]              	add	bx,[MDBPB+2Dh]
 18535 00001EC4 11C9                    	adc	cx,cx			; CX:BX = MDFAT entry #
 18536                                  
 18537 00001EC6 D1E3                    	shl	bx,1
 18538 00001EC8 D1D1                    	rcl	cx,1
 18539 00001ECA D1E3                    	shl	bx,1
 18540 00001ECC D1D1                    	rcl	cx,1			; * 4 bytes per MDFAT entry
 18541                                  
 18542 00001ECE 01D8                    	add	ax,bx
 18543 00001ED0 11CA                    	adc	dx,cx			; DX:AX = file offset of MDFAT entry
 18544                                  
 18545 00001ED2 8B0E[B79E]              	mov	cx,[cFATEntries]
 18546 00001ED6 D1E1                    	shl	cx,1
 18547 00001ED8 D1E1                    	shl	cx,1			; size to read
 18548 00001EDA 8B1E[BF9E]              	mov	bx,[pbufMDFAT]		; es:bx = location to read into
 18549                                  
 18550 00001EDE E80400                  	call	ReadCVFile
 18551                                  	;jnc	short cfb_ret ; cf = 0 ; 08/06/2023
 18552                                  	; 08/06/2023
 18553                                  	; cf = 1
 18554                                  cfb_error:
 18555                                  	;stc
 18556                                  cfb_ret:
 18557 00001EE1 5A                      	pop	dx
 18558 00001EE2 59                      	pop	cx
 18559 00001EE3 58                      	pop	ax
 18560 00001EE4 C3                      	retn
 18561                                  
 18562                                  ; --------------------------------------------------------------------------- 
 18563                                  
 18564                                  ;***	ReadCVFile - read from the Compressed Volume File
 18565                                  ;
 18566                                  ;	Entry	DX:AX file offset, ES:BX buffer location, CX length in bytes
 18567                                  ;
 18568                                  ;	Exit	CY set if error, else data read
 18569                                  ;
 18570                                  ;	Uses	AX, BX, CX, DX
 18571                                  
 18572                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18573                                  ReadCVFile:
 18574 00001EE5 53                      	push	bx			; save buffer loc
 18575 00001EE6 51                      	push	cx			; save read length
 18576                                  
 18577 00001EE7 89D1                    	mov	cx,dx
 18578 00001EE9 89C2                    	mov	dx,ax			; cx:dx = file offset of fat entry
 18579                                  	;mov	ax,(LSEEK shl 8) or 0
 18580 00001EEB B80042                  	mov	ax,4200h
 18581 00001EEE 8B1E[639E]              	mov	bx,[fhCVF]
 18582 00001EF2 CD21                    	int	21h
 18583 00001EF4 720E                    	jc	short rcf_ret 		; CY set for error return
 18584                                  
 18585                                  	;mov	ah,READ
 18586 00001EF6 B43F                    	mov	ah,3Fh
 18587 00001EF8 59                      	pop	cx			; read length
 18588 00001EF9 5A                      	pop	dx			; buffer loc offset
 18589 00001EFA 1E                      	push	ds
 18590 00001EFB 06                      	push	es
 18591 00001EFC 1F                      	pop	ds			; buffer loc segment
 18592 00001EFD CD21                    	int	21h
 18593 00001EFF 1F                      	pop	ds
 18594 00001F00 7202                    	jc	short rcf_ret 		; CY set for error return
 18595                                  
 18596 00001F02 39C8                    	cmp	ax,cx			; read it all?
 18597                                  	;je	short rcf_ret 		; yes, CY clear
 18598                                  	; 08/06/2023	
 18599                                  	; ax < cx
 18600                                  	;stc				; end-of-file?
 18601                                  rcf_ret:
 18602 00001F04 C3                      	retn
 18603                                  
 18604                                  ;============================================================================
 18605                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 18606                                  ;============================================================================
 18607                                  ; 09/10/2018 - Retro DOS v3.0
 18608                                  
 18609                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
 18610                                  
 18611                                  ; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18612                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1A4Ah
 18613                                  
 18614                                  ; =============== S U B	R O U T	I N E =======================================
 18615                                  
 18616                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18617                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1FF4h
 18618                                  PAUSE:
 18619 00001F05 BA[8592]                	mov	dx,PAUSEMES_PTR ; 19/02/2023
 18620 00001F08 E82236                  	call	std_printf
 18621 00001F0B E819E7                  	call	GETKEYSTROKE
 18622                                  	;call	CRLF2
 18623                                  	;retn
 18624                                  	; 19/02/2023
 18625 00001F0E E9100C                  	jmp	CRLF2
 18626                                  
 18627                                  ; ---------------------------------------------------------------------------
 18628                                  
 18629                                  ;****************************************************************
 18630                                  ;*
 18631                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
 18632                                  ;*
 18633                                  ;* FUNCTION:	PARSE command line for file or path name and /P
 18634                                  ;*		and invoke PATHCRUNCH. If an error occurs, set
 18635                                  ;*		up an error message and transfer control to CERROR.
 18636                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
 18637                                  ;*		entered or SLASHP_ERASE if /P entered.
 18638                                  ;*
 18639                                  ;* INPUT:	command line at offset 81H
 18640                                  ;*
 18641                                  ;* OUTPUT:	if no error:
 18642                                  ;*		FCB at 5ch set up with filename(s) entered
 18643                                  ;*		Current directory set to entered directory
 18644                                  ;*
 18645                                  ;****************************************************************
 18646                                  
 18647                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18648                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A57h
 18649                                  
 18650                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18651                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2001h
 18652                                  ERASE:
 18653                                  	; MSDOS 6.0
 18654                                  
 18655                                  	;assume	ds:trangroup,es:trangroup
 18656                                  
 18657 00001F11 BE8100                  	mov	si,81h		;AC000; get command line
 18658 00001F14 C706[2C9E]0000          	mov	word [COMSW],0 	;AN000; clear switch indicator
 18659 00001F1A BF[4D98]                	mov	di,PARSE_ERASE
 18660                                  				;AN000; Get address of PARSE_ERASE
 18661 00001F1D 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 18662                                  erase_scan:
 18663 00001F1F 31D2                    	xor	dx,dx		;AN000;
 18664 00001F21 E8E507                  	call	Parse_With_Msg	;AC018; call parser
 18665                                  	
 18666                                  	;cmp	ax,-1  ; 0FFFFh
 18667                                  	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 18668                                  	;je	short good_line	;AN000; yes - done parsing
 18669                                  	;;cmp	ax,0
 18670                                  	;;cmp	ax,RESULT_NO_ERROR ; 0
 18671                                  	;and	ax,ax		;AC000; did we have an error?
 18672                                  	;jnz	short errj2	;AC000; yes exit
 18673                                  	; 10/06/2023
 18674 00001F24 40                      	inc	ax  ; cmp ax,-1
 18675 00001F25 743C                    	jz	short good_line ; 0FFFFh -> 0
 18676 00001F27 48                      	dec	ax  ; cmp ax,0	
 18677 00001F28 7566                    	jnz	short errj2  ; 1 -> 0
 18678                                  	; ax = 0
 18679                                  
 18680 00001F2A 813E[09AA][C097]        	cmp	word [PARSE1_SYN],SLASH_P_SYN ; "/P"
 18681                                  				;AN000; was /P entered?
 18682 00001F30 741C                    	je	short set_erase_prompt
 18683                                  				;AN000; yes - go set prompt
 18684                                  ;
 18685                                  ; Must be filespec since no other matches occurred. move filename to srcbuf
 18686                                  ;
 18687 00001F32 56                      	push	si		;AC000; save position in line
 18688 00001F33 C536[0BAA]              	lds	si,[PARSE1_ADDR]
 18689                                  				;AC000; get address of filespec
 18690                                  	;cmp	byte [si+1],colon_char
 18691 00001F37 807C013A                	cmp	byte [si+1],':'	;AC000; drive specified?
 18692 00001F3B 750B                    	jne	short erase_drive_ok
 18693                                  				;AC000; no - continue
 18694                                  	;cmp	byte [si+2],END_OF_LINE_OUT	
 18695 00001F3D 807C0200                	cmp	byte [si+2],0	;AC000; was only drive entered?
 18696 00001F41 7505                    	jne	short erase_drive_ok
 18697                                  				;AC000; no - continue
 18698 00001F43 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2 
 18699                                  				;AN022; get message number in control block
 18700 00001F46 EB3D                    	jmp	short extend_setup
 18701                                  				;AC000; exit
 18702                                  erase_drive_ok:
 18703 00001F48 E8AA12                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 18704 00001F4B 5E                      	pop	si		;AC000; get position back
 18705 00001F4C EBD1                    	jmp	short erase_scan
 18706                                  				;AN000; continue parsing
 18707                                  set_erase_prompt:
 18708 00001F4E 833E[2C9E]00            	cmp	word [COMSW],0 	;AN018; was /P already entered?
 18709 00001F53 7408                    	jz	short ok_to_set_erase_prompt
 18710                                  				;AN018; no go set switch
 18711                                  	;mov	ax,1
 18712 00001F55 B80100                  	mov	ax,MoreArgs_Ptr 
 18713                                  				;AN018; set up too many arguments
 18714 00001F58 E8BD07                  	call	setup_parse_error_msg
 18715                                  				;AN018; set up an error message
 18716 00001F5B EB33                    	jmp	short errj2	;AN018; exit
 18717                                  
 18718                                  ok_to_set_erase_prompt: 	;AN018;
 18719 00001F5D FF06[2C9E]              	inc	word [COMSW]	;AN000; indicate /p specified
 18720 00001F61 EBBC                    	jmp	short erase_scan
 18721                                  				;AN000; continue parsing
 18722                                  good_line:			;G  We know line is good
 18723 00001F63 E8640C                  	call	PathCrunch
 18724 00001F66 730D                    	jnc	short checkdr
 18725 00001F68 A1[4BA2]                	mov	ax,[Msg_Numb]	;AN022; get message number
 18726                                  	;cmp	ax,0		;AN022; was message flag set?
 18727 00001F6B 09C0                    	or	ax,ax
 18728 00001F6D 7516                    	jnz	short extend_setup
 18729                                  				;AN022; yes - print out message
 18730                                  	;cmp	byte [DestIsDir],0
 18731 00001F6F 3806[D0A0]              	cmp	[DestIsDir],al 	; No CHDIRs worked
 18732 00001F73 750D                    	jnz	short badpath_err
 18733                                  				;AC022; see if they should have
 18734                                  checkdr:
 18735 00001F75 833E[2C9E]00            	cmp	word [COMSW],0 	;AN000; was /p specified
 18736 00001F7A 7403                    	jz	short notest2j	;AN000; no - go to notest2
 18737 00001F7C E9071B                  	jmp	slashp_erase	;AN000; yes - go to slashp_erase
 18738                                  notest2j:
 18739 00001F7F E99F1A                  	jmp	notest2
 18740                                  
 18741                                  badpath_err:			;AN022; "Path not found" message
 18742 00001F82 B80300                  	mov	ax,ERROR_PATH_NOT_FOUND ; 3
 18743                                  				;AN022; set up error number
 18744                                  extend_setup:			;AN022;
 18745                                  	;mov	byte [msg_disp_class],1
 18746 00001F85 C606[F191]01            	mov	byte [msg_disp_class],ext_msg_class
 18747                                  				;AN022; set up extended error msg class
 18748 00001F8A BA[F391]                	mov	dx,extend_buf_ptr
 18749                                  				;AC022; get extended message pointer
 18750 00001F8D A3[F391]                	mov	[extend_buf_ptr],ax
 18751                                  				;AN022; get message number in control block
 18752                                  errj2:				;AC022; exit jump
 18753 00001F90 E90F0F                  	jmp	cerror		;AN022;
 18754                                  
 18755                                  ; ---------------------------------------------------------------------------
 18756                                  
 18757                                  ; ****************************************************************
 18758                                  ; *
 18759                                  ; * ROUTINE:	 CRENAME - rename file(s)
 18760                                  ; *
 18761                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
 18762                                  ; *		 filename. Invoke PATHCRUNCH on the full filespec.
 18763                                  ; *		 Make sure the second filespec only contains a
 18764                                  ; *		 filename. If both openands are valid, attempt
 18765                                  ; *		 to rename the file.
 18766                                  ; *
 18767                                  ; * INPUT:	 command line at offset 81H
 18768                                  ; *
 18769                                  ; * OUTPUT:	 none
 18770                                  ; *
 18771                                  ; ****************************************************************
 18772                                  
 18773                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18774                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18775                                  CRENAME:
 18776                                  	; MSDOS 6.0
 18777                                  	;assume	ds:trangroup,es:trangroup
 18778                                  
 18779 00001F93 BE8100                  	mov	si,81h		;AC000; Point to command line
 18780 00001F96 BF[CF98]                	mov	di,PARSE_RENAME
 18781                                  				;AN000; Get address of PARSE_RENAME
 18782 00001F99 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 18783 00001F9B 31D2                    	xor	dx,dx		;AN000;
 18784 00001F9D E86907                  	call	Parse_With_Msg	;AC018; call parser
 18785                                  	;cmp	ax,RESULT_NO_ERROR ; 0
 18786 00001FA0 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 18787                                  ;	jz	short crename_no_parse_error
 18788                                  				;AC000; no - continue
 18789 00001FA2 752C                    	jnz	short crename_parse_error
 18790                                  				;AC000; Yes, fail. (need long jump)
 18791                                  ;
 18792                                  ;  Get first file name returned from parse into our buffer
 18793                                  ;
 18794                                  crename_no_parse_error:
 18795 00001FA4 56                      	push	si		;AN000; save position in line
 18796 00001FA5 C536[0BAA]              	lds	si,[PARSE1_ADDR]
 18797                                  				;AN000; get address of filespec
 18798 00001FA9 E84912                  	call    Move_To_SrcBuf	;AN000; move to srcbuf
 18799 00001FAC 5E                      	pop	si		;AN000; restore position in line
 18800                                  
 18801 00001FAD 31D2                    	xor	dx,dx		;AN000; clear dx
 18802 00001FAF E85707                  	call	Parse_With_Msg	;AC018; call parser
 18803                                  	;cmp	ax,RESULT_NO_ERROR
 18804 00001FB2 21C0                    	and	ax,ax ; 0 ?	;AN000; did we have an error?
 18805 00001FB4 751A                    	jnz	short crename_parse_error
 18806                                  				;AN000; Yes, fail.
 18807                                  ;
 18808                                  ;  Check the second file name for drive letter colon
 18809                                  ;
 18810 00001FB6 56                      	push	si		;AN000; save position in line
 18811 00001FB7 C536[0BAA]              	lds	si,[PARSE1_ADDR]
 18812                                  				;AC000; get address of path
 18813                                  	;mov	al,':'		;AC000;
 18814                                  	;cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
 18815 00001FBB 807C013A                	cmp	byte [si+1],':'
 18816 00001FBF 7511                    	jnz	short ren_no_drive
 18817                                  				;AN000; Yes, error
 18818                                  	;mov	byte [msg_disp_class],2
 18819 00001FC1 C606[F191]02            	mov	byte [msg_disp_class],parse_msg_class
 18820                                  				;AN000; set up parse error msg class
 18821 00001FC6 BA[F391]                	mov	dx,extend_buf_ptr
 18822                                  				;AC000; get extended message pointer
 18823                                  	;mov	word [extend_buf_ptr],0Ah
 18824 00001FC9 C706[F391]0A00          	mov	word [extend_buf_ptr],BadParm_Ptr
 18825                                  				;AN000; get "Invalid parameter" message number
 18826 00001FCF 5E                      	pop	si		;AN000;
 18827                                  crename_parse_error:		;AC022;
 18828 00001FD0 EB64                    	jmp	short errj	;AC000;
 18829                                  
 18830                                  ;  Get second file name returned from parse into the fCB. Save
 18831                                  ;  character after file name so we can later check to make sure it
 18832                                  ;  isn't a path character.
 18833                                  
 18834                                  ren_no_drive:
 18835 00001FD2 BF6C00                  	mov	di,FCB+10h ; 6Ch
 18836                                  				;AC000; set up to parse second file name
 18837                                  	;mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
 18838 00001FD5 B80129                  	mov	ax,2901h
 18839 00001FD8 CD21                    	int	21h		;AC000; do the function
 18840 00001FDA AC                      	lodsb			;AC000; Load char after filename
 18841 00001FDB A2[C8A0]                	mov	[One_Char_Val],al
 18842                                  				;AN000; save char after filename
 18843 00001FDE 5E                      	pop	si		;AN000; get line position back
 18844                                  ;
 18845                                  ; We have source and target. See if any args beyond.
 18846                                  ;
 18847 00001FDF BF[CF98]                	mov	di,PARSE_RENAME
 18848                                  				;AC000; get address of parse_rename
 18849 00001FE2 E80E07                  	call	parse_check_eol ;AC000; are we at end of line?
 18850 00001FE5 75E9                    	jnz	short crename_parse_error
 18851                                  				;AN000; no, fail.
 18852 00001FE7 E8E00B                  	call	PathCrunch
 18853 00001FEA BA[0492]                	mov	dx,BADCPMES_PTR
 18854 00001FED 74A1                    	jz	short errj2	; If 1st parm a dir, print error msg
 18855 00001FEF 730F                    	jnc	short notest3
 18856 00001FF1 A1[4BA2]                	mov	ax,[Msg_Numb]	;AN022; get message number
 18857                                  	;cmp	ax,0		;AN022; was message flag set?
 18858 00001FF4 21C0                    	and	ax,ax ; 0 ?
 18859 00001FF6 758D                    	jnz	short extend_setup
 18860                                  				;AN022; yes - print out message
 18861                                  	;cmp	byte [DestIsDir],0
 18862 00001FF8 3806[D0A0]              	cmp	[DestIsDir],al	; No CHDIRs worked
 18863 00001FFC 7402                    	jz	short notest3 	; see if they should have
 18864 00001FFE EB82                    	Jmp	badpath_err	;AC022; set up error
 18865                                  notest3:
 18866 00002000 A0[C8A0]                	mov	al,[One_Char_Val]
 18867                                  				;AN000; move char into AX
 18868 00002003 BA[2292]                	mov	dx,INORNOT_PTR 
 18869                                  				; Load invalid fname error ptr
 18870 00002006 E8B30B                  	call	pathchrcmp	; Is the char in al a path sep?
 18871 00002009 742B                    	jz	short errj	; Yes, error - 2nd arg must be
 18872                                  				;  filename only.
 18873                                  	;mov	ah,FCB_Rename
 18874 0000200B B417                    	mov	ah,17h
 18875 0000200D BA5C00                  	mov	dx,FCB ; 5Ch
 18876 00002010 CD21                    	int	21h
 18877 00002012 3CFF                    	cmp	al,0FFh		; Did an error occur??
 18878 00002014 7506                    	jne	short renameok
 18879                                  
 18880 00002016 E82902                  	call	get_ext_error_number
 18881                                  				;AN022; get extended error
 18882 00002019 50                      	push	ax		;AC022; Save results
 18883 0000201A B0FF                    	mov	al,0FFh		; Restore original error state
 18884                                  renameok:
 18885 0000201C 50                      	push	ax
 18886 0000201D E8BE09                  	call	RestUDir
 18887 00002020 58                      	pop	ax
 18888 00002021 FEC0                    	inc	al
 18889                                  	;;retnz
 18890                                  	;jz	short rn1
 18891                                  	;retn	
 18892 00002023 7514                    	jnz	short ret56
 18893                                  rn1:
 18894 00002025 58                      	pop	ax		;AC022; get the error number back
 18895 00002026 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2 
 18896                                  				;AN022; error file not found?
 18897 00002029 7408                    	je	short use_renerr
 18898                                  				;AN022; yes - use generic error message
 18899 0000202B 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5 
 18900                                  				;AN022; error file not found?
 18901 0000202E 7403                    	je	short use_renerr
 18902                                  				;AN022; yes - use generic error message
 18903 00002030 E952FF                  	jmp	extend_setup	;AN022; need long jump - use extended error
 18904                                  
 18905                                  use_renerr:
 18906 00002033 BA[0192]                	mov	dx,RENERR_PTR	;AC022;
 18907                                  errj:
 18908 00002036 E9690E                  	jmp	cerror
 18909                                  ret56:
 18910                                  ;typefil_ret:	; 20/02/2023 ; 17/04/2023	
 18911 00002039 C3                      	retn
 18912                                  
 18913                                  ; ---------------------------------------------------------------------------
 18914                                  
 18915                                  ;****************************************************************
 18916                                  ;*
 18917                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
 18918                                  ;*		standard output device
 18919                                  ;*
 18920                                  ;* SYNTAX:	TYPE filespec
 18921                                  ;*
 18922                                  ;* FUNCTION:	If a valid filespec is found, read the file until
 18923                                  ;*		1Ah and display the contents to STDOUT.
 18924                                  ;*
 18925                                  ;* INPUT:	command line at offset 81H
 18926                                  ;*
 18927                                  ;* OUTPUT:	none
 18928                                  ;*
 18929                                  ;****************************************************************
 18930                                  
 18931                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18932                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18933                                  TYPEFIL:
 18934                                  	; MSDOS 6.0	
 18935                                  	;assume	ds:trangroup,es:trangroup
 18936                                  
 18937 0000203A BE8100                  	mov	si,81h
 18938 0000203D BF[3B98]                	mov	di,PARSE_MRDIR
 18939                                  				;AN000; Get address of PARSE_MRDIR
 18940 00002040 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 18941 00002042 31D2                    	xor	dx,dx		;AN000;
 18942 00002044 E8C206                  	call	Parse_With_Msg	;AC018; call parser
 18943                                  	;cmp	ax,RESULT_NO_ERROR
 18944 00002047 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 18945 00002049 751E                    	jnz	short typefil_parse_error
 18946                                  				;AN000; yes - issue error message
 18947                                  
 18948 0000204B 56                      	push	si		;AC000; save position in line
 18949 0000204C C536[0BAA]              	lds	si,[PARSE1_ADDR]
 18950                                  				;AC000; get address of filespec
 18951 00002050 E8A211                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 18952 00002053 5E                      	pop	si		;AC000; get position back
 18953 00002054 BF[3B98]                	mov	di,PARSE_MRDIR
 18954                                  				;AC000; get address of parse_mrdir
 18955 00002057 E89906                  	call	parse_check_eol ;AC000; are we at end of line?
 18956                                  	;jz	short gottarg 	;AC000; yes - continue
 18957                                  	; 20/02/2023
 18958                                  ;typefil_parse_error:		;AN000; no - set up error message and exit
 18959                                  	;jmp	cerror
 18960 0000205A 750D                    	jnz	short typefil_parse_error
 18961                                  gottarg:
 18962 0000205C E8DD0F                  	call	SETPATH
 18963 0000205F F606[D4A0]02            	test	byte [DestInfo],00000010b ; 2
 18964                                  				; Does the filespec contain wildcards
 18965 00002064 7406                    	jz	short nowilds 	; No, continue processing
 18966 00002066 BA[2292]                	mov	dx,INORNOT_PTR	; Yes, report error
 18967                                  	; 20/02/2023
 18968                                  typefil_parse_error:
 18969 00002069 E9360E                  	jmp	cerror
 18970                                  nowilds:
 18971                                  	;mov	ax,ExtOpen SHL 8 ;AC000; open the file
 18972 0000206C B8006C                  	mov	ax,6C00h
 18973                                  	;mov	bx,read_open_mode ; 0
 18974                                  				;AN000; get open mode for TYPE
 18975 0000206F 31C9                    	xor	cx,cx		;AN000; no special files
 18976 00002071 89CB                    	mov	bx,cx ; 20/02/2023
 18977 00002073 BA0101                  	mov	dx,101h
 18978                                  	;mov	dx,read_open_flag ; 101h
 18979                                  				;AN000; set up open flags
 18980 00002076 BE[38A1]                	mov	si,SrcBuf	;AN030; get file name
 18981 00002079 CD21                    	int	21h
 18982 0000207B 7313                    	jnc	short typecont	; If open worked, continue. Otherwise load
 18983                                  
 18984                                  typerr: 			;AN022;
 18985 0000207D 0E                      	push	cs		;AN022; make sure we have local segment
 18986 0000207E 1F                      	pop	ds		;AN022;
 18987 0000207F E8B001                  	call	Set_Ext_Error_Msg ;AN022;
 18988 00002082 C706[B7A0][38A1]        	mov	word [string_ptr_2],SrcBuf 
 18989                                  				;AC022; get address of failed string
 18990                                  	;mov	byte [extend_buf_sub],1
 18991 00002088 C606[F591]01            	mov	byte [extend_buf_sub],one_subst
 18992                                  				;AC022; put number of subst in control block
 18993 0000208D E9120E                  	jmp	cerror		;AC022; exit
 18994                                  
 18995                                  typecont:
 18996 00002090 89C3                    	mov	bx,ax		;AC000; get Handle
 18997                                  ;M043
 18998                                  ; We should do the LSEEK for filesize only if this handle belongs to a file
 18999                                  ;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
 19000                                  ;indicate it is a device.
 19001                                  ;
 19002                                  	;mov	ax,(IOCTL shl 8) or 0
 19003 00002092 B80044                  	mov	ax,4400h
 19004 00002095 CD21                    	int	21h
 19005                                  
 19006 00002097 F6C280                  	test	dl,80h		;is it a device?
 19007 0000209A 7408                    	jz	short not_device
 19008                                  				;no, a file
 19009                                  
 19010 0000209C C706[05AA]FFFF          	mov	word [TypeFilSiz+2],-1 ; 0FFFFh
 19011                                  				;indicate it is a device
 19012 000020A2 EB17                    	jmp	short dotype
 19013                                  not_device:
 19014                                  ;SR;
 19015                                  ; Find the filesize by seeking to the end and then reset file pointer to
 19016                                  ;start of file
 19017                                  
 19018                                  	;mov	ax,(LSEEK shl 8) or 2
 19019 000020A4 B80242                  	mov	ax,4202h
 19020 000020A7 31D2                    	xor	dx,dx
 19021 000020A9 89D1                    	mov	cx,dx		;seek  to end of file
 19022 000020AB CD21                    	int	21h
 19023                                  
 19024 000020AD A3[03AA]                	mov	[TypeFilSiz],ax
 19025 000020B0 8916[05AA]              	mov	[TypeFilSiz+2],dx ;store filesize
 19026                                  	;mov	ax,(LSEEK shl 8) or 0
 19027 000020B4 B80042                  	mov	ax,4200h
 19028 000020B7 31D2                    	xor	dx,dx
 19029 000020B9 CD21                    	int	21h	        ;reset file pointer to start
 19030                                  dotype:				;M043
 19031 000020BB C606[B5A8]00            	mov	byte [zflag],0 	; Reset ^Z flag
 19032 000020C0 8E1E[179E]              	mov	ds,[TPA]
 19033 000020C4 31D2                    	xor	dx,dx
 19034                                  	;ASSUME	DS:NOTHING
 19035                                  typelp:
 19036 000020C6 2E803E[B5A8]00          	cmp	byte [cs:zflag],0
 19037                                  				;AC050; Is the ^Z flag set?
 19038                                  	;retnz			; Yes, return
 19039                                  	; 17/04/2023
 19040 000020CC 7401                    	jz	short tf1
 19041 000020CE C3                      	retn
 19042                                  tf1:
 19043 000020CF 2E8B0E[369E]            	mov	cx,[cs:BYTCNT]	;AC056; No, continue
 19044                                  
 19045                                  ;Update the filesize left to read
 19046                                  
 19047 000020D4 2E833E[05AA]FF          	cmp	word [cs:TypeFilSiz+2],-1
 19048                                  				;is it a device? M043
 19049 000020DA 7431                    	je	short typ_read	;yes, just read from it; M043
 19050                                  
 19051 000020DC 2E833E[05AA]00          	cmp	word [cs:TypeFilSiz+2],0
 19052                                  				;more than 64K left?
 19053 000020E2 740D                    	jz	short lt64k	;no, do word subtraction
 19054 000020E4 2E290E[03AA]            	sub	[cs:TypeFilSiz],cx
 19055 000020E9 2E831E[05AA]00          	sbb	word [cs:TypeFilSiz+2],0
 19056                                  				;update filesize
 19057 000020EF EB1C                          	jmp	short typ_read	;do the read
 19058                                  lt64k:
 19059 000020F1 2E3B0E[03AA]            	cmp	cx,[cs:TypeFilSiz]
 19060                                  				;readsize <= buffer?
 19061 000020F6 7610                    	jbe	short gtbuf	; yes, just update readsize
 19062                                  
 19063                                  ;Buffer size is larger than bytes to read
 19064                                  
 19065 000020F8 2E8B0E[03AA]            	mov	cx,[cs:TypeFilSiz]
 19066 000020FD E361                    	jcxz	typelp_ret
 19067 000020FF 2EC706[03AA]0000        	mov	word [cs:TypeFilSiz],0
 19068 00002106 EB05                    	jmp	short typ_read
 19069                                  gtbuf:
 19070 00002108 2E290E[03AA]            	sub	[cs:TypeFilSiz],cx
 19071                                  				;update filesize remaining
 19072                                  typ_read:
 19073                                  	;mov	ah,read
 19074 0000210D B43F                    	mov	ah,3Fh
 19075 0000210F CD21                    	int	21h
 19076 00002111 7303                    	jnc	short tf2	;M043
 19077 00002113 E967FF                  	jmp	typerr		;M043
 19078                                  tf2:				;M043
 19079                                  ;M043;	jc	typerr		;AN022; Exit if error
 19080                                  
 19081 00002116 89C1                    	mov	cx,ax
 19082 00002118 E346                    	jcxz	typelp_ret	;AC000; exit if nothing read
 19083 0000211A 1E                      	push	ds
 19084 0000211B 07                      	pop	es		; Check to see if a ^Z was read.
 19085                                  	;assume es:nothing
 19086 0000211C 31FF                    	xor	di,di
 19087 0000211E 50                      	push	ax
 19088 0000211F B01A                    	mov	al,1Ah
 19089 00002121 F2AE                    	repnz	scasb
 19090 00002123 58                      	pop	ax
 19091 00002124 91                      	xchg	ax,cx
 19092                                  	;cmp	ax,0
 19093 00002125 21C0                    	and	ax,ax
 19094 00002127 7506                    	jnz	short foundz	; Yes, handle it
 19095 00002129 807DFF1A                	cmp	byte [di-1],1Ah	; No, double check
 19096 0000212D 750A                    	jnz	short typecont2	; No ^Z, continue
 19097                                  foundz:
 19098 0000212F 29C1                    	sub	cx,ax		; Otherwise change cx so that only those
 19099 00002131 49                      	dec	cx		;  bytes up to but NOT including the ^Z
 19100 00002132 0E                      	push	cs		;  will be typed.
 19101 00002133 07                      	pop	es
 19102                                  	;assume es:trangroup
 19103 00002134 26F616[B5A8]            	not	byte [es:zflag]	; Turn on ^Z flag so that the routine
 19104                                  typecont2:			;  will quit after this write.
 19105 00002139 53                      	push	bx
 19106 0000213A BB0100                  	mov	bx,1
 19107                                  	;mov	ah,Write
 19108 0000213D B440                    	mov	ah,40h
 19109 0000213F CD21                    	int	21h
 19110 00002141 5B                      	pop	bx
 19111 00002142 720C                    	jc	short Error_outputj
 19112 00002144 39C8                    	cmp	ax,cx
 19113 00002146 7503                    	jnz	short tf3	;M043
 19114 00002148 E97BFF                  	jmp	typelp		;M043
 19115                                  tf3:				;M043
 19116                                  ;M043;	jz	short typelp
 19117 0000214B 49                      	dec	cx
 19118 0000214C 39C8                    	cmp	ax,cx
 19119                                  	;;retz			; One less byte OK (^Z)
 19120                                  	;jnz	short Error_outputj
 19121                                  ;tf4:
 19122                                  	;retn
 19123 0000214E 7410                    	jz	short typelp_ret ; 20/02/2023
 19124                                  
 19125                                  Error_outputj:
 19126 00002150 BB0100                  	mov	bx,1
 19127                                  	;mov	ax,IOCTL SHL 8
 19128 00002153 B80044                  	mov	ax,4400h
 19129 00002156 CD21                    	int	21h
 19130 00002158 F6C280                  	test	dl,80h
 19131                                  	;test	dl,devid_ISDEV
 19132                                  	;;retnz			; If device, no error message
 19133                                  	;jnz	short tf4
 19134 0000215B 7503                    	jnz	short typelp_ret
 19135 0000215D E9420A                  	jmp	error_output
 19136                                  typelp_ret:
 19137 00002160 C3                      	retn
 19138                                  
 19139                                  ; ---------------------------------------------------------------------------
 19140                                  
 19141                                  ; VOLUME command displays the volume ID on the specified drive
 19142                                  
 19143                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19144                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19145                                  	; 10/06/2023
 19146                                  VOLUME:
 19147                                  	; MSDOS 6.0
 19148 00002161 BE8100                  	mov	si,81h
 19149 00002164 BF[2998]                	mov	di,PARSE_VOL
 19150                                  				;AN000; Get address of PARSE_VOL
 19151 00002167 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 19152 00002169 31D2                    	xor	dx,dx		;AN000;
 19153 0000216B E89B05                  	call	Parse_With_Msg	;AC018; call parser
 19154                                  
 19155                                  	;cmp	ax,-1 ; 0FFFFh
 19156                                  	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 19157                                  	;je	short OkVolArg	;AC000; Yes, display default volume ID
 19158                                  	;;cmp	ax,RESULT_NO_ERROR
 19159                                  	;;cmp	ax,0		;AC000; did we have an error?
 19160                                  	;or	ax,ax ; 0?
 19161                                  	;jnz	short badvolarg	;AC000; Yes, fail.
 19162                                  	; 10/06/2023
 19163 0000216E 40                      	inc	ax  ; cmp ax,-1
 19164 0000216F 7443                    	jz	short OkVolArg ; 0FFFFh -> 0
 19165 00002171 48                      	dec	ax  ; cmp ax,0
 19166 00002172 750A                    	jnz	short badvolarg ; 1 -> 0
 19167                                  	; ax = 0
 19168                                  
 19169                                  ; We have parsed off the drive. See if there are any more chars left
 19170                                  
 19171 00002174 BF[2998]                	mov	di,PARSE_VOL
 19172                                  				;AC000; get address of parse_vol
 19173 00002177 31D2                    	xor	dx,dx		;AC000;
 19174 00002179 E87705                  	call	parse_check_eol ;AC000; call parser
 19175 0000217C 7436                    	jz	short OkVolArg	;AC000; yes, end of road
 19176                                  
 19177                                  ; The line was not interpretable. Report an error.
 19178                                  
 19179                                  badvolarg:
 19180 0000217E E9210D                  	jmp	cerror
 19181                                  
 19182                                  ; ---------------------------------------------------------------------------
 19183                                  
 19184                                  ;***	DisAppend - disable APPEND
 19185                                  ;
 19186                                  ;	ENTRY	nothing
 19187                                  ;
 19188                                  ;	EXIT	nothing
 19189                                  ;
 19190                                  ;	USED	AX,BX
 19191                                  ;
 19192                                  ;	EFFECTS
 19193                                  ;
 19194                                  ;	  APPEND is disabled. If it was active, it will be re-enabled
 19195                                  ;	  after the command finishes, by the HeadFix routine.
 19196                                  ;
 19197                                  ;	NOTE
 19198                                  ;
 19199                                  ;	  This routine must not be called more than once during a single
 19200                                  ;	  command cycle. The second call would permanently disable APPEND.
 19201                                  
 19202                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19203                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1CDFh
 19204                                  	
 19205                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19206                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2289h
 19207                                  
 19208                                  	; MSDOS 6.0
 19209                                  DisAppend:
 19210 00002181 1E                      	push	ds			; save DS
 19211 00002182 06                      	push	es			; save ES
 19212 00002183 57                      	push	di
 19213                                  
 19214                                  	;mov	ax,APPENDINSTALL	; AX = Append Installed Check code
 19215 00002184 B800B7                  	mov	ax,0B700h
 19216 00002187 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 19217 00002189 08C0                    	or	al,al
 19218 0000218B 7423                    	jz	short daRet		; APPEND not installed, return
 19219                                  
 19220                                  	;mov	ax,APPENDDOS		; AX = Get Append Version code
 19221 0000218D B802B7                  	mov	ax,0B702h
 19222 00002190 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 19223 00002192 83F8FF                  	cmp	ax,0FFFFh
 19224 00002195 7519                    	jne	short daRet		; it's not a local version, return
 19225                                  
 19226                                  	;mov	ax,APPENDGETSTATE	; AX = Get Function State code
 19227 00002197 B806B7                  	mov	ax,0B706h
 19228 0000219A CD2F                    	int	2Fh			; talk to APPEND via multiplex
 19229                                  
 19230 0000219C 8E1E[159E]              	mov	ds,[RESSEG]		; DS = resident seg addr
 19231                                  
 19232 000021A0 891E[6002]              	mov	[Append_State],bx	; Append_State = saved APPEND state
 19233 000021A4 C606[6202]FF            	mov	byte [Append_Flag],-1	; Append_Flag = true, restore state
 19234                                  
 19235 000021A9 31DB                    	xor	bx,bx			; BX = APPEND state = off
 19236                                  	;mov	ax,APPENDSETSTATE	; AX = Set Append State code
 19237 000021AB B807B7                  	mov	ax,0B707h
 19238 000021AE CD2F                    	int	2Fh			; talk to APPEND via multiplex
 19239                                  daRet:	
 19240 000021B0 5F                      	pop	di
 19241 000021B1 07                      	pop	es			; restore ES
 19242 000021B2 1F                      	pop	ds			; restore DS
 19243                                  
 19244 000021B3 C3                      	retn
 19245                                  
 19246                                  ; ---------------------------------------------------------------------------
 19247                                  
 19248                                  ; Find the Volume ID on the disk.
 19249                                  
 19250                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19251                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19252                                  	
 19253                                  	; MSDOS 6.0
 19254                                  OkVolArg:
 19255 000021B4 E8CAFF                  	call	DisAppend		; disable APPEND
 19256 000021B7 E86709                  	call	CRLF2
 19257                                  	;mov	al,blank			
 19258 000021BA B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 19259 000021BC E88E01                  	call	PRINT_CHAR		;AN051;  before volume message
 19260 000021BF 1E                      	push	ds
 19261 000021C0 07                      	pop	es
 19262                                  
 19263                                  ; Volume IDs are only findable via extended FCBs or find_first with attributes
 19264                                  ; of volume_id ONLY.
 19265                                  
 19266 000021C1 BF5500                  	mov	di,FCB-7 ; 55h		; Point to extended FCB beginning
 19267 000021C4 B0FF                    	mov	al,-1 ; 0FFh		; Tag to indicate Extention
 19268 000021C6 AA                      	stosb
 19269 000021C7 31C0                    	xor	ax,ax			; Zero padding to volume label
 19270 000021C9 AB                      	stosw
 19271 000021CA AB                      	stosw
 19272 000021CB AA                      	stosb
 19273 000021CC B008                    	mov	al,ATTR_VOLUME_ID ; 8	; Look for volume label
 19274 000021CE AA                      	stosb
 19275 000021CF 47                      	inc	di			; Skip drive byte; it is already set
 19276 000021D0 B90B00                  	mov	cx,11			; fill in remainder of file
 19277 000021D3 B03F                    	mov	al,'?'
 19278 000021D5 F3AA                    	rep	stosb
 19279                                  
 19280                                  ; Set up transfer address (destination of search first information)
 19281                                  
 19282 000021D7 BA[50A0]                	mov	dx,DIRBUF
 19283                                  	;mov	ah,Set_DMA
 19284 000021DA B41A                    	mov	ah,1Ah
 19285 000021DC CD21                    	int	21h
 19286                                  
 19287                                  ; Do the search
 19288                                  
 19289 000021DE BA5500                  	mov	dx,FCB-7 ; 55h
 19290                                  	;mov	ah,Dir_Search_First
 19291 000021E1 B411                    	mov	ah,11h
 19292 000021E3 CD21                    	int	21h
 19293                                  
 19294                                  ;********************************
 19295                                  ; Print volume ID info
 19296                                  
 19297 000021E5 50                      	push	ax			;AC000; AX return from SEARCH_FIRST for VOL ID
 19298 000021E6 A05C00                  	mov	al,[FCB]  ; [5Ch]	;AC000; get drive letter
 19299 000021E9 0440                    	add	al,'@'  ; add al,40h
 19300 000021EB 3C40                    	cmp	al,'@'
 19301 000021ED 7505                    	jne	short drvok
 19302 000021EF A0[299E]                	mov	al,[CURDRV]
 19303                                  	;add	al,capital_A
 19304 000021F2 0441                    	add	al,'A'
 19305                                  drvok:
 19306 000021F4 A2[CAA0]                	mov	[vol_drv],al		;AC000; get drive letter into argument
 19307 000021F7 58                      	pop	ax			;AC000; get return code back
 19308 000021F8 08C0                    	or	al,al			;AC000; volume label found?
 19309 000021FA 7405                    	jz	short Get_vol_name	;AC000; volume label exists - go get it
 19310 000021FC BA[EE92]                	mov	dx,VolMes_Ptr_2		;AC000; set up no volume message
 19311 000021FF EB13                    	jmp	short print_serial	;AC000; go print it
 19312                                  
 19313                                  Get_vol_name:
 19314 00002201 BF[819F]                	mov	di,CHARBUF
 19315 00002204 89FA                    	mov	dx,di
 19316 00002206 BE[58A0]                	mov	si,DIRBUF+8		;AN000;  3/3/KK
 19317 00002209 B90B00                  	mov	cx,11			;AN000;  3/3/KK
 19318 0000220C F3A4                    	rep	movsb			;AN000;  3/3/KK
 19319                                  
 19320 0000220E 30C0                    	xor	al,al			;AC000; store a zero to terminate the string
 19321 00002210 AA                      	stosb
 19322 00002211 BA[FC92]                	mov	dx,VolMes_Ptr		;AC000; set up message
 19323                                  
 19324                                  print_serial:
 19325                                  
 19326                                  ; Attempt to get the volume serial number from the disk. If an error
 19327                                  ; occurs, do not print volume serial number.
 19328                                  
 19329 00002214 52                      	push	dx			;AN000; save message offset
 19330                                  	;mov	ax,(GetSetMediaID SHL 8)
 19331 00002215 B80069                  	mov	ax,6900h		;AC036; Get the volume serial info
 19332 00002218 8A1E5C00                	mov	bl,[FCB] ; [5Ch]	;AN000; get drive number from FCB
 19333 0000221C BA[30A2]                	mov	dx,vol_ioctl_buf	;AN000;target buffer
 19334 0000221F CD21                    	int	21h			;AN000; do the call
 19335                                  			; DOS - 4.0 internal - GET/SET DISK SERIAL NUMBER
 19336                                  			; AL = 00h get serial number / 01h set serial number
 19337                                  			; BL = drive (0=default, 1=A, 2=B, etc)
 19338                                  			; DS:DX -> disk info
 19339 00002221 5A                      	pop	dx			;AN000; get message offset back
 19340 00002222 720B                    	jc	short printvol_end	;AN000; if error, just go print label
 19341 00002224 E80633                  	call	std_printf		;AC000; go print volume message
 19342                                  	;mov	al,blank				
 19343 00002227 B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 19344 00002229 E82101                  	call	PRINT_CHAR		;AN051;  before volume message
 19345 0000222C BA[1593]                	mov	dx,VolSerMes_Ptr 	;AN000; get serial number message
 19346                                  printvol_end:
 19347 0000222F E9FB32                  	jmp	std_printf		;AC000; go print and exit
 19348                                  
 19349                                  ; ---------------------------------------------------------------------------
 19350                                  
 19351                                  ;****************************************************************
 19352                                  ;*
 19353                                  ;* ROUTINE:	Set_ext_error_msg
 19354                                  ;*
 19355                                  ;* FUNCTION:	Sets up extended error message for printing
 19356                                  ;*
 19357                                  ;* INPUT:	return from INT 21
 19358                                  ;*
 19359                                  ;* OUTPUT:	extended error message set up in extended error
 19360                                  ;*		buffer.
 19361                                  ;*
 19362                                  ;****************************************************************
 19363                                  	
 19364                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19365                                  
 19366                                  	; MSDOS 6.0
 19367                                  Set_Ext_Error_Msg:			;AN000;
 19368 00002232 E80D00                  	call	get_ext_error_number	;AC022; get the extended error
 19369 00002235 C606[F191]01            	mov	byte [msg_disp_class],ext_msg_class
 19370                                  	;mov	byte [msg_disp_class],1	;AN000; set up extended error msg class
 19371 0000223A BA[F391]                	mov	dx,extend_buf_ptr 	;AC000; get extended message pointer
 19372 0000223D A3[F391]                	mov	[extend_buf_ptr],ax	;AN000; get message number in control block
 19373 00002240 F9                      	stc				;AN000; make sure carry is set
 19374 00002241 C3                      	retn				;AN000; return
 19375                                  
 19376                                  ; ---------------------------------------------------------------------------
 19377                                  
 19378                                  ;****************************************************************
 19379                                  ;*
 19380                                  ;* ROUTINE:	Get_ext_error_number
 19381                                  ;*
 19382                                  ;* FUNCTION:	Does get extended error function call
 19383                                  ;*
 19384                                  ;* INPUT:	return from INT 21
 19385                                  ;*
 19386                                  ;* OUTPUT:	AX - extended error number
 19387                                  ;*
 19388                                  ;****************************************************************
 19389                                  
 19390                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19391                                  
 19392                                  	; MSDOS 6.0
 19393                                  get_ext_error_number:			;AN022;
 19394                                  
 19395                                  	;SaveReg <BX,CX,DX,SI,DI,BP,ES,DS>
 19396                                  					;AN022; save registers
 19397 00002242 53                      	push	bx
 19398 00002243 51                      	push	cx
 19399 00002244 52                      	push	dx
 19400 00002245 56                      	push	si
 19401 00002246 57                      	push	di
 19402 00002247 55                      	push	bp
 19403 00002248 06                      	push	es
 19404 00002249 1E                      	push	ds
 19405                                  	;mov	ah,GetExtendedError	;AN022; get extended error
 19406 0000224A B459                    	mov	ah,59h
 19407 0000224C 31DB                    	xor	bx,bx			;AN022; clear BX
 19408 0000224E CD21                    	int	21h			;AN022;
 19409                                  			; DOS - 3+ - GET EXTENDED ERROR CODE
 19410                                  			; BX = version code (0000h for DOS 3.x)
 19411                                  
 19412                                  	;RestoreReg  <DS,ES,BP,DI,SI,DX,CX,BX>
 19413                                  					;AN022; restore registers
 19414 00002250 1F                      	pop	ds
 19415 00002251 07                      	pop	es
 19416 00002252 5D                      	pop	bp
 19417 00002253 5F                      	pop	di
 19418 00002254 5E                      	pop	si
 19419 00002255 5A                      	pop	dx
 19420 00002256 59                      	pop	cx
 19421 00002257 5B                      	pop	bx
 19422                                  
 19423 00002258 C3                      	retn				;AN022; return
 19424                                  
 19425                                  ;============================================================================
 19426                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
 19427                                  ;============================================================================
 19428                                  ; 08/10/2018 - Retro DOS v3.0
 19429                                  
 19430                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
 19431                                  
 19432                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 19433                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1DB7h
 19434                                  
 19435                                  ; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19436                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 2361h
 19437                                  
 19438                                  ; ---------------------------------------------------------------------------
 19439                                  
 19440                                  ; MSDOS 6.0
 19441                                  ;***	Version - display DOS version
 19442                                  ;
 19443                                  ;	SYNTAX	ver [/debug]
 19444                                  ;
 19445                                  ;		/debug - display additional DOS configuration info
 19446                                  ;
 19447                                  ;	ENTRY	command-line tail is in PSP
 19448                                  ;
 19449                                  ;	EXIT	if successful, nothing
 19450                                  ;		if parse fails,
 19451                                  ;		  parse error message is set up (for Std_EPrintf)
 19452                                  ;		    AX = system parser error code
 19453                                  ;		    DX = ptr to message block
 19454                                  ;		  we jump to CError
 19455                                  ;
 19456                                  ;	EFFECTS
 19457                                  ;	  If parse fails, a parse error message is displayed.
 19458                                  ;	  Otherwise, version message is displayed.
 19459                                  ;	  If /debug is specified, additional DOS info is displayed.
 19460                                  
 19461                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19462                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19463                                  VERSION:
 19464                                  	;assume	ds:TRANGROUP,es:TRANGROUP
 19465                                  
 19466                                  ;	Parse command line for /debug switch.
 19467                                  
 19468 00002259 BE8100                  	mov	si,81h			; DS:SI = ptr to command tail
 19469 0000225C BF[EC98]                	mov	di,PARSE_VER		; ES:DI = ptr to parse block
 19470 0000225F 31C9                    	xor	cx,cx			; CX = # positional param's found
 19471 00002261 E8A504                  	call	Parse_With_Msg
 19472                                  
 19473 00002264 B301                    	mov	bl,1			; BL = flag = /debug present
 19474                                  	;cmp	ax,RESULT_NO_ERROR
 19475                                  	;cmp	ax,0
 19476                                  	;je	short verPrintVer	; something parsed - must be /debug
 19477 00002266 09C0                    	or	ax,ax
 19478 00002268 740A                    	jz	short verPrintVer 
 19479 0000226A FECB                    	dec	bl			; BL = flag = no /debug present
 19480                                  	;cmp	ax,END_OF_LINE ; -1
 19481 0000226C 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 19482                                  
 19483                                  ; 20/07/2024 - Retro DOS v4.2 COMMAND.COM
 19484                                  %if 0
 19485                                  	je	short verPrintVer	; reached end of line - ok
 19486                                  %else
 19487 0000226F 7414                    	je	short not_truever_sw
 19488                                  %endif
 19489                                  
 19490                                  ;	The parse failed. Error message has been set up.
 19491                                  
 19492 00002271 E92E0C                  	jmp	cerror
 19493                                  
 19494                                  verPrintVer:
 19495                                  
 19496                                  ; 20/07/2024 - Retro DOS v4.2 COMMAND.COM
 19497                                  %if 1
 19498                                  check_t_switch:
 19499 00002274 813E[09AA][0C99]        	cmp	word [PARSE1_SYN],SLASH_T_SYN ; "/T" ; /t switch
 19500 0000227A 7509                    	jne	short not_truever_sw
 19501 0000227C BA[3099]                	mov	dx,RD4CMD_VER_MSG
 19502 0000227F B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9 ; print the message
 19503 00002281 CD21                    	int	21h
 19504 00002283 EB43                    	jmp	short verDone
 19505                                  not_truever_sw:
 19506                                  %endif
 19507 00002285 53                      	push	bx			; save /debug flag
 19508 00002286 E89808                  	call	CRLF2
 19509 00002289 E83F00                  	call	PRINT_VERSION
 19510 0000228C E89208                  	call	CRLF2
 19511 0000228F 5B                      	pop	bx   			; BL = /debug flag
 19512 00002290 08DB                    	or	bl,bl
 19513 00002292 7434                    	jz	short verDone		; /debug is false - we're done
 19514                                  
 19515                                  ;*	For /debug, display DOS internal revision and DOS location
 19516                                  ;	(low memory, HMA, or ROM).
 19517                                  
 19518                                  ;	Bugbug:	use symbols for bitmasks below.
 19519                                  
 19520                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) + 6 ; M013
 19521 00002294 B80633                  	mov	ax,3306h
 19522 00002297 CD21                    	int	21h
 19523                                  		; DOS - 5+ Get TRUE Version Number
 19524                                  		; (BL major, BH minor, DL revision, DH flags)
 19525 00002299 88D0                    	mov	al,dl			;revision number in dl; M013
 19526 0000229B 88F7                    	mov	bh,dh			;flags in dh now; M013
 19527                                  ;M032	and	al,7			; AL = DOS internal revision
 19528 0000229D 3C19                    	cmp	al,'Z'-'A' ; 25	 ;M032	; revision in A-to-Z range?
 19529                                  	;jbe	short @f	 ;M032	; A-to-Z revision ok
 19530 0000229F 7602                    	jbe	short ver1
 19531 000022A1 B0E9                    	mov	al,'*'-'A' ; -23 ;M032	; beyond Z, just say revision *
 19532                                  ;@@:
 19533                                  ver1:
 19534 000022A3 0441                    	add	al,'A' ; 41h		; AL = DOS internal rev letter
 19535 000022A5 A2[C8A0]                	mov	[One_Char_Val],al
 19536 000022A8 BA[4C94]                	mov	dx,dosrev_ptr
 19537 000022AB E87F32                  	call	std_printf		; print DOS internal revision
 19538                                  
 19539 000022AE B104                    	mov	cl,4
 19540 000022B0 D2EF                    	shr	bh,cl			; CY = DOS in ROM
 19541 000022B2 7209                    	jc	short verRom
 19542 000022B4 D0EF                    	shr	bh,1			; CY = DOS in HMA
 19543 000022B6 720A                    	jc	short verHma
 19544                                  
 19545                                  ;	DOS isn't in ROM or HMA, so it must be in lower memory.
 19546                                  
 19547                                  	;mov	dx,offset TRANGROUP:DosLow_Ptr
 19548 000022B8 BA[6094]                	mov	dx,DosLow_Ptr
 19549 000022BB EB08                    	jmp	short verPrintLoc
 19550                                  verRom: 
 19551                                  	;mov	dx,offset TRANGROUP:DosRom_Ptr
 19552 000022BD BA[5A94]                	mov	dx,DosRom_Ptr
 19553 000022C0 EB03                    	jmp	short verPrintLoc
 19554                                  verHma: 
 19555                                  	;mov	dx,offset TRANGROUP:DosHma_Ptr
 19556 000022C2 BA[5D94]                	mov	dx,DosHma_Ptr
 19557                                  verPrintLoc:
 19558 000022C5 E86532                  	call	std_printf
 19559                                  verDone:
 19560 000022C8 E95608                  	jmp	CRLF2
 19561                                  
 19562                                  ; 21/02/2023
 19563                                  ;	; MSDOS 3.3
 19564                                  ;VERSION:
 19565                                  ;	call	CRLF2
 19566                                  ;	call	PRINT_VERSION
 19567                                  ;	jmp	CRLF2
 19568                                  
 19569                                  ; =============== S U B	R O U T	I N E =======================================
 19570                                  
 19571                                  	; 21/02/2023 - Retro DOS v4.0
 19572                                  PRINT_VERSION:
 19573                                  	;mov	ah,GET_VERSION ; 30h
 19574 000022CB B430                    	mov	ah,30h
 19575 000022CD CD21                    	int	21h	; DOS -	GET DOS	VERSION
 19576                                  			; Return: AL = major version number (00h for DOS 1.x)
 19577 000022CF 50                      	push	ax
 19578 000022D0 30E4                    	xor	ah,ah
 19579 000022D2 A3[C4A0]                	mov	[Major_Ver_Num],ax
 19580 000022D5 58                      	pop	ax
 19581 000022D6 86E0                    	xchg	ah,al
 19582 000022D8 30E4                    	xor	ah,ah
 19583 000022DA A3[C6A0]                	mov	[Minor_Ver_Num],ax
 19584 000022DD BA[D592]                	mov	dx,VerMes_Ptr
 19585 000022E0 E94A32                  	jmp	std_printf
 19586                                  
 19587                                  ; =============== S U B	R O U T	I N E =======================================
 19588                                  
 19589                                  	; 21/02/2023 - Retro DOS v4.0
 19590                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19591                                  PRINT_PROMPT:
 19592 000022E3 1E                      	push	ds
 19593 000022E4 0E                      	push	cs
 19594 000022E5 1F                      	pop	ds		; Make sure DS is in TRANGROUP
 19595 000022E6 06                      	push	es
 19596 000022E7 E87805                  	call	find_prompt	; Look for prompt string
 19597 000022EA 7206                    	jc	short PP0	; Can't find one
 19598 000022EC 26803D00                	cmp	byte [es:di],0
 19599 000022F0 7524                    	jnz	short PP1
 19600                                  PP0:				; Use default prompt
 19601 000022F2 E86700                  	call	PRINT_DRIVE
 19602 000022F5 B03E                    	mov	al,'>'
 19603                                  	;mov	al,SYM
 19604 000022F7 E85300                  	call	PRINT_CHAR
 19605 000022FA EB36                    	jmp	short PP5
 19606                                  ;PP1:
 19607                                  ;	mov	al,[es:di]	; Get a char
 19608                                  ;	inc	di
 19609                                  ;	or	al,al
 19610                                  ;	jz	short PP5	; Nul terminated
 19611                                  ;	; 21/02/2023
 19612                                  ;	cmp	al,'$' ; 24h
 19613                                  ;	;cmp	al,[DOLLAR]	; Meta character
 19614                                  ;	jz	short PP2	; Nope
 19615                                  ;	call	PRINT_CHAR
 19616                                  ;	jmp	short PP1
 19617                                  PP2:
 19618 000022FC 268A05                  	mov	al,[es:di]
 19619 000022FF 47                      	inc	di
 19620                                  	;mov	bx,CLSSTRING+2	; "[2J"
 19621 00002300 BB[BA95]                	mov	bx,PROMPT_TABLE-3
 19622 00002303 08C0                    	or	al,al
 19623 00002305 742B                    	jz	short PP5
 19624                                  PP3:
 19625 00002307 83C303                  	add	bx,3
 19626                                  	; 21/02/2023
 19627 0000230A E82C06                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 19628                                  	;call	UPCONV_MAPCALL  ; MSDOS 3.3
 19629 0000230D 3A07                    	cmp	al,[bx]
 19630 0000230F 7416                    	jz	short PP4
 19631 00002311 803F00                  	cmp	byte [bx],0
 19632 00002314 75F1                    	jnz	short PP3
 19633                                  	;jmp	short PP1
 19634                                  	; 21/02/2023
 19635                                  PP1:
 19636 00002316 268A05                  	mov	al,[es:di]	; Get a char
 19637 00002319 47                      	inc	di
 19638 0000231A 08C0                    	or	al,al
 19639 0000231C 7414                    	jz	short PP5	; Nul terminated
 19640                                  	; 21/02/2023
 19641 0000231E 3C24                    	cmp	al,'$' ; 24h
 19642                                  	;cmp	al,[DOLLAR]	; Meta character
 19643 00002320 74DA                    	jz	short PP2	; Nope
 19644 00002322 E82800                  	call	PRINT_CHAR
 19645 00002325 EBEF                    	jmp	short PP1
 19646                                  PP4:
 19647 00002327 06                      	push	es
 19648 00002328 57                      	push	di
 19649 00002329 0E                      	push	cs
 19650 0000232A 07                      	pop	es
 19651 0000232B FF5701                  	call	word [bx+1]
 19652 0000232E 5F                      	pop	di
 19653 0000232F 07                      	pop	es
 19654 00002330 EBE4                    	jmp	short PP1
 19655                                  PP5:
 19656 00002332 07                      	pop	es		; Restore segments
 19657 00002333 1F                      	pop	ds
 19658 00002334 C3                      	retn
 19659                                  
 19660                                  ; ---------------------------------------------------------------------------
 19661                                  
 19662                                  PRINT_BACK:
 19663                                  	; 21/02/2023
 19664 00002335 BA[D293]                	mov	dx,dback_ptr
 19665 00002338 E9F231                  	jmp	std_printf
 19666                                  
 19667                                  ; ---------------------------------------------------------------------------
 19668                                  
 19669                                  PRINT_EQ:
 19670 0000233B B03D                    	mov	al,'='
 19671 0000233D EB0E                    	jmp	short PRINT_CHAR
 19672                                  
 19673                                  ; ---------------------------------------------------------------------------
 19674                                  
 19675                                  PRINT_ESC:
 19676 0000233F B01B                    	mov	al,1Bh
 19677 00002341 EB0A                    	jmp	short PRINT_CHAR
 19678                                  
 19679                                  ; ---------------------------------------------------------------------------
 19680                                  
 19681                                  	; 21/02/2023
 19682                                  PRINT_G:
 19683                                  	;mov	al,[RABRACKET]
 19684 00002343 B03E                    	mov	al,'>' ; 3Eh
 19685 00002345 EB06                    	jmp	short PRINT_CHAR
 19686                                  
 19687                                  ; ---------------------------------------------------------------------------
 19688                                  
 19689                                  	; 21/02/2023
 19690                                  PRINT_L:
 19691                                  	;mov	al,[LABRACKET]
 19692 00002347 B03C                    	mov	al,'<' ; 3Ch
 19693 00002349 EB02                    	jmp	short PRINT_CHAR
 19694                                  
 19695                                  ; ---------------------------------------------------------------------------
 19696                                  
 19697                                  	; 21/02/2023
 19698                                  Print_B:
 19699                                  	;mov	al,[VBAR]
 19700 0000234B B07C                    	mov	al,'|' ; 7Ch
 19701                                  
 19702                                  ; =============== S U B	R O U T	I N E =======================================
 19703                                  
 19704                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19705                                  PRINT_CHAR:
 19706                                  	; MSDOS 6.0
 19707                                  
 19708                                  ;	Bugbug:	Why bother with ds,es here?
 19709                                  		
 19710 0000234D 06                      	push	es
 19711 0000234E 1E                      	push	ds
 19712 0000234F 07                      	pop	es
 19713 00002350 57                      	push	di
 19714 00002351 52                      	push	dx
 19715 00002352 88C2                    	mov	dl,al		;AC000; Get char into al
 19716                                  	;mov	ah,STD_CON_OUTPUT
 19717                                  				;AC000; print the char to stdout
 19718 00002354 B402                    	mov	ah,2
 19719 00002356 CD21                    	int	21h		;AC000;
 19720 00002358 5A                      	pop	dx
 19721 00002359 5F                      	pop	di
 19722 0000235A 07                      	pop	es
 19723 0000235B C3                      	retn
 19724                                  
 19725                                  ; ---------------------------------------------------------------------------
 19726                                  
 19727                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19728                                  PRINT_DRIVE:
 19729                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 19730 0000235C B419                    	mov	ah,19h
 19731 0000235E CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
 19732 00002360 0441                    	add	al,'A'
 19733                                  	;add	al,[CAPITAL_A]
 19734                                  	;call	PRINT_CHAR
 19735                                  	;retn
 19736                                  	; 21/02/2023
 19737 00002362 EBE9                    	jmp	short PRINT_CHAR
 19738                                  
 19739                                  ; ---------------------------------------------------------------------------
 19740                                  
 19741                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19742                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EB6h
 19743                                  
 19744                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19745                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2460h
 19746                                  
 19747                                  build_dir_for_prompt:
 19748 00002364 30D2                    	xor	dl,dl
 19749 00002366 BE[50A0]                	mov	si,BWDBUF
 19750 00002369 89F7                    	mov	di,si
 19751 0000236B A0[299E]                	mov	al,[CURDRV]
 19752 0000236E 0441                    	add	al,'A'
 19753 00002370 B43A                    	mov	ah,':'
 19754 00002372 AB                      	stosw
 19755 00002373 A0[1A9E]                	mov	al,[DIRCHAR]
 19756 00002376 AA                      	stosb
 19757 00002377 87F7                    	xchg	si,di
 19758 00002379 893E[B7A0]              	mov	[string_ptr_2],di
 19759                                  	;mov	ah,CURRENT_DIR ; 47h
 19760 0000237D B447                    	mov	ah,47h
 19761 0000237F CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 19762                                  			; DL = drive (0=default,1=A,etc.)
 19763                                  			; DS:SI	points to 64-byte buffer area
 19764                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 19765 00002381 BA[BA93]                	mov	dx,string_buf_ptr
 19766 00002384 7303                    	jnc	short doprint
 19767                                  	;mov	dx,BADCURDRVPTR	; MSDOS 3.3
 19768 00002386 BA[8292]                	mov	dx,BADCURDRV
 19769                                  doprint:
 19770                                  	;call	std_printf
 19771                                  	;retn
 19772 00002389 E9A131                  	jmp	std_printf
 19773                                  
 19774                                  ; =============== S U B	R O U T	I N E =======================================
 19775                                  
 19776                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19777                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EDFh
 19778                                  
 19779                                  build_dir_for_chdir:
 19780 0000238C E80D00                  	call	build_dir_string
 19781 0000238F BA[50A0]                	mov	dx,DIRBUF
 19782 00002392 8916[B7A0]              	mov	[string_ptr_2],dx
 19783                                  	;mov	dx,offset trangroup:string_buf_ptr ; MSDOS 6.0
 19784                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 19785 00002396 BA[BA93]                	mov	dx,string_buf_ptr
 19786                                  	;call	std_printf
 19787                                  	;retn
 19788                                  	; 21/02/2023
 19789                                  	;jmp	short doprint
 19790 00002399 E99131                  	jmp	std_printf
 19791                                  
 19792                                  ; =============== S U B	R O U T	I N E =======================================
 19793                                  
 19794                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19795                                  build_dir_string:
 19796 0000239C 8A165C00                	mov	dl,[FCB] ; mov dl,[5Ch]
 19797 000023A0 88D0                    	mov	al,dl
 19798 000023A2 0440                    	add	al,'@'	; 40h
 19799 000023A4 3C40                    	cmp	al,'@'
 19800 000023A6 7506                    	jne	short gotdrive
 19801 000023A8 0206[299E]              	add	al,[CURDRV]
 19802 000023AC FEC0                    	inc	al
 19803                                  gotdrive:
 19804 000023AE 50                      	push	ax
 19805 000023AF BE[53A0]                	mov	si,BWDBUF+3
 19806                                  	;mov	ah,CURRENT_DIR ; 47h
 19807 000023B2 B447                    	mov	ah,47h
 19808 000023B4 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 19809                                  			; DL = drive (0=default,1=A,etc.)
 19810                                  			; DS:SI	points to 64-byte buffer area
 19811 000023B6 7305                    	jnc	short dpbisok
 19812 000023B8 0E                      	push	cs
 19813 000023B9 1F                      	pop	ds
 19814 000023BA E9ED09                  	jmp	DRVBAD
 19815                                  dpbisok:
 19816 000023BD BF[50A0]                	mov	di,BWDBUF
 19817 000023C0 89FA                    	mov	dx,di
 19818 000023C2 58                      	pop	ax
 19819 000023C3 B43A                    	mov	ah,':'
 19820 000023C5 AB                      	stosw
 19821 000023C6 A0[1A9E]                	mov	al,[DIRCHAR]
 19822 000023C9 AA                      	stosb
 19823 000023CA C3                      	retn
 19824                                  
 19825                                  ; ---------------------------------------------------------------------------
 19826                                  
 19827                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19828                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1F1Fh
 19829                                  
 19830                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19831                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:24C9h
 19832                                  PATH:
 19833                                  	; MSDOS 6.0
 19834 000023CB 30C0                    	xor	al,al			;AN049; Set up holding buffer
 19835 000023CD BF[439B]                	mov	di,SRCXNAME		;AN049;  for PATH while parsing
 19836 000023D0 AA                      	stosb				;AN049; Initialize PATH to null
 19837 000023D1 4F                      	dec	di			;AN049; point to the start of buffer
 19838 000023D2 E8DE0C                  	call	PGETARG 		; Pre scan for arguments
 19839 000023D5 7460                    	jz	short disppath		; Print the current path
 19840                                  	;cmp	al,semicolon		;AC049; NUL path argument?
 19841 000023D7 3C3B                    	cmp	al,';' ; 3Bh
 19842 000023D9 7503                    	jne	short pathslp 		;AC049;
 19843 000023DB 46                      	inc	si			;AN049; point past semicolon
 19844 000023DC EB1B                    	jmp	short scan_white	;AC049; Yes - make sure nothing else on line
 19845                                  pathslp:					; Get the user specified path
 19846 000023DE AC                      	lodsb				; Get a character
 19847 000023DF 3C0D                    	cmp	al,0Dh
 19848                                  	;cmp	al,END_OF_LINE_IN	;AC049; Is it end of line?
 19849 000023E1 7434                    	je	short path_eol		;AC049; yes - end of command
 19850 000023E3 E82905                  	call	testkanj		;See if DBCS
 19851 000023E6 7405                    	jz	short notkanj2		;No - continue
 19852 000023E8 AA                      	stosb				;AC049; Yes - store the first byte
 19853 000023E9 AC                      	lodsb				;skip second byte of DBCS
 19854                                  path_hold:				;AN049;
 19855 000023EA AA                      	stosb				;AC049; Store a byte in the PATH buffer
 19856 000023EB EBF1                    	jmp	short pathslp		;continue parsing
 19857                                  notkanj2:
 19858 000023ED E84905                  	call	UPCONV			;upper case the character
 19859                                  
 19860 000023F0 3C3B                    	cmp	al,';' ; 3Bh
 19861                                  	;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
 19862 000023F2 74F6                    	je	short path_hold		;AC049; go store it
 19863 000023F4 E83F07                  	call	DELIM			;delimiter?
 19864 000023F7 75F1                    	jnz	short path_hold		;AC049; no - go store character
 19865                                  scan_white:				;AN049; make sure were at EOL
 19866 000023F9 AC                      	lodsb				;AN049; get a character
 19867 000023FA 3C0D                    	cmp	al,0Dh
 19868                                  	;cmp	al,END_OF_LINE_IN	;AN049; end of line?
 19869 000023FC 7419                    	je	short path_eol		;AN049; yes - go set path
 19870 000023FE 3C20                    	cmp	al,' ' ; 20h
 19871                                  	;cmp	al,blank		;AN049; whitespace?
 19872 00002400 74F7                    	je	short scan_white	;AN049; yes - continue scanning
 19873                                  	;cmp	al,9
 19874 00002402 3C09                    	cmp	al,tab_chr ; 9		;AN049; whitespace?
 19875 00002404 74F3                    	je	short scan_white	;AN049; yes - continue scanning
 19876                                  
 19877 00002406 BA[F391]                	mov	dx,extend_buf_ptr 	;AN049; no - set up error message
 19878                                  	;mov	word [extend_buf_ptr],1	;AN049; get "Too many parameters" message number
 19879 00002409 C706[F391]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 19880                                  	;mov	byte [msg_disp_class],2		
 19881                                  					;AN049; set up parse error msg class
 19882 0000240F C606[F191]02            	mov	byte [msg_disp_class],parse_msg_class
 19883 00002414 E98B0A                  	jmp	cerror			;AN049;
 19884                                  path_eol:				;AN049; Parsing was clean
 19885 00002417 30C0                    	xor	al,al			;AN049; null terminate the PATH
 19886 00002419 AA                      	stosb				;AN049;    buffer
 19887 0000241A E84004                  	call	find_path		;AN049; Find PATH in environment
 19888 0000241D E81404                  	call	delete_path		;AC049; Delete any offending name
 19889 00002420 E8CA04                  	call	scan_double_null	;AC049; Scan to end of environment
 19890 00002423 E89A04                  	call	move_name		;AC049; move in PATH=
 19891 00002426 BE[439B]                	mov	si,SRCXNAME		;AN049; Set up source as PATH buffer
 19892                                  store_path:				;AN049; Store the PATH in the environment
 19893 00002429 AC                      	lodsb				;AN049; Get a character
 19894                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN049; null character?
 19895 0000242A 20C0                    	and	al,al ; al=0 ?
 19896 0000242C 7405                    	jz	short got_paths		;AN049; yes - exit
 19897 0000242E E82A05                  	call	store_char		;AN049; no - store character
 19898 00002431 EBF6                    	jmp	short store_path	;AN049; continue
 19899                                  got_paths:				;AN049; we're finished
 19900 00002433 31C0                    	xor	ax,ax			;	null terminate the PATH in
 19901 00002435 AB                      	stosw				;    	the environment
 19902 00002436 C3                      	retn
 19903                                  disppath:
 19904 00002437 E82304                  	call	find_path		;AN049;
 19905 0000243A E80300                  	call	print_path
 19906                                  	;call	CRLF2
 19907                                  	;retn
 19908                                  	; 21/02/2023
 19909 0000243D E9E106                  	jmp	CRLF2
 19910                                  
 19911                                  ; =============== S U B	R O U T	I N E =======================================
 19912                                  
 19913                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19914                                  print_path:
 19915 00002440 26803D00                	cmp	byte [es:di],0
 19916 00002444 750A                    	jnz	short path1
 19917                                  path0:
 19918 00002446 BA[4893]                	mov	dx,NULLPATH_PTR
 19919 00002449 0E                      	push	cs
 19920 0000244A 07                      	pop	es
 19921 0000244B 0E                      	push	cs
 19922 0000244C 1F                      	pop	ds
 19923 0000244D E9DD30                  	jmp	std_printf
 19924                                  path1:
 19925 00002450 06                      	push	es
 19926 00002451 1F                      	pop	ds
 19927 00002452 83EF05                  	sub	di,5
 19928 00002455 89FE                    	mov	si,di
 19929 00002457 E8AD04                  	call	SCASB2		; Look for null
 19930                                  	;cmp	cx,0FFh ; 255
 19931                                  	; 21/02/2023
 19932                                  	;ch = 0
 19933 0000245A 80F9FF                  	cmp	cl,255
 19934 0000245D 74E7                    	je	short path0
 19935 0000245F 0E                      	push	cs
 19936 00002460 07                      	pop	es
 19937 00002461 BF[ADA7]                	mov	di,Arg_Buf
 19938                                  	;mov	dx,100h ; 256
 19939                                  	;sub	dx,cx
 19940                                  	;xchg	dx,cx
 19941                                  	; 21/02/2023
 19942 00002464 F6D9                    	neg	cl ; 256-cl
 19943 00002466 F3A4                    	rep	movsb
 19944 00002468 BA[9093]                	mov	dx,arg_buf_ptr
 19945 0000246B 0E                      	push	cs
 19946 0000246C 1F                      	pop	ds
 19947 0000246D E9BD30                  	jmp	std_printf
 19948                                  
 19949                                  ; ---------------------------------------------------------------------------
 19950                                  
 19951                                  ; ****************************************************************
 19952                                  ; *
 19953                                  ; * ROUTINE:	 CLS
 19954                                  ; *
 19955                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
 19956                                  ; *		 installed, send a control string to clear the
 19957                                  ; *		 screen.
 19958                                  ; *
 19959                                  ; * INPUT:	 command line at offset 81H
 19960                                  ; *
 19961                                  ; * OUTPUT:	 none
 19962                                  ; *
 19963                                  ; ****************************************************************
 19964                                  
 19965                                  	; MSDOS 6.0
 19966                                  
 19967                                  ANSI_installed	equ 0FFh
 19968                                  
 19969                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19970                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19971                                  CLS:
 19972                                  	;;mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
 19973                                  	;mov	ah,1Ah
 19974                                  	;mov	al,0			;AN000;
 19975 00002470 B8001A                  	mov	ax,1A00h
 19976 00002473 CD2F                    	int	2Fh			;AN000;
 19977                                  		; - Multiplex - DOS 4+ ANSI.SYS internal - INSTALLATION CHECK
 19978                                  		; Return: AL = FFh if installed
 19979 00002475 3CFF                    	cmp	al,ANSI_installed	;AN000;
 19980 00002477 7429                    	je	short ansicls 		;AN000; installed - go do ANSI CLS
 19981                                  
 19982                                  check_lines:
 19983                                  	;mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ; 440Ch
 19984 00002479 B80C44                  	mov	ax,440Ch		;AN000; get lines per page on display
 19985                                  	;mov	bx,stdout		;AN000; lines for stdout
 19986 0000247C BB0100                  	mov	bx,1   ; handle
 19987                                  	;;mov	ch,ioc_sc		;AN000; type is display
 19988                                  	;mov	ch,3   ; CON device	
 19989                                  	;;mov	cl,get_generic		;AN000; get information
 19990                                  	;mov	cl,7Fh ; minor function, get display info
 19991                                  	; 25/04/2023
 19992 0000247F B97F03                  	mov	cx,037Fh
 19993 00002482 BA[1EA2]                	mov	dx,Display_Ioctl	;AN000;
 19994 00002485 CD21                    	int	21h			;AN000;
 19995 00002487 720A                    	jc	short no_variable	;AN000; function had error, use default
 19996                                  		; 21/02/2023
 19997                                  		; ds:dx = parameter block
 19998                                  		; --- https://stanislavs.org/helppc/int_21-44-c.html ---
 19999                                  		; offset 00h  byte  level (0 for DOS 4.0)
 20000                                  		;   	 01h  byte  reserved
 20001                                  		;   	 02h  word  length of following data
 20002                                  		;   	 04h  word  control flags
 20003                                  		;	       bit 0 set for blink, clear for intensity
 20004                                  		;	       bits 1 to 15 reserved
 20005                                  		;   	 06h  byte  mode type (1=text, 2=graphics)
 20006                                  		;   	 07h  byte  reserved
 20007                                  		;   	 08h  word  colors; 0=monochrome, n=bits per pixel
 20008                                  		;   	 0Ah  word  pixel columns
 20009                                  		;   	 0Ch  word  pixel rows
 20010                                  		;   	 0Eh  word  character columns
 20011                                  		;   	 10h  word  character rows
 20012                                  	
 20013                                  	;mov	ax,[LinPerPag] ; [Display_Ioctl+10h]
 20014                                  	;				;AN000; get number of rows returned
 20015                                  	;mov	dh,al			;AN000; set number of rows
 20016                                  	;mov	ax,[display_width] ; [Display_Ioctl+0Eh]
 20017                                  	;				;AN000; get number of columns returned
 20018                                  	;mov	dl,al			;AN000; set number of columns
 20019                                  	; 21/02/2023
 20020 00002489 8A16[2CA2]              	mov	dl,[display_width]
 20021 0000248D 8A36[2EA2]              	mov	dh,[LinPerPag]
 20022 00002491 EB3B                    	jmp	short regcls		;AN000; go do cls
 20023                                  
 20024                                  no_variable:
 20025                                  	;;mov	bx,stdout		;AC000; set handle as stdout
 20026                                  	;mov	bx,1
 20027                                  	; bx = 1
 20028                                  	;mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
 20029 00002493 B80044                  	mov	ax,4400h
 20030 00002496 CD21                    	int	21h			;AC000;
 20031 00002498 F6C280                  	test	dl,80h
 20032                                  	;test	dl,devid_ISDEV		;AC000; is handle a device
 20033 0000249B 7405                    	jz	short ansicls 		;AC000; If a file put out ANSI
 20034 0000249D F6C210                  	test	dl,10h
 20035                                  	;test	dl,devid_SPECIAL	;AC000;
 20036 000024A0 7505                    	jnz	short cls_normal	;AC000; If not special CON, do ANSI
 20037                                  
 20038                                  ansicls:
 20039 000024A2 E85200                  	call	ansi_cls		;AN000; clear the screen
 20040 000024A5 EB2C                    	jmp	short cls_ret		;AN000; exit
 20041                                  
 20042                                  ; Get video mode
 20043                                  
 20044                                  cls_normal:				;AC000;
 20045                                  	;mov	ah,get_video_state	;AC000; set up to get video state
 20046 000024A7 B40F                    	mov	ah,0Fh
 20047                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 20048 000024A9 CD10                    	int	10h
 20049 000024AB 3C03                    	cmp	al,3
 20050                                  	;cmp	al,video_alpha		;AC000; see if in text mode
 20051 000024AD 760A                    	jbe	short DoAlpha
 20052 000024AF 3C07                    	cmp	al,7
 20053                                  	;cmp	al,video_bw		;AC000; see if black & white card
 20054 000024B1 7406                    	je	short DoAlpha
 20055                                  
 20056                                  ; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
 20057                                  ; be just as bogus and set the mode that we just got. This will blank the
 20058                                  ; screen too.
 20059                                  
 20060                                  	;mov	ah,set_video_mode	;AC000; set video mode call
 20061 000024B3 B400                    	mov	ah,0
 20062                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 20063 000024B5 CD10                    	int	10h
 20064 000024B7 EB1A                    	jmp	short cls_ret		;AC000; exit
 20065                                  
 20066                                  DoAlpha:
 20067                                  
 20068                                  ; Get video mode and number of columns to scroll
 20069                                  
 20070                                  ;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
 20071                                  ;M01   adaptors. We circumvent this by reaching directly into the BIOS data
 20072                                  ;M01   area
 20073                                  ;M01   Commented out code here is the original
 20074                                  ;M01	mov	ah,get_video_state	;AC000; set up to get current video state
 20075                                  ;M01	int	video_io_int		;AC000; do int 10h - BIOS video IO
 20076                                  ;M01	mov	dl,ah
 20077                                  ;M01	mov	dh,linesperpage 	;AC000; have 25 rows on the screen
 20078                                  
 20079                                  ;M01   Following code lifted from a fix Compaq applied to ANSI
 20080                                  
 20081 000024B9 1E                      	push	ds
 20082                                  	;mov	ax,ROMBIOS_DATA 	; GET ROM Data segment	M01
 20083 000024BA B84000                  	mov	ax,40h
 20084 000024BD 8ED8                    	mov	ds,ax			;  *			M01
 20085                                  
 20086                                  	;mov	dx,[CRT_Cols]		; Get Columns - assume < 256 M01
 20087 000024BF 8A164A00                	mov	dl,[4Ah]
 20088                                  	;mov	dh,[CRT_Rows]		; GET MAX NUM OF ROWS	M01
 20089 000024C3 8A368400                	mov	dh,[84h]
 20090 000024C7 1F                      	pop	ds			;			M01
 20091                                  
 20092 000024C8 08F6                    	or	dh,dh			; Q:ZERO		M01
 20093 000024CA 7502                    	jnz	short regcls		;  *JMP IF NO		M01
 20094                                  
 20095                                  	;mov	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
 20096                                  	; 25/04/2023
 20097 000024CC B619                    	mov	dh,25
 20098                                  regcls:
 20099 000024CE FEC6                    	inc	dh			; height+1		M018
 20100 000024D0 E80100                  	call	reg_cls 		; go clear the screen
 20101                                  cls_ret:
 20102 000024D3 C3                      	retn				; exit
 20103                                  
 20104                                  ; ---------------------------------------------------------------------------
 20105                                  
 20106                                  ; MSDOS 6.0
 20107                                  
 20108                                  ; ****************************************************************
 20109                                  ; *
 20110                                  ; * ROUTINE:	 REG_CLS
 20111                                  ; *
 20112                                  ; * FUNCTION:	 Clear the screen using INT 10H.
 20113                                  ; *
 20114                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
 20115                                  ; *		 DH = NUMBER OF ROWS
 20116                                  ; *
 20117                                  ; * OUTPUT:	 none
 20118                                  ; *
 20119                                  ; ****************************************************************
 20120                                  
 20121                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20122                                  reg_cls:
 20123                                  ; Set overscan to black.
 20124                                  
 20125 000024D4 FECE                    	dec	dh			; decrement rows and columns
 20126 000024D6 FECA                    	dec	dl			;  to zero base
 20127 000024D8 52                      	push	dx			; save rows,columns
 20128                                  	;mov	ah,set_color_palette	; set up to set the color to blank
 20129 000024D9 B40B                    	mov	ah,0Bh
 20130 000024DB 31DB                    	xor	bx,bx
 20131                                  	;int	video_io_int		; do int 10h - BIOS video IO
 20132 000024DD CD10                    	int	10h
 20133 000024DF 5A                      	pop	dx			;  restore rows,colums
 20134                                  
 20135 000024E0 31C0                    	xor	ax,ax			; zero out ax
 20136 000024E2 89C1                    	mov	cx,ax			;  and cx
 20137                                  
 20138                                  ; Scroll active page
 20139                                  
 20140                                  	;mov	ah,scroll_video_page	; set up to scroll page up
 20141 000024E4 B406                    	mov	ah,6
 20142                                  	;mov	bh,video_attribute	; attribute for blank line
 20143 000024E6 B707                    	mov	bh,7
 20144 000024E8 30DB                    	xor	bl,bl			; set BL to 0
 20145                                  	;int	video_io_int		; do int 10h - BIOS video IO
 20146 000024EA CD10                    	int	10h
 20147                                  
 20148                                  ; Seek to cursor to 0,0
 20149                                  
 20150                                  ;M022 following two lines added
 20151                                  	;mov	ah,get_video_state	; get current video page in BH
 20152 000024EC B40F                    	mov	ah,0Fh
 20153                                  	;int	video_io_int
 20154 000024EE CD10                    	int	10h
 20155                                  	;mov	ah,set_cursor_position	; set up to set cursor position
 20156 000024F0 B402                    	mov	ah,2
 20157 000024F2 31D2                    	xor	dx,dx			; row and column 0
 20158                                  ;M022	mov	bh,0
 20159                                  	;int	video_io_int		; do into 10h - BIOS video IO
 20160 000024F4 CD10                    	int	10h
 20161                                  
 20162 000024F6 C3                      	retn
 20163                                  
 20164                                  ; ---------------------------------------------------------------------------
 20165                                  
 20166                                  ; MSDOS 6.0
 20167                                  
 20168                                  ; ****************************************************************
 20169                                  ; *
 20170                                  ; * ROUTINE:	 ANSI_CLS
 20171                                  ; *
 20172                                  ; * FUNCTION:	 Clear the screen using by writing a control code
 20173                                  ; *		 to STDOUT.
 20174                                  ; *
 20175                                  ; * INPUT:	 none
 20176                                  ; *
 20177                                  ; * OUTPUT:	 none
 20178                                  ; *
 20179                                  ; ****************************************************************
 20180                                  
 20181                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20182                                  ansi_cls:			;AC000;
 20183 000024F7 BE[B895]                	mov	si,CLSSTRING
 20184                                  			; db 4,1Bh,'[2J'
 20185 000024FA AC                      	lodsb
 20186 000024FB 88C1                    	mov	cl,al	; al = 4
 20187 000024FD 30ED                    	xor	ch,ch
 20188                                  	;mov	ah,Raw_CON_IO
 20189 000024FF B406                    	mov	ah,6
 20190                                  clrloop:
 20191 00002501 AC                      	lodsb
 20192 00002502 88C2                    	mov	dl,al
 20193 00002504 CD21                    	int	21h
 20194                                  		; DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
 20195 00002506 E2F9                    	loop	clrloop
 20196 00002508 C3                      	retn
 20197                                  
 20198                                  ;============================================================================
 20199                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
 20200                                  ;============================================================================
 20201                                  ; 08/10/2018 - Retro DOS v3.0
 20202                                  
 20203                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
 20204                                  
 20205                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 20206                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 206Bh
 20207                                  
 20208                                  ; ---------------------------------------------------------------------------
 20209                                  
 20210                                  ; ****************************************************************
 20211                                  ; *
 20212                                  ; * ROUTINE:	 CTTY - Change console
 20213                                  ; *
 20214                                  ; * SYNTAX:	 CTTY device
 20215                                  ; *
 20216                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
 20217                                  ; *		 duplicate the device handle to STDIN, STDOUT and
 20218                                  ; *		 STDERR. This routine returns to LODCOM1.
 20219                                  ; *
 20220                                  ; * INPUT:	 command line at offset 81H
 20221                                  ; *
 20222                                  ; * OUTPUT:	 none
 20223                                  ; *
 20224                                  ; ****************************************************************
 20225                                  
 20226                                  	; 21/02/2023 - Retro DOS v4.0
 20227                                  	; 08/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 20228                                  	; 10/06/2023
 20229                                  CTTY:
 20230                                  	; MSDOS 6.0
 20231 00002509 1E                      	push	ds			;AN000; Get local ES
 20232 0000250A 07                      	pop	es			;AN000;
 20233 0000250B BE8100                  	mov	si,81h			;AC000; Get command argument for CTTY
 20234 0000250E BF[DA98]                	mov	di,PARSE_CTTY
 20235                                  					;AC000; Get address of PARSE_CTTY
 20236 00002511 31C9                    	xor	cx,cx			;AC000; clear cx,dx
 20237 00002513 31D2                    	xor	dx,dx			;AC000;
 20238 00002515 E84425                  	call	cmd_parse		;AC000; call parser
 20239                                  
 20240                                  	;cmp	ax,-1 ; 0FFFFh
 20241                                  	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 20242                                  	;je	short ctty_error	;AN000; yes - error
 20243                                  	;;cmp	ax,RESULT_NO_ERROR ; 0	;AN000; did an error occur
 20244                                  	;and	ax,ax ; ax > 0 ?
 20245                                  	;jnz	short ctty_error	;AN000; YES -ERROR
 20246                                  	; 10/06/2023
 20247 00002518 40                      	inc	ax  ; cmp ax,-1
 20248 00002519 7434                    	jz	short ctty_error  ; 0FFFFh -> 0
 20249 0000251B 48                      	dec	ax  ; cmp ax,0
 20250 0000251C 7531                    	jnz	short ctty_error  ; 1 -> 0
 20251                                  	; ax = 0
 20252                                  
 20253 0000251E 56                      	push	si			;AN000; save position in line
 20254 0000251F C536[0BAA]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 20255 00002523 BF[38A1]                	mov	di,SrcBuf		;AN000; get address of srcbuf
 20256                                  ctty_move_filename:			;AN000; put filespec in srcbuf
 20257 00002526 AC                      	lodsb				;AN000; get a char from buffer
 20258 00002527 AA                      	stosb				;AN000; store in srcbuf
 20259                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN000; it char a terminator?
 20260 00002528 08C0                    	or	al,al ; al = 0 ?
 20261 0000252A 75FA                    	jnz	short ctty_move_filename ; 26/04/2023
 20262                                  					;AN000; no - keep moving
 20263 0000252C 5E                      	pop	si			;AN000; get line position back
 20264 0000252D BF[DA98]                	mov	di,PARSE_CTTY		;AC000; Get address of PARSE_CTTY
 20265 00002530 E8C001                  	call	parse_check_eol 	;AN000; are we at end of line?
 20266                                  	;jz	short nocolon 		;AN000; yes - continue
 20267                                  	; 21/02/2023
 20268 00002533 751A                    	jnz	short ctty_error
 20269                                  ;ctty_error:
 20270                                  	;jmp	short isbaddev		;AC000; yes - exit
 20271                                  
 20272                                  	; 21/02/2023
 20273                                  	; MSDOS 3.3
 20274                                  	;call	SETPATH
 20275                                  	;dec	si
 20276                                  	;dec	si
 20277                                  	;cmp	byte [si],':'
 20278                                  	;jnz	short NOCOLON
 20279                                  	;mov	byte [si],0
 20280                                  nocolon:
 20281                                  	; 21/02/2023
 20282                                  	; MSDOS 6.0
 20283 00002535 BA[38A1]                	mov	dx,SrcBuf
 20284                                  ;NOCOLON:
 20285                                  	; MSDOS 3.3 & MSDOS 6.0
 20286                                  	;;mov	ax,(OPEN SHL 8) OR 2 ; Read and write
 20287                                  	;mov	ax,(OPEN<<8)|2 ; 3D02h
 20288 00002538 B8023D                  	mov	ax,3D02h ; 21/02/2023
 20289 0000253B CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 20290                                  			; DS:DX	-> ASCIZ filename
 20291                                  			; AL = access mode
 20292                                  			; 2 - read & write
 20293 0000253D 7210                    	jc	short isbaddev
 20294 0000253F 89C3                    	mov	bx,ax
 20295                                  	;mov	ax,IOCTL*256 ; 4400h
 20296 00002541 B80044                  	mov	ax,4400h
 20297 00002544 CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 20298                                  			; BX = file or device handle
 20299 00002546 F6C280                  	test	dl,80h
 20300 00002549 750C                    	jnz	short devisok
 20301                                  closedev:
 20302                                  	;mov	ah,CLOSE ; 3Eh ; Close initial handle
 20303 0000254B B43E                    	mov	ah,3Eh
 20304 0000254D CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 20305                                  			; BX = file handle
 20306                                  ctty_error:
 20307                                  isbaddev:
 20308 0000254F BA[4E93]                	mov	dx,BADDEV_PTR
 20309 00002552 E8D82F                  	call	std_printf
 20310 00002555 EB40                    	jmp	short resret
 20311                                  
 20312                                  	;nop
 20313                                  devisok:
 20314                                  	; 21/02/2023
 20315                                  	; MSDOS 6.0
 20316 00002557 52                      	push	dx		;AN007; save device info
 20317                                  	; 08/06/2023
 20318 00002558 A1[D593]                	mov	ax,[acrlf_ptr]	;AN021; get message number for 0d, 0a
 20319                                  	;mov	dh,util_msg_class
 20320 0000255B B6FF                    	mov	dh,-1 ; 0FFh	;AN021; this is a utility message
 20321 0000255D 53                      	push	bx		;AN021; save handle
 20322 0000255E E8B130                  	call	TSYSGETMSG	;AN021; get the address of the message
 20323 00002561 89F2                    	mov	dx,si		;AN021; get address into dx
 20324                                  	;mov	ax,(Write shl 8)
 20325 00002563 B80040                  	mov	ax,4000h	;AN007; write to device
 20326 00002566 B90200                  	mov	cx,2		;AN007; write two bytes
 20327 00002569 CD21                    	int	21h		;AN007;
 20328 0000256B 5B                      	pop	bx		;AN021; get back handle
 20329 0000256C 5A                      	pop	dx		;AN007; get back device info
 20330 0000256D 72DC                    	jc	short closedev	;AN007; if error, quit
 20331                                  
 20332                                  	; MSDOS 3.3 & MSDOS 6.0
 20333 0000256F 30F6                    	xor	dh,dh
 20334 00002571 80CA03                  	or	dl,3
 20335                                  	;;mov	ax,(IOCTL SHL 8) OR 1
 20336                                  	;mov	ax,(IOCTL<<8)|1 ; 4401h
 20337 00002574 B80144                  	mov	ax,4401h
 20338 00002577 CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 20339                                  			; BX = device handle,DH = 0
 20340                                  			; DL = device information to set 
 20341                                  			;	(bits 0-7 from	function 0)
 20342 00002579 53                      	push	bx
 20343 0000257A B90300                  	mov	cx,3
 20344 0000257D 31DB                    	xor	bx,bx
 20345                                  iclloop:			; Close basic handles
 20346                                  	;mov	ah,CLOSE ; 3Eh
 20347 0000257F B43E                    	mov	ah,3Eh
 20348 00002581 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 20349                                  			; BX = file handle
 20350 00002583 43                      	inc	bx
 20351 00002584 E2F9                    	loop	iclloop
 20352 00002586 5B                      	pop	bx		; Get handle
 20353                                  	;mov	ah,XDUP ; 45h
 20354 00002587 B445                    	mov	ah,45h
 20355 00002589 CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 20356                                  			; BX = file handle to duplicate
 20357                                  	;mov	ah,XDUP ; 45h
 20358 0000258B B445                    	mov	ah,45h
 20359 0000258D CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 20360                                  			; BX = file handle to duplicate
 20361                                  	;mov	ah,XDUP ; 45h
 20362 0000258F B445                    	mov	ah,45h
 20363 00002591 CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 20364                                  			; BX = file handle to duplicate
 20365                                  	;mov	ah,CLOSE ; 3Eh
 20366 00002593 B43E                    	mov	ah,3Eh
 20367 00002595 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 20368                                  			; BX = file handle
 20369                                  resret:
 20370 00002597 8E1E[159E]              	mov	ds,[RESSEG]
 20371 0000259B 1E                      	push	ds
 20372                                  	;mov	ax,[18h]
 20373 0000259C A11800                  	mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
 20374 0000259F A3[3D02]                	mov	[Io_Save],ax
 20375                                  	;;;mov	ax,31Eh ; MSDOS 3.3
 20376                                  	;;mov	ax,LODCOM1
 20377                                  	;;mov	ax,offset DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
 20378                                  	;mov	ax,175h ; MSDOS 6.0
 20379 000025A2 B8[7400]                	mov	ax,TrnLodCom1_Trap
 20380 000025A5 50                      	push	ax
 20381                                  
 20382 000025A6 CB                      	retf		; Far return
 20383                                  
 20384                                  ; ---------------------------------------------------------------------------
 20385                                  
 20386                                  ;****************************************************************
 20387                                  ;*
 20388                                  ;* ROUTINE:	CHCP - Change code page internal command
 20389                                  ;*		(added DOS 3.30 07/21/86)
 20390                                  ;*
 20391                                  ;* SYNTAX:	CHCP [xxx]
 20392                                  ;*		where xxx is a valid code page
 20393                                  ;*
 20394                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
 20395                                  ;*		6402H to set the code page to xxxx. If no parameters
 20396                                  ;*		are specified, CHCP will use INT 21H function 6401H
 20397                                  ;*		to get global code page and display it to the user.
 20398                                  ;*
 20399                                  ;* INPUT:	command line at offset 81H
 20400                                  ;*
 20401                                  ;* OUTPUT:	none
 20402                                  ;*
 20403                                  ;****************************************************************
 20404                                  
 20405                                  NLSFUNC_installed equ  0FFh
 20406                                  set_global_cp	  equ  2
 20407                                  get_global_cp	  equ  1
 20408                                  
 20409                                  	; 21/02/2023 - Retro DOS v4.0
 20410                                  	; 09/06/2023 - Retro DOS v4.2 COMMAND.COM
 20411                                  	; 10/06/2023
 20412                                  CHCP:
 20413                                  	; MSDOS 6.0
 20414 000025A7 1E                      	push	ds		;AN000; Get local ES
 20415 000025A8 07                      	pop	es		;AN000;
 20416 000025A9 BE8100                  	mov	si,81h		;AC000; Get command argument for CHCP
 20417 000025AC BF[E697]                	mov	di,PARSE_CHCP
 20418                                  				;AN000; Get address of PARSE_CHCP
 20419 000025AF 31C9                    	xor	cx,cx		;AC000; clear cx,dx
 20420 000025B1 31D2                    	xor	dx,dx		;AC000;
 20421 000025B3 E85301                  	call    Parse_With_Msg	;AC018; call parser
 20422                                  
 20423                                  	;cmp	ax,-1
 20424                                  	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 20425                                  	;;jne	short setcp	;AC000; no go get number & set code page
 20426                                  	;je	short getcp	;AC000; yes - no parm - get code page
 20427                                  ;setcp:
 20428                                  	;;cmp	ax,0
 20429                                  	;;cmp	ax,RESULT_NO_ERROR
 20430                                  	;			;AN000; did we have an error?
 20431                                  	;;jne	short cp_error	;AC018; yes - go issue message
 20432                                  	;and	ax,ax ; ax > 0 ?
 20433                                  	;jnz	short cp_error	
 20434                                  	; 10/06/2023
 20435 000025B6 40                      	inc	ax  ; cmp ax,-1	
 20436 000025B7 745C                    	jz	short getcp ; 0FFFFh -> 0
 20437 000025B9 48                      	dec	ax  ; cmp ax,0
 20438 000025BA 7556                    	jnz	short cp_error ; 1 -> 0
 20439                                  	; ax = 0
 20440                                  
 20441                                  	;;push	cx		;AN000; save positional count
 20442                                  	;mov	bx,PARSE1_ADDR	;AN000; get number returned
 20443                                  	;;mov	cx,[bx]		;AN000;  into cx
 20444                                  	;;mov	[system_cpage],cx
 20445                                  	;			;AN000; save user input number
 20446                                  	;;pop	cx		;AC000; restore positional count
 20447                                  	;; 21/02/2023
 20448                                  	;mov	di,[bx]
 20449                                  	;mov	[system_cpage],di
 20450                                  	; 09/06/2023	
 20451 000025BC 8B1E[0BAA]              	mov	bx,[PARSE1_ADDR]
 20452 000025C0 891E[B1A0]              	mov	[system_cpage],bx
 20453                                  	;
 20454 000025C4 BF[E697]                	mov	di,PARSE_CHCP	;AN000; Get address of PARSE_CHCP
 20455 000025C7 E82901                  	call	parse_check_eol ;AN000; are we at end of line?
 20456 000025CA 7546                    	jnz	short cp_error	;AC000; no - exit
 20457                                  okset:
 20458                                  	;;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
 20459                                  	;mov	ah,14h
 20460                                  	;mov	al,0		;AN000;
 20461 000025CC B80014                  	mov	ax,1400h
 20462 000025CF CD2F                    	int	2Fh		;AN000;
 20463                                  	;cmp	al,0FFh
 20464 000025D1 3CFF                    	cmp	al,NLSFUNC_installed
 20465                                  				;AN000;
 20466 000025D3 7405                    	je	short got_NLS 	;AN000; Yes - continue
 20467 000025D5 BA[7C92]                	mov	dx,NLSFUNC_PTR
 20468                                  				;AN000; no - set up error message
 20469 000025D8 EB38                    	jmp	short cp_error	;AN000; error exit
 20470                                  
 20471                                  	; 21/02/2023
 20472                                  got_NLS:
 20473                                  	; MSDOS 6.0
 20474 000025DA 8B1E[B1A0]              	mov	bx,[system_cpage]
 20475                                  				;AN000; get user input code page
 20476                                  ;SET_CP_TBL_NUM:
 20477                                  	;mov	[SYSTEM_CPAGE],bx ; MSDOS 3.3
 20478                                  	;
 20479                                  	; MSDOS 3.3 & MSDOS 6.0
 20480                                  	;;mov	ah,GETSETCDPG 	;get/set global code page function
 20481                                  	;mov	ah,66h
 20482                                  	;;mov	al,set_global_cp 
 20483                                  	;mov	al,2		;minor - set
 20484                                  	; 26/04/2023
 20485 000025DE B80266                  	mov	ax,6602h
 20486 000025E1 CD21                    	int	21h
 20487                                  		; DOS - 3.3+ - SET GLOBAL CODE PAGE TABLE
 20488                                  		; BX = active code page
 20489                                  		; DX = system code page (active page at boot time)
 20490                                  
 20491 000025E3 733F                    	jnc	short chcp_return
 20492                                  				;no error - exit
 20493                                  
 20494 000025E5 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2
 20495 000025E8 7515                    	jnz	short chcp_other_error
 20496                                  
 20497                                  	;mov	ah,GETEXTENDEDERROR ; 59h
 20498 000025EA B459                    	mov	ah,59h
 20499 000025EC 31DB                    	xor	bx,bx
 20500 000025EE CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 20501                                  			; BX = version code (0000h for DOS 3.x)
 20502                                  
 20503 000025F0 83F80D                  	cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
 20504 000025F3 7505                    	jne	short no_countrysys ; 26/04/2023
 20505                                  	;mov	dx,FNOTFOUNDPTR ; MSDOS 3.3
 20506 000025F5 BA[7F92]                	mov	dx,INV_CODE_PAGE
 20507                                  	;jmp	cerror
 20508 000025F8 EB18                    	jmp	short cp_error
 20509                                  
 20510                                  	; 21/02/2023
 20511                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 20512                                  no_countrysys:
 20513                                  ;M045;	mov	byte [msg_disp_class],ext_msg_class	   
 20514                                  ;					;AN000; set up extended error msg class
 20515                                  ;M045;	mov	dx,extend_buf_ptr	;AC000; get extended message pointer
 20516                                  ;M045;	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND
 20517                                  					;AN000; get message number in control block
 20518 000025FA BA[6994]                	mov	dx,NoCntry_Ptr
 20519 000025FD EB13                    	jmp	short cp_error
 20520                                  
 20521                                  chcp_other_error:		; end of p716
 20522                                  	;mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
 20523 000025FF B459                    	mov	ah,59h
 20524 00002601 31DB                    	xor	bx,bx
 20525 00002603 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 20526                                  			; BX = version code (0000h for DOS 3.x)
 20527 00002605 83F841                  	cmp	ax,65		;was it access denied?
 20528 00002608 7505                    	jne	short none_set	;no - assume all failed
 20529 0000260A BA[6092]                	mov	dx,cp_not_all_ptr
 20530                                  				;set up message
 20531                                  	;jmp	cerror		;AC000; error exit
 20532 0000260D EB03                    	jmp     short cp_error
 20533                                  none_set:
 20534 0000260F BA[5292]                	mov	dx,cp_not_set_ptr
 20535                                  				;set up message
 20536                                  cp_error:
 20537 00002612 E98D08                  	jmp	cerror		;exit
 20538                                  getcp:
 20539                                  	;;mov	ah,GETSETCDPG ; 66h
 20540                                  	;mov	ah,66h		;get/set global code page function	
 20541                                  	;;mov	al,get_global_cp ; 1
 20542                                  	;mov	al,1		;minor - get
 20543                                  	; 26/04/2023
 20544 00002615 B80166                  	mov	ax,6601h
 20545 00002618 CD21                    	int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
 20546 0000261A 891E[B1A0]              	mov	[system_cpage],bx
 20547                                  				;get active cp for output
 20548 0000261E BA[6E92]                	mov	dx,cp_active_ptr
 20549 00002621 E8092F                  	call	std_printf	;print it out
 20550                                  chcp_return:
 20551 00002624 C3                      	retn
 20552                                  
 20553                                  ; ---------------------------------------------------------------------------
 20554                                  
 20555                                  ; ****************************************************************
 20556                                  ; *
 20557                                  ; * ROUTINE:	 TRUENAME
 20558                                  ; *
 20559                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
 20560                                  ; *		 Parses the command line. If a path is found, set
 20561                                  ; *		 SRCXNAME to path. If only a drive letter is found,
 20562                                  ; *		 set SRCXNAME to the drive letter. If no path
 20563                                  ; *		 is found, set the path of SRCXNAME to dot (.) for
 20564                                  ; *		 current directory. Use the NAME TRANSLATE system
 20565                                  ; *		 call to get the real name and  then display the 
 20566                                  ; *		 real name. If an error occurs issue an error
 20567                                  ; *		 message and transfer control to  CERROR.
 20568                                  ; *
 20569                                  ; * INPUT:	 command line at offset 81H
 20570                                  ; *
 20571                                  ; * OUTPUT:	 none
 20572                                  ; *
 20573                                  ; ****************************************************************
 20574                                  
 20575                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20576                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2197h
 20577                                  
 20578                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 20579                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2741h
 20580                                  
 20581                                  TRUENAME:				;AN000; TRUENAME entry point
 20582 00002625 1E                      	push	ds			;AN000; Get local ES
 20583 00002626 07                      	pop	es			;AN000;
 20584 00002627 BE8100                  	mov	si,81h			;AN000; Get command line
 20585 0000262A BF[4498]                	mov	di,PARSE_CHDIR		;AN000; Get address of PARSE_CHDIR
 20586 0000262D 31C9                    	xor	cx,cx			;AN000; clear cx,dx
 20587 0000262F 31D2                    	xor	dx,dx			;AN000;
 20588 00002631 E8D500                  	call	Parse_With_Msg		;AC018; call parser
 20589                                  
 20590 00002634 BF[439B]                	mov	di,SRCXNAME		;AN000; get address of srcxname
 20591                                  	;cmp	ax,0FFFFh
 20592                                  	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 20593                                  	;je	short tn_eol		;AN000; yes - go process
 20594                                  	;; 22/02/2023
 20595                                  	;;cmp	ax,0
 20596                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 20597                                  	;;jne	short tn_parse_error	;AN000; yes - go issue message
 20598                                  	;and	ax,ax ; ax = 0 ?
 20599                                  	;jnz	short tn_parse_error ; no, parse error	
 20600                                  	; 10/06/2023
 20601 00002637 40                      	inc	ax  ; 0FFFFh -> 0 ; cmp ax,0FFFFh
 20602 00002638 7433                    	jz	short tn_eol ; ah = 0 ; *
 20603 0000263A 48                      	dec	ax  ; 1 -> 0 ; cmp ax, 0
 20604 0000263B 752D                    	jnz	short tn_parse_error
 20605                                  	
 20606                                  	;cmp	byte [PARSE1_TYPE],6
 20607 0000263D 803E[07AA]06            	cmp	byte [PARSE1_TYPE],result_drive
 20608                                  					;AN000; was a drive entered?
 20609                                  	;je	short tn_drive		;AN000; yes - go process
 20610                                  	;jmp	short tn_filespec	;AN000; nothing else - must be filespec
 20611                                  	; 23/02/2023
 20612 00002642 7512                    	jne	short tn_filespec
 20613                                  
 20614                                  ;tn_eol: 
 20615                                  ;	;mov	ah,0			;AN000; no parameters on line
 20616                                  ;	mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 20617                                  ;	;mov	al,dot_chr		;AN000;   for current dir
 20618                                  ;	mov	al,'.'
 20619                                  ;	stosw				;AN000; store in srcxname
 20620                                  ;	jmp	short tn_doit		;AN000; go do command
 20621                                  
 20622                                  tn_drive:				;AN000; a drive was entered
 20623 00002644 56                      	push	si			;AN000; save position in line
 20624 00002645 BE[0BAA]                	mov	si,PARSE1_ADDR		;AN000; get address of drive
 20625 00002648 AC                      	lodsb				;AN000; get the drive number
 20626 00002649 0440                    	add	al,"A"-1 ; 40h		;AN000; convert it to char
 20627 0000264B AA                      	stosb				;AN000; store it in srcxname
 20628                                  	;mov	ax,dot_colon		;AN000; get colon and . and
 20629 0000264C B83A2E                  	mov	ax,':.' ; 2E3Ah ; ah=".", al=":"
 20630 0000264F AB                      	stosw				;AN000;  store in srcxname
 20631                                  	;mov	al,0
 20632 00002650 B000                    	mov	al,END_OF_LINE_OUT	;AN000; put a terminator char
 20633 00002652 AA                      	stosb				;AN000;
 20634 00002653 5E                      	pop	si			;AN000; get line position back
 20635 00002654 EB0C                    	jmp	short tn_check_eol	;AN000; check to make sure eol
 20636                                  
 20637                                  tn_filespec:				;AN000; a filespec was entered
 20638 00002656 56                      	push	si			;AN000; save position in line
 20639 00002657 C536[0BAA]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 20640                                  
 20641                                  tn_move_filename:			;AN000; put filespec in srcxname
 20642 0000265B AC                      	lodsb				;AN000; get a char from buffer
 20643 0000265C AA                      	stosb				;AN000; store in srcxname
 20644                                  	;;cmp	al,0
 20645                                  	;cmp	al,END_OF_LINE_OUT	;AN000; it char a terminator?
 20646 0000265D 08C0                    	or	al,al ; al = 0 ?
 20647 0000265F 75FA                    	jnz	short tn_move_filename	;AN000; no - keep moving
 20648 00002661 5E                      	pop	si			;AN000; get line position back
 20649                                  
 20650                                  tn_check_eol:				;AN000; make sure no extra parms
 20651 00002662 BF[4498]                	mov	di,PARSE_CHDIR		;AN000; get address of parse_chdir
 20652 00002665 E88B00                  	call	parse_check_eol 	;AN000; are we at end of line?
 20653 00002668 7406                    	jz	short tn_doit 		;AN000; Yes - do the command
 20654                                  tn_parse_error: 			;AN000; A parse error occurred
 20655 0000266A E93508                  	jmp	cerror			;AN000; Go to error routine
 20656                                  
 20657                                  tn_eol: 
 20658                                  	;23/02/2023
 20659                                  	;;mov	ah,0			;AN000; no parameters on line
 20660                                  	;mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 20661                                  	;;mov	al,dot_chr		;AN000;   for current dir
 20662                                  	;mov	al,'.'
 20663                                  	; 10/06/2023
 20664                                  	;mov	ax,002Eh
 20665                                  	; ah = 0 ; *
 20666 0000266D B02E                    	mov	al,'.'  ;dot_chr ; 2Eh
 20667                                  	;	
 20668 0000266F AB                      	stosw				;AN000; store in srcxname
 20669                                  	; 23/02/2023
 20670                                  	;jmp	short tn_doit		;AN000; go do command
 20671                                  
 20672                                  tn_doit:				;AN000;
 20673 00002670 BE[439B]                	mov	si,SRCXNAME		;AN000; set up srcxname as source
 20674 00002673 BF[749C]                	mov	di,COMBUF		;AN000; set up combuf as target (need big target)
 20675 00002676 B460                    	mov	ah,xNameTrans		;AN000; do name translate call
 20676                                  	;mov	ah,60h
 20677 00002678 CD21                    	int	21h			;AN000;
 20678 0000267A 7311                    	jnc	short tn_print_xname	;AN000; If no error - print result
 20679                                  
 20680 0000267C E8B3FB                  	call	Set_Ext_Error_Msg	;AN000; get extended message
 20681 0000267F C706[B7A0][439B]        	mov	word [string_ptr_2],SRCXNAME
 20682                                  					;AN000; get address of failed string
 20683                                  	;mov	byte [extend_buf_sub],1
 20684 00002685 C606[F591]01            	mov	byte [extend_buf_sub],one_subst
 20685                                  					;AN000; put number of subst in control block
 20686 0000268A E91508                  	jmp	cerror			;AN000; Go to error routine
 20687                                  
 20688                                  tn_print_xname: 			;AN000;
 20689 0000268D C706[B7A0][749C]        	mov	word [string_ptr_2],COMBUF
 20690                                  					;AN000; Set up address of combuf
 20691 00002693 BA[BA93]                	mov	dx,string_buf_ptr	;AN000; Set up address of print control block
 20692 00002696 E88804                  	call	CRLF2			;AN000; print a crlf
 20693                                  	;call	Printf_Crlf		;AN000; print it out
 20694                                  	;retn				;AN000;
 20695                                  	; 23/02/2023
 20696 00002699 E9832E                  	jmp	Printf_Crlf
 20697                                  
 20698                                  ; ---------------------------------------------------------------------------
 20699                                  
 20700                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20701                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2219h
 20702                                  
 20703                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 20704                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:27C3h
 20705                                  _$EXIT:
 20706                                  	; MSDOS 6.0
 20707 0000269C 1E                      	push	ds			;AN000; save data segment
 20708 0000269D 8E1E[159E]              	mov	ds,[RESSEG]		;AN000; get resident data segment
 20709                                  	;assume	ds:resgroup		;AN000;
 20710                                  
 20711 000026A1 803E[4002]00            	cmp	byte [PermCom],0	;AN045; is this a permanent COMMAND?
 20712 000026A6 740A                    	jz	short free_com		;AN045; no - free everything
 20713                                  
 20714                                  ;	We're a permanent command.
 20715                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
 20716                                  
 20717 000026A8 833E[4302]FF            	cmp	word [SingleCom],-1	;M034
 20718 000026AD 7412                    	je	short no_reset		;M034 ; exit singlecom
 20719 000026AF E952DA                  	jmp	TCOMMAND		;permanent command, recycle
 20720                                  
 20721                                  free_com:
 20722                                  	;mov	ax,(multdos shl 8 or message_2f)
 20723 000026B2 B82E12                  	mov	ax,122Eh		;AN060; reset parse message pointers
 20724                                  	;mov	dl,SET_CRITICAL_MSG	;AN000; set up critical error message address
 20725 000026B5 B205                    	mov	dl,5
 20726 000026B7 8B3E[5802]              	mov	di,[Crit_Msg_Off] 	;AN000; old offset of critical messages
 20727 000026BB 8E06[5A02]              	mov	es,[Crit_Msg_Seg] 	;AN000; old segment of critical messages
 20728 000026BF CD2F                    	int	2Fh			;AN000; go set it
 20729                                  no_reset:				;AN045;
 20730 000026C1 1F                      	pop	ds			;AN000; restore local data segment
 20731                                  	;assume	ds:trangroup		;AN000;
 20732                                  ;M040
 20733                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
 20734                                  ;this, restores user dir if flag is set and resets the flag.
 20735                                  
 20736                                  	;invoke	RestUDir1		;restore user dir if needed ;M040
 20737 000026C2 E80C03                  	call	RestUDir1
 20738 000026C5 8E06[159E]              	mov	es,[RESSEG]
 20739                                  	;assume	es:resgroup
 20740                                  
 20741 000026C9 26A1[DC01]              	mov	ax,[es:Parent]
 20742                                  	;mov	[es:16h],ax
 20743                                  	;mov	[es:PDB_Parent_PID],ax
 20744 000026CD 26A31600                	mov	[es:PDB.PARENT_PID],ax
 20745 000026D1 26A1[DE01]              	mov	ax,[es:OldTerm]
 20746                                  	;mov	[es:0Ah],ax
 20747                                  	;mov	[es:PDB_Exit],ax
 20748 000026D5 26A30A00                	mov	[es:PDB.EXIT],ax
 20749 000026D9 26A1[E001]              	mov	ax,[es:OldTerm+2]
 20750                                  	;mov	[es:0Ch],ax
 20751                                  	;mov	[es:PDB_Exit+2],ax
 20752 000026DD 26A30C00                	mov	[es:PDB.EXIT+2],ax
 20753                                  
 20754 000026E1 06                      	push	es
 20755 000026E2 8E06[259E]              	mov	es,[TRAN_TPA]
 20756                                  	;mov	ah,DEALLOC
 20757 000026E6 B449                    	mov	ah,49h
 20758 000026E8 CD21                    	int	21h			; Now running in "free" space
 20759 000026EA 07                      	pop	es
 20760                                  
 20761                                  	;mov	ah,Exit
 20762 000026EB B44C                    	mov	ah,4Ch
 20763                                  	;mov	al,byte ptr RetCode
 20764 000026ED 26A0[3802]              	mov	al,[es:RetCode]
 20765 000026F1 CD21                    	int	21h
 20766                                  
 20767                                  ; ---------------------------------------------------------------------------
 20768                                  
 20769                                  ; MSDOS 6.0
 20770                                  ; ****************************************************************
 20771                                  ; *
 20772                                  ; * ROUTINE:	 PARSE_CHECK_EOL
 20773                                  ; *
 20774                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
 20775                                  ; *		 If not end of line, set up to print parse
 20776                                  ; *		 error message. ASSUMES NO MORE PARAMETERS ARE
 20777                                  ; *		 EXPECTED!
 20778                                  ; *
 20779                                  ; * INPUT:	 DS:SI	  last output from parser
 20780                                  ; *		 ES:DI	  points to parse block
 20781                                  ; *		 CX	  last output from parser
 20782                                  ; *
 20783                                  ; * OUTPUT:	 AX	  parser return code
 20784                                  ; *
 20785                                  ; *		 if end of line found
 20786                                  ; *		     zero flag set
 20787                                  ; *		 else
 20788                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 20789                                  ; *
 20790                                  ; ****************************************************************
 20791                                  
 20792                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20793                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2270h
 20794                                  
 20795                                  parse_check_eol:
 20796 000026F3 31D2                    	xor	dx,dx			;AN000;
 20797 000026F5 8936[AFA0]              	mov	[parse_last],si 	;AN018; save start of parameter
 20798 000026F9 E86023                  	call	cmd_parse		;AN000; call parser
 20799 000026FC 3CFF                    	cmp	al,-1 ; 0FFh
 20800                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN000; Are we at end of line?
 20801 000026FE 7408                    	je	short parse_good_eol	;AN000; yes - no problem
 20802                                  	;cmp	ax,0
 20803                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; was any error found?
 20804 00002700 21C0                    	and	ax,ax ; ax = 0 ?
 20805 00002702 7501                    	jnz	short ok_to_setup_pmsg	;AN018; yes - continue
 20806 00002704 40                      	inc	ax			;AN018; set AX to 1 and turn off zero flag
 20807                                  ok_to_setup_pmsg:
 20808 00002705 E81000                  	call	setup_parse_error_msg	;AN018; go set up error message
 20809                                  parse_good_eol:
 20810                                  parse_msg_good:	; 23/02/2023
 20811 00002708 C3                      	retn				;AN000;
 20812                                  
 20813                                  ; ---------------------------------------------------------------------------
 20814                                  
 20815                                  ; MSDOS 6.0
 20816                                  ; ****************************************************************
 20817                                  ; *
 20818                                  ; * ROUTINE:	 PARSE_WITH_MSG
 20819                                  ; *
 20820                                  ; * FUNCTION:	 Calls parser. If an error occurred, the error
 20821                                  ; *		 message is set up.
 20822                                  ; *
 20823                                  ; * INPUT:	 DS:SI	  last output from parser
 20824                                  ; *		 ES:DI	  points to parse block
 20825                                  ; *		 CX	  last output from parser
 20826                                  ; *
 20827                                  ; * OUTPUT:	 AX	  parser return code
 20828                                  ; *
 20829                                  ; *		 if no error
 20830                                  ; *		     outputs from parser
 20831                                  ; *		 else
 20832                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 20833                                  ; *		     error message set up for STD_PRINTF
 20834                                  ; *
 20835                                  ; ****************************************************************
 20836                                  
 20837                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20838                                  Parse_With_Msg:
 20839 00002709 8936[AFA0]              	mov	[parse_last],si 	;AN018; save start of parameter
 20840 0000270D E84C23                  	call	cmd_parse		;AN018; call parser
 20841 00002710 3CFF                    	cmp	al,-1 ; 0FFh
 20842                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN018; Are we at end of line?
 20843 00002712 74F4                    	je	short parse_msg_good	;AN018; yes - no problem
 20844                                  	;cmp	ax,0
 20845                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; did an error occur
 20846 00002714 09C0                    	or	ax,ax ; ax = 0 ?
 20847 00002716 74F0                    	jz	short parse_msg_good	;AN018; yes - no problem
 20848                                  	; 23/02/2023
 20849                                  	;call	setup_parse_error_msg	;AN018; go set up error message
 20850                                  ;parse_msg_good:
 20851                                  	;retn				;AN018;
 20852                                  	; 23/02/2023
 20853                                  	;jmp	short setup_parse_error_msg	
 20854                                  
 20855                                  ; ---------------------------------------------------------------------------
 20856                                  
 20857                                  ; MSDOS 6.0
 20858                                  ; ****************************************************************
 20859                                  ; *
 20860                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
 20861                                  ; *
 20862                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
 20863                                  ; *		 message is set up.
 20864                                  ; *
 20865                                  ; * INPUT:	 AX	     Parse error number
 20866                                  ; *		 SI	     Set to past last parameter
 20867                                  ; *		 Parse_last  Set to start of last parameter
 20868                                  ; *
 20869                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
 20870                                  ; *		 error message set up for STD_PRINTF
 20871                                  ; *
 20872                                  ; ****************************************************************
 20873                                  
 20874                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20875                                  setup_parse_error_msg:
 20876 00002718 C606[F191]02            	mov	byte [msg_disp_class],parse_msg_class
 20877                                  	;mov	byte [msg_disp_class],2	;AC018; Set up parse message class
 20878 0000271D BA[F391]                	mov	dx,extend_buf_ptr	;AC018; get extended message pointer
 20879 00002720 C60400                  	mov	byte [si],END_OF_LINE_OUT ; 0
 20880                                  					;AC018; terminate the parameter string
 20881 00002723 A3[F391]                	mov	[extend_buf_ptr],ax	;AC018; get message number in control block
 20882 00002726 83F802                  	cmp	ax,2
 20883                                  	;cmp	ax,LessArgs_Ptr 	;AC018; if required parameter missing
 20884 00002729 740D                    	je	short setup_parse_msg_ret
 20885                                  					;AN018;    no subst
 20886 0000272B 8B36[AFA0]              	mov	si,[parse_last] 	;AC018; get start of parameter
 20887 0000272F 8936[B7A0]              	mov	[string_ptr_2],si 	;AC018; get address of failed string
 20888 00002733 C606[F591]01            	mov	byte [extend_buf_sub],one_subst
 20889                                  					;AC018; put number of subst in control block
 20890                                  	;mov	byte [extend_buf_sub],1
 20891                                  setup_parse_msg_ret:
 20892 00002738 46                      	inc	si			;AN018; make sure zero flag not set
 20893 00002739 C3                      	retn				;AC018;
 20894                                  
 20895                                  ;============================================================================
 20896                                  ; TENV.ASM, MSDOS 6.0, 1991
 20897                                  ;============================================================================
 20898                                  ; 08/10/2018 - Retro DOS v3.0
 20899                                  
 20900                                  ; TITLE	Part6 COMMAND Transient routines.
 20901                                  
 20902                                  ;	Environment utilities and misc. routines
 20903                                  
 20904                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
 20905                                  
 20906                                  ; 23/02/2023 - Retro DOS v4.0 (& v4.1)
 20907                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 22BDh
 20908                                  
 20909                                  ; ---------------------------------------------------------------------------
 20910                                  
 20911                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20912                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 20913                                  ADD_PROMPT:
 20914 0000273A E8FC00                  	call	delete_prompt	; Delete any existing prompt
 20915 0000273D E8AD01                  	call	scan_double_null
 20916                                  
 20917                                  ADD_PROMPT2:
 20918 00002740 56                      	push	si
 20919 00002741 E89B01                  	call	GETARG
 20920 00002744 5E                      	pop	si
 20921 00002745 7501                    	jnz	short ADD_PROMPT3
 20922                                  ADD_PROMPT_RETN:
 20923 00002747 C3                      	retn
 20924                                  ADD_PROMPT3:			; Pre scan for arguments
 20925 00002748 E87501                  	call	move_name	; Move in name
 20926 0000274B E89101                  	call	GETARG
 20927 0000274E 56                      	push	si
 20928 0000274F EB53                    	jmp	short ADD_NAME
 20929                                  
 20930                                  ;break	The SET command
 20931                                  
 20932                                  ; Input: DS:SI points to a CR terminated string
 20933                                  ; Output: carry flag is set if no room
 20934                                  ;	  otherwise name is added to environment
 20935                                  
 20936                                  DISP_ENVJ:
 20937 00002751 E9BC00                  	jmp	DISP_ENV
 20938                                  
 20939                                  ADD_NAME_TO_ENVIRONMENT:
 20940 00002754 E88801                  	call	GETARG
 20941 00002757 74F8                    	jz	short DISP_ENVJ
 20942                                  
 20943                                  ; check if line contains exactly one equals sign
 20944                                  
 20945 00002759 31DB                    	xor	bx,bx		; = count is 0
 20946 0000275B 56                      	push	si		; Save pointer to beginning of line
 20947                                  EQLP:
 20948 0000275C AC                      	lodsb			; Get a char
 20949 0000275D 3C0D                    	cmp	al,13 ; 0Dh	; IF CR we're all done
 20950 0000275F 740F                    	je	short QUEQ	
 20951 00002761 3C3D                    	cmp	al,'='		; Look for = sign	
 20952 00002763 75F7                    	jne	short EQLP	; not there, get next char
 20953 00002765 FEC3                    	inc	bl		; Otherwise increment EQ count
 20954 00002767 803C0D                  	cmp	byte [si],13	; Look for CR following = sign
 20955 0000276A 75F0                    	jne	short EQLP
 20956 0000276C FEC7                    	inc	bh		; Set BH=1 means no parameters
 20957 0000276E EBEC                    	jmp	short EQLP	; And look for more
 20958                                  QUEQ:
 20959 00002770 5E                      	pop	si		; Restore beginning of line
 20960 00002771 FECB                    	dec	bl		; Zero flag means only one EQ
 20961 00002773 7406                    	jz	short ONEQ	; Good line
 20962 00002775 BA[8B92]                	mov	dx,SYNTMES_PTR
 20963 00002778 E92707                  	jmp	cerror
 20964                                  ONEQ:
 20965 0000277B 53                      	push	bx
 20966 0000277C E8BD00                  	call	delete_name_in_environment
 20967 0000277F 5B                      	pop	bx
 20968 00002780 FECF                    	dec	bh
 20969 00002782 74C3                    	jz	short ADD_PROMPT_RETN
 20970 00002784 E86601                  	call	scan_double_null
 20971 00002787 89FB                    	mov	bx,di		; Save ptr to beginning of env var name
 20972 00002789 E83401                  	call	move_name
 20973 0000278C 56                      	push	si
 20974 0000278D 87DF                    	xchg	bx,di		; Switch ptrs to beginning and end of
 20975                                  				;  env var name
 20976                                  		
 20977                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
 20978                                  ; necessary in the resident for re-reading the transient. Let's look for
 20979                                  ; COMSPEC=
 20980                                  
 20981 0000278F C606[9697]00            	mov	byte [comspec_flag],0 ; MSDOS 6.0 ; clear flag ; M024
 20982 00002794 BE[B694]                	mov	si,COMSPECSTR ; "COMSPEC="
 20983 00002797 B90400                  	mov	cx,4
 20984 0000279A F3A7                    	repe	cmpsw
 20985 0000279C 7504                    	jnz	short NOT_COMSPEC
 20986                                  				; Zero set => exact match
 20987 0000279E FE06[9697]              	inc	byte [comspec_flag] ; MSDOS 6.0 ; comspec is changing ; M024
 20988                                  	;mov	byte [COMSPEC_FLAG],1
 20989                                  NOT_COMSPEC:
 20990 000027A2 89DF                    	mov	di,bx		; Load ptr to end of env var name
 20991                                  ADD_NAME:
 20992 000027A4 5E                      	pop	si		; Add the value of the new env var
 20993 000027A5 56                      	push	si		;  to the environment.
 20994                                  ADD_NAME1:
 20995 000027A6 AC                      	lodsb
 20996 000027A7 3C0D                    	cmp	al,13 ; 0Dh
 20997 000027A9 7405                    	je	short ADD_NAME_RET
 20998 000027AB E8AD01                  	call	store_char
 20999 000027AE EBF6                    	jmp	short ADD_NAME1
 21000                                  ADD_NAME_RET:
 21001 000027B0 5E                      	pop	si
 21002 000027B1 803E[9697]00            	cmp	byte [comspec_flag],0
 21003                                  				; If the new env var is comspec,	
 21004                                  ADD_NAME_JZ_RET:
 21005 000027B6 748F                    	jz	short ADD_PROMPT_RETN 
 21006                                  				;  copy the value into the
 21007                                  				;  comspec var in the resident
 21008                                  
 21009                                  ; We have changed the COMSPEC variable. We need to update the resident
 21010                                  ; pieces necessary to reread in the info. First, skip all delimiters
 21011                                  
 21012 000027B8 E87303                  	call	scanoff
 21013 000027BB 8E06[159E]              	mov	es,[RESSEG]	;  comspec var in the resident
 21014                                  
 21015                                  ; Make sure that the printer knows where the beginning of the string is
 21016                                  
 21017 000027BF BF[E901]                	mov	di,ComSpec
 21018 000027C2 89FB                    	mov	bx,di
 21019                                  
 21020                                  ; Generate drive letter for display
 21021                                  
 21022 000027C4 31C0                    	xor	ax,ax		;g assume no drive first
 21023 000027C6 26A2[3202]              	mov	[es:ComDrv],al
 21024                                  	; 23/02/2023
 21025                                  	; MSDOS 6.0 (& 5.0)
 21026 000027CA 50                      	push	ax		;AN000; 3/3/KK
 21027 000027CB 8A04                    	mov	al,[si]		;AN000; 3/3/KK
 21028 000027CD E83F01                  	call	testkanj	;AN000; 3/3/KK	
 21029 000027D0 58                      	pop	ax		;AN000; 3/3/KK
 21030 000027D1 7518                    	jnz	short _GOTDRIVE
 21031                                  	;
 21032 000027D3 807C013A                	cmp	byte [si+1],':'	; drive specified?
 21033 000027D7 7512                    	jne	short _GOTDRIVE
 21034 000027D9 8A04                    	mov	al,[si]		; get his specified drive
 21035                                  	; 23/02/2023
 21036 000027DB E85B01                  	call	UPCONV
 21037                                  	;call	UPCONV_MAPCALL	; convert to uppercase
 21038 000027DE 2C41                    	sub	al,'A'		; convert to 0-based
 21039 000027E0 83C702                  	add	di,2
 21040 000027E3 FEC0                    	inc	al		; convert to 1-based number
 21041 000027E5 26A2[3202]              	mov	[es:ComDrv],al
 21042                                  
 21043                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
 21044                                  ; done here..
 21045                                  	;add	al,40h
 21046 000027E9 0440                    	add	al,'A'-1
 21047                                  _GOTDRIVE:
 21048                                  	; 23/02/2023
 21049                                  	;;mov	[es:0BD9h],di	; MSDOS 3.3 COMMAND.COM offset 1734h
 21050                                  	;mov	[es:PUTBACKSUBSTPTR],di
 21051                                  	;mov	[es:0233h],di	; MSDOS 5.0 COMMAND.COM offset 236Eh
 21052 000027EB 26893E[C801]            	mov	[es:PutBackComSpec],di
 21053                                  				;g point to beginning of name after drive
 21054                                  	;;mov	[es:0A21h],al	; MSDOS 3.3 COMMAND.COM offset 1739h
 21055                                  	;mov	[es:PUTBACKDRV],al
 21056                                  	;mov	[es:0238h],al	; MSDOS 5.0 COMMAND.COM offset 2373h
 21057 000027F0 26A2[CD01]              	mov	[es:PutBackDrv],al
 21058                                  
 21059                                  ; Copy chars until delim      	
 21060                                  
 21061 000027F4 89DF                    	mov	di,bx
 21062                                  COPY_COMSPEC:
 21063 000027F6 AC                      	lodsb
 21064 000027F7 E83C03                  	call	DELIM
 21065 000027FA 7407                    	jz	short COPYDONE
 21066 000027FC 3C0D                    	cmp	al,13 ; 0Dh
 21067 000027FE 7403                    	je	short COPYDONE
 21068 00002800 AA                      	stosb
 21069 00002801 EBF3                    	jmp	short COPY_COMSPEC
 21070                                  COPYDONE:
 21071 00002803 30C0                    	xor	al,al		; Null terminate the string and quit
 21072 00002805 AA                      	stosb
 21073                                  	;mov	byte [comspec_flag],0
 21074 00002806 A2[9697]                	mov	[comspec_flag],al ; 0 ; 23/02/2023
 21075 00002809 4F                      	dec	di
 21076 0000280A 26893E[2902]            	mov	[es:ComSpec_End],di
 21077 0000280F C3                      	retn
 21078                                  
 21079                                  DISP_ENV:
 21080 00002810 8E1E[159E]              	mov	ds,[RESSEG]
 21081 00002814 8E1E[DC03]              	mov	ds,[EnvirSeg]
 21082                                  	; assume ds:nothing
 21083 00002818 31F6                    	xor	si,si
 21084                                  PENVLP:
 21085 0000281A 803C00                  	cmp	byte [si],0
 21086 0000281D 7497                    	jz	short ADD_NAME_JZ_RET
 21087 0000281F BF[ADA7]                	mov	di,Arg_Buf
 21088                                  PENVLP2:
 21089 00002822 AC                      	lodsb
 21090 00002823 AA                      	stosb
 21091 00002824 08C0                    	or	al,al
 21092 00002826 75FA                    	jnz	short PENVLP2
 21093 00002828 BA[9093]                	mov	dx,arg_buf_ptr
 21094 0000282B 1E                      	push	ds
 21095 0000282C 06                      	push	es
 21096 0000282D 1F                      	pop	ds
 21097                                  	; assume ds:nothing
 21098 0000282E E8EE2C                  	call	Printf_Crlf
 21099 00002831 1F                      	pop	ds
 21100 00002832 EBE6                    	jmp	short PENVLP
 21101                                  
 21102                                  ; =============== S U B	R O U T	I N E =======================================
 21103                                  
 21104                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21105                                  delete_path:
 21106 00002834 BE[AA94]                	mov	si,PATH_TEXT ; "PATH="
 21107 00002837 EB03                    	jmp	short delete_name_in_environment
 21108                                  
 21109                                  ; =============== S U B	R O U T	I N E =======================================
 21110                                  
 21111                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21112                                  delete_prompt:
 21113 00002839 BE[AF94]                	mov	si,PROMPT_TEXT ; "PROMPT="
 21114                                  
 21115                                  ; ---------------------------------------------------------------------------
 21116                                  
 21117                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21118                                  delete_name_in_environment:
 21119                                  
 21120                                  ; Input: DS:SI points to a "=" terminated string
 21121                                  ; Output: carry flag is set if name not found
 21122                                  ;	  otherwise name is deleted
 21123                                  
 21124 0000283C 56                      	push	si
 21125 0000283D 1E                      	push	ds
 21126 0000283E E82C00                  	call	FIND		; ES:DI points to name
 21127 00002841 7217                    	jc	short del1
 21128 00002843 89FE                    	mov	si,di		; Save it
 21129 00002845 E8BF00                  	call	SCASB2		; Scan for the nul
 21130 00002848 87F7                    	xchg	si,di
 21131                                  ;SR;
 21132                                  ; If we have only one env string, then the double null is lost when the last
 21133                                  ;string is deleted and we have an invalid empty environment with only a
 21134                                  ;single null. To avoid this, we will look for the double null case and then
 21135                                  ;move an extra null char.
 21136                                  ; Bugbug: The only possible problem is that the last pathstring
 21137                                  ;will be followed by a triple null. Is this really a problem?
 21138                                  
 21139                                  	; MSDOS 6.0
 21140 0000284A 26803C00                	cmp	byte [es:si],0	;null char?
 21141 0000284E 7501                    	jnz	short not_dnull	;no, we are at a double null
 21142 00002850 4E                      	dec	si		;point at the double null
 21143                                  not_dnull:
 21144                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21145 00002851 E86901                  	call	GETENVSIZ
 21146 00002854 29F1                    	sub	cx,si
 21147 00002856 06                      	push	es
 21148 00002857 1F                      	pop	ds		; ES:DI points to name
 21149                                  				; DS:SI points to next name
 21150 00002858 F3A4                    	rep	movsb
 21151                                  del1:
 21152 0000285A 1F                      	pop	ds
 21153 0000285B 5E                      	pop	si
 21154                                  find_retn:
 21155 0000285C C3                      	retn
 21156                                  
 21157                                  ; =============== S U B	R O U T	I N E =======================================
 21158                                  
 21159                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21160                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:23E2h
 21161                                  find_path:
 21162 0000285D BE[AA94]                	mov	si,PATH_TEXT ; "PATH="
 21163 00002860 EB03                    	jmp	short find_name_in_environment
 21164                                  
 21165                                  ; =============== S U B	R O U T	I N E =======================================
 21166                                  
 21167                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21168                                  find_prompt:
 21169 00002862 BE[AF94]                	mov	si,PROMPT_TEXT ; "PROMPT="
 21170                                  
 21171                                  ; ---------------------------------------------------------------------------
 21172                                  
 21173                                  find_name_in_environment:
 21174                                  
 21175                                  ; Input: DS:SI points to a "=" terminated string
 21176                                  ; Output: ES:DI points to the arguments in the environment
 21177                                  ;	  zero is set if name not found
 21178                                  ;	  carry flag is set if name not valid format
 21179                                  
 21180 00002865 E80500                  	call	FIND		; Find the name
 21181 00002868 72F2                    	jc	short find_retn	; Carry means not found	
 21182 0000286A E99600                  	jmp	SCASB1		; Scan for = sign
 21183                                  
 21184                                  ; ---------------------------------------------------------------------------
 21185                                  	;nop
 21186                                  
 21187                                  ; =============== S U B	R O U T	I N E =======================================
 21188                                  
 21189                                  ; On return of FIND1, ES:DI points to beginning of name
 21190                                  
 21191                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 21192                                  FIND:
 21193 0000286D FC                      	cld
 21194 0000286E E84100                  	call	COUNT0		; CX = Length of name
 21195 00002871 8E06[159E]              	mov	es,[RESSEG]
 21196                                  	;assume es:RESGROUP
 21197 00002875 268E06[DC03]            	mov	es,[es:EnvirSeg]
 21198                                  	;assume es:NOTHING
 21199 0000287A 31FF                    	xor	di,di
 21200                                  find1:	
 21201 0000287C 51                      	push	cx
 21202 0000287D 56                      	push	si
 21203 0000287E 57                      	push	di
 21204                                  find11:
 21205 0000287F AC                      	lodsb
 21206                                  	; 23/02/2023 
 21207                                  	; MSDOS 6.0 (& 5.0)
 21208 00002880 E88C00                  	call	testkanj	
 21209 00002883 740F                    	jz	short notkanj3
 21210 00002885 4E                      	dec	si
 21211 00002886 AD                      	lodsw
 21212 00002887 47                      	inc	di
 21213 00002888 47                      	inc	di
 21214 00002889 263B45FE                	cmp	ax,[es:di-2]
 21215 0000288D 7511                    	jne	short find12
 21216 0000288F 49                      	dec	cx
 21217 00002890 E2ED                    	loop	find11
 21218 00002892 EB0C                    	jmp	short find12
 21219                                  notkanj3:
 21220 00002894 E8A200                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 21221                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 21222 00002897 47                      	inc	di
 21223 00002898 263A45FF                	cmp	al,[es:di-1]
 21224 0000289C 7502                    	jne	short find12
 21225 0000289E E2DF                    	loop	find11
 21226                                  find12:
 21227 000028A0 5F                      	pop	di
 21228 000028A1 5E                      	pop	si
 21229 000028A2 59                      	pop	cx
 21230 000028A3 74B7                    	jz	short find_retn
 21231 000028A5 51                      	push	cx
 21232 000028A6 E85E00                  	call	SCASB2		; Scan for a nul
 21233 000028A9 59                      	pop	cx
 21234 000028AA 26803D00                	cmp	byte [es:di],0
 21235 000028AE 75CC                    	jnz	short find1
 21236 000028B0 F9                      	stc			; Indicate not found
 21237 000028B1 C3                      	retn
 21238                                  
 21239                                  ; =============== S U B	R O U T	I N E =======================================
 21240                                  
 21241                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21242                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2437h
 21243                                  COUNT0:
 21244 000028B2 1E                      	push	ds
 21245 000028B3 07                      	pop	es
 21246                                  	;assume es:nothing
 21247 000028B4 89F7                    	mov	di,si
 21248                                  ;COUNT1:
 21249 000028B6 57                      	push	di		; Count number of chars until "="
 21250 000028B7 E84900                  	call	SCASB1
 21251                                  	; 23/02/2023
 21252                                  ;	jmp	short COUNTX
 21253                                  ;COUNT2:
 21254                                  ;	push	di		; Count number of chars until nul
 21255                                  ;	call	SCASB2
 21256                                  ;COUNTX:
 21257 000028BA 59                      	pop	cx
 21258 000028BB 29CF                    	sub	di,cx
 21259 000028BD 87F9                    	xchg	di,cx
 21260                                  move_name_retn:
 21261 000028BF C3                      	retn
 21262                                  
 21263                                  ; =============== S U B	R O U T	I N E =======================================
 21264                                  
 21265                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21266                                  move_name:
 21267 000028C0 803C0D                  	cmp	byte [si],13 ; 0Dh
 21268 000028C3 74FA                    	je	short move_name_retn
 21269 000028C5 AC                      	lodsb
 21270                                  	; 23/02/2023 
 21271                                  	; MSDOS 6.0 (& 5.0)
 21272 000028C6 E84600                  	call	testkanj		
 21273 000028C9 7409                    	jz	short notkanj1
 21274 000028CB E88D00                  	call	store_char
 21275 000028CE AC                      	lodsb
 21276 000028CF E88900                  	call	store_char
 21277 000028D2 EBEC                    	jmp	short move_name
 21278                                  notkanj1: 
 21279 000028D4 E86200                  	call	UPCONV
 21280                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3
 21281 000028D7 E88100                  	call	store_char
 21282 000028DA 3C3D                    	cmp	al,'='
 21283 000028DC 75E2                    	jne	short move_name
 21284                                  getarg_retn:
 21285 000028DE C3                      	retn
 21286                                  
 21287                                  ; =============== S U B	R O U T	I N E =======================================
 21288                                  
 21289                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21290                                  GETARG:
 21291 000028DF BE8000                  	mov	si,80h
 21292 000028E2 AC                      	lodsb
 21293 000028E3 08C0                    	or	al,al
 21294 000028E5 74F7                    	jz	short getarg_retn
 21295 000028E7 E84402                  	call	scanoff
 21296 000028EA 3C0D                    	cmp	al,13 ; 0Dh
 21297                                  sdn_retn:
 21298 000028EC C3                      	retn
 21299                                  
 21300                                  ; =============== S U B	R O U T	I N E =======================================
 21301                                  
 21302                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
 21303                                  ; there is NO double NULL, merely a string that is empty.
 21304                                  
 21305                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21306                                  scan_double_null:
 21307 000028ED 8E06[159E]              	mov	es,[RESSEG]
 21308 000028F1 268E06[DC03]            	mov	es,[es:EnvirSeg]
 21309 000028F6 31FF                    	xor	di,di
 21310                                  
 21311                                  ; Top cycle-point. If the string here is empty, then we are done
 21312                                  
 21313                                  sdn1:
 21314 000028F8 26803D00                	cmp	byte [es:di],0	; nul string?
 21315 000028FC 74EE                    	jz	short sdn_retn	; yep, all done
 21316 000028FE E80600                  	call	SCASB2
 21317 00002901 EBF5                    	jmp	short sdn1
 21318                                  
 21319                                  ; =============== S U B	R O U T	I N E =======================================
 21320                                  
 21321                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21322                                  SCASB1:
 21323 00002903 B03D                    	mov	al,'='		; Scan for an =
 21324 00002905 EB02                    	jmp	short SCASBX
 21325                                  
 21326                                  ; =============== S U B	R O U T	I N E =======================================
 21327                                  
 21328                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21329                                  SCASB2:
 21330 00002907 30C0                    	xor	al,al		; Scan for a nul
 21331                                  
 21332                                  ; ---------------------------------------------------------------------------
 21333                                  
 21334                                  	; 23/02/2023
 21335                                  SCASBX:
 21336 00002909 B90001                  	mov	cx,256
 21337 0000290C F2AE                    	repne	scasb
 21338 0000290E C3                      	retn
 21339                                  
 21340                                  ; =============== S U B	R O U T	I N E =======================================
 21341                                  
 21342                                  ; MSDOS 6.0
 21343                                  
 21344                                  ;Bugbug: This is Kanji stuff - put it in conditionals
 21345                                  
 21346                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21347                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:249Ah
 21348                                  testkanj:
 21349 0000290F 1E                      	push	ds			;AN000;  3/3/KK
 21350 00002910 56                      	push	si			;AN000;  3/3/KK
 21351 00002911 50                      	push	ax			;AN000;  3/3/KK
 21352 00002912 2E8E1E[159E]            	mov	ds,[cs:RESSEG]		;AN000;  Get resident segment
 21353 00002917 C536[5C02]              	lds	si,[Dbcs_Vector_Addr]	;AN000;  get DBCS vector
 21354                                  ktlop:					;AN000;  3/3/KK
 21355 0000291B 833C00                  	cmp	word [si],0		;AN000;  end of Table 3/3/KK
 21356 0000291E 740E                    	je	short notlead 		;AN000;  3/3/KK
 21357 00002920 58                      	pop	ax			;AN000;  3/3/KK
 21358 00002921 50                      	push	ax			;AN000;  3/3/KK
 21359 00002922 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 21360 00002924 7208                    	jb	short notlead 		;AN000;  3/3/KK
 21361 00002926 46                      	inc	si			;AN000;  3/3/KK
 21362 00002927 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 21363 00002929 7607                    	jbe	short islead		;AN000;  3/3/KK
 21364 0000292B 46                      	inc	si			;AN000;  3/3/KK
 21365 0000292C EBED                    	jmp	short ktlop		;AN000;  try another range ; 3/3/KK
 21366                                  notlead:				;AN000;  3/3/KK
 21367 0000292E 31C0                    	xor	ax,ax			;AN000;  set zero 3/3/KK
 21368 00002930 EB03                    	jmp	short ktret		;AN000;  3/3/KK
 21369                                  islead: 				;AN000;  3/3/KK
 21370 00002932 31C0                    	xor	ax,ax			;AN000;  reset zero 3/3/KK
 21371 00002934 40                      	inc	ax			;AN000;  3/3/KK
 21372                                  ktret:					;AN000;  3/3/KK
 21373 00002935 58                      	pop	ax			;AN000;  3/3/KK
 21374 00002936 5E                      	pop	si			;AN000;  3/3/KK
 21375 00002937 1F                      	pop	ds			;AN000;  3/3/KK
 21376 00002938 C3                      	retn				;AN000;  3/3/KK
 21377                                  
 21378                                  ; =============== S U B	R O U T	I N E =======================================
 21379                                  
 21380                                  ; MSDOS 6.0
 21381                                  
 21382                                  ; ****************************************************************
 21383                                  ; *
 21384                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 21385                                  ; *
 21386                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 21387                                  ; *		 the character in AL from the file upper case table
 21388                                  ; *		 in DOS if character if above  ascii 128, else
 21389                                  ; *		 subtracts 20H if between "a" and "z".
 21390                                  ; *
 21391                                  ; * INPUT:	 AL	      char to be upper cased
 21392                                  ; *		 FUCASE_ADDR  set to the file upper case table
 21393                                  ; *
 21394                                  ; * OUTPUT:	 AL	      upper cased character
 21395                                  ; *
 21396                                  ; ****************************************************************
 21397                                  
 21398                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21399                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:24C4h
 21400                                  
 21401                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 21402                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2A6Eh
 21403                                  UPCONV:
 21404 00002939 3C80                    	cmp	al,80h			;AN000;  see if char is > ascii 128
 21405 0000293B 7213                    	jb	short oth_fucase	;AN000;  no - upper case math
 21406 0000293D 2C80                    	sub	al,80h			;AN000;  only upper 128 chars in table
 21407 0000293F 1E                      	push	ds			;AN000;
 21408 00002940 53                      	push	bx			;AN000;
 21409 00002941 8E1E[159E]              	mov	ds,[RESSEG]		;AN000;  get resident data segment
 21410                                  	;lds	bx,dword ptr FUCase_Addr+1
 21411 00002945 C51E[5402]              	lds	bx,[FUCase_Addr+1]	;AN000;  get table address
 21412 00002949 83C302                  	add	bx,2			;AN000;  skip over first word
 21413                                  	;xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
 21414 0000294C D7                      	xlat
 21415 0000294D 5B                      	pop	bx			;AN000;
 21416 0000294E 1F                      	pop	ds			;AN000;
 21417                                  	;jmp	short upconv_end	;AN000;  we finished - exit
 21418                                  	; 10/06/2023
 21419                                  upconv_end:
 21420                                  	; 24/02/2023
 21421 0000294F C3                      	retn
 21422                                  oth_fucase:				;AN000;
 21423 00002950 3C61                    	cmp	al,'a' ; small_a	;AC000; if between "a" and "z",
 21424 00002952 72FB                    	jb	short upconv_end	;AC000;    subtract 20h to get
 21425 00002954 3C7A                    	cmp	al,'z' ; small_z	;AC000;    upper case equivalent.
 21426 00002956 77F7                    	ja	short upconv_end	;AC000;
 21427 00002958 2C20                    	sub	al,20h			;AC000; Change lower-case to upper
 21428                                  ;upconv_end:	; 10/06/2023		;AN000;
 21429 0000295A C3                      	retn
 21430                                  
 21431                                  ; ---------------------------------------------------------------------------
 21432                                  
 21433                                  ; MSDOS 3.3
 21434                                  
 21435                                  	; 24/02/2023
 21436                                  ;UPCONV_MAPCALL:
 21437                                  	;			; If between "a" and "z"
 21438                                  	;cmp	al,[small_a]
 21439                                  	;jb	short UPCONV_END
 21440                                  	;cmp	al,[small_z]
 21441                                  	;ja	short UPCONV_END
 21442                                  	;sub	al,20h		; Change lower-case to upper
 21443                                  ;UPCONV_END:
 21444                                  	;call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
 21445                                  	;			  ; 	  for (current) country
 21446                                  	;retn
 21447                                  
 21448                                  ; =============== S U B	R O U T	I N E =======================================
 21449                                  
 21450                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
 21451                                  
 21452                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21453                                  store_char:
 21454 0000295B 51                      	push	cx
 21455 0000295C 53                      	push	bx
 21456                                  
 21457                                  	; 24/02/2023
 21458                                  	;;16/10/2018
 21459                                  	; MSDOS 6.0
 21460 0000295D 06                      	push	es		;AN056;*
 21461 0000295E 1E                      	push	ds		;AN056; Save local DS
 21462 0000295F 8E1E[159E]              	mov	ds,[RESSEG]	;AN056; Get resident segment
 21463 00002963 8E06[DC03]              	mov	es,[EnvirSeg]	;AN056; Get environment segment
 21464 00002967 1F                      	pop	ds		;AN056; Get local segment back
 21465                                  
 21466                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21467 00002968 E85200                  	call	GETENVSIZ
 21468 0000296B 89CB                    	mov	bx,cx		; Save room for double nul
 21469 0000296D 83EB02                  	sub	bx,2
 21470 00002970 39DF                    	cmp	di,bx
 21471 00002972 723F                    	jb	short store1
 21472 00002974 50                      	push	ax
 21473 00002975 51                      	push	cx
 21474 00002976 53                      	push	bx		; Save Size of environment
 21475 00002977 E85DDE                  	call	FREE_TPA
 21476 0000297A 5B                      	pop	bx
 21477 0000297B 83C302                  	add	bx,2		; Recover true environment size
 21478                                  
 21479 0000297E 81FB0080                	cmp	bx,8000h	; Don't let environment grow > 32K
 21480 00002982 7203                    	jb	short envsiz_ok
 21481                                  bad_env_size:			;AN056;
 21482 00002984 F9                      	stc
 21483 00002985 EB16                    	jmp	short envnoset
 21484                                  	;nop
 21485                                  envsiz_ok:
 21486 00002987 B104                    	mov	cl,4
 21487 00002989 D3EB                    	shr	bx,cl		; Convert back to paragraphs
 21488 0000298B 43                      	inc	bx
 21489                                  	; 24/02/2023
 21490                                  	; MSDOS 6.0
 21491 0000298C 8CC1                    	mov	cx,es		;AN056; Get environment segment
 21492 0000298E 01D9                    	add	cx,bx		;AN056; Add in size of environment
 21493 00002990 83C120                  	add	cx,20h		;AN056; Add in some TPA
 21494 00002993 8CC8                    	mov	ax,cs		;AN056; Get the transient segment
 21495 00002995 39C1                    	cmp	cx,ax		;AN056; Are we hitting the transient?
 21496 00002997 73EB                    	jnb	short bad_env_size
 21497                                  				;AN056; Yes - don't do it!!!
 21498                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21499 00002999 B44A                    	mov	ah,4Ah
 21500                                  	;mov	ah,SETBLOCK ; 4Ah
 21501 0000299B CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 21502                                  			; ES = segment address of block	to change
 21503                                  			; BX = new size	in paragraphs
 21504                                  envnoset:
 21505 0000299D 9C                      	pushf
 21506 0000299E 06                      	push	es
 21507 0000299F 8E06[159E]              	mov	es,[RESSEG]
 21508 000029A3 E841DE                  	call	ALLOC_TPA
 21509 000029A6 07                      	pop	es
 21510 000029A7 9D                      	popf
 21511 000029A8 59                      	pop	cx
 21512 000029A9 58                      	pop	ax
 21513                                  	; 10/06/2023
 21514 000029AA 7307                    	jnc	short store1
 21515                                  	; 24/02/2023
 21516 000029AC 07                      	pop	es ; MSDOS 6.0	;AN056;*	
 21517                                  	;jnc	short store1
 21518 000029AD BA[0A92]                	mov	dx,ENVERR_PTR
 21519 000029B0 E9EF04                  	jmp	cerror
 21520                                  store1:	
 21521 000029B3 AA                      	stosb
 21522 000029B4 26C7050000              	mov	word [es:di],0	; NULL IS AT END
 21523                                  	; 24/02/2023
 21524 000029B9 07                      	pop	es ; MSDOS 6.0	;AN056;*
 21525 000029BA 5B                      	pop	bx
 21526 000029BB 59                      	pop	cx
 21527 000029BC C3                      	retn
 21528                                  
 21529                                  ; =============== S U B	R O U T	I N E =======================================
 21530                                  
 21531                                  	; 24/02/2023
 21532                                  GETENVSIZ:
 21533                                  
 21534                                  ;Get size of environment in bytes, rounded up to paragraph boundry
 21535                                  ;ES has environment segment
 21536                                  ;Size returned in CX, all other registers preserved
 21537                                  
 21538 000029BD 06                      	push	es
 21539 000029BE 50                      	push	ax
 21540 000029BF 8CC0                    	mov	ax,es
 21541 000029C1 48                      	dec	ax		;Point at arena
 21542 000029C2 8EC0                    	mov	es,ax
 21543                                  	;mov	ax,[es:3]
 21544 000029C4 26A10300                	mov	ax,[es:ARENA.size]
 21545 000029C8 B104                    	mov	cl,4
 21546 000029CA D3E0                    	shl	ax,cl		;Convert to bytes
 21547 000029CC 89C1                    	mov	cx,ax
 21548 000029CE 58                      	pop	ax
 21549 000029CF 07                      	pop	es
 21550                                  getenvsiz_retn:
 21551 000029D0 C3                      	retn
 21552                                  
 21553                                  ; =============== S U B	R O U T	I N E =======================================
 21554                                  
 21555                                  	; 24/02/2023
 21556                                  RestUDir1:
 21557 000029D1 1E                      	push	ds
 21558 000029D2 8E1E[159E]              	mov	ds,[RESSEG]
 21559 000029D6 803E[3F02]00            	cmp	byte [RestDir],0
 21560 000029DB 1F                      	pop	ds
 21561 000029DC 74F2                    	jz	short getenvsiz_retn
 21562                                  
 21563                                  ; =============== S U B	R O U T	I N E =======================================
 21564                                  
 21565                                  	; 24/02/2023
 21566                                  RestUDir:
 21567 000029DE BA[F79C]                	mov	dx,USERDIR1
 21568 000029E1 B43B                    	mov	ah,3Bh
 21569                                  	;mov	ah,CHDir ; 3Bh
 21570 000029E3 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21571                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21572 000029E5 30C0                    	xor	al,al
 21573                                  	;call	SETREST
 21574                                  	;retn
 21575                                  	; 24/02/2023
 21576 000029E7 E94908                  	jmp	SETREST
 21577                                  
 21578                                  ;============================================================================
 21579                                  ; TENV2.ASM, MSDOS 6.0, 1991
 21580                                  ;============================================================================
 21581                                  ; 07/10/2018 - Retro DOS v3.0
 21582                                  
 21583                                  ; TITLE	Part6 COMMAND Transient routines.
 21584                                  
 21585                                  ;	Environment utilities and misc. routines
 21586                                  
 21587                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
 21588                                  
 21589                                  ; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21590                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2577h
 21591                                  
 21592                                  ; ---------------------------------------------------------------------------
 21593                                  
 21594                                  ; ****************************************************************
 21595                                  ; *
 21596                                  ; * ROUTINE:	 $CHDIR
 21597                                  ; *
 21598                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
 21599                                  ; *		 line. If path is found, CHDIR to path. If a drive
 21600                                  ; *		 letter is found, get and display the current dir
 21601                                  ; *		 of the specified drive. If nothing is found, get
 21602                                  ; *		 and display the current dir of the default drive.
 21603                                  ; *
 21604                                  ; * INPUT:	 command line at offset 81H
 21605                                  ; *
 21606                                  ; * OUTPUT:	 none
 21607                                  ; *
 21608                                  ; ****************************************************************
 21609                                  
 21610                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21611                                  
 21612                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 21613                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2B21h
 21614                                  _$CHDIR:
 21615                                  	; MSDOS 6.0
 21616 000029EA BE8100                  	mov	si,81h
 21617 000029ED BF[4498]                	mov	di,PARSE_CHDIR
 21618                                  				;AN000; Get address of PARSE_CHDIR
 21619 000029F0 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 21620 000029F2 31D2                    	xor	dx,dx		;AN000;
 21621 000029F4 E812FD                  	call	Parse_With_Msg	;AC018; call parser
 21622                                  	
 21623                                  	;cmp	ax,-1
 21624                                  	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 21625                                  	;je	short bwdj	; No args
 21626                                  	;;cmp	ax,0
 21627                                  	;;cmp	ax,RESULT_NO_ERROR
 21628                                  	;			;AC000; did we have an error?
 21629                                  	;or	ax,ax ; ax = 0 ?
 21630                                  	;jnz	short ChDirErr	;AC018; yes - exit
 21631                                  	
 21632                                  	; 10/06/2023
 21633 000029F7 40                      	inc	ax	; cmp ax,-1
 21634 000029F8 7414                    	jz	short bwdj ; 0FFFFh -> 0
 21635 000029FA 48                      	dec	ax	; cmp ax,0
 21636 000029FB 756D                    	jnz	short ChDirErr ; 1 -> 0
 21637                                  	; ax = 0
 21638                                  
 21639                                  	;cmp	byte [PARSE1_TYPE],6
 21640 000029FD 803E[07AA]06            	cmp	byte [PARSE1_TYPE],result_drive
 21641                                  				;AC000; was a drive entered?
 21642 00002A02 7511                    	jne	short REALCD	; no
 21643                                  
 21644                                  ; D: was found. See if there is anything more.
 21645                                  
 21646 00002A04 BF[4498]                	mov	di,PARSE_CHDIR
 21647                                  				;AC000; get address of parse_chdir
 21648 00002A07 31D2                    	xor	dx,dx		;AC000;
 21649 00002A09 E8E7FC                  	call	parse_check_eol ;AC000; call parser
 21650 00002A0C 755C                    	jnz	short ChDirErr	;AC000;
 21651                                  bwdj:
 21652 00002A0E E87BF9                  	call	build_dir_for_chdir
 21653                                  				; Drive only specified
 21654 00002A11 E80D01                  	call	CRLF2
 21655                                  chdir_retn:
 21656 00002A14 C3                      	retn
 21657                                  
 21658                                  	; 24/02/2023
 21659                                  	; MSDOS 3.3
 21660                                  	;mov	ax,[COMSW]
 21661                                  	;or	ax,[ALLSWITCH]
 21662                                  	;mov	dx,BADPARMPTR
 21663                                  	;jnz	short CHDIR_ERR
 21664                                  	;mov	si,81h
 21665                                  	;call	SCANOFF
 21666                                  	;cmp	al,0Dh		; are we at end of line?
 21667                                  	;je	short BWDJ	; No args
 21668                                  	;inc	si
 21669                                  	;lodsb
 21670                                  	;cmp	al,':'
 21671                                  	;jne	short REALCD
 21672                                  	;push	si
 21673                                  	;call	SCANOFF
 21674                                  	;pop	si
 21675                                  	;cmp	al,0Dh		; was a drive entered?
 21676                                  	;jne	short REALCD	; no
 21677                                  ;BWDJ:
 21678                                  	;call	BUILD_DIR_FOR_CHDIR ; Drive only specified
 21679                                  	;call	CRLF2
 21680                                  ;CHDIR_RETN:
 21681                                  	;retn
 21682                                  
 21683                                  	; 24/02/2023
 21684                                  	; MSDOS 6.0
 21685                                  REALCD:
 21686 00002A15 56                      	push	si		;AN000; save position in line
 21687 00002A16 C536[0BAA]              	lds	si,[PARSE1_ADDR]
 21688                                  				;AN000; get address of filespec
 21689 00002A1A E8D807                  	call	Move_To_SrcBuf	;AN000; move to srcbuf
 21690 00002A1D 5E                      	pop	si		;AN000; restore position in line
 21691 00002A1E BF[4498]                	mov	di,PARSE_CHDIR	;AC000; get address of parse_chdir
 21692 00002A21 31D2                    	xor	dx,dx		;AC000;
 21693 00002A23 E8CDFC                  	call	parse_check_eol ;AC000; call parser
 21694 00002A26 7542                    	jnz	short ChDirErr	;AC000;
 21695                                  	
 21696 00002A28 E81106                  	call	SETPATH
 21697 00002A2B F606[D4A0]02            	test	byte [DestInfo],2
 21698 00002A30 7518                    	jnz	short BadChDir
 21699                                  
 21700                                  	; 26/04/2023
 21701 00002A32 B43B                    	mov	ah,3Bh
 21702                                  	;mov	ah,CHDir
 21703 00002A34 CD21                    	int	21h
 21704 00002A36 73DC                    	jnc	short chdir_retn
 21705                                  	
 21706 00002A38 E807F8                  	call	get_ext_error_number
 21707                                  				;AN022; get the extended error
 21708 00002A3B 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 21709                                  				;AN022; see if path not found
 21710 00002A3E 740A                    	je	short BadChDir	;AN022; yes - issue old message
 21711                                  ;SR;
 21712                                  ; We want to issue "Invalid Directory" message even if the path is valid
 21713                                  ;but is not a directory. The extended error returns "Access denied" which
 21714                                  ;is kind of confusing. Issue the old message if access denied error is 
 21715                                  ;returned
 21716                                  
 21717 00002A40 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 21718 00002A43 7405                    	je	short BadChDir
 21719                                  	
 21720 00002A45 E89E00                  	call	set_ext_error_subst ;AN022;
 21721 00002A48 EB20                    	jmp	short ChDirErr	;AN022;
 21722                                  
 21723                                  BadChDir:
 21724 00002A4A BA[2E93]                	mov	dx,badcd_ptr
 21725                                  ;ChDirErr:
 21726                                  ;	call	std_eprintf
 21727                                  ;mkdir_retn:
 21728                                  	;retn
 21729                                  	; 24/02/2023
 21730 00002A4D EB1B                    	jmp	short ChDirErr	;AN022;
 21731                                  
 21732                                  	; 24/02/2023
 21733                                  	; MSDOS 3.3
 21734                                  ;REALCD:
 21735                                  	;call	SETPATH
 21736                                  	;test	byte [DESTINFO],2
 21737                                  	;jnz	short BADCHDIR
 21738                                  	;mov	ah,CHDir ; 3Bh
 21739                                  	;int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21740                                  	;		; DS:DX	-> ASCIZ directory name	(may include drive)
 21741                                  	;jnc	short CHDIR_RETN
 21742                                  ;BADCHDIR:
 21743                                  	;mov	dx,BADCDPTR
 21744                                  ;CHDIR_ERR:
 21745                                  	;call	STD_EPRINTF
 21746                                  ;MKDIR_RETN:
 21747                                  	;retn
 21748                                  
 21749                                  ; =============== S U B	R O U T	I N E =======================================
 21750                                  
 21751                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21752                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:25E2h
 21753                                  
 21754                                  	; 11/06/2023 - Retro DOS v4.2
 21755                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2B8Ch
 21756                                  _$MKDIR:
 21757                                  	; MSDOS 6.0
 21758 00002A4F E86300                  	call	SETRMMK
 21759 00002A52 7216                    	jc	short MkDirErr
 21760                                  
 21761 00002A54 B439                    	mov	ah,39h
 21762                                  	;mov	ah,MKDIR
 21763 00002A56 CD21                    	int	21h
 21764 00002A58 7313                    	jnc	short mkdir_retn
 21765                                  
 21766 00002A5A E8E5F7                  	call	get_ext_error_number	
 21767                                  				;AN022; get the extended error
 21768 00002A5D 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 21769                                  				;AN022; see if path not found
 21770 00002A60 742A                    	je	short MD_other_err
 21771                                  				;AN022; yes - issue old message
 21772 00002A62 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 21773                                  				;AN022; access denied?
 21774 00002A65 7407                    	je	short badmderr	;AN022; yes - see if file exists
 21775                                  	
 21776 00002A67 E87C00                  	call	set_ext_error_subst
 21777                                  				;AN022;
 21778                                  	;jmp	short MkDirerr	;AC022; yes - go print it
 21779                                  	; 24/02/2023
 21780                                  ChDirErr:
 21781                                  MkDirErr:
 21782                                  RmDirErr:
 21783 00002A6A E8B82A                  	call	std_eprintf
 21784                                  mkdir_retn:
 21785                                  rmdir_retn:
 21786 00002A6D C3                      	retn
 21787                                  	
 21788                                  badmderr:
 21789 00002A6E BA[439B]                	mov	dx,SRCXNAME	;AN006; Set Disk transfer address
 21790 00002A71 B41A                    	mov	ah,1Ah
 21791                                  	;mov	ah,Set_DMA	;AN006;
 21792 00002A73 CD21                    	int	21h		;AN006;
 21793                                  	
 21794 00002A75 B44E                    	mov	ah,4Eh
 21795                                  	;mov	ah,Find_First	;AN006; see if file/dir exists
 21796                                  	;mov	cx,10h
 21797 00002A77 B91000                  	mov	cx,ATTR_DIRECTORY
 21798                                  				;AN006;   search for directory
 21799 00002A7A CD21                    	int	21h		;AN006;
 21800 00002A7C 720E                    	jc	short MD_other_err
 21801                                  				;AN006; doesn't exist - must be something else
 21802                                  	;;mov	dl,SRCXNAME.find_buf_attr
 21803                                  				;AN006; we found a file/dir
 21804                                  	;mov	dl,[SRCXNAME+21] 
 21805 00002A7E 8A16[589B]              	mov	dl,[SRCXNAME+FIND_BUF.ATTR]
 21806 00002A82 F6C210                  	test	dl,ATTR_DIRECTORY
 21807                                  				;AN006; was it a directory?
 21808 00002A85 7405                    	jz	short MD_other_err
 21809                                  				;AN006; no - must have been a file
 21810 00002A87 BA[2194]                	mov	dx,MD_EXISTS_PTR
 21811                                  				;AN006; set up already exists error
 21812 00002A8A EBDE                    	jmp	short MkDirErr	;AN006; make sure we didn't have network error
 21813                                  MD_other_err:			;AN006;
 21814 00002A8C BA[3193]                	mov	dx,badmkd_ptr
 21815                                  ;MkDirErr:
 21816                                  	;call	std_eprintf
 21817                                  	;retn
 21818                                  	; 24/02/2023
 21819 00002A8F EBD9                    	jmp	short MkDirErr
 21820                                  
 21821                                  	; 24/02/2023
 21822                                  	; MSDOS 3.3
 21823                                  	;call	SETRMMK
 21824                                  	;jb	short MKDIRERR
 21825                                  	;mov	ah,MKDIR ; 39h
 21826                                  	;int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
 21827                                  	;		; DS:DX	-> ASCIZ pathname (may include drive)
 21828                                  	;jnc	short MKDIR_RETN
 21829                                  	;mov	dx,BADMKDPTR
 21830                                  	;call	GET_EXT_ERR_NUMBER
 21831                                  ;MKDIRERR:
 21832                                  	;call	STD_EPRINTF
 21833                                  	;retn
 21834                                  
 21835                                  ; =============== S U B	R O U T	I N E =======================================
 21836                                  
 21837                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21838                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2656h
 21839                                  	; 11/06/2023 - Retro DOS v4.2
 21840                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2C00h
 21841                                  _$RMDIR:
 21842 00002A91 E82100                  	call	SETRMMK
 21843 00002A94 72D4                    	jb	short RmDirErr
 21844 00002A96 7518                    	jnz	short badrderr
 21845                                  
 21846 00002A98 B43A                    	mov	ah,3Ah
 21847                                  	;mov	ah,RMDIR ; 3Ah
 21848 00002A9A CD21                    	int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
 21849                                  			; DS:DX	-> ASCIZ pathname (may include drive)
 21850 00002A9C 73CF                    	jnc	short rmdir_retn ; 24/02/2023
 21851                                  
 21852                                  	; 24/02/2023
 21853                                  	; MSDOS 6.0
 21854 00002A9E E8A1F7                  	call	get_ext_error_number
 21855                                  				;AN022; get the extended error
 21856 00002AA1 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 21857                                  				;AN022; see if path not found
 21858 00002AA4 740A                    	je	short badrderr	;AN022; yes - issue old message
 21859 00002AA6 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 21860                                  				;AN022; access denied?
 21861 00002AA9 7405                    	je	short badrderr	;AN022; yes - issue old message
 21862                                  
 21863 00002AAB E83800                  	call	set_ext_error_subst
 21864                                  				;AN022;
 21865 00002AAE EBBA                    	jmp	short RmDirErr	;AC022; yes - go print it
 21866                                  
 21867                                  	; MSDOS 6.0
 21868                                  badrderr:
 21869                                  	; 24/02/2023
 21870 00002AB0 BA[3493]                	mov	dx,badrmd_ptr
 21871 00002AB3 EBB5                    	jmp	short RmDirErr
 21872                                  ;RmDirErr:
 21873                                  	;call	std_eprintf
 21874                                  ;;rmdir_retn
 21875                                  	;retn
 21876                                  
 21877                                  	; 24/02/2023
 21878                                  	; MSDOS 3.3
 21879                                  	;mov	dx,BADRMDPTR
 21880                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 21881                                  ;RMDIRERR:
 21882                                  	;call	STD_EPRINTF
 21883                                  ;RMDIR_RETN:
 21884                                  	;retn
 21885                                  
 21886                                  ; =============== S U B	R O U T	I N E =======================================
 21887                                  
 21888                                  ; 	<Common MkDir/RmDir set up code>
 21889                                  ;****************************************************************
 21890                                  ;*
 21891                                  ;* ROUTINE:	SETRMMK
 21892                                  ;*
 21893                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
 21894                                  ;*		commands. Parses the command line for a required
 21895                                  ;*		filespec.
 21896                                  ;*
 21897                                  ;* INPUT:	command line at offset 81H
 21898                                  ;*
 21899                                  ;* OUTPUT:	carry clear
 21900                                  ;*		    DS:DX points to ASCIIZ argument
 21901                                  ;*		carry set
 21902                                  ;*		    DS:DX has error message pointer
 21903                                  ;*
 21904                                  ;****************************************************************
 21905                                  
 21906                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21907                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2624h
 21908                                  	; 11/06/2023 - Retro DOS v4.2
 21909                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2BCEh
 21910                                  SETRMMK:
 21911                                  	; MSDOS 6.0
 21912 00002AB5 BE8100                  	mov	si,81h
 21913 00002AB8 BF[3B98]                	mov	di,PARSE_MRDIR 	;AN000; Get address of PARSE_MRDIR
 21914 00002ABB 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 21915 00002ABD 31D2                    	xor	dx,dx		;AN000;
 21916                                  	;invoke	Parse_With_Msg	;AC000; call parser
 21917 00002ABF E847FC                  	call	Parse_With_Msg
 21918                                  	;cmp	ax,0
 21919                                  	;cmp	ax,RESULT_NO_ERROR
 21920 00002AC2 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 21921 00002AC4 7519                    	jnz	short noargerr	;AC000; yes - exit
 21922                                  
 21923 00002AC6 BF[439B]                	mov	di,SRCXNAME
 21924                                  				;AN000; get address of srcxname
 21925 00002AC9 57                      	push	di		;AN000; save address
 21926 00002ACA 56                      	push	si		;AN000; save position in line
 21927 00002ACB C536[0BAA]              	lds	si,[PARSE1_ADDR]
 21928                                  				;AN000; get address of path
 21929                                  mrdir_move_filename:		;AN000; put filespec in srcxname
 21930 00002ACF AC                      	lodsb			;get a char from buffer
 21931 00002AD0 AA                      	stosb			;AN000; store in srcxname
 21932                                  	;cmp	al,0
 21933                                  	;cmp	al,END_OF_LINE_OUT
 21934 00002AD1 20C0                    	and	al,al ; 0 ?	;AC000; it char a terminator?
 21935 00002AD3 75FA                    	jnz	short mrdir_move_filename
 21936                                  				;AC000; no - keep moving
 21937 00002AD5 5E                      	pop	si		;AN000; get line position back
 21938                                  
 21939                                  ; we have scanned an argument.	See if any args beyond.
 21940                                  
 21941 00002AD6 BF[3B98]                	mov	di,PARSE_MRDIR
 21942 00002AD9 E817FC                  	call	parse_check_eol ;AC000; are we at end of line?
 21943 00002ADC 5A                      	pop	dx		;AC000; get address of SRCXNAME
 21944                                  	;retz			;yes - return no error
 21945 00002ADD 7406                    	jz	short setrmmk_retn
 21946                                  noargerr:
 21947 00002ADF BA[F391]                	mov	dx,extend_buf_ptr
 21948                                  				;AC000; get extended message pointer
 21949 00002AE2 31C0                    	xor	ax,ax
 21950 00002AE4 F9                      	stc
 21951                                  setrmmk_retn:
 21952 00002AE5 C3                      	retn
 21953                                  
 21954                                  	; 24/02/2023
 21955                                  	; MSDOS 3.3
 21956                                  ;SETRMMK:
 21957                                  	;mov	si,81h
 21958                                  	;call	SCANOFF
 21959                                  	;cmp	al,0Dh
 21960                                  	;je	short NOARGERR
 21961                                  	;mov	dx,si
 21962                                  ;SETRMMK1:
 21963                                  	;lodsb
 21964                                  	;call	DELIM
 21965                                  	;jz	short SETRMMK3
 21966                                  	;cmp	al,0Dh
 21967                                  	;jne	short SETRMMK1
 21968                                  	;mov	byte [si-1],0
 21969                                  ;SETRMMK2:
 21970                                  	;retn
 21971                                  ;SETRMMK3:
 21972                                  	;mov	byte [si-1],0
 21973                                  	;push	si
 21974                                  	;call	SCANOFF
 21975                                  	;pop	si
 21976                                  	;cmp	al,0Dh
 21977                                  	;je	short SETRMMK2
 21978                                  ;NOARGERR:
 21979                                  	;mov	dx,BADARGSPTR
 21980                                  	;xor	ax,ax
 21981                                  	;stc
 21982                                  ;SETRMMK_RETN:
 21983                                  	;retn
 21984                                  
 21985                                  ; =============== S U B	R O U T	I N E =======================================
 21986                                  
 21987                                  ; MSDOS 6.0
 21988                                  
 21989                                  ;****************************************************************
 21990                                  ;*
 21991                                  ;* ROUTINE:	Set_ext_error_subst
 21992                                  ;*
 21993                                  ;* FUNCTION:	Sets up substitution for extended error
 21994                                  ;*
 21995                                  ;* INPUT:	AX - extended error number
 21996                                  ;*		DX - offset of string
 21997                                  ;*
 21998                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
 21999                                  ;*
 22000                                  ;****************************************************************
 22001                                  
 22002                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22003                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:267Ch
 22004                                  set_ext_error_subst:
 22005                                  	;mov	byte [msg_disp_class],1
 22006 00002AE6 C606[F191]01            	mov	byte [msg_disp_class],ext_msg_class
 22007                                  					;AN022; set up extended error msg class
 22008 00002AEB 8916[B7A0]              	mov	[string_ptr_2],dx 	;AN022; get address of failed string
 22009                                  	;mov	byte [extend_buf_sub],1
 22010 00002AEF C606[F591]01            	mov	byte [extend_buf_sub],one_subst
 22011                                  	;AN022; put number of subst in control block
 22012 00002AF4 BA[F391]                	mov	dx,extend_buf_ptr 	;AN022; get extended message pointer
 22013 00002AF7 A3[F391]                	mov	[extend_buf_ptr],ax	;AN022; get message number in control block
 22014                                  savudir_err_retn: ; 24/02/2023
 22015 00002AFA C3                      	retn				;AN022; return
 22016                                  
 22017                                  ; =============== S U B	R O U T	I N E =======================================
 22018                                  
 22019                                  ; <SavUDir - preserve the users current directory on a particular drive>
 22020                                  
 22021                                  ; SavUDir - move the user's current directory on a drive into UserDir1
 22022                                  ; SavUDir1 - move the user's current directory on a drive into a specified
 22023                                  ;   buffer
 22024                                  ;
 22025                                  ;   Inputs:	DL has 1-based drive number
 22026                                  ;		ES:DI has destination buffer (SavUDir1 only)
 22027                                  ;   Outputs:	Carry Clear
 22028                                  ;		    DS = TranGroup
 22029                                  ;		Carry Set
 22030                                  ;		    AX has error code
 22031                                  ;   Registers Modified: AX, SI
 22032                                  
 22033                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22034                                  SAVUDIR:
 22035 00002AFB BF[F79C]                	mov	di,USERDIR1
 22036                                  ; --------------
 22037                                  SAVUDIR1:
 22038 00002AFE 88D0                    	mov	al,dl
 22039 00002B00 0440                    	add	al,'@' ; 40h
 22040 00002B02 3C40                    	cmp	al,'@' ; 40h
 22041 00002B04 7506                    	jne	short GOTUDRV
 22042 00002B06 0206[299E]              	add	al,[CURDRV]
 22043 00002B0A FEC0                    	inc	al		; A = 1
 22044                                  GOTUDRV:
 22045 00002B0C AA                      	stosb
 22046 00002B0D 8A26[1A9E]              	mov	ah,[DIRCHAR]
 22047 00002B11 B03A                    	mov	al,':' ; 3Ah
 22048 00002B13 AB                      	stosw
 22049 00002B14 06                      	push	es
 22050 00002B15 1F                      	pop	ds
 22051 00002B16 89FE                    	mov	si,di
 22052 00002B18 B447                    	mov	ah,47h ; 24/02/2023
 22053                                  	;mov	ah,CURRENT_DIR	; 47h
 22054 00002B1A CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 22055                                  			; DL = drive (0=default,1=A,etc.)
 22056                                  			; DS:SI	points to 64-byte buffer area
 22057 00002B1C 72DC                    	jc	short savudir_err_retn ; 24/02/2023
 22058 00002B1E 0E                      	push	cs
 22059 00002B1F 1F                      	pop	ds
 22060 00002B20 C3                      	retn
 22061                                  
 22062                                  ; =============== S U B	R O U T	I N E =======================================
 22063                                  
 22064                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22065                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:26B7h
 22066                                  CRLF2:
 22067 00002B21 52                      	push	dx
 22068 00002B22 BA[D593]                	mov	dx,acrlf_ptr
 22069 00002B25 1E                      	push	ds
 22070 00002B26 0E                      	push	cs
 22071 00002B27 1F                      	pop	ds
 22072 00002B28 E8022A                  	call	std_printf
 22073 00002B2B 1F                      	pop	ds
 22074 00002B2C 5A                      	pop	dx
 22075 00002B2D C3                      	retn
 22076                                  
 22077                                  ; =============== S U B	R O U T	I N E =======================================
 22078                                  
 22079                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
 22080                                  ; may NOT be TRANGROUP
 22081                                  
 22082                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22083                                  scanoff:
 22084 00002B2E AC                      	lodsb
 22085 00002B2F E80400                  	call	DELIM
 22086 00002B32 74FA                    	jz	short scanoff
 22087 00002B34 4E                      	dec	si		; Point to first non-delimiter
 22088                                  scanoff_retn:
 22089 00002B35 C3                      	retn
 22090                                  
 22091                                  ; =============== S U B	R O U T	I N E =======================================
 22092                                  
 22093                                  ; Input:    AL is character to classify
 22094                                  ; Output:   Z set if delimiter
 22095                                  ;	    NZ set otherwise
 22096                                  ; Registers modified: none
 22097                                  
 22098                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22099                                  DELIM:
 22100 00002B36 3C20                    	cmp	al,' '	 ;20h
 22101 00002B38 74FB                    	je	short scanoff_retn
 22102 00002B3A 3C3D                    	cmp	al,'='  ; 3Dh
 22103 00002B3C 74F7                    	je	short scanoff_retn
 22104 00002B3E 3C2C                    	cmp	al,','	; 2Ch
 22105 00002B40 74F3                    	je	short scanoff_retn
 22106 00002B42 3C3B                    	cmp	al,';'	 ;3Bh
 22107 00002B44 74EF                    	je	short scanoff_retn
 22108 00002B46 3C09                    	cmp	al,9		; Check for TAB character
 22109 00002B48 74EB                    	je	short scanoff_retn
 22110 00002B4A 3C0A                    	cmp	al,0Ah		; Check for line feed character - BAS
 22111 00002B4C C3                      	retn
 22112                                  
 22113                                  
 22114                                  ; =============== S U B	R O U T	I N E =======================================
 22115                                  
 22116                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22117                                  FCB_TO_ASCZ:			
 22118                                  	; Convert DS:SI to ASCIZ ES:DI
 22119 00002B4D B90800                  	mov	cx,8
 22120                                  MAINNAME:
 22121 00002B50 AC                      	lodsb
 22122 00002B51 3C20                    	cmp	al,' ' ; 20h
 22123 00002B53 7401                    	jz	short SKIPSPC
 22124 00002B55 AA                      	stosb
 22125                                  SKIPSPC:
 22126 00002B56 E2F8                    	loop	MAINNAME
 22127 00002B58 AC                      	lodsb
 22128 00002B59 3C20                    	cmp	al,' '
 22129 00002B5B 740F                    	je	short GOTNAME
 22130 00002B5D 88C4                    	mov	ah,al
 22131                                  	; 24/02/2023
 22132 00002B5F B02E                    	mov	al,'.' ; 2Eh  ; MSDOS 5.0 (& 6.0)
 22133                                  	;mov	al,[DOT_CHR]  ; MSDOS 3.3
 22134                                  	;stosb
 22135                                  	;xchg	al,ah
 22136                                  	;stosb
 22137                                  	; 24/02/2023
 22138 00002B61 AB                      	stosw
 22139 00002B62 B102                    	mov	cl,2
 22140                                  EXTNAME:
 22141 00002B64 AC                      	lodsb
 22142 00002B65 3C20                    	cmp	al,' '
 22143 00002B67 7403                    	je	short GOTNAME
 22144 00002B69 AA                      	stosb
 22145 00002B6A E2F8                    	loop	EXTNAME
 22146                                  GOTNAME:
 22147 00002B6C 30C0                    	xor	al,al
 22148 00002B6E AA                      	stosb
 22149                                  STRCOMP_RETN:
 22150 00002B6F C3                      	retn
 22151                                  
 22152                                  ; =============== S U B	R O U T	I N E =======================================
 22153                                  
 22154                                  ; Compare ASCIZ DS:SI with ES:DI.
 22155                                  ; SI,DI destroyed.
 22156                                  
 22157                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22158                                  STRCOMP:	
 22159 00002B70 A6                      	cmpsb
 22160 00002B71 75FC                    	jnz	short STRCOMP_RETN ; Strings not equal
 22161 00002B73 807CFF00                	cmp	byte [si-1],0	; Hit NUL terminator?	
 22162                                  	;jz	short STRCOMP_RETN ; Yes, strings equal
 22163                                  	;jmp	short STRCOMP	; Equal so far, keep going
 22164                                  	; 24/02/2023
 22165 00002B77 75F7                    	jnz	short STRCOMP
 22166 00002B79 C3                      	retn
 22167                                  
 22168                                  ; =============== S U B	R O U T	I N E =======================================
 22169                                  
 22170                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22171                                  CRPRINT:
 22172 00002B7A 50                      	push	ax
 22173                                  	;mov	al,13	; 0Dh
 22174 00002B7B B00D                    	mov	al,0Dh
 22175 00002B7D 51                      	push	cx
 22176 00002B7E 57                      	push	di
 22177 00002B7F 89D7                    	mov	di,dx
 22178 00002B81 B9FFFF                  	mov	cx,65535 ; 0FFFFh
 22179 00002B84 06                      	push	es
 22180 00002B85 1E                      	push	ds
 22181 00002B86 07                      	pop	es
 22182 00002B87 F2AE                    	repne	scasb		; LOOK FOR TERMINATOR
 22183 00002B89 C645FF00                	mov	byte [di-1],0	; nul terminate the string
 22184 00002B8D 07                      	pop	es
 22185 00002B8E 8916[B7A0]              	mov	[string_ptr_2],dx
 22186                                  	;mov	dx,STRINGBUF2PTR  ; MSDOS 3.3 (Retro DOS v3.0 COMMAND.COM)
 22187 00002B92 BA[BA93]                	mov	dx,string_buf_ptr ; MSDOS 5.0 (& 6.0)
 22188 00002B95 E89529                  	call	std_printf
 22189                                  	;mov	byte [di-1],13
 22190 00002B98 C645FF0D                	mov	byte [di-1],0Dh	; now put the CR back
 22191 00002B9C 7204                    	jb	short error_output
 22192 00002B9E 5F                      	pop	di
 22193 00002B9F 59                      	pop	cx
 22194 00002BA0 58                      	pop	ax
 22195 00002BA1 C3                      	retn
 22196                                  
 22197                                  ; ---------------------------------------------------------------------------
 22198                                  
 22199                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22200                                  error_output:
 22201 00002BA2 0E                      	push	cs
 22202 00002BA3 1F                      	pop	ds
 22203 00002BA4 8E06[159E]              	mov	es,[RESSEG]
 22204 00002BA8 BA[0792]                	mov	dx,NOSPACE_PTR
 22205 00002BAB 26803E[B502]00          	cmp	byte [es:PipeFlag],0
 22206 00002BB1 7406                    	jz	short go_to_error
 22207 00002BB3 E80209                  	call	PipeOff
 22208 00002BB6 BA[5493]                	mov	dx,PIPEEMES_PTR
 22209                                  go_to_error:
 22210 00002BB9 E9E602                  	jmp	cerror
 22211                                  
 22212                                  ; =============== S U B	R O U T	I N E =======================================
 22213                                  
 22214                                  ;---- Mod for path invocation ----
 22215                                  
 22216                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22217                                  pathchrcmp:
 22218                                  	; 18/03/2023	
 22219                                  	;push	ax
 22220                                  	;mov	ah,'/' ; 2Fh
 22221                                  	;cmp	[SWITCHAR],ah
 22222 00002BBC 803E[199E]2F            	cmp	byte [SWITCHAR],'/' ; 2Fh
 22223 00002BC1 7404                    	je	short noslasht
 22224 00002BC3 3C2F                    	cmp	al,'/'
 22225 00002BC5 7402                    	je	short pccont
 22226                                  noslasht:
 22227 00002BC7 3C5C                    	cmp	al,'\' ; 5Ch
 22228                                  pccont:	
 22229                                  	;pop	ax
 22230 00002BC9 C3                      	retn
 22231                                  
 22232                                  ; =============== S U B	R O U T	I N E =======================================
 22233                                  
 22234                                  ; PATHCRUNCH -
 22235                                  ;
 22236                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
 22237                                  ;       PathPos = ptr to string with pathname in it
 22238                                  ;       PathCnt = length of string
 22239                                  ;
 22240                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
 22241                                  ;       PathCnt = length left in string
 22242                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
 22243                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
 22244                                  ;       If path crunched successfully,
 22245                                  ;         CY = clear
 22246                                  ;         Current directory is changed to directory in pathname
 22247                                  ;         UserDir1 contains previous directory for use by RestUDir
 22248                                  ;         RestDir = nonzero to flag later restoration of user's dir
 22249                                  ;         DestTail = ptr to beginning of filename
 22250                                  ;         If filename found in pathname,
 22251                                  ;           ZR = clear
 22252                                  ;           FCB filename fields contain filename
 22253                                  ;         If filename not found (pure directory path),
 22254                                  ;           ZR = set
 22255                                  ;           FCB filename fields are wildcarded with ?'s
 22256                                  ;       If pathcrunch failed (no ChDir's worked),
 22257                                  ;         CY = set
 22258                                  ;         Msg_Numb = extended error code
 22259                                  ;
 22260                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
 22261                                  ;       FCB by setting DirFlag. In this case, the FCB is returned
 22262                                  ;       with the filename wildcarded.
 22263                                  
 22264                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 22265                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2767h
 22266                                  
 22267                                  	; 11/06/2023 - Retro DOS v4.2
 22268                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2D11h
 22269                                  PathCrunch:
 22270                                  	; MSDOS 6.0
 22271 00002BCA C706[4BA2]0000          	mov     word [Msg_Numb],0
 22272                                  				;AN022; Set up message flag
 22273                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22274                                  	;mov	dl,[5Ch]
 22275 00002BD0 8A165C00                	mov	dl,[FCB]	; DL = drive # (1 = A)
 22276 00002BD4 E824FF                  	call	SAVUDIR		; save current directory in UserDir1
 22277                                  	; MSDOS 6.0
 22278 00002BD7 7233                     	jc	short pcrunch_cderrj
 22279                                  				;AN022; if error on current dir - report
 22280 00002BD9 E86004                  	call	SETPATH		; scan past switches, whitespace
 22281                                  
 22282                                  ;       DX = ptr to pathname, NULL-terminated
 22283                                  ;       PathPos = ptr to byte after NULL at end of pathname
 22284                                  
 22285                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22286 00002BDC F606[D4A0]02            	test	byte [DestInfo],2 ; test if wildcards (? or *) seen
 22287 00002BE1 752C                    	jnz	short trypeel	; wildcard seen, peel filename
 22288                                  
 22289                                  	;mov	ah,CHDir ; 3Bh
 22290 00002BE3 B43B                    	mov	ah,3Bh
 22291 00002BE5 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 22292                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 22293                                  	; MSDOS 6.0
 22294 00002BE7 7313                    	jnc	short chdir_worked	;AN022; no error - continue
 22295                                  	
 22296 00002BE9 E856F6                  	call	get_ext_error_number    ;AN022; get the extended error
 22297 00002BEC 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found
 22298 00002BEF 741E                    	je	short trypeel		;AC022;    keep trying
 22299 00002BF1 83F805                  	cmp	ax,ERROR_ACCESS_DENIED  ;AN022; if access denied
 22300 00002BF4 7419                    	je	short trypeel		;AC022;    keep trying
 22301 00002BF6 A3[4BA2]                	mov	[Msg_Numb],ax           ;AN022; set up message flag
 22302 00002BF9 E99C00                  	jmp	peelfail                ;AN022; exit with other error
 22303                                  
 22304                                  	; MSDOS 3.3
 22305                                  	;jc	short trypeel
 22306                                  chdir_worked:
 22307                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22308 00002BFC E83206                  	call	SetRest1	; set 'Restore Directory' flag true
 22309 00002BFF B03F                    	mov	al,'?'		; if pure dir, wildcard filename in FCB
 22310 00002C01 BF5D00                  	mov	di,5Dh  ; FCB+1
 22311 00002C04 B90B00                  	mov	cx,11
 22312 00002C07 F3AA                    	rep	stosb
 22313 00002C09 30C0                    	xor	al,al		; return carry clear, zero set
 22314 00002C0B C3                      	retn
 22315                                  
 22316                                  pcrunch_cderrj: 		;AN022; need this for long jmp
 22317 00002C0C E98100                  	jmp	pcrunch_cderr	;AN022;
 22318                                  
 22319                                  trypeel:
 22320 00002C0F 8B36[A6A0]              	mov	si,[PathPos]
 22321 00002C13 4E                      	dec	si		; SI = ptr to NULL at end of pathname
 22322 00002C14 8A44FF                  	mov	al,[si-1]	; AL = last char of pathname
 22323                                  	; 25/02/2023
 22324                                  	; MSDOS 5.0 (& 6.0)
 22325 00002C17 803E[66A2]00            	cmp	byte [KPARSE],0
 22326 00002C1C 7505                    	jnz	short delstrt	; Last char is 2nd KANJI byte, might be '\'
 22327                                  	
 22328 00002C1E E89BFF                  	call	pathchrcmp
 22329 00002C21 7475                    	jz	short peelfail	; Trailing '/'
 22330                                  delstrt:
 22331 00002C23 89F1                    	mov	cx,si		; CX = ptr to NULL at end of pathname
 22332 00002C25 89D6                    	mov	si,dx		; SI = ptr to start of pathname
 22333 00002C27 52                      	push	dx		; save ptr to pathname
 22334                                  delloop:
 22335 00002C28 39CE                    	cmp	si,cx
 22336                                  	;jz	short BADRET
 22337                                  	; 25/02/2023
 22338 00002C2A 7413                    	je	short gotdele	; no char's left, we have what we have
 22339 00002C2C AC                      	lodsb			; AL = next char of pathname
 22340 00002C2D E8DFFC                  	call	testkanj
 22341 00002C30 7403                    	jz	short notkanj8	; not Kanji, move along
 22342 00002C32 46                      	inc	si
 22343 00002C33 EBF3                    	jmp	short delloop	
 22344                                  
 22345                                  	; 25/02/2023
 22346                                  	; MSDOS 3.3
 22347                                  	;mov	al,[si]
 22348                                  	;call	PATHCHRCMP
 22349                                  	;jz	short TRYCD
 22350                                  	;dec	si
 22351                                  	;jmp	short delloop
 22352                                  
 22353                                  notkanj8:
 22354 00002C35 E884FF                  	call	pathchrcmp
 22355 00002C38 75EE                    	jnz	short delloop	; not a path delimiter, keep looking
 22356 00002C3A 89F2                    	mov	dx,si
 22357 00002C3C 4A                      	dec	dx		; DX = ptr to last delimiter found	
 22358 00002C3D EBE9                    	jmp	short delloop	; go look for more
 22359                                  
 22360                                  	; 25/02/2023
 22361                                  	; MSDOS 5.0 (& 6.0)
 22362                                  gotdele:
 22363 00002C3F 89D6                    	mov	si,dx		; SI = ptr to pathname or last delim
 22364 00002C41 5A                      	pop	dx		; DX = ptr to pathname
 22365 00002C42 39D6                    	cmp	si,dx
 22366 00002C44 7454                    	je	short badret	; didn't find path delim
 22367 00002C46 89F1                    	mov	cx,si		; CX = ptr to last path delimiter
 22368 00002C48 89D6                    	mov	si,dx		; SI = ptr to pathname
 22369                                  delloop2:			; Set value of KPARSE
 22370 00002C4A 39CE                    	cmp	si,cx
 22371 00002C4C 7412                    	je	short trycd	; roll up till SI meets CX
 22372 00002C4E C606[66A2]00            	mov	byte [KPARSE],0
 22373 00002C53 AC                      	lodsb
 22374 00002C54 E8B8FC                  	call	testkanj
 22375 00002C57 74F1                    	jz	short delloop2
 22376 00002C59 46                      	inc	si
 22377 00002C5A FE06[66A2]              	inc	byte [KPARSE]
 22378 00002C5E EBEA                    	jmp	short delloop2
 22379                                  
 22380                                  trycd:
 22381 00002C60 50                      	push	ax
 22382                                  	; 25/02/2023
 22383 00002C61 B02E                    	mov	al,'.'
 22384                                  	;mov	al,[DOT_CHR]	; AL = '.'
 22385                                  	; MSDOS 6.0
 22386 00002C63 384401                  	cmp	[si+1],al	; check for '.' after path delim
 22387                                  				;M019; allow continuation if '. ' or 
 22388                                  				;M019; '..' is not found.
 22389 00002C66 7509                    	jne	short trycd1	;M019; '.' not found
 22390 00002C68 384402                  	cmp	[si+2],al	;M019; check for '..'
 22391 00002C6B 7404                    	je	short trycd1	;M019; found '..'
 22392 00002C6D 807C0200                	cmp	byte [si+2],0	;M019; check for '. ' (null terminated)
 22393                                  trycd1:	
 22394 00002C71 58                      	pop     ax
 22395 00002C72 7424                    	jz	short peelfail	; if . or .., pure cd should have worked
 22396                                  
 22397                                  	; 25/02/2023
 22398                                  	; MSDOS 3.3
 22399                                  	;cmp	[si+1],	al	; check for '.' after path delim
 22400                                  	;pop	ax
 22401                                  	;jz	short PEELFAIL	; if . or .., pure cd should have worked
 22402                                  
 22403                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22404 00002C74 8A44FF                  	mov	al,[si-1]
 22405 00002C77 3C3A                    	cmp	al,':' 		; Special case d:\file
 22406 00002C79 741F                    	je	short badret
 22407                                  	; 25/02/2023
 22408                                  	; MSDOS 6.0
 22409 00002C7B 803E[66A2]00            	cmp	byte [KPARSE],0
 22410 00002C80 7505                    	jnz	short notdoublesl
 22411 00002C82 E837FF                  	call	pathchrcmp
 22412                                  	;jnz	short notdoublesl
 22413                                  				; Last char is 2nd KANJI byte, might be '\'
 22414                                  	; 25/02/2023
 22415 00002C85 7411                    	jz	short peelfail 
 22416                                  ;peelfail:
 22417                                  	;stc
 22418                                  	;retn
 22419                                  
 22420                                  notdoublesl:
 22421 00002C87 C60400                  	mov	byte [si],0
 22422                                  	;mov	ah,CHDir ; 3Bh
 22423 00002C8A B43B                    	mov	ah,3Bh
 22424 00002C8C CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 22425                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 22426 00002C8E 7320                    	jnc	short cdsucc
 22427                                  
 22428                                  	; 25/02/2023
 22429                                  	; MSDOS 6.0
 22430                                  pcrunch_cderr:
 22431 00002C90 E8AFF5                  	call	get_ext_error_number
 22432                                  				;AN022; get the extended error
 22433 00002C93 A3[4BA2]                	mov	[Msg_Numb],ax	;AN022; set up message flag
 22434 00002C96 09F6                    	or	si,si		;AN022; set up zero flag to not zero
 22435                                  peelfail: ; 25/02/2023
 22436 00002C98 F9                      	stc			;AN022; set up carry flag
 22437                                  pcrunch_retn:
 22438 00002C99 C3                      	retn
 22439                                  
 22440                                  badret:
 22441                                  	; MSDOS 3.3 & MSDOS 6.0
 22442 00002C9A 8A04                    	mov	al,[si]
 22443 00002C9C E81DFF                  	call	pathchrcmp	; Special case 'DIRCHAR'file
 22444 00002C9F F9                      	stc
 22445 00002CA0 75F7                    	jnz	short pcrunch_retn
 22446 00002CA2 30DB                    	xor	bl,bl
 22447 00002CA4 865C01                  	xchg	bl,[si+1]
 22448                                  	;mov	ah,CHDir ; 3Bh
 22449 00002CA7 B43B                    	mov	ah,3Bh
 22450 00002CA9 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 22451                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 22452                                  	;jc	short pcrunch_retn ; MSDOS 3.3
 22453                                  	; 25/02/2023
 22454 00002CAB 72E3                    	jc	short pcrunch_cderr
 22455                                  				;AN022; go to error exit 
 22456 00002CAD 885C01                  	mov	[si+1],bl
 22457                                  cdsucc:
 22458 00002CB0 E87E05                  	call	SetRest1
 22459 00002CB3 46                      	inc	si		; Reset zero
 22460 00002CB4 8936[D2A0]              	mov	[DestTail],si
 22461                                  	; 25/02/2023
 22462                                  	; MSDOS 6.0
 22463 00002CB8 9C                      	pushf			;AN015; save flags
 22464 00002CB9 803E[AEA0]FF            	cmp	byte [DirFlag],-1
 22465                                  				;AN015; don't do parse if in DIR
 22466 00002CBE 7408                    	je	short pcrunch_end
 22467                                  				;AN015;
 22468                                  	; MSDOS 3.3 & MSDOS 6.0
 22469 00002CC0 BF5C00                  	mov	di,FCB  ; 5Ch
 22470                                  	;mov	ax,(Parse_File_Descriptor<<8)|2 ; 2902h
 22471 00002CC3 B80229                  	mov	ax,2902h	
 22472 00002CC6 CD21                    	int	21h		; Parse with default drive
 22473                                  			; DOS -	PARSE FILENAME
 22474                                  			; DS:SI	-> string to parse
 22475                                  			; ES:DI	-> buffer to fill with unopened	FCB
 22476                                  			; AL = bit mask	to control parsing
 22477                                  	; MSDOS 3.3
 22478                                  	;retn
 22479                                  
 22480                                  pcrunch_end:
 22481 00002CC8 9D                      	popf			;AN015; get flags back
 22482 00002CC9 C3                      	retn
 22483                                  
 22484                                  ;============================================================================
 22485                                  ; TMISC1.ASM, MSDOS 6.0, 1991
 22486                                  ;============================================================================
 22487                                  ; 05/10/2018 - Retro DOS v3.0
 22488                                  
 22489                                  ;TITLE	Part7 COMMAND Transient Routines
 22490                                  
 22491                                  ;	More misc routines
 22492                                  
 22493                                  ;---------------------------
 22494                                  ; We can get rid of this switch processing code if we can take
 22495                                  ; care of the remaining two calls to switch, later in the file.
 22496                                  ; However, I have not checked whether or not any other files use
 22497                                  ; switch -- after all, it IS public!
 22498                                  ;---------------------------
 22499                                  
 22500                                  ; 14/06/2023
 22501                                  SWCOUNT	EQU 8	; MSDOS 6.22		; Length of switch_list
 22502                                  ; 28/03/2023
 22503                                  ;SWCOUNT  EQU  6  ; MSDOS 6.0 (& MSDOS 5.0)
 22504                                  ;;SWCOUNT EQU  5  ; MSDOS 3.3	
 22505                                  
 22506                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
 22507                                  
 22508                                  ; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 22509                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2869h
 22510                                  
 22511                                  ; ---------------------------------------------------------------------------
 22512                                  
 22513                                  	; 25/02/2023
 22514                                  RETSW:
 22515 00002CCA 93                      	xchg	ax,bx		; Put switches in AX
 22516 00002CCB C3                      	retn
 22517                                  
 22518                                  ; =============== S U B	R O U T	I N E =======================================
 22519                                  
 22520                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 22521                                  	; 11/06/2023 - Retro DOS 4.2 COMMAND.COM
 22522                                  SWITCH:
 22523 00002CCC 31DB                    	xor	bx,bx		; Initialize - no switches set
 22524                                  SWLOOP:
 22525 00002CCE E85DFE                  	call	scanoff		; Skip any delimiters
 22526 00002CD1 3A06[199E]              	cmp	al,[SWITCHAR]	; Is it a switch specifier?
 22527 00002CD5 75F3                    	jnz	short RETSW	; No -- we're finished
 22528 00002CD7 81CB0080                	or	bx,8000h
 22529                                  	;or	bx,FSWITCH	; Indicate there is a switch specified
 22530 00002CDB 46                      	inc	si		; Skip over the switch character
 22531 00002CDC E84FFE                  	call	scanoff
 22532 00002CDF 3C0D                    	cmp	al,0Dh
 22533 00002CE1 74E7                    	je	short RETSW	; Oops
 22534 00002CE3 46                      	inc	si
 22535                                  
 22536                                  	; Convert lower case input to upper case
 22537                                  
 22538 00002CE4 E852FC                  	call	UPCONV
 22539                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 22540                                  
 22541 00002CE7 BF[8297]                	mov	di,switch_list	; "-Y?VBAPW" (for MSDOS 6.22) ; 11/06/2023
 22542                                  				; "?VBAPW" (for MSDOS 6.0)
 22543                                  				; ("VBAPW" (for MSDOS 3.3))
 22544                                  	; 11/06/2023
 22545                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2E33h
 22546 00002CEA B90800                  	mov	cx,8  ; MSDOS 6.22	   	
 22547                                  	;mov	cx,6  ; MSDOS 6.0 (& MSDOS 5.0)
 22548                                  	;;mov	cx,5  ; MSDOS 3.3
 22549                                  	;;mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
 22550                                  		
 22551                                  	;nop
 22552                                  		
 22553 00002CED F2AE                    	repne	scasb		; Look for matching switch
 22554 00002CEF 7507                    	jnz	short BADSW
 22555 00002CF1 B80100                  	mov	ax,1
 22556 00002CF4 D3E0                    	shl	ax,cl		; Set a bit for the switch
 22557 00002CF6 09C3                    	or	bx,ax
 22558                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
 22559 00002CF8 EBD4                    	jmp	short SWLOOP
 22560                                  ;BADSW:
 22561                                  	;jmp	short SWLOOP
 22562                                  ;DRVBAD:
 22563                                  ;	mov	dx,baddrv_ptr
 22564                                  ;	jmp	cerror
 22565                                  EXTERNALJ:
 22566 00002CFA E90501                  	jmp	EXTERNAL
 22567                                  FNDCOM:				; search the internal command table
 22568 00002CFD 08C0                    	or	al,al		; Get real length of first arg
 22569 00002CFF 74F9                    	jz	short EXTERNALJ	; If 0, it must begin with "\" so has
 22570                                  				;  to be external.
 22571                                  ; barryf code starts here
 22572                                  
 22573 00002D01 E82703                  	call	test_append	; see if APPEND installed
 22574 00002D04 7429                    	jz	short CONTCOM	; not loaded
 22575                                  
 22576                                  APPEND_INTERNAL:
 22577 00002D06 8A0E[D19F]              	mov	cl,[IDLEN]
 22578 00002D0A B500                    	mov	ch,0
 22579 00002D0C 890E[A6A0]              	mov	[PathPos],cx
 22580                                  	
 22581                                  	; 25/02/2023	
 22582                                  	; MSDOS 6.0
 22583 00002D10 FE06[4DA2]              	inc 	byte [append_exec]
 22584                                  				;AN041; set APPEND to ON
 22585 00002D14 E8B603                  	call	IOSET		; re-direct the o'l io
 22586                                  
 22587 00002D17 BE[D19F]                	mov	si,IDLEN	; address command name, DS already set	
 22588 00002D1A BAFFFF                  	mov	dx,-1 ; 0FFFFh	; set invoke function
 22589                                  		
 22590                                  	; MSDOS 6.0
 22591 00002D1D BF[1755]                	mov	di,append_parse
 22592                                  				;AN010; Get the entry point for PARSE for APPEND
 22593                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22594 00002D20 B801AE                  	mov	ax,0AE01h
 22595 00002D23 CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal
 22596                                  			; - INSTALLABLE	COMMAND	- EXECUTE
 22597                                  			; DX = FFFFh, DS:SI -> buffer
 22598                                  			; Return: buffer at DS:SI filled with a	length byte
 22599                                  			; followed by the uppercase internal command
 22600                                  			; to execute (if length not 0)
 22601                                  	; 25/02/2023
 22602                                  	; INT 2Fh
 22603                                  	; 	AX = AE01h
 22604                                  	; entry:
 22605                                  	; 	DX = magic value FFFFh
 22606                                  	; 	CH = 00h
 22607                                  	; 	CL = length of command name
 22608                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 22609                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 22610                                  	; return:
 22611                                  	;	DS:SI buffer updated
 22612                                  	;	if length byte is nonzero, the following bytes contain
 22613                                  	;	the uppercase internal command to execute and the command line
 22614                                  	; 	buffer contains the command's parameters
 22615                                  	;	(the first DS:[SI] bytes are ignored)
 22616                                  	;
 22617                                  	; Format of COMMAND.COM command line buffer:
 22618                                  	;	Offset  Size    Description
 22619                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 22620                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 22621                                  	;	N BYTEs command line text, terminated by 0Dh
 22622                                  	;
 22623                                  	; Format of command name buffer:
 22624                                  	;	Offset  Size    Description
 22625                                  	;	00h     BYTE    length of command name
 22626                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 22627                                  
 22628 00002D25 803E[D19F]00            	cmp	byte [IDLEN],0 ; execute requested
 22629 00002D2A 7503                    	jne	short CONTCOM
 22630 00002D2C E9A300                  	jmp	CMD_DONE
 22631                                  
 22632                                  	;nop
 22633                                  CONTCOM:			; continue with internal scan
 22634 00002D2F BF[0196]                	mov	di,COMTAB
 22635 00002D32 31C9                    	xor	cx,cx
 22636                                  FINDCOM:
 22637 00002D34 BE[D29F]                	mov	si,ID		; pointer to command argument
 22638 00002D37 8A0D                    	mov	cl,[di]		; load length of internal command
 22639 00002D39 47                      	inc	di		; advance past length
 22640 00002D3A E3BE                    	jcxz	EXTERNALJ 	; if it's zero, we're out of internals
 22641 00002D3C 3A0E[D19F]              	cmp	cl,[IDLEN]	; that of the command argument
 22642 00002D40 7506                    	jne	short ABCD	; lengths not equal ==> strings not eq
 22643 00002D42 890E[A6A0]              	mov	[PathPos],cx	; store length of command
 22644 00002D46 F3A6                    	repe	cmpsb
 22645                                  ABCD:					
 22646 00002D48 9F                      	lahf			; save the good ol' flags
 22647 00002D49 01CF                    	add	di,cx		; skip over remaining internal, if any
 22648 00002D4B 8A05                    	mov	al,[di]		; load drive-check indicator byte (DCIB)
 22649 00002D4D A2[279E]                	mov	[CHKDRV],al	; save command flag byte in chkdrv
 22650 00002D50 47                      	inc	di		; increment DI (OK, OK, I'll stop)
 22651 00002D51 8B1D                    	mov	bx,[di]		; load internal command address
 22652 00002D53 47                      	inc	di		; skip over the puppy
 22653 00002D54 47                      	inc	di
 22654                                  		
 22655                                  	; MSDOS 6.0
 22656 00002D55 8B15                    	mov	dx,[di]		; load ptr to help msg #s
 22657 00002D57 47                      	inc	di
 22658 00002D58 47                      	inc	di
 22659 00002D59 9E                      	sahf			; remember those flags?
 22660 00002D5A 75D8                    	jnz	short FINDCOM	; well, if all the cmps worked...
 22661                                  
 22662                                  ; All messages get redirected.
 22663                                  
 22664 00002D5C 803E[4DA2]00            	cmp     byte [append_exec],0
 22665                                  				;AN041; APPEND just executed?
 22666 00002D61 7503                    	jnz 	short DONT_SET_IO
 22667                                  				;AN041; Yes - this junk is already set
 22668 00002D63 E86703                  	call	IOSET		; re-direct the ol' i/o
 22669                                  
 22670                                  DONT_SET_IO:			;AN041;
 22671                                  
 22672                                  ; Check for /?. Certain commands, flagged fLimitHelp,
 22673                                  ; respond to /? only if it is the only command-line argument.
 22674                                  
 22675 00002D66 A1[2C9E]                	mov	ax,[COMSW]	; AX = switches after command
 22676 00002D69 0B06[329E]              	or	ax,[AllSwitch]	; AX = all switches
 22677                                  	;and	ax,SwitchQues	
 22678 00002D6D 83E020                  	and	ax,20h
 22679 00002D70 7426                    	jz	short DRIVE_CHECK
 22680                                  				; /? not in command line
 22681 00002D72 F606[279E]04            	test	byte [CHKDRV],4	
 22682                                  	;test	byte [CHKDRV],fLimitHelp
 22683 00002D77 7407                    	jz	short DO_HELP	; /? allowed in combination
 22684                                  
 22685                                  ; Make sure /? is the only argument on the command line.
 22686                                  
 22687 00002D79 833E[27A5]02            	cmp	word [ARG+ARG_UNIT.argvcnt],2
 22688 00002D7E 7518                    	jne	short DRIVE_CHECK
 22689                                  				; /? not only arg - ignore
 22690                                  
 22691                                  ; Note: this is all the check we need, even against things like /??.
 22692                                  ; Our argv parser breaks /?? into two args, /? and ?.
 22693                                  
 22694                                  DO_HELP:
 22695                                  ; DX = ptr to word list of msg #s, terminated by zero word
 22696                                  
 22697 00002D80 89D6                    	mov	si,dx		; SI = ptr to list of msg #s
 22698                                      	;mov	ax,no_subst	; AL = no subst's code
 22699 00002D82 B80000                  	mov	ax,0
 22700 00002D85 50                      	push	ax		; build subst block on stack
 22701                                  
 22702                                  NEXT_HELP_MSG:
 22703 00002D86 AD                      	lodsw			; AX = help msg # or zero
 22704 00002D87 09C0                    	or	ax,ax
 22705 00002D89 7409                    	jz	short HELP_DONE
 22706 00002D8B 50                      	push	ax		; SS:SP = ptr to subst block
 22707                                  				; (msg # and no_subst byte)
 22708                                  ;; We assume DS = SS.
 22709                                  	
 22710 00002D8C 89E2                    	mov     dx,sp		; DS:DX = ptr to subst block
 22711 00002D8E E89C27                  	call	std_printf	; display help message	
 22712 00002D91 58                      	pop	ax		; remove msg # from stack
 22713 00002D92 EBF2                    	jmp	short NEXT_HELP_MSG
 22714                                  
 22715                                  HELP_DONE:
 22716 00002D94 58                      	pop	ax		; clean up stack
 22717 00002D95 E96CD3                  	jmp	TCOMMAND	
 22718                                  
 22719                                  	; 25/02/2023
 22720                                  	; MSDOS 3.3
 22721                                  	;sahf			; remember those flags?
 22722                                  	;jnz	short FINDCOM	; well, if all the cmps worked...
 22723                                  	;call	IOSET		; re-direct the ol' i/o
 22724                                  
 22725                                  DRIVE_CHECK:
 22726 00002D98 F606[279E]01            	test	byte [CHKDRV],1
 22727                                  	;test	byte [CHKDRV],FCHECKDRIVE 
 22728                                  				; did we wanna check those drives?
 22729 00002D9D 7411                    	jz	short NOCHECK
 22730 00002D9F A0[2A9E]                	mov	al,[PARM1]	; parse_file_descriptor results tell
 22731 00002DA2 0A06[2B9E]              	or	al,[PARM2]	; us whether those drives were OK
 22732 00002DA6 3CFF                    	cmp	al,-1
 22733 00002DA8 7506                    	jne	short NOCHECK
 22734                                  	;jmp	DRVBAD
 22735                                  	; 25/02/2023
 22736                                  DRVBAD:
 22737 00002DAA BA[4F92]                	mov	dx,baddrv_ptr
 22738 00002DAD E9F200                  	jmp	cerror
 22739                                  
 22740                                  ; The user may have omitted the space between the command and its arguments.
 22741                                  ; We need to copy the remainder of the user's command line into the buffer.
 22742                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
 22743                                  ; into the command line at 80.
 22744                                  
 22745                                  NOCHECK:
 22746 00002DB0 E85B02                  	call	cmd_copy
 22747                                  SWITCHECK:
 22748                                  	;test	byte [CHKDRV],2
 22749 00002DB3 F606[279E]02            	test	byte [CHKDRV],fSwitchAllowed 
 22750                                  				; Does the command take switches
 22751 00002DB8 7516                    	jnz	short REALWORK	; Yes, process the command
 22752 00002DBA E82F00                  	call	noswit		; No, check to see if any switches
 22753 00002DBD 7511                    	jnz	short REALWORK	; None, process the command
 22754                                  
 22755                                  	; MSDOS 6.0
 22756                                  	;mov	byte [msg_disp_class],2
 22757 00002DBF C606[F191]02            	mov	byte [msg_disp_class],parse_msg_class
 22758                                  				;AN000; set up parse error msg class
 22759 00002DC4 BA[F391]                	mov	dx,extend_buf_ptr	
 22760                                  				;AC000; get extended message pointer
 22761                                  	;mov	word [extend_buf_ptr],3
 22762 00002DC7 C706[F391]0300          	mov	word [extend_buf_ptr],BadSwt_Ptr
 22763                                  				;AN000; get "Invalid switch" message number
 22764 00002DCD E9D200                  	jmp	cerror		; Print error and chill out...
 22765                                  
 22766                                  	; 25/02/2023
 22767                                  	; MSDOS 3.3
 22768                                  	;mov	dx,BADPARMPTR
 22769                                  	;jmp	CERROR
 22770                                  
 22771                                  REALWORK:
 22772 00002DD0 FFD3                    	call	bx		; do some real work, at last
 22773                                  
 22774                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
 22775                                  ; otherwise, go get another command.
 22776                                  
 22777                                  CMD_DONE:
 22778 00002DD2 0E                      	push	cs		; g  restore data segment
 22779 00002DD3 1F                      	pop	ds		; g
 22780 00002DD4 1E                      	push	ds
 22781 00002DD5 8E1E[159E]              	mov	ds,[RESSEG]	; g  save data segment
 22782                                  	;cmp	byte [Call_Flag],1
 22783                                  				; G  Is a call in progress?
 22784 00002DD9 803E[4E02]01            	cmp	byte [Call_Flag],call_in_progress
 22785 00002DDE C606[4E02]00            	mov	byte [Call_Flag],0
 22786                                  				; G  Either way, reset flag
 22787 00002DE3 1F                      	pop	ds		; g  get data segment back
 22788 00002DE4 7403                    	jz	short INCALL	; G
 22789 00002DE6 E91BD3                  	jmp	TCOMMAND	; chill out...
 22790                                  INCALL:
 22791                                  	;jmp	DOCOM1
 22792                                  	; 11/06/2023
 22793                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 22794 00002DE9 E907D5                  	jmp	DOCOM0
 22795                                  
 22796                                  ; =============== S U B	R O U T	I N E =======================================
 22797                                  
 22798                                  	; 25/02/2023
 22799                                  noswit:
 22800 00002DEC 57                      	push	di		; Save di
 22801 00002DED BF8100                  	mov	di,81h		; di = ptr to command args
 22802 00002DF0 BE8000                  	mov	si,80h		; Get address of length of command args
 22803 00002DF3 AC                      	lodsb			; Load length
 22804 00002DF4 88C1                    	mov	cl,al		; Move length to cl
 22805 00002DF6 30ED                    	xor	ch,ch		; Zero ch
 22806 00002DF8 2EA0[199E]              	mov	al,[cs:SWITCHAR] ; al = switch character
 22807                                  	;cmp	al,0		; Turn off ZF
 22808                                  	; 25/02/2023
 22809 00002DFC 20C0                    	and	al,al
 22810 00002DFE F2AE                    	repne	scasb		; Scan for a switch character and return
 22811 00002E00 5F                      	pop	di		;  with ZF set if one was found
 22812 00002E01 C3                      	retn
 22813                                  
 22814                                  ; ---------------------------------------------------------------------------
 22815                                  
 22816                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 22817                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:29A6h
 22818                                  
 22819                                  EXTERNAL:
 22820 00002E02 E82602                  	call	test_append	; check to see if append installed
 22821 00002E05 7403                    	jz	short NOT_BARRYF
 22822                                  				; no - truly external command
 22823 00002E07 E9FCFE                  	jmp	APPEND_INTERNAL	; yes - go to Barryf code
 22824                                  
 22825                                  NOT_BARRYF:
 22826 00002E0A 2EC606[289E]00          	mov	byte [cs:FILTYP],0
 22827 00002E10 2E8A16[359E]            	mov	dl,[cs:SPECDRV]
 22828 00002E15 2E8816[D19F]            	mov	[cs:IDLEN],dl
 22829 00002E1A 2EC606[CBA0]00          	mov	byte [cs:ROM_CALL],0
 22830 00002E20 52                      	push	dx
 22831 00002E21 BA[D19F]                	mov	dx,IDLEN
 22832 00002E24 E8A6D6                  	call	ROM_SCAN
 22833 00002E27 5A                      	pop	dx
 22834                                  	;jnc	short POSTSAVE
 22835 00002E28 7305                    	jnc	short DO_SCAN
 22836 00002E2A 2EFE06[CBA0]            	inc	byte [cs:ROM_CALL]
 22837                                  	;jmp	short POSTSAVE
 22838                                  
 22839                                  	;nop
 22840                                  DO_SCAN:
 22841                                  POSTSAVE:
 22842 00002E2F BF[3D9D]                	mov	di,EXECPATH
 22843 00002E32 C60500                  	mov	byte [di],0	; Initialize to current directory
 22844                                  	
 22845 00002E35 2E803E[CBA0]00          	cmp	byte [cs:ROM_CALL],0
 22846                                  	;jz	short RESEARCH
 22847                                  	; 25/02/2023
 22848                                  	;jmp	short NEOEXECUTE
 22849 00002E3B 750F                    	jnz	short NEOEXECUTE	
 22850                                  
 22851                                  	;nop
 22852                                  RESEARCH:
 22853 00002E3D E87008                  	call	path_search	; find the mother (result in execpath)
 22854 00002E40 09C0                    	or	ax,ax		; did we find anything?
 22855                                  	;jz	short BADCOMJ45	; null means no (sob)
 22856                                  	; 25/02/2023
 22857 00002E42 7459                    	jz	short BADCOM
 22858 00002E44 83F804                  	cmp	ax,4		; 04H and 08H are .exe and .com
 22859                                  				; fuckin' sixteen-bit machine ought
 22860                                  	;jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
 22861                                  				; DISPLACEMENT!!
 22862                                  	;;jmp	short NEOEXECUTE
 22863                                  	;jmp	short EXECUTE	
 22864                                  	; 25/02/2023
 22865 00002E47 7D03                    	jnl	short EXECUTE ; jge
 22866                                  
 22867                                  	; 02H is .bat
 22868                                  
 22869                                  	;nop
 22870                                  BATCOMJ:
 22871 00002E49 E911DA                  	jmp	BATCOM
 22872                                  
 22873                                  	; 25/02/2023
 22874                                  ;BADCOMJ45:
 22875                                  	;jmp	short BADCOM
 22876                                  
 22877                                  	;nop
 22878                                  EXECUTE:
 22879                                  NEOEXECUTE:
 22880 00002E4C E87E02                  	call	IOSET
 22881                                  
 22882                                  ; MSDOS 6.0
 22883                                  ;M051
 22884                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
 22885                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
 22886                                  ;After a close, this would still leave one open active resulting in sharing
 22887                                  ;errors on subsequent opens of the redirected file.
 22888                                  
 22889                                  LH_EXECUTE:			;M051	
 22890 00002E4F 8E06[259E]              	mov	es,[TRAN_TPA]
 22891                                  	;mov	ah,DEALLOC ; 49h
 22892 00002E53 B449                    	mov	ah,49h
 22893 00002E55 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 22894                                  			; ES = segment address of area to be freed
 22895                                  				; Now running in "free" space
 22896 00002E57 8E06[159E]              	mov	es,[RESSEG]
 22897 00002E5B 26FE06[3702]            	inc	byte [es:ExtCom] ; Indicate external command
 22898 00002E60 26C606[3F02]00          	mov	byte [es:RestDir],0 
 22899                                  				; Since USERDIR1 is in transient, insure
 22900                                  				; this flag value for re-entry to COMMAND
 22901                                  	; MSDOS 6.0
 22902 00002E66 BE[3D9D]                	mov	si,EXECPATH	  ; offset TRANGROUP:EXECPATH	
 22903 00002E69 BF[0204]                	mov	di,SafePathBuffer ; offset RESGROUP:SAFEPATHBUFFER
 22904                                  	;mov	cx,LENMSGORPATHBUF
 22905 00002E6C B95000                  	mov	cx,80
 22906 00002E6F FC                      	cld
 22907 00002E70 F3A4                    	rep	movsb		; copy program pathname to resident
 22908                                  
 22909                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22910 00002E72 BF5C00                  	mov	di,FCB ; 5Ch
 22911 00002E75 89FE                    	mov	si,di
 22912                                  	;mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
 22913 00002E77 B152                    	mov	cl,82 ; 25/02/2023
 22914 00002E79 F3A5                    	rep	movsw		; Transfer parameters to resident header
 22915                                  	
 22916                                  	; 25/02/2023
 22917                                  	;mov	dx,EXECPATH  ; MSDOS 3.3
 22918                                  	; MSDOS 6.0 (& 5.0)
 22919                                  	;mov	dx,offset RESGROUP:SAFEPATHBUFFER
 22920 00002E7B BA[0204]                	mov	dx,SafePathBuffer
 22921 00002E7E 06                      	push	es
 22922 00002E7F 1F                      	pop	ds
 22923                                  
 22924                                  	;mov	bx,offset RESGROUP:EXEC_BLOCK
 22925 00002E80 BB[DC03]                	mov	bx,Exec_Block  ; = offset EnvirSeg
 22926                                  	;mov	ax,EXEC*256 ; 4B00h
 22927 00002E83 B8004B                  	mov	ax,4B00h
 22928                                  	;test	byte [ROM_CALL],-1 ; 0FFh ; MSDOS 3.3
 22929 00002E86 2EF606[CBA0]FF          	test	byte [cs:ROM_CALL],-1 ; MSDOS 6.0 (& 5.0)
 22930 00002E8C 7403                    	jz	short OK_EXEC
 22931 00002E8E E9B5D6                  	jmp	ROM_EXEC
 22932                                  
 22933                                  OK_EXEC:
 22934                                  
 22935                                  ; we are now running in free space. Anything we do from here on may get
 22936                                  ; trashed. Move the stack (also in free space) to allocated space because
 22937                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
 22938                                  
 22939 00002E91 8CC1                    	mov	cx,es
 22940 00002E93 8ED1                    	mov	ss,cx
 22941 00002E95 BC[D604]                	mov	sp,RStack
 22942                                  	; MSDOS 3.3
 22943                                  	;jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
 22944                                  	; 25/02/2023
 22945                                  	; MSDOS 6.0
 22946 00002E98 2EFF2E[1B9E]            	jmp	far [cs:EXEC_ADDR] ; Jmp to the EXEC in the resident
 22947                                  
 22948                                  ; ---------------------------------------------------------------------------
 22949                                  
 22950                                  	;  25/02/2023 - Retro DOS v4.0 COMMAND.COM
 22951                                  BADCOM:
 22952 00002E9D 0E                      	push	cs
 22953 00002E9E 1F                      	pop	ds
 22954 00002E9F BA[1692]                	mov	dx,BADNAM_PTR
 22955                                  cerror:		
 22956 00002EA2 E88026                  	call	std_eprintf
 22957 00002EA5 E95CD2                  	jmp	TCOMMAND
 22958                                  
 22959                                  ; =============== S U B	R O U T	I N E =======================================
 22960                                  
 22961                                  ; Prescan converts the input buffer into a canonicalized form.
 22962                                  ; All redirections and pipes are removed.
 22963                                  
 22964                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22965                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2A51h
 22966                                  
 22967                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 22968                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2FFBh
 22969                                  
 22970                                  PRESCAN:
 22971 00002EA8 31C9                    	xor	cx,cx
 22972 00002EAA 8E06[159E]              	mov	es,[RESSEG]
 22973 00002EAE BE[769C]                	mov	si,COMBUF+2
 22974 00002EB1 89F7                    	mov	di,si
 22975                                  COUNTQUOTES:
 22976 00002EB3 AC                      	lodsb			; get a byte
 22977 00002EB4 3C22                    	cmp	al,22h	; '"'	; is it a quote?
 22978 00002EB6 7504                    	jne	short COUNTEND	; no, try for end of road
 22979 00002EB8 FEC5                    	inc	ch		; bump count
 22980 00002EBA EBF7                    	jmp	short COUNTQUOTES
 22981                                  				; go get next char
 22982                                  COUNTEND:
 22983 00002EBC 3C0D                    	cmp	al,0Dh	; 13	; end of road?
 22984 00002EBE 75F3                    	jne	short COUNTQUOTES
 22985                                  				; no, go back for next char
 22986                                  	; 26/02/2023
 22987                                  	; MSDOS 5.0 (& 6.0)
 22988 00002EC0 51                      	push	cx		; save count
 22989 00002EC1 89FE                    	mov	si,di		; restore pointer to begining
 22990                                  KanjiScan:
 22991 00002EC3 AC                      	lodsb			; get a byte
 22992 00002EC4 E848FA                  	call	testkanj	; is it a leadin byte
 22993 00002EC7 740F                    	jz	short KanjiQuote
 22994                                  				; no, check for quotes
 22995 00002EC9 88C4                    	mov	ah,al		; save leadin
 22996 00002ECB AC                      	lodsb			; get trailing byte
 22997 00002ECC 3D2020                  	cmp	ax,2020h
 22998                                  	;cmp	ax,DB_SPACE	; is it Kanji space
 22999 00002ECF 75F2                    	jne	short KanjiScan	; no, go get next
 23000 00002ED1 C744FE2020              	mov	word [si-2],2020h
 23001                                  				; replace with spaces
 23002 00002ED6 EBEB                    	jmp	short KanjiScan	; go get next char
 23003                                  	
 23004                                  KanjiQuote:
 23005 00002ED8 3C22                    	cmp	al,22h	; '"'	; beginning of quoted string
 23006 00002EDA 750D                    	jne	short KanjiEnd	; no, check for end
 23007 00002EDC FECD                    	dec	ch		; drop count
 23008 00002EDE 74E3                    	jz	short KanjiScan	; if count is zero, no quoting
 23009                                  KanjiQuoteLoop:
 23010 00002EE0 AC                      	lodsb			; get next byte
 23011 00002EE1 3C22                    	cmp	al,22h	; '"'	; is it another quote
 23012 00002EE3 75FB                    	jne	short KanjiQuoteLoop
 23013                                  				; no, get another
 23014 00002EE5 FECD                    	dec	ch		; yes, drop count
 23015 00002EE7 EBDA                    	jmp	short KanjiScan	; go get next char
 23016                                  KanjiEnd:
 23017 00002EE9 3C0D                    	cmp	al,13 ; 0Dh	; end of line character?
 23018 00002EEB 75D6                    	jne	short KanjiScan	; go back to beginning
 23019 00002EED 59                      	pop	cx		; get back original count
 23020                                  	; 26/04/2023
 23021 00002EEE 89FE                    	mov	si,di		; restore pointer to beginning
 23022                                  	
 23023                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23024                                  PRESCANLP:
 23025 00002EF0 AC                      	lodsb
 23026                                  	; 26/02/2023
 23027 00002EF1 E81BFA                  	call	testkanj
 23028 00002EF4 740C                    	jz	short NOTKANJ6
 23029                                  	; MSDOS 6.0
 23030 00002EF6 8805                    	mov	[di],al
 23031 00002EF8 47                      	inc	di		; fake STOSB into DS
 23032 00002EF9 AC                      	lodsb			; grab second byte
 23033 00002EFA 8805                    	mov	[di],al		; fake stosb into DS
 23034 00002EFC FEC1                    	inc	cl
 23035 00002EFE FEC1                    	inc	cl
 23036 00002F00 EBEE                    	jmp	short PRESCANLP
 23037                                  
 23038                                  NOTKANJ6:
 23039                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23040 00002F02 3C22                    	cmp	al,'"'	; 22h	; " character
 23041 00002F04 7510                    	jne	short TRYGREATER
 23042 00002F06 FECD                    	dec	ch
 23043 00002F08 740C                    	jz	short TRYGREATER
 23044                                  QLOOP:
 23045 00002F0A 8805                    	mov	[di],al
 23046 00002F0C 47                      	inc	di
 23047 00002F0D FEC1                    	inc	cl
 23048 00002F0F AC                      	lodsb
 23049 00002F10 3C22                    	cmp	al,'"'		; " character
 23050 00002F12 75F6                    	jne	short QLOOP
 23051 00002F14 FECD                    	dec	ch
 23052                                  TRYGREATER:
 23053 00002F16 3C3E                    	cmp	al,'>' ; 3Eh
 23054                                  	;cmp	al,rabracket	; MSDOS 6.0 (& 5.0)
 23055                                  	;;cmp	al,[RABRACKET]	; MSDOS 3.3
 23056 00002F18 7557                    	jne	short NOOUT
 23057                                  
 23058                                  ; We have found a ">" char. We need to see if there is another ">"
 23059                                  ; following it.
 23060                                  
 23061 00002F1A 3804                    	cmp	[si],al
 23062 00002F1C 7506                    	jne	short NOAPPND
 23063 00002F1E AC                      	lodsb
 23064 00002F1F 26FE06[6302]            	inc	byte [es:Re_Out_App] ; Flag >>
 23065                                  NOAPPND:
 23066                                  ; Now we attempt to find the file name. First, scan off all whitespace
 23067                                  
 23068 00002F24 E807FC                  	call	scanoff
 23069                                  
 23070                                  	; 26/02/2023
 23071                                  	; MSDOS 6.0
 23072 00002F27 3C3C                    	cmp	al,'<' ; 3Ch
 23073                                  	;cmp	al,labracket	;AN040; was there no filename?
 23074 00002F29 7404                    	je	short REOUT_ERRSET
 23075                                  				;AN040; yes - set up error
 23076                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23077 00002F2B 3C0D                    	cmp	al,0Dh
 23078 00002F2D 750D                    	jnz	short GOTREOFIL
 23079                                  
 23080                                  ; There was no file present. Set us up at end-of-line.
 23081                                  
 23082                                  REOUT_ERRSET:			;AN040; set up for an error
 23083 00002F2F C6050D                  	mov	byte [di],0Dh	; Clobber first ">"
 23084 00002F32 26C706[6402]0900        	mov	word [es:Re_OutStr],9
 23085                                  				; Cause an error later
 23086 00002F39 E9A900                  	jmp	PRESCANEND
 23087                                  
 23088                                  GOTREOFIL:
 23089 00002F3C 57                      	push	di
 23090                                  	;mov	di,offset RESGROUP:RE_OUTSTR
 23091 00002F3D BF[6402]                	mov	di,Re_OutStr
 23092 00002F40 89FB                    	mov	bx,di
 23093 00002F42 06                      	push	es
 23094                                  
 23095                                  	; 26/02/2023
 23096                                  	; MSDOS 6.0
 23097                                  SETREOUTSTR:			; Get the output redirection name
 23098                                  				; MSKK06 07/14/89
 23099 00002F43 51                      	push	cx		; save cx
 23100 00002F44 B94D00                  	mov	cx,64+13	; CX = max string length
 23101                                  SETREOUTSTR_LOOP:
 23102 00002F47 AC                      	lodsb
 23103 00002F48 3C0D                    	cmp	al,0Dh
 23104 00002F4A 741A                    	je	short GOTRESTR_J
 23105 00002F4C E8E7FB                  	call	DELIM
 23106 00002F4F 7415                    	jz	short GOTRESTR_J
 23107 00002F51 3A06[199E]              	cmp	al,[SWITCHAR]
 23108 00002F55 740F                    	je	short GOTRESTR_J
 23109 00002F57 3C22                    	cmp	al,'"' ; 22h 	;AN033; Is the character a quote?
 23110 00002F59 7413                    	je	short PIPEERRSYNJ5_J
 23111                                  				;AN033; Yes - get out quick - or system crashes
 23112 00002F5B 3C3C                    	cmp	al,'<' ; 3Ch
 23113                                  	;cmp	al,labracket	;AN002; Is char for input redirection
 23114 00002F5D 7404                    	je	short ABRACKET_TERM
 23115                                  				;AN002; yes - end of string
 23116 00002F5F 3C3E                    	cmp	al,'>' ; 3Eh
 23117                                  	;cmp	al,rabracket	;AN002; Is char for output redirection
 23118 00002F61 7506                    	jne	short NO_ABRACKET
 23119                                  				;AN002; no - not end of string
 23120                                  ABRACKET_TERM:			;AN002; have end of string by < or >
 23121 00002F63 4E                      	dec	si		;AN002; back up over symbol
 23122 00002F64 B020                    	mov	al,20h ; BLANK	;AN002; show delimiter as char
 23123                                  GOTRESTR_J:
 23124 00002F66 59                      	pop	cx		; MSKK06 07/14/89
 23125 00002F67 EB58                    	jmp	short GOTRESTR	;AN002; go process it
 23126                                  NO_ABRACKET:			;AN002; NOT AT END OF STRING
 23127 00002F69 AA                      	stosb			; store it into resgroup
 23128 00002F6A E2DB                    	loop	SETREOUTSTR_LOOP
 23129                                  				; MSKK06 07/14/89
 23130 00002F6C EBF8                    	jmp	short GOTRESTR_J
 23131                                  PIPEERRSYNJ5_J:
 23132 00002F6E 59                      	pop	cx		; recover CX
 23133 00002F6F EB4B                    	jmp	short PIPEERRSYNJ5
 23134                                  
 23135                                  	; 26/02/2023
 23136                                  ;	; MSDOS 3.3
 23137                                  ;SETREOUTSTR_LOOP:		; Get the output redirection name
 23138                                  ;	lodsb
 23139                                  ;	cmp	al,0Dh
 23140                                  ;	jz	short GOTRESTR
 23141                                  ;	call	DELIM
 23142                                  ;	jz	short GOTRESTR
 23143                                  ;	cmp	al,[SWITCHAR]
 23144                                  ;	je	short GOTRESTR
 23145                                  ;	cmp	al,'"'
 23146                                  ;	jne	short NO_ABRACKET
 23147                                  ;	dec	ch
 23148                                  ;NO_ABRACKET:
 23149                                  ;	stosb
 23150                                  ;	jmp	short SETREOUTSTR_LOOP
 23151                                  
 23152                                  NOOUT:
 23153                                  	; 26/02/2023
 23154                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23155 00002F71 3C3C                    	cmp	al, '<' ; 3Ch
 23156                                  	;cmp	al,labracket	; MSDOS 6.0
 23157                                  	;;cmp	al,[LABRACKET]  ; MSDOS 3.3
 23158 00002F73 7523                    	jne	short CHKPIPE
 23159 00002F75 89F3                    	mov	bx,si		; Save loc of "<"
 23160 00002F77 E8B4FB                  	call	scanoff
 23161                                  	; MSDOS 6.0
 23162 00002F7A 3C3E                    	cmp	al,'>' ; 3Eh
 23163                                  	;cmp	al,rabracket	;AN040; was there no filename?
 23164 00002F7C 7404                    	je	short REIN_ERRSET ;AN040; yes - set up error
 23165                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23166 00002F7E 3C0D                    	cmp	al,0Dh
 23167 00002F80 750B                    	jne	short GOTREIFIL
 23168                                  REIN_ERRSET:			;AN040; set up for error
 23169 00002F82 C6050D                  	mov	byte [di],0Dh	; Clobber "<"
 23170 00002F85 C706[C09D]0900          	mov	word [RE_INSTR],9 
 23171                                  				; Cause an error later
 23172 00002F8B EB58                    	jmp	short PRESCANEND
 23173                                  GOTREIFIL:
 23174 00002F8D 57                      	push	di
 23175 00002F8E BF[C09D]                	mov	di,RE_INSTR
 23176 00002F91 89FB                    	mov	bx,di
 23177 00002F93 06                      	push	es
 23178 00002F94 0E                      	push	cs
 23179 00002F95 07                      	pop	es		; store in TRANGROUP
 23180                                  	; 26/04/2023
 23181                                  	;jmp	short SETREOUTSTR_LOOP  ; MSDOS 3.3 COMMAND.COM
 23182 00002F96 EBAB                    	jmp	short SETREOUTSTR ; MSDOS 5.0 (& 6.0) COMMAND.COM
 23183                                  				; Get the input redirection name
 23184                                  CHKPIPE:
 23185 00002F98 88C4                    	mov	ah,al
 23186                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23187 00002F9A 80FC7C                  	cmp	ah,'|' ; 7Ch
 23188                                  	;cmp	ah,ALTPIPECHR ; 7Ch
 23189                                  	;je	short ISPIPE3
 23190                                  	;; MSDOS 6.0
 23191                                  	;cmp	ah,'|' ; 7Ch
 23192                                  	;;cmp	al,vbar ; 7Ch
 23193                                  	;;;cmp	ah,[VBAR]  ; MSDOS 3.3
 23194 00002F9D 7539                    	jne	short CONTPRESCAN
 23195                                  ISPIPE3:
 23196                                  ; Only push the echo flag if we are entering the pipe for the first time.
 23197                                  
 23198 00002F9F 26803E[B502]00          	cmp	byte [es:PipeFlag],0
 23199 00002FA5 7505                    	jne	short NOECHOPUSH
 23200 00002FA7 26D026[3B02]            	shl	byte [es:EchoFlag],1 ; push echo state and turn it off
 23201                                  NOECHOPUSH:
 23202 00002FAC 26FE06[B502]            	inc	byte [es:PipeFlag]
 23203 00002FB1 E87AFB                  	call	scanoff
 23204 00002FB4 3C0D                    	cmp	al,0Dh
 23205 00002FB6 7404                    	je	short PIPEERRSYNJ5
 23206                                  	; 26/02/2023
 23207 00002FB8 3C7C                    	cmp	al,'|' ; 7Ch
 23208                                  	;cmp	al,ALTPIPECHR ; 7Ch
 23209                                  	;je	short PIPEERRSYNJ5
 23210                                  	;; MSDOS 6.0
 23211                                  	;cmp	al,'|' ; 7Ch
 23212                                  	;;cmp	al,vbar ; 7Ch
 23213                                  	;;;cmp	al,[VBAR]  ; MSDOS 3.3	
 23214 00002FBA 751C                    	jne	short CONTPRESCAN
 23215                                  
 23216                                  PIPEERRSYNJ5:
 23217 00002FBC 06                      	push	es
 23218 00002FBD 1F                      	pop	ds
 23219 00002FBE E99C02                  	jmp	PIPEERRSYN
 23220                                  
 23221                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
 23222                                  ; than just a : in the redir string.
 23223                                  
 23224                                  GOTRESTR:
 23225 00002FC1 86E0                    	xchg	ah,al
 23226 00002FC3 B03A                    	mov	al,':' ; 3Ah
 23227 00002FC5 29FB                    	sub	bx,di		; compute negative of number of chars
 23228 00002FC7 83FBFF                  	cmp	bx,-1		; is there just a :?
 23229 00002FCA 7407                    	je	short NOTRAILCOL ; yep, don't change
 23230 00002FCC 263845FF                	cmp	[es:di-1],al	; Trailing ':' OK on devices
 23231 00002FD0 7501                    	jne	short NOTRAILCOL
 23232 00002FD2 4F                      	dec	di		; Back up over trailing ':'
 23233                                  NOTRAILCOL:
 23234 00002FD3 30C0                    	xor	al,al
 23235 00002FD5 AA                      	stosb			; NUL terminate the string
 23236 00002FD6 07                      	pop	es
 23237 00002FD7 5F                      	pop	di		; Remember the start
 23238                                  CONTPRESCAN:
 23239 00002FD8 8825                    	mov	[di],ah		; "delete" the redirection string
 23240 00002FDA 47                      	inc	di
 23241 00002FDB 80FC0D                  	cmp	ah,0Dh
 23242 00002FDE 7405                    	je	short PRESCANEND
 23243 00002FE0 FEC1                    	inc	cl
 23244 00002FE2 E90BFF                  	jmp	PRESCANLP
 23245                                  PRESCANEND:
 23246 00002FE5 26803E[B502]00          	cmp	byte [es:PipeFlag],0
 23247 00002FEB 7414                    	jz	short ISNOPIPE
 23248                                  
 23249                                  	; 11/06/2023
 23250                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:314Ah
 23251                                  	;mov	di,48Ah		; PipeStr ; RESGROUP:EndInit+160
 23252                                  	;mov	[es:488h],di	; [es:PipePtr],di
 23253                                  				; (RESGROUP:EndInit+158)
 23254                                  	; 26/02/2023
 23255                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA0h
 23256                                  	;;mov	di,3C0h		; offset RESGROUP:PIPESTR
 23257                                  	;;			; (EndInit+160]
 23258                                  	;mov	di,offset RESGROUP:PIPESTR
 23259 00002FED BF[5703]                	mov	di,PipeStr	; RESGROUP:EndInit+160
 23260                                  
 23261                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA3h
 23262                                  	;;mov	[es:3BEh],di	; [es:EndInit+158]
 23263 00002FF0 26893E[5503]            	mov	[es:PipePtr],di	; RESGROUP:EndInit+158
 23264                                  	
 23265 00002FF5 BE[769C]                	mov	si,COMBUF+2
 23266 00002FF8 E833FB                  	call	scanoff
 23267                                  PIPESETLP:			; Transfer the pipe into the resident
 23268 00002FFB AC                      	lodsb			; pipe buffer
 23269 00002FFC AA                      	stosb
 23270 00002FFD 3C0D                    	cmp	al,0Dh
 23271 00002FFF 75FA                    	jnz	short PIPESETLP
 23272                                  ISNOPIPE:
 23273 00003001 880E[759C]              	mov	[COMBUF+1],cl
 23274 00003005 26803E[B502]00          	cmp	byte [es:PipeFlag],0
 23275 0000300B 0E                      	push	cs
 23276 0000300C 07                      	pop	es
 23277 0000300D C3                      	retn
 23278                                  
 23279                                  ; =============== S U B	R O U T	I N E =======================================
 23280                                  
 23281                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23282                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2BC1h
 23283                                  cmd_copy:
 23284 0000300E BE[769C]                	mov	si,COMBUF+2
 23285 00003011 E81AFB                  	call	scanoff		; advance past separators...
 23286 00003014 0336[A6A0]              	add	si,[PathPos]
 23287 00003018 BF8100                  	mov	di,81h
 23288 0000301B 31C9                    	xor	cx,cx
 23289                                  cmdcopy:
 23290 0000301D AC                      	lodsb
 23291 0000301E AA                      	stosb
 23292 0000301F 3C0D                    	cmp	al,0Dh
 23293 00003021 7403                    	je	short copy_done
 23294 00003023 41                      	inc	cx
 23295 00003024 EBF7                    	jmp	short cmdcopy
 23296                                  copy_done:
 23297 00003026 880E8000                	mov	[80h],cl
 23298 0000302A C3                      	retn
 23299                                  
 23300                                  ; =============== S U B	R O U T	I N E =======================================
 23301                                  
 23302                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23303                                  test_append:
 23304 0000302B BB[749C]                	mov	bx,COMBUF	; barry can address
 23305 0000302E BE[D19F]                	mov	si,IDLEN	; address command name, DS already set 	
 23306 00003031 BAFFFF                  	mov	dx,-1
 23307 00003034 B800AE                  	mov	ax,0AE00h
 23308 00003037 CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal 
 23309                                  			; - INSTALLABLE	COMMAND	- INSTALL CHECK
 23310                                  			; DX = FFFFh,[BX -> command line
 23311                                  			; Return: AL = FFh if this command is a TSR extension 
 23312                                  			;		   to COMMAND.COM
 23313                                  			; AL = 00h if the command should be executed as	usual
 23314                                  	;cmp	al,0
 23315 00003039 08C0                    	or	al,al ; 25/02/2023
 23316 0000303B C3                      	retn
 23317                                  
 23318                                  	; 25/02/2023
 23319                                  	; INT 2Fh
 23320                                  	; 	AX = AE00h
 23321                                  	; entry:
 23322                                  	; 	DX = magic value FFFFh
 23323                                  	; 	CH = FFh
 23324                                  	; 	CL = length of command line tail
 23325                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 23326                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 23327                                  	; return:
 23328                                  	;	AL = FFh if this command is a TSR extension to COMMAND.COM
 23329                                  	;	AL = 00h if the command should be executed as usual
 23330                                  	;
 23331                                  	; Format of COMMAND.COM command line buffer:
 23332                                  	;	Offset  Size    Description
 23333                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 23334                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 23335                                  	;	N BYTEs command line text, terminated by 0Dh
 23336                                  	;
 23337                                  	; Format of command name buffer:
 23338                                  	;	Offset  Size    Description
 23339                                  	;	00h     BYTE    length of command name
 23340                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 23341                                  
 23342                                  ;============================================================================
 23343                                  ; TMISC2.ASM, MSDOS 6.0, 1991
 23344                                  ;============================================================================
 23345                                  ; 05/10/2018 - Retro DOS v3.0
 23346                                  
 23347                                  ;	More misc routines
 23348                                  
 23349                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
 23350                                  
 23351                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23352                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2BEFh
 23353                                  
 23354                                  ; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23355                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 3199h
 23356                                  
 23357                                  ; =============== S U B	R O U T	I N E =======================================
 23358                                  
 23359                                  SETPATH:
 23360                                  
 23361                                  ; ENTRY PathPos = ptr to string
 23362                                  ;       PathCnt = length of string
 23363                                  ;
 23364                                  ; EXIT  PathPos = ptr to string after pathname
 23365                                  ;       PathCnt = length of rest of string
 23366                                  ;       DX = ptr to pathname in string, made ASCIIZ
 23367                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
 23368                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
 23369                                  ;
 23370                                  ;       A null character is dropped at the end of the pathname. If the
 23371                                  ;       character in that spot previously was CR, it is copied into the
 23372                                  ;       following byte. So there must be at least two two character 
 23373                                  ;       positions in the buffer following the pathname.
 23374                                  
 23375                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23376                                  	
 23377                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23378                                  	; MSDOS 6.0
 23379                                  	;mov	ax,[PathCnt]	;AC000; get length of string
 23380                                  	;mov	si,[PathPos]	;AC000; get start of source buffer
 23381                                  
 23382                                  	; 26/02/2023
 23383                                  	; MSDOS 3.3
 23384                                  	;mov	si,80h
 23385                                  	;lodsb
 23386                                  	;xor	ah,ah
 23387                                  	;mov	[PATCNT],ax
 23388                                  	;mov	[PATHPOS],si
 23389                                  GETPATH:
 23390                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23391 0000303C C606[D4A0]00            	mov	byte [DestInfo],0
 23392 00003041 C606[D0A0]00            	mov	byte [DestIsDir],0
 23393 00003046 8B36[A6A0]              	mov	si,[PathPos]	; SI = ptr to string
 23394 0000304A 8B0E[A4A0]              	mov	cx,[PathCnt]	; CX = string length
 23395 0000304E 89F2                    	mov	dx,si		; DX = ptr to string
 23396 00003050 E34D                    	jcxz	PATHDONE	; string length is zero, we're done
 23397 00003052 51                      	push	cx		; save string length
 23398 00003053 56                      	push	si		; save ptr to string
 23399 00003054 E875FC                  	call	SWITCH
 23400                                  
 23401                                  ;       After Switch, SI has been scanned past any switches, and
 23402                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
 23403                                  
 23404 00003057 A3[A8A0]                	mov	[PathSw],ax	; PathSw = switch occurrence mask
 23405 0000305A 5B                      	pop	bx		; BX = ptr to original string
 23406 0000305B 29F3                    	sub	bx,si		; BX = -(# chars scanned by Switch)
 23407 0000305D 59                      	pop	cx		; CX = string length
 23408 0000305E 01D9                    	add	cx,bx		; CX = string length from current SI
 23409 00003060 89F2                    	mov	dx,si		; DX = ptr to current string
 23410                                  SKIPPATH:
 23411                                  	; 26/02/2023
 23412                                  	; MSDOS 6.0
 23413 00003062 C606[66A2]00            	mov	byte [KPARSE],0
 23414                                  SKIPPATH2:
 23415 00003067 E336                    	jcxz	PATHDONE	; string length is zero, we're done
 23416 00003069 49                      	dec	cx		; CX = length left after next char
 23417 0000306A AC                      	lodsb			; AL = next char of string
 23418                                  				; SI = ptr to char after this one
 23419                                  	; 26/02/2023
 23420 0000306B E8A1F8                  	call	testkanj
 23421 0000306E 7408                    	jz	short TESTPPSEP
 23422 00003070 49                      	dec	cx
 23423 00003071 46                      	inc	si
 23424 00003072 FE06[66A2]              	inc	byte [KPARSE]
 23425 00003076 EBEF                    	jmp	short SKIPPATH2
 23426                                  TESTPPSEP:
 23427 00003078 E841FB                  	call	pathchrcmp	; compare AL to path delimiter char
 23428 0000307B 7504                    	jnz	short TESTPMETA	; it's not a path delim
 23429 0000307D FE06[D0A0]              	inc	byte [DestIsDir]
 23430                                  				; DestIsDir = 1, signalling path char
 23431                                  TESTPMETA:
 23432 00003081 3C3F                    	cmp	al,'?'
 23433 00003083 7505                    	jne	short TESTPSTAR	; char is not '?'
 23434 00003085 800E[D4A0]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 23435                                  TESTPSTAR:
 23436 0000308A 3C2A                    	cmp	al,'*'
 23437                                  	;cmp	al,[STAR] ; MSDOS 3.3	
 23438 0000308C 7505                    	jne	short TESTPDELIM ; char is not '*'
 23439 0000308E 800E[D4A0]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 23440                                  TESTPDELIM:
 23441 00003093 E8A0FA                  	call	DELIM		; compare AL to all delimiters
 23442 00003096 7406                    	jz	short PATHDONEDEC ; delimiter found, back up & leave
 23443 00003098 3A06[199E]              	cmp	al,[SWITCHAR]
 23444 0000309C 75C4                    	jne	short SKIPPATH	; char isn't switch, go get next char
 23445                                  PATHDONEDEC:
 23446 0000309E 4E                      	dec	si		; SI = ptr to char after pathname
 23447                                  PATHDONE:
 23448 0000309F 30C0                    	xor	al,al		; AL = NULL
 23449 000030A1 8604                    	xchg	al,[si]		; place NULL after pathname
 23450 000030A3 46                      	inc	si		; SI = ptr to byte after NULL
 23451 000030A4 3C0D                    	cmp	al,0Dh		; were we at end of line?
 23452 000030A6 7502                    	jne	short NOPSTORE	; not EOL, finish up
 23453 000030A8 8804                    	mov	[si],al		; save EOL after NULL
 23454                                  NOPSTORE:
 23455 000030AA 8936[A6A0]              	mov	[PathPos],si	; PathPos = ptr to char after NULL
 23456 000030AE 890E[A4A0]              	mov	[PathCnt],cx	; PathCnt = length of string left
 23457                                  SETPATH_RETN:
 23458 000030B2 C3                      	retn
 23459                                  
 23460                                  ; ---------------------------------------------------------------------------
 23461                                  
 23462                                  PGETARG:
 23463 000030B3 BE8000                  	mov	si,80h
 23464 000030B6 AC                      	lodsb
 23465 000030B7 08C0                    	or	al,al
 23466 000030B9 74F7                    	jz	short SETPATH_RETN
 23467 000030BB E80300                  	call	PSCANOFF
 23468 000030BE 3C0D                    	cmp	al,0Dh
 23469 000030C0 C3                      	retn
 23470                                  
 23471                                  ; ---------------------------------------------------------------------------
 23472                                  
 23473                                  PSCANOFF:
 23474 000030C1 AC                      	lodsb
 23475 000030C2 E871FA                  	call	DELIM
 23476 000030C5 7504                    	jnz	short PSCANOFFD
 23477 000030C7 3C3B                    	cmp	al,';' ; 3Bh
 23478 000030C9 75F6                    	jne	short PSCANOFF	; ';' is not a delimiter
 23479                                  PSCANOFFD:
 23480 000030CB 4E                      	dec	si		; Point to first non-delimiter
 23481 000030CC C3                      	retn
 23482                                  
 23483                                  ; =============== S U B	R O U T	I N E =======================================
 23484                                  
 23485                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23486                                  IOSET:
 23487                                  	; ALL REGISTERS PRESERVED
 23488 000030CD 1E                      	push	ds
 23489 000030CE 52                      	push	dx
 23490 000030CF 50                      	push	ax
 23491 000030D0 53                      	push	bx
 23492 000030D1 51                      	push	cx
 23493 000030D2 2E8E1E[159E]            	mov	ds,[cs:RESSEG]
 23494 000030D7 803E[B502]00            	cmp	byte [PipeFlag],0
 23495 000030DC 750D                    	jne	short NOREDIR
 23496 000030DE F606[4802]FF            	test	byte [IfFlag],0FFh
 23497 000030E3 7506                    	jnz	short NOREDIR
 23498 000030E5 E88C00                  	call	TESTDOREIN
 23499 000030E8 E80600                  	call	TESTDOREOUT
 23500                                  NOREDIR:
 23501 000030EB 59                      	pop	cx
 23502 000030EC 5B                      	pop	bx
 23503 000030ED 58                      	pop	ax
 23504 000030EE 5A                      	pop	dx
 23505 000030EF 1F                      	pop	ds
 23506                                  IOSET_RETN:	; 06/08/2024
 23507 000030F0 C3                      	retn
 23508                                  
 23509                                  ; =============== S U B	R O U T	I N E =======================================
 23510                                  
 23511                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23512                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CF3h
 23513                                  	; 06/08/2024
 23514                                  TESTDOREOUT:
 23515 000030F1 803E[6402]00            	cmp	byte [Re_OutStr],0
 23516                                  	;je	short NOREOUT  ; MSDOS 3.3
 23517                                  	; 26/02/2023
 23518                                  	;jne	short REOUTEXISTS
 23519                                  	;jmp	NOREOUT
 23520                                  	; 06/08/2024
 23521 000030F6 74F8                    	jz	short IOSET_RETN
 23522                                  REOUTEXISTS:
 23523 000030F8 803E[6302]00            	cmp	byte [Re_Out_App],0
 23524 000030FD 745D                    	je	short REOUTCRT
 23525                                  
 23526 000030FF BA[6402]                	mov	dx,Re_OutStr
 23527                                  
 23528                                  	; 26/02/2023
 23529                                  	; MSDOS 6.0
 23530                                  	;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
 23531 00003102 B8023D                  	mov	ax,3D02h
 23532                                  	; MSDOS 3.3
 23533                                  	;mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
 23534                                  
 23535                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23536 00003105 50                      	push	ax
 23537 00003106 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 23538                                  			; DS:DX	-> ASCIZ filename
 23539                                  			; AL = access mode
 23540                                  			; 1 - write
 23541 00003108 5B                      	pop	bx
 23542 00003109 724B                    	jc	short OpenWriteError
 23543                                  
 23544                                  	; 26/02/2023
 23545                                  	; MSDOS 6.0
 23546 0000310B 89C3                    	mov	bx,ax
 23547                                  	;mov	ax,IOCTL<<8		;AN035; Get attributes of handle
 23548 0000310D B80044                  	mov	ax,4400h
 23549 00003110 CD21                    	int	21h			;AN035;
 23550                                  			; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 23551                                  			; BX = file or device handle
 23552 00003112 F6C280                  	test	dl,80h
 23553                                  	;test	dl,devid_ISDEV		;AN035; Is it a device?
 23554 00003115 7554                    	jnz	short SET_REOUT		;AN035; Yes, don't read from it
 23555                                  	
 23556                                  	;mov	ax,(LSEEK SHL 8) OR 2
 23557 00003117 B80242                  	mov	ax,4202h
 23558 0000311A B9FFFF                  	mov	cx,-1			;AC011; MOVE TO EOF -1
 23559 0000311D 89CA                    	mov	dx,cx			;AC011;
 23560 0000311F CD21                    	int	21h
 23561                                  			; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 23562                                  			; AL = method: offset from end of file
 23563 00003121 0E                      	push	cs			;AN011; Get transient seg to DS
 23564 00003122 1F                      	pop	ds			;AN011;
 23565                                  
 23566                                  	;mov	ax,(READ SHL 8) 	;AN011; Read one byte from the
 23567 00003123 B8003F                  	mov	ax,3F00h
 23568 00003126 B90100                  	mov	cx,1			;AN011;  file into one_char_val
 23569 00003129 BA[C8A0]                	mov	dx,One_Char_Val		;AN011;
 23570 0000312C CD21                    	int	21h			;AN011;
 23571                                  			; DOS - 2+ - READ FROM FILE WITH HANDLE
 23572                                  			; BX = file handle, CX = number of bytes to read
 23573                                  			; DS:DX -> buffer
 23574 0000312E 7226                    	jc	short OpenWriteError	;AN011; If error, exit
 23575 00003130 39C8                    	cmp	ax,cx			;AN017; Did we read 1 byte?
 23576 00003132 7517                    	jnz	short reout_0_length	;AN017; No - file must be 0 length
 23577                                  
 23578 00003134 803E[C8A0]1A            	cmp	byte [One_Char_Val],1Ah	;AN011; Was char an eof mark?
 23579 00003139 8E1E[159E]              	mov	ds,[RESSEG]		;AN011; Get resident segment back
 23580 0000313D 752C                    	jne	short SET_REOUT		;AN011; No, just continue
 23581                                  
 23582                                  	;mov	ax,(LSEEK<<8)|1		;AN011; EOF mark found
 23583 0000313F B80142                  	mov	ax,4201h
 23584 00003142 B9FFFF                  	mov	cx,-1			;AN011; LSEEK back one byte
 23585                                  setreout_p:	; 26/02/2023
 23586 00003145 89CA                    	mov	dx,cx			;AN011;
 23587 00003147 CD21                    	int	21h			;AN011;
 23588 00003149 EB20                    	jmp	short SET_REOUT
 23589                                  reout_0_length: 			;AN017; We have a 0 length file
 23590                                  	; ds = cs ; 26/02/2023
 23591                                  	;mov	ds,[cs:RESSEG] ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2D50h
 23592                                  					;AN017; Get resident segment back
 23593                                  	; 26/02/2023
 23594 0000314B 8E1E[159E]              	mov	ds,[RESSEG]
 23595                                  	;mov	ax,(LSEEK SHL 8)	;AN017; Move to beginning of file
 23596 0000314F B80042                  	mov	ax,4200h
 23597 00003152 31C9                    	xor	cx,cx			;AN017; Offset is 0
 23598                                  	;mov	dx,cx			;AN017;
 23599                                  	;int	21h			;AN017;
 23600                                  	;jmp	short SET_REOUT 	;AN017; now finish setting up redirection
 23601                                  	; 26/02/2023
 23602 00003154 EBEF                    	jmp	short setreout_p
 23603                                  
 23604                                  	; 26/02/2023
 23605                                  	; MSDOS 3.3
 23606                                  	;xor	dx,dx
 23607                                  	;xor	cx,cx
 23608                                  	;mov	bx,ax
 23609                                  	;mov	ax,(LSEEK<<8)|2 ; 4202h
 23610                                  	;int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 23611                                  	;		; AL = method: offset from end of file
 23612                                  	;jmp	short SET_REOUT
 23613                                  
 23614                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23615                                  OpenWriteError:
 23616                                  	;cmp	ax,5
 23617 00003156 83F805                  	cmp	ax,ERROR_ACCESS_DENIED
 23618 00003159 F9                      	stc
 23619                                  	;;je	short REDIRERR ; MSDOS 3.3
 23620                                  	; 26/02/2023
 23621                                  	;jnz	short REOUTCRT
 23622                                  	;jmp	REDIRERR
 23623 0000315A 743B                    	je	short REDIRERR
 23624                                  
 23625                                  REOUTCRT:
 23626 0000315C BA[6402]                	mov	dx,Re_OutStr
 23627 0000315F 31C9                    	xor	cx,cx
 23628                                  	;mov	ah,CREAT ; 3Ch
 23629 00003161 B43C                    	mov	ah,3Ch
 23630 00003163 50                      	push	ax
 23631 00003164 CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 23632                                  			; CX = attributes for file
 23633                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 23634 00003166 5B                      	pop	bx
 23635                                  	;jc	short REDIRERR ; MSDOS 3.3
 23636                                  	; 26/02/2023
 23637                                  	;jnc	short NOREDIRERR
 23638                                  	;jmp	REDIRERR
 23639 00003167 722E                    	jc	short REDIRERR
 23640                                  
 23641                                  NOREDIRERR:
 23642 00003169 89C3                    	mov	bx,ax
 23643                                  SET_REOUT:
 23644                                  
 23645                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
 23646                                  ; spot. We invalidate the new JFN we got.
 23647                                  
 23648 0000316B B0FF                    	mov	al,0FFh
 23649                                  	;xchg	al,[bx+18h]
 23650 0000316D 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 23651 00003170 A21900                  	mov	[PDB.JFN_TABLE+1],al
 23652                                  	; 06/08/2024
 23653                                  NOREOUT:
 23654                                  ;IOSET_RETN:	; 17/04/2023
 23655 00003173 C3                      	retn
 23656                                  
 23657                                  ; =============== S U B	R O U T	I N E =======================================
 23658                                  
 23659                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23660                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 23661                                  	; 06/08/2024
 23662                                  TESTDOREIN:
 23663 00003174 2E803E[C09D]00          	cmp	byte [cs:RE_INSTR],0
 23664                                  	;jz	short IOSET_RETN
 23665                                  	; 06/08/2024
 23666 0000317A 74F7                    	jz	short NOREOUT
 23667 0000317C 1E                      	push	ds
 23668 0000317D 0E                      	push	cs
 23669 0000317E 1F                      	pop	ds
 23670 0000317F BA[C09D]                	mov	dx,RE_INSTR
 23671                                  	;mov	ax,OPEN*256 ; 3D00h
 23672 00003182 B8003D                  	mov	ax,3D00h
 23673 00003185 89C3                    	mov	bx,ax
 23674 00003187 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 23675                                  			; DS:DX	-> ASCIZ filename
 23676                                  			; AL = access mode
 23677                                  			; 0 - read
 23678 00003189 1F                      	pop	ds
 23679                                  
 23680 0000318A 720B                    	jc	short REDIRERR
 23681                                  
 23682 0000318C 89C3                    	mov	bx,ax
 23683 0000318E B0FF                    	mov	al,0FFh
 23684                                  
 23685                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
 23686                                  ; spot. We invalidate the new JFN we got.
 23687                                  
 23688                                  	;xchg	al,[bx+18h]
 23689 00003190 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 23690 00003193 A21800                  	mov	[PDB.JFN_TABLE],al
 23691 00003196 C3                      	retn
 23692                                  
 23693                                  ; ---------------------------------------------------------------------------
 23694                                  
 23695                                  ; We had some kind of error on the redirection. Figure out what the
 23696                                  ; appropriate message should be; BX has the system call that failed
 23697                                  
 23698                                  REDIRERR:
 23699 00003197 0E                      	push	cs
 23700 00003198 1F                      	pop	ds
 23701 00003199 E82E00                  	call	TriageError  ; MSDOS 6.0
 23702                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 23703                                  
 23704                                  ; At this point, we have recognized the network-generated access denied error.
 23705                                  ; The correct message is in DX
 23706                                  
 23707 0000319C 83F841                  	cmp	ax,65
 23708 0000319F 7408                    	je	short _CERRORJ	;AC000; just issue message returned
 23709 000031A1 80FF3D                  	cmp	bh,OPEN ; 3Dh
 23710 000031A4 7406                    	je	short OpenError
 23711 000031A6 BA[0D92]                	mov	dx,FULLDIR_PTR
 23712                                  _CERRORJ:
 23713 000031A9 E9F6FC                  	jmp	cerror
 23714                                  
 23715                                  OpenError:
 23716                                  ; The system call was an OPEN. Report either file not found or path not found.
 23717                                  
 23718                                  	; 26/02/2023
 23719                                  	; MSDOS 6.0
 23720                                  	;mov	byte [cs:msg_disp_class],1
 23721 000031AC 2EC606[F191]01          	mov	byte [cs:msg_disp_class],ext_msg_class
 23722                                  				;AN000; set up extended error msg class
 23723 000031B2 BA[F391]                	mov	dx,extend_buf_ptr
 23724                                  				;AC000; get extended message pointer
 23725 000031B5 2EA3[F391]              	mov	[cs:extend_buf_ptr],ax
 23726                                  				;AN000; get message number in control block
 23727 000031B9 E9E6FC                  	jmp	cerror
 23728                                  
 23729                                  	; 26/02/2023
 23730                                  	; MSDOS 3.3
 23731                                  	;mov	dx,FNOTFOUNDPTR
 23732                                  	;;cmp	ax,2
 23733                                  	;cmp	ax,ERROR_FILE_NOT_FOUND
 23734                                  	;je	short _CERRORJ
 23735                                  	;mov	dx,ACCDENPTR
 23736                                  	;;cmp	ax,5 ; Access denied error
 23737                                  	;cmp	ax,ERROR_ACCESS_DENIED
 23738                                  	;je	short _CERRORJ
 23739                                  	;	; ERROR_PATH_NOT_FOUND
 23740                                  	;mov	dx,PNOTFOUNDPTR
 23741                                  	;jmp	CERROR
 23742                                  
 23743                                  ; =============== S U B	R O U T	I N E =======================================
 23744                                  
 23745                                  ; Compute length of string (including NUL) in DS:SI into CX. Change no other
 23746                                  ; registers
 23747                                  
 23748                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 23749                                  dstrlen:
 23750 000031BC 50                      	push	ax
 23751 000031BD 31C9                    	xor	cx,cx
 23752 000031BF FC                      	cld
 23753                                  dloop:
 23754 000031C0 AC                      	lodsb
 23755 000031C1 41                      	inc	cx
 23756 000031C2 08C0                    	or	al,al
 23757 000031C4 75FA                    	jnz	short dloop
 23758 000031C6 29CE                    	sub	si,cx
 23759 000031C8 58                      	pop	ax
 23760                                  TRIAGEERR_RETN:
 23761 000031C9 C3                      	retn
 23762                                  
 23763                                  ; =============== S U B	R O U T	I N E =======================================
 23764                                  
 23765                                  ;Break	<Extended error support>
 23766                                  
 23767                                  TriageError:  ; MSDOS 6.0
 23768                                  
 23769                                  ; TriageError will examine the return from a carry-set system call and
 23770                                  ; return the correct error if applicable.
 23771                                  ;
 23772                                  ;   Inputs:	outputs from a carry-settable system call
 23773                                  ;		No system calls may be done in the interrim
 23774                                  ;   Outputs:	If carry was set on input
 23775                                  ;		   carry set on output
 23776                                  ;		   DX contains trangroup offset to printf message
 23777                                  ;		else
 23778                                  ;		   No registers changed
 23779                                  
 23780                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
 23781                                  
 23782                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23783                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2D92h
 23784                                  
 23785                                  ; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23786                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 333Ch
 23787                                  
 23788                                  GET_EXT_ERR_NUMBER:  ; MSDOS 3.3
 23789 000031CA 73FD                    	jnc	short TRIAGEERR_RETN ; no carry => do nothing...
 23790 000031CC 9C                      	pushf
 23791 000031CD 53                      	push	bx
 23792 000031CE 51                      	push	cx
 23793 000031CF 56                      	push	si
 23794 000031D0 57                      	push	di
 23795 000031D1 55                      	push	bp
 23796 000031D2 06                      	push	es
 23797 000031D3 1E                      	push	ds
 23798 000031D4 50                      	push	ax
 23799 000031D5 52                      	push	dx
 23800 000031D6 B459                    	mov	ah,59h
 23801                                  	;mov	ah,GETEXTENDEDERROR
 23802 000031D8 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 23803                                  			; BX = version code (0000h for DOS 3.x)
 23804 000031DA 59                      	pop	cx
 23805 000031DB 5B                      	pop	bx		; restore original AX
 23806 000031DC BA[1992]                	mov	dx,ACCDEN_PTR
 23807 000031DF 83F841                  	cmp	ax,65		; network access denied?
 23808 000031E2 7404                    	je	short NoMove	; Yes, return it.
 23809 000031E4 89D8                    	mov	ax,bx
 23810 000031E6 89CA                    	mov	dx,cx
 23811                                  NoMove:
 23812 000031E8 1F                      	pop	ds
 23813 000031E9 07                      	pop	es
 23814 000031EA 5D                      	pop	bp
 23815 000031EB 5F                      	pop	di
 23816 000031EC 5E                      	pop	si
 23817 000031ED 59                      	pop	cx
 23818 000031EE 5B                      	pop	bx
 23819 000031EF 9D                      	popf
 23820 000031F0 C3                      	retn
 23821                                  
 23822                                  ; =============== S U B	R O U T	I N E =======================================
 23823                                  
 23824                                  	; Far call from resident portion/segment of COMMAND.COM
 23825                                  
 23826                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
 23827                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DB9h
 23828                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 3363h
 23829                                  
 23830                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23831                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23832                                  Triage_Init:
 23833 000031F1 E8D6FF                  	call	TriageError	 ; MSDOS 6.0
 23834                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 23835 000031F4 CB                      	retf
 23836                                  
 23837                                  ; =============== S U B	R O U T	I N E =======================================
 23838                                  
 23839                                  ; MSDOS 6.0
 23840                                  
 23841                                  ; ****************************************************************
 23842                                  ; *
 23843                                  ; * ROUTINE:	 MOVE_TO_SRCBUF
 23844                                  ; *
 23845                                  ; * FUNCTION:	 Move ASCIIZ string from DS:SI to SRCBUF.  Change
 23846                                  ; *		 terminating 0 to 0dH.	Set PATHCNT to length of
 23847                                  ; *		 string.  Set PATHPOS to start of SRCBUF.
 23848                                  ; *
 23849                                  ; * INPUT:	 DS:SI points to ASCIIZ string
 23850                                  ; *		 ES    points to TRANGROUP
 23851                                  ; *
 23852                                  ; * OUTPUT:	 SRCBUF filled in with string terminated by 0dH
 23853                                  ; *		 PATHCNT set to length of string
 23854                                  ; *		 PATHPOS set to start of SRCBUF
 23855                                  ; *		 CX,AX	 changed
 23856                                  ; *
 23857                                  ; ****************************************************************
 23858                                  
 23859                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23860                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 23861                                  Move_To_SrcBuf:
 23862 000031F5 56                      	push	si			;AN000;  save si,di
 23863 000031F6 57                      	push	di			;AN000;
 23864 000031F7 51                      	push	cx			;AN000;
 23865 000031F8 BF[38A1]                	mov	di,SrcBuf		;AN000;  set ES:DI to srcbuf
 23866 000031FB 31C9                    	xor	cx,cx			;AN000; clear cx for counint
 23867 000031FD 89C8                    	mov	ax,cx			;AN000; clear ax
 23868 000031FF 57                      	push	di			;AN000; save start of srcbuf
 23869 00003200 AC                      	lodsb				;AN000; get a character from DS:SI
 23870                                  mts_get_chars:				;AN000;
 23871                                  	;cmp	al,0			;AN000; was it a null char?
 23872 00003201 20C0                    	and 	al,al ; al = 0 ?
 23873 00003203 7405                    	jz	short mts_end_string	;AN000; yes - exit
 23874 00003205 AA                      	stosb				;AN000; no - store it in srcbuf
 23875 00003206 41                      	inc	cx			;AN000; increment length count
 23876 00003207 AC                      	lodsb				;AN000; get a character from DS:SI
 23877 00003208 EBF7                    	jmp	short mts_get_chars	;AN000; go check it
 23878                                  mts_end_string: 			;AN000; we've reached the end of line
 23879                                  	;mov	al,END_OF_LINE_IN	;AN000; store 0Dh in srcbuf
 23880 0000320A B00D                    	mov	al,0Dh
 23881 0000320C AA                      	stosb				;AN000;
 23882 0000320D 5F                      	pop	di			;AN000; restore start of srcbuf
 23883 0000320E 0E                      	push	cs			;AN000; set DS to local segment
 23884 0000320F 1F                      	pop	ds			;AN000;
 23885 00003210 890E[A4A0]              	mov	[PathCnt],cx		;AN000; set patchcnt to length count
 23886 00003214 893E[A6A0]              	mov	[PathPos],di		;AN000; set pathpos to start of srcbuf
 23887 00003218 59                      	pop	cx			;AN000; restore cx,di,si
 23888 00003219 5F                      	pop	di			;AN000;
 23889 0000321A 5E                      	pop	si			;AN000;
 23890 0000321B C3                      	retn				;AN000; exit
 23891                                  
 23892                                  ;============================================================================
 23893                                  ; TPIPE.ASM, MSDOS 6.0, 1991
 23894                                  ;============================================================================
 23895                                  ; 03/10/2018 - Retro DOS v3.0
 23896                                  
 23897                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
 23898                                  
 23899                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23900                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DE4h
 23901                                  
 23902                                  ; =============== S U B	R O U T	I N E =======================================
 23903                                  
 23904                                  	; 26/02/2023
 23905                                  SINGLETEST:
 23906 0000321C 1E                      	push	ds
 23907 0000321D 2E8E1E[159E]            	mov	ds,[cs:RESSEG]
 23908 00003222 833E[4302]00            	cmp	word [SingleCom],0
 23909 00003227 7406                    	jz	short TESTDONE
 23910 00003229 813E[4302]FFEF          	cmp	word [SingleCom],0EFFFh
 23911                                  TESTDONE:
 23912 0000322F 1F                      	pop	ds
 23913 00003230 C3                      	retn
 23914                                  
 23915                                  ; =============== S U B	R O U T	I N E =======================================
 23916                                  
 23917                                  	; 26/02/2023
 23918                                  SetRest1:
 23919 00003231 B001                    	mov	al,1
 23920                                  
 23921                                  ; ---------------------------------------------------------------------------
 23922                                  
 23923                                  SETREST:
 23924 00003233 1E                      	push	ds
 23925 00003234 8E1E[159E]              	mov	ds,[RESSEG]
 23926 00003238 A2[3F02]                	mov	[RestDir],al
 23927 0000323B 1F                      	pop	ds
 23928 0000323C C3                      	retn
 23929                                  
 23930                                  ; =============== S U B	R O U T	I N E =======================================
 23931                                  
 23932                                  ; Note that we need to handle the same thing that RestDir handles: the
 23933                                  ; requirement that we try only once to restore the user's environment after
 23934                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
 23935                                  ; disappear, we just give up.
 23936                                  
 23937                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 23938                                  	;
 23939                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23940                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:33AFh 
 23941                                  PIPEDEL:
 23942 0000323D 1E                      	push	ds
 23943 0000323E 52                      	push	dx
 23944 0000323F 2E8E1E[159E]            	mov	ds,[cs:RESSEG]
 23945                                  	;mov	dx,3EAh	; MSDOS 6.22 COMMAND.COM - TRANGROUP:33B1h
 23946                                  	;;mov	dx,320h	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E0Ch
 23947                                  			; Pipe1 = offset RESGROUP:EndInit
 23948 00003244 BA[B702]                	mov	dx,Pipe1	; Clean up in case ^C
 23949                                  	;mov	ah,Unlink ; 41h 
 23950 00003247 B441                    	mov	ah,41h
 23951 00003249 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 23952                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 23953                                  			;		(no wildcards allowed)
 23954                                  
 23955                                  	;mov	dx,439h	; MSDOS 6.22 COMMAND.COM - TRANGROUP:33BDh
 23956                                  	;;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E13h
 23957                                  			; Pipe2 = offset RESGROUP:EndInit+79
 23958 0000324B BA[0603]                	mov	dx,Pipe2
 23959                                  	;mov	ah,Unlink ; 41h
 23960 0000324E B441                    	mov	ah,41h
 23961 00003250 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 23962                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 23963                                  			;		(no wildcards allowed)
 23964 00003252 5A                      	pop	dx
 23965 00003253 E86202                  	call	PipeOff
 23966 00003256 C606[B602]00            	mov	byte [PipeFiles],0
 23967 0000325B 1F                      	pop	ds
 23968 0000325C C3                      	retn
 23969                                  
 23970                                  ; ---------------------------------------------------------------------------
 23971                                  
 23972                                  	; 26/02/2023
 23973                                  PIPEERRSYN:
 23974 0000325D BA[8B92]                	mov	dx,SYNTMES_PTR
 23975 00003260 E8DAFF                  	call	PIPEDEL
 23976 00003263 0E                      	push	cs
 23977 00003264 1F                      	pop	ds
 23978 00003265 E93AFC                  	jmp	cerror
 23979                                  
 23980                                  ; ---------------------------------------------------------------------------
 23981                                  
 23982                                  	; 26/02/2023
 23983                                  PIPERR:
 23984 00003268 9C                      	pushf
 23985 00003269 E85EFF                  	call    TriageError
 23986                                  	;call	GET_EXT_ERR_NUMBER  ; MSDOS 3.3
 23987 0000326C 50                      	push	ax		; Save results from TriageError
 23988 0000326D 52                      	push	dx
 23989 0000326E BA[5493]                	mov	dx,PIPEEMES_PTR
 23990 00003271 E8C9FF                  	call	PIPEDEL
 23991 00003274 0E                      	push	cs
 23992 00003275 1F                      	pop	ds
 23993 00003276 E8AC22                  	call	std_eprintf
 23994 00003279 5A                      	pop	dx		; Restore results from TriageError
 23995 0000327A 58                      	pop	ax
 23996 0000327B 9D                      	popf
 23997 0000327C 83F841                  	cmp	ax,65
 23998 0000327F 7503                    	jne	short TCOMMANDJ
 23999 00003281 E91EFC                  	jmp	cerror
 24000                                  
 24001                                  TCOMMANDJ:
 24002 00003284 E97DCE                  	jmp	TCOMMAND
 24003                                  
 24004                                  ; ---------------------------------------------------------------------------
 24005                                  
 24006                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 24007                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24008                                  PIPEPROCSTRT:
 24009 00003287 8E1E[159E]              	mov	ds,[RESSEG]
 24010 0000328B FE06[B602]              	inc	byte [PipeFiles] ; Flag that the pipe files exist
 24011                                  
 24012                                  	; MSDOS 6.0
 24013 0000328F 06                      	push	es
 24014 00003290 57                      	push	di
 24015 00003291 1E                      	push	ds
 24016 00003292 56                      	push	si
 24017                                  	
 24018 00003293 1E                      	push	ds
 24019 00003294 06                      	push	es
 24020 00003295 1F                      	pop	ds			;ds = TRANGROUP
 24021 00003296 BE[1899]                	mov	si,TempVarName		;ds:si = "TEMP="
 24022                                  
 24023                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
 24024                                  ;so the routine is not really general
 24025                                  
 24026 00003299 E8C9F5                  	call	find_name_in_environment
 24027                                  					;es:di points at path
 24028 0000329C 1F                      	pop	ds			;ds = DATARES again
 24029 0000329D 721F                    	jc	short no_temp_path
 24030                                  	
 24031 0000329F 1E                      	push	ds
 24032 000032A0 06                      	push	es
 24033 000032A1 1F                      	pop	ds
 24034 000032A2 07                      	pop	es			;swap ds and es
 24035 000032A3 89FE                    	mov	si,di			;ds:si points at path
 24036                                  	
 24037 000032A5 E8AA02                  	call	skip_white		;skip white space chars
 24038                                  
 24039                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
 24040                                  
 24041 000032A8 E8B302                  	call	copy_pipe_path		;copy the pipe path
 24042                                  	
 24043                                  ;Check if the TEMP path is valid
 24044                                  
 24045 000032AB 06                      	push	es
 24046 000032AC 1F                      	pop	ds			;ds = DATARES
 24047                                  	;mov	dx,offset DATARES:Pipe1	;ds:dx = path to look for
 24048                                  	;;mov	dx,320h ; MSDOS 5.0 - offset EndInit
 24049                                  	;mov	dx,3EAh	; MSDOS 6.22 - offset EndInit
 24050 000032AD BA[B702]                	mov	dx,Pipe1
 24051                                  	;mov	ax,(CHMOD shl 8) or 0
 24052 000032B0 B80043                  	mov	ax,4300h
 24053 000032B3 CD21                    	int	21h
 24054 000032B5 7207                    	jc	short no_temp_path
 24055                                  	
 24056 000032B7 F7C11000                	test	cx,10h			;is it a directory?
 24057 000032BB 7501                    	jnz	short no_temp_path	;yes, continue (carry clear)
 24058                                  	
 24059 000032BD F9                      	stc				;no, indicate fail
 24060                                  no_temp_path:
 24061 000032BE 5E                      	pop	si
 24062 000032BF 1F                      	pop	ds
 24063 000032C0 5F                      	pop	di
 24064 000032C1 07                      	pop	es
 24065 000032C2 730B                    	jnc	short crt_temp		;path found, create tempfiles
 24066                                  
 24067                                  	; 27/02/2023
 24068                                  	; MSDOS 3.3
 24069                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 24070                                  	;				; Get current drive
 24071                                  	;int	21h ; DOS - GET DEFAULT DISK NUMBER
 24072                                  	;add	al,[cs:CAPITAL_A]
 24073                                  	;mov	byte [PIPE2],al		; Make pipe files in root of def drv
 24074                                  	;mov	bx,PIPE1
 24075                                  	;mov	[bx],al
 24076                                  	;xor	ah,ah			; nul terminate path names
 24077                                  	;mov	byte [PIPE1+3],ah
 24078                                  	;mov	byte [PIPE2+3],ah
 24079                                  
 24080                                  	; MSDOS 6.0
 24081                                  ;SR;
 24082                                  ; We want to create temp files in the current directory rather than in the 
 24083                                  ;root of the drive. This is because the number of files that can be present
 24084                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
 24085                                  
 24086                                  	;mov	ah,'.'
 24087                                  	;mov	[Pipe1],ah	; = RESGROUP:EndInit
 24088                                  	;mov	[Pipe2],ah	; = RESGROUP:EndInit+79
 24089                                  	;xor	ah,ah
 24090                                  	;mov	[Pipe1+1],ah	; = RESGROUP:EndInit+1
 24091                                  	;mov	[Pipe2+1],ah		;create files in current dir
 24092                                  	; 27/02/2023
 24093 000032C4 B92E00                  	mov	cx,002Eh
 24094 000032C7 890E[B702]              	mov	[Pipe1],cx
 24095 000032CB 890E[0603]              	mov	[Pipe2],cx
 24096                                  crt_temp:
 24097                                  	; MSDOS 6.0
 24098                                  	;mov	dx,offset DATARES:Pipe1	; = RESGROUP:EndInit
 24099                                  	;;mov	dx,320h ; MSDOS 5.0 COMMAND.COM
 24100                                  	;mov	dx,3EAh ; MSDOS 6.22 COMMAND.COM	
 24101 000032CF BA[B702]                	mov	dx,Pipe1
 24102                                  	; MSDOS 3.3
 24103                                  	;mov	dx,bx
 24104                                  	
 24105                                  	; MSDOS 3.3 (& MSDOS 6.0)
 24106 000032D2 31C9                    	xor	cx,cx
 24107                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 24108 000032D4 B45A                    	mov	ah,5Ah
 24109 000032D6 CD21                    	int	21h
 24110                                  		; DOS -	3+ - CREATE UNIQUE FILE
 24111                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 24112                                  		; receive generated filename
 24113                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 24114 000032D8 728E                    	jc	short PIPERR	; Couldn't create
 24115                                  
 24116 000032DA 89C3                    	mov	bx,ax
 24117                                  	;mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 24118 000032DC B43E                    	mov	ah,3Eh
 24119 000032DE CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 24120                                  			; BX = file handle
 24121                                  	;;;mov	dx,PIPE2
 24122                                  	;;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM
 24123                                  	;mov	dx,439h ; MSDOS 6.22 COMMAND.COM
 24124 000032E0 BA[0603]                	mov	dx,Pipe2
 24125                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 24126 000032E3 B45A                    	mov	ah,5Ah
 24127 000032E5 CD21                    	int	21h
 24128                                  		; DOS -	3+ - CREATE UNIQUE FILE
 24129                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 24130                                  		; receive generated filename
 24131                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 24132                                  	; 17/04/2023
 24133                                  	;jc	short PIPERR
 24134                                  	; 27/02/2023
 24135 000032E7 7303                    	jnc	short pps1
 24136 000032E9 E97CFF                  	jmp	PIPERR
 24137                                  pps1:
 24138 000032EC 89C3                    	mov	bx,ax
 24139 000032EE B43E                    	mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 24140 000032F0 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 24141                                  				; BX = file handle
 24142                                  	;call	near ptr TESTDOREIN ; Set up a redirection if specified
 24143 000032F2 E87FFE                  	call	TESTDOREIN
 24144                                  	;mov	si,[488h] ; MSDOS 6.22 COMMAND.COM ; 11/06/2023
 24145 000032F5 8B36[5503]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 24146 000032F9 833E[4302]FF            	cmp	word [SingleCom],-1 ; 0FFFFh
 24147 000032FE 7506                    	jne	short NOSINGP
 24148 00003300 C706[4302]00F0          	mov	word [SingleCom],0F000h ; Flag single command pipe
 24149                                  NOSINGP:
 24150 00003306 EB29                    	jmp	short FIRSTPIPE
 24151                                  
 24152                                  ; ---------------------------------------------------------------------------
 24153                                  
 24154                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 24155                                  	; 11/06/2026 - Retro DOS v4.2 COMMAND.COM
 24156                                  PIPEPROC:
 24157 00003308 8026[3B02]FE            	and	byte [EchoFlag],0FEh  ; force current echo to be off
 24158                                  	;;mov	si,[488h] ; MSDOS 6.22 COMMAND.COM ; 11/06/2023
 24159 0000330D 8B36[5503]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 24160 00003311 AC                      	lodsb
 24161                                  	; 27/02/2023
 24162 00003312 3C7C                    	cmp	al,'|'		
 24163                                  	;;cmp	al,ALTPIPECHR	; Alternate pipe char? 	
 24164                                  	;je	short ISPIPE1	; Yes
 24165                                  	;cmp	al,'|'
 24166                                  	;;cmp	al,[cs:VBAR]
 24167 00003314 7403                    	je	short ISPIPE1
 24168 00003316 E98400                  	jmp	PIPEEND		; Pipe done
 24169                                  ISPIPE1:
 24170 00003319 8B16[D803]              	mov	dx,[InPipePtr]	; Get the input file name
 24171                                  	;mov	ax,OPEN*256 ; 3D00h
 24172 0000331D B8003D                  	mov	ax,3D00h
 24173 00003320 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 24174                                  			; DS:DX	-> ASCIZ filename
 24175                                  			; AL = access mode
 24176                                  			; 0 - read
 24177                                  PIPEERRJ:
 24178 00003322 7303                    	jnc	short NO_PIPEERR
 24179 00003324 E941FF                  	jmp	PIPERR		; Lost the pipe file
 24180                                  NO_PIPEERR:
 24181 00003327 89C3                    	mov	bx,ax
 24182 00003329 B0FF                    	mov	al,0FFh
 24183                                  	;xchg	al,[bx+18h]
 24184 0000332B 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 24185 0000332E A21800                  	mov	[PDB.JFN_TABLE],al	; Redirect
 24186                                  FIRSTPIPE:
 24187 00003331 BF[769C]                	mov	di,COMBUF+2
 24188 00003334 31C9                    	xor	cx,cx
 24189 00003336 803C0D                  	cmp	byte [si],0Dh	; '|<CR>'
 24190 00003339 7503                    	jne	short PIPEOK1
 24191                                  PIPEERRSYNJ:
 24192 0000333B E91FFF                  	jmp	PIPEERRSYN
 24193                                  PIPEOK1:
 24194                                  	;;;mov	al,[cs:VBAR]
 24195                                  	; 27/02/2023
 24196                                  	;;mov	al,vbar
 24197                                  	;mov	al,'|'
 24198                                  	;cmp	[si],al		; '||'
 24199                                  	;je	short PIPEERRSYNJ
 24200 0000333E 803C7C                  	cmp	byte [si],'|'
 24201                                  	;cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
 24202 00003341 74F8                    	je	short PIPEERRSYNJ
 24203                                  PIPECOMLP:
 24204 00003343 AC                      	lodsb
 24205 00003344 AA                      	stosb
 24206                                  	; 27/02/2023
 24207 00003345 E8C7F5                  	call	testkanj
 24208 00003348 7405                    	jz	short NOTKANJ5
 24209 0000334A A4                      	movsb
 24210                                  ;  Added following 2 commands to the fix pipe bug.
 24211 0000334B 41                      	inc	cx		;AN000;  3/3/KK
 24212 0000334C 41                      	inc	cx		;AN000;  3/3/KK
 24213 0000334D EBF4                    	jmp	short PIPECOMLP
 24214                                  NOTKANJ5:
 24215 0000334F 3C0D                    	cmp	al,0Dh
 24216 00003351 7438                    	je	short LASTPIPE
 24217 00003353 41                      	inc	cx
 24218                                  	; 27/02/2023
 24219 00003354 3C7C                    	cmp	al,'|'
 24220                                  	;cmp	al,ALTPIPECHR
 24221                                  	;je	short ISPIPE2
 24222                                  	;;cmp	al,[cs:VBAR]
 24223                                  	;cmp	al,vbar
 24224 00003356 75EB                    	jne	short PIPECOMLP
 24225                                  ISPIPE2:
 24226 00003358 26C645FF0D              	mov	byte [es:di-1],0Dh
 24227 0000335D 49                      	dec	cx
 24228                                  	;mov	[cs:COMBUF+1],cl
 24229                                  	; 27/02/2023
 24230 0000335E 26880E[759C]            	mov	[es:COMBUF+1],cl
 24231 00003363 4E                      	dec	si
 24232                                  	;;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
 24233                                  	; 11/06/2023 - MSDOS 6.22 COMMAND.COM
 24234                                  	;mov	[488h],si ; [PipePtr] = [EndInit+158]
 24235 00003364 8936[5503]              	mov	[PipePtr],si		; On to next pipe element
 24236                                  			; mov [EndInit+158],si
 24237 00003368 8B16[DA03]              	mov	dx,[OutPipePtr]
 24238 0000336C 51                      	push	cx
 24239 0000336D 31C9                    	xor	cx,cx
 24240                                  	;mov	ax,CREAT*256 ; 3C00h
 24241 0000336F B8003C                  	mov	ax,3C00h
 24242 00003372 CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 24243                                  			; CX = attributes for file
 24244                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 24245 00003374 59                      	pop	cx
 24246 00003375 72AB                    	jc	short PIPEERRJ		; Lost the file
 24247 00003377 89C3                    	mov	bx,ax
 24248 00003379 B0FF                    	mov	al,0FFh
 24249                                  	;xchg	al,[bx+18h]
 24250 0000337B 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 24251 0000337E A21900                  	mov	[PDB.JFN_TABLE+1],al
 24252 00003381 8716[D803]              	xchg	dx,[InPipePtr]	; Swap for next element of pipe
 24253 00003385 8916[DA03]              	mov	[OutPipePtr],dx
 24254 00003389 EB0D                    	jmp	short PIPECOM
 24255                                  LASTPIPE:
 24256                                  	;mov	[cs:COMBUF+1],cl 
 24257                                  	; 27/02/2023
 24258 0000338B 26880E[759C]            	mov	[es:COMBUF+1],cl
 24259 00003390 4E                      	dec	si
 24260                                  	;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
 24261                                  	;mov	[488h],si ; MSDOS 6.22 COMMAND.COM ; 11/06/2023
 24262 00003391 8936[5503]              	mov	[PipePtr],si	; Point at the CR (anything not '|' will do)
 24263                                  		; mov [EndInit+158],si
 24264 00003395 E859FD                  	call	TESTDOREOUT	; Set up the redirection if specified
 24265                                  PIPECOM:
 24266 00003398 0E                      	push	cs
 24267 00003399 1F                      	pop	ds
 24268 0000339A E97DCF                  	jmp	NOPIPEPROC	; Process the pipe element
 24269                                  PIPEEND:
 24270 0000339D E89DFE                  	call	PIPEDEL
 24271 000033A0 813E[4302]00F0          	cmp	word [SingleCom],0F000h
 24272 000033A6 7506                    	jnz	short NOSINGP2
 24273 000033A8 C706[4302]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Make it return
 24274                                  NOSINGP2:
 24275 000033AE E953CD                  	jmp	TCOMMAND
 24276                                  
 24277                                  ; =============== S U B	R O U T	I N E =======================================
 24278                                  
 24279                                  ; Date and time are set during initialization and use
 24280                                  ; this routines since they need to do a long return
 24281                                  
 24282                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 24283                                  DATINIT:
 24284 000033B1 2E8C1E[159E]            	mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
 24285 000033B6 06                      	push	es
 24286 000033B7 1E                      	push	ds		; Going to use the previous stack
 24287 000033B8 8CC8                    	mov	ax,cs		; Set up the appropriate segment registers
 24288 000033BA 8EC0                    	mov	es,ax
 24289 000033BC 8ED8                    	mov	ds,ax
 24290 000033BE E84B22                  	call	TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
 24291 000033C1 BA[B6A9]                	mov	dx,INTERNATVARS
 24292 000033C4 B80038                  	mov	ax,3800h
 24293                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
 24294 000033C7 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 24295                                  			; get current-country info
 24296                                  			; DS:DX	-> buffer for returned info
 24297                                  	; 20/10/2018
 24298 000033C9 C70681000D00            	mov	word [81h],0Dh ; Want to prompt for date during initialization
 24299 000033CF C606[749C]80            	mov	byte [COMBUF],128 ; Init COMBUF
 24300 000033D4 C706[759C]010D          	mov	word [COMBUF+1],0D01h
 24301 000033DA E80600                  	call	DATE
 24302 000033DD E86200                  	call	CTIME
 24303 000033E0 1F                      	pop	ds
 24304 000033E1 07                      	pop	es
 24305 000033E2 CB                      	retf	; far return
 24306                                  
 24307                                  ; =============== S U B	R O U T	I N E =======================================
 24308                                  
 24309                                  ; MSDOS 6.0
 24310                                  
 24311                                  ; ****************************************************************
 24312                                  ; *
 24313                                  ; * ROUTINE:	 DATE - Set system date
 24314                                  ; *
 24315                                  ; * FUNCTION:	 If a date is specified, set the system date,
 24316                                  ; *		 otherwise display the current system date and
 24317                                  ; *		 prompt the user for a new date.  If an invalid
 24318                                  ; *		 date is specified, issue an error message and
 24319                                  ; *		 prompt for a new date.  If the user enters
 24320                                  ; *		 nothing when prompted for a date, terminate.
 24321                                  ; *
 24322                                  ; * INPUT:	 command line at offset 81H
 24323                                  ; *
 24324                                  ; * OUTPUT:	 none
 24325                                  ; *
 24326                                  ; ****************************************************************
 24327                                  
 24328                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24329                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2FC4h
 24330                                  
 24331                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24332                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:356Eh
 24333                                  DATE:
 24334 000033E3 BE8100                  	mov	si,81h			; Accepting argument for date inline
 24335 000033E6 BF[0598]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 24336 000033E9 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 24337 000033EB 31D2                    	xor	dx,dx			;AN000;
 24338 000033ED E86C16                  	call	cmd_parse		;AC000; call parser
 24339                                  
 24340                                  	; 27/02/2023
 24341                                  	;cmp	ax,-1
 24342                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 24343                                  	;je	short PRMTDAT 		;AC000; yes - go ask for date
 24344                                  	;;cmp	ax,0
 24345                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 24346                                  	;;jne	short DATERR		;AN000; yes - go issue message
 24347                                  	; 26/04/2023
 24348                                  	;or	ax,ax ; ax = 0 ?
 24349                                  	;jnz	short DATERR
 24350                                  	;;jmp	short COMDAT		;AC000; we have a date
 24351                                  	; 11/06/2023
 24352 000033F0 40                      	inc	ax  ; cmp ax,-1
 24353 000033F1 7428                    	jz	short PRMTDAT ; 0FFFFh -> 0
 24354 000033F3 48                      	dec	ax  ; cmp ax,0
 24355 000033F4 7541                    	jnz	short DATERR ; 1 -> 0
 24356                                  	; ax = 0
 24357                                  
 24358                                  	; 27/02/2023
 24359                                  COMDAT:
 24360 000033F6 8B0E[13AA]              	mov	cx,[DATE_YEAR]		;AC000; get parts of date in
 24361 000033FA 8A36[15AA]              	mov	dh,[DATE_MONTH]		;AC000;  cx and dx for set
 24362 000033FE 8A16[16AA]              	mov	dl,[DATE_DAY]		;AC000;  date function call.
 24363 00003402 51                      	push	cx			;AC000; save date
 24364 00003403 52                      	push	dx			;AC000;
 24365 00003404 B90100                  	mov	cx,1			;AC000; set 1 positional entered
 24366 00003407 31D2                    	xor	dx,dx			;AN029;
 24367 00003409 E85016                  	call	cmd_parse		;AN029; call parser
 24368 0000340C 3CFF                    	cmp	al,0FFh ; -1
 24369                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 24370 0000340E 5A                      	pop	dx			;AC000; retrieve date
 24371 0000340F 59                      	pop	cx			;AC000;
 24372 00003410 7525                    	jnz	short DATERR		;AC000; extra stuff on line - try again
 24373                                  	; 26/04/2023
 24374                                  	;mov	ah,SET_DATE		;yes - set date
 24375 00003412 B42B                    	mov	ah,2Bh
 24376 00003414 CD21                    	int	21h
 24377                                  			; DOS - SET CURRENT DATE
 24378                                  			; DL = day, DH = month, CX = year
 24379                                  			; Return: AL = 00h if no error /= FFh if bad value sent to routine
 24380 00003416 08C0                    	or	al,al
 24381 00003418 751D                    	jnz	short DATERR
 24382                                  date_end:
 24383 0000341A C3                      	retn
 24384                                  
 24385                                  PRMTDAT:
 24386                                  	; Print "Current date is
 24387 0000341B E81608                  	call	GetDate 		;AN000; get date for output
 24388                                  
 24389 0000341E 86F2                    	xchg	dh,dl			;AN000; switch month & day
 24390 00003420 890E[A192]              	mov	[CurDat_yr],cx		;AC000; put year into message control block
 24391 00003424 8916[A392]              	mov	[CurDat_mo_day],dx	;AC000; put month and day into message control block
 24392 00003428 BA[9192]                	mov	dx,CurDat_Ptr		;AC000; set up message for output
 24393 0000342B E8FF20                  	call	std_printf
 24394                                  
 24395                                  ;AD061; mov	word [CurDat_yr],0	;AC000; reset year, month and day
 24396                                  ;AD061; mov	word [CurDat_mo_day],0 	;AC000;  pointers in control block
 24397                                  
 24398                                  GET_NEW_DATE:				;AN000;
 24399 0000342E E8BC00                  	call	GETDAT			;AC000; prompt user for date
 24400                                  	
 24401                                  	; 11/06/2023
 24402                                  	;cmp	ax,0FFFFh ; -1
 24403                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 24404                                  	;je	short date_end		;AC000; yes - exit
 24405                                  	; 26/04/2023
 24406                                  	;;cmp	ax,0
 24407                                  	;;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 24408                                  	;;;jnz	short DATERR		;AN000; yes - go issue message
 24409                                  	;; 27/02/2023
 24410                                  	;;jz	short COMDAT
 24411                                  	; 26/04/2023
 24412                                  	;and	ax,ax ; 0 ?
 24413                                  	;jz	short COMDAT
 24414                                  
 24415                                  	; 11/06/2023
 24416 00003431 40                      	inc	ax  ; cmp ax,-1
 24417 00003432 74E6                    	jz	short date_end ; 0FFFFh -> 0
 24418 00003434 48                      	dec	ax  ; cmp ax,0
 24419 00003435 74BF                    	jz	short COMDAT ; 1 -> 0
 24420                                  	; ax > 0
 24421                                  
 24422                                  ;COMDAT:
 24423                                  ;	....
 24424                                  DATERR:
 24425 00003437 E8E7F6                  	call	CRLF2			;AN028; print out a blank line
 24426 0000343A BA[8E92]                	mov	dx,BADDAT_PTR
 24427 0000343D E8ED20                  	call	std_printf
 24428 00003440 EBEC                    	jmp	short GET_NEW_DATE	;AC000; get date again
 24429                                  
 24430                                  ; =============== S U B	R O U T	I N E =======================================
 24431                                  
 24432                                  ; MSDOS 6.0
 24433                                  
 24434                                  ; TIME gets and sets the time
 24435                                  
 24436                                  ; ****************************************************************
 24437                                  ; *
 24438                                  ; * ROUTINE:	 TIME - Set system time
 24439                                  ; *
 24440                                  ; * FUNCTION:	 If a time is specified, set the system time,
 24441                                  ; *		 otherwise display the current system time and
 24442                                  ; *		 prompt the user for a new time.  If an invalid
 24443                                  ; *		 time is specified, issue an error message and
 24444                                  ; *		 prompt for a new time.  If the user enters
 24445                                  ; *		 nothing when prompted for a time, terminate.
 24446                                  ; *
 24447                                  ; * INPUT:	 command line at offset 81H
 24448                                  ; *
 24449                                  ; * OUTPUT:	 none
 24450                                  ; *
 24451                                  ; ****************************************************************
 24452                                  
 24453                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24454                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:302Dh
 24455                                  
 24456                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24457                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:35D7h
 24458                                  CTIME:
 24459 00003442 BE8100                  	mov	si,81h			; Accepting argument for time inline
 24460 00003445 BF[1798]                	mov	di,PARSE_TIME		;AN000; Get address of PARSE_time
 24461 00003448 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 24462 0000344A 31D2                    	xor	dx,dx			;AN000;
 24463 0000344C E80D16                  	call	cmd_parse		;AC000; call parser
 24464                                  	
 24465                                  	; 27/02/2023
 24466                                  	;cmp	ax,-1
 24467                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 24468                                  	;je	short PRMTTIM 		;AC000; yes - prompt for time
 24469                                  	;;cmp	ax,0
 24470                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 24471                                  	;;jne	short TIMERR		;AN000; yes - go issue message
 24472                                  	;and	ax,ax ; ax = 0 ?
 24473                                  	;jnz	short TIMERR
 24474                                  	;;jmp	short COMTIM		;AC000; we have a time
 24475                                  	; 11/06/2023
 24476 0000344F 40                      	inc	ax  ; cmp ax,-1
 24477 00003450 742C                    	jz	short PRMTTIM ; 0FFFFh -> 0
 24478 00003452 48                      	dec	ax  ; cmp ax,0
 24479 00003453 7548                    	jnz	short TIMERR ; 1 -> 0
 24480                                  	; ax = 0
 24481                                  	
 24482                                  	; 27/02/2023
 24483                                  COMTIM:
 24484 00003455 8A2E[1BAA]              	mov	ch,[TIME_HOUR]		;AC000; get parts of time in
 24485 00003459 8A0E[1CAA]              	mov	cl,[TIME_MINUTES]	;AC000;  cx and dx for set
 24486 0000345D 8A36[1DAA]              	mov	dh,[TIME_SECONDS]	;AC000;  time function call
 24487 00003461 8A16[1EAA]              	mov	dl,[TIME_FRACTION]	;AC000;
 24488 00003465 51                      	push	cx			;AC000; save time
 24489 00003466 52                      	push	dx			;AC000;
 24490 00003467 B90100                  	mov	cx,1			;AC000; set 1 positional parm entered
 24491 0000346A 31D2                    	xor	dx,dx			;AN029;
 24492 0000346C E8ED15                  	call	cmd_parse		;AN029; call parser
 24493 0000346F 3CFF                    	cmp	al, -1
 24494                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 24495 00003471 5A                      	pop	dx			;AC000; retieve time
 24496 00003472 59                      	pop	cx			;AC000;
 24497 00003473 7528                    	jnz	short TIMERR		;AC000; extra stuff on line - try again
 24498                                  SAVTIM:
 24499                                  	;mov	ah,SET_TIME
 24500 00003475 B42D                    	mov	ah,2Dh
 24501 00003477 CD21                    	int	21h
 24502 00003479 08C0                    	or	al,al
 24503 0000347B 7520                    	jnz	short TIMERR		;AC000; if an error occured, try again
 24504                                  time_end:
 24505 0000347D C3                      	retn
 24506                                  
 24507                                  PRMTTIM:
 24508                                  	;Printf "Current time is ... "
 24509                                  
 24510                                  	;mov	ah,Get_Time		;AC000; get the current time
 24511 0000347E B42C                    	mov	ah,2Ch
 24512 00003480 CD21                    	int	21h			;AC000;   Get time in CX:DX
 24513 00003482 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 24514 00003484 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 24515 00003486 890E[C392]              	mov	[CurTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 24516 0000348A 8916[C592]              	mov	[CurTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 24517 0000348E BA[BE92]                	mov	dx,CurTim_Ptr		;AC000; set up message for output
 24518 00003491 E89920                  	call	std_printf
 24519                                  
 24520                                  ;AD061; mov	word [CurTim_hr_min],0 	;AC000; reset hour, minutes, seconds, and hundredths
 24521                                  ;AD061; mov	word [CurTim_Sec_hn],0 	;AC000;  pointers in control block
 24522                                  
 24523                                  GET_NEW_TIME:
 24524 00003494 E8AE00                  	call	GETTIM			;AC000;
 24525                                  	
 24526                                  	; 11/06/2023
 24527                                  	;cmp	ax,-1
 24528                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 24529                                  	;je	short time_end		;AC000;
 24530                                  	;;cmp	ax,0
 24531                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 24532                                  	;;jne	short TIMERR		;AN000; yes - go issue message
 24533                                  	;or	ax,ax  ; ax = 0 ?
 24534                                  	;;jnz	short TIMERR
 24535                                  	; 27/02/2023
 24536                                  	;jz	short COMTIM
 24537                                  
 24538                                  	; 11/06/2023
 24539 00003497 40                      	inc	ax  ; cmp ax,-1
 24540 00003498 74E3                    	jz	short time_end ; 0FFFFh -> 0
 24541 0000349A 48                      	dec	ax  ; cmp ax,0
 24542 0000349B 74B8                    	jz	short COMTIM ; 1 -> 0
 24543                                  	; ax > 0
 24544                                  
 24545                                  ;COMTIM:
 24546                                  ;	....
 24547                                  TIMERR:
 24548 0000349D E881F6                  	call	CRLF2			;AN028; print out a blank line
 24549 000034A0 BA[BB92]                	mov	dx,BadTim_Ptr
 24550 000034A3 E88720                  	call	std_printf		; Print error message
 24551 000034A6 EBEC                    	jmp	short GET_NEW_TIME	;AC000; Try again
 24552                                  
 24553                                  ; =============== S U B	R O U T	I N E =======================================
 24554                                  
 24555                                  ; MSDOS 6.0
 24556                                  
 24557                                  ; Set the special flag in the INIT flag to the value in CX.
 24558                                  
 24559                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24560                                  SetInitFlag:
 24561 000034A8 8E1E[159E]              	mov	ds,[RESSEG]
 24562                                  
 24563 000034AC 8026[B402]FD            	and	byte [InitFlag],~INITSPECIAL ; 0FDh ; not initspecial
 24564                                  	;and	byte [InitFlag],0FDh
 24565 000034B1 080E[B402]              	or	byte [InitFlag],cl
 24566 000034B5 0E                      	push	cs
 24567 000034B6 1F                      	pop	ds
 24568 000034B7 C3                      	retn
 24569                                  
 24570                                  ; =============== S U B	R O U T	I N E =======================================
 24571                                  
 24572                                  ; MSDOS 6.0
 24573                                  
 24574                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24575                                  PipeOff:
 24576 000034B8 1E                      	push	ds
 24577 000034B9 50                      	push	ax
 24578 000034BA 2E8E1E[159E]            	mov	ds,[cs:RESSEG]
 24579 000034BF 30C0                    	xor	al,al
 24580 000034C1 8606[B502]              	xchg	[PipeFlag],al
 24581 000034C5 08C0                    	or	al,al
 24582 000034C7 7404                    	jz	short PipeOffDone
 24583 000034C9 D02E[3B02]              	shr	byte [EchoFlag],1
 24584                                  PipeOffDone:
 24585 000034CD 58                      	pop	ax
 24586 000034CE 1F                      	pop	ds
 24587 000034CF C3                      	retn
 24588                                  
 24589                                  ; =============== S U B	R O U T	I N E =======================================
 24590                                  
 24591                                  ; MSDOS 6.0
 24592                                  
 24593                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24594                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24595                                  PRINT_TIME:
 24596                                  	;mov	ah,Get_Time
 24597 000034D0 B42C                    	mov	ah,2Ch
 24598 000034D2 CD21                    	int	21h			; Get time in CX:DX
 24599                                  
 24600 000034D4 06                      	push	es
 24601 000034D5 0E                      	push	cs
 24602 000034D6 07                      	pop	es
 24603 000034D7 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 24604 000034D9 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 24605 000034DB 2E890E[FF93]            	mov	[cs:PromTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 24606 000034E0 2E8916[0194]            	mov	[cs:PromTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 24607 000034E5 BA[FA93]                	mov	dx,promtim_ptr		;AC000; set up message for output
 24608 000034E8 E84220                  	call	std_printf
 24609                                  
 24610                                  ;AD061; mov	word [cs:PromTim_hr_min],0
 24611                                  					;AC000; reset hour, minutes, seconds, and hundredths
 24612                                  ;AD061; mov	word [cs:PromTim_Sec_hn],0
 24613                                  					;AC000;  pointers in control block
 24614 000034EB 07                      	pop	es
 24615 000034EC C3                      	retn
 24616                                  
 24617                                  ; =============== S U B	R O U T	I N E =======================================
 24618                                  
 24619                                  ; MSDOS 6.0
 24620                                  
 24621                                  ; ****************************************************************
 24622                                  ; *
 24623                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 24624                                  ; *
 24625                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 24626                                  ; *		 INFORMATION and issues the "Enter new date"
 24627                                  ; *		 message with the proper date format. COMBUF
 24628                                  ; *		 is reset to get a date from the command line.
 24629                                  ; *		 The PARSE_DATE blocks are then reset and the
 24630                                  ; *		 PARSE function call is issued.
 24631                                  ; *
 24632                                  ; * INPUT:	 NONE
 24633                                  ; *
 24634                                  ; * OUTPUT:	 COMBUF
 24635                                  ; *		 PARSER RETURN CODES
 24636                                  ; *
 24637                                  ; ****************************************************************
 24638                                  
 24639                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24640                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:30E2h
 24641                                  
 24642                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24643                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:368Ch
 24644                                  GETDAT:
 24645                                  	;mov	ax,(International SHL 8)
 24646 000034ED B80038                  	mov	ax,3800h
 24647                                  					; Determine what format the date
 24648 000034F0 BA5C00                  	mov	dx,5Ch			;  should be entered in and
 24649 000034F3 CD21                    	int	21h			;  print a message describing it
 24650                                  			; DOS - 2+ - GET COUNTRY-DEPENDENT INFORMATION
 24651                                  			; get current-country info
 24652                                  			; DS:DX -> buffer for returned info
 24653 000034F5 89D6                    	mov	si,dx
 24654 000034F7 AD                      	lodsw
 24655 000034F8 2E8B16[D893]            	mov	dx,[cs:usadat_ptr]	;AC000; get mm-dd-yy
 24656 000034FD 48                      	dec	ax
 24657 000034FE 780C                    	js	short printformat
 24658 00003500 2E8B16[DB93]            	mov	dx,[cs:eurdat_ptr]	;AC000; get dd-mm-yy
 24659 00003505 7405                    	jz	short printformat
 24660 00003507 2E8B16[DE93]            	mov	dx,[cs:japdat_ptr]	;AC000; get yy-mm-dd
 24661                                  printformat:
 24662 0000350C 89D0                    	mov	ax,dx			;AN000; get message number of format
 24663                                  	;mov	dh,util_msg_class	;AN000; this is a utility message
 24664 0000350E B6FF                    	mov	dh,-1 ; 0FFh
 24665 00003510 E8FF20                  	call	TSYSGETMSG		;AN000; get the address of the message
 24666 00003513 2E8936[B292]            	mov	[cs:NewDat_Format],si	;AN000; put the address in subst block
 24667 00003518 BA[AD92]                	mov	dx,NewDat_Ptr		;AC000; get address of message to print
 24668 0000351B E80F20                  	call	std_printf
 24669                                  	;mov	word [cs:NewDat_Format],no_subst
 24670                                  					;AN000; reset subst block
 24671 0000351E 2EC706[B292]0000        	mov	word [cs:NewDat_Format],0
 24672                                  
 24673                                  	; 28/02/2023
 24674 00003525 BF[0598]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 24675                                  ; 28/02/2023
 24676                                  gettim_p:	
 24677                                  	;mov	ah,Std_Con_String_Input
 24678 00003528 B40A                    	mov	ah,0Ah
 24679 0000352A BA[749C]                	mov	dx,COMBUF
 24680 0000352D B90200                  	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 24681 00003530 E875FF                  	call	SetInitFlag		;  prompting for date.
 24682 00003533 CD21                    	int	21h			; Get input line
 24683 00003535 31C9                    	xor	cx,cx			; Reset bit in InitFlag that indicates
 24684 00003537 E86EFF                  	call	SetInitFlag		;  prompting for date.
 24685 0000353A E8E4F5                  	call	CRLF2
 24686                                  	; 28/02/2023
 24687                                  	;mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 24688                                  ;gettim_p: ; 28/02/2023
 24689 0000353D BE[769C]                	mov	si,COMBUF+2
 24690                                  	;xor	cx,cx	 ; cx = 0	;AN000; clear counter for positionals
 24691 00003540 31D2                    	xor	dx,dx			;AN000;
 24692                                  	;call	cmd_parse		;AC000; call parser
 24693                                  	;retn
 24694                                  	; 28/02/2023
 24695 00003542 E91715                  	jmp	cmd_parse
 24696                                  
 24697                                  ; =============== S U B	R O U T	I N E =======================================
 24698                                  
 24699                                  ; MSDOS 6.0
 24700                                  
 24701                                  ; ****************************************************************
 24702                                  ; *
 24703                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 24704                                  ; *
 24705                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 24706                                  ; *		 INFORMATION and issues the "Enter new time"
 24707                                  ; *		 message. COMBUF is reset to get a time from the
 24708                                  ; *		 command line. The PARSE_TIME blocks are then
 24709                                  ; *		 reset and the PARSE function call is issued.
 24710                                  ; *
 24711                                  ; * INPUT:	 NONE
 24712                                  ; *
 24713                                  ; * OUTPUT:	 COMBUF
 24714                                  ; *		 PARSER RETURN CODES
 24715                                  ; *
 24716                                  ; ****************************************************************
 24717                                  
 24718                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24719                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:313Dh
 24720                                  
 24721                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24722                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:36E7h
 24723                                  GETTIM:
 24724 00003545 31C9                    	xor	cx,cx			; Initialize hours and minutes to zero
 24725 00003547 BA[CC92]                	mov	dx,NewTim_Ptr
 24726 0000354A E8E01F                  	call	std_printf
 24727                                  
 24728                                  	; 28/02/2023
 24729 0000354D BF[1798]                	mov	di,PARSE_TIME
 24730 00003550 EBD6                    	jmp	short gettim_p
 24731                                  
 24732                                  ; 28/02/2023
 24733                                  ;	;mov	ah,Std_Con_String_Input
 24734                                  ;	mov	ah,0Ah
 24735                                  ;	mov	dx,COMBUF
 24736                                  ;	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 24737                                  ;	call	SetInitFlag		;  prompting for time.
 24738                                  ;	int	21h			; Get input line
 24739                                  ;	; 28/02/2023
 24740                                  ;	xor	cx,cx			; Reset bit in InitFlag that indicates
 24741                                  ;	call	SetInitFlag		;  prompting for time.
 24742                                  ;	call	CRLF2
 24743                                  ;	; 28/02/2023
 24744                                  ;	;mov	si,COMBUF+2
 24745                                  ;	; 28/02/2023
 24746                                  ;	mov	di,PARSE_TIME		;AN000; Get address of PARSE_TIME
 24747                                  ;	; 28/02/2023
 24748                                  ;	jmp	short gettim_p	
 24749                                  ;	; 28/02/2023
 24750                                  ;	;;xor	cx,cx			;AN000; clear counter for positionals
 24751                                  ;	;xor	dx,dx			;AN000;
 24752                                  ;	;call	cmd_parse		;AC000; call parser
 24753                                  ;	;retn
 24754                                  
 24755                                  
 24756                                  ; =============== S U B	R O U T	I N E =======================================
 24757                                  
 24758                                  ; MSDOS 6.0
 24759                                  
 24760                                  ;Skip_white: Skips over the whitespace chars that could be present after
 24761                                  ;the '=' sign in the environment variable before the actual path.
 24762                                  ;
 24763                                  ;	ENTRY:	ds:si = arguments of the environment variable
 24764                                  ;
 24765                                  ;	EXIT:	ds:si = start of the path
 24766                                  ;
 24767                                  ;	REGISTERS AFFECTED: ax
 24768                                  
 24769                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24770                                  skip_white:
 24771 00003552 FC                      	cld
 24772                                  skw_lp:
 24773 00003553 AC                      	lodsb
 24774 00003554 3C20                    	cmp	al,' '			;blank char?
 24775 00003556 74FB                    	jz	short skw_lp		;yes, skip it
 24776 00003558 3C09                    	cmp	al,9			;tab char?
 24777 0000355A 74F7                    	jz	short skw_lp		;yes, skip it
 24778 0000355C 4E                      	dec	si			;point at first non-white
 24779 0000355D C3                      	retn
 24780                                  
 24781                                  ; =============== S U B	R O U T	I N E =======================================
 24782                                  
 24783                                  ; MSDOS 6.0
 24784                                  
 24785                                  ;Copy_pipe_path: This routine copies the path from the TEMP environment
 24786                                  ;variable into the path buffers Pipe1 & Pipe2.
 24787                                  ;
 24788                                  ;	ENTRY:	ds:si = path to be copied
 24789                                  ;		es = RESGROUP
 24790                                  ;
 24791                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 24792                                  ;
 24793                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 24794                                  
 24795                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24796                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3174h
 24797                                  
 24798                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24799                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:371Eh
 24800                                  copy_pipe_path:
 24801 0000355E B9FFFF                  	mov	cx,0FFFFh ; 65535
 24802 00003561 30C0                    	xor	al,al
 24803                                  
 24804 00003563 89F7                    	mov	di,si
 24805 00003565 06                      	push	es			;save es
 24806 00003566 1E                      	push	ds
 24807 00003567 07                      	pop	es			;es:di = path to be copied
 24808                                  	
 24809 00003568 FC                      	cld
 24810 00003569 57                      	push	di
 24811 0000356A F2AE                    	repnz	scasb			;look for the null char
 24812 0000356C 5F                      	pop	di
 24813                                  
 24814 0000356D 07                      	pop	es			;es = RESGROUP again
 24815                                  
 24816 0000356E F7D1                    	not	cx			;length including the null
 24817                                  
 24818                                  	;;;mov	di,320h ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit)
 24819                                  	;;mov	di,3EAh ; MSDOS 6.22 COMMAND.COM ; 11/06/2023
 24820                                  	;mov	di,offset DATARES:Pipe1
 24821 00003570 BF[B702]                	mov	di,Pipe1  ; (offset RESGROUP:EndInit)
 24822 00003573 57                      	push	di
 24823 00003574 51                      	push	cx			
 24824 00003575 F3A4                    	rep	movsb			;copy path into Pipe1
 24825 00003577 59                      	pop	cx
 24826 00003578 5F                      	pop	di
 24827                                  
 24828 00003579 1E                      	push	ds
 24829 0000357A 06                      	push	es
 24830 0000357B 1F                      	pop	ds			;ds:si = Pipe1
 24831 0000357C 89FE                    	mov	si,di
 24832                                  	;;;mov	di,36Fh ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit+79)
 24833                                  	;;mov	di,439h ; MSDOS 6.22 COMMAND.COM ; 11/06/2023
 24834                                  	;mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 24835 0000357E BF[0603]                	mov	di,Pipe2  ; (offset RESGROUP:EndInit+79)
 24836 00003581 F3A4                    	rep	movsb			;copy path into Pipe2
 24837 00003583 1F                      	pop	ds
 24838 00003584 C3                      	retn
 24839                                  
 24840                                  ;============================================================================
 24841                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 24842                                  ;============================================================================
 24843                                  ; 03/10/2018 - Retro DOS v3.0
 24844                                  
 24845                                  ;----------------------------------------------------------------------------
 24846                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 24847                                  ; argv[argvcnt] array. The most important difference between this array and
 24848                                  ; the tradition UNIX format is the extra cparse information included with
 24849                                  ; each argument element.
 24850                                  ;---------------
 24851                                  ; ENTRY:
 24852                                  ;	BL	     special delimiter for cparse -- not implemented)
 24853                                  ;---------------
 24854                                  ; EXIT:
 24855                                  ;	CF	    set if error
 24856                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 24857                                  ;	argv[]	    array of cparse flags and pointers to arguments
 24858                                  ;	argvcnt     argument count
 24859                                  ;---------------
 24860                                  ; NOTE(S):
 24861                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 24862                                  ;	*   Parseflags record contains cparse flags, as follows:
 24863                                  ;		sw_flag 	--	was this arg a switch?
 24864                                  ;		wildcard	--	whether or not it contained a * or ?
 24865                                  ;		path_sep	--	maybe it was a pathname
 24866                                  ;		unused		--	for future expansion
 24867                                  ;		special_delim	--	was there an initial special delimiter?
 24868                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 24869                                  ;	*   Relationship between input, cparse output, and comtail can be
 24870                                  ;	    found in the following chart. Despite the claim of the cparse
 24871                                  ;	    documentation that, "Token buffer always starts d: for non switch
 24872                                  ;	    tokens", such is not the case (see column two, row two).
 24873                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 24874                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 24875                                  ;	    STARTEL addresses) will be null. This is clearly just a
 24876                                  ;	    documentation error.
 24877                                  ;	*   cparse also returns a switch code in BP for each switch it
 24878                                  ;	    recognizes on the command line.
 24879                                  ;	*   arglen for each token does NOT include the terminating null.
 24880                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 24881                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 24882                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 24883                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 24884                                  ;	    line parsing may result in slightly different behavior than
 24885                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 24886                                  ;
 24887                                  ;	    Input		    Cparse		Command Line (80H)
 24888                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 24889                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 24890                                  ;	foo.bat 		foo.bat 		foo.bat
 24891                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 24892                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 24893                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 24894                                  
 24895                                  ; =============== S U B	R O U T	I N E =======================================
 24896                                  
 24897                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 24898                                  
 24899                                  ; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24900                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 319Bh
 24901                                  
 24902                                  ; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 24903                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 3745h
 24904                                  
 24905                                  ; 27/07/2024 - Retro DOS v4.0-v4.1-v4.2-v5.0 COMMAND.COM (PARSELINE)
 24906                                  ; PCDOS 7.1 - COMMAND.COM, transient portion/segment offset 35F5h
 24907                                  
 24908                                  PARSELINE:
 24909 00003585 50                      	push	ax			; most of these are clobbered
 24910 00003586 53                      	push	bx			; by cparse...
 24911 00003587 51                      	push	cx
 24912 00003588 52                      	push	dx
 24913 00003589 57                      	push	di
 24914 0000358A 56                      	push	si
 24915 0000358B 9C                      	pushf
 24916                                  	;mov	byte [cpyflag],0  ; Turn "CPARSE called from COPY flag" off
 24917 0000358C C706[2DA8]FFFF          	mov	word [LASTARG],-1 ; last argument at which to accumulate
 24918 00003592 31C0                    	xor	ax,ax
 24919                                  	;;mov	cx,1348
 24920                                  	; 27/07/2024
 24921                                  	;mov	cx,1092  ; PCDOS 7.1 COMMAND.COM
 24922 00003594 B94404                  	mov	cx,ARG_UNIT.SIZE ; 1092
 24923 00003597 A2[BBA0]                	mov	[cpyflag],al ; 0 ; 27/07/2024
 24924 0000359A BF[67A2]                	mov	di,ARG
 24925 0000359D F3AA                    	rep	stosb
 24926                                  	;mov	word [ARGBUF_PTR],ARG_ARGBUF
 24927 0000359F C706[ABA7][2BA5]        	mov	word [ARGBUF_PTR],ARG+ARG_UNIT.argbuf
 24928                                  	;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 24929                                  	;mov	word [ARG+ARG_UNIT.argswinfo],0
 24930 000035A5 A3[29A5]                	mov	[ARG+ARG_UNIT.argswinfo],ax ; 0 ; 27/07/2024
 24931                                  	;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 24932                                  	;mov	word [ARG+ARG_UNIT.argvcnt],0
 24933 000035A8 A3[27A5]                	mov	[ARG+ARG_UNIT.argvcnt],ax ; 0 ; 27/07/2024 
 24934 000035AB BE[769C]                	mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 24935                                  
 24936                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 24937                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 24938                                  ; otherwise. This is done so that commands can get arg pointers into their
 24939                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 24940                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 24941                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 24942                                  ; the command to be repeated or the transient part of command has been
 24943                                  ; reloaded.
 24944                                  
 24945 000035AE 1E                      	push	ds
 24946 000035AF 8E1E[159E]              	mov	ds,[RESSEG]
 24947                                  	;cmp	byte [ForFlag],0
 24948 000035B3 3806[4902]              	cmp	[ForFlag],al ; 0 ; 27/07/2024
 24949 000035B7 1F                      	pop	ds
 24950 000035B8 7510                    	jnz	short PCONT
 24951                                  	;mov	di,ARG_ARGFORCOMBUF
 24952 000035BA BF[2BA6]                	mov	di,ARG+ARG_UNIT.argforcombuf
 24953 000035BD 30ED                    	xor	ch,ch
 24954 000035BF 8A0E[759C]              	mov	cl,[COMBUF+1]
 24955 000035C3 FEC1                    	inc	cl
 24956 000035C5 F3A4                    	rep	movsb
 24957                                  	;mov	si,ARG_ARGFORCOMBUF
 24958 000035C7 BE[2BA6]                	mov	si,ARG+ARG_UNIT.argforcombuf
 24959                                  PCONT:
 24960 000035CA BF[ADA7]                	mov	di,TPBUF	; destination is temporary token buffer
 24961 000035CD B320                    	mov	bl,' '		; no special delimiter, for now
 24962                                  PARSELOOP:
 24963 000035CF 8936[2FA8]              	mov	[COMPTR],si	; save ptr into original command buffer
 24964 000035D3 31ED                    	xor	bp,bp		; switch information put here by cparse
 24965 000035D5 C606[49A2]00            	mov	byte [expand_star],0 ; don't expand *'s to ?'s
 24966 000035DA E851F5                  	call	scanoff		; skip leading blanks...
 24967 000035DD E8B712                  	call	cparse		; byte off a token (args in SI, DI, BL)
 24968 000035E0 730B                    	jnb	short MORE_PRSE
 24969 000035E2 09ED                    	or	bp,bp		; Check for trailing switch character
 24970 000035E4 7403                    	jz	short PARSEDONE
 24971 000035E6 E81700                  	call	newarg		; We hit CR but BP is non-zero. The
 24972                                  				;   typical cause of this is that a
 24973                                  				;   switch char IMMEDIATELY preceeds
 24974                                  				;   the CR. We have an argument, but it
 24975                                  				;   is sort of an error.
 24976                                  	;jmp	short PARSEDONE	; We're done (found the CR).
 24977                                  	; 01/03/2023
 24978                                  PARSEDONE:
 24979 000035E9 9D                      	popf
 24980 000035EA F8                      	clc
 24981 000035EB EB0C                    	jmp	short PARSE_EXIT
 24982                                  
 24983                                  MORE_PRSE:
 24984 000035ED C606[BBA0]02            	mov	byte [cpyflag],2
 24985                                  				; tell CPARSE that 1st token is done
 24986 000035F2 E80B00                  	call	newarg		; add to argv array (CX has char count)
 24987 000035F5 73D8                    	jnb	short PARSELOOP	; was everything OK?
 24988                                  	;jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 24989                                  	; 01/03/2023
 24990                                  ;PARSEDONE:
 24991                                  	;popf
 24992                                  	;clc
 24993                                  	;jmp	short PARSE_EXIT
 24994                                  
 24995                                  PARSE_ERROR:			; error entry (er, exit) point
 24996 000035F7 9D                      	popf
 24997 000035F8 F9                      	stc
 24998                                  PARSE_EXIT:			; depend on not changing CF
 24999 000035F9 5E                      	pop	si
 25000 000035FA 5F                      	pop	di
 25001 000035FB 5A                      	pop	dx
 25002 000035FC 59                      	pop	cx
 25003 000035FD 5B                      	pop	bx
 25004 000035FE 58                      	pop	ax
 25005 000035FF C3                      	retn
 25006                                  
 25007                                  ; =============== S U B	R O U T	I N E =======================================
 25008                                  
 25009                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 25010                                  ;
 25011                                  ; ENTRY:
 25012                                  ;   BH			argflags
 25013                                  ;   CX			character count in argstring
 25014                                  ;   DI			pointer to argstring
 25015                                  ;   comptr		ptr to starting loc of current token in original command
 25016                                  ;   [STARTEL]		cparse's answer to where the last element starts
 25017                                  ; EXIT:
 25018                                  ;   argbufptr		points to next free section of argbuffer
 25019                                  ;   arg.argbuf		contains null-terminated argument strings
 25020                                  ;   arg.argvcnt 	argument count
 25021                                  ;   arg.argv[]		array of flags and pointers
 25022                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 25023                                  ;   CF			set if error
 25024                                  ;   AL			carry set:  error code; otherwise, zero
 25025                                  
 25026                                  	; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25027                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25028                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM 
 25029                                  	;	     & Retro DOS v4.2 COMMAND.COM (2024 modification)
 25030                                  newarg:
 25031 00003600 53                      	push	bx
 25032 00003601 51                      	push	cx
 25033 00003602 52                      	push	dx
 25034 00003603 57                      	push	di
 25035 00003604 56                      	push	si
 25036 00003605 9C                      	pushf
 25037 00003606 E86200                  	call	arg_switch		; if it's a switch, record switch info
 25038                                  					; LEAVE SWITCH ON COMMAND LINE!!
 25039                                  	;;;jc	short newarg_done 	; previous arg's switches -- and leave
 25040                                  
 25041                                  	;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 25042 00003609 833E[27A5]40            	cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 25043 0000360E 7D50                    	jge	short to_many_args	; exceeded array limits
 25044 00003610 88FE                    	mov	dh,bh			
 25045                                  	;mov	bx,[ARG_ARGVCNT]	; save argflags	
 25046 00003612 8B1E[27A5]              	mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 25047                                  	;inc	word [ARG_ARGVCNT]
 25048 00003616 FF06[27A5]              	inc	word [ARG+ARG_UNIT.argvcnt]
 25049                                  	;mov	ax,ARG_ARGV
 25050 0000361A B8[67A2]                	mov	ax,ARG+ARG_UNIT.argv
 25051 0000361D E87E00                  	call	argv_calc		; convert offset to pointer
 25052                                  	;mov	[BX].argsw_word,0 	; no switch information, yet...
 25053                                  	;mov	word [bx+7],0
 25054 00003620 C747070000              	mov	word [bx+ARGV_ELE.argsw_word],0
 25055                                  	;mov	[BX].arglen,CX		; argv[argvcnt].arglen = arg length
 25056                                  	;mov	[bx+5],cx
 25057 00003625 894F05                  	mov	[bx+ARGV_ELE.arglen],cx 
 25058                                  	;mov	[BX].argflags,DH 	; argv[argvcnt].argflags = cparse flags
 25059                                  	;mov	[bx+2],dh
 25060 00003628 887702                  	mov	[bx+ARGV_ELE.argflags],dh
 25061 0000362B 8B36[ABA7]              	mov	si,[ARGBUF_PTR]
 25062                                  	;mov	[BX].argpointer,SI 	; argv[argvcnt].argpointer = [argbufptr]
 25063                                  	;mov	[bx+ARGV_ELE.argpointer],si
 25064 0000362F 8937                    	mov	[bx],si			
 25065 00003631 0336[0DA2]              	add	si,[STARTEL]		; save startel from new location
 25066 00003635 29FE                    	sub	si,di			; form pointer into argbuf
 25067                                  	;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 25068                                  	;mov	[bx+3],si
 25069 00003637 897703                  	mov	[bx+ARGV_ELE.argstartel],si
 25070 0000363A 8B36[2FA8]              	mov	si,[COMPTR]
 25071                                  	;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 25072                                  	;mov	[bx+9],si
 25073 0000363E 897709                  	mov	[bx+ARGV_ELE.arg_ocomptr],si
 25074 00003641 89FE                    	mov	si,di			; now save argstring in argbuffer
 25075 00003643 8B3E[ABA7]              	mov	di,[ARGBUF_PTR]		; load the argbuf pointer and make
 25076                                  
 25077                                  ; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 25078                                  ; PCDOS 7.1 COMMAND.COM
 25079                                  %if 0
 25080                                  	add	di,cx			; sure we're not about to run off
 25081                                  	;cmp	DI,OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 25082                                  	;;cmp	di,ARG_ARGBUF+255
 25083                                  	;cmp	di,ARG+ARG_UNIT.argbuf+127
 25084                                  	cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 25085                                  	jge	short buf_oflow		; the end of the buffer (plus null byte)
 25086                                  	sub	di,cx
 25087                                  %else
 25088                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 25089                                  	;mov	bx,ARG_ARGBUF+127
 25090 00003647 BB[AAA5]                	mov	bx,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 25091 0000364A 29FB                    	sub	bx,di	; sure we're not about to run off
 25092 0000364C 39CB                    	cmp	bx,cx
 25093 0000364E 7302                    	jnb	short newarg_@
 25094 00003650 89D9                    	mov	cx,bx	
 25095                                  %endif
 25096                                  
 25097                                  newarg_@:	; 27/07/2024
 25098 00003652 FC                      	cld
 25099 00003653 F3A4                    	rep	movsb
 25100 00003655 B000                    	mov	al,ANULL ; 0		; tack a null byte on the end
 25101 00003657 AA                      	stosb
 25102 00003658 893E[ABA7]              	mov	[ARGBUF_PTR],di		; update argbufptr after copy
 25103                                  newarg_done:
 25104 0000365C 9D                      	popf
 25105 0000365D F8                      	clc
 25106 0000365E EB05                    	jmp	short newarg_exit
 25107                                  
 25108                                  ; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 25109                                  ; PCDOS 7.1 COMMAND.COM
 25110                                  %if 0
 25111                                  to_many_args:
 25112                                  	mov	ax,1
 25113                                  	jmp	short newarg_error
 25114                                  buf_oflow:
 25115                                  	mov	ax,2
 25116                                  %else
 25117                                  ; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 25118                                  ;buf_oflow:
 25119                                  ;	; 27/07/2024
 25120                                  ;	; PCDOS 7.1 COMMAND.COM
 25121                                  ;	sub	di,cx
 25122                                  ;	;mov	cx,ARG_ARGBUF+7Fh
 25123                                  ;	mov	cx,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 25124                                  ;	sub	cx,di
 25125                                  ;	jmp     short newarg_@
 25126                                  to_many_args:
 25127 00003660 B80100                  	mov	ax,1
 25128                                  %endif
 25129                                  
 25130                                  newarg_error:
 25131 00003663 9D                      	popf
 25132 00003664 F9                      	stc
 25133                                  newarg_exit:
 25134 00003665 5E                      	pop	si
 25135 00003666 5F                      	pop	di
 25136 00003667 5A                      	pop	dx
 25137 00003668 59                      	pop	cx
 25138 00003669 5B                      	pop	bx
 25139 0000366A C3                      	retn
 25140                                  
 25141                                  ; =============== S U B	R O U T	I N E =======================================
 25142                                  
 25143                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 25144                                  ; event that it is, and we can recognize
 25145                                  ;
 25146                                  ; ENTRY:
 25147                                  ;   As in <newarg>.
 25148                                  ; EXIT:
 25149                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 25150                                  ; NOTE(S):
 25151                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 25152                                  ;	on the order of definition in the <switch_list> variable and the
 25153                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 25154                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 25155                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 25156                                  ;   *	The <switch_list> declared below is redundant to one declared in
 25157                                  ;	TDATA.ASM, and used in TCODE.ASM.
 25158                                  ;   *	An ugly routine.
 25159                                  
 25160                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 25161                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25162                                  arg_switch:
 25163 0000366B 50                      	push	ax
 25164 0000366C 53                      	push	bx
 25165 0000366D 51                      	push	cx
 25166 0000366E 57                      	push	di
 25167 0000366F 9C                      	pushf
 25168 00003670 F6C701                  	test	bh,1 ; sw_flag		; is it a switch? (preserve flag word)
 25169 00003673 741C                    	jz	short arg_no_switch0
 25170 00003675 833E[2DA8]FF            	cmp	word [LASTARG],-1 	; have we encountered any REAL args yet?
 25171 0000367A 741B                    	je	short arg_no_switch1 	; no, so leading switches don't matter
 25172 0000367C 8B1E[2DA8]              	mov	bx,[LASTARG]		; yes, add switch info to last REAL arg
 25173                                  	;mov	ax,offset TRANGROUP:arg.argv
 25174                                  	;mov	ax,ARG_ARGV
 25175 00003680 B8[67A2]                	mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 25176 00003683 E81800                  	call	argv_calc
 25177                                  	;or	[BX].argsw_word,BP
 25178                                  	;or	[bx+7],bp
 25179 00003686 096F07                  	or	[bx+ARGV_ELE.argsw_word],bp
 25180                                  	;or	arg.argswinfo,BP
 25181                                  	;or	[ARG_ARGSWINFO],bp
 25182 00003689 092E[29A5]              	or	[ARG+ARG_UNIT.argswinfo],bp
 25183                                  arg_yes_switch:
 25184 0000368D 9D                      	popf
 25185 0000368E F9                      	stc
 25186 0000368F EB08                    	jmp	short arg_switch_exit
 25187                                  
 25188                                  arg_no_switch0:
 25189                                  	;mov	ax,[ARG_ARGVCNT]
 25190 00003691 A1[27A5]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 25191 00003694 A3[2DA8]                	mov	[LASTARG],ax
 25192                                  arg_no_switch1:
 25193 00003697 9D                      	popf
 25194 00003698 F8                      	clc
 25195                                  arg_switch_exit:
 25196 00003699 5F                      	pop	di
 25197 0000369A 59                      	pop	cx
 25198 0000369B 5B                      	pop	bx
 25199 0000369C 58                      	pop	ax
 25200 0000369D C3                      	retn
 25201                                  
 25202                                  ; =============== S U B	R O U T	I N E =======================================
 25203                                  
 25204                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 25205                                  ; the supplied array.  Method used for computing the address is:
 25206                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 25207                                  ; ENTRY:
 25208                                  ;   AX	    --	    base of array
 25209                                  ;   BX	    --	    array index
 25210                                  ; EXIT:
 25211                                  ;   BX	    --	    byte offset
 25212                                  
 25213                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 25214                                  argv_calc:
 25215 0000369E 50                      	push	ax		; Save base
 25216 0000369F 88D8                    	mov	al,bl		; al = array index
 25217                                  	;mov	bl,11
 25218 000036A1 B30B                    	mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 25219 000036A3 F6E3                    	mul	bl		; ax = base offset
 25220 000036A5 5B                      	pop	bx		; Get base
 25221 000036A6 01D8                    	add	ax,bx		; Add in base offset
 25222 000036A8 93                      	xchg	ax,bx		; Restore ax and put byte offset in bx
 25223 000036A9 C3                      	retn
 25224                                  
 25225                                  ; ---------------------------------------------------------------------------
 25226                                  	
 25227                                  	;db 0Ah dup(0)
 25228                                  	;times 10 db 0
 25229                                  
 25230 000036AA 90<rep 6h>              align 16
 25231                                  
 25232                                  ;============================================================================
 25233                                  ; PATH1.ASM, MSDOS 6.0, 1991
 25234                                  ;============================================================================
 25235                                  ; 03/10/2018 - Retro DOS v3.0
 25236                                  
 25237                                  ;----------------------------------------------------------------------------
 25238                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 25239                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 25240                                  ;    given a pathname, attempts to find a corresponding executable or batch
 25241                                  ;    file on disk. Directories specified in the user's search path will be
 25242                                  ;    searched for a matching file, if a match is not found in the current
 25243                                  ;    directory and if the pathname is actually only an MSDOS filename.
 25244                                  ;    <Path_Search> assumes that the parsed command name can be found in
 25245                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 25246                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 25247                                  ;    information could be placed in argv[0], or <Path_Search> could be
 25248                                  ;    (easily) modified to make no assumptions about where its input is found.
 25249                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 25250                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 25251                                  ;    allocated memory. This is handy for for-loop processing, and anything
 25252                                  ;    else that wants to save the whole shebang and then process other command
 25253                                  ;    lines.
 25254                                  ;
 25255                                  ; Alan L, OS/MSDOS				    August 15, 1983
 25256                                  ;
 25257                                  ; ENTRY:
 25258                                  ;   <Path_Search>:	    argv[0].
 25259                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 25260                                  ; EXIT:
 25261                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 25262                                  ;   <Save_Args>:	    success flag, segment address of new memory
 25263                                  ; NOTE(S):
 25264                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 25265                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 25266                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 25267                                  ;	does not function as specified; see <Parseline> for more details.
 25268                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 25269                                  ;	need to know about. This extra information is stored in a switch_flag
 25270                                  ;	word with each command-line argument; the switches themselves will not
 25271                                  ;	appear in the resulting arg structure.
 25272                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 25273                                  ;----------------------------------------------------------------------------
 25274                                  
 25275                                  ; =============== S U B	R O U T	I N E =======================================
 25276                                  
 25277                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 25278                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 25279                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 25280                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 25281                                  ; have a match, either in the current working directory if we were handed
 25282                                  ; a filename, or in the specified directory, given a pathname. If this call
 25283                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 25284                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 25285                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 25286                                  ; either the first invocation of search or on one of the succeeding calls
 25287                                  ; sets up the appropriate information for copying the successful pathname
 25288                                  ; prefix (if any) into the result buffer, followed by the successful filename
 25289                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 25290                                  ;
 25291                                  ; ENTRY:
 25292                                  ;   argv[0]		--	command name and associated information
 25293                                  ; EXIT:
 25294                                  ;   AX			--	non-zero indicates type of file found
 25295                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 25296                                  ; NOTE(S):
 25297                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 25298                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 25299                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 25300                                  ;	if search returns an .exe or .bat.
 25301                                  ;   5)	Clobbers dma address.
 25302                                  
 25303                                  PBUFLEN 	EQU	128		; length of EXECPATH
 25304                                  PATH_SEP_CHAR	EQU	';'
 25305                                  
 25306                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 25307                                  
 25308                                  	;special_delim equ 128
 25309                                  	;path_sep equ 4
 25310                                  	;wildcard equ 2
 25311                                  	;sw_flag  equ 1
 25312                                  
 25313                                  ;----------------------------------------------------------------------------
 25314                                  
 25315                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 25316                                  
 25317                                  ; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25318                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 32D1h
 25319                                  
 25320                                  ; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25321                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 387Bh
 25322                                  
 25323                                  path_search:
 25324 000036B0 53                      	push	bx
 25325 000036B1 51                      	push	cx
 25326 000036B2 52                      	push	dx		; could use a "stack 'em" instruction
 25327 000036B3 56                      	push	si
 25328 000036B4 57                      	push	di
 25329 000036B5 55                      	push	bp
 25330 000036B6 9C                      	pushf
 25331                                  
 25332                                  	;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 25333                                  	;test	byte [ARGV0_ARG_FLAGS],3
 25334 000036B7 F606[69A2]03            	test	byte [ARG+ARGV_ELE.argflags],3 ; wildcard+sw_flag
 25335 000036BC 7403                    	jz	short path_search_ok
 25336                                  path_failure_jmp:
 25337 000036BE E9C100                  	jmp	path_failure	; ambiguous commands not allowed
 25338                                  
 25339                                  path_search_ok:
 25340 000036C1 E85201                  	call	STORE_PCHAR	; figure out the pathname separator
 25341 000036C4 BA[31A8]                	mov	dx,FBUF		; clobber old dma value with
 25342 000036C7 B8001A                  	mov	ax,Set_DMA*256 ; 1A00h ; a pointer to our dma buffer
 25343 000036CA CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 25344                                  			; DS:DX	-> disk	transfer buffer
 25345 000036CC 06                      	push	es
 25346 000036CD E88DF1                  	call	find_path	; get a handle (ES:DI) on user path
 25347 000036D0 8C06[5CA8]              	mov	[pathinfo+0],es	; and squirrel it away
 25348 000036D4 893E[5EA8]              	mov	[pathinfo+2],di	; "old" pathstring pointer
 25349 000036D8 893E[60A8]              	mov	[pathinfo+4],di	; "new" pathstring pointer
 25350 000036DC 07                      	pop	es
 25351                                  	
 25352 000036DD BB8000                  	mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 25353 000036E0 BE[3D9D]                	mov	si,EXECPATH
 25354 000036E3 E88002                  	call	STRIP
 25355 000036E6 72D6                    	jc	short path_failure_jmp ; if possible, of course
 25356                                  		
 25357 000036E8 89F2                    	mov	dx,si		; search (EXECPATH, error_message)
 25358 000036EA C706[B1A8][4F92]        	mov	word [search_error],baddrv_ptr
 25359 000036F0 E89F01                  	call	PSEARCH		; must do at least one search
 25360 000036F3 09C0                    	or	ax,ax		; find anything?
 25361 000036F5 7469                    	jz	short path_noinit
 25362                                  				; failure ... search farther
 25363 000036F7 89C5                    	mov	bp,ax		; success... save filetype code
 25364 000036F9 BF[3D9D]                	mov	di,EXECPATH
 25365                                  	;mov	si,ds:arg.argv[0].argpointer
 25366                                  	;mov	si,[ARG_ARGV]
 25367 000036FC 8B36[67A2]              	mov	si,[ARG+ARGV_ELE.argpointer]
 25368                                  	;mov	cx,ds:arg.argv[0].argstartel
 25369                                  	;mov	cx,[ARGV0_ARGSTARTEL]
 25370 00003700 8B0E[6AA2]              	mov	cx,[ARG+ARGV_ELE.argstartel]
 25371 00003704 29F1                    	sub	cx,si		; compute prefix bytes to copy
 25372                                  
 25373                                  ; We have the number of bytes in the prefix (up to the final component).
 25374                                  ; We need to form the complete pathname including leading drive and current
 25375                                  ; directory.
 25376                                  ;
 25377                                  ; Is there a drive letter present?
 25378                                  
 25379 00003706 B43A                    	mov	ah,':'
 25380 00003708 83F902                  	cmp	cx,2		; room for drive letter?
 25381 0000370B 7205                    	jb	short adddrive	; no, stick it in
 25382 0000370D 386401                  	cmp	[si+1],	ah	; colon present?
 25383 00003710 7408                    	je	short movedrive	; yes, just move it
 25384                                  adddrive:
 25385 00003712 A0[299E]                	mov	al,[CURDRV]	; get current drive
 25386 00003715 0441                    	add	al,'A'		; convert to uppercase letter
 25387 00003717 AB                      	stosw			; store d:
 25388 00003718 EB05                    	jmp	short checkpath
 25389                                  
 25390                                  movedrive:
 25391 0000371A AD                      	lodsw			; move d:
 25392 0000371B AB                      	stosw
 25393 0000371C 83E902                  	sub	cx,2		; 2 bytes less to move
 25394                                  checkpath:
 25395 0000371F 0C20                    	or	al,20h
 25396 00003721 88C2                    	mov	dl,al
 25397                                  	;sub	dl,60h
 25398 00003723 80EA60                  	sub	dl,'a'-1	; convert to 1-based for current dir
 25399                                  
 25400                                  ; Stick in beginning path char
 25401                                  
 25402 00003726 A0[62A8]                	mov	al,[psep_char]
 25403 00003729 AA                      	stosb
 25404                                  
 25405                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 25406                                  ; Otherwise, get current dir for DL.
 25407                                  
 25408 0000372A 83F901                  	cmp	cx,1		; is there room for path char?
 25409 0000372D 720A                    	jb	short addpath	; no, go add path
 25410 0000372F AC                      	lodsb
 25411 00003730 49                      	dec	cx
 25412 00003731 3A06[62A8]              	cmp	al,[psep_char]	; is there a path separator?
 25413 00003735 741C                    	je	short movepath	; yes, go move remainder of path
 25414 00003737 41                      	inc	cx
 25415 00003738 4E                      	dec	si		; undo the lodsb
 25416                                  addpath:
 25417 00003739 56                      	push	si
 25418 0000373A 89FE                    	mov	si,di		; remainder of buffer
 25419 0000373C B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25420 0000373F CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25421                                  			; DL = drive (0=default,1=A,etc.)
 25422                                  			; DS:SI	points to 64-byte buffer area
 25423                                  
 25424                                  ; The previous current dir will succeed a previous find_first already worked.
 25425                                  ;
 25426                                  ; Find end of string.
 25427                                  
 25428 00003741 89F7                    	mov	di,si
 25429 00003743 5E                      	pop	si
 25430 00003744 A0[62A8]                	mov	al,[psep_char]
 25431 00003747 803D00                  	cmp	byte [di],0	; root (empty dir string)?
 25432 0000374A 7407                    	jz	short movepath	; yes, no need for path char
 25433                                  scanend:
 25434                                  	;cmp	byte [di],0	; end of string?
 25435                                  	;jz	short foundend
 25436                                  	;inc	di
 25437                                  	;jmp	short scanend
 25438                                  	; 18/03/2023 - Retro DOS v4.0 COMMAND.COM
 25439 0000374C 47                      	inc	di
 25440 0000374D 803D00                  	cmp	byte [di],0
 25441 00003750 75FA                    	jnz	short scanend
 25442                                  
 25443                                  ; Stick in a trailing path char.
 25444                                  
 25445                                  foundend:
 25446 00003752 AA                      	stosb
 25447                                  
 25448                                  ; Move remaining part of path. Skip leading path char if present.
 25449                                  
 25450                                  movepath:
 25451 00003753 3804                    	cmp	[si],al		; first char a path char?
 25452 00003755 7502                    	jne	short copypath
 25453                                  	; 26/04/2023
 25454 00003757 46                      	inc	si		; move past leading char
 25455 00003758 49                      	dec	cx		; drop from count
 25456                                  copypath:
 25457 00003759 E302                    	jcxz	_copydone	; no chars to move!
 25458 0000375B F3A4                    	rep	movsb
 25459                                  _copydone:
 25460 0000375D E9A100                  	jmp	path_success
 25461                                  				; run off and form complete pathname
 25462                                  path_noinit:
 25463                                  	;test	ds:arg.argv[0].argflags, MASK path_sep
 25464                                  	;test	byte [ARGV0_ARG_FLAGS],4
 25465 00003760 F606[69A2]04            	test	byte [ARG+ARGV_ELE.argflags],4 ; path_sep
 25466 00003765 751B                    	jnz	short path_failure
 25467                                  				; complete pathname specified ==> fail
 25468                                  	;mov	bh,';'
 25469 00003767 B73B                    	mov	bh,PATH_SEP_CHAR
 25470                                  				; semicolon terminates pathstring
 25471                                  	;mov	dx,ds:arg.argv[0].argstartel
 25472                                  				; this is where the last element starts
 25473                                  	;mov	dx,[ARGV0_ARGSTARTEL]
 25474 00003769 8B16[6AA2]              	mov	dx,[ARG+ARGV_ELE.argstartel]
 25475                                  	;sub	dx,ds:arg.argv[0].argpointer
 25476                                  				; form pointer into EXECPATH,
 25477                                  	;sub	dx,[ARG_ARGV]
 25478 0000376D 2B16[67A2]              	sub	dx,[ARG+ARGV_ELE.argpointer]
 25479 00003771 81C2[3D9D]              	add	dx,EXECPATH	; skipping over drive spec, if any
 25480                                  path_loop:
 25481 00003775 E8AD00                  	call	path_crunch	; pcrunch (EXECPATH, pathinfo)
 25482 00003778 89C5                    	mov	bp,ax		; save filetype code
 25483 0000377A 9F                      	lahf			; save flags, just in case
 25484 0000377B 09ED                    	or	bp,bp		; did path_crunch find anything?
 25485 0000377D 7508                    	jnz	short path_found
 25486 0000377F 9E                      	sahf			; see? needed those flags, after all!
 25487 00003780 73F3                    	jnc	short path_loop	; is there anything left to the path?
 25488                                  path_failure:
 25489 00003782 31C0                    	xor	ax,ax
 25490 00003784 E98700                  	jmp	path_exit
 25491                                  
 25492                                  path_found:				; pathinfo[] points to winner
 25493 00003787 BF[3D9D]                	mov	di,EXECPATH
 25494                                  	;mov	cx,pathinfo[4]
 25495 0000378A 8B0E[60A8]              	mov	cx,[pathinfo+4]	; "new" pointer -- end of string
 25496                                  	;mov	si,pathinfo[2]
 25497 0000378E 8B36[5EA8]              	mov	si,[pathinfo+2]	; "old" pointer -- beginning of string
 25498                                  
 25499                                  ;	BAS Nov 20/84
 25500                                  ;   Look at the pathname and expand . and .. if they are the first element
 25501                                  ;   in the pathname (after the drive letter)
 25502                                  
 25503 00003792 06                      	push	es
 25504                                  	;push	pathinfo[0]
 25505 00003793 FF36[5CA8]              	push	word [pathinfo+0]
 25506 00003797 07                      	pop	es
 25507                                  ;SR;
 25508                                  ; Oops! Gets fooled if path= \;..
 25509                                  ; We should also check if a drive letter is really present
 25510                                  ;
 25511 00003798 26807C022E              	cmp	byte [es:si+2],'.'
 25512                                  				; Look for Current dir at start of path
 25513 0000379D 7534                    	jne	short path_cpy
 25514                                  
 25515                                  	; 18/03/2023
 25516                                  	; MSDOS 6.0
 25517 0000379F 26807C013A              	cmp	byte [es:si+1],':'
 25518                                  				; does path have drive letter?
 25519 000037A4 752D                    	jne	short path_cpy	; no, copy the path string
 25520                                  
 25521 000037A6 51                      	push	cx		; Save pointer to end of string
 25522                                  	;mov	al,[es:si]
 25523                                  	;mov	[di],al		; Copy drive letter, :, and root char
 25524                                  	;mov	al,[es:si+1]	; to EXECPATH
 25525                                  	;mov	[di+1],al
 25526                                  	; 05/05/2023
 25527 000037A7 268B04                  	mov	ax,[es:si]
 25528 000037AA 8905                    	mov	[di],ax
 25529 000037AC A0[62A8]                	mov	al,[psep_char]
 25530 000037AF 884502                  	mov	[di+2],	al
 25531 000037B2 56                      	push	si		; Save pointer to begining of string
 25532 000037B3 268A14                  	mov	dl,[es:si]	; Convert device letter for cur dir
 25533 000037B6 80CA20                  	or	dl,20h
 25534                                  	;sub	dl,60h
 25535 000037B9 80EA60                  	sub	dl,'a'-1
 25536 000037BC 89FE                    	mov	si,di		; pointer to EXECPATH
 25537 000037BE 83C603                  	add	si,3		; Don't wipe out drive and root info
 25538 000037C1 B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25539 000037C4 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25540                                  			; DL = drive (0=default,1=A,etc.)
 25541                                  			; DS:SI	points to 64-byte buffer area
 25542 000037C6 E8F3F9                  	call	dstrlen		; Determine length of present info
 25543 000037C9 01CE                    	add	si,cx		; Don't copy over drive and root info
 25544 000037CB 4E                      	dec	si
 25545 000037CC 89F7                    	mov	di,si		; Point to end of target string
 25546 000037CE 5E                      	pop	si		; Restore pointer to begining of string
 25547 000037CF 83C603                  	add	si,3		; Point past drive letter, :, .
 25548 000037D2 59                      	pop	cx		; Restore pointer to end of string
 25549                                  path_cpy:
 25550 000037D3 07                      	pop	es
 25551 000037D4 29F1                    	sub	cx,si		; yields character count
 25552 000037D6 1E                      	push	ds		; time to switch segments
 25553 000037D7 FF36[5CA8]              	push	word [pathinfo+0]
 25554                                  				; string lives in this segment
 25555 000037DB 1F                      	pop	ds
 25556 000037DC FC                      	cld
 25557                                  
 25558                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25559                                  	; MSDOS 5.0 (& MSDOS 5.0)
 25560                                  	;;rep	movsb ; 3/3/KK	; copy the prefix path into EXECPATH
 25561                                  kloop:
 25562 000037DD AC                      	lodsb			;AN000;  3/3/KK
 25563 000037DE AA                      	stosb			;AN000;  3/3/KK
 25564 000037DF E82DF1                  	call	testkanj	;AN000;  3/3/KK
 25565 000037E2 7410                    	jz	short _notkanj1	;AN000;  3/3/KK
 25566 000037E4 49                      	dec	cx		;AN000;  3/3/KK
 25567 000037E5 E307                    	jcxz	popdone		;AN000;  Ignore boundary error 3/3/KK
 25568 000037E7 A4                      	movsb			;AN000;  3/3/KK
 25569 000037E8 49                      	dec	cx		;AN000;  3/3/KK
 25570 000037E9 83F901                  	cmp	cx,1		;AN000;  One char (the terminator) left ? 3/3/KK
 25571 000037EC 77EF                    	ja	short kloop	;AN000;  no.  3/3/KK
 25572                                  popdone:			;AN000;  3/3/KK
 25573 000037EE 1F                      	pop	ds		;AN000;  Yes ES:DI->terminator, last char is 3/3/KK
 25574 000037EF A0[62A8]                	mov	al,[psep_char]	;AN000;  KANJI 3/3/KK
 25575 000037F2 EB0C                    	jmp	short path_store
 25576                                  				;AN000;  3/3/KK
 25577                                  _notkanj1:
 25578                                  	; 26/04/2023
 25579 000037F4 E2E7                    	loop	kloop
 25580 000037F6 1F                      	pop	ds		; return to our segment
 25581 000037F7 4F                      	dec	di		; overwrite terminator
 25582 000037F8 A0[62A8]                	mov	al,[psep_char]	; with a pathname separator
 25583 000037FB 3A45FF                  	cmp	al,[di-1]
 25584 000037FE 7401                    	je	short path_success
 25585                                  path_store:
 25586 00003800 AA                      	stosb
 25587                                  path_success:
 25588 00003801 BE[64A8]                	mov	si,search_best_buf
 25589 00003804 31C9                    	xor	cx,cx
 25590                                  path_succ_loop:
 25591 00003806 AC                      	lodsb			; append winning filename to path
 25592 00003807 AA                      	stosb			; (including terminating null)
 25593 00003808 08C0                    	or	al,al
 25594 0000380A 75FA                    	jnz	short path_succ_loop
 25595 0000380C 89E8                    	mov	ax,bp		; retrieve filetype code
 25596                                  path_exit:
 25597 0000380E 9D                      	popf
 25598 0000380F 5D                      	pop	bp
 25599 00003810 5F                      	pop	di
 25600 00003811 5E                      	pop	si		; chill out...
 25601 00003812 5A                      	pop	dx
 25602 00003813 59                      	pop	cx
 25603 00003814 5B                      	pop	bx
 25604 00003815 C3                      	retn
 25605                                  
 25606                                  ; =============== S U B	R O U T	I N E =======================================
 25607                                  
 25608                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 25609                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 25610                                  ;
 25611                                  ; ENTRY:
 25612                                  ; EXIT:
 25613                                  ; NOTE(S):
 25614                                  ;   *	Uses <psep_char>, defined in <path_search>.
 25615                                  
 25616                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25617                                  STORE_PCHAR:
 25618 00003816 50                      	push	ax
 25619 00003817 B02F                    	mov	al,'/'		; is the pathname-element separator
 25620 00003819 E8A0F3                  	call	pathchrcmp	; a regular slash?
 25621 0000381C 7402                    	jz	short STORE_SLASH
 25622                                  				; if yes, remember slash
 25623 0000381E B05C                    	mov	al,'\'
 25624                                  	; 18/03/2023
 25625                                  	;mov	[psep_char],al	; otherwise, remember back-slash
 25626                                  	;pop	ax
 25627                                  	;retn
 25628                                  STORE_SLASH:
 25629 00003820 A2[62A8]                	mov	[psep_char],al
 25630 00003823 58                      	pop	ax
 25631 00003824 C3                      	retn
 25632                                  
 25633                                  ; =============== S U B	R O U T	I N E =======================================
 25634                                  
 25635                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 25636                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 25637                                  ; additional separator to use for breaking up the path-string. Null is the
 25638                                  ; default. Once the user-string has been formed, search is invoked to see
 25639                                  ; what's out there.
 25640                                  ;
 25641                                  ; ENTRY:
 25642                                  ;   BH			--	additional terminator character
 25643                                  ;   SI			--	pointer into pathstring to be dissected
 25644                                  ;   DX			--	pointer to stripped filename
 25645                                  ; EXIT:
 25646                                  ;   AX			--	non-zero (file type), zero (nothing found)
 25647                                  ;   SI			--	moves along pathstring from call to call
 25648                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 25649                                  ;   [tpbuf]		--	clobbered
 25650                                  ; NOTE(S):
 25651                                  ;   *	Implicit in this code is the ability to specify when to search
 25652                                  ;	the current directory (if at all) through the PATH defined by
 25653                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 25654                                  ;	current directory before the bin and etc directories of drive c).
 25655                                  
 25656                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25657                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3454h
 25658                                  
 25659                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25660                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:39FEh
 25661                                  	
 25662                                  path_crunch:
 25663 00003825 53                      	push	bx
 25664 00003826 51                      	push	cx
 25665 00003827 52                      	push	dx
 25666 00003828 57                      	push	di
 25667 00003829 56                      	push	si
 25668                                  	;pushf	; ** ; 18/03/2023
 25669 0000382A E8E9FF                  	call	STORE_PCHAR	; figure out pathname separator
 25670 0000382D BF[ADA7]                	mov	di,TPBUF	; destination of concatenated string
 25671 00003830 8B36[60A8]              	mov	si,[pathinfo+4]	; "new" pointer to start with
 25672 00003834 8936[5EA8]              	mov	[pathinfo+2],si	; becomes "old" pointer
 25673 00003838 1E                      	push	ds		; save old segment pointer
 25674 00003839 FF36[5CA8]              	push	word [pathinfo+0]
 25675                                  				; replace with pointer to userpath's
 25676 0000383D 1F                      	pop	ds		; segment
 25677                                  	; 26/04/2023
 25678 0000383E 30C9                    	xor	cl,cl		;AN000; clear flag for later use 3/3/KK
 25679                                  path_cr_copy:
 25680 00003840 AC                      	lodsb			; get a pathname byte
 25681 00003841 08C0                    	or	al,al		; check for terminator(s)
 25682 00003843 7414                    	jz	short path_seg	; null terminates segment & pathstring
 25683 00003845 38F8                    	cmp	al,bh
 25684 00003847 7410                    	je	short path_seg	; BH terminates a pathstring segment
 25685                                  	;
 25686                                  	; 18/03/2023
 25687                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 25688 00003849 E8C3F0                  	call	testkanj	;AN000; 3/3/KK
 25689 0000384C 7406                    	jz	short _notkanj2	;AN000; 3/3/KK
 25690 0000384E AA                      	stosb			;AN000; 3/3/KK
 25691 0000384F A4                      	movsb			;AN000; 3/3/KK
 25692 00003850 B101                    	mov	cl,1 ; *	;AN000; CL=1 means latest stored char is DBCS 3/3/KK
 25693 00003852 EBEC                    	jmp	short path_cr_copy
 25694                                  _notkanj2:
 25695 00003854 30C9                    	xor	cl,cl ; *	;AN000; CL=0 means latest stored char is SBCS 3/3/KK
 25696                                  	;
 25697 00003856 AA                      	stosb
 25698 00003857 EBE7                    	jmp	short path_cr_copy
 25699                                  
 25700                                  path_seg:
 25701 00003859 1F                      	pop	ds		; restore old data segment
 25702 0000385A 8936[60A8]              	mov	[pathinfo+4],si	; save "new" pointer for next time
 25703 0000385E 88C3                    	mov	bl,al		; remember if we saw null or not...
 25704                                  				;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 25705 00003860 31C0                    	xor	ax,ax		; in case nothing in pathstr...
 25706 00003862 81FF[ADA7]              	cmp	di,TPBUF	; was there really anything in pathstr?
 25707 00003866 7421                    	je	short path_cr_leave
 25708                                  				; if nothing was copied, pathstr empty
 25709                                  path_cr_look:
 25710 00003868 A0[62A8]                	mov	al,[psep_char]	; form complete pathname
 25711                                  	;
 25712                                  	; 18/03/2023
 25713                                  	; MSDOS 6.0
 25714 0000386B 08C9                    	or	cl,cl ; *	;AN000; 3/3/KK
 25715 0000386D 7505                    	jnz	short path_cr_store
 25716                                  				;AN000; this is a trailing byte of ECS code 3/3/KK
 25717                                  	;
 25718 0000386F 3A45FF                  	cmp	al,[di-1]	; add pathname separator for suffix
 25719 00003872 7401                    	je	short path_cr_l1
 25720                                  path_cr_store:
 25721 00003874 AA                      	stosb
 25722                                  path_cr_l1:
 25723 00003875 89D6                    	mov	si,dx
 25724                                  path_cr_l2:
 25725 00003877 AC                      	lodsb			; tack the stripped filename onto
 25726 00003878 AA                      	stosb			; the end of the path, up to and
 25727 00003879 08C0                    	or	al,al		; including the terminating null
 25728 0000387B 75FA                    	jnz	short path_cr_l2
 25729 0000387D BA[ADA7]                	mov	dx,TPBUF	; and look for an appropriate file...
 25730 00003880 C706[B1A8][4B93]        	mov	word [search_error],BADPMES_PTR
 25731                                  	;invoke search
 25732 00003886 E80900                  	call	PSEARCH		; results are in AX & search_best_buf
 25733                                  
 25734                                  	; 18/03/2023
 25735                                  ;path_cr_leave:
 25736                                  	;or	bl,bl		; did we finish off the pathstring?
 25737                                  	;jz	short path_cr_empty
 25738                                  	;			; null in BL means all gone...
 25739                                  	;popf	; **		; otherwise, plenty left
 25740                                  	;clc
 25741                                  	;jmp	short path_cr_exit
 25742                                  ;path_cr_empty:
 25743                                  	;popf	; **
 25744                                  	;stc
 25745                                  ;path_cr_exit:
 25746                                  
 25747                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25748                                  path_cr_leave:
 25749                                  	;popf ; ** ; 18/03/2023
 25750 00003889 80FB01                  	cmp	bl,1	; if bl = 0 -> cf = 1 (path_cr_empty:)
 25751                                  
 25752                                  path_cr_exit:
 25753 0000388C 5E                      	pop	si
 25754 0000388D 5F                      	pop	di
 25755 0000388E 5A                      	pop	dx
 25756 0000388F 59                      	pop	cx
 25757 00003890 5B                      	pop	bx
 25758 00003891 C3                      	retn
 25759                                  
 25760                                  ;============================================================================
 25761                                  ; PATH2.ASM, MSDOS 6.0, 1991
 25762                                  ;============================================================================
 25763                                  ; 02/10/2018 - Retro DOS v3.0
 25764                                  
 25765                                  ;----------------------------------------------------------------------------
 25766                                  ;   SEARCH, when given a pathname, attempts to find a file with
 25767                                  ; one of the following extensions: .com, .exe, .bat (highest to
 25768                                  ; lowest priority). Where conflicts arise, the extension with
 25769                                  ; the highest priority is favored.
 25770                                  ; ENTRY:
 25771                                  ;   DX		--	pointer to null-terminated pathname
 25772                                  ;   fbuf	--	dma buffer for findfirst/next
 25773                                  ; EXIT:
 25774                                  ;   AX		--	8)  file found with .com extension
 25775                                  ;			4)  file found with .exe extension
 25776                                  ;			2)  file found with .bat extension
 25777                                  ;			0)  no such file to be found
 25778                                  ;   (if AX is non-zero:)
 25779                                  ;   [search_best]	identical to AX
 25780                                  ;   [search_best_buf]	null-terminated filename
 25781                                  ; NOTES:
 25782                                  ;   1) Requires caller to have allocated a dma buffer and executed a setdma.
 25783                                  ;---------------
 25784                                  ; CONSTANTS:
 25785                                  ;---------------
 25786                                  SEARCH_FILE_NOT_FOUND	EQU	0
 25787                                  SEARCH_COM		EQU	8
 25788                                  SEARCH_EXE		EQU	4
 25789                                  SEARCH_BAT		EQU	2
 25790                                  FNAME_LEN		EQU	8
 25791                                  FNAME_MAX_LEN		EQU	13
 25792                                  DOT			EQU	'.'
 25793                                  WILDCHAR		EQU	'?'
 25794                                  
 25795                                  
 25796                                  ; =============== S U B	R O U T	I N E =======================================
 25797                                  
 25798                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 25799                                  
 25800                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25801                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:34C9h
 25802                                  
 25803                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25804                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:3A73h
 25805                                  PSEARCH:
 25806 00003892 51                      	push	cx
 25807 00003893 52                      	push	dx
 25808 00003894 57                      	push	di
 25809 00003895 56                      	push	si
 25810                                  	;pushf	; ** ; 18/03/2023
 25811 00003896 52                      	push	dx		; check drivespec (save pname ptr)
 25812 00003897 89D7                    	mov	di,dx		; working copy of pathname
 25813 00003899 BE[71A8]                	mov	si,search_curdir_buf
 25814 0000389C 31D2                    	xor	dx,dx		; zero means current drive
 25815 0000389E 807D013A                	cmp	byte [di+1],':'	; is there a drive spec?
 25816 000038A2 7508                    	jne	short SEARCH_DIR_CHECK
 25817 000038A4 8A15                    	mov	dl,[di]		; get the drive byte
 25818 000038A6 80E2DF                  	and	dl,0DFh ; ~20h	; uppercase the sucker
 25819 000038A9 80EA40                  	sub	dl,'@' ; 40h	; and convert to drive number
 25820                                  SEARCH_DIR_CHECK:
 25821 000038AC B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25822 000038AF CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25823                                  			; DL = drive (0=default,1=A,etc.)
 25824                                  			; DS:SI	points to 64-byte buffer area
 25825 000038B1 5A                      	pop	dx		; directory? If we can't we'll
 25826 000038B2 724C                    	jc	short SEARCH_INVALID_DRIVE
 25827                                  				; assume it's a bad drive...
 25828 000038B4 B91300                  	mov	cx,search_attr	; 13h
 25829                                  				; filetypes to search for
 25830 000038B7 B8004E                  	mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 25831 000038BA CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 25832                                  			; CX = search attributes
 25833                                  			; DS:DX	-> ASCIZ filespec
 25834                                  			; (drive,path, and wildcards allowed)
 25835 000038BC 7249                    	jc	short SEARCH_NO_FILE
 25836 000038BE C606[63A8]00            	mov	byte [search_best],SEARCH_FILE_NOT_FOUND ; 0
 25837 000038C3 C606[64A8]00            	mov	byte [search_best_buf],ANULL
 25838                                  				; 0 ; nothing's been found, yet
 25839                                  SEARCH_LOOP:
 25840 000038C8 E84300                  	call	SEARCH_FTYPE	; determine if .com, &c...
 25841 000038CB 3A06[63A8]              	cmp	al,[search_best]
 25842                                  				; better than what we've found so far?
 25843 000038CF 7E13                    	jle	short SEARCH_NEXT
 25844                                  				; no, look for another
 25845 000038D1 A2[63A8]                	mov	[search_best],al
 25846                                  				; found something... save its code
 25847                                  	;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 25848                                  	;mov	si,FBUF_PNAME
 25849 000038D4 BE[4FA8]                	mov	si,FBUF+FIND_BUF.PNAME ; FBUF+30
 25850 000038D7 BF[64A8]                	mov	di,search_best_buf
 25851 000038DA B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25852 000038DD FC                      	cld
 25853 000038DE F3A4                    	rep	movsb		; save complete pathname representation
 25854 000038E0 3C08                    	cmp	al,SEARCH_COM	; 8
 25855                                  				; have we found the best of all?
 25856 000038E2 740A                    	je	short SEARCH_DONE
 25857                                  SEARCH_NEXT:			; keep on looking
 25858 000038E4 B91300                  	mov	cx,search_attr ; 13h
 25859 000038E7 B8004F                  	mov	ax,Find_Next*256 ; 4F00h ; next match
 25860 000038EA CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 25861                                  			; [DTA]	= data block from
 25862                                  			; last AH = 4Eh/4Fh call
 25863 000038EC 73DA                    	jnc	short SEARCH_LOOP
 25864                                  SEARCH_DONE:			; it's all over with...
 25865 000038EE A0[63A8]                	mov	al,[search_best]
 25866                                  				; pick best to return with
 25867                                  	; 18/03/2023
 25868                                  	; MSDOS 6.0
 25869 000038F1 803E[1DA2]01            	cmp	byte [ext_entered],1
 25870                                  				;AN005; Did user request a specific ext?
 25871 000038F6 7411                    	je	short SEARCH_EXIT
 25872                                  				;AN005; no - exit
 25873 000038F8 A0[1DA2]                	mov	al,[ext_entered]
 25874                                  				;AN005; yes - get the real file type back
 25875 000038FB A2[63A8]                	mov	[search_best],al
 25876                                  				;AN005; save the real file type
 25877                                  	;
 25878 000038FE EB09                    	jmp	short SEARCH_EXIT
 25879                                  
 25880                                  SEARCH_INVALID_DRIVE:		; Tell the user path/drive
 25881 00003900 8B16[B1A8]              	mov	dx,[search_error]
 25882                                  				; appropriate error message
 25883 00003904 E8261C                  	call	std_printf	; and pretend no file found
 25884                                  
 25885                                  SEARCH_NO_FILE:			; couldn't find a match
 25886                                  	;mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 25887                                  	; 18/03/2023
 25888 00003907 31C0                    	xor	ax,ax
 25889                                  SEARCH_EXIT:
 25890                                  	;popf	; ** ; 18/03/2023
 25891 00003909 5E                      	pop	si
 25892 0000390A 5F                      	pop	di
 25893 0000390B 5A                      	pop	dx
 25894 0000390C 59                      	pop	cx
 25895 0000390D C3                      	retn
 25896                                  
 25897                                  ; =============== S U B	R O U T	I N E =======================================
 25898                                  
 25899                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 25900                                  ;
 25901                                  ; ENTRY:
 25902                                  ;   fbuf    --	dma buffer containing filename
 25903                                  ; EXIT:
 25904                                  ;   AX	    --	file code, as given in search header
 25905                                  ; NOTE(S):
 25906                                  ;   *	Implicit assumption that NULL == search_file_not_found
 25907                                  
 25908                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25909                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25910                                  SEARCH_FTYPE:
 25911 0000390E 57                      	push	di
 25912 0000390F 56                      	push	si
 25913                                  	;mov	ax,ANULL ; 0	; find the end of the filename
 25914                                  	; 18/02/2023
 25915 00003910 31C0                    	xor	ax,ax ; ax = 0		
 25916                                  	;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 25917                                  	;mov	di,FBUF_PNAME
 25918 00003912 BF[4FA8]                	mov	di,FBUF+FIND_BUF.PNAME ; FBUF+1Eh
 25919 00003915 B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25920 00003918 FC                      	cld
 25921 00003919 F2AE                    	repnz	scasb		; search for the terminating null
 25922 0000391B 7535                    	jnz	short FTYPE_EXIT
 25923                                  				; weird... no null byte at end
 25924 0000391D 83EF05                  	sub	di,5		; . + E + X + T + NULL
 25925                                  
 25926                                  	; Compare .COM
 25927                                  
 25928 00003920 BE[7697]                	mov	si,comext ; ".COM"
 25929 00003923 89F8                    	mov	ax,di
 25930 00003925 A7                      	cmpsw
 25931 00003926 7508                    	jnz	short FTYPE_EXE
 25932 00003928 A7                      	cmpsw
 25933 00003929 7505                    	jnz	short FTYPE_EXE
 25934                                  	;mov	ax,8
 25935 0000392B B80800                  	mov	ax,SEARCH_COM	; success!
 25936 0000392E EB22                    	jmp	short FTYPE_EXIT
 25937                                  
 25938                                  	; Compare .EXE
 25939                                  FTYPE_EXE:			; still looking... now for '.exe'
 25940 00003930 89C7                    	mov	di,ax
 25941 00003932 BE[7A97]                	mov	si,exeext ; ".EXE"
 25942 00003935 A7                      	cmpsw
 25943 00003936 7508                    	jnz	short FTYPE_BAT
 25944 00003938 A7                      	cmpsw
 25945 00003939 7505                    	jnz	short FTYPE_BAT
 25946                                  	;mov	ax,4
 25947 0000393B B80400                  	mov	ax,SEARCH_EXE	; success!
 25948 0000393E EB12                    	jmp	short FTYPE_EXIT
 25949                                  
 25950                                  	; Compare .BAT
 25951                                  FTYPE_BAT:			; still looking... now for '.bat'
 25952 00003940 89C7                    	mov	di,ax
 25953 00003942 BE[7E97]                	mov	si,batext ; ".BAT"
 25954 00003945 A7                      	cmpsw
 25955 00003946 7508                    	jnz	short FTYPE_FAIL
 25956 00003948 A7                      	cmpsw
 25957 00003949 7505                    	jnz	short FTYPE_FAIL
 25958                                  	;mov	ax,2
 25959 0000394B B80200                  	mov	ax,SEARCH_BAT	; success!
 25960 0000394E EB02                    	jmp	short FTYPE_EXIT
 25961                                  
 25962                                  FTYPE_FAIL:			; file doesn't match what we need
 25963                                  	;mov	ax,ANULL ; 0
 25964                                  	; 18/03/2023
 25965 00003950 29C0                    	sub	ax,ax  ; ax = 0
 25966                                  FTYPE_EXIT:
 25967                                  	; 18/03/2023
 25968                                  	; MSDOS 6.0
 25969 00003952 803E[1DA2]01            	cmp	byte [ext_entered],1
 25970                                  				;AN005; was an extension entered?
 25971 00003957 740A                    	jz	short FTYPE_DONE
 25972                                  				;AN005; no - exit
 25973                                  	;cmp	ax,ANULL	;AN005; was any match found
 25974 00003959 21C0                    	and	ax,ax  ; ax = 0 ?
 25975 0000395B 7406                    	jz	short FTYPE_DONE
 25976                                  				;AN005; no - exit
 25977 0000395D A2[1DA2]                	mov	[ext_entered],al
 25978                                  				;AN005; save the match type found
 25979 00003960 B80800                  	mov	ax,SEARCH_COM	;AN005; send back best was found to stop search
 25980                                  FTYPE_DONE:
 25981 00003963 5E                      	pop	si
 25982 00003964 5F                      	pop	di
 25983 00003965 C3                      	retn
 25984                                  
 25985                                  ; =============== S U B	R O U T	I N E =======================================
 25986                                  
 25987                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 25988                                  ; replacing any extension with wildcards.
 25989                                  ;
 25990                                  ; ENTRY:
 25991                                  ;	BX	--	maximum length of destination buffer
 25992                                  ;	DS:SI	--	address of destination buffer
 25993                                  ;	argv[0] --	command name to be stripped
 25994                                  ; EXIT:
 25995                                  ;	CF	--	set if failure, clear if successful
 25996                                  ; NOTE(S):
 25997                                  
 25998                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25999                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 26000                                  STRIP:
 26001 00003966 50                      	push	ax
 26002 00003967 53                      	push	bx
 26003 00003968 51                      	push	cx
 26004 00003969 52                      	push	dx
 26005 0000396A 57                      	push	di
 26006 0000396B 56                      	push	si
 26007                                  	;pushf	; ** ; 18/03/2023
 26008                                  		
 26009                                  	; 05/05/2023
 26010                                  	; MSDOS 6.0
 26011 0000396C C606[1DA2]01            	mov	byte [ext_entered],1
 26012                                  				;AN005; assume no extension on file name
 26013                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26014                                  	;mov	dx,[ARG_ARGV]
 26015                                  	;mov	dx,ds:arg.argv[0].argpointer
 26016                                  				; save pointer to beginning of argstring
 26017                                  	;mov	dx,[ARGV0_ARGPOINTER]
 26018 00003971 8B16[67A2]              	mov	dx,[ARG+ARGV_ELE.argpointer]
 26019                                  	;mov	di,ds:arg.argv[0].argstartel
 26020                                  				; beginning of last pathname element
 26021                                  	;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 26022 00003975 8B3E[6AA2]              	mov	di,[ARG+ARGV_ELE.argstartel]
 26023 00003979 803D00                  	cmp	byte [di],0	; *STARTEL == NULL means no command
 26024 0000397C 743D                    	je	short STRIP_ERROR
 26025 0000397E 89D1                    	mov	cx,dx		; compute where end of argstring lies
 26026                                  	;add	cx,ds:arg.argv[0].arglen
 26027                                  	;add	cx,[ARGV0_ARGLEN]
 26028 00003980 030E[6CA2]              	add	cx,[ARG+ARGV_ELE.arglen]
 26029 00003984 29F9                    	sub	cx,di		; and then find length of last element
 26030 00003986 41                      	inc	cx		; include null as well
 26031 00003987 B02E                    	mov	al,'.'
 26032                                  	;mov	al,DOT		; let's find the filetype extension
 26033 00003989 FC                      	cld
 26034 0000398A F2AE                    	repnz	scasb		; wind up pointing to either null or dot
 26035                                  
 26036                                  	; 18/03/2023
 26037                                  	; MSDOS 6.0
 26038 0000398C E307                    	jcxz	PROCESS_EXT	;AN005; if no extension found, just continue
 26039 0000398E B000                    	mov	al,0 ; 18/03/2023
 26040                                  	;mov	byte [ext_entered],0
 26041 00003990 A2[1DA2]                	mov	[ext_entered],al
 26042                                  				;AN005; we found an extension
 26043                                  	;;mov	al,ANULL	;AN005; continue scanning until the
 26044                                  	;mov	al,0
 26045 00003993 F2AE                    	repnz	scasb		;AN005; end of line is reached.
 26046                                  PROCESS_EXT:
 26047                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26048 00003995 89F9                    	mov	cx,di		; pointer to end of argstring yields
 26049 00003997 29D1                    	sub	cx,dx		; number of bytes to be copied
 26050 00003999 83EB04                  	sub	bx,4		; can argstring fit into dest. buffer?
 26051 0000399C 39D9                    	cmp	cx,bx
 26052 0000399E 7F1B                    	jg	short STRIP_ERROR
 26053                                  				; if not, we must have a bad pathname
 26054 000039A0 89F7                    	mov	di,si		; destination buffer
 26055 000039A2 89D6                    	mov	si,dx		; source is beginning of pathname
 26056 000039A4 FC                      	cld
 26057 000039A5 F3A4                    	rep	movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 26058                                  
 26059                                  	; 18/03/2023
 26060                                  	; MSDOS 6.0
 26061 000039A7 803E[1DA2]01            	cmp	byte [ext_entered],1
 26062                                  				;AN005; if an extension was entered
 26063 000039AC 750A                    	jne	short SKIP_WILDS ; cf = 1 ; 12/06/2023
 26064                                  				;AN005;    don't set up wildcard ext.
 26065                                  
 26066                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26067 000039AE 4F                      	dec	di		; overwrite null or dot
 26068 000039AF AA                      	stosb			; with a dot
 26069 000039B0 B03F                    	mov	al,'?'
 26070                                  	;mov	al,WILDCHAR	; now add wildcards
 26071 000039B2 AA                      	stosb
 26072 000039B3 AA                      	stosb
 26073 000039B4 AA                      	stosb
 26074 000039B5 B000                    	mov	al,0
 26075                                  	;mov	al,ANULL	; and a terminating null	
 26076 000039B7 AA                      	stosb
 26077                                  SKIP_WILDS:
 26078                                  	;popf	; ** ; 18/03/2023
 26079 000039B8 F8                      	clc
 26080 000039B9 EB01                    	jmp	short STRIP_EXIT ; chill out...
 26081                                  
 26082                                  STRIP_ERROR:
 26083                                  	;popf	; ** ; 18/03/2023
 26084 000039BB F9                      	stc
 26085                                  STRIP_EXIT:
 26086 000039BC 5E                      	pop	si
 26087 000039BD 5F                      	pop	di
 26088 000039BE 5A                      	pop	dx
 26089 000039BF 59                      	pop	cx
 26090 000039C0 5B                      	pop	bx
 26091 000039C1 58                      	pop	ax
 26092 000039C2 C3                      	retn
 26093                                  
 26094                                  ; =============== S U B	R O U T	I N E =======================================
 26095                                  
 26096                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 26097                                  ;
 26098                                  ; structure in newly allocated memory. The argv[] structure is found at the
 26099                                  ; beginning of this area. The caller indicates how much extra space is
 26100                                  ; needed in the resulting structure; Save_Args returns a segment number and
 26101                                  ; an offset into that area, indicating where the caller may preserve its own
 26102                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 26103                                  ; ENTRY:
 26104                                  ;   BX	    --	size (in bytes) of extra area to allocate
 26105                                  ; EXIT:
 26106                                  ;   AX	    --	segment of new area.
 26107                                  ;   CF	    --	set if unable to save a copy.
 26108                                  ; NOTE(S):
 26109                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 26110                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 26111                                  ;	paragraphs.
 26112                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 26113                                  ;	as the caller of Save_Args requests.
 26114                                  ;   3)	AX is undefined if CF indicates an error.
 26115                                  
 26116                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26117                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 26118                                  SAVE_ARGS:
 26119 000039C3 53                      	push	bx
 26120 000039C4 51                      	push	cx
 26121 000039C5 52                      	push	dx
 26122 000039C6 57                      	push	di
 26123 000039C7 56                      	push	si
 26124 000039C8 55                      	push	bp
 26125                                  	; 01/05/2023
 26126                                  	; 26/04/2023
 26127                                  	;pushf ; **
 26128                                  	;add	bx,1363		; space for arg structure, round up
 26129 000039C9 81C35304                	add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 26130                                  			; 1092+15 ; 31/07/2024
 26131 000039CD B104                    	mov	cl,4		; to paragraph size and convert
 26132 000039CF D3EB                    	shr	bx,cl		; size in bytes to size in paragraphs
 26133 000039D1 B80048                  	mov	ax,ALLOC*256 ; 4800h
 26134 000039D4 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 26135                                  			; BX = number of 16-byte paragraphs desired
 26136 000039D6 7242                    	jc	short SAVE_ERROR ; ***
 26137 000039D8 89C5                    	mov	bp,ax		; save segment id
 26138 000039DA 06                      	push	es		; save TRANGROUP address
 26139 000039DB 8EC0                    	mov	es,ax		; switch to new memory segment
 26140                                  	; assume es:nothing
 26141                                  	;mov	cx,1348		; get back structure size
 26142 000039DD B94404                  	mov	cx,ARG_UNIT.SIZE ; 1092 ; 31/07/2024
 26143 000039E0 31FF                    	xor	di,di		; destination is new memory area
 26144                                  	;mov	si,ARG_ARGV
 26145 000039E2 BE[67A2]                	mov	si,ARG		; source is arg structure
 26146 000039E5 F3A4                    	rep	movsb		; move that sucker!
 26147                                  	;mov	cx,arg.argvcnt 	; adjust argv pointers
 26148                                  	;mov	cx,[ARG_ARGVCNT]
 26149 000039E7 8B0E[27A5]              	mov	cx,[ARG+ARG_UNIT.argvcnt]
 26150 000039EB 31C0                    	xor	ax,ax		; base address for argv_calc
 26151                                  
 26152                                  ;	Bugbug:	What did they mean by this?
 26153                                  ;	Note that the replacement line produces exactly the same code.
 26154                                  ;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 26155                                  ;	mov	SI, OFFSET TRANGROUP:arg
 26156                                  
 26157                                  	;mov	si,ARG_ARGV
 26158 000039ED BE[67A2]                	mov	si,ARG	
 26159                                  SAVE_PTR_LOOP:
 26160 000039F0 49                      	dec	cx		; exhausted all args?
 26161 000039F1 7C24                    	jl	short SAVE_DONE
 26162 000039F3 89CB                    	mov	bx,cx		; get arg index and
 26163 000039F5 E8A6FC                  	call	argv_calc	; convert to a pointer
 26164                                  	;mov	dx,ds:arg.argv[bx].argpointer
 26165                                  	;mov	dx,[ARG_ARGV+bx]
 26166 000039F8 8B97[67A2]              	mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 26167 000039FC 29F2                    	sub	dx,si		; adjust argpointer
 26168                                  	;mov	es:argv[BX].argpointer,dx
 26169                                  	;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 26170 000039FE 268917                  	mov	[es:bx],dx
 26171                                  	;mov	dx,ds:arg.argv[bx].argstartel
 26172                                  	;mov	dx,[ARGV0_ARGSTARTEL+bx]
 26173 00003A01 8B97[6AA2]              	mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 26174 00003A05 29F2                    	sub	dx,si		; and adjust argstartel
 26175                                  	;mov	es:argv[bx].argstartel,dx
 26176                                  	;mov	[es:bx+3],dx
 26177 00003A07 26895703                	mov	[es:bx+ARGV_ELE.argstartel],dx
 26178                                  	;mov	dx,ds:arg.argv[bx].arg_ocomptr
 26179                                  	;mov	dx,[ARGV0_OCOMPTR+bx]
 26180 00003A0B 8B97[70A2]              	mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 26181 00003A0F 29F2                    	sub	dx,si		; and adjust arg_ocomptr
 26182                                  	;mov	es:argv[bx].arg_ocomptr,dx
 26183                                  	;mov	[es:bx+9],dx
 26184 00003A11 26895709                	mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 26185 00003A15 EBD9                    	jmp	short SAVE_PTR_LOOP
 26186                                  SAVE_DONE:
 26187 00003A17 07                      	pop	es		; back we go to TRANGROUP
 26188                                  	; assume es:nothing
 26189 00003A18 89E8                    	mov	ax,bp		; restore segment id
 26190                                  	; 26/04/2023
 26191                                  	; cf = 0 ; *
 26192                                  	;jmp	short SAVE_OK
 26193                                  
 26194                                  	; 26/04/2023
 26195                                  ;SAVE_ERROR:
 26196                                  ;	; 26/04/2023
 26197                                  ;	;popf ; **
 26198                                  ;	stc
 26199                                  ;	jmp	short SAVE_EXIT
 26200                                  
 26201                                  SAVE_OK:
 26202                                  	; 26/04/2023
 26203                                  	;popf ; **
 26204                                  	; 26/04/2023
 26205                                  	; cf = 0 ; *
 26206                                  	;clc
 26207                                  SAVE_EXIT:
 26208                                  SAVE_ERROR:	; 26/04/2023 (cf=1) ; ***
 26209 00003A1A 5D                      	pop	bp
 26210 00003A1B 5E                      	pop	si
 26211 00003A1C 5F                      	pop	di
 26212 00003A1D 5A                      	pop	dx
 26213 00003A1E 59                      	pop	cx
 26214 00003A1F 5B                      	pop	bx
 26215                                  answ_no:	; 26/04/2023
 26216 00003A20 C3                      	retn
 26217                                  
 26218                                  ;============================================================================
 26219                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 26220                                  ;============================================================================
 26221                                  ; 02/10/2018 - Retro DOS v3.0
 26222                                  
 26223                                  ; Title	COMMAND Language midifiable Code Transient
 26224                                  
 26225                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 26226                                  
 26227                                  ; =============== S U B	R O U T	I N E =======================================
 26228                                  
 26229                                  ; ****************************************************************
 26230                                  ; *
 26231                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 26232                                  ; *
 26233                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 26234                                  ; *		 user for Y/N if necessary. If an error occurs,
 26235                                  ; *		 set up an error message and go to CERROR.
 26236                                  ; *
 26237                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 26238                                  ; *		 Current directory set to entered directory
 26239                                  ; *
 26240                                  ; * OUTPUT:	 none
 26241                                  ; *
 26242                                  ; ****************************************************************
 26243                                  ;
 26244                                  ; ARE YOU SURE prompt when deleting *.*
 26245                                  
 26246                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26247                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 26248                                  notest2:
 26249 00003A21 B90B00                  	mov	cx,11
 26250 00003A24 BE5D00                  	mov	si,FCB+1 ; 5Dh
 26251                                  ambspec:
 26252 00003A27 AC                      	lodsb
 26253 00003A28 3C3F                    	cmp	al,'?'
 26254 00003A2A 7502                    	jne	short allfil
 26255 00003A2C E2F9                    	loop	ambspec
 26256                                  allfil:
 26257                                  	; 19/03/2023
 26258                                  	;cmp	cx,0
 26259 00003A2E 09C9                    	or	cx,cx
 26260 00003A30 752E                    	jnz	short noprmpt
 26261                                  askagn:	
 26262 00003A32 BA[D292]                	mov	dx,SureMes_Ptr	; "Are you sure (Y/N)?"
 26263 00003A35 E8F51A                  	call	std_printf
 26264 00003A38 BE8000                  	mov	si,80h
 26265 00003A3B 89F2                    	mov	dx,si
 26266 00003A3D C7047800                	mov	word [si],120	; zero length
 26267                                  	;mov	ax,0C0Ah
 26268 00003A41 B80A0C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8)|Std_Con_String_Input
 26269 00003A44 CD21                    	int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 26270                                  			; AL must be 01h,06h,07h,08h or 0Ah.
 26271 00003A46 AD                      	lodsw
 26272 00003A47 08E4                    	or	ah,ah
 26273 00003A49 74E7                    	jz	short askagn
 26274 00003A4B E8E0F0                  	call	scanoff
 26275                                  	; 19/03/2023
 26276                                  	; MSDOS 6.0
 26277 00003A4E E80C02                  	call	char_in_xlat	; Convert to upper case
 26278                                  	;retc			; return if function not supported
 26279                                  	; 19/03/2023
 26280                                  	;jnc	short check_yn
 26281                                  ;answ_no:
 26282                                  	;retn
 26283 00003A51 72CD                    	jc	short answ_no
 26284                                  
 26285                                  	; 19/03/2023
 26286                                  	; AL = 0 if it was (country depended) NO character
 26287                                  	; AL = 1 if it was (country depenced) YES character
 26288                                  
 26289                                  	; MSDOS 3.3
 26290                                  	;call	UPCONV
 26291                                  
 26292                                  	; 19/03/2023	
 26293                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26294                                  	;cmp	al,[CAPITAL_N]
 26295                                  	;jne	short CHECK_Y
 26296                                  	;retn
 26297                                  ;CHECK_Y:
 26298                                  	;cmp	al,[CAPITAL_Y]
 26299                                  	;pushf
 26300                                  	;call	CRLF2
 26301                                  	;popf
 26302                                  	;jne	short ASKAGN
 26303                                  
 26304                                  check_yn:
 26305                                  	; 19/03/2023
 26306                                  	;cmp	al,0	; NO character
 26307 00003A53 08C0                    	or	al,al
 26308 00003A55 74C9                    	jz	short answ_no
 26309                                  	;cmp	al,1	 ;YES character
 26310 00003A57 FEC8                    	dec	al ; 1 -> 0 --> zf = 1
 26311 00003A59 9C                      	pushf
 26312 00003A5A E8C4F0                  	call	CRLF2
 26313 00003A5D 9D                      	popf
 26314 00003A5E 75D2                    	jnz	short askagn
 26315                                  noprmpt:
 26316 00003A60 B413                    	mov	ah,FCB_Delete ; 13h
 26317 00003A62 BA5C00                  	mov	dx,FCB ; 5Ch
 26318 00003A65 CD21                    	int	21h	; DOS -	DELETE FILE via	FCB
 26319                                  			; DS:DX	-> FCB with filename field filled with
 26320                                  			; template for deletion ('?' wildcard allowed,but not '*')
 26321                                  			; Return: AL = 00h file	found,FFh file	not found
 26322 00003A67 FEC0                    	inc	al
 26323 00003A69 7403                    	jz	short eraerr
 26324                                  	; 26/04/2023
 26325                                  	;call	RestUDir
 26326                                  ;answ_no:
 26327                                  	;retn
 26328 00003A6B E970EF                  	jmp	RestUDir ; 26/04/2023
 26329                                  
 26330                                  	; 19/03/2023
 26331                                  	; MSDOS 6.0
 26332                                  eraerr:
 26333                                  	;invoke	set_ext_error_msg
 26334                                  				;AN022; set up the extended error
 26335 00003A6E E8C1E7                  	call	Set_Ext_Error_Msg
 26336 00003A71 52                      	push	dx		;AN022; save message
 26337                                  	;invoke	RESTUDIR
 26338 00003A72 E869EF                  	call	RestUDir
 26339 00003A75 5A                      	pop	dx		;AN022; restore message
 26340                                  	
 26341 00003A76 833E[F391]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 26342                                  				;AN022; convert no more files to
 26343 00003A7B 7506                    	jne	short cerrorj2	;AN022;  file not found
 26344 00003A7D C706[F391]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2  
 26345                                  				;AN000; get message number in control block
 26346                                  cerrorj2:
 26347 00003A83 E91CF4                  	jmp	cerror
 26348                                  	
 26349                                  	; 19/03/2023
 26350                                  	; MSDOS 3.3
 26351                                  ;ERAERR:	
 26352                                  	;mov	ah,Set_DMA ; 1Ah
 26353                                  	;mov	dx,FCB ; 5Ch
 26354                                  	;int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 26355                                  	;			; DS:DX	-> disk	transfer buffer
 26356                                  	;mov	ah,Dir_Search_First ; 11h
 26357                                  	;int	21h		; DOS -	SEARCH FIRST USING FCB
 26358                                  	;			; DS:DX	-> FCB
 26359                                  	;push	ax
 26360                                  	;call	RESTUDIR
 26361                                  	;pop	ax
 26362                                  	;mov	dx,FNOTFOUNDPTR
 26363                                  	;inc	al
 26364                                  	;jz	short CERRORJ
 26365                                  	;mov	dx,ACCDENPTR
 26366                                  	;jmp	CERROR
 26367                                  
 26368                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26369                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:36D4h
 26370                                  
 26371                                  ; ****************************************************************
 26372                                  ; *
 26373                                  ; * ROUTINE:	 SLASHP_ERASE - execution of DEL/ERASE /P
 26374                                  ; *
 26375                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 26376                                  ; *		 user for Y/N where necessary. If an error occurs
 26377                                  ; *		 set up and error message and transfer control
 26378                                  ; *		 to CERROR.
 26379                                  ; *
 26380                                  ; * INPUT:	 FCB at 5Ch set up with filename(s) entered
 26381                                  ; *		 Current directory set to entered directory
 26382                                  ; *
 26383                                  ; * OUTPUT:	 none
 26384                                  ; *
 26385                                  ; ****************************************************************
 26386                                  
 26387                                  	; 19/03/2023
 26388                                  slashp_erase:				;AN000; entry point
 26389                                  	;invoke	build_dir_string	;AN000; set up current directory string for output
 26390 00003A86 E813E9                  	call	build_dir_string
 26391                                  
 26392 00003A89 B41A                    	mov	ah,Set_DMA ; 1Ah	;AN000; issue set dta int 21h
 26393                                  	;mov	dx,offset trangroup:destdir
 26394 00003A8B BA[0DA0]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 26395 00003A8E CD21                    	int	21h			;AN000;
 26396                                  
 26397                                  	;mov	ah,11h
 26398 00003A90 B411                    	mov	ah,Dir_Search_First	;AN000; do dir search first int 21h
 26399 00003A92 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000; use FCB at 5Ch for target
 26400 00003A95 CD21                    	int	21h			;AN000;
 26401 00003A97 FEC0                    	inc	al			;AN000; did an error occur
 26402                                  	;jz	short eraerr		;AN022; go to error exit
 26403                                  	; 26/04/2023
 26404 00003A99 7502                    	jnz	short delete_prompt_loop
 26405                                  
 26406                                  	; 26/04/2023
 26407                                  stop_del:
 26408 00003A9B EBD1                    	jmp	short eraerr		;AN022; go to error exit - need long jmp
 26409                                  
 26410                                  delete_prompt_loop:			;AN000;
 26411                                  	;mov	si,offset trangroup:destdir+1
 26412 00003A9D BE[0EA0]                	mov	si,DESTDIR+1		;AN000; set up FCB as source
 26413                                  	;mov	di,offset trangroup:dest
 26414 00003AA0 BF[DD9F]                	mov	di,DEST			;AN000; set up dest as target
 26415 00003AA3 A0[1A9E]                	mov	al,[DIRCHAR]		;AN000; store a "\" in the first char
 26416 00003AA6 AA                      	stosb				;AN000;   of DEST
 26417                                  	;invoke	FCB_TO_ASCZ		;AN000; convert filename from FCB to ASCIIZ string
 26418 00003AA7 E8A3F0                  	call	FCB_TO_ASCZ
 26419                                  
 26420                                  slashp_askagn:				;AN000;
 26421 00003AAA E874F0                  	call	CRLF2			;AN000; print out carriage return, line feed
 26422                                  	;mov	dx,offset trangroup:bwdbuf
 26423 00003AAD BA[50A0]                	mov	dx,BWDBUF		;AN000; print out current directory string
 26424 00003AB0 89D3                    	mov	bx,dx			;AN000; get string pointer in bx
 26425 00003AB2 807F0300                	cmp	byte [bx+3],END_OF_LINE_OUT ; 0
 26426                                  					;AN000; see if only D:\,0
 26427 00003AB6 7504                    	jnz	short not_del_root	;AN000; no continue
 26428 00003AB8 C6470200                	mov	byte [bx+2],END_OF_LINE_OUT ; 0
 26429                                  					;AN000; yes, get rid of \ ;
 26430                                  not_del_root:				;AN000;
 26431 00003ABC 8916[B7A0]              	mov	[string_ptr_2],dx 	;AN000;
 26432                                  	;mov	dx,offset trangroup:string_buf_ptr
 26433 00003AC0 BA[BA93]                	mov	dx,string_buf_ptr	;AN000;
 26434                                  	;invoke	std_printf		;AN000;
 26435 00003AC3 E8671A                  	call	std_printf
 26436                                  	;mov	dx,offset trangroup:dest
 26437 00003AC6 BA[DD9F]                	mov	dx,DEST			;AN000; print out file name string
 26438 00003AC9 8916[B7A0]              	mov	[string_ptr_2],dx 	;AN000;
 26439                                  	;mov	dx,offset trangroup:string_buf_ptr
 26440 00003ACD BA[BA93]                	mov	dx,string_buf_ptr	;AN000;
 26441                                  	;invoke	std_printf		;AN000;
 26442 00003AD0 E85A1A                  	call	std_printf
 26443                                  	;mov	dx,offset trangroup:Del_Y_N_Ptr
 26444 00003AD3 BA[CF92]                	mov	dx,Del_Y_N_Ptr		;AN000; issue ", Delete (Y/N)?" message
 26445                                  	;invoke	std_printf		;AN000;
 26446 00003AD6 E8541A                  	call	std_printf
 26447                                  
 26448                                  ;;M029	mov	si,80H			;AN000; set up buffer for input
 26449                                  ;;M029	mov	dx,si			;AN000;
 26450                                  ;;M029	mov	word ptr [si],combuflen ;AN000;
 26451                                  ;;M029	mov	ax,(std_con_input_flush shl 8) or std_con_string_input	;AN000;
 26452                                  ;;M029	int	21h			;AN000; get input from the user
 26453                                  ;;M029	lodsw				;AN000;
 26454                                  ;;M029	or	ah,ah			;AN000; was a character entered?
 26455                                  ;;M029	jz	short slashp_askagn	;AN000; no - ask again
 26456                                  ;;M029	invoke	scanoff 		;AN000; scan off leading delimiters
 26457                                  
 26458                                  ;	Get a single character input.
 26459                                  
 26460                                  	;;mov	ax,(STD_CON_INPUT_FLUSH shl 8) or STD_CON_INPUT	;M029
 26461                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT
 26462 00003AD9 B8010C                  	mov	ax,0C01h
 26463 00003ADC CD21                    	int	21h			;M029
 26464                                  
 26465 00003ADE E87C01                  	call	char_in_xlat		;AN000; yes - upper case it
 26466                                  	;retc				;AN000; return if function not supported
 26467                                  	; 19/03/2023
 26468 00003AE1 7301                    	jnc	short slashp_check_yn
 26469                                  slashp_ans_no:
 26470 00003AE3 C3                      	retn
 26471                                  
 26472                                  slashp_check_yn:
 26473                                  	; 19/03/2023
 26474                                  	; AL = 0 if it was (country depended) NO character
 26475                                  	; AL = 1 if it was (country depenced) YES character
 26476                                  
 26477                                  	;cmp	al,capital_n		;AN000; was it no?
 26478                                  	;cmp	al,0
 26479 00003AE4 20C0                    	and	al,al ; 0
 26480 00003AE6 7420                    	jz	short next_del_file	;AN000; yes - don't delete file
 26481                                  	;cmp	al,capital_y		;AN000; was it yes?
 26482                                  	;cmp	al,1
 26483 00003AE8 FEC8                    	dec	al  ; 1-> 0 --> zf = 1
 26484                                  	;jz	short delete_this_file	;AN000; yes - delete the file
 26485                                  	;jmp	short slashp_askagn	;AN000; it was neither - ask again
 26486                                  	; 19/03/2023
 26487 00003AEA 75BE                    	jnz	short slashp_askagn
 26488                                  
 26489                                  delete_this_file:			;AN000;
 26490 00003AEC B413                    	mov	ah,FCB_Delete ; 13h	;AN000; delete the file
 26491                                  	;mov	dx,offset trangroup:destdir
 26492 00003AEE BA[0DA0]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 26493 00003AF1 CD21                    	int	21h			;AN000;
 26494 00003AF3 FEC0                    	inc	al			;AN000; did an error occur?
 26495 00003AF5 7511                    	jnz	short next_del_file	;AN000; no - get next file
 26496                                  ;
 26497                                  ;M041; Begin changes
 26498                                  ; We got an error deleting the file. If this is access denied, we can go on
 26499                                  ;to the next file after printing an error message.
 26500                                  ;
 26501                                  	;invoke	Get_ext_error_number	;see what error we got
 26502 00003AF7 E848E7                  	call	get_ext_error_number
 26503 00003AFA 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 26504                                  					;is it access denied?
 26505 00003AFD 759C                    	jne	short stop_del		;no, some other error
 26506                                  	;invoke	CrLf2			;print a CR-LF
 26507 00003AFF E81FF0                  	call	CRLF2
 26508                                  	;invoke set_ext_error_msg	;error message
 26509 00003B02 E82DE7                  	call	Set_Ext_Error_Msg
 26510                                  	;invoke	std_eprintf		;"Access denied"
 26511 00003B05 E81D1A                  	call	std_eprintf
 26512                                  	; 26/04/2023
 26513                                  	;jmp	short next_del_file	;try next file
 26514                                  	; 26/04/2023
 26515                                  ;stop_del:
 26516                                  ;;
 26517                                  ;;M041; End changes
 26518                                  ;;
 26519                                  ;	jmp	eraerr			;AN022; go to error exit - need long jmp
 26520                                  
 26521                                  next_del_file:				;AN000;
 26522                                  ;
 26523                                  ; M050 - begin
 26524                                  ; 	Norton Utilities 5.0 has a bug. DiskMon when invoked
 26525                                  ;       with /protect+ and /light+ makes it intercept all
 26526                                  ;       deletes. This hook does not save and restore the DTA correctly.
 26527                                  ;       They save the DWORD in a WORD by mistake! They save both the
 26528                                  ;       segment and the offset in the SAME variable (WORD)!!!
 26529                                  ;
 26530 00003B08 B41A                    	mov	ah,Set_DMA ; 1Ah
 26531                                  	;mov	dx,offset trangroup:destdir
 26532 00003B0A BA[0DA0]                	mov	dx,DESTDIR
 26533 00003B0D CD21                    	int	21h
 26534                                  ;
 26535                                  ; M050 - end
 26536                                  
 26537 00003B0F B412                    	mov	ah,Dir_Search_Next ; 12h
 26538                                  					;AN000; search for another file
 26539 00003B11 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000;
 26540 00003B14 CD21                    	int	21h			;AN000;
 26541 00003B16 FEC0                    	inc	al			;AN000; was a file found?
 26542                                  	;jz	short slash_p_exit	;AN000; no - exit
 26543                                  	;jmp	delete_prompt_loop	;AN000; yes - continue (need long jump)
 26544                                  	; 26/04/2023
 26545 00003B18 7583                    	jnz	short delete_prompt_loop
 26546                                  
 26547                                  slash_p_exit:
 26548                                  	;invoke	get_ext_error_number	;AN022; get the extended error number
 26549 00003B1A E825E7                  	call	get_ext_error_number
 26550 00003B1D 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	;AN022; was error file not found?
 26551 00003B20 7403                    	jz	short good_erase_exit 	;AN022; yes - clean exit
 26552 00003B22 E960E4                  	jmp	extend_setup		;AN022; go issue error message
 26553                                  
 26554                                  good_erase_exit:
 26555                                  	;invoke	restudir		;AN000; we're finished - restore user's dir
 26556 00003B25 E8B6EE                  	call	RestUDir
 26557                                  	;call	CRLF2			;AN000; print out carriage return, line feed
 26558                                  	;retn				;AN000; exit
 26559                                  	; 19/03/2023
 26560 00003B28 E9F6EF                  	jmp	CRLF2
 26561                                  
 26562                                  ; =============== S U B	R O U T	I N E =======================================
 26563                                  
 26564                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 26565                                  
 26566                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26567                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 26568                                  _ECHO:
 26569 00003B2B E89900                  	call	ON_OFF
 26570 00003B2E 7212                    	jb	short DOEMES
 26571 00003B30 8E1E[159E]              	mov	ds,[RESSEG]
 26572 00003B34 7506                    	jnz	short ECH_OFF
 26573 00003B36 800E[3B02]01            	or	byte [EchoFlag],1
 26574 00003B3B C3                      	retn
 26575                                  
 26576                                  ECH_OFF:
 26577 00003B3C 8026[3B02]FE            	and	byte [EchoFlag],0FEh
 26578 00003B41 C3                      	retn
 26579                                  
 26580                                  	; 19/03/2023
 26581                                  	; MSDOS 6.0 (& MSDOS 5.0)
 26582                                  ;CERRORJ:
 26583                                  	;jmp	cerror
 26584                                  
 26585                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 26586                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 26587                                  
 26588                                  DOEMES:
 26589                                  	; 19/03/2023
 26590                                  	; MSDOS 6.0
 26591                                  	;cmp	cl,0		;AC000; was anything on the line?
 26592 00003B42 20C9                    	and	cl,cl
 26593 00003B44 7409                    	jz	short PECHO	; just display current state.
 26594 00003B46 BA8200                  	mov	dx,82h		; Skip one char after "ECHO"
 26595 00003B49 E82EF0                  	call	CRPRINT
 26596 00003B4C E9D2EF                  	jmp	CRLF2
 26597                                  
 26598                                  	; 19/03/2023
 26599                                  	; MSDOS 3.3
 26600                                  	;call	MOVE_TO_FIRST_ARG
 26601                                  	;jz	short PECHO
 26602                                  	;mov	dx,82h
 26603                                  	;call	CRPRINT
 26604                                  	;jmp	CRLF2
 26605                                  
 26606                                  PECHO:
 26607                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26608 00003B4F 8E1E[159E]              	mov	ds,[RESSEG]
 26609 00003B53 8A1E[3B02]              	mov	bl,[EchoFlag]
 26610 00003B57 0E                      	push	cs
 26611 00003B58 1F                      	pop	ds
 26612 00003B59 80E301                  	and	bl,1
 26613 00003B5C BA[7693]                	mov	dx,EchoMes_Ptr
 26614 00003B5F EB24                    	jmp	short PYN
 26615                                  
 26616                                  ; ---------------------------------------------------------------------------
 26617                                  
 26618                                  	; 19/03/2023
 26619                                  	; MSDOS 3.3
 26620                                  CERRORJ:
 26621 00003B61 E93EF3                  	jmp	cerror
 26622                                  
 26623                                  ; =============== S U B	R O U T	I N E =======================================
 26624                                  
 26625                                  	; 19/03/2023
 26626                                  	; MSDOS 3.3
 26627                                  ;MOVE_TO_FIRST_ARG:
 26628                                  	;mov	si,81h
 26629                                  	;call	SCANOFF
 26630                                  	;cmp	al,0Dh
 26631                                  	;retn
 26632                                  
 26633                                  ; =============== S U B	R O U T	I N E =======================================
 26634                                  
 26635                                  CNTRLC:
 26636 00003B64 E86000                  	call	ON_OFF
 26637 00003B67 B80133                  	mov	ax,(Set_CTRL_C_Trapping<<8)|1 ; 3301h
 26638 00003B6A 720C                    	jc	short PCNTRLC
 26639 00003B6C 7505                    	jnz	short CNTRLC_OFF
 26640 00003B6E B201                    	mov	dl,1
 26641 00003B70 CD21                    	int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 26642                                  			; AL = 00h get state / 01h set state / 02h set AND get
 26643                                  			; DL = 00h for OFF or 01h for ON
 26644 00003B72 C3                      	retn
 26645                                  
 26646                                  ; ---------------------------------------------------------------------------
 26647                                  
 26648                                  CNTRLC_OFF:
 26649 00003B73 30D2                    	xor	dl,dl
 26650 00003B75 CD21                    	int	21h		; Turn off ^C check
 26651 00003B77 C3                      	retn
 26652                                  
 26653                                  ; ---------------------------------------------------------------------------
 26654                                  
 26655                                  PCNTRLC:
 26656                                  	; 19/03/2023
 26657                                  	; MSDOS 6.0
 26658                                  	;cmp	cl,0		;AC000; rest of line blank?
 26659 00003B78 08C9                    	or	cl,cl
 26660 00003B7A 75E5                    	jnz	short CERRORJ 	; no, oops!
 26661                                  
 26662                                  	; 19/03/2023
 26663                                  	; MSDOS 3.3
 26664                                  	;call	MOVE_TO_FIRST_ARG
 26665                                  	;jnz	short CERRORJ
 26666                                  ;pccont:
 26667                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26668 00003B7C 30C0                    	xor	al,al
 26669 00003B7E CD21                    	int	21h		; get Ctrl-Break state (ah=33h)
 26670 00003B80 88D3                    	mov	bl,dl
 26671 00003B82 BA[5A93]                	mov	dx,CtrlcMes_Ptr
 26672                                  
 26673                                  ; ---------------------------------------------------------------------------
 26674                                  
 26675                                  PYN:	; write "ON" or "OFF" state 
 26676                                  
 26677                                  	; 26/04/2023
 26678                                  	; 19/03/2023
 26679                                  	; MSDOS 3.3
 26680                                  	;call	STD_PRINTF
 26681                                  	;mov	dx,ONMES_PTR	;AC000; get ON pointer
 26682                                  	;or	bl,bl
 26683                                  	;jnz	short PRINTVAL
 26684                                  	;mov	dx,OFFMES_PTR	;AC000; get OFF pointer
 26685                                  	
 26686                                  	; 26/04/2023
 26687                                  	; 19/03/2023
 26688                                  	; MSDOS 6.0
 26689 00003B85 BE[8793]                	mov	si,ONMES_PTR
 26690 00003B88 08DB                    	or	bl,bl
 26691 00003B8A 7503                    	jnz	short PRINTVAL
 26692 00003B8C BE[8493]                	mov	si,OFFMES_PTR
 26693                                  PRINTVAL:
 26694                                  	; 19/03/2023
 26695                                  	; MSDOS 3.3
 26696                                  	;jmp	STD_PRINTF
 26697                                  
 26698                                  	; 19/03/2023
 26699                                  	; MSDOS 6.0
 26700 00003B8F 52                      	push	dx		;AN000; save offset of message block
 26701 00003B90 89D3                    	mov	bx,dx		;AN000; save offset value
 26702 00003B92 AD                      	lodsw			;AN000; get message number of on or off
 26703 00003B93 B6FF                    	mov	dh,util_msg_class ; -1 ; 0FFh
 26704                                  				;AN000; this is a utility message
 26705 00003B95 E87A1A                  	call	TSYSGETMSG	;AN000; get the address of the message
 26706                                  	;add	bx,5
 26707 00003B98 83C305                  	add	bx,Ptr_off_pos	;AN000; point to offset of ON/OFF
 26708                                  	
 26709 00003B9B 8937                    	mov	[bx],si		;AN000; put the offset in the message block
 26710 00003B9D 5A                      	pop	dx		;AN000; get message back
 26711 00003B9E E88C19                  	call	std_printf	;AC000; go print message
 26712 00003BA1 C7070000                	mov	word [bx],0	;AN000; zero out message pointer
 26713 00003BA5 C3                      	retn			;AN000; exit
 26714                                  
 26715                                  ; =============== S U B	R O U T	I N E =======================================
 26716                                  
 26717                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.CO
 26718                                  VERIFY:
 26719 00003BA6 E81E00                  	call	ON_OFF
 26720 00003BA9 B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 26721 00003BAC 720A                    	jc	short PVERIFY
 26722 00003BAE 7503                    	jnz	short VER_OFF
 26723 00003BB0 CD21                    	int	21h	; DOS -	SET VERIFY FLAG
 26724                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 26725 00003BB2 C3                      	retn
 26726                                  
 26727                                  ; ---------------------------------------------------------------------------
 26728                                  
 26729                                  VER_OFF:
 26730 00003BB3 FEC8                    	dec	al
 26731 00003BB5 CD21                    	int	21h		; Turn off verify after write
 26732 00003BB7 C3                      	retn
 26733                                  
 26734                                  ; ---------------------------------------------------------------------------
 26735                                  
 26736                                  PVERIFY:
 26737                                  	; 19/03/2023
 26738                                  	; MSDOS 6.0
 26739                                  	;cmp	cl,0		;AC000; is rest of line blank?
 26740 00003BB8 20C9                    	and	cl,cl
 26741 00003BBA 75A5                    	jnz	short CERRORJ 	; nope...
 26742                                  
 26743                                  	 ;19/03/2023
 26744                                  	; MSDOS 3.3
 26745                                  	;call	MOVE_TO_FIRST_ARG
 26746                                  	;jnz	short CERRORJ
 26747                                  
 26748 00003BBC B454                    	mov	ah,Get_Verify_On_Write ; 54h
 26749 00003BBE CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 26750                                  				; Return: AL = 00h if flag OFF
 26751                                  				; AL = 01h if flag ON
 26752 00003BC0 88C3                    	mov	bl,al
 26753 00003BC2 BA[6893]                	mov	dx,VeriMes_Ptr
 26754 00003BC5 EBBE                    	jmp	short PYN
 26755                                  
 26756                                  ; =============== S U B	R O U T	I N E =======================================
 26757                                  
 26758                                  ; ****************************************************************
 26759                                  ; *
 26760                                  ; * ROUTINE:	 ON_OFF
 26761                                  ; *
 26762                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 26763                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 26764                                  ; *		 routines.
 26765                                  ; *
 26766                                  ; * INPUT:	 command line at offset 81H
 26767                                  ; *		 PARSE_BREAK control block
 26768                                  ; *
 26769                                  ; * OUTPUT:	 If carry is clear
 26770                                  ; *		    If ON is found
 26771                                  ; *		       Zero flag set
 26772                                  ; *		    If OFF is found
 26773                                  ; *		       Zero flag clear
 26774                                  ; *		 If carry set
 26775                                  ; *		    If nothing on command line
 26776                                  ; *		       CL set to zero
 26777                                  ; *		    If error
 26778                                  ; *		       CL contains error value from parse
 26779                                  ; *
 26780                                  ; ****************************************************************
 26781                                  
 26782                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26783                                  ON_OFF:
 26784 00003BC7 BE8100                  	mov	si,81h
 26785                                  
 26786                                  	; 19/03/2023
 26787                                  	; MSDOS 3.3
 26788                                  	;call	SCANOFF		; scan off leading blanks & equal
 26789                                  	;cmp	al,0Dh		; are we at end of line?
 26790                                  	;je	short BAD_ONF	; yes, return error
 26791                                  	;lodsw
 26792                                  	;or	ax,2020h	; convert to lowercase
 26793                                  	;cmp	ax,6E6Fh ;'on'
 26794                                  	;je	short ON_CHECK
 26795                                  	;cmp	ax,666Fh ;'of'
 26796                                  	;jne	short BAD_ONF
 26797                                  	;lodsb
 26798                                  	;or	al,20h		; convert to lowercase		
 26799                                  	;cmp	al,66h	 ; 'f'
 26800                                  	;jne	short BAD_ONF	
 26801                                  	;or	al,66h ; or al,'f'
 26802                                  	;jmp	short OFF_CHECK
 26803                                  ;ON_CHECK:
 26804                                  	;xor	al,al
 26805                                  ;OFF_CHECK:
 26806                                  	;lahf
 26807                                  	;mov	bx,ax
 26808                                  	;call	SCANOFF		; scan off leading blanks & equal
 26809                                  	;cmp	al,0Dh		; are we at end of line?	
 26810                                  	;jne	short BAD_ONF	; no, return error
 26811                                  	;mov	ax,bx
 26812                                  	;sahf
 26813                                  	;clc
 26814                                  	;retn
 26815                                  
 26816                                  	; 19/03/2023
 26817                                  	; MSDOS 6.0
 26818                                  scan_on_off:			;AN032; scan off leading blanks & equal
 26819 00003BCA AC                      	lodsb			;AN032; get a char
 26820                                  	;cmp	al,blank	;AN032; if whitespace
 26821 00003BCB 3C20                    	cmp	al,20h
 26822 00003BCD 74FB                    	je	short scan_on_off
 26823                                  				;AN032;    keep scanning
 26824 00003BCF 3C09                    	cmp	al,tab_chr	;AN032; if tab
 26825                                  	;cmp	al,09h
 26826 00003BD1 74F7                    	je	short scan_on_off
 26827                                  				;AN032;    keep scanning
 26828                                  	;cmp	al,equal_chr	;AN032; if equal char
 26829 00003BD3 3C3D                    	cmp	al,'=' ; 3Dh
 26830 00003BD5 7401                    	je	short parse_on_off
 26831                                  				;AN032;    start parsing
 26832 00003BD7 4E                      	dec	si		;AN032; if none of above - back up
 26833                                  
 26834                                  parse_on_off:			;AN032;    and start parsing
 26835 00003BD8 BF[C397]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 26836 00003BDB 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 26837 00003BDD 31D2                    	xor	dx,dx		;AN000;
 26838 00003BDF E87A0E                  	call	cmd_parse	;AC000; call parser
 26839                                  	;cmp	ax,-1 ; 0FFFFh
 26840 00003BE2 83F8FF                  	cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 26841 00003BE5 742E                    	je	short BADONF	;AC000; yes, return error
 26842                                  	;cmp	ax,RESULT_NO_ERROR ;AN000; did an error occur
 26843                                  	;cmp	ax,0
 26844 00003BE7 21C0                    	and	ax,ax ; ax = 0 ?
 26845 00003BE9 7404                    	jz	short on_off_there
 26846                                  				;AN000; no - continue
 26847 00003BEB 89C1                    	mov	cx,ax		;AN000; yes - set cl to error code
 26848 00003BED EB26                    	jmp	short BADONF	;AN000; return error
 26849                                  
 26850                                  on_off_there:
 26851 00003BEF 803E[08AA]FF            	cmp	byte [PARSE1_CODE],-1 ; 0FFh
 26852                                  				;AN014; was a valid positional present?
 26853 00003BF4 7505                    	jnz	short good_on_off
 26854                                  				;AN014; yes - continue
 26855 00003BF6 B90A00                  	mov	cx,BadParm_Ptr	;AN014; something other than ON/OFF
 26856                                  	;mov	cx,10 ; 0Ah
 26857 00003BF9 EB1A                    	jmp	short BADONF	;AN014; return error
 26858                                  
 26859                                  good_on_off:			;AN014;
 26860 00003BFB 31C0                    	xor	ax,ax		;AC000; set up return code for
 26861 00003BFD 0A06[08AA]              	or	al,[PARSE1_CODE]
 26862                                  				;AC000;    ON or OFF in AX
 26863 00003C01 9C                      	pushf			;AN000; save flags
 26864 00003C02 BF[C397]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 26865 00003C05 31D2                    	xor	dx,dx		;AN000;
 26866 00003C07 E8520E                  	call	cmd_parse	;AN000; call parser
 26867 00003C0A 83F8FF                  	cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 26868                                  	;cmp	ax,-1 ; 0FFFFh
 26869 00003C0D 7503                    	jne	short BADONF_flags
 26870                                  				;AN000; NO, return error
 26871 00003C0F 9D                      	popf			;AN000; restore flags
 26872 00003C10 F8                      	clc			;AC000; no error
 26873                                  	;jmp	short on_off_end
 26874                                  				;AN000; return to caller
 26875                                  	; 26/04/2023
 26876 00003C11 C3                      	retn
 26877                                  
 26878                                  BADONF_flags:
 26879 00003C12 89C1                    	mov	cx,ax
 26880 00003C14 9D                      	popf
 26881                                  
 26882                                  ; ---------------------------------------------------------------------------
 26883                                  
 26884                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 26885                                  ; and return the error
 26886                                  
 26887                                  BADONF:
 26888 00003C15 BA[3793]                	mov	dx,bad_on_off_ptr
 26889 00003C18 F9                      	stc
 26890                                  on_off_end:
 26891 00003C19 C3                      	retn
 26892                                  
 26893                                  ;============================================================================
 26894                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 26895                                  ;============================================================================
 26896                                  ; 02/10/2018 - Retro DOS v3.0
 26897                                  
 26898                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 26899                                  
 26900                                  ; =============== S U B	R O U T	I N E =======================================
 26901                                  
 26902                                  	; 20/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26903                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3876h
 26904                                  	
 26905                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 26906                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:3E20h
 26907                                  PRINT_DATE:
 26908                                  	; 20/03/2023
 26909                                  	; MSDOS 3.3
 26910                                  	;push	es
 26911                                  	;push	di
 26912                                  	;push	cs
 26913                                  	;pop	es
 26914                                  	;mov	di,ARG_BUF
 26915                                  	;mov	ah,Get_Date ; 2Ah
 26916                                  	;int	21h	; DOS -	GET CURRENT DATE
 26917                                  	;		; Return: DL = day,DH = month,	CX = year
 26918                                  	;		; AL = day of the week (0=Sunday,1=Monday,etc.)
 26919                                  	;cbw
 26920                                  	;call	GETDATE
 26921                                  	;call	P_DATE
 26922                                  	;xor	al,al
 26923                                  	;stosb
 26924                                  	;mov	dx,ARG_BUF_PTR
 26925                                  	;call	STD_PRINTF
 26926                                  		; 20/03/2023 (MSDOS 3.3 COMMAND.COM - TRANGROUP:29DAh)
 26927                                  	;pop	es ; !!??!! 
 26928                                  	;pop	di
 26929                                  	;retn
 26930                                  
 26931                                  	; 20/03/2023
 26932                                  	; MSDOS 6.0
 26933 00003C1A 06                      	push	es
 26934 00003C1B 57                      	push	di
 26935 00003C1C 0E                      	push	cs
 26936 00003C1D 07                      	pop	es
 26937 00003C1E E81300                  	call	GetDate 		; get date
 26938 00003C21 86F2                    	xchg	dh,dl			;AN000; switch month & day
 26939 00003C23 890E[F193]              	mov	[promptDat_yr],cx 	;AC000; put year into message control block
 26940 00003C27 8916[F393]              	mov	[promptDat_moday],dx	;AC000; put month and day into message control block
 26941 00003C2B BA[E193]                	mov	dx,promptdat_ptr	;AC000; set up message for output
 26942 00003C2E E8FC18                  	call	std_printf
 26943                                  	;AD061; mov word [promptDat_yr],0 ;AC000; reset year, month and day
 26944                                  	;AD061; mov word [promptDat_moday],0 ;AC000; pointers in control block
 26945 00003C31 5F                      	pop	di			;AC000; restore di,es
 26946 00003C32 07                      	pop	es			;AC000;
 26947 00003C33 C3                      	retn
 26948                                  
 26949                                  ; ---------------------------------------------------------------------------
 26950                                  
 26951                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26952                                  
 26953                                  ;GETDATE:
 26954                                  	; 21/03/2023
 26955                                  	; MSDOS 3.3
 26956                                  	;mov	si,ax
 26957                                  	;shl	si,1
 26958                                  	;add	si,ax
 26959                                  	;add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 26960                                  	;mov	bx,cx
 26961                                  	;mov	cx,3
 26962                                  	;rep	movsb
 26963                                  	;mov	al,' '
 26964                                  	;stosb
 26965                                  	;retn
 26966                                  
 26967                                  	; 21/03/2023
 26968                                  	; MSDOS 6.0
 26969                                  
 26970                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 26971                                  ; for output. Date will be returned in CX,DX.
 26972                                  
 26973                                  GetDate:
 26974 00003C34 BF[ADA7]                	mov	di,Arg_Buf		;AC000; target for day of week
 26975 00003C37 B42A                    	mov	ah,Get_Date ;2Ah	;AC000; get current date
 26976 00003C39 CD21                    	int	21h			;AC000; Get date in CX:DX
 26977 00003C3B 98                      	cbw				;AC000;
 26978 00003C3C 51                      	push	cx			;AN000; save date returned in
 26979 00003C3D 52                      	push	dx			;AN000;  CX:DX
 26980 00003C3E 89C6                    	mov	si,ax
 26981 00003C40 D1E6                    	shl	si,1
 26982 00003C42 01C6                    	add	si,ax			; SI=AX*3
 26983 00003C44 89F1                    	mov	cx,si			;AN000; save si
 26984 00003C46 A1[AA92]                	mov	ax,[WeekTab]		;AN000; get message number of weektab
 26985 00003C49 B6FF                    	mov	dh,util_msg_class ;0FFh	;AN000; this is a utility message
 26986 00003C4B 57                      	push	di			;AN000; save argument buffer
 26987 00003C4C E8C319                  	call	TSYSGETMSG		;AN000; get the address of the message
 26988 00003C4F 5F                      	pop	di			;AN000; retrieve argument buffer
 26989 00003C50 01CE                    	add	si,cx			;AC000; get day of week
 26990 00003C52 B90300                  	mov	cx,3
 26991 00003C55 F3A4                      	rep	movsb
 26992 00003C57 B000                    	mov	al,END_OF_LINE_OUT ; 0	;AC000; terminate the string
 26993 00003C59 AA                      	stosb
 26994 00003C5A 5A                      	pop	dx			;AN000; get back date
 26995 00003C5B 59                      	pop	cx			;AN000;
 26996 00003C5C C3                      	retn
 26997                                  
 26998                                  ; =============== S U B	R O U T	I N E =======================================
 26999                                  
 27000                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27001                                  
 27002                                  	; MSDOS 6.0
 27003                                  
 27004                                  ; This routine determines whether the character in AL is a
 27005                                  ; Yes or No character. On return, if AL=0, the character is
 27006                                  ; No, if AL=1, the character is Yes.
 27007                                  
 27008                                  ;	assume	ds:trangroup
 27009                                  
 27010                                  char_in_xlat:	; proc	near
 27011                                  	; 21/03/2023
 27012 00003C5D 88C2                    	mov	dl,al			;AC000; get character into DX
 27013 00003C5F 30F6                    	xor	dh,dh			;AC000;
 27014                                  	;mov	ax,(GetExtCntry<<8)+35	;AC000; Yes/No char call
 27015 00003C61 B82365                  	mov	ax,6523h
 27016 00003C64 CD21                    	int	21h			;AC000;
 27017 00003C66 C3                      	retn
 27018                                  
 27019                                  ;char_in_xlat	endp
 27020                                  
 27021                                  ;============================================================================
 27022                                  ; TENV.ASM, MSDOS 6.0, 1991
 27023                                  ;============================================================================
 27024                                  ; 02/10/2018 - Retro DOS v3.0
 27025                                  
 27026                                  ;	Environment utilities and misc. routines
 27027                                  
 27028                                  ; MSDOS 6.0
 27029                                  ; ****************************************************************
 27030                                  ; *
 27031                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 27032                                  ; *
 27033                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 27034                                  ; *		 the character in AL from the file upper case table
 27035                                  ; *		 in DOS if character if above  ascii 128, else
 27036                                  ; *		 subtracts 20H if between "a" and "z".
 27037                                  ; *
 27038                                  ; * INPUT:	 AL	      char to be upper cased
 27039                                  ; *		 FUCASE_ADDR  set to the file upper case table
 27040                                  ; *
 27041                                  ; * OUTPUT:	 AL	      upper cased character
 27042                                  ; *
 27043                                  ; ****************************************************************
 27044                                  ;
 27045                                  ;assume	ds:trangroup				;AN000;
 27046                                  ;
 27047                                  ;upconv	proc	near				;AN000;
 27048                                  ;
 27049                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 27050                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 27051                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 27052                                  ;	push	ds				;AN000;
 27053                                  ;	push	bx				;AN000;
 27054                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 27055                                  ;assume	ds:resgroup				;AN000;
 27056                                  ;	lds	bx,dword ptr FUCase_Addr+1	;AN000;  get table address
 27057                                  ;	add	bx,2				;AN000;  skip over first word
 27058                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 27059                                  ;	pop	bx				;AN000;
 27060                                  ;	pop	ds				;AN000;
 27061                                  ;assume	ds:trangroup				;AN000;
 27062                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 27063                                  ;
 27064                                  ;oth_fucase:					;AN000;
 27065                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 27066                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 27067                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 27068                                  ;	ja	upconv_end			;AC000;
 27069                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 27070                                  ;
 27071                                  ;upconv_end:					;AN000;
 27072                                  ;	ret
 27073                                  ;
 27074                                  ;upconv	endp					;AN000;
 27075                                  
 27076                                  ;============================================================================
 27077                                  ; COPY.ASM, MSDOS 6.0, 1991
 27078                                  ;============================================================================
 27079                                  ; 01/10/2018 - Retro DOS v3.0
 27080                                  
 27081                                  ;	title	COMMAND COPY routines.
 27082                                  
 27083                                  ;/*
 27084                                  ; *                      Microsoft Confidential
 27085                                  ; *                      Copyright (C) Microsoft Corporation 1991
 27086                                  ; *                      All Rights Reserved.
 27087                                  ; */
 27088                                  
 27089                                  ;***	COPY.ASM
 27090                                  
 27091                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 27092                                  
 27093                                  
 27094                                  ;***	MODIFICATION HISTORY
 27095                                  
 27096                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 27097                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 27098                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 27099                                  ;	     to tokens which begin with path characters so that PARSELINE
 27100                                  ;	     will work correctly.
 27101                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 27102                                  ;	     individual tokens. That distinction is no longer needed for
 27103                                  ;	     FOR loop processing.
 27104                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent. Flag is
 27105                                  ;	     1 when Cparse is called from COPY.
 27106                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 27107                                  ;	     mod. It now is conditional on flag like previous mod.
 27108                                  ;11/21/83 NP  Added printf
 27109                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 27110                                  ;	     be added to a token.
 27111                                  ;05/30/84 MZ  Initialize all copy variables. Fix confusion with destclosed
 27112                                  ;	     NOTE: DestHand is the destination handle. There are two
 27113                                  ;	     special values: -1 meaning destination was never opened and
 27114                                  ;	     0 which means that the destination has been openned and
 27115                                  ;	     closed.
 27116                                  ;06/01/84 MZ  Above reasoning totally specious. Returned things to normal
 27117                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 27118                                  ;	     lost on large and multiple file (wildcard) copies.
 27119                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 27120                                  ;	     destination are not equal.
 27121                                  ;
 27122                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 27123                                  ;	     first source file AND we run out of disk space before
 27124                                  ;	     completing the concatenation, restore the first source
 27125                                  ;	     file as best we can. See SeekEnd and CopErr. Bug #859.
 27126                                  ;
 27127                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 27128                                  ;		instead of compatibility mode. This gives lesser sharing
 27129                                  ;		violations when files are opened for read on a copy.
 27130                                  
 27131                                  ; ---------------------------------------------------------------------------
 27132                                  ;***	COPY CODE
 27133                                  ; ---------------------------------------------------------------------------
 27134                                  
 27135                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 27136                                  
 27137                                  ; 23/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27138                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 38C3h
 27139                                  
 27140                                  ; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 27141                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 3E6Dh
 27142                                  
 27143                                  COPY:
 27144                                  	; 	Initialize internal variables.
 27145                                  
 27146 00003C67 31C0                    	xor	ax,ax		; AX = 0
 27147 00003C69 A3[B9A0]                	mov	[Copy_num],ax	; # files copied (destinations) = 0
 27148 00003C6C A3[E9A1]                	mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 27149 00003C6F A3[35A1]                	mov	[SrcTail],ax	; ptr to last element of source pathname = 0
 27150 00003C72 A2[349E]                	mov	[CFLAG],al	; 'destination file created' = false
 27151 00003C75 A3[3A9E]                	mov	[NXTADD],ax	; ptr into TPA buffer = 0
 27152 00003C78 A3[309E]                	mov	[DestSwitch],ax	; destination switches = none
 27153 00003C7B A3[0DA2]                	mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 27154 00003C7E A3[D2A0]                	mov	[DestTail],ax	; ptr to last element of dest pathname = 0
 27155 00003C81 A2[359E]                	mov	[DestClosed],al	; 'destination file closed' = false
 27156 00003C84 A2[D1A0]                	mov	[DestSiz],al	; length of destination pathname = 0
 27157 00003C87 A2[34A1]                	mov	[SrcSiz],al	; length of source pathname = 0
 27158 00003C8A A2[D4A0]                	mov	[DestInfo],al	; destination pathname flags = none
 27159 00003C8D A2[37A1]                	mov	[SrcInfo],al	; source pathname flags = none
 27160 00003C90 A2[EBA1]                	mov	[INEXACT],al	; 'inexact copy' = false
 27161 00003C93 A2[D0A0]                	mov	[DestVars],al	; 'dest pathname is directory' = false  ;*!*
 27162 00003C96 A2[33A1]                	mov	[SrcVars],al	; 'source pathname is directory' = false
 27163 00003C99 A2[F79C]                	mov	[USERDIR1],al	; saved working directory = null
 27164 00003C9C A2[ECA1]                	mov	[NOWRITE],al	; 'no write' (source = dest) = false
 27165 00003C9F A2[289E]                	mov	[RDEOF],al	; 'read end of file' = false
 27166 00003CA2 A3[8FA1]                	mov	[SRCHAND],ax	; source handle = 0
 27167 00003CA5 A3[F4A1]                	mov	[CPDATE],ax	; copy date = 0
 27168 00003CA8 A3[F6A1]                	mov	[CPTIME],ax	; copy time = 0
 27169 00003CAB A2[91A1]                	mov	[SRCISDEV],al	; 'source is device' = false
 27170                                  	; 23/03/2023
 27171                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM	
 27172 00003CAE A2[FCA1]                	mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 27173 00003CB1 A3[F8A1]                	mov	[OFilePtr_Lo],ax
 27174 00003CB4 A3[FAA1]                	mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 27175 00003CB7 A2[F0A1]                	mov	[TERMREAD],al	; 'terminate read' = false
 27176 00003CBA A2[ACA0]                	mov	[comma],al	; '"+,," found' = false
 27177 00003CBD A2[ADA0]                	mov	[plus_comma],al ; '"+,," found last time' = false (?)
 27178 00003CC0 A2[4AA2]                	mov	[msg_flag],al	;AN022; 'non-utility msg issued' = false
 27179 00003CC3 A3[329E]                	mov	[AllSwitch],ax	; all switches = none
 27180 00003CC6 A2[2B9E]                	mov	[ArgC],al	; source/dest argument count = 0
 27181 00003CC9 A2[F2A1]                	mov	[PLUS],al	; '"+" in command line' = false
 27182 00003CCC A2[EDA1]                	mov	[BINARY],al	; 'binary copy' = false
 27183 00003CCF A2[F1A1]                	mov	[ASCII],al	; 'ascii copy' = false
 27184 00003CD2 A3[439E]                	mov	[FileCnt],ax	; # files copied (destinations) = 0
 27185 00003CD5 A3[EEA1]                	mov	[WRITTEN],ax	; 'destination written to' = false
 27186 00003CD8 A2[2A9E]                	mov	[Concat],al	; 'concatenating' = false
 27187 00003CDB A2[30A1]                	mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 27188 00003CDE A3[31A1]                	mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0
 27189                                  	
 27190                                  	; 12/06/2023
 27191                                  	; MSDOS 6.22 COMMAND.COM
 27192                                  	; (Disassembled source code by using Hex-Rays IDA disassembler)
 27193 00003CE1 A2[09A2]                	mov     [cox_dest_file], al ; MSDOS 6.22
 27194 00003CE4 A2[0AA2]                	mov     [cox_src_file], al  ; MSDOS 6.22
 27195                                  
 27196                                  	;	Initialize buffers with double-nulls.
 27197                                  
 27198 00003CE7 A3[92A1]                	mov	[ScanBuf],ax
 27199 00003CEA A3[D5A0]                	mov	[DestBuf],ax
 27200 00003CED A3[38A1]                	mov	[SrcBuf],ax
 27201 00003CF0 A3[96A0]                	mov	[SDIRBUF],ax
 27202 00003CF3 A3[50A0]                	mov	[DIRBUF],ax
 27203 00003CF6 A3[0DA0]                	mov	[DestFcb],ax
 27204                                  
 27205 00003CF9 A2[F3A1]                	mov	[objcnt],al	; # CParse cmd-line objects found = 0
 27206                                  		
 27207 00003CFC 48                      	dec	ax ; -1		; AX = 0FFFFh
 27208 00003CFD A3[2CA1]                	mov	[DESTHAND],ax	; destination handle = 'never opened'
 27209 00003D00 A2[3C9E]                	mov	[FRSTSRCH],al	; 'first search for source' = true
 27210 00003D03 A2[2FA1]                	mov	[FIRSTDEST],al	; 'first time for dest' = true
 27211 00003D06 A2[D0A0]                	mov	[DestIsDir],al	; 'haven't analyzed destination' ; *!*
 27212                                  
 27213                                  	; 12/06/2023
 27214                                  	; Retro DOS v4.2 COMMAND.COM
 27215                                  	; MSDOS 6.22 COMMAND.COM code only !
 27216                                  	; (Disassembled source code by using Hex-Rays IDA disassembler)
 27217                                  	;
 27218 00003D09 E8F306                  	call	init_copycmd_option ; MSDOS 6.22 
 27219                                  		
 27220 00003D0C BE8100                  	mov	si,81h		; SI = ptr to command line
 27221                                  	;mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 27222                                  	; 23/03/2023
 27223 00003D0F B32B                    	mov	bl,'+'
 27224 00003D11 FE06[49A2]              	inc	byte [expand_star] ; CParse 'expand * to ?s' = true
 27225 00003D15 C606[BBA0]01            	mov	byte [cpyflag],1 ; CParse 'called from COPY' = true
 27226                                  
 27227                                  	;*	Scan the command line for destination information.
 27228                                  
 27229                                  DESTSCAN:
 27230 00003D1A 31ED                    	xor	bp,bp			; BP = switch flag accumulator
 27231 00003D1C BF[92A1]                	mov	di,ScanBuf		; ES:DI = ptr to pathname buf
 27232                                  	; 23/03/2023
 27233 00003D1F 8936[AFA0]              	mov	[parse_last],si		;AN018; save cmd line ptr
 27234 00003D23 E8710B                  	call	cparse			; parse next object
 27235 00003D26 9C                      	pushf	; (*)			; save CParse flags
 27236 00003D27 FE06[F3A1]              	inc	byte [objcnt]		; count object
 27237 00003D2B F6C780                  	test	bh,80h
 27238 00003D2E 7405                    	jz	short NOCOPY		; no "+" delimiter
 27239 00003D30 C606[F2A1]01            	mov	byte [PLUS],1		; "+" delimiter occurred
 27240                                  NOCOPY:
 27241 00003D35 F6C701                  	test	bh,1
 27242 00003D38 747D                    	jz	short TESTP2		; not a switch
 27243                                  
 27244                                  	;	Found a switch.
 27245                                  
 27246                                  	; 23/03/2023 - Retro DOS v4.0 COMMAND.COM
 27247                                  	;
 27248                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 27249                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:3F43h
 27250                                  CHK_CP_SWITCH:
 27251                                  	; MSDOS 6.0
 27252 00003D3A F7C51000                	test	bp,10h
 27253                                  	;test	bp,SwitchV ; 10h	;AN038; Verify requested?
 27254 00003D3E 740B                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 27255                                  	;test	word [AllSwitch],10h
 27256 00003D40 F606[329E]10            	test	byte [AllSwitch],10h
 27257                                  	;test	byte [AllSwitch],SwitchV ;AN038; Verify already entered?
 27258 00003D45 7404                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 27259                                  ;AD018; ;or	word [AllSwitch],FBadSwitch ;AN038; Set up bad switch
 27260                                  	;or	bp,FBadSwitch		;AN018; Set up bad switch
 27261 00003D47 81CD0040                	or	bp,4000h
 27262                                  NOT_SLASHV:
 27263                                  	; ****************************************
 27264                                  	; 12/06/2023
 27265                                  	; Retro DOS v4.2 COMMAND.COM
 27266                                  	; MSDOS 6.22 COMMAND.COM code only !
 27267                                  	; (Disassembled source code by using Hex-Rays IDA disassembler)
 27268                                  	; ****************************************
 27269                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:3F55h
 27270                                  	;
 27271 00003D4B F7C54000                	test    bp,40h			; negative Y (-Y) switch flag
 27272 00003D4F 7417                    	jz	short CHK_SLASHY0
 27273                                  	;
 27274                                  	;test	word [AllSwitch],40h
 27275 00003D51 F606[329E]40            	test	byte [AllSwitch],40h	; [AllSwitch] negative (-Y) flag
 27276 00003D56 7507                    	jnz	short NOT_SLASHY1	; N flag
 27277                                  	;test	word [AllSwitch],80h
 27278 00003D58 F606[329E]80            	test	byte [AllSwitch],80h	; [AllSwitch] SwitchY (Y) flag
 27279 00003D5D 7404                    	jz	short NOT_SLASHY2
 27280                                  NOT_SLASHY1:
 27281 00003D5F 81CD0040                	or	bp,4000h		; FBadSwitch (Repetitive)
 27282                                  NOT_SLASHY2:				; Set up bad switch
 27283 00003D63 C606[08A2]00            	mov	byte [cox_y_override],0	; cox_y setting will be used
 27284                                  CHK_SLASHY0:
 27285 00003D68 F7C58000                	test    bp,80h
 27286 00003D6C 742B                    	jz      short CHK_SLASHY4	; not a /Y switch
 27287                                  	;
 27288 00003D6E 8A04                    	mov	al,[si]
 27289 00003D70 3C79                    	cmp	al,'y'
 27290 00003D72 740A                    	je	short CHK_SLASHY1
 27291 00003D74 3C59                    	cmp	al,'Y'
 27292 00003D76 7406                    	je	short CHK_SLASHY1
 27293 00003D78 81CD0040                	or	bp,4000h		; FBadSwitch
 27294                                  	;				; Set up bad switch
 27295 00003D7C EB1B                    	jmp	short CHK_SLASHY4
 27296                                  CHK_SLASHY1:
 27297 00003D7E C60420                  	mov	byte [si],20h ; ' '
 27298 00003D81 46                      	inc	si
 27299                                  	;test	word [AllSwitch],40h
 27300 00003D82 F606[329E]40            	test	byte [AllSwitch],40h	; [AllSwitch] negative (-Y) flag
 27301 00003D87 7507                    	jnz	short CHK_SLASHY2	; N flag
 27302                                  	;test	word [AllSwitch],80h
 27303 00003D89 F606[329E]80            	test	byte [AllSwitch],80h	; [AllSwitch] SwitchY (Y) flag
 27304 00003D8E 7404                    	jz	short CHK_SLASHY3
 27305                                  CHK_SLASHY2:
 27306 00003D90 81CD0040                	or	bp,4000h		; FBadSwitch (Repetitive)
 27307                                  	;				; Set up bad switch
 27308                                  CHK_SLASHY3:
 27309 00003D94 C606[08A2]01            	mov	byte [cox_y_override],1
 27310                                  CHK_SLASHY4:
 27311                                  	; ****************************************
 27312                                  	; 12/06/2023
 27313                                  ;NOT_SLASHV:
 27314                                  	;or	[DestSwitch],bp		; assume destination
 27315                                  	;or	[AllSwitch],bp		; keep tabs on all switches
 27316                                  
 27317                                  	; 12/06/2023
 27318                                  	; Retro DOS v4.2 COMMAND.COM
 27319                                  	; MSDOS 6.22 COMMAND.COM -TRANGROUP:3FA7h
 27320 00003D99 092E[309E]              	or	[DestSwitch],bp		; set [DestSwitch] SwitchY flag to 1
 27321 00003D9D 092E[329E]              	or	[AllSwitch],bp		; set [AllSwitch] SwitchY flag to 1
 27322                                  	;test	bp,~SwitchCopy		; Bad switch?
 27323 00003DA1 F7C5237F                	test	bp,7F23h ; MSDOS 6.22	; ~SwitchCopy ; not SwitchCopy
 27324 00003DA5 740A                    	jz	short NOT_BAD_SWITCH	; Switches are okay
 27325                                  
 27326                                  	; 12/06/2023
 27327                                  	; 23/03/2023
 27328                                  	; MSDOS 6.0
 27329                                  	;;test	bp,not SwitchCopy	;AN018; Bad switch?
 27330                                  	;test	bp,7FE3h ; test bp,~SwitchCopy
 27331                                  	;jz	short NOT_BAD_SWITCH	;AN018; Switches are okay
 27332                                  	
 27333 00003DA7 9D                      	popf	; (*)			;AN018; fix up stack
 27334 00003DA8 B80300                  	mov	ax,BadSwt_Ptr ; 3	;AN018; get "Invalid switch" message number
 27335 00003DAB E86AE9                  	call	setup_parse_error_msg	;AN018; setup to print the message
 27336 00003DAE E9F1F0                  	jmp	cerror			;AC018; exit
 27337                                  NOT_BAD_SWITCH:
 27338 00003DB1 9D                      	popf				; restore CParse flags
 27339 00003DB2 7235                    	jc	short CHECKDONE		; found CR
 27340 00003DB4 E963FF                  	jmp	DESTSCAN		; continue scanning for destination
 27341                                  TESTP2:
 27342 00003DB7 9D                      	popf	; (*)			; restore CParse flags
 27343 00003DB8 722F                    	jc	short CHECKDONE		; found CR
 27344 00003DBA F6C780                  	test	bh,80h
 27345 00003DBD 7504                    	jnz	short GOTPLUS		; found a "+pathname" argument
 27346 00003DBF FE06[2B9E]              	inc	byte [ArgC]		; count independent pathname args
 27347                                  GOTPLUS:
 27348 00003DC3 56                      	push	si			; save cmd line ptr
 27349 00003DC4 A1[0DA2]                	mov	ax,[STARTEL]		; AX = ptr to last path element
 27350 00003DC7 BE[92A1]                	mov	si,ScanBuf		; SI = ptr to path string
 27351 00003DCA 29F0                    	sub	ax,si			; AX = offset of last element
 27352 00003DCC BF[D5A0]                	mov	di,DestBuf		; DI = ptr to destination buf
 27353 00003DCF 01F8                    	add	ax,di			; AX = ptr to last element in
 27354                                  					;  destination path buffer
 27355 00003DD1 A3[D2A0]                	mov	[DestTail],ax		; save ptr to last element
 27356 00003DD4 880E[D1A0]              	mov	[DestSiz],cl		; save path string length
 27357 00003DD8 41                      	inc	cx			; CX = mov length (incl null)
 27358 00003DD9 F3A4                    	rep	movsb			; DestBuf = possible destination path
 27359 00003DDB 883E[D4A0]              	mov	[DestInfo],bh		; save CParse info flags
 27360 00003DDF C706[309E]0000          	mov	word [DestSwitch],0	; clear destination switches
 27361 00003DE5 5E                      	pop	si			; SI = ptr into cmd line again
 27362 00003DE6 E931FF                  	jmp	DESTSCAN		;AC018; continue scanning for dest
 27363                                  
 27364                                  CHECKDONE:
 27365                                  	;	We reached the CR. The destination scan is finished.
 27366                                  
 27367                                  	;	Disallow "copy file1+" as file overwriting itself.
 27368                                  	;
 27369                                  	;	(Note that "copy file1+file2+" will be accepted, and
 27370                                  	;	equivalent to "copy file1+file2".)
 27371                                  
 27372                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 27373                                  	;	through this check, since the switch would count
 27374                                  	;	as another object in ObjCnt.
 27375                                  
 27376 00003DE9 803E[F2A1]01            	cmp	byte [PLUS],1		; "+" with
 27377 00003DEE 7514                    	jnz	short CDCONT
 27378 00003DF0 803E[2B9E]01            	cmp	byte [ArgC],1		; one arg,
 27379 00003DF5 750D                    	jnz	short CDCONT
 27380 00003DF7 803E[F3A1]02            	cmp	byte [objcnt],2		; two objects..
 27381 00003DFC 7506                    	jnz	short CDCONT
 27382 00003DFE BA[1C92]                	mov	dx,OVERWR_PTR
 27383 00003E01 E9AE07                  	jmp	COPYERR			; is file overwrite
 27384                                  
 27385                                  CDCONT:
 27386 00003E04 A0[F2A1]                	mov	al,[PLUS]		; AL = '"+" occurred'
 27387 00003E07 A2[2A9E]                	mov	[Concat],al		; if "+" occurred, we're concatenating
 27388 00003E0A D0E0                    	shl	al,1
 27389 00003E0C D0E0                    	shl	al,1
 27390 00003E0E A2[EBA1]                	mov	[INEXACT],al		; therefore making an inexact copy
 27391                                  	;mov	dx,BADARGSPTR ; MSDOS 3.3 ; 18/04/2023
 27392 00003E11 A0[2B9E]                	mov	al,[ArgC]		; AL = # independent arguments
 27393                                  
 27394                                  	; 23/03/2023
 27395                                  	; MSDOS 3.3		
 27396                                  	;or	al,al
 27397                                  	;jz	short CERROR4J
 27398                                  	; MSDOS 6.0
 27399 00003E14 08C0                    	or	al,al
 27400 00003E16 750B                    	jnz	short TRY_TOO_MANY	; more than 0 args; check if too many
 27401                                  		
 27402 00003E18 BA[F391]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 27403 00003E1B C706[F391]0200          	mov	word [extend_buf_ptr],LessArgs_Ptr ; 2
 27404                                  	;mov	word [extend_buf_ptr],2	; set msg # "param missing"
 27405 00003E21 EB0D                    	jmp	short CERROR_PARSEJ	; take parse error exit		
 27406                                  
 27407                                  	; more than 0 args; check if too many
 27408                                  TRY_TOO_MANY:
 27409 00003E23 3C02                    	cmp	al,2
 27410 00003E25 7611                    	jbe	short ACOUNTOK		; <= 2 arguments - ok
 27411                                  
 27412                                  	; 23/03/2023
 27413                                  	; MSDOS 6.0
 27414 00003E27 BA[F391]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 27415 00003E2A C706[F391]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 27416                                  	;mov	word [extend_buf_ptr],1 ; set msg # "too many params"
 27417                                  CERROR_PARSEJ:
 27418 00003E30 C606[F191]02            	mov	byte [msg_disp_class],parse_msg_class ; 2
 27419                                  					; parse error message	
 27420                                  CERROR4J:
 27421 00003E35 E96AF0                  	jmp	cerror
 27422                                  
 27423                                  ACOUNTOK:
 27424 00003E38 BD[D0A0]                	mov	bp,DestVars		; BP = base of dest variables
 27425                                  
 27426 00003E3B 3C01                    	cmp	al,1
 27427 00003E3D 7520                    	jnz	short GOT2ARGS
 27428                                  
 27429                                  	;	Only one independent pathname argument on command line.
 27430                                  	;	Set destination to d:*.*, where d: is current drive.
 27431                                  
 27432                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 27433                                  	;	The two files would be appended as d:file1, rather than x:file1.
 27434                                  
 27435 00003E3F A0[299E]                	mov	al,[CURDRV]		; AL = current drive (0 = A)
 27436                                  	;add	al,[CAPITAL_A]		; AL = current drive letter
 27437                                  	; 23/03/2023
 27438 00003E42 0441                    	add	al,'A'
 27439 00003E44 B43A                    	mov	ah,':'			; AX = "d:"
 27440                                  	;mov	byte [bp+1],2
 27441 00003E46 C6460102                	mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 27442                                  
 27443 00003E4A BF[D5A0]                	mov	di,DestBuf		; ES:DI = ptr to dest path buf
 27444 00003E4D AB                      	stosw				; store "d:"
 27445                                  		
 27446 00003E4E C706[309E]0000          	mov	word [DestSwitch],0	; clear destination switches
 27447                                  	;mov	byte [bp+4],2		
 27448 00003E54 C6460402                	mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 27449                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 27450                                  	;mov	byte [bp+0],0		
 27451 00003E58 C6460000                	mov	byte [bp],0
 27452 00003E5C E8090A                  	call	SETSTARS		; add wildcards
 27453                                  GOT2ARGS:
 27454                                  	;	If destination pathname is "d:", add full wildcard filename
 27455                                  
 27456                                  	;cmp	byte [bp+1],2
 27457 00003E5F 807E0102                	cmp	byte [bp+VARSTRUC.SIZ],2
 27458 00003E63 7516                    	jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 27459 00003E65 B03A                    	mov	al,':'  ; 3Ah
 27460 00003E67 3806[D6A0]              	cmp	byte [DestBuf+1],al
 27461 00003E6B 750E                    	jnz	short NOTSHORTDEST	; it's just a 2-character filename
 27462                                  	;or	byte [bp+4],2
 27463 00003E6D 804E0402                	or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 27464 00003E71 BF[D7A0]                	mov	di,DestBuf+2		; ES:DI = ptr after "d:"
 27465                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 27466                                  	;mov	byte [bp+0],0		
 27467 00003E74 C6460000                	mov	byte [bp],0
 27468 00003E78 E8ED09                  	call	SETSTARS		; add wildcards
 27469                                  NOTSHORTDEST:
 27470                                  	;	If destination pathname ends with "\", try to make
 27471                                  	;	sure it's "d:\".
 27472                                  
 27473                                  	;mov	di,[bp+2]
 27474 00003E7B 8B7E02                  	mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 27475 00003E7E 803D00                  	cmp	byte [di],0
 27476 00003E81 7515                    	jnz	short CHKSWTCHES	; not a null, so last char not "\"
 27477                                  
 27478 00003E83 BA[2E93]                	mov	dx,badcd_ptr
 27479 00003E86 B03A                    	mov	al,':'
 27480 00003E88 3845FE                  	cmp	[di-2],al
 27481 00003E8B 75A8                    	jne	short CERROR4J		; it's not "d:\", exit with error msg
 27482                                  	;mov	byte [bp+0],2
 27483                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 27484 00003E8D C6460002                	mov	byte [bp],2
 27485                                  	;or	byte [bp+4],6
 27486 00003E91 804E0406                	or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 27487                                  					  ;  path character
 27488 00003E95 E8D009                  	call	SETSTARS		; add wildcards
 27489                                  CHKSWTCHES:
 27490                                  	;	We have enough information about the destination for now.
 27491                                  
 27492                                  	;	Turn on verify if requested. Save the current verify flag.
 27493                                  
 27494                                  	; 23/03/2023
 27495                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM
 27496                                  	;mov	dx,BADPARMPTR
 27497                                  	
 27498 00003E98 A1[329E]                	mov	ax,[AllSwitch]		; AX = all switch flags
 27499                                  
 27500                                  	; 23/03/2023
 27501                                  	; MSDOS 3.3
 27502                                  	;;test	ax,~SWITCHCOPY ; 7FE3h
 27503                                  	;test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 27504                                  	;jnz	short CERROR4J
 27505                                  	
 27506                                  	; 23/03/2023
 27507                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27508                                  	;test	ax,SwitchV ; 10h
 27509                                  	; 18/04/2023
 27510                                  	;test	ax,10h
 27511 00003E9B A810                    	test	al,10h  ; test al,SwitchV
 27512 00003E9D 7414                    	jz	short NOVERIF		; no /v, no verify
 27513                                  
 27514 00003E9F B454                    	mov	ah,Get_Verify_On_Write ; 54h
 27515 00003EA1 CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 27516                                  				; Return: AL = 00h if flag OFF
 27517                                  				; AL = 01h if flag ON
 27518 00003EA3 1E                      	push	ds
 27519 00003EA4 8E1E[159E]              	mov	ds,[RESSEG]
 27520 00003EA8 30E4                    	xor	ah,ah
 27521 00003EAA A3[4502]                	mov	[VerVal],ax		; save current verify flag
 27522 00003EAD 1F                      	pop	ds
 27523 00003EAE B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 27524 00003EB1 CD21                    	int	21h		; DOS -	SET VERIFY FLAG
 27525                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 27526                                  NOVERIF:
 27527                                  	;*	Scan for first source.
 27528                                  
 27529 00003EB3 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 27530 00003EB5 BE8100                  	mov	si,81h			; SI = ptr into command line
 27531                                  	;mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 27532                                  	; 23/03/2023
 27533 00003EB8 B32B                    	mov	bl,'+' ; 2Bh
 27534                                  SCANFSRC:
 27535 00003EBA BF[92A1]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 27536 00003EBD E8D709                  	call	cparse			; parse first source pathname
 27537 00003EC0 F6C701                  	test	bh,1			; switch?
 27538 00003EC3 75F5                    	jnz	short SCANFSRC		; yes, try again
 27539 00003EC5 092E[309E]              	or	[DestSwitch],bp		; include copy-wide switches on dest
 27540                                  
 27541                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 27542                                  
 27543                                  	; 23/03/2023
 27544 00003EC9 F7C50800                	test	bp,8
 27545                                  	;test	bp,SWITCHB
 27546 00003ECD 750C                    	jnz	short NOSETCASC		; /b - explicit binary copy
 27547 00003ECF 803E[2A9E]00            	cmp	byte [Concat],0
 27548 00003ED4 7405                    	jz	short NOSETCASC		; we're not concatenating
 27549 00003ED6 C606[F1A1]04            	mov	byte [ASCII],4
 27550                                  	;mov	byte [ASCII],SWITCHA	; set ascii copy
 27551                                  NOSETCASC:
 27552 00003EDB E82604                  	call	SOURCE_SET		; set source variables
 27553 00003EDE E84400                  	call	FRSTSRC			; set up first source copy
 27554 00003EE1 E99500                  	jmp	FIRSTENT		; jump into the copy loop
 27555                                  
 27556                                  ; ---------------------------------------------------------------------------
 27557                                  
 27558                                  	; 24/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27559                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3AE9h
 27560                                  ENDCOPY:
 27561                                  	;*	End of the road. Close destination, display # files
 27562                                  	;	copied (meaning # destinations), and go back to main
 27563                                  	;	transient COMMAND code.
 27564                                  
 27565 00003EE4 E83203                  	call	CLOSEDEST
 27566                                  ENDCOPY2:
 27567 00003EE7 BA[2592]                	mov	dx,copied_ptr
 27568 00003EEA 8B36[439E]              	mov	si,[FileCnt]
 27569 00003EEE 8936[B9A0]              	mov	[Copy_num],si
 27570 00003EF2 E83816                  	call	std_printf
 27571 00003EF5 E90CC2                  	jmp	TCOMMAND		; stack could be messed up
 27572                                  
 27573                                  ; ---------------------------------------------------------------------------
 27574                                  
 27575                                  SRCNONEXIST:
 27576                                  	;*	Source doesn't exist. If concatenating, ignore and continue.
 27577                                  	;	Otherwise, say 'file not found' and quit.
 27578                                  
 27579 00003EF8 803E[2A9E]00            	cmp	byte [Concat],0
 27580 00003EFD 7543                    	jne	short NEXTSRC		; concatenating - go on to next source
 27581                                  
 27582                                  	; 24/03/2023
 27583                                  	; MSDOS 3.3
 27584                                  	;mov	dx,SRCBUF
 27585                                  	;mov	[STRING_PTR_1],dx
 27586                                  	;mov	dx,STRINGBUF1PTR
 27587                                  	;call	STD_PRINTF
 27588                                  	;mov	dx,FNOTFOUNDPTR
 27589                                  	;jmp	COPYERR
 27590                                  
 27591                                  	; 24/*03/2023
 27592                                  	; MSDOS 6.0
 27593                                  	;	Set up error message.
 27594 00003EFF C606[F191]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 27595                                  				  	; extended error msg
 27596 00003F04 BA[F391]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 27597 00003F07 C706[F391]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 27598                                  					; 'file not found' msg#
 27599 00003F0D C706[B7A0][38A1]        	mov	word [string_ptr_2],SrcBuf
 27600                                  					; point at bad pathname
 27601 00003F13 C606[F591]01            	mov	byte [extend_buf_sub],one_subst ; 1
 27602                                  					; 1 substitution
 27603 00003F18 E99706                  	jmp	COPYERR			; print msg and clean up
 27604                                  
 27605                                  ; ---------------------------------------------------------------------------
 27606                                  
 27607                                  SOURCEPROC:
 27608                                  
 27609                                  	;*	Preparatory processing for each source file.
 27610                                  	;	Called at FrstSrc for first source file.
 27611                                  
 27612 00003F1B E8E603                  	call	SOURCE_SET		; set source variables & ascii/binary
 27613 00003F1E 803E[2A9E]00            	cmp	byte [Concat],0
 27614 00003F23 750B                    	jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 27615                                  
 27616                                  ; ---------------------------------------------------------------------------
 27617                                  
 27618                                  FRSTSRC:
 27619 00003F25 31C0                    	xor	ax,ax
 27620 00003F27 A2[349E]                	mov	[CFLAG],al		; 'destination not created'
 27621 00003F2A A3[3A9E]                	mov	[NXTADD],ax		; copy buffer ptr = 0
 27622 00003F2D A2[359E]                	mov	[DestClosed],al		; 'destination not closed'
 27623                                  
 27624                                  LEAVECFLAG:
 27625 00003F30 8936[E9A1]              	mov	[SRCPT],si		; save cmd-line ptr
 27626 00003F34 BF[F79C]                	mov	di,USERDIR1		; DI = ptr to buf for user's 
 27627                                  						;   current dir
 27628 00003F37 BD[33A1]                	mov	bp,SrcVars		; BP = base of source variables
 27629 00003F3A E8DB07                  	call	BUILDPATH		; cd to source dir, figure
 27630                                  						;   out stuff about source
 27631 00003F3D 8B36[35A1]              	mov	si,[SrcTail]		; SI = ptr to source filename
 27632 00003F41 C3                      	retn
 27633                                  
 27634                                  ; ---------------------------------------------------------------------------
 27635                                  
 27636                                  	; 25/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27637                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 27638                                  NEXTSRC:
 27639                                  	;*	Next source. Come here after handling each pathname.
 27640                                  	;	We're done unless there are additional source pathnames
 27641                                  	;	to be appended.
 27642                                  	;
 27643                                  	;	Note that all files matching an ambiguous pathname
 27644                                  	;	are processed before coming here.
 27645                                  
 27646 00003F42 803E[F2A1]00            	cmp	byte [PLUS],0
 27647                                  	;jne	short MORECP		; copying "+" sources - keep going
 27648                                  	; 26/04/2023
 27649                                  ;ENDCOPYJ2:
 27650                                  	;jmp	short ENDCOPY
 27651 00003F47 749B                    	je	short ENDCOPY
 27652                                  MORECP:
 27653 00003F49 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 27654 00003F4B 8B36[E9A1]              	mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 27655                                  	;mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 27656 00003F4F B32B                    	mov	bl,'+' ; 2Bh
 27657                                  SCANSRC:
 27658 00003F51 BF[92A1]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 27659 00003F54 E84009                  	call	cparse			; parse first source name
 27660                                  	;jb	short ENDCOPYJ2		; CR found - we're done
 27661                                  	; 26/04/2023
 27662 00003F57 728B                    	jb	short ENDCOPY
 27663                                  
 27664 00003F59 F6C780                  	test	bh,80h
 27665                                  	;jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 27666                                  	; 26/04/2023
 27667 00003F5C 7486                    	jz	short ENDCOPY
 27668                                  
 27669 00003F5E F6C701                  	test	bh,1
 27670 00003F61 75EE                    	jnz	short SCANSRC		; switch found - keep looking
 27671                                  
 27672                                  	;	ScanBuf contains the next source pathname.
 27673                                  
 27674 00003F63 E8B5FF                  	call	SOURCEPROC		; prepare this source
 27675 00003F66 803E[ACA0]01            	cmp	byte [comma],1		; was +,, found last time?
 27676 00003F6B 7507                    	jnz	short NOSTAMP		;  no - try for a file
 27677 00003F6D C606[ADA0]01            	mov	byte [plus_comma],1	; yes - set flag
 27678 00003F72 EB84                    	jmp	short SRCNONEXIST	; we know we won't find it
 27679                                  
 27680                                  NOSTAMP:
 27681 00003F74 C606[ADA0]00            	mov	byte [plus_comma],0	; reset +,, flag
 27682                                  
 27683                                  ; ---------------------------------------------------------------------------
 27684                                  
 27685                                  FIRSTENT:
 27686                                  
 27687                                  ;M047
 27688                                  ; The only case we need to worry about is when the source is wildcarded and
 27689                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 27690                                  ;concatenation. We check for this case.
 27691                                  ;
 27692                                  ;NB: This change has been backed out and replaced by M048. This is not the
 27693                                  ;right place to do this check.
 27694                                  
 27695                                  	;	This is where we enter the loop with the first source.
 27696                                  
 27697 00003F79 BF5C00                  	mov	di,FCB ; 5Ch		; DI = ptr to FCB
 27698 00003F7C B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27699 00003F7F CD21                    	int	21h		; DOS -	PARSE FILENAME
 27700                                  				; DS:SI	-> string to parse
 27701                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27702                                  				; AL = bit mask	to control parsing
 27703 00003F81 803C00                  	cmp	byte [si],0		; did we parse the whole thing?
 27704 00003F84 7516                    	jne	short SRCHDONE		; no, error, simulate 'not found'
 27705 00003F86 A1[38A1]                	mov	ax,[SrcBuf]		; AX = possible "d:"
 27706 00003F89 80FC3A                  	cmp	ah,':'
 27707 00003F8C 7402                    	je	short DRVSPEC1		; AX = definite "d:"
 27708 00003F8E B040                    	mov	al,'@'	; 40h		; AL = drive 'letter' for current drive
 27709                                  DRVSPEC1:
 27710 00003F90 0C20                    	or	al,20h			; AL = lowercase drive letter
 27711 00003F92 2C60                    	sub	al,60h			; AL = drive id (0=current,1=A,..)
 27712                                  	;mov	[5Ch],al
 27713 00003F94 A25C00                  	mov	[FCB],al		; put drive id in FCB
 27714                                  
 27715                                  	;	FCB contains drive and filename to search.
 27716                                  		
 27717 00003F97 B411                    	mov	ah,Dir_Search_First ; 11h  ; AH = 'Find First File'	
 27718 00003F99 E86D01                  	call	SEARCH
 27719                                  SRCHDONE:
 27720 00003F9C 9C                      	pushf				; save flags from Search
 27721 00003F9D E831EA                  	call	RestUDir1		; restore users current directory
 27722 00003FA0 9D                      	popf				; restore flags from search
 27723 00003FA1 7403                    	jz	short NEXTAMBIG0	; found the source - continue
 27724 00003FA3 E952FF                  	jmp	SRCNONEXIST		; didn't find the source
 27725                                  
 27726                                  NEXTAMBIG0:
 27727 00003FA6 30C0                    	xor	al,al
 27728 00003FA8 8606[3C9E]              	xchg	al,[FRSTSRCH]
 27729 00003FAC 08C0                    	or	al,al
 27730 00003FAE 740B                    	jz	short NEXTAMBIG
 27731                                  SETNMEL:
 27732 00003FB0 B90C00                  	mov	cx,12
 27733 00003FB3 BF[96A0]                	mov	di,SDIRBUF
 27734 00003FB6 BE[50A0]                	mov	si,DIRBUF
 27735 00003FB9 F3A4                    	rep	movsb			; save very first source name
 27736                                  NEXTAMBIG:
 27737 00003FBB 30C0                    	xor	al,al
 27738 00003FBD A2[ECA1]                	mov	[NOWRITE],al		; turn off nowrite
 27739 00003FC0 8B3E[35A1]              	mov	di,[SrcTail]
 27740 00003FC4 BE[51A0]                	mov	si,DIRBUF+1
 27741 00003FC7 E883EB                  	call	FCB_TO_ASCZ		; SrcBuf has complete name
 27742                                  ;MELDO:
 27743                                  	; ****************************************
 27744                                  	; 12/06/2023
 27745                                  	; Retro DOS v4.2 COMMAND.COM
 27746                                  	; MSDOS 6.22 COMMAND.COM code only !
 27747                                  	; (Disassembled source code by using Hex-Rays IDA disassembler)
 27748                                  	; ****************************************
 27749                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:41DBh
 27750                                  MELDO0:
 27751 00003FCA 803E[08A2]00            	cmp	byte [cox_y_override],0 ; /Y switch override (question) enabled ?
 27752 00003FCF 746C                    	jz	short MELDO ; no
 27753                                  	; ----------------------
 27754                                  	; yes
 27755 00003FD1 E85406                  	call	BUILDDEST
 27756 00003FD4 BE[38A1]                	mov	si,SrcBuf
 27757 00003FD7 BF[439B]                	mov	di,SRCXNAME
 27758                                  	;mov	ah,60h
 27759 00003FDA B460                    	mov	ah,xNameTrans ; 60h
 27760 00003FDC CD21                    	int	21h	; DOS - RESOLVE PATH STRING TO CANONICAL PATH STRING
 27761                                  			; DS:SI -> ASCIZ relative path string or directory name
 27762                                  			; ES:DI -> 128-byte buffer for ASCIZ canonical fully qualified name
 27763 00003FDE E8A308                  	call	COMPNAME
 27764 00003FE1 7540                    	jnz	short MELDO1    	; different file names
 27765 00003FE3 803E[2A9E]00            	cmp	byte [Concat],0
 27766 00003FE8 7539                    	jnz	short MELDO1		; concatenating
 27767                                  	; "File cannot be copied onto itself"
 27768 00003FEA BA[9E93]                	mov	dx,file_name_ptr
 27769 00003FED E83D15                  	call	std_printf
 27770 00003FF0 E82EEB                  	call	CRLF2
 27771 00003FF3 BA[1C92]                	mov	dx,OVERWR_PTR
 27772 00003FF6 E9B905                  	jmp	COPYERR
 27773                                  ;MELDO1:
 27774                                  	;cmp	byte [CFLAG],0		; destination file created flag
 27775                                  	;jnz	short MELDO		; yes, new (created) file
 27776                                  	;				; no, overwrite question (must be confirmed)
 27777                                  	;call	get_answer_YNA
 27778                                  	;jb	short MELDO2    	; answer is no
 27779                                  	;cmp	byte [Concat],0
 27780                                  	;jnz	short MELDO
 27781                                  	;cmp	byte [cox_dest_file],0	; is there a (valid) target file ?
 27782                                  	;jnz	short DOREAD    	; yes
 27783                                  	;jmp	short MELDO     	; no, destination/target file does not exist
 27784                                  MELDO2:
 27785 00003FF9 803E[30A1]00            	cmp	byte [MELCOPY],0	; is 'Mel Hallerman copy' false ?
 27786 00003FFE 7507                    	jnz	short MELDO3    	; no (, it is true)
 27787 00004000 803E[2A9E]00            	cmp	byte [Concat],0
 27788 00004005 7408                    	jz	short MELDO4
 27789                                  MELDO3:
 27790 00004007 C606[359E]01            	mov	byte [DestClosed],1
 27791 0000400C E9D5FE                  	jmp	ENDCOPY
 27792                                  MELDO4:
 27793 0000400F E8EB00                  	call	SEARCHNEXT
 27794 00004012 74A7                    	jz	short NEXTAMBIG
 27795 00004014 803E[0AA2]00            	cmp	byte [cox_src_file],0
 27796                                  	;jz	short MELDO5
 27797                                  	;jmp	NEXTSRC
 27798                                  	; 18/06/2023
 27799 00004019 7505                    	jnz	short NEXTSRCJ
 27800                                  MELDO5:
 27801 0000401B C606[359E]01            	mov	byte [DestClosed],1
 27802                                  NEXTSRCJ:	; 18/06/2023
 27803 00004020 E91FFF                  	jmp	NEXTSRC
 27804                                  
 27805                                  	; 12/06/2023
 27806                                  MELDO1:
 27807 00004023 803E[349E]00            	cmp	byte [CFLAG],0		; destination file created flag
 27808 00004028 7513                    	jnz	short MELDO     	; yes, new (created) file
 27809                                  					; no, overwrite question (must be confirmed)
 27810 0000402A E81803                  	call	get_answer_YNA
 27811 0000402D 72CA                    	jb	short MELDO2    	; answer is no
 27812 0000402F 803E[2A9E]00            	cmp	byte [Concat],0
 27813 00004034 7507                    	jnz	short MELDO
 27814 00004036 803E[09A2]00            	cmp	byte [cox_dest_file],0	; is there a (valid) target file ?
 27815 0000403B 7517                    	jnz	short DOREAD    	; yes
 27816                                  	; 12/06/2023
 27817                                  	;jmp	short MELDO     	; no, destination/target file does not exist
 27818                                  
 27819                                  	; ****************************************
 27820                                  	; 12/06/2023
 27821                                  MELDO:
 27822 0000403D 803E[2A9E]00            	cmp	byte [Concat],0
 27823 00004042 7507                    	jnz	short SHOWCPNAM		; concatenating - show name
 27824 00004044 F606[37A1]02            	test	byte [SrcInfo],2	; wildcard - show name
 27825 00004049 7409                    	jz	short DOREAD
 27826                                  SHOWCPNAM:
 27827                                  	; 25/03/2023
 27828                                  	; MSDOS 3.3
 27829                                  	;mov	dx,SRCBUF
 27830                                  	;mov	[STRING_PTR_2],dx
 27831                                  	;mov	dx,STRINGBUF2PTR
 27832                                  	;call	STD_PRINTF
 27833                                  	;call	CRLF2
 27834                                  	; 25/03/2023 - Retro DOS 4.0 COMMAND.COM
 27835                                  	; MSDOS 6.0 (& MSDOS 5.0
 27836 0000404B BA[9E93]                	mov	dx,file_name_ptr
 27837 0000404E E8DC14                  	call	std_printf
 27838 00004051 E8CDEA                  	call	CRLF2
 27839                                  DOREAD:
 27840 00004054 E8C300                  	call	DOCOPY
 27841 00004057 803E[2A9E]00            	cmp	byte [Concat],0
 27842 0000405C 750A                    	jnz	short NODCLOSE		; concatenating - don't close dest
 27843                                  
 27844 0000405E E8B801                  	call	CLOSEDEST		; close current destination
 27845 00004061 7205                    	jc	short NODCLOSE		; concatenating - dest not closed
 27846                                  
 27847 00004063 C606[349E]00            	mov	byte [CFLAG],0		; 'destination not created'
 27848                                  NODCLOSE:
 27849 00004068 803E[2A9E]00            	cmp	byte [Concat],0		
 27850 0000406D 740A                    	jz	short NOFLUSH
 27851                                  
 27852                                  ;	Concatenating - flush output between source files so LostErr
 27853                                  ;	stuff works correctly.
 27854                                  
 27855                                  	;invoke	FlshFil  ; MSDOS 6.0
 27856                                  	; 25/03/2023
 27857 0000406F E80304                  	call	FlshFil
 27858                                  	;call	FLUSHFIL ; MSDOS 3.3
 27859                                  
 27860 00004072 F606[30A1]FF            	test	byte [MELCOPY],0FFh
 27861                                  	;jz	short NOFLUSH
 27862                                  	;jmp	short DOMELCOPY
 27863                                  	; 25/03/2023
 27864 00004077 750D                    	jnz	short DOMELCOPY
 27865                                  NOFLUSH:
 27866 00004079 E88100                  	call	SEARCHNEXT		; try next match
 27867 0000407C 75A2                    	jnz	short NEXTSRCJ		; not found - finished with 
 27868                                  					;   this source spec
 27869 0000407E C606[359E]00            	mov	byte [DestClosed],0	; 'destination not closed'
 27870 00004083 E935FF                  	jmp	NEXTAMBIG		; do next ambig match
 27871                                  
 27872                                  DOMELCOPY:
 27873 00004086 803E[30A1]FF            	cmp	byte [MELCOPY],0FFh
 27874 0000408B 740D                    	je	short CONTMEL
 27875 0000408D 8B36[E9A1]              	mov	si,[SRCPT]
 27876 00004091 8936[31A1]              	mov	[MELSTART],si
 27877 00004095 C606[30A1]FF            	mov	byte [MELCOPY],0FFh
 27878                                  
 27879                                  CONTMEL:
 27880 0000409A 31ED                    	xor	bp,bp
 27881 0000409C 8B36[E9A1]              	mov	si,[SRCPT]
 27882                                  	;mov	bl,[PLUS_CHR]
 27883                                  	; 25/03/2023
 27884 000040A0 B32B                    	mov	bl,'+'
 27885                                  SCANSRC2:
 27886 000040A2 BF[92A1]                	mov	di,ScanBuf
 27887 000040A5 E8EF07                  	call	cparse
 27888 000040A8 F6C780                  	test	bh,80h
 27889 000040AB 742F                    	jz	short NEXTMEL		; no "+" - go back to start
 27890 000040AD F6C701                  	test	bh,1
 27891 000040B0 75F0                    	jnz	short SCANSRC2		; switch - keep scanning
 27892 000040B2 E866FE                  	call	SOURCEPROC
 27893 000040B5 E819E9                  	call	RestUDir1
 27894 000040B8 BF[D19F]                	mov	di,DESTFCB2
 27895 000040BB B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27896 000040BE CD21                    	int	21h		; DOS -	PARSE FILENAME
 27897                                  				; DS:SI	-> string to parse
 27898                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27899                                  				; AL = bit mask	to control parsing
 27900 000040C0 BB[97A0]                	mov	bx,SDIRBUF+1
 27901 000040C3 BE[D29F]                	mov	si,DESTFCB2+1
 27902 000040C6 8B3E[35A1]              	mov	di,[SrcTail]
 27903                                  
 27904 000040CA E81C06                  	call	BUILDNAME
 27905                                  
 27906 000040CD 803E[2A9E]00            	cmp	byte [Concat],0
 27907 000040D2 7405                    	je	short MELDOJ		; not concatenating - continue
 27908                                  
 27909                                  	;	Yes, turn off nowrite because this part of the code 
 27910                                  	;	is only reached after the first file has been dealt with.
 27911                                  
 27912 000040D4 C606[ECA1]00            	mov	byte [NOWRITE],0
 27913                                  MELDOJ:
 27914 000040D9 E961FF                  	jmp	MELDO
 27915                                  	; 18/06/2023
 27916                                  ;NEXTSRCJ:
 27917                                  	;jmp	NEXTSRC
 27918                                  
 27919                                  NEXTMEL:
 27920 000040DC E83A01                  	call	CLOSEDEST
 27921 000040DF 31C0                    	xor	ax,ax
 27922 000040E1 A2[349E]                	mov	[CFLAG],al
 27923 000040E4 A3[3A9E]                	mov	[NXTADD],ax
 27924 000040E7 A2[359E]                	mov	[SPECDRV],al
 27925 000040EA 8B36[31A1]              	mov	si,[MELSTART]
 27926 000040EE 8936[E9A1]              	mov	[SRCPT],si
 27927 000040F2 E80800                  	call	SEARCHNEXT
 27928 000040F5 7403                    	jz	short SETNMELJ
 27929 000040F7 E9EDFD                  	jmp	ENDCOPY2
 27930                                  SETNMELJ:
 27931 000040FA E9B3FE                  	jmp	SETNMEL
 27932                                  
 27933                                  ; ---------------------------------------------------------------------------
 27934                                  
 27935                                  SEARCHNEXT:
 27936 000040FD B412                    	mov	ah,Dir_Search_Next ; 12h
 27937 000040FF F606[37A1]02            	test	byte [SrcInfo],2
 27938 00004104 7503                    	jnz	short SEARCH		; do search-next if ambig
 27939 00004106 08E4                    	or	ah,ah			; reset zero flag
 27940 00004108 C3                      	retn
 27941                                  
 27942                                  ; ---------------------------------------------------------------------------
 27943                                  
 27944                                  SEARCH:
 27945 00004109 50                      	push	ax
 27946 0000410A B41A                    	mov	ah,Set_DMA ; 1Ah
 27947 0000410C BA[50A0]                	mov	dx,DIRBUF	; put result of search in dirbuf
 27948 0000410F CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 27949                                  			; DS:DX	-> disk	transfer buffer
 27950 00004111 58                      	pop	ax		; restore search first/next command
 27951 00004112 BA5C00                  	mov	dx,FCB ; 5Ch
 27952 00004115 CD21                    	int	21h		; Do the search
 27953 00004117 08C0                    	or	al,al
 27954 00004119 C3                      	retn
 27955                                  
 27956                                  ; ---------------------------------------------------------------------------
 27957                                  
 27958                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27959                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 27960                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:4335h
 27961                                  DOCOPY:
 27962 0000411A BE[38A1]                	mov	si,SrcBuf	; do name translate of source
 27963 0000411D BF[439B]                	mov	di,SRCXNAME	; save for name comparison
 27964 00004120 B460                    	mov	ah,xNameTrans ; 60h
 27965                                  	;mov	ah,60h
 27966 00004122 CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 27967                                  			; DS:SI	-> ASCIZ relative path string or directory name
 27968                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 27969 00004124 C606[289E]00            	mov	byte [RDEOF],0	; no EOF yet
 27970                                  
 27971                                  	; MSDOS 6.0
 27972                                  	;mov	ax,ExtOpen shl 8	; open the file
 27973                                  	; 26/03/2023
 27974 00004129 B8006C                  	mov	ax,6C00h
 27975                                  ;M046
 27976                                  ; For reads, the sharing mode should be deny none so that any process can
 27977                                  ;open this file again in any other sharing mode. This is mainly to allow
 27978                                  ;multiple command.com's to access the same file without getting sharing
 27979                                  ;violations
 27980                                  ;
 27981                                  	;mov	bx,deny_none|read_open_mode
 27982 0000412C BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 27983 0000412F 31C9                    	xor	cx,cx			; no special files
 27984                                  	;mov	dx,read_open_flag	; set up open flags
 27985 00004131 BA0101                  	mov	dx,101h
 27986 00004134 CD21                    	int	21h
 27987                                  	; 26/03/2023
 27988 00004136 7230                    	jc	short Error_On_Source
 27989                                  	;jnc	short OPENOK
 27990                                  
 27991                                  	;	Bogosity: IBM wants us to issue Access Denied in this case.
 27992                                  	;	They asked for it...
 27993                                  
 27994                                  	;jmp	short Error_On_Source ;AC022; clean up and exit
 27995                                  
 27996                                  	; 26/03/2023
 27997                                  	; MSDOS 3.3
 27998                                  	;mov	dx,SRCBUF
 27999                                  	;mov	ax,OPEN*256 ; 3D00h
 28000                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 28001                                  	;			; DS:DX	-> ASCIZ filename
 28002                                  	;			; AL = access mode
 28003                                  	;			; 0 - read
 28004                                  	;jnc	short OPENOK
 28005                                  	;call	GET_EXT_ERR_NUMBER
 28006                                  	;pushf
 28007                                  	;cmp	ax,65
 28008                                  	;jnz	short DOCOPY_ERR
 28009                                  	;mov	dx,ACCDENPTR
 28010                                  	;call	STD_PRINTF
 28011                                  ;DOCOPY_ERR:
 28012                                  	;popf
 28013                                  	;retn
 28014                                  
 28015                                  	; 26/03/2023
 28016                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28017                                  OPENOK:
 28018 00004138 89C3                    	mov	bx,ax
 28019 0000413A 891E[8FA1]              	mov	[SRCHAND],bx		; save handle
 28020 0000413E B80057                  	mov	ax,File_Times*256 ; 5700h
 28021 00004141 CD21                    	int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 28022                                  				; BX = file handle
 28023                                  
 28024 00004143 7223                    	jc	short Error_On_Source ; MSDOS 6.0
 28025                                  
 28026 00004145 8916[F4A1]              	mov	[CPDATE],dx		; save date
 28027 00004149 890E[F6A1]              	mov	[CPTIME],cx		; save time
 28028                                  
 28029                                  	; MSDOS 6.0
 28030                                  	;jmp	short No_Copy_Xa 	; (xa copy code removed)
 28031                                  	; 26/04/2023
 28032                                  No_Copy_Xa:
 28033                                  	; 26/03/2023
 28034                                  	;mov	bx,[SRCHAND]		;AN022; get handle back
 28035                                  
 28036                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28037 0000414D B80044                  	mov	ax,(IOCTL<<8) ; 4400h
 28038 00004150 CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 28039                                  				; BX = file or device handle
 28040                                  	;and	dl,devid_ISDEV ; 80h
 28041                                  	; 18/04/2023
 28042 00004152 80E280                  	and	dl,80h ; devid_ISDEV
 28043 00004155 8816[91A1]              	mov	[SRCISDEV],dl		; set source info
 28044 00004159 7436                    	jz	short COPYLP		; source not a device
 28045 0000415B 803E[EDA1]00            	cmp	byte [BINARY],0
 28046 00004160 742F                    	je	short COPYLP		; ascii device ok
 28047 00004162 BA[5793]                	mov	dx,INBDEV_PTR		; cannot do binary input
 28048 00004165 E94A04                  	jmp	COPYERR
 28049                                  
 28050                                  Error_On_Source:			;AN022; we have a BAD error
 28051 00004168 E8C7E0                  	call	Set_Ext_Error_Msg	;AN022; set up the error message
 28052 0000416B C706[B7A0][38A1]        	mov	word [string_ptr_2],SrcBuf
 28053                                  				;AN022; get address of failed string
 28054 00004171 C606[F591]01            	mov	byte [extend_buf_sub],one_subst ; 1
 28055                                  				;AN022; put number of subst in control block
 28056 00004176 E8AC13                  	call	std_eprintf		;AN022; print it
 28057                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 28058 00004179 8B1E[8FA1]              	mov	bx,[SRCHAND]
 28059                                  	;cmp	word [SRCHAND],0	;AN022; did we open the file?
 28060                                  	;je	short No_Close_Src	;AN022; no - don't close
 28061 0000417D 09DB                    	or	bx,bx
 28062 0000417F 7403                    	jz	short No_Close_Src
 28063                                  	;call	CLOSESRC		;AN022; clean up
 28064                                  	; 26/03/2023
 28065 00004181 E89000                  	call	CLOSESRC2 ; bx = [SRCHAND]
 28066                                  No_Close_Src:				;AN022;
 28067 00004184 803E[349E]00            	cmp	byte [CFLAG],0		;AN022; was destination created?
 28068 00004189 7403                    	je	short EndCopyJ3		;AN022; no - just cleanup and exit
 28069 0000418B E956FD                  	jmp	ENDCOPY			;AN022; clean up concatenation and exit
 28070                                  EndCopyJ3:				;AN022;
 28071 0000418E E956FD                  	jmp	ENDCOPY2		;AN022;
 28072                                  
 28073                                  	; 26/04/2023
 28074                                  ;No_Copy_Xa:
 28075                                  ;	; 26/03/2023
 28076                                  ;	;mov	bx,[SRCHAND]		;AN022; get handle back
 28077                                  ;
 28078                                  ;	; MSDOS 3.3 (& MSDOS 6.0)
 28079                                  ;	mov	ax,(IOCTL<<8) ; 4400h
 28080                                  ;	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 28081                                  ;				; BX = file or device handle
 28082                                  ;	;and	dl,devid_ISDEV ; 80h
 28083                                  ;	; 18/04/2023
 28084                                  ;	and	dl,80h ; devid_ISDEV
 28085                                  ;	mov	[SRCISDEV],dl		; set source info
 28086                                  ;	jz	short COPYLP		; source not a device
 28087                                  ;	cmp	byte [BINARY],0
 28088                                  ;	je	short COPYLP		; ascii device ok
 28089                                  ;	mov	dx,INBDEV_PTR		; cannot do binary input
 28090                                  ;	jmp	COPYERR
 28091                                  
 28092                                  COPYLP:
 28093                                  	; 26/03/2023
 28094 00004191 8B1E[8FA1]              	mov	bx,[SRCHAND] ; ? ; 26/03/2023
 28095 00004195 8B0E[369E]              	mov	cx,[BYTCNT]
 28096 00004199 8B16[3A9E]              	mov	dx,[NXTADD]
 28097 0000419D 29D1                    	sub	cx,dx			; compute available space
 28098 0000419F 750E                    	jnz	short GOTROOM
 28099 000041A1 E8D102                  	call	FlshFil   ; MSDOS 6.0
 28100                                  	;call	FLUSHFIL  ; MSDOS 3.3
 28101 000041A4 803E[F0A1]00            	cmp	byte [TERMREAD],0
 28102 000041A9 7565                    	jne	short CLOSESRC		; give up
 28103 000041AB 8B0E[369E]              	mov	cx,[BYTCNT]
 28104                                  GOTROOM:
 28105 000041AF 1E                      	push	ds
 28106 000041B0 8E1E[179E]              	mov	ds,[TPA]
 28107 000041B4 B43F                    	mov	ah,READ ; 3Fh
 28108 000041B6 CD21                    	int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 28109                                  				; BX = file handle,CX = number of bytes to read
 28110                                  				; DS:DX	-> buffer
 28111 000041B8 1F                      	pop	ds
 28112                                  	;jc	short CLOSESRC	; MSDOS 3.3
 28113                                  	; 26/03/2023
 28114 000041B9 72AD                    	jc	short Error_On_Source ; MSDOS 6.0
 28115 000041BB 89C1                    	mov	cx,ax			; get count
 28116 000041BD E351                    	jcxz	CLOSESRC		; no more to read
 28117 000041BF 803E[91A1]00            	cmp	byte [SRCISDEV],0
 28118 000041C4 7507                    	jne	short NOTESTA		; is a device, ascii mode
 28119 000041C6 803E[F1A1]00            	cmp	byte [ASCII],0
 28120 000041CB 741B                    	je	short BINREAD
 28121                                  NOTESTA:
 28122 000041CD 89CA                    	mov	dx,cx
 28123 000041CF 8B3E[3A9E]              	mov	di,[NXTADD]
 28124 000041D3 B01A                    	mov	al,1Ah
 28125 000041D5 06                      	push	es
 28126 000041D6 8E06[179E]              	mov	es,[TPA]		; scan for EOF
 28127 000041DA F2AE                    	repne	scasb
 28128 000041DC 07                      	pop	es
 28129 000041DD 7505                    	jnz	short USEALL
 28130 000041DF FE06[289E]              	inc	byte [RDEOF]
 28131 000041E3 41                      	inc	cx
 28132                                  USEALL:
 28133 000041E4 29CA                    	sub	dx,cx
 28134 000041E6 89D1                    	mov	cx,dx
 28135                                  BINREAD:
 28136 000041E8 030E[3A9E]              	add	cx,[NXTADD]
 28137 000041EC 890E[3A9E]              	mov	[NXTADD],cx
 28138 000041F0 3B0E[369E]              	cmp	cx,[BYTCNT]		; is buffer full?
 28139 000041F4 720C                    	jb	short TESTDEV		; if not, we may have found eof
 28140                                  	; 26/03/2023
 28141 000041F6 E87C02                  	call	FlshFil
 28142                                  	;call	FLUSHFIL
 28143 000041F9 803E[F0A1]00            	cmp	byte [TERMREAD],0
 28144 000041FE 7510                    	jne	short CLOSESRC		; give up
 28145 00004200 EB8F                    	jmp	short COPYLP
 28146                                  TESTDEV:
 28147 00004202 803E[91A1]00            	cmp	byte [SRCISDEV],0	; if file then EOF
 28148 00004207 7407                    	je	short CLOSESRC
 28149 00004209 803E[289E]00            	cmp	byte [RDEOF],0
 28150 0000420E 7481                    	je	short COPYLP		; on device, go till ^Z
 28151                                  CLOSESRC:
 28152 00004210 8B1E[8FA1]              	mov	bx,[SRCHAND]
 28153                                  CLOSESRC2:
 28154 00004214 B43E                    	mov	ah,CLOSE ; 3Eh
 28155 00004216 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 28156                                  				; BX = file handle
 28157                                  CLOSESRCDEST_RETN:
 28158 00004218 C3                      	retn
 28159                                  
 28160                                  ; ---------------------------------------------------------------------------
 28161                                  
 28162                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28163                                  CLOSEDEST:
 28164                                  
 28165                                  	;	We are called to close the destination.
 28166                                  	;	We need to note whether or not there is any internal data left
 28167                                  	;	to be flushed out.
 28168                                  
 28169 00004219 803E[359E]00            	cmp	byte [DestClosed],0
 28170 0000421E 75F8                    	jne	short CLOSESRCDEST_RETN	; don't double close
 28171 00004220 A0[309E]                	mov	al,[DestSwitch]
 28172 00004223 E8E803                  	call	SETASC			; check for b or a switch
 28173 00004226 742E                    	jz	short BINCLOS		;   on destination
 28174 00004228 8B1E[3A9E]              	mov	bx,[NXTADD]
 28175                                  ;
 28176                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 28177                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 28178                                  ;just return without appending a ^Z incorrectly for the first file (since we
 28179                                  ;are concatenating now). Also, in case it is a single file copy, we will
 28180                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 28181                                  ;performance overhead on single ASCII file copies which now always involve
 28182                                  ;2 writes instead of 1 before. Is this really that important?
 28183                                  ;
 28184                                  ;M048;	cmp	bx,[BYTCNT]		; is memory full?
 28185                                  ;M048;	jne	short PutZ
 28186                                  
 28187                                  	; 26/03/2023
 28188                                  	; MSDOS 3.3
 28189                                  	;cmp	bx,[BYTCNT]		; is memory full?
 28190                                  	;jne	short PUTZ
 28191                                  
 28192                                  	; 26/03/2023
 28193 0000422C E83902                  	call	TRYFLUSH		; flush (and double-check for concat)	
 28194 0000422F 7402                    	jz	short NOCONC
 28195                                  CONCHNG:
 28196 00004231 F9                      	stc
 28197 00004232 C3                      	retn
 28198                                  
 28199                                  NOCONC:	
 28200 00004233 31DB                    	xor	bx,bx
 28201                                  PUTZ:
 28202 00004235 1E                      	push	ds
 28203 00004236 8E1E[179E]              	mov	ds,[TPA]
 28204 0000423A C7071A00                	mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 28205 0000423E 1F                      	pop	ds
 28206 0000423F FF06[3A9E]              	inc	word [NXTADD]	; make sure our ^z gets written	
 28207 00004243 C606[ECA1]00            	mov	byte [NOWRITE],0
 28208 00004248 A1[EEA1]                	mov	ax,[WRITTEN]
 28209 0000424B 0306[3A9E]              	add	ax,[NXTADD]
 28210 0000424F 7205                    	jc	short BINCLOS	; > 1
 28211 00004251 83F801                  	cmp	ax,1
 28212 00004254 740C                    	je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 28213                                  BINCLOS:
 28214 00004256 E80F02                  	call	TRYFLUSH
 28215 00004259 75D6                    	jnz	short CONCHNG
 28216                                  
 28217                                  	; 26/04/2023
 28218 0000425B 833E[EEA1]00            	cmp	word [WRITTEN],0
 28219                                  	; 26/03/2023
 28220 00004260 7503                    	jnz	short NO_FORGET
 28221                                  FORGETITJ:
 28222                                  	;jz	short FORGETIT	; never wrote nothing
 28223                                  	; 26/03/2023
 28224 00004262 E98500                  	jmp	FORGETIT ; 18/04/2023
 28225                                  NO_FORGET:			; wrote something
 28226 00004265 8B1E[2CA1]              	mov	bx,[DESTHAND]
 28227 00004269 8B0E[F6A1]              	mov	cx,[CPTIME]
 28228 0000426D 8B16[F4A1]              	mov	dx,[CPDATE]
 28229 00004271 803E[EBA1]00            	cmp	byte [INEXACT],0 ; copy not exact?
 28230 00004276 7431                    	je	short DODCLOSE	; if no, copy date & time
 28231 00004278 B42C                    	mov	ah,Get_Time ; 2Ch
 28232 0000427A CD21                    	int	21h		; DOS -	GET CURRENT TIME
 28233                                  				; Return: CH = hours,CL = minutes,DH = seconds
 28234                                  				; DL = hundredths of seconds
 28235 0000427C D0E1                    	shl	cl,1
 28236 0000427E D0E1                    	shl	cl,1		; left justify min in cl
 28237 00004280 D1E1                    	shl	cx,1
 28238 00004282 D1E1                    	shl	cx,1
 28239 00004284 D1E1                    	shl	cx,1		; hours to high 5 bits, min to 5-10
 28240 00004286 D0EE                    	shr	dh,1		; divide seconds by 2 (now 5 bits)
 28241 00004288 08F1                    	or	cl,dh		; and stick into low 5 bits of cx
 28242 0000428A 51                      	push	cx		; save packed time
 28243 0000428B B42A                    	mov	ah,Get_Date ; 2Ah
 28244 0000428D CD21                    	int	21h		; DOS -	GET CURRENT DATE
 28245                                  				; Return: DL = day,DH = month,	CX = year
 28246                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 28247 0000428F 81E9BC07                	sub	cx,1980
 28248 00004293 86E9                    	xchg	ch,cl
 28249 00004295 D1E1                    	shl	cx,1		; year to high 7 bits
 28250 00004297 D0E6                    	shl	dh,1		; month to high 3 bits
 28251 00004299 D0E6                    	shl	dh,1
 28252 0000429B D0E6                    	shl	dh,1
 28253 0000429D D0E6                    	shl	dh,1
 28254 0000429F D0E6                    	shl	dh,1		; most sig bit of month in carry
 28255 000042A1 80D500                  	adc	ch,0		; put that bit next to year
 28256 000042A4 08F2                    	or	dl,dh		; or low three of month into day
 28257 000042A6 88EE                    	mov	dh,ch		; get year and high bit of month
 28258 000042A8 59                      	pop	cx
 28259                                  DODCLOSE:
 28260 000042A9 83FB00                  	cmp	bx,0
 28261 000042AC 7E36                    	jle	short CLOSEDONE
 28262 000042AE B80157                  	mov	ax,(File_Times<<8)|1 ; 5701h
 28263 000042B1 CD21                    	int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 28264                                  				; BX = file handle,CX = time to be set
 28265                                  				; DX = date to be set
 28266                                  	; 26/03/2023
 28267                                  	; MSDOS 6.0
 28268 000042B3 721A                    	jc	short Cleanup_Err ;AN022; handle error
 28269                                  
 28270                                  	;	See if the destination has *anything* in it.
 28271                                  	;	If not, just close and delete it.
 28272                                  
 28273 000042B5 B80242                  	mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 28274 000042B8 31D2                    	xor	dx,dx
 28275 000042BA 89D1                    	mov	cx,dx
 28276 000042BC CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 28277                                  			; AL = method: offset from end of file
 28278                                  	;	DX:AX is file size
 28279                                  
 28280 000042BE 09C2                    	or	dx,ax
 28281 000042C0 9C                      	pushf
 28282 000042C1 B80044                  	mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 28283 000042C4 CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 28284                                  			; BX = file or device handle
 28285 000042C6 52                      	push	dx		; save them away
 28286 000042C7 B43E                    	mov	ah,CLOSE ; 3Eh
 28287 000042C9 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 28288                                  			; BX = file handle
 28289 000042CB 5A                      	pop	dx
 28290                                  
 28291                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 28292                                  	; MSDOS 6.0
 28293 000042CC 730D                    	jnc	short Close_Cont ;AN022; handle error on close
 28294 000042CE 9D                      	popf			;AN022; get the flags back
 28295                                  Cleanup_Err: 			;AN022;
 28296 000042CF E85A00                  	call	CleanUpErr	;AN022; attempt to delete the target
 28297                                  	; 26/03/2023
 28298                                  	;call	DestDelete	;AN022; attempt to delete the target
 28299                                  	;jmp	short FILECLOSED
 28300                                  	;			;AN022; close the file
 28301                                  	; 26/03/2023
 28302                                  DestDel_fclosed:
 28303 000042D2 E82700                  	call	DestDelete
 28304                                  FILECLOSED:
 28305 000042D5 FE06[359E]              	inc	byte [DestClosed]
 28306                                  RET50:
 28307 000042D9 F8                      	clc
 28308 000042DA C3                      	retn
 28309                                  	
 28310                                  Close_Cont:			;AN022; no error - co
 28311                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28312 000042DB 9D                      	popf
 28313 000042DC 7506                    	jnz	short CLOSEDONE
 28314 000042DE F7C28000                	test	dx,80h		; is the destination a device?
 28315                                  	;jnz	short CLOSEDONE	; yes, copy succeeded
 28316                                  	;call	DestDelete
 28317                                  	;jmp	short FILECLOSED
 28318                                  	; 26/03/2023
 28319 000042E2 74EE                    	jz	short DestDel_fclosed
 28320                                  CLOSEDONE:
 28321 000042E4 FF06[439E]              	inc	word [FileCnt]
 28322                                  	; 26/03/2023
 28323 000042E8 EBEB                    	jmp	short FILECLOSED
 28324                                  	
 28325                                  ;FILECLOSED:
 28326                                  ;	inc	byte [DestClosed]
 28327                                  ;RET50:
 28328                                  	;clc
 28329                                  	;retn
 28330                                  
 28331                                  FORGETIT:
 28332 000042EA 8B1E[2CA1]              	mov	bx,[DESTHAND]
 28333 000042EE E8B8FF                  	call	DODCLOSE	 ; close the dest	
 28334 000042F1 E80800                  	call	DestDelete
 28335 000042F4 C706[439E]0000          	mov	word [FileCnt],0 ; no files transferred
 28336 000042FA EBDD                    	jmp	short RET50
 28337                                  
 28338                                  ; ---------------------------------------------------------------------------
 28339                                  
 28340                                  	; 26/03/2023
 28341                                  DestDelete:
 28342 000042FC BA[D5A0]                	mov	dx,DestBuf
 28343 000042FF B441                    	mov	ah,Unlink ; 41h
 28344 00004301 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 28345                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 28346                                  			;		(no wildcards allowed)
 28347 00004303 C3                      	retn
 28348                                  
 28349                                  ; ---------------------------------------------------------------------------
 28350                                  
 28351                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28352                                  SOURCE_SET:
 28353 00004304 56                      	push	si
 28354 00004305 A1[0DA2]                	mov	ax,[STARTEL]
 28355 00004308 BE[92A1]                	mov	si,ScanBuf	; adjust to copy
 28356 0000430B 29F0                    	sub	ax,si
 28357 0000430D BF[38A1]                	mov	di,SrcBuf
 28358 00004310 01F8                    	add	ax,di
 28359 00004312 A3[35A1]                	mov	[SrcTail],ax
 28360 00004315 880E[34A1]              	mov	[SrcSiz],cl	; save its size
 28361 00004319 41                      	inc	cx		; include the nul
 28362 0000431A F3A4                    	rep	movsb		; save this source
 28363 0000431C 883E[37A1]              	mov	[SrcInfo],bh	; save info about it
 28364 00004320 5E                      	pop	si
 28365 00004321 89E8                    	mov	ax,bp		; switches so far
 28366 00004323 E8E802                  	call	SETASC		; set a,b switches accordingly
 28367 00004326 E8A3E9                  	call	SWITCH		; get any more switches on this arg
 28368                                  	;call	SETASC		; set
 28369                                  	;retn
 28370                                  	; 26/03/2023
 28371 00004329 E9E202                  	jmp	SETASC
 28372                                  
 28373                                  ; =============== S U B	R O U T	I N E =======================================
 28374                                  
 28375                                  ; MSDOS 6.0
 28376                                  
 28377                                  ;****************************************************************
 28378                                  ;*
 28379                                  ;* ROUTINE:	CleanupErr
 28380                                  ;*
 28381                                  ;* FUNCTION:	Issues extended error message for destination
 28382                                  ;*		if not alreay issued
 28383                                  ;*
 28384                                  ;* INPUT:	return from INT 21
 28385                                  ;*
 28386                                  ;* OUTPUT:	none
 28387                                  ;*
 28388                                  ;****************************************************************
 28389                                  
 28390                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28391                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28392                                  	; MSDOS 6.0 (MSDOS 5.0) COMMAND.COM
 28393                                  CleanUpErr:	;proc near		;AN022;
 28394                                  
 28395 0000432C 803E[4AA2]00            	cmp	byte [msg_flag],0	;AN022; have we already issued a message?
 28396 00004331 7511                    	jnz	short CleanupErr_Cont	;AN022; yes - don't issue duplicate error
 28397 00004333 E8FCDE                  	call	Set_Ext_Error_Msg	;AN022; set up error message
 28398 00004336 C706[B7A0][D5A0]        	mov	word [string_ptr_2],DestBuf 
 28399                                  					;AN022; get address of failed string
 28400 0000433C C606[F591]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 28401                                  					;AN022; put number of subst in control block
 28402 00004341 E8E111                  	call	std_eprintf		;AN022; issue the error message
 28403                                  CleanupErr_Cont:			;AN022;
 28404                                  getansw_8:	; 12/06/2023
 28405 00004344 C3                      	retn				;AN022; return to caller
 28406                                  
 28407                                  ;CleanUpErr	endp			;AN022;
 28408                                  
 28409                                  
 28410                                  ; 12/06/2023
 28411                                  ; ---------------------------------------------------------------------------
 28412                                  ; MSDOS 6.2(2) COMMAND.COM procedure only !
 28413                                  ; -----------------------------------------
 28414                                  ; Hex-Rays IDA / disassembled source code ! modified for NASM by Erdogan Tan
 28415                                  ; ---------------------------------------------------------------------------
 28416                                  
 28417                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28418                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:456Dh
 28419                                  
 28420                                  get_answer_YNA:
 28421 00004345 C606[09A2]00            	mov	byte [cox_dest_file],0	; clear validation flag
 28422 0000434A B80043                  	mov	ax,4300h
 28423 0000434D BA[D5A0]                	mov	dx,DestBuf
 28424 00004350 CD21                    	int	21h		; DOS -	2+ - GET FILE ATTRIBUTES
 28425                                  				; DS:DX	-> ASCIZ file name or directory
 28426                                  				; name without trailing	slash
 28427                                  	;jnc	short getansw_1
 28428                                  	;jmp	getansw_5
 28429                                  	; 12/06/2023
 28430 00004352 F5                      	cmc
 28431 00004353 73EF                    	jnc	short getansw_8 
 28432                                  getansw_1:
 28433 00004355 FE06[09A2]              	inc	byte [cox_dest_file]	; valid destination file
 28434 00004359 8D36[FDA1]              	lea	si,cox_sublist_buff
 28435 0000435D C7040B00                	mov	word [si],11		; sublist size, 11 bytes
 28436 00004361 C74402[D5A0]            	mov	word [si+2],DestBuf	; sublist value	(pointer)
 28437 00004366 8C5C04                  	mov	[si+4],ds		; sublist segment
 28438                                  	;mov	byte [si+6],1		; sub id (N of %N)
 28439 00004369 C6440710                	mov	byte [si+7],10h		; data type flags
 28440                                  	;mov	byte [si+8],0		; maximum length (chars)
 28441                                  	;mov	byte [si+9],0		; minimum length (chars)
 28442                                  	;mov	byte [si+10],0		; pad field character (0)
 28443                                  	; 12/06/2023
 28444 0000436D 31C9                    	xor	cx,cx
 28445 0000436F 894C08                  	mov	[si+8],cx ; 0
 28446 00004372 884C0A                  	mov	[si+10],cl ; 0
 28447 00004375 FEC1                    	inc	cl
 28448 00004377 884C06                  	mov	[si+6],cl ; 1	
 28449                                  
 28450                                  	; 12/06/2023
 28451                                  	;lea	si,cox_sublist_buff
 28452 0000437A B84F04                  	mov	ax,1103			; message number
 28453                                  					; 'Overwrite %1 (Yes/No/All)?'
 28454 0000437D BB0200                  	mov	bx,2			; std error (file handle = 2)
 28455                                  	; 12/06/2023
 28456                                  	;mov	cx,1			; byte count
 28457                                  	; cx = 1
 28458                                  	;mov	dh,0FFh			; message class	(utility)
 28459                                  	;xor	dl,dl			; control flag = 0
 28460 00004380 31D2                    	xor	dx,dx
 28461 00004382 FECE                    	dec	dh  ; dh = 0FFh
 28462 00004384 E87314                  	call	SYSDISPMSG
 28463                                  	; 12/06/2023
 28464                                  	;xor	bx,bx
 28465                                  	; bh = 0
 28466                                  getansw_2:
 28467 00004387 B8080C                  	mov	ax,0C08h
 28468 0000438A CD21                    	int	21h		; DOS -	CLEAR KEYBOARD BUFFER
 28469                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 28470                                  	;cmp	al,0
 28471                                  	;jz	short getansw_2
 28472                                  	; 12/06/2023
 28473 0000438C 20C0                    	and	al,al
 28474 0000438E 74F7                    	jz	short getansw_2
 28475 00004390 3C0D                    	cmp	al,0Dh
 28476 00004392 743B                    	je	short getansw_4
 28477 00004394 88C3                    	mov	bl,al
 28478 00004396 88C2                    	mov	dl,al
 28479 00004398 B82065                  	mov	ax,6520h
 28480 0000439B CD21                    	int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
 28481                                  				; AL = function	-
 28482 0000439D 3A16[CF6E]              	cmp	dl,[_Y_es]		; 'Y' ?
 28483 000043A1 740C                    	je	short getansw_3
 28484 000043A3 3A16[D06E]              	cmp	dl,[_N_o]		; 'N' ?
 28485 000043A7 7406                    	je	short getansw_3
 28486 000043A9 3A16[D16E]              	cmp	dl,[_A_ll]		; 'A' ?
 28487 000043AD 75D8                    	jne	short getansw_2
 28488                                  getansw_3:
 28489 000043AF 88DF                    	mov	bh,bl
 28490 000043B1 53                      	push	bx
 28491 000043B2 881E[CE6E]              	mov	[MSG_1104],bl
 28492 000043B6 B440                    	mov	ah,40h
 28493 000043B8 BB0200                  	mov	bx,2			; std error (file handle = 2)
 28494 000043BB B90100                  	mov	cx,1			; byte count
 28495 000043BE BA[CE6E]                	mov	dx,MSG_1104
 28496 000043C1 CD21                    	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28497                                  				; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
 28498 000043C3 B440                    	mov	ah,40h
 28499 000043C5 C606[CE6E]08            	mov	byte [MSG_1104],8	; backspace (move cursor to back)
 28500 000043CA CD21                    	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28501                                  				; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
 28502 000043CC 5B                      	pop	bx
 28503 000043CD EBB8                    	jmp	short getansw_2
 28504                                  getansw_4:
 28505                                  	;cmp	bh,0
 28506                                  	;jz	short getansw_2
 28507                                  	; 12/06/2023
 28508 000043CF 08FF                    	or	bh,bh
 28509 000043D1 74B4                    	jz	short getansw_2
 28510 000043D3 88FA                    	mov	dl,bh
 28511 000043D5 B82065                  	mov	ax,6520h
 28512 000043D8 CD21                    	int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
 28513                                  				; AL = function	-
 28514 000043DA 52                      	push	dx
 28515 000043DB B82E04                  	mov	ax,1070			; message number
 28516 000043DE BB0200                  	mov	bx,2			; std error (file handle = 2)
 28517 000043E1 31C9                    	xor	cx,cx
 28518                                  	;mov	dh,0FFh			; message class	(utility)
 28519                                  	;xor	dl,dl
 28520                                  	; 12/06/2023
 28521 000043E3 31D2                    	xor	dx,dx
 28522 000043E5 FECE                    	dec	dh  ; dh = 0FFh
 28523 000043E7 E81014                  	call	SYSDISPMSG
 28524 000043EA 5A                      	pop	dx
 28525 000043EB 3A16[CF6E]              	cmp	dl,[_Y_es]
 28526 000043EF 740B                    	jz	short getansw_5
 28527 000043F1 3A16[D06E]              	cmp	dl,[_N_o]
 28528 000043F5 7406                    	jz	short getansw_6
 28529 000043F7 C606[08A2]00            	mov	byte [cox_y_override],0
 28530                                  	; 12/06/2023
 28531                                  	;jmp	short $+2
 28532                                  getansw_5:
 28533                                  	; 12/06/2023
 28534                                  	;clc
 28535                                  	; cf = 0
 28536                                  	;jmp	short getansw_7
 28537                                  	; 12/06/2023
 28538 000043FC C3                      	retn
 28539                                  getansw_6:
 28540                                  gcpcmdo_2:	; 12/06/2023
 28541                                  gecpcmd_3:	; 12/06/2023
 28542 000043FD F9                      	stc
 28543                                  getansw_7:
 28544 000043FE C3                      	retn
 28545                                  
 28546                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28547                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:463Ah
 28548                                  init_copycmd_option:
 28549 000043FF C606[08A2]01            	mov	byte [cox_y_override],1 ; suppress copy overwrite confirmation
 28550 00004404 06                      	push	es
 28551 00004405 8E06[159E]              	mov	es,[RESSEG]
 28552 00004409 268E06[DC03]            	mov	es,[es:EnvirSeg]
 28553 0000440E 8D36[1E99]              	lea	si,copycmd		; "COPYCMD="
 28554 00004412 B90800                  	mov	cx,8
 28555 00004415 E83500                  	call	getenv_copycmd
 28556 00004418 7216                    	jc	short icpcmd_3
 28557 0000441A E82000                  	call	get_copycmd_option	; copycmd=/Y or copycmd=/-Y
 28558 0000441D 720F                    	jc	short icpcmd_2
 28559 0000441F 47                      	inc	di			; skip '/'
 28560 00004420 268A05                  	mov	al,[es:di]
 28561 00004423 24DF                    	and	al,0DFh			; convert to uppercase
 28562 00004425 3C59                    	cmp	al,'Y'
 28563 00004427 7505                    	jnz	short icpcmd_2
 28564                                  icpcmd_1:
 28565 00004429 C606[08A2]00            	mov	byte [cox_y_override],0	; clear copy overwrite question/confirmation
 28566                                  					; (don't suppress)
 28567                                  icpcmd_2:
 28568 0000442E 07                      	pop	es
 28569 0000442F C3                      	retn
 28570                                  icpcmd_3:				; ...
 28571 00004430 8E06[159E]              	mov	es,[RESSEG]
 28572 00004434 803E[9B01]00            	cmp	byte [cox_Y_option],0	; default (/Y) switch option (1 = enabled)
 28573 00004439 74F3                    	jz	short icpcmd_2
 28574 0000443B EBEC                    	jmp	short icpcmd_1
 28575                                  
 28576                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28577                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:4679h
 28578                                  get_copycmd_option:
 28579 0000443D 26803D00                	cmp	byte [es:di],0
 28580 00004441 74BA                    	jz	short gcpcmdo_2
 28581 00004443 26803D2F                	cmp	byte [es:di],'/'
 28582 00004447 7403                    	jz	short gcpcmdo_1
 28583 00004449 47                      	inc	di
 28584 0000444A EBF1                    	jmp	short get_copycmd_option
 28585                                  gcpcmdo_1:
 28586                                  	; 12/06/2023
 28587                                  	;clc
 28588                                  	; cf = 0
 28589                                  	;jmp	short gcpcmdo_3
 28590                                  	; 12/06/2023
 28591 0000444C C3                      	retn
 28592                                  	; 12/06/2023
 28593                                  ;gcpcmdo_2:
 28594                                  ;	stc
 28595                                  ;gcpcmdo_3:
 28596                                  ;	retn
 28597                                  
 28598                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28599                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:468Dh
 28600                                  getenv_copycmd:
 28601 0000444D 31FF                    	xor	di,di
 28602 0000444F 30C0                    	xor	al,al
 28603                                  gecpcmd_1:
 28604                                  	;cmp	byte [es:di],0
 28605                                  	; 12/06/2023
 28606 00004451 263805                  	cmp	[es:di],al ; 0
 28607 00004454 74A7                    	jz	short gecpcmd_3
 28608 00004456 51                      	push	cx
 28609 00004457 56                      	push	si
 28610 00004458 F3A6                    	repe	cmpsb
 28611 0000445A 5E                      	pop	si
 28612 0000445B 59                      	pop	cx
 28613 0000445C 7409                    	jz	short gecpcmd_2 ; cf = 0
 28614 0000445E 51                      	push	cx
 28615 0000445F B90080                  	mov	cx,32768
 28616 00004462 F2AE                    	repne	scasb	; al = 0
 28617 00004464 59                      	pop	cx
 28618 00004465 EBEA                    	jmp	short gecpcmd_1
 28619                                  gecpcmd_2:
 28620                                  	;clc
 28621                                  	; 12/06/2023
 28622                                  	; cf = 0
 28623                                  	;jmp	short gecpcmd_4
 28624                                  	; 12/06/2023
 28625 00004467 C3                      	retn
 28626                                  	; 12/06/2023
 28627                                  ;gecpcmd_3:
 28628                                  ;	stc
 28629                                  ;gecpcmd_4:
 28630                                  ;	retn
 28631                                  
 28632                                  ;============================================================================
 28633                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 28634                                  ;============================================================================
 28635                                  ; 01/10/2018 - Retro DOS v3.0
 28636                                  
 28637                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 28638                                  
 28639                                  ; =============== S U B	R O U T	I N E =======================================
 28640                                  
 28641                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 28642                                  ;
 28643                                  ;	EXIT	ZR set if concatenate flag unchanged
 28644                                  
 28645                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28646                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3EEAh
 28647                                  
 28648                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28649                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:46ADh
 28650                                  TRYFLUSH:
 28651 00004468 A0[2A9E]                	mov	al,[Concat]
 28652 0000446B 50                      	push	ax
 28653                                  	;call	FLUSHFIL
 28654 0000446C E80600                  	call	FlshFil
 28655 0000446F 58                      	pop	ax
 28656 00004470 3A06[2A9E]              	cmp	al,[Concat]
 28657 00004474 C3                      	retn
 28658                                  
 28659                                  ; =============== S U B	R O U T	I N E =======================================
 28660                                  
 28661                                  	; 26/03/2023
 28662                                  	; MSDOS 3.3
 28663                                  ;FLUSHFIL:
 28664                                  	;mov	al,[BINARY]
 28665                                  	;mov	ah,[ASCII]
 28666                                  	;push	ax
 28667                                  	;call	FLSHFIL
 28668                                  	;pop	ax
 28669                                  	;mov	[ASCII],ah
 28670                                  	;mov	[BINARY],al
 28671                                  	;retn
 28672                                  
 28673                                  ; =============== S U B	R O U T	I N E =======================================
 28674                                  
 28675                                  ;***	Flshfil - write out any data remaining in copy buffer.
 28676                                  ;
 28677                                  ;	Inputs:
 28678                                  ;	  [NXTADD] = No. of bytes to write
 28679                                  ;	  [CFLAG] <> 0 if file has been created
 28680                                  ;	Outputs:
 28681                                  ;	  [NXTADD] = 0
 28682                                  
 28683                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28684                                  	;
 28685                                  	; 13/06/2023 - Retro DOS v4.2 COMMAND.COM
 28686                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:46BAh
 28687                                  FlshFil:
 28688 00004475 C606[F0A1]00            	mov	byte [TERMREAD],0
 28689 0000447A 803E[349E]00            	cmp	byte [CFLAG],0
 28690 0000447F 7403                    	jz	short NotExists
 28691 00004481 E99600                  	jmp	Exists
 28692                                  NotExists:
 28693 00004484 E8A101                  	call	BUILDDEST		; find out all about the destination
 28694 00004487 E8FA03                  	call	COMPNAME		; source and dest. the same?
 28695 0000448A 7519                    	jnz	short ProcDest		; if not, go ahead
 28696 0000448C 803E[91A1]00            	cmp	byte [SRCISDEV],0
 28697 00004491 7512                    	jnz	short ProcDest		; same name on device ok
 28698 00004493 803E[2A9E]00            	cmp	byte [Concat],0		; concatenation?
 28699 00004498 BA[1C92]                	mov	dx,OVERWR_PTR
 28700                                  	;je	short COPERR		; not concatenating - overwrite error
 28701                                  	; 26/03/2023
 28702 0000449B 7503                    	jne	short No_Concat_Err
 28703 0000449D E91201                  	jmp	COPYERR
 28704                                  	
 28705                                  No_Concat_Err:	; concatenating
 28706 000044A0 C606[ECA1]01            	mov	byte [NOWRITE],1 	; flag not writing (just seeking)
 28707                                  ProcDest:
 28708                                  	; MSDOS 6.0
 28709                                  	;mov	ax,(ExtOpen<<8)		; open the file
 28710                                  	; 26/03/2023
 28711 000044A5 B8006C                  	mov	ax,6C00h
 28712 000044A8 BE[D5A0]                	mov	si,DestBuf		; get file name
 28713                                  ;M046
 28714                                  ; For writes, we want to deny writes by anyone else at the same time that we
 28715                                  ;are writing to it. For instance, on a network, 2 workstations could try
 28716                                  ;writing to the same file. Also, because we opened the source file with
 28717                                  ;DENY NONE, it is fine if the source and destination files are the same as
 28718                                  ;would happen when we append to an existing file.
 28719                                  
 28720                                  	; 26/03/2023
 28721                                  	;mov	bx,deny_write|write_open_mode
 28722 000044AB BB2100                  	mov	bx,21h			; get open mode for copy; M046
 28723 000044AE 31C9                    	xor	cx,cx			; no special files
 28724                                  	;mov	dx,write_open_flag	; set up open flags
 28725 000044B0 BA0101                  	mov	dx,101h	
 28726                                  
 28727 000044B3 803E[ECA1]00            	cmp	byte [NOWRITE],0
 28728 000044B8 7503                    	jne	short DoDestOpen	; don't actually create if nowrite set
 28729                                  	;mov	dx,creat_open_flag	; set up create flags
 28730 000044BA BA1201                  	mov	dx,112h
 28731                                  
 28732                                  	; 26/03/2023
 28733                                  	; MSDOS 3.3
 28734                                  	;mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 28735                                  	;cmp	byte [NOWRITE],0
 28736                                  	;jne	short DODESTOPEN
 28737                                  	;mov	ah,CREAT ; 3Ch
 28738                                  	;xor	cx,cx
 28739                                  ;DODESTOPEN:
 28740                                  	;mov	dx,DESTBUF
 28741                                  	;int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 28742                                  	;		; CX = attributes for file
 28743                                  	;		; DS:DX	-> ASCIZ filename (may include drive and path)
 28744                                  
 28745                                  ; 26/03/2023
 28746                                  ;	; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 28747                                  ;	;mov	dx,FULDIRPTR
 28748                                  ;	;call	GET_EXT_ERR_NUMBER
 28749                                  ;	;jc	short COPERR
 28750                                  ;
 28751                                  ;	; 01/10/2018
 28752                                  ;	;jnc	short DEST_OPEN_OKAY
 28753                                  ;		
 28754                                  ;	;mov	dx,FULDIRPTR
 28755                                  ;	;call	GET_EXT_ERR_NUMBER
 28756                                  ;	;jmp	short COPERR
 28757                                  ;
 28758                                  ;	jc	short DEST_OPEN_ERROR
 28759                                  
 28760                                  	; 26/03/2023
 28761                                  DoDestOpen:
 28762 000044BD CD21                    	int     21h	; DOS - 4.0 - EXTENDED OPEN/CREATE
 28763                                  			; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
 28764                                  			; BH = flags
 28765                                  			; CX = create attribute
 28766                                  			; DL = action if file exists/does not exists
 28767                                  			; DH = 00h (reserved), DS:SI -> ASCIZ file name
 28768                                  
 28769                                  ;	We assume that the error is normal.
 28770                                  ;	TriageError will correct the DX value appropriately.
 28771                                  	
 28772 000044BF 7311                    	jnc	short Dest_Open_Okay
 28773                                  Xa_Set_Error:				;AN030; error occurred on XA
 28774 000044C1 E86EDD                  	call	Set_Ext_Error_Msg	;AN030; get extended error
 28775                                  
 28776                                  	; 26/04/2023 - Retro DOS v4.0 ( 4.1) COMMAND.COM
 28777                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3F46h
 28778                                  Ext_Err_Set:				;AN030;
 28779 000044C4 C706[B7A0][D5A0]        	mov	word [string_ptr_2],DestBuf
 28780                                  					;AN000; get address of failed string
 28781 000044CA C606[F591]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 28782                                  					;AN030; put number of subst in control block
 28783                                  CopErrJ2:				;AN030;
 28784 000044CF E9E000                  	jmp	COPYERR			;AN030; go issue message
 28785                                  
 28786                                  ;DEST_OPEN_OKAY:
 28787                                  	; 26/03/2023
 28788                                  Dest_Open_Okay:
 28789 000044D2 A3[2CA1]                	mov	[DESTHAND],ax		; save handle
 28790 000044D5 C606[349E]01            	mov	byte [CFLAG],1		; destination now exists
 28791 000044DA 89C3                    	mov	bx,ax
 28792 000044DC B80044                  	mov	ax,IOCTL*256 ; 4400h 	; get device stuff
 28793 000044DF CD21                    	int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 28794                                  			   	; BX = file or device handle
 28795                                  
 28796 000044E1 8816[2EA1]              	mov	[DESTISDEV],dl		; set dest info
 28797                                  	; 18/04/2023
 28798 000044E5 F6C280                  	test	dl,80h
 28799                                  	;test	dl,devid_ISDEV
 28800 000044E8 7430                    	jz	short Exists		; Dest not a device
 28801                                  
 28802                                  ;	Destination is device.
 28803                                  
 28804 000044EA A0[309E]                	mov	al,[DestSwitch]
 28805                                  	; 26/03/2023
 28806 000044ED 240C                    	and	al,0Ch
 28807                                  	;and	al,SWITCHA+SWITCHB ; 4+8
 28808 000044EF 7509                    	jnz	short TestBoth
 28809 000044F1 A0[F1A1]                	mov	al,[ASCII]		; neither set, use current setting
 28810 000044F4 0A06[EDA1]              	or	al,[BINARY]
 28811 000044F8 7416                    	jz	short ExSetA		; neither set, default to ascii
 28812                                  TestBoth:
 28813 000044FA 7A1E                    	jpe	short Exists		; both are set, ignore
 28814 000044FC A808                    	test	al,8
 28815                                  	;test	al,SWITCHB
 28816 000044FE 741A                    	jz	short Exists
 28817                                  	;mov	ax,(IOCTL shl 8) or 1
 28818 00004500 B80144                  	mov	ax,(IOCTL<<8)|1 ; 4401h
 28819 00004503 30F6                    	xor	dh,dh
 28820                                  	; 18/04/2023
 28821 00004505 80CA20                  	or	dl,20h
 28822                                  	;or	dl,devid_RAW
 28823 00004508 8816[2EA1]              	mov	[DESTISDEV],dl
 28824 0000450C CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 28825                                  			; BX = device handle,DH = 0
 28826                                  			; DL = device information to set (bits 0-7 from	function 0)
 28827 0000450E EB0A                    	jmp	short Exists
 28828                                  
 28829                                  	; 26/03/2023
 28830                                  	; 01/10/2018 - Retro DOS v3.0 modification
 28831                                  ;DEST_OPEN_ERROR:
 28832                                  	;mov	dx,FULDIRPTR
 28833                                  	;call	GET_EXT_ERR_NUMBER
 28834                                  ;COPERR:
 28835                                  	; 26/03/2023
 28836                                  ;CopyErrj:
 28837                                  	;jmp	short COPYERR
 28838                                  
 28839                                  ExSetA:
 28840                                  ;	What we read in may have been in binary mode, flag zapped write OK
 28841                                  
 28842 00004510 C606[F1A1]04            	mov	byte [ASCII],4
 28843                                  	;mov	byte [ASCII],SWITCHA	; set ascii mode
 28844 00004515 800E[EBA1]04            	or	byte [INEXACT],4
 28845                                  	;or	byte [INEXACT],SWITCHA	; ascii -> inexact
 28846                                  Exists:
 28847 0000451A 803E[ECA1]00            	cmp	byte [NOWRITE],0
 28848 0000451F 7524                    	jnz	short NoChecking	; if nowrite don't bother with name check
 28849 00004521 803E[ADA0]01            	cmp	byte [plus_comma],1	; don't check if just doing +,,
 28850 00004526 741D                    	jz	short NoChecking
 28851 00004528 E85903                  	call	COMPNAME		; source and dest. the same?
 28852 0000452B 7518                    	jnz	short NoChecking	; if not, go ahead
 28853 0000452D 803E[91A1]00            	cmp	byte [SRCISDEV],0
 28854 00004532 7511                    	jne	short NoChecking	; same name on device ok
 28855                                  
 28856                                  ;	At this point we know in append (would have gotten overwrite error
 28857                                  ;	on first destination create otherwise), and user trying to specify
 28858                                  ;	destination which has been scribbled already (if dest had been named
 28859                                  ;	first, NoWrite would be set).
 28860                                  
 28861 00004534 BA[1F92]                	mov	dx,LOSTERR_PTR		; tell him he's not going to get it
 28862                                  	;invoke	Std_EprintF		;ac022;
 28863                                  	; 26/03/2023
 28864 00004537 E8EB0F                  	call	std_eprintf ; MSDOS 6.0 (& 5.0)
 28865                                  	;call	STD_PRINTF  ; MSDOS 3.3	
 28866 0000453A C706[3A9E]0000          	mov	word [NXTADD],0		; set return
 28867 00004540 FE06[F0A1]              	inc	byte [TERMREAD]		; tell read to give up
 28868                                  Ret60:
 28869 00004544 C3                      	retn
 28870                                  
 28871                                  NoChecking:
 28872 00004545 8B1E[2CA1]              	mov	bx,[DESTHAND]		; get handle
 28873 00004549 31C9                    	xor	cx,cx
 28874 0000454B 870E[3A9E]              	xchg	cx,[NXTADD]
 28875 0000454F E3F3                    	jcxz	Ret60			; if nothing to write, forget it
 28876 00004551 FF06[EEA1]              	inc	word [WRITTEN]		; flag that we wrote something
 28877 00004555 803E[ECA1]00            	cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 28878 0000455A 7514                    	jnz	short SeekEnd
 28879 0000455C 31D2                    	xor	dx,dx
 28880 0000455E 1E                      	push	ds
 28881 0000455F 8E1E[179E]              	mov	ds,[TPA]
 28882 00004563 B440                    	mov	ah,Write ; 40h
 28883 00004565 CD21                    	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28884                                  			; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 28885 00004567 1F                      	pop	ds
 28886 00004568 BA[0792]                	mov	dx,NOSPACE_PTR
 28887                                  	;jc	short COPERRP		; failure
 28888                                  	; 26/03/2023
 28889                                  	; MSDOS 6.0
 28890 0000456B 7326                    	jnc	short NoChecking2
 28891 0000456D E951FF                  	jmp	Xa_Set_Error
 28892                                  
 28893                                  	; 18/04/2023
 28894                                  	; 26/03/2023
 28895                                  SeekEnd:
 28896 00004570 31D2                    	xor	dx,dx
 28897 00004572 87D1                    	xchg	dx,cx
 28898                                  	;mov	ax,(LSEEK shl 8) or 1
 28899 00004574 B80142                  	mov	ax,(LSEEK<<8)|1 ; 4201h
 28900 00004577 CD21                    	int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 28901                                  				; AL = method: offset from present location
 28902                                  
 28903                                  	; 26/03/2023
 28904                                  	; MSDOS 6.0
 28905                                  
 28906                                  ;	Save the file pointer in DX:AX to restore the file
 28907                                  ;	with in case the copy should fail.
 28908                                  
 28909 00004579 A3[F8A1]                	mov	[OFilePtr_Lo],ax
 28910 0000457C 8916[FAA1]              	mov	[OFilePtr_Hi],dx
 28911                                  
 28912                                  	; 26/03/2023
 28913                                  	; MSDOS 3.3  MSDOS 6.0
 28914                                  
 28915 00004580 803E[289E]00            	cmp	byte [RDEOF],0
 28916 00004585 740B                    	jz	short Retz60
 28917                                  
 28918                                  ;	^Z has been read - we must set the file size to the current
 28919                                  ;	file pointer location
 28920                                  
 28921 00004587 B440                    	mov	ah,Write ; 40h
 28922 00004589 CD21                    	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28923                                  				; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 28924                                  
 28925                                  	; 26/03/2023
 28926                                  	; MSDOS 6.0
 28927 0000458B 727E                    	jc	short Xa_Set_Error_Jmp	;AC022; failure
 28928                                  
 28929                                  ;	Make note that ^Z was removed, in case the
 28930                                  ;	copy should fail and we need to restore the file.
 28931                                  
 28932 0000458D C606[FCA1]1A            	mov	byte [OCtrlZ],1Ah
 28933                                  Retz60:
 28934 00004592 C3                      	retn
 28935                                  
 28936                                  NoChecking2:
 28937 00004593 29C1                    	sub	cx,ax
 28938 00004595 74AD                    	jz	short Ret60		; wrote all supposed to
 28939                                  	; 18/04/2023
 28940 00004597 F606[2EA1]80            	test	byte [DESTISDEV],80h ; devid_ISDEV
 28941                                  	;test	byte [DESTISDEV],devid_ISDEV ;80h
 28942 0000459C 7414                    	jz	short COPYERR		; is a file, error
 28943 0000459E F606[2EA1]20            	test	byte [DESTISDEV],20h  ; devid_RAW
 28944                                  	;test	byte [DESTISDEV],devid_RAW ; 20h
 28945 000045A3 750A                    	jnz	short DevWrtErr	; is a raw device, error
 28946 000045A5 803E[EBA1]00            	cmp	byte [INEXACT],0
 28947 000045AA 7598                    	jnz	short Ret60		; inexact so ok
 28948 000045AC 49                      	dec	cx
 28949                                  ;Retz60:
 28950 000045AD 7495                    	jz	short Ret60		; wrote one byte less (the ^z)		
 28951                                  
 28952                                  DevWrtErr:
 28953 000045AF BA[8A93]                	mov	dx,DEVWMES_PTR
 28954                                  	; 26/03/2023
 28955                                  COPYERR:
 28956                                  	;invoke	Std_EPrintF		;AC022;
 28957 000045B2 E8700F                  	call	std_eprintf  ; MSDOS 6.0
 28958                                  	;call	STD_PRINTF   ; MSDOS 3.3
 28959                                  CopErrP:
 28960 000045B5 FE06[359E]              	inc	byte [DestClosed]
 28961 000045B9 803E[349E]00            	cmp	byte [CFLAG],0
 28962 000045BE 7448                    	jz	short EndCopyJ		; never actually got it open
 28963 000045C0 8B1E[2CA1]              	mov	bx,[DESTHAND]
 28964 000045C4 83FB00                  	cmp	bx,0
 28965 000045C7 7E33                    	jle	short NoClose
 28966                                  
 28967                                  ;	Check to see if we should save part of the destination file.
 28968                                  
 28969                                  	; 26/03/2023
 28970                                  	; MSDOS 6.0
 28971 000045C9 8B0E[FAA1]              	mov	cx,[OFilePtr_Hi]	; CX = hi word of original file ptr
 28972 000045CD 8B16[F8A1]              	mov	dx,[OFilePtr_Lo]	; DX = lo word of original file ptr
 28973                                  			
 28974 000045D1 89C8                    	mov	ax,cx
 28975 000045D3 09D0                    	or	ax,dx
 28976 000045D5 7421                    	jz	short ceClose		; null file ptr means nothing to save
 28977                                  
 28978                                  ;	Destination was also the first source. Do the best we can to
 28979                                  ;	restore it. Truncate it back to the size we took from it (which
 28980                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 28981                                  ;	file). If a Ctrl-Z was originally read, put it back.
 28982                                  
 28983 000045D7 B80042                  	mov	ax,(LSEEK<<8) ; 4200h
 28984 000045DA CD21                    	int	21h
 28985                                  
 28986 000045DC 31C9                    	xor	cx,cx			; CX = # bytes to write = 0
 28987 000045DE B440                    	mov	ah,Write ; 40h
 28988 000045E0 CD21                    	int	21h			; truncate file
 28989                                  
 28990 000045E2 803E[FCA1]00            	cmp	byte [OCtrlZ],0
 28991 000045E7 7408                    	je	short ceClose0		; no ctrl-z removed from original
 28992 000045E9 41                      	inc	cx			; CX = # bytes to write = 1
 28993 000045EA BA[FCA1]                	mov	dx,OCtrlZ		; DS:DX = ptr to original ctrl-z
 28994 000045ED B440                    	mov	ah,Write ; 40h
 28995 000045EF CD21                    	int	21h			; write ctrl-z
 28996                                  ceClose0:
 28997 000045F1 B43E                    	mov	ah,CLOSE ; 3Eh
 28998 000045F3 CD21                    	int	21h			; close it
 28999                                  ;;	;mov	byte [CFLAG],0
 29000 000045F5 E9ECF8                  	jmp	ENDCOPY			; and go home
 29001                                  
 29002                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29003                                  ceClose:
 29004 000045F8 B43E                    	mov	ah,CLOSE ; 3Eh		; close the file
 29005 000045FA CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 29006                                  				; BX = file handle
 29007                                  NoClose:
 29008 000045FC BA[D5A0]                	mov	dx,DestBuf
 29009 000045FF B441                    	mov	ah,Unlink ; 41h 	; and delete it
 29010 00004601 CD21                    	int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 29011                                  				; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 29012 00004603 C606[349E]00            	mov	byte [CFLAG],0
 29013                                  EndCopyJ:
 29014 00004608 E9D9F8                  	jmp	ENDCOPY
 29015                                  
 29016                                  Xa_Set_Error_Jmp:			;AN022; go set up error message
 29017 0000460B E9B3FE                  	jmp	Xa_Set_Error
 29018                                  
 29019                                  ;============================================================================
 29020                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 29021                                  ;============================================================================
 29022                                  ; 01/10/2018 - Retro DOS v3.0
 29023                                  
 29024                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 29025                                  
 29026                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29027                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4095h
 29028                                  
 29029                                  ; =============== S U B	R O U T	I N E =======================================
 29030                                  
 29031                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 29032                                  ;
 29033                                  ;	Given switch vector in AX,
 29034                                  ;	  Set Ascii flag if /a is set
 29035                                  ;	  Clear Ascii flag if /b is set
 29036                                  ;	  Binary set if /b specified
 29037                                  ;	  Leave Ascii unchanged if neither or both are set
 29038                                  ; 	Also sets Inexact if Ascii is ever set. 
 29039                                  ;	AL = Ascii on exit, flags set
 29040                                  
 29041                                  	; 26/03/2023
 29042                                  SETASC:
 29043                                  	;and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 29044 0000460E 240C                    	and	al,0Ch ; 4+8
 29045 00004610 7A10                    	jpe	short LOADSW	; even parity - both or neither
 29046 00004612 50                      	push	ax
 29047                                  	;and	al,SWITCHB  ; 8
 29048 00004613 2408                    	and	al,8
 29049 00004615 A2[EDA1]                	mov	[BINARY],al
 29050 00004618 58                      	pop	ax
 29051                                  	;and	al,SWITCHA
 29052 00004619 2404                    	and	al,4	
 29053 0000461B A2[F1A1]                	mov	[ASCII],al
 29054 0000461E 0806[EBA1]              	or	[INEXACT],al
 29055                                  LOADSW:
 29056 00004622 A0[F1A1]                	mov	al,[ASCII]
 29057 00004625 08C0                    	or	al,al
 29058 00004627 C3                      	retn
 29059                                  
 29060                                  ; =============== S U B	R O U T	I N E =======================================
 29061                                  
 29062                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29063                                  	; 13/06/2023 - Retro DOS v4.2 COMMAND.COM
 29064                                  BUILDDEST:
 29065 00004628 803E[D0A0]FF            	cmp	byte [DestIsDir],-1 ; 0FFh
 29066 0000462D 750C                    	jnz	short KNOWABOUTDEST	; figuring already done
 29067 0000462F BF[F79C]                	mov	di,USERDIR1
 29068 00004632 BD[D0A0]                	mov	bp,DestVars
 29069 00004635 E8E000                  	call	BUILDPATH
 29070 00004638 E896E3                  	call	RestUDir1
 29071                                  
 29072                                  ;	We now know all about the destination
 29073                                  
 29074                                  KNOWABOUTDEST:
 29075 0000463B 30C0                    	xor	al,al
 29076 0000463D 8606[2FA1]              	xchg	al,[FIRSTDEST]
 29077 00004641 08C0                    	or	al,al
 29078 00004643 7503                    	jnz	short FIRSTDST
 29079 00004645 E98D00                  	jmp	NOFIRSTDEST
 29080                                  
 29081                                  FIRSTDST:
 29082                                  ;	Create an fcb of the original dest.
 29083                                  
 29084 00004648 8B36[D2A0]              	mov	si,[DestTail]
 29085 0000464C BF[0DA0]                	mov	di,DestFcb
 29086 0000464F B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 29087 00004652 CD21                    	int	21h		; DOS -	PARSE FILENAME
 29088                                  				; DS:SI	-> string to parse
 29089                                  				; ES:DI	-> buffer to fill with unopened	FCB
 29090                                  				; AL = bit mask	to control parsing
 29091 00004654 803C00                  	cmp	byte [si],0
 29092 00004657 7406                    	jz	short GOODPARSE
 29093                                  
 29094                                  	; 27/03/2023	
 29095                                  	; MSDOS 6.0
 29096                                  	;mov	byte [di+1],"|"	;AD052; must be illegal file name character
 29097                                  	
 29098 00004659 BA[0D92]                	mov	dx,FULLDIR_PTR		;AN052; issue "file creation error"
 29099 0000465C E953FF                  	jmp	COPYERR			;AN052;
 29100                                  GOODPARSE:
 29101 0000465F A1[D5A0]                	mov	ax,[DestBuf]		; AX = possible "d:"
 29102 00004662 80FC3A                  	cmp	ah,':'
 29103 00004665 7402                    	jz	short DRVSPEC4
 29104 00004667 B040                    	mov	al,'@'  ; 40h
 29105                                  DRVSPEC4:
 29106                                  ;	AX = "d:" for following FCB drive computation
 29107                                  
 29108 00004669 8A0E[F1A1]              	mov	cl,[ASCII]		; CL = saved Ascii flag
 29109 0000466D 0C20                    	or	al,20h
 29110 0000466F 2C60                    	sub	al,60h
 29111 00004671 A2[0DA0]                	mov	[DestFcb],al		; store drive # in FCB
 29112                                  
 29113                                  ;*	Figure out what copy mode we're in.
 29114                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 29115                                  ;	+n stands for additional sources delimited by +'s.
 29116                                  ;
 29117                                  ;	copy a b	not concatenating
 29118                                  ;	copy a *	not concatenating
 29119                                  ;	copy * a	concatenating
 29120                                  ;	copy * *	not concatenating
 29121                                  ;	copy a+n b	concatenating
 29122                                  ;	copy *+n a	concatenating
 29123                                  ;	copy *+n *	concatenating, Mel Hallerman style
 29124                                  
 29125                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 29126                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 29127                                  
 29128 00004674 A0[D4A0]                	mov	al,[DestInfo]		; AL = destination CParse flags
 29129 00004677 8A26[37A1]              	mov	ah,[SrcInfo]		; AH = source CParse flags
 29130 0000467B 250202                  	and	ax,202h			; AH,AL = source,dest wildcard flags
 29131 0000467E 08C0                    	or	al,al
 29132 00004680 7413                    	jz	short NOTMELCOPY 	; no destination wildcard
 29133                                  
 29134                                  ;	Destination is wildcarded.
 29135                                  	
 29136 00004682 38E0                    	cmp	al,ah
 29137 00004684 750F                    	jnz	short NOTMELCOPY ; no source wildcard
 29138                                  
 29139                                  ;	Source and destination are both wildcarded.
 29140                                  
 29141 00004686 803E[F2A1]00            	cmp	byte [PLUS],0
 29142 0000468B 7408                    	jz	short NOTMELCOPY	; no +'s in source
 29143                                  
 29144                                  ;	Source and destination are wildcarded, and source includes +'s.
 29145                                  ;	It's Mel Hallorman copy time.
 29146                                  
 29147 0000468D FE06[30A1]              	inc	byte [MELCOPY]		; 'Mel copy' = true
 29148 00004691 30C0                    	xor	al,al
 29149 00004693 EB06                    	jmp	short SETCONC
 29150                                  
 29151                                  NOTMELCOPY:
 29152 00004695 3402                    	xor	al,2			; AL=0 -> ambiguous destination, 2 otherwise
 29153 00004697 20E0                    	and	al,ah
 29154 00004699 D0E8                    	shr	al,1			; AL=1 -> ambiguous source, unambiguous dest
 29155                                  					;   (implies concatenation)
 29156                                  SETCONC:
 29157 0000469B 0A06[F2A1]              	or	al,[PLUS]		; "+" always infers concatenation
 29158                                  
 29159                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 29160                                  
 29161 0000469F A2[2A9E]                	mov	[Concat],al
 29162 000046A2 D0E0                    	shl	al,1
 29163 000046A4 D0E0                    	shl	al,1
 29164 000046A6 A2[EBA1]                	mov	[INEXACT],al		; concatenation -> inexact copy
 29165 000046A9 803E[EDA1]00            	cmp	byte [BINARY],0
 29166 000046AE 7525                    	jne	short NOFIRSTDEST 	; explicit binary copy	
 29167                                  
 29168                                  	; 13/06/2023 - Retro DOS v4.2 COMMAND.COM
 29169                                  	; MSDOS 6.0 (MSDOS.50)
 29170                                  	;mov	[ASCII],al		; otherwise, concatenate in ascii mode
 29171                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:48FAh
 29172 000046B0 0806[F1A1]              	or	[ASCII],al	
 29173                                  
 29174 000046B4 08C9                    	or	cl,cl
 29175 000046B6 751D                    	jnz	short NOFIRSTDEST 	; Ascii flag set before, data read correctly	
 29176 000046B8 08C0                    	or	al,al
 29177 000046BA 7419                    	jz	short NOFIRSTDEST 	; Ascii flag did not change state
 29178                                  
 29179                                  ;	At this point there may already be binary read data in the read
 29180                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 29181                                  ;	amount of data in the buffer correctly.
 29182                                  
 29183 000046BC 8B0E[3A9E]              	mov	cx,[NXTADD]
 29184 000046C0 E313                    	jcxz	NOFIRSTDEST		; no data, everything ok
 29185 000046C2 B01A                    	mov	al,1Ah
 29186 000046C4 06                      	push	es
 29187 000046C5 31FF                    	xor	di,di
 29188 000046C7 8E06[179E]              	mov	es,[TPA]
 29189 000046CB F2AE                    	repne	scasb			; scan for EOF
 29190 000046CD 07                      	pop	es
 29191 000046CE 7505                    	jnz	short NOFIRSTDEST 	; no ^z in buffer, everything ok
 29192 000046D0 4F                      	dec	di			; point at ^z
 29193 000046D1 893E[3A9E]              	mov	[NXTADD],di		; new buffer length
 29194                                  
 29195                                  NOFIRSTDEST:
 29196 000046D5 BB[51A0]                	mov	bx,DIRBUF+1		; Source of replacement chars
 29197 000046D8 803E[2A9E]00            	cmp	byte [Concat],0
 29198 000046DD 7403                    	jz	short GOTCHRSRC		; Not a concat
 29199 000046DF BB[97A0]                	mov	bx,SDIRBUF+1		; Source of replacement chars
 29200                                  GOTCHRSRC:
 29201 000046E2 BE[0EA0]                	mov	si,DestFcb+1		; Original dest name
 29202 000046E5 8B3E[D2A0]              	mov	di,[DestTail]		; Where to put result
 29203                                  
 29204                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 29205                                  
 29206                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29207                                  BUILDNAME:
 29208 000046E9 B90800                  	mov	cx,8
 29209                                  BUILDMAIN:
 29210 000046EC AC                      	lodsb
 29211 000046ED 3C3F                    	cmp	al,'?'
 29212 000046EF 7502                    	jne	short NOTAMBIG
 29213 000046F1 8A07                    	mov	al,[bx]
 29214                                  NOTAMBIG:
 29215 000046F3 3C20                    	cmp	al,' '
 29216 000046F5 7401                    	je	short NOSTORE
 29217 000046F7 AA                      	stosb
 29218                                  NOSTORE:
 29219 000046F8 43                      	inc	bx
 29220 000046F9 E2F1                    	loop	BUILDMAIN
 29221 000046FB B103                    	mov	cl,3
 29222                                  	;mov	al,' ' ; 20h
 29223                                  	;cmp	[si],al
 29224                                  	; 27/03/2023
 29225 000046FD 803C20                  	cmp	byte [si],20h ; ' '
 29226 00004700 7412                    	je	short ENDDEST		; No extension
 29227                                  	;mov	al,[DOT_CHR]
 29228                                  	; 27/03/2023
 29229 00004702 B02E                    	mov	al,'.' ; 2Eh ; dot_chr
 29230 00004704 AA                      	stosb
 29231                                  BUILDEXT:
 29232 00004705 AC                      	lodsb
 29233 00004706 3C3F                    	cmp	al,'?'
 29234 00004708 7502                    	jne	short NOTAMBIGE
 29235 0000470A 8A07                    	mov	al,[bx]
 29236                                  NOTAMBIGE:
 29237 0000470C 3C20                    	cmp	al,' '
 29238 0000470E 7401                    	je	short NOSTOREE
 29239 00004710 AA                      	stosb
 29240                                  NOSTOREE:
 29241 00004711 43                      	inc	bx
 29242 00004712 E2F1                    	loop	BUILDEXT
 29243                                  ENDDEST:
 29244 00004714 30C0                    	xor	al,al
 29245 00004716 AA                      	stosb				; NUL terminate
 29246 00004717 C3                      	retn
 29247                                  
 29248                                  ; =============== S U B	R O U T	I N E =======================================
 29249                                  
 29250                                  	; 28/03/2023
 29251                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29252                                  	;
 29253                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 29254                                  BUILDPATH:
 29255 00004718 F6460402                	test	byte [bp+VARSTRUC.INFO],2 ; test byte [bp+4],2
 29256 0000471C 7543                    	jnz	short NOTPFILE		; If ambig don't bother with open
 29257 0000471E 89EA                    	mov	dx,bp			; Set DX to spec
 29258 00004720 83C205                  	add	dx,VARSTRUC.BUF 	; add dx,5
 29259                                  
 29260                                  	; 27/03/2023
 29261                                  	; MSDOS 6.0
 29262 00004723 57                      	push	di			;AN000;
 29263 00004724 B8006C                  	mov	ax,(ExtOpen<<8)	; 6C00h	;AC000; open the file
 29264                                  	;mov	bx,deny_none|read_open_mode
 29265 00004727 BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 29266 0000472A 31C9                    	xor	cx,cx			;AN000; no special files
 29267 0000472C 89D6                    	mov	si,dx			;AN030; get file name offset
 29268                                  	;mov	dx,read_open_flag	;AN000; set up open flags
 29269 0000472E BA0101                  	mov	dx,101h
 29270 00004731 CD21                    	INT	21h
 29271 00004733 5F                      	pop	di			;AN000;
 29272 00004734 7315                    	jnc	short PURE_FILE		;AN022; is pure file
 29273 00004736 E809DB                  	call	get_ext_error_number	;AN022; get the extended error
 29274                                  	;cmp	ax,2
 29275 00004739 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ;AN022; if file not found - okay
 29276 0000473C 7423                    	jz	short NOTPFILE		;AN022;
 29277                                  	;cmp	ax,3
 29278 0000473E 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 29279 00004741 741E                    	jz	short NOTPFILE		;AN022;
 29280                                  	;cmp	ax,5
 29281 00004743 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 29282 00004746 7419                    	jz	short NOTPFILE		;AN022;
 29283 00004748 E93AD8                  	jmp	extend_setup		;AN022; exit with error
 29284                                  
 29285                                  	; 27/03/2023
 29286                                  	; MSDOS 3.3
 29287                                  	;mov	ax,OPEN*256 ; 3D00h
 29288                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 29289                                  	;			; DS:DX	-> ASCIZ filename
 29290                                  	;			; AL = access mode
 29291                                  	;			; 0 - read
 29292                                  	;jc	short NOTPFILE
 29293                                  
 29294                                  PURE_FILE:
 29295 0000474B 89C3                    	mov	bx,ax
 29296 0000474D B80044                  	mov	ax,IOCTL*256 ; 4400h
 29297 00004750 CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 29298                                  				; BX = file or device handle
 29299 00004752 B43E                    	mov	ah,CLOSE ;3Eh
 29300 00004754 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 29301                                  				; BX = file handle
 29302                                  	; 18/04/2023
 29303 00004756 F6C280                  	test	dl,80h
 29304                                  	;test	dl,devid_ISDEV ; test dl,80h
 29305 00004759 7553                    	jnz	short ISADEV
 29306 0000475B F6460404                	test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 29307 0000475F 744D                    	jz	short ISADEV
 29308                                  NOTPFILE:
 29309 00004761 8B5605                  	mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 29310                                  	
 29311                                  	; 27/03/2023	
 29312                                  	; MSDOS 6.0
 29313 00004764 80FA00                  	cmp	dl,0		     	;AN034; If no drive specified, get
 29314 00004767 7405                    	je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 29315                                  
 29316 00004769 80FE3A                  	cmp	dh,':'
 29317 0000476C 7402                    	je	short DRVSPEC5
 29318                                  SET_DRIVE_SPEC:
 29319 0000476E B240                    	mov	dl,'@' ; 40h
 29320                                  DRVSPEC5:
 29321 00004770 80CA20                  	or	dl,20h
 29322 00004773 80EA60                  	sub	dl,60h		; A = 1
 29323 00004776 E885E3                  	call	SAVUDIR1
 29324                                  	
 29325                                  	; 27/03/2023
 29326                                  	; MSDOS 6.0
 29327 00004779 7306                    	jnc	short CURDIR_OK		;AN022; if error - exit
 29328 0000477B E8C4DA                  	call	get_ext_error_number	;AN022; get the extended error
 29329 0000477E E904D8                  	jmp	extend_setup		;AN022; exit with error
 29330                                  
 29331                                  CURDIR_OK:
 29332 00004781 89EA                    	mov	dx,bp
 29333                                  	;add	dx,5
 29334 00004783 83C205                  	add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 29335                                  	;mov	bh,[bp+4]
 29336 00004786 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 29337 00004789 80E706                  	and	bh,6
 29338 0000478C 80FF06                  	cmp	bh,6			; Ambig and path ?
 29339 0000478F 7518                    	jne	short CHECKAMB		; jmp if no
 29340                                  	;mov	si,[bp+2]
 29341 00004791 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 29342 00004794 B33A                    	mov	bl,':'
 29343 00004796 385CFE                  	cmp	[si-2],bl
 29344 00004799 7506                    	jne	short KNOWNOTSPEC
 29345                                  	;mov	byte [bp+VARSTRUC.ISDIR],2
 29346                                  					; Know is d:/file
 29347                                  	;mov	byte [bp+0],2
 29348 0000479B C6460002                	mov	byte [bp],2
 29349 0000479F EB05                    	jmp	short DOPCDJ
 29350                                  KNOWNOTSPEC:
 29351                                  	;mov	byte [bp+VARSTRUC.ISDIR],1
 29352                                  					; Know is path/file
 29353                                  	;mov	byte [bp+0],1		
 29354 000047A1 C6460001                	mov	byte [bp],1
 29355 000047A5 4E                      	dec	si
 29356                                  DOPCDJ:
 29357 000047A6 E98300                  	jmp	DOPCD
 29358                                  CHECKAMB:
 29359 000047A9 80FF02                  	cmp	bh,2
 29360 000047AC 7505                    	jnz	short CHECKCD
 29361                                  ISSIMPFILE:
 29362                                  ISADEV:
 29363                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 29364                                  	;mov	byte [bp+0],0		
 29365 000047AE C6460000                	mov	byte [bp],0
 29366 000047B2 C3                      	retn
 29367                                  CHECKCD:
 29368 000047B3 E87BEA                  	call	SetRest1
 29369 000047B6 B43B                    	mov	ah,CHDir ; 3Bh
 29370 000047B8 CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 29371                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 29372 000047BA 7239                    	jb	short NOTPDIR
 29373 000047BC 89D7                    	mov	di,dx
 29374 000047BE 31C0                    	xor	ax,ax
 29375 000047C0 89C1                    	mov	cx,ax
 29376 000047C2 49                      	dec	cx
 29377                                  	; 14/06/2023
 29378                                  	;repne	scasb	 ; MSDOS 3.3
 29379                                  
 29380                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29381                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:424Ah)
 29382                                  	; MSDOS 6.0
 29383                                  Kloop:					;AN000;  3/3/KK
 29384 000047C3 268A05                  	mov	al,[es:di]		;AN000;  3/3/KK
 29385 000047C6 47                      	inc	di			;AN000;  3/3/KK
 29386 000047C7 08C0                    	or	al,al			;AN000;  3/3/KK
 29387 000047C9 740C                    	jz	short DONE		;AN000;  3/3/KK
 29388 000047CB 30E4                    	xor	ah,ah			;AN000;  3/3/KK
 29389 000047CD E83FE1                  	call	testkanj		;AN000;  3/3/KK
 29390 000047D0 74F1                    	jz	short Kloop		;AN000;  3/3/KK
 29391 000047D2 47                      	inc	di			;AN000;  3/3/KK
 29392 000047D3 FEC4                    	inc	ah			;AN000;  3/3/KK
 29393 000047D5 EBEC                    	jmp	short Kloop		;AN000;  3/3/KK
 29394                                  DONE:
 29395 000047D7 4F                      	dec	di
 29396 000047D8 A0[1A9E]                	mov	al,[DIRCHAR]
 29397                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 29398                                  	;mov	byte [bp+0],2
 29399 000047DB C6460002                	mov	byte [bp],2
 29400                                  	; 27/03/2023
 29401                                  	; MSDOS 6.0
 29402 000047DF 08E4                    	or	ah,ah			;AN000; 3/3/KK
 29403 000047E1 7505                    	jnz	short _STORE_PCHAR	;AN000; 3/3/KK	 this is the tra
 29404                                  	;
 29405 000047E3 3A45FF                  	cmp	al,[di-1]
 29406 000047E6 7405                    	jz	short GOTSRCSLSH
 29407                                  _STORE_PCHAR:
 29408 000047E8 AA                      	stosb
 29409                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 29410                                  	;mov	byte [bp+0],1
 29411 000047E9 C6460001                	mov	byte [bp],1
 29412                                  GOTSRCSLSH:
 29413                                  	;or	byte [bp+4],6
 29414 000047ED 804E0406                	or 	byte [bp+VARSTRUC.INFO],6 
 29415 000047F1 E87400                  	call	SETSTARS
 29416                                  NOTPDIR_RETN:
 29417 000047F4 C3                      	retn
 29418                                  
 29419                                  	; 28/03/2023
 29420                                  NOTPDIR:
 29421                                  	; MSDOS 6.0
 29422 000047F5 E84ADA                  	call	get_ext_error_number	;AN022; get the extended error
 29423                                  	;cmp	ax,3
 29424 000047F8 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 29425 000047FB 7405                    	je	short NOTPDIR_TRY	;AN022;
 29426                                  	;cmp	ax,5
 29427 000047FD 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 29428 00004800 7560                    	jne	short EXTEND_SETUPJ	;AN022; otherwise - exit error
 29429                                  NOTPDIR_TRY:
 29430                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29431                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 29432                                  	;mov	byte [bp+0],0
 29433 00004802 C6460000                	mov	byte [bp],0
 29434                                  	;mov	bh,[bp+4]
 29435 00004806 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 29436 00004809 F6C704                  	test	bh,4
 29437 0000480C 74E6                    	jz	short NOTPDIR_RETN	; Know pure file, no path seps
 29438                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 29439                                  	;mov	byte [bp+0],2		
 29440 0000480E C6460002                	mov	byte [bp],2
 29441                                  	;mov	si,[bp+2]
 29442 00004812 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 29443 00004815 803C00                  	cmp	byte [si],0
 29444 00004818 744B                    	je	short BADCDERRJ2	; Trailing '/'	
 29445                                  	;mov	bl,[DOT_CHR]
 29446                                  	; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 29447                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 29448 0000481A B32E                    	mov	bl,'.'  ; 2Eh ; dot_chr
 29449 0000481C 381C                    	cmp	[si],bl
 29450 0000481E 7445                    	je	short BADCDERRJ2	; If . or .. pure cd should have worked
 29451 00004820 B33A                    	mov	bl,':'  ; 3Ah
 29452 00004822 385CFE                  	cmp	[si-2],bl
 29453 00004825 7405                    	je	short DOPCD		; Know d:/file
 29454                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 
 29455                                  					; Know path/file
 29456                                  	;mov	byte [bp+0],1
 29457 00004827 C6460001                	mov	byte [bp],1
 29458 0000482B 4E                      	dec	si			; Point at last '/'
 29459                                  DOPCD:
 29460 0000482C 30DB                    	xor	bl,bl
 29461 0000482E 861C                    	xchg	bl,[si]			; Stick in a NUL
 29462 00004830 E8FEE9                  	call	SetRest1
 29463                                  
 29464                                  	; 28/03/2023
 29465                                  	; MSDOS 6.0 (& MSDOS 5.0)
 29466 00004833 39F2                    	cmp	dx,si			;AN000;  3/3/KK
 29467 00004835 771B                    	ja	short LookBack		;AN000;  3/3/KK
 29468 00004837 56                      	push	si			;AN000;  3/3/KK
 29469 00004838 51                      	push	cx			;AN000;  3/3/KK
 29470 00004839 89F1                    	mov	cx,si			;AN000;  3/3/KK
 29471 0000483B 89D6                    	mov	si,dx			;AN000;  3/3/KK
 29472                                  Kloop2: 				;AN000;  3/3/KK
 29473 0000483D AC                      	lodsb				;AN000;  3/3/KK
 29474 0000483E E8CEE0                  	call	testkanj		;AN000;  3/3/KK
 29475 00004841 7409                    	jz	short NotKanj4		;AN000;  3/3/KK
 29476 00004843 AC                      	lodsb				;AN000;  3/3/KK
 29477 00004844 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 29478 00004846 72F5                    	jb	short Kloop2		;AN000;  3/3/KK
 29479 00004848 59                      	pop	cx			;AN000;  3/3/KK
 29480 00004849 5E                      	pop	si			;AN000;  3/3/KK
 29481 0000484A EB0B                    	jmp	short DoCdr		;AN000;  3/3/KK  Last char is ECS code, don't check for
 29482                                  					;		 trailing path sep
 29483                                  NotKanj4:				;AN000;  3/3/KK
 29484 0000484C 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 29485 0000484E 72ED                    	jb	short Kloop2		;AN000;  3/3/KK
 29486 00004850 59                      	pop	cx			;AN000;  3/3/KK
 29487 00004851 5E                      	pop	si			;AN000;  3/3/KK
 29488                                  LookBack:				;AN000;  3/3/KK
 29489                                  	; 28/03/2023
 29490                                  	; MSDOS 3.3 & MSDOS 6.0
 29491 00004852 3A5CFF                  	cmp	bl,[si-1]		; if double slash, then complain.
 29492 00004855 740E                    	je	short BADCDERRJ2
 29493                                  DoCdr:
 29494 00004857 B43B                    	mov	ah,CHDir ; 3Bh
 29495 00004859 CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 29496                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 29497 0000485B 861C                    	xchg	bl,[si]
 29498 0000485D 7395                    	jnc	short NOTPDIR_RETN
 29499                                  	
 29500                                  	; 28/03/2023
 29501                                  	; MSDOS 3.3
 29502                                  ;BADCDERRJ2:
 29503                                  	;stc
 29504                                  	;jmp	BADCDERR
 29505                                  
 29506                                  	; 28/03/2023
 29507                                  	; MSDOS 6.0 (& MSDOS 5.0)
 29508 0000485F E8E0D9                  	call	get_ext_error_number	;AN022; get the extended error
 29509                                  EXTEND_SETUPJ:					;AN022;
 29510 00004862 E920D7                  	jmp	extend_setup		;AN022; go issue the error message
 29511                                  BADCDERRJ2:
 29512 00004865 E91AD7                  	jmp	badpath_err		;AC022; go issue path not found message
 29513                                  
 29514                                  ; =============== S U B	R O U T	I N E =======================================
 29515                                  
 29516                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29517                                  SETSTARS:
 29518                                  	;mov	[bp+2],di
 29519 00004868 897E02                  	mov	[bp+VARSTRUC.TTAIL],di
 29520                                  	;add	byte [bp+1],12
 29521 0000486B 8046010C                	add	byte [bp+VARSTRUC.SIZ],12
 29522                                  	;;mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 29523                                  	; 28/03/2023
 29524                                  	; MSDOS 6.0
 29525 0000486F B83F2E                  	mov	ax,dot_qmark ; 2E3Fh
 29526                                  	;mov	ax,'?.' ; dot_qmark
 29527                                  
 29528 00004872 B90800                  	mov	cx,8
 29529 00004875 F3AA                    	rep	stosb
 29530 00004877 86C4                    	xchg	al,ah
 29531 00004879 AA                      	stosb
 29532 0000487A 86C4                    	xchg	al,ah
 29533 0000487C B103                    	mov	cl,3
 29534 0000487E F3AA                    	rep	stosb
 29535 00004880 30C0                    	xor	al,al
 29536 00004882 AA                      	stosb
 29537 00004883 C3                      	retn
 29538                                  
 29539                                  ; =============== S U B	R O U T	I N E =======================================
 29540                                  
 29541                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29542                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 29543                                  COMPNAME:
 29544 00004884 BE[D5A0]                	mov	si,DestBuf	; do name translate of target
 29545 00004887 BF[9A9B]                	mov	di,TRGXNAME	; save for name comparison
 29546 0000488A B460                    	mov	ah,xNameTrans ; 60h
 29547                                  	;mov	ah,60h
 29548 0000488C CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 29549                                  			; DS:SI	-> ASCIZ relative path string or directory name
 29550                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 29551 0000488E BE[439B]                	mov	si,SRCXNAME	; get name translate of source
 29552 00004891 BF[9A9B]                	mov	di,TRGXNAME	; get name translate of target
 29553                                  	;call	STRCOMP
 29554                                  	;retn
 29555                                  	; 28/03/2023
 29556 00004894 E9D9E2                  	jmp	STRCOMP
 29557                                  
 29558                                  ;============================================================================
 29559                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 29560                                  ;============================================================================
 29561                                  ; 30/09/2018 - Retro DOS v3.0
 29562                                  ; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29563                                  ; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 29564                                  
 29565                                  ;-----------------------------------------------------------------------;
 29566                                  ; ENTRY:								;
 29567                                  ;	DS:SI	Points input buffer					;
 29568                                  ;	ES:DI	Points to the token buffer				;
 29569                                  ;	BL	Special delimiter for this call 			;
 29570                                  ;		    Always checked last 				;
 29571                                  ;		    set it to space if there is no special delimiter	;
 29572                                  ; EXIT: 								;
 29573                                  ;	DS:SI	Points to next char in the input buffer 		;
 29574                                  ;	ES:DI	Points to the token buffer				;
 29575                                  ;	[STARTEL] Points to start of last element of path in token	;
 29576                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 29577                                  ;	CX	Character count 					;
 29578                                  ;	BH	Condition Code						;
 29579                                  ;			Bit 1H of BH set if switch character		;
 29580                                  ;				Token buffer contains char after	;
 29581                                  ;				switch character			;
 29582                                  ;				BP has switch bits set (ORing only)	;
 29583                                  ;			Bit 2H of BH set if ? or * in token		;
 29584                                  ;				if * found element ? filled		;
 29585                                  ;			Bit 4H of BH set if path sep in token		;
 29586                                  ;			Bit 80H of BH set if the special delimiter	;
 29587                                  ;			   was skipped at the start of this token	;
 29588                                  ;		Token buffer always starts d: for non switch tokens	;
 29589                                  ;	CARRY SET							;
 29590                                  ;	    if CR on input						;
 29591                                  ;		token buffer not altered				;
 29592                                  ;									;
 29593                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 29594                                  ; MODIFIES:								;
 29595                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 29596                                  ;									;
 29597                                  ;-----------------------------------------------------------------------;
 29598                                  
 29599                                  ; Modifications to cparse: recognition of right and left parentheses
 29600                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 29601                                  ;
 29602                                  ; Both modifications were installed in the course of adding a coherent
 29603                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 29604                                  ; structure for command-line arguments. This parser relies on cparse to
 29605                                  ; recognize individual tokens.
 29606                                  ;
 29607                                  ; To process for-loops correctly, parentheses must therefore be
 29608                                  ; recognized as tokens. The upper-case conversion code was removed so
 29609                                  ; that commands (such as for and echo) would be able to use the "original"
 29610                                  ; text of the command line.
 29611                                  ;
 29612                                  ; Note also the modification to prevent the automatic conversion of colons
 29613                                  ; into spaces WITHIN THE SOURCE TEXT!
 29614                                  ;
 29615                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 29616                                  ; on the command line.
 29617                                  ;
 29618                                  ; Alan L, OS/MSDOS				    14 August 1983
 29619                                  
 29620                                  ; ---------------------------------------------------------------------------
 29621                                  
 29622                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 29623                                  
 29624                                  ;FSWITCH	EQU	8000h
 29625                                  ;FBADSWITCH	EQU	4000h
 29626                                  
 29627                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 29628                                  
 29629                                  ; =============== S U B	R O U T	I N E =======================================
 29630                                  		
 29631                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29632                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 431Fh
 29633                                  
 29634                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 29635                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 4AE3h
 29636                                  cparse:
 29637 00004897 31C0                    	xor	ax,ax
 29638 00004899 893E[0DA2]              	mov	[STARTEL],di		; No path element (Is DI correct?)
 29639 0000489D A2[10A2]                	mov	[ELPOS],al		; Start in 8 char prefix
 29640                                  	; MSDOS 3.3
 29641                                  	;mov	[SOURCE],al		
 29642                                  	; MSDOS 6.0
 29643 000048A0 A2[11A2]                	mov	[SKPDEL], al		; No skip delimiter yet
 29644 000048A3 88C7                    	mov	bh,al			; Init nothing
 29645 000048A5 9C                      	pushf				; save flags
 29646 000048A6 57                      	push	di			; save the token buffer addrss
 29647 000048A7 31C9                    	xor	cx,cx			; no chars in token buffer
 29648 000048A9 880E[ACA0]              	mov	[comma],cl		; reset comma flag
 29649                                  moredelim:
 29650 000048AD AC                      	lodsb
 29651 000048AE E885E2                  	call	DELIM
 29652 000048B1 751D                    	jnz	short SCANCDONE
 29653 000048B3 3C20                    	cmp	al,' '
 29654 000048B5 74F6                    	jz	short moredelim
 29655 000048B7 3C09                    	cmp	al,9
 29656 000048B9 74F2                    	jz	short moredelim
 29657                                  	;xchg	al,[SOURCE]
 29658                                  	; 28/03/2023
 29659 000048BB 8606[11A2]              	xchg	al,[SKPDEL]
 29660 000048BF 08C0                    	or	al,al
 29661 000048C1 74EA                    	jz	short moredelim		; One non space/tab delimiter allowed
 29662 000048C3 F6C780                  	test	bh,80h			; has a special char been found?
 29663 000048C6 7405                    	jz	short no_comma		; no - just exit
 29664 000048C8 C606[ACA0]01            	mov	byte [comma],1		; set comma flag
 29665                                  no_comma:
 29666 000048CD E92A01                  	jmp	x_done			; Nul argument
 29667                                  
 29668                                  SCANCDONE:
 29669                                  	; 28/03/2023
 29670                                  	; MSDOS 6.0
 29671                                  	; -----------------------------------
 29672                                  	; Mod to avoid upper-case conversion.
 29673                                  	; -----------------------------------
 29674                                  	; MSDOS 3.3
 29675                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 29676                                  	;jnz	short cpcont1		; 3/3/KK
 29677                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 29678                                  cpcont1:
 29679                                  	; -----------------------------------
 29680                                  	; 28/03/2023
 29681 000048D0 38D8                    	cmp	al,bl			; Special delimiter?
 29682 000048D2 7505                    	jne	short nospec
 29683 000048D4 80CF80                  	or	bh,80h
 29684 000048D7 EBD4                    	jmp	short moredelim
 29685                                  nospec:
 29686 000048D9 3C0D                    	cmp	al,0Dh			; a CR?
 29687 000048DB 7503                    	jne	short ncperror
 29688 000048DD E91501                  	jmp	cperror
 29689                                  ncperror:
 29690 000048E0 3A06[199E]              	cmp	al,[SWITCHAR]		; is the char the switch char?
 29691 000048E4 7503                    	jne	short na_switch		; yes, process...
 29692 000048E6 E91401                  	jmp	a_switch
 29693                                  na_switch:
 29694 000048E9 B23A                    	mov	dl,':'
 29695 000048EB 3814                    	cmp	[si],dl
 29696 000048ED 751D                    	jne	short anum_chard	; Drive not specified
 29697                                  	; 28/03/2023
 29698                                  	; MSDOS 6.0 
 29699 000048EF 803E[BBA0]01            	cmp	byte [cpyflag],1	; 3/3/KK
 29700 000048F4 7503                    	jne	short cpcont2		; 3/3/KK
 29701 000048F6 E840E0                  	call	UPCONV			; 3/3/KK
 29702                                  cpcont2:
 29703 000048F9 E85901                  	call	move_char
 29704 000048FC AC                      	lodsb				; Get the ':'
 29705 000048FD E85501                  	call	move_char
 29706 00004900 893E[0DA2]              	mov	[STARTEL],di
 29707 00004904 C606[0FA2]00            	mov	byte [ELCNT],0
 29708 00004909 E9B300                  	jmp	anum_test
 29709                                  anum_chard:
 29710 0000490C 893E[0DA2]              	mov	[STARTEL],di
 29711 00004910 C606[0FA2]00            	mov	byte [ELCNT],0		; Store of this char sets it to one
 29712 00004915 803E[BBA0]01            	cmp	byte [cpyflag],1	; Was CPARSE called from COPY?
 29713 0000491A 751D                    	jnz	short anum_char		; No, don't add drive spec.
 29714 0000491C E89DE2                  	call	pathchrcmp		; Starts with a pathchar?
 29715 0000491F 7518                    	jnz	short anum_char		; no
 29716 00004921 50                      	push	ax
 29717 00004922 A0[299E]                	mov	al,[CURDRV]		; Insert drive spec
 29718                                  	;add	al,[CAPITAL_A]
 29719                                  	; 28/03/2023
 29720                                  	; MSDOS 6.0
 29721 00004925 0441                    	add	al,'A' ; 41h
 29722 00004927 E82B01                  	call	move_char
 29723 0000492A B03A                    	mov	al,':' ; 3Ah
 29724 0000492C E82601                  	call	move_char
 29725 0000492F 58                      	pop	ax
 29726 00004930 893E[0DA2]              	mov	[STARTEL],di
 29727 00004934 C606[0FA2]00            	mov	byte [ELCNT],0
 29728                                  anum_char:
 29729                                  	; 28/03/2023
 29730                                  	; MSDOS 6.0
 29731 00004939 E8D3DF                  	call	testkanj		;AC048			
 29732 0000493C 7406                    	jz	short NOTKANJ		;AC048;
 29733 0000493E E81401                  	call	move_char
 29734 00004941 AC                      	lodsb
 29735 00004942 EB78                    	jmp	short notspecial
 29736                                  
 29737                                  NOTKANJ:				;AN048; If not kanji
 29738 00004944 803E[BBA0]01            	cmp	byte [cpyflag],1	;AN048; and if we're in COPY
 29739 00004949 7503                    	jne	short TESTDOT 		;AN048;
 29740 0000494B E8EBDF                  	call	UPCONV			;AN048; upper case the char
 29741                                  TESTDOT:
 29742                                  	; 28/03/2023
 29743                                  	;cmp	al,dot_chr  ; 2Eh
 29744 0000494E 3C2E                    	cmp	al,'.'
 29745 00004950 7509                    	jne	short testquest
 29746 00004952 FE06[10A2]              	inc	byte [ELPOS] 		; flag in extension
 29747 00004956 C606[0FA2]FF            	mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 29748                                  testquest:
 29749 0000495B 3C3F                    	cmp	al,'?'  ; 3Fh
 29750 0000495D 7503                    	jnz	short testsplat
 29751 0000495F 80CF02                  	or	bh,2
 29752                                  testsplat:
 29753                                  	;cmp	al,[STAR]
 29754 00004962 3C2A                    	cmp	al,star	; 2Ah
 29755                                  	; 27/04/2023
 29756                                  	;cmp	al,'*' 
 29757 00004964 7530                    	jne	short testpath
 29758 00004966 80CF02                  	or	bh,2
 29759 00004969 803E[49A2]00            	cmp	byte [expand_star],0
 29760 0000496E 7504                    	jne	short expand_filename
 29761 00004970 EB24                    	jmp	short testpath
 29762                                  
 29763                                  BADPERR2J:
 29764                                  	;jmp	BADPERR2
 29765                                  	; 28/03/2023
 29766                                  	; MSDOS 6.0
 29767 00004972 EB75                    	jmp	short BADPERR2
 29768                                  
 29769                                  expand_filename:
 29770 00004974 B407                    	mov	ah,7
 29771 00004976 803E[10A2]00            	cmp	byte [ELPOS],0
 29772 0000497B 7402                    	jz	short gotelcnt
 29773 0000497D B402                    	mov	ah,2
 29774                                  gotelcnt:
 29775 0000497F B03F                    	mov	al,'?'
 29776 00004981 2A26[0FA2]              	sub	ah,[ELCNT]
 29777 00004985 72EB                    	jb	short BADPERR2J
 29778 00004987 86E1                    	xchg	ah,cl
 29779 00004989 E309                    	jcxz	testpathx
 29780                                  qmove:
 29781 0000498B 86E1                    	xchg	ah,cl
 29782 0000498D E8C500                  	call	move_char
 29783 00004990 86E1                    	xchg	ah,cl
 29784 00004992 E2F7                    	loop	qmove
 29785                                  testpathx:
 29786 00004994 86E1                    	xchg	ah,cl
 29787                                  testpath:
 29788 00004996 E823E2                  	call	pathchrcmp
 29789 00004999 7521                    	jnz	short notspecial
 29790 0000499B 80CF04                  	or	bh,4
 29791 0000499E 803E[49A2]00            	cmp	byte [expand_star],0
 29792 000049A3 7405                    	jz	short no_err_check
 29793 000049A5 F6C702                  	test	bh,2			; If just hit a '/', cannot have ? or * yet
 29794 000049A8 7545                    	jnz	short BADPERR
 29795                                  no_err_check:
 29796 000049AA 893E[0DA2]              	mov	[STARTEL],di	  	; New element
 29797 000049AE FF06[0DA2]              	inc	word [STARTEL]	  	; Point to char after /
 29798 000049B2 C606[0FA2]FF            	mov	byte [ELCNT],0FFh 	; Store of '/' sets it to 0
 29799 000049B7 C606[10A2]00            	mov	byte [ELPOS],0
 29800                                  notspecial:
 29801 000049BC E89600                  	call	move_char		; just an alphanum string
 29802                                  anum_test:
 29803 000049BF AC                      	lodsb
 29804                                  
 29805                                  	; 28/03/2023
 29806                                  	; MSDOS 6.0
 29807                                  	; -----------------------------------
 29808                                  	; Mod to avoid upper-case conversion.
 29809                                  	; -----------------------------------
 29810                                  	; MSDOS 3.3
 29811                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 29812                                  	;jnz	short cpcont3		; 3/3/KK
 29813                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 29814                                  cpcont3:
 29815                                  	; -----------------------------------
 29816                                  
 29817 000049C0 E873E1                  	call	DELIM
 29818 000049C3 7435                    	jz	short x_done
 29819 000049C5 3C0D                    	cmp	al,0Dh
 29820 000049C7 7431                    	je	short x_done
 29821 000049C9 3A06[199E]              	cmp	al,[SWITCHAR]
 29822 000049CD 742B                    	je	short x_done
 29823 000049CF 38D8                    	cmp	al,bl
 29824 000049D1 7427                    	je	short x_done
 29825 000049D3 3C3A                    	cmp	al,':'			; ':' allowed as trailer because of devices
 29826                                  	; 28/03/2023
 29827                                  	; MSDOS 3.3
 29828                                  	;jnz	short ANUM_CHARJ 
 29829                                  	; MSDOS 6.0
 29830 000049D5 7403                    	je	short FOO15
 29831 000049D7 E95FFF                  	jmp	anum_char
 29832                                  
 29833                                  ; Modification made for parseline.
 29834                                  ; Why would it be necessary to change colons to spaces? In this
 29835                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 29836                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 29837                                  
 29838                                  FOO15:
 29839 000049DA 803E[BBA0]02            	cmp	byte [cpyflag],2
 29840 000049DF 7505                    	jnz	short cpcont4
 29841 000049E1 E87100                  	call	move_char
 29842 000049E4 EBD9                    	jmp	short anum_test
 29843                                  cpcont4:
 29844 000049E6 46                      	inc	si			; Skip the ':'
 29845 000049E7 EB11                    	jmp	short x_done
 29846                                  
 29847                                  	; 28/03/2023
 29848                                  ;ANUM_CHARJ:
 29849                                  	;jmp	anum_char
 29850                                  
 29851                                  BADPERR2:
 29852 000049E9 BA[0492]                	mov	dx,BADCPMES_PTR
 29853 000049EC E9B3E4                  	jmp	cerror
 29854                                  
 29855                                  BADPERR:
 29856                                  	; 28/03/2023
 29857                                  	;jmp	BADCDERR  ; MSDOS 3.3	
 29858                                  BADCDERR:
 29859                                  	; MSDOS 6.0
 29860 000049EF BA[2E93]                	mov	dx,badcd_ptr		;AC022; Issue "Invalid Directory"
 29861 000049F2 E9ADE4                  	jmp	cerror			;AC022;  message
 29862                                  	
 29863                                  cperror:
 29864 000049F5 4E                      	dec	si			; adjust the pointer
 29865 000049F6 5F                      	pop	di			; retrive token buffer address
 29866 000049F7 9D                      	popf				; restore flags
 29867 000049F8 F9                      	stc				; set the carry bit
 29868 000049F9 C3                      	retn
 29869                                  
 29870                                  x_done:
 29871 000049FA 4E                      	dec	si			; adjust for next round
 29872                                  
 29873                                  ; Mod to recognize right and left parens as integral tokens.
 29874                                  ;x_done2:
 29875 000049FB EB51                    	jmp	short out_token
 29876                                  
 29877                                  a_switch:
 29878 000049FD 80CF01                  	or	bh,1			; Indicate switch
 29879                                  	;or	bp,FSWITCH ; 8000h
 29880                                  	; 28/03/2023
 29881 00004A00 81CD0080                	or	bp,8000h
 29882 00004A04 E827E1                  	call	scanoff
 29883 00004A07 46                      	inc	si
 29884                                  	; 28/03/2023
 29885                                  	; MSDOS 6.0
 29886 00004A08 E804DF                  	call	testkanj		;AN057; See if DBCS lead byte
 29887 00004A0B 740D                    	jz	short a_switch_notkanj	;AN057; no - continue processing
 29888 00004A0D E84500                  	call	move_char		;AN057; DBCS - store first byte
 29889 00004A10 AC                      	lodsb				;AN057; get second byte
 29890 00004A11 E84100                  	call	move_char		;AN057; store second byte
 29891                                  	;or	bp,FBADSWITCH ; 4000h	;AN057; DBCS switch is invalid
 29892 00004A14 81CD0040                	or	bp,4000h
 29893 00004A18 EB34                    	jmp	short out_token 	;AN057; don't bother checking switch
 29894                                  a_switch_notkanj:			;AN057;
 29895 00004A1A 3C0D                    	cmp	al,0Dh
 29896 00004A1C 7509                    	jne	short Store_swt
 29897 00004A1E B000                    	mov	al,0
 29898 00004A20 AA                      	stosb
 29899                                  	;or	bp,FBADSWITCH ; 4000h
 29900 00004A21 81CD0040                	or	bp,4000h
 29901 00004A25 EBCE                    	jmp	short cperror		; Trailing switch character error
 29902                                  					;   BP = fSwitch but no switch
 29903                                  					;   bit is set (unknown switch)
 29904                                  Store_swt:
 29905 00004A27 E82B00                  	call	move_char		; store the character
 29906                                  
 29907                                  ; This upconv call must stay. It is used to identify copy-switches
 29908                                  ; on the command line, and won't store anything into the output buffer.
 29909                                  
 29910                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3 (Retro DOS 3.0)
 29911                                  	; 28/03/2023
 29912 00004A2A E80CDF                  	call	UPCONV 	; MSDOS 6.0 & MSDOS 5.0 (Retro DOS 4.0)
 29913                                  	
 29914 00004A2D 06                      	push	es
 29915 00004A2E 57                      	push	di
 29916 00004A2F 51                      	push	cx
 29917 00004A30 0E                      	push	cs
 29918 00004A31 07                      	pop	es
 29919                                  	; 28/03/2023
 29920                                  	; MSDOS 3.3
 29921                                  	;;mov	di,SWITCH_LIST ; "VBAPW"
 29922                                  	; MSDOS 6.0
 29923                                  	;mov	di,switch_list ; "?VBAPW"
 29924                                  	; 14/06/*2023
 29925                                  	; MSDOS 6.22
 29926 00004A32 BF[8297]                	mov	di,switch_list ; "-Y?VBAPW"
 29927                                  
 29928                                  	; MSDOS 3.3
 29929                                  	;mov	cx,SWCOUNT ; 5
 29930                                  	; MSDOS 6.0
 29931                                  	;mov	cx,6  ; SWCOUNT = 6
 29932                                  	; 14/06/2023
 29933                                  	; MSDOS 6.22
 29934 00004A35 B90800                  	mov	cx,8  ; SWCOUNT = 8	
 29935                                  
 29936                                  	;or	bp,FBADSWITCH  ; 4000h
 29937 00004A38 81CD0040                	or	bp,4000h
 29938 00004A3C F2AE                    	repne	scasb
 29939 00004A3E 750B                    	jnz	short out_tokenp
 29940                                  	;and	bp,~FBADSWITCH ; 0BFFFh
 29941 00004A40 81E5FFBF                	and	bp,0BFFFh
 29942 00004A44 B80100                  	mov	ax,1
 29943 00004A47 D3E0                    	shl	ax,cl
 29944 00004A49 09C5                    	or	bp,ax
 29945                                  out_tokenp:
 29946 00004A4B 59                      	pop	cx
 29947 00004A4C 5F                      	pop	di
 29948 00004A4D 07                      	pop	es
 29949                                  out_token:
 29950 00004A4E B000                    	mov	al,0			; null at the end
 29951 00004A50 AA                      	stosb
 29952 00004A51 5F                      	pop	di			; restore token buffer pointer	
 29953 00004A52 9D                      	popf
 29954 00004A53 F8                      	clc				; clear carry flag
 29955 00004A54 C3                      	retn
 29956                                  
 29957                                  ; =============== S U B	R O U T	I N E =======================================
 29958                                  
 29959                                  	; 28/03/2023
 29960                                  move_char:
 29961 00004A55 AA                      	stosb				; store char in token buffer
 29962 00004A56 41                      	inc	cx			; increment char count
 29963 00004A57 FE06[0FA2]              	inc	byte [ELCNT]		; increment element count for * substi
 29964 00004A5B C3                      	retn
 29965                                  
 29966                                  ;============================================================================
 29967                                  ; PARSE.ASM, MSDOS 6.0, 1991
 29968                                  ;============================================================================
 29969                                  ; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29970                                  ; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 29971                                  
 29972                                  ; -----------------------------
 29973                                  ; (PSDATA.INC, MSDOS 6.0, 1991)
 29974                                  ; -----------------------------
 29975                                  
 29976                                  ;**** Equation field
 29977                                  ;-------- Character code definition
 29978                                  
 29979                                  $P_DBSP1	   equ	20h ; DB_SP_HI	;AN000; 1st byte of DBCS blank
 29980                                  $P_DBSP2	   equ	20h ; DB_SP_LO	;AN000; 2nd byte of DBCS blank
 29981                                  $P_Period	   equ	"."             ;AN020;
 29982                                  $P_Slash	   equ	"/"             ;AN020;
 29983                                  $P_Space	   equ	" "             ;AN000; SBCS blank
 29984                                  $P_Comma	   equ	","             ;AN000;
 29985                                  $P_Switch	   equ	"/"             ;AN000;
 29986                                  $P_Keyword	   equ	"="             ;AN000;
 29987                                  $P_Colon	   equ	":"             ;AN000;
 29988                                  $P_Plus 	   equ	"+"             ;AN000;
 29989                                  $P_Minus	   equ	"-"             ;AN000;
 29990                                  $P_Rparen	   equ	")"             ;AN000;
 29991                                  $P_Lparen	   equ	"("             ;AN000;
 29992                                  ;(deleted ;AN025;) $P_SQuote equ  "'"
 29993                                  $P_DQuote	   equ	'"'             ;AN000;
 29994                                  $P_NULL 	   equ	0		;AN000;
 29995                                  $P_TAB		   equ	9		;AN000;
 29996                                  $P_CR		   equ	0Dh		;AN000;
 29997                                  $P_LF		   equ	0Ah		;AN000;
 29998                                  $P_ASCII80	   equ	80h		;AN000; ASCII 80h character code
 29999                                  
 30000                                  $P_DOSTBL_File	   equ	4		;AN000; get file uppercase table
 30001                                  $P_DOSTBL_Char	   equ	2		;AN000; get character uppercase table
 30002                                  
 30003                                  $P_error_filespec  equ  1
 30004                                  
 30005                                  ;----------------------------------------------------------------------------
 30006                                  ; PARMS LABEL	BYTE
 30007                                  ;	DW	PARMSX
 30008                                  ;	DB	2		; NUMBER OF STRINGS (0, 1, 2)
 30009                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 30010                                  ;	DB	" .. "          ; EXTRA DELIMITER LIST,
 30011                                  ;				; TYPICAL ARE ";", "="
 30012                                  ;				; "," & WHITESPACE ALWAYS
 30013                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 30014                                  ;	DB	" .. "          ; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
 30015                                  ;----------------------------------------------------------------------------
 30016                                  
 30017                                  struc $P_PARMS_BLK			;AN000;
 30018 00000000 ????                    .$P_PARMSX_Address:  resw 1		;AN000; Address of PARMSX
 30019 00000002 ??                      .$P_Num_Extra:	     resb 1		;AN000; Number of extra stuff
 30020 00000003 ??                      .$P_Len_Extra_Delim: resb 1		;AN000; Length of extra delimiter
 30021                                  endstruc 				;AN000;
 30022                                  
 30023                                  $P_Len_PARMS	   equ	4		;AN000;
 30024                                  $P_I_Use_Default   equ	0		;AN000; no extra stuff specified
 30025                                  $P_I_Have_Delim    equ	1		;AN000; extra delimiter specified
 30026                                  $P_I_Have_EOL	   equ	2		;AN000; extra EOL specified
 30027                                  
 30028                                  ;----------------------------------------------------------------------------
 30029                                  ; PARMSX LABEL	BYTE
 30030                                  ;	DB	minp,maxp		; MIN, MAX POSITIONAL OPERANDS ALLOWED
 30031                                  ;	DW	CONTROL 		; DESCRIPTION OF POSITIONAL 1
 30032                                  ;	:				; REPEATS maxp-1 TIMES
 30033                                  ;	DB	maxs			; # OF SWITCHES
 30034                                  ;	DW	CONTROL 		; DESCRIPTION OF SWITCH 1
 30035                                  ;	:				; REPEATS maxs-1 TIMES
 30036                                  ;	DB	maxk			; # OF KEYWORD
 30037                                  ;	DW	CONTROL 		; DESCRIPTION OF KEYWORD 1
 30038                                  ;	:				; REPEATS maxk-1 TIMES
 30039                                  ;----------------------------------------------------------------------------
 30040                                  
 30041                                  struc $P_PARMSX_BLK			;AN000;
 30042 00000000 ??                      .$P_MinP: 	 resb 1	 ; 27/04/2023	;AN000; Minimum positional number
 30043 00000001 ??                      .$P_MaxP: 	 resb 1			;AN000; Maximum positional number
 30044 00000002 ??                      .$P_1st_Control: resb 1			;AN000; Address of the 1st CONTROL block
 30045                                  endstruc				;AN000;
 30046                                  
 30047                                  ; 31/03/2023
 30048                                  ;----------------------------------------------------------------------------
 30049                                  ; << Control field definition >>
 30050                                  ;
 30051                                  ;CONTROL   LABEL   BYTE
 30052                                  ;	   DW MATCH_FLAGS	; CONTROLS TYPE MATCHED
 30053                                  ;				; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
 30054                                  ;				; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
 30055                                  ;				; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
 30056                                  ;				; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
 30057                                  ;				; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
 30058                                  ;				; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
 30059                                  ;				; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
 30060                                  ;				; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
 30061                                  ;				; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
 30062                                  ;				; 0010H=IGNORE ":" AT END IN MATCH
 30063                                  ;				; 0002H=REPEATS ALLOWED
 30064                                  ;				; 0001H=OPTIONAL
 30065                                  ;	   DW FUNCTION_FLAGS
 30066                                  ;				; 0001H=CAP RESULT BY FILE TABLE
 30067                                  ;				; 0002H=CAP RESULT BY CHAR TABLE
 30068                                  ;				; 0010H=REMOVE ":" AT END
 30069                                  ; (tm10)			; 0020H=colon is not necessary for switch
 30070                                  ;
 30071                                  ;	   DW RESULT		; RESULT BUFFER
 30072                                  ;	   DW VALUES		; VALUE LISTS
 30073                                  ;	   DB nid		; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
 30074                                  ;	   DB "...",0		; IF n >0, KEYWORD 1
 30075                                  ;	   :
 30076                                  ;
 30077                                  ;Note:
 30078                                  ;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
 30079                                  ;      DATE bit simalteniously.
 30080                                  ;
 30081                                  ;      The parser examins each bit along with the following priority.
 30082                                  ;
 30083                                  ;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
 30084                                  ;      FILE SPEC -> SIMPLE STRING.
 30085                                  ;
 30086                                  ;
 30087                                  ;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
 30088                                  ;      in the result buffer is capitalized.
 30089                                  ;
 30090                                  ;    - Match_Flags 0001H and 0002H have meaning only for the positional.
 30091                                  ;
 30092                                  ;
 30093                                  ;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
 30094                                  ;      switch, for example, '/A', then STRING points to;
 30095                                  ;
 30096                                  ;		DB    1 	; number of following synonyms
 30097                                  ;		DB   '/A',0
 30098                                  ;
 30099                                  ;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
 30100                                  ;
 30101                                  ;		DB    1 	; number of following synonyms
 30102                                  ;		DB   'CODEPAGE=',0
 30103                                  ;
 30104                                  ;
 30105                                  ;    - "..." must consist of upper case characters only because the parser
 30106                                  ;      performs pattern matching after converting input to upper case (by
 30107                                  ;      using the current country upper case table)
 30108                                  ;
 30109                                  ;
 30110                                  ;    - One "..." can contain only one switch or keyword. If you need, for
 30111                                  ;      example /A and /B, the format will be;
 30112                                  ;
 30113                                  ;		DB    2 	; number of following synonyms
 30114                                  ;		DB    '/A',0
 30115                                  ;		DB    '/B',0
 30116                                  ;----------------------------------------------------------------------------
 30117                                  
 30118                                  ;**** Match_Flags
 30119                                  
 30120                                  $P_Num_Val	   equ	8000h		;AN000; Numeric Value
 30121                                  $P_SNum_Val	   equ	4000h		;AN000; Signed numeric value
 30122                                  $P_Simple_S	   equ	2000h		;AN000; Simple string
 30123                                  $P_Date_S	   equ	1000h		;AN000; Date string
 30124                                  $P_Time_S	   equ	0800h		;AN000; Time string
 30125                                  $P_Cmpx_S	   equ	0400h		;AN000; Complex string
 30126                                  $P_File_Spc	   equ	0200h		;AN000; File Spec
 30127                                  $P_Drv_Only	   equ	0100h		;AN000; Drive Only
 30128                                  $P_Qu_String	   equ	0080h		;AN000; Quoted string
 30129                                  $P_Ig_Colon	   equ	0010h		;AN000; Ignore colon at end in match
 30130                                  $P_Repeat	   equ	0002h		;AN000; Repeat allowed
 30131                                  $P_Optional	   equ	0001h		;AN000; Optional
 30132                                  
 30133                                  ;**** Function flags
 30134                                  
 30135                                  $P_CAP_File	   equ	0001h		;AN000; CAP result by file table
 30136                                  $P_CAP_Char	   equ	0002h		;AN000; CAP result by character table
 30137                                  $P_Rm_Colon	   equ	0010h		;AN000; Remove ":" at the end
 30138                                  $P_colon_is_not_necessary equ 0020h	;AN000;(tm10) /+10 and /+:10
 30139                                  
 30140                                  ;-------------------------------- Control block structure
 30141                                  struc $P_CONTROL_BLK
 30142 00000000 ????                    .$P_Match_Flag:	   resw 1		;AN000; Controls type matched
 30143 00000002 ????                    .$P_Function_Flag: resw 1		;AN000; Function should be taken
 30144 00000004 ????                    .$P_Result_Buf:	   resw 1		;AN000; Result buffer address
 30145 00000006 ????                    .$P_Value_List:	   resw 1		;AN000; Value list address
 30146 00000008 ??                      .$P_nid:	   resb 1		;AN000; # of keyword/SW synonyms
 30147 00000009 ??                      .$P_KEYorSW:	   resb 1		;AN000; keyword or sw
 30148                                  endstruc
 30149                                  
 30150                                  ; 31/03/2023
 30151                                  ;----------------------------------------------------------------------------
 30152                                  ;
 30153                                  ;VALUES LABEL	BYTE
 30154                                  ;	DB	nval		; NUMBER OF VALUE DEFINITIONS (0 - 3)
 30155                                  ;	+-
 30156                                  ;	| DB	nrng		; NUMBER OF RANGES
 30157                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF RANGE MATCHED
 30158                                  ;	| +DD	X,Y		; RANGE OF VALUES
 30159                                  ;	|	:
 30160                                  ;	| DB	nnval		; NUMBER OF CHOICES
 30161                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF NUMBER CHOICE MATCHED
 30162                                  ;	| +DD	VALUE		; SPECIFIC CHOICE IF NUMBER
 30163                                  ;	|	:
 30164                                  ;	| DB	nstrval 	; NUMBER OF CHOICES
 30165                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF STRING CHOICE MATCHED
 30166                                  ;	| +DW	STRING		; SPECIFIC CHOICE IF STING
 30167                                  ;	+-	:
 30168                                  ;
 30169                                  ;STRING DB	"...",0		; ASCIIZ STRING IMAGE
 30170                                  ;
 30171                                  ;Note:
 30172                                  ;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
 30173                                  ;      when no choice lists are provided.
 30174                                  ;
 30175                                  ;    - STRING must consist of upper case characters only because the parser
 30176                                  ;      performs pattern matching after converting input to upper case (by
 30177                                  ;      using the current country upper case table)
 30178                                  ;----------------------------------------------------------------------------
 30179                                  
 30180                                  $P_nval_None	equ 0		;AN000; no value list ID
 30181                                  $P_nval_Range	equ 1		;AN000; range list ID
 30182                                  $P_nval_Value	equ 2		;AN000; value list ID
 30183                                  $P_nval_String	equ 3		;AN000; string list ID
 30184                                  $P_Len_Range	equ 9		;AN000; Length of a range choice(two DD plus one DB)
 30185                                  $P_Len_Value	equ 5		;AN000; Length of a value choice(one DD plus one DB)
 30186                                  $P_Len_String	equ 3		;AN000; Length of a string choice(one DW plus one DB)
 30187                                  $P_No_nrng	equ 0		;AN000; (tm07) no nrng. nnval must not be 0.
 30188                                  
 30189                                  struc $P_VAL_LIST
 30190 00000000 ??                      .$P_NumofList:	resb 1		;AN000; number of following choice
 30191 00000001 ????                    .$P_Val_XL:	resw 1		;AN000; lower word of value
 30192 00000003 ????                    .$P_Val_XH:	resw 1		;AN000; higher word of value
 30193 00000005 ????                    .$P_Val_YL:	resw 1		;AN000; lower word of another value
 30194 00000007 ????                    .$P_Val_YH:	resw 1		;AN000; higher word of another value
 30195                                  endstruc
 30196                                  
 30197                                  ; 31/03/2023
 30198                                  ;----------------------------------------------------------------------------
 30199                                  ;
 30200                                  ;RESULT LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
 30201                                  ;	DB	type			; TYPE RETURNED: 0=RESERVED,
 30202                                  ;					;	1=NUMBER, 2=LIST INDEX,
 30203                                  ;					;	3=STRING, 4=COMPLEX,
 30204                                  ;					;	5=FILESPEC, 6=DRIVE
 30205                                  ;					;	7=DATE, 8=TIME
 30206                                  ;					;	9=QUOTED STRING
 30207                                  ;	DB	ITEM_TAG		; MATCHED ITEM TAG
 30208                                  ;
 30209                                  ;	dw	synonym@		; es:@ points to found SYNONYM if provided.
 30210                                  ;
 30211                                  ;       +-
 30212                                  ;       | DD	n			; VALUE IF NUMBER
 30213                                  ;       | or
 30214                                  ;       |	DW i			; INDEX (OFFSET) INTO VALUE LIST
 30215                                  ;       |				; (ES presents Segment address)
 30216                                  ;       | or
 30217                                  ;       |	DD STRING		; OFFSET OF STRING VALUE
 30218                                  ;       | or
 30219                                  ;       |	DB drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
 30220                                  ;       | or
 30221                                  ;       |	DW YEAR	   		;(1980-2099)  IN CASE OF DATE
 30222                                  ;       |	DB MONTH   ;(1-12)	 Note: Range check is not performed.
 30223                                  ;       |	DB DATE	   ;(1-31)	 0 is filled when the corresponding field was not specified.
 30224                                  ;       | or
 30225                                  ;       |	DB HOUR	   ;(0-23)	 IN CASE OF TIME
 30226                                  ;       |	DB MINUTES    ;(0-59)	 Note: Range check is not performed .
 30227                                  ;       |	DB SECONDS    ;(0-59)	 0 is filled when the corresponding field was not specified .
 30228                                  ;       |	DB HUNDREDTHS ;(0-99)
 30229                                  ;       +-
 30230                                  ;
 30231                                  ;Note: ITEM_TAG is 0FFH when the caller does not specify the choice
 30232                                  ;      list.
 30233                                  ;
 30234                                  ;      YEAR: If the input value for the year is less than 100, parser
 30235                                  ;	     adds 1900 to it. For example, when 87 is input to parser for
 30236                                  ;	     the year value, he returns 1987.
 30237                                  ;----------------------------------------------------------------------------
 30238                                  
 30239                                  ;-------------------------------- Result block structure
 30240                                  struc $P_RESULT_BLK;
 30241 00000000 ??                      .$P_Type:	 resb 1		;AN000; Type returned
 30242 00000001 ??                      .$P_Item_Tag:	 resb 1		;AN000; Matched item tag
 30243 00000002 ????                    .$P_SYNONYM_Ptr: resw 1		;AN000; pointer to Synonym list returned
 30244 00000004 ????????                .$P_Picked_Val:	 resb 4		;AN000; value
 30245                                  endstruc
 30246                                  
 30247                                  ;**** values for the type field in the result block
 30248                                  
 30249                                  $P_EOL		 equ 0		;AN000; End of line
 30250                                  $P_Number	 equ 1		;AN000; Number
 30251                                  $P_List_Idx	 equ 2		;AN000; List Index
 30252                                  $P_String	 equ 3		;AN000; String
 30253                                  $P_Complex	 equ 4		;AN000; Complex
 30254                                  $P_File_Spec	 equ 5		;AN000; File Spec
 30255                                  $P_Drive	 equ 6		;AN000; Drive
 30256                                  $P_Date_F	 equ 7		;AN000; Date
 30257                                  $P_Time_F	 equ 8		;AN000; Time
 30258                                  $P_Quoted_String equ 9		;AN000; Quoted String
 30259                                  
 30260                                  $P_No_Tag	 equ 0FFh	;AN000; No ITEM_TAG found
 30261                                  
 30262                                  ;**** Return code
 30263                                  ;
 30264                                  ; following return code will be returned in the AX register.
 30265                                  
 30266                                  $P_No_Error	 equ 0		;AN000; No error
 30267                                  $P_Too_Many	 equ 1		;AN000; Too many operands
 30268                                  $P_Op_Missing	 equ 2		;AN000; Required operand missing
 30269                                  $P_Not_In_SW	 equ 3		;AN000; Not in switch list provided
 30270                                  $P_Not_In_Key	 equ 4		;AN000; Not in keyword list provided
 30271                                  $P_Out_Of_Range  equ 6		;AN000; Out of range specified
 30272                                  $P_Not_In_Val	 equ 7		;AN000; Not in value list provided
 30273                                  $P_Not_In_Str	 equ 8		;AN000; Not in string list provided
 30274                                  $P_Syntax	 equ 9		;AN000; Syntax error
 30275                                  $P_RC_EOL	 equ -1		;AN000; End of command line
 30276                                  
 30277                                  ;in second byte of $P_Flags, referenced as $P_Flags2:
 30278                                  $P_equ		 equ 01h	;AN000; "=" packed in string buffet
 30279                                  $P_Neg		 equ 02h	;AN000; Negative value
 30280                                  $P_Time12	 equ 04h	;AN000; set when PM is specified
 30281                                  $P_Key_Cmp	 equ 08h	;AN000; set when keyword compare
 30282                                  $P_SW_Cmp	 equ 10h	;AN000; set when switch compare
 30283                                  $P_Extra	 equ 20h	;AN000; set when extra delimiter found
 30284                                  $P_SW		 equ 40h	;AN000; set when switch found (tm08)
 30285                                  $P_Signed	 equ 80h	;AN000; signed numeric specified
 30286                                  
 30287                                  ;-------- Masks
 30288                                  $P_Make_Lower	 equ 20h	;AN000; make lower case character
 30289                                  $P_Make_Upper	 equ 0FFh-$P_Make_Lower ;AN000; make upper case character
 30290                                  
 30291                                  ;-------------
 30292                                  
 30293                                  struc $P_DOS_TBL
 30294 00000000 ??                      .$P_DOS_InfoID:	 resb 1		;AN000; information id for the table
 30295 00000001 ????                    .$P_DOS_TBL_Off: resw 1		;AN000; offset address of the table
 30296 00000003 ????                    .$P_DOS_TBL_Seg: resw 1		;AN000; segment address of the table
 30297                                  endstruc
 30298                                  
 30299                                  $P_DOS_Get_TBL	 equ 65h	;AN000; get uppercase table call
 30300                                  				;AN000; following parameters are set
 30301                                  				;AN000; to get casemap table.
 30302                                  $P_DOSTBL_Def	 equ -1		;AN000; get default
 30303                                  $P_DOSTBL_BL	 equ 5		;AN000; buffer length for Tbl pointer
 30304                                  $P_DOSTBL_File	 equ 4		;AN000; get file uppercase table
 30305                                  $P_DOSTBL_Char	 equ 2		;AN000; get character uppercase table
 30306                                  				; By this call following information
 30307                                  				; is returned.
 30308                                  
 30309                                  ; 03/04/2023
 30310                                  ;-------------------------------- country dependent information
 30311                                  
 30312                                  $P_DOS_Get_CDI	equ 3800h
 30313                                  
 30314                                  struc $P_CDI
 30315 00000000 ????                    .$P_CDI_DateF:	resw 1		;AN000;
 30316 00000002 ????????                .$P_CDI_Money:	resb 4		;AN000;
 30317 00000006 ????                    .$P_CDI_1000:	resb 2		;AN000;
 30318 00000008 ????                    .$P_CDI_Dec:	resb 2		;AN000;
 30319 0000000A ????                    .$P_CDI_DateS:	resb 2		;AN000;
 30320 0000000C ????                    .$P_CDI_TimeS:	resb 2		;AN000;
 30321 0000000E ??                      		resb 1		;AN000;
 30322 0000000F ??                      		resb 1		;AN000;
 30323 00000010 ??                      .$P_CDI_TimeF:	resb 1		;AN000;
 30324 00000011 ????????                		resw 2		;AN000;
 30325 00000015 ????                    		resb 2		;AN000;
 30326 00000017 <res Ah>                		resw 5		;AN000;
 30327                                  endstruc
 30328                                  
 30329                                  $P_Date_MDY	equ 0		;AN000;
 30330                                  $P_Date_DMY	equ 1		;AN000;
 30331                                  $P_Date_YMD	equ 2		;AN000;
 30332                                  
 30333                                  ; ----------------------------
 30334                                  ; (PARSE.ASM, MSDOS 6.0, 1991)
 30335                                  ; ----------------------------
 30336                                  
 30337                                  ;***********************************************************************
 30338                                  ; SysParse;
 30339                                  ;
 30340                                  ;  Function : Parser Entry
 30341                                  ;
 30342                                  ;  Input: DS:SI -> command line
 30343                                  ;	  ES:DI -> parameter block
 30344                                  ;	  psdata_seg -> psdata.inc
 30345                                  ;	  CX = operand ordinal
 30346                                  ;
 30347                                  ;	  Note:  ES is the segment containing all the control blocks defined
 30348                                  ;		 by the caller, except for the DOS COMMAND line parms, which
 30349                                  ;		 is in DS.
 30350                                  ;
 30351                                  ;  Output: CY = 1   error of caller, means invalid parameter block or
 30352                                  ;		    invalid value list. But this parser does NOT implement
 30353                                  ;		    this feature. Therefore CY always zero.
 30354                                  ;
 30355                                  ;	   CY = 0   AX = return code
 30356                                  ;		    BL = terminated delimiter code
 30357                                  ;		    CX = new operand ordinal
 30358                                  ;		    SI = set past scaned operand
 30359                                  ;		    DX = selected result buffer
 30360                                  ;
 30361                                  ; Use:	$P_Skip_Delim, $P_Chk_EOL, $P_Chk_Delim, $P_Chk_DBCS
 30362                                  ;	$P_Chk_Swtch, $P_Chk_Pos_Control, $P_Chk_Key_Control
 30363                                  ;	$P_Chk_Sw_Control, $P_Fill_Result
 30364                                  ;
 30365                                  ; Vars: $P_Ordinal(RW), $P_RC(RW), $P_SI_Save(RW), $P_DX(R), $P_Terminator(R)
 30366                                  ;	$P_SaveSI_Cmpx(W), $P_Flags(RW), $P_Found_SYNONYM(R), $P_Save_EOB(W)
 30367                                  ;
 30368                                  ;-------- Modification History -----------------------------------------
 30369                                  ;
 30370                                  ;  4/04/87 : Created by K. K,
 30371                                  ;  4/28/87 : $P_Val_YH assemble error (tm01)
 30372                                  ;	   : JMP SHORT assemble error (tm02)
 30373                                  ;  5/14/87 : Someone doesn't want to include psdata (tm03)
 30374                                  ;  6/12/87 : $P_Bridge is missing when TimeSw equ 0 and (CmpxSw equ 1 or
 30375                                  ;	     DateSW equ 1)	      (tm04)
 30376                                  ;  6/12/87 : $P_SorD_Quote is missing when QusSw equ 0 and CmpxSW equ 1
 30377                                  ;				      (tm05) in PSDATA.INC
 30378                                  ;  6/12/87 : $P_FileSp_Char and $P_FileSP_Len are missing
 30379                                  ;	     when FileSW equ 0 and DrvSW equ 1 (tm06) in PSDATA.INC
 30380                                  ;  6/18/87 : $VAL1 and $VAL3, $VAL2 and $VAL3 can be used in the same
 30381                                  ;	     value-list block	      (tm07)
 30382                                  ;  6/20/87 : Add $P_SW to check if there's an omiting parameter after
 30383                                  ;	     switch (keyword) or not. If there is, backup si for next call
 30384                                  ;	     (tm08)
 30385                                  ;  6/24/87 : Complex Item checking does not work correctly when CmpSW equ 1
 30386                                  ;	     and DateSW equ 0 and TimeSW equ 0 (tm09)
 30387                                  ;  6/24/87 : New function flag $P_colon_is_not_necessary for switch
 30388                                  ;	     /+15 and /+:15 are allowed for user (tm10)
 30389                                  ;  6/29/87 : ECS call changes DS register but it causes the address problem
 30390                                  ;	     in user's routines. $P_Chk_DBCS (tm11)
 30391                                  ;  7/10/87 : Switch with no_match flag (0x0000H) does not work correctly
 30392                                  ;					  (tm12)
 30393                                  ;  7/10/87 : Invalid switch/keyword does not work correctly
 30394                                  ;					  (tm13)
 30395                                  ;  7/10/87 : Drive_only breaks 3 bytes after the result buffer
 30396                                  ;					  (tm14)
 30397                                  ;  7/12/87 : Too_Many_Operands sets DX=0 as the PARSE result
 30398                                  ;					  (tm15)
 30399                                  ;  7/24/87 : Negative lower bound on numeric ranges cause trouble
 30400                                  ;
 30401                                  ;  7/24/87 : Quoted strings being returned with quotes.
 30402                                  ;
 30403                                  ;  7/28/87 : Kerry S (;AN018;)
 30404                                  ;	     Non optional value on switch (match flags<>0 and <>1) not flagged
 30405                                  ;	     as an error when missing.	Solution: return error 2.  Modules
 30406                                  ;	     affected: $P_Chk_SW_Control.
 30407                                  ;
 30408                                  ;  7/29/87 : Kerry S (;AN019;)
 30409                                  ;	     Now allow the optional bit in match flags for switches.  This
 30410                                  ;	     allows the switch to be encountered with a value or without a
 30411                                  ;	     value and no error is returned.
 30412                                  ;
 30413                                  ;
 30414                                  ;  8/28/87 : Ed K, Kerry S (;AN020;)
 30415                                  ;  9/14/87   In PROC $P_Get_DecNum, when checking for field separators
 30416                                  ;	     within a date response, instead of checking just for the one
 30417                                  ;	     character defined by the COUNTRY DEPENDENT INFO, check for
 30418                                  ;	     all three chars, "-", "/", and ".". Change $P_Chk_Switch to allow
 30419                                  ;	     slashes in date strings when DateSw (assembler switch) is set.
 30420                                  ;
 30421                                  ;  9/1/87  : Kerry S (;AN021)
 30422                                  ;	     In PROC $P_String_Comp, when comparing the switch or keyword on
 30423                                  ;	     the command line with the string in the control block the
 30424                                  ;	     comparing was stopping at a colon (switch) or equal (keyword)
 30425                                  ;	     on the command line and assuming a match.	This allowed a shorter
 30426                                  ;	     string on the command line than in the synonym list in the control
 30427                                  ;	     block.  I put in a test for a null in the control block so the
 30428                                  ;	     string in the control block must be the same length as the string
 30429                                  ;	     preceeding the colon or equal on the command line.
 30430                                  ;
 30431                                  ;  8/28/87 : Kerry S (;AN022;)
 30432                                  ;	     All references to data in PSDATA.INC had CS overrides.  This caused
 30433                                  ;	     problems for people who included it themselves in a segment other
 30434                                  ;	     than CS.  Added switch to allow including PSDATA.INC in any
 30435                                  ;	     segment.
 30436                                  ;
 30437                                  ;  9/16/87 : Ed K (;AN023;) PTM1040
 30438                                  ;	     in $p_set_cdi PROC, it assumes CS points to psdata. Change Push CS
 30439                                  ;	     into PUSH PSDATA_SEG.  In $P_Get_DecNum PROC, fix AN020
 30440                                  ;	     forced both TIME and DATE to use the delims, "-","/",".".
 30441                                  ;	     Created FLag, in $P_time_Format PROC, to request the delim in
 30442                                  ;	     BL be used if TIME is being parsed.
 30443                                  ;
 30444                                  ;  9/24/87 : Ed K
 30445                                  ;	     Removed the include to STRUC.INC.	Replaced the STRUC macro
 30446                                  ;	     invocations with their normally expanded code; made comments
 30447                                  ;	     out of the STRUC macro invocation statements to maintain readability.
 30448                                  ;
 30449                                  ;  9/24/87 : Ed K (;AN024;) PTM1222
 30450                                  ;	     When no CONTROL for a keyword found, tried to fill in RESULT
 30451                                  ;	     pointed to by non-existant CONTROL.
 30452                                  ;
 30453                                  ; 10/15/87 : Ed K (;AN025;) PTM1672
 30454                                  ;	     A quoted text string can be framed only by double quote.  Remove
 30455                                  ;	     support to frame quoted text string with single quote.
 30456                                  ;	     (apostrophe) $P_SorD_Quote is removed from PSDATA.INC.
 30457                                  ;	     $P_SQuote EQU also removed from PSDATA.INC.  Any references to
 30458                                  ;	     single quote in PROC prologues are left as is for history reasons.
 30459                                  ;
 30460                                  ;	     This fixes another bug, not mentioned in p1672, in that two
 30461                                  ;	     quote chars within a quoted string is supposed to be reported as
 30462                                  ;	     one quote character, but is reported as two quotes.  This changed
 30463                                  ;	     two instructions in PROC $P_Quoted_Str.
 30464                                  ;
 30465                                  ;	     Also fixed are several JMP that caused a NOP, these changed to
 30466                                  ;	     have the SHORT operator to avoid the unneeded NOP.
 30467                                  ;
 30468                                  ;	     The code and PSDATA.INC have been aligned for ease of reading.
 30469                                  ;
 30470                                  ; 10/26/87 : Ed K (;AN026;) PTM2041, DATE within SWITCH, BX reference to
 30471                                  ;	     psdata buffer should have psdata_seg.
 30472                                  ;
 30473                                  ; 10/27/87 : Ed K (;AN027;) PTM2042 comma between keywords implies
 30474                                  ;	     positional missing.
 30475                                  ;
 30476                                  ; 11/06/87 : Ed K (;AN028;) PTM 2315 Parser should not use line feed
 30477                                  ;	     as a line delimiter, should use carriage return.
 30478                                  ;	     Define switch: LFEOLSW, if on, accept LF as end of line char.
 30479                                  ;
 30480                                  ; 11/11/87 : Ed K (;AN029;) PTM 1651 GET RID OF WHITESPACE AROUND "=".
 30481                                  ;
 30482                                  ; 11/18/87 : Ed K (;AN030;) PTM 2551 If filename is just "", then
 30483                                  ;	     endless loop since SI is returned still pointing to start
 30484                                  ;	     of that parm.
 30485                                  ;
 30486                                  ; 11/19/87 : Ed K (;AN031;) PTM 2585 date & time getting bad values.
 30487                                  ;	     Vector to returned string has CS instead of Psdata_Seg, but
 30488                                  ;	     when tried to fix it on previous version, changed similar
 30489                                  ;	     but wrong place.
 30490                                  ;
 30491                                  ; 12/09/87 : Bill L (;AN032;) PTM 2772 colon and period are now valid
 30492                                  ;	     delimiters between hours, minutes, seconds for time. And period
 30493                                  ;	     and comma are valid delimiters between seconds and 100th second.
 30494                                  ;
 30495                                  ; 12/14/87 : Bill L (;AN033;) PTM 2722 if illegal delimiter characters
 30496                                  ;	     in a filespec, then flag an error.
 30497                                  ;
 30498                                  ; 12/22/87 : Bill L (;AN034;)	    All local data to parser is now
 30499                                  ;	     indexed off of the psdata_seg equate instead of the DS register.
 30500                                  ;	     Using this method, DS can point to the segment of PSP or to psdata
 30501                                  ;  -->	     local parser data. Why were some references to local data changed
 30502                                  ;	     to do this before, but not all ?????
 30503                                  ;
 30504                                  ; 02/02/88 : Ed K (;AC035;) INSPECT utility, suggests optimizations.
 30505                                  ;
 30506                                  ; 02/05/88 : Ed K (;AN036;) P3372-UPPERCASE TRANSLATION, PSDATA_SEG HOSED.
 30507                                  ;
 30508                                  ; 02/08/88 : Ed K (;AN037;) P3410-AVOID POP OF CS, CHECK BASESW FIRST.
 30509                                  ;
 30510                                  ; 02/19/88 : Ed K (;AN038;) p3524 above noon and "am" should be error
 30511                                  ;
 30512                                  ; 02/23/88 : Ed K (;AN039;) p3518 accept "comma" and "period" as decimal
 30513                                  ;	     separator in TIME before hundredths field.
 30514                                  ;
 30515                                  ; 08/09/90 : SA	M005	Prevented parser from recognizing '=' signs within
 30516                                  ;			strings as keywords.
 30517                                  ;
 30518                                  ;***********************************************************************
 30519                                  
 30520                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30521                                  cmd_parse:
 30522                                  	;call	sysparse
 30523                                  	;retn
 30524                                  
 30525                                  ; -----------------------------------
 30526                                  
 30527                                  	; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30528                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:44E7h
 30529                                  
 30530                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30531                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:4CABh
 30532                                  sysparse:
 30533 00004A5C 2EC706[7099]0000        	mov	word [cs:$P_Flags],0	;AC034; Clear all internal flags
 30534 00004A63 2E890E[FA99]            	mov	[cs:$P_ORIG_ORD],cx	;AN039; ORIGINAL ORDINAL FROM CX
 30535 00004A68 2E8926[FC99]            	mov	[cs:$P_ORIG_STACK],sp	;AN039; ORIGINAL VALUE OF STACK FROM SP
 30536 00004A6D 2E8936[FE99]            	mov	[cs:$P_ORIG_SI],si	;AN039; ORIGINAL START PARSE POINTER FROM SI
 30537                                  $P_Redo_Time:				;AN039; try to parse time again
 30538 00004A72 FC                      	cld				;AN000; confirm forward direction
 30539 00004A73 2E890E[6399]            	mov	[cs:$P_ORDINAL],cx      ;AC034; save operand ordinal
 30540                                  	;mov	word [cs:$P_RC],$P_No_Error
 30541 00004A78 2EC706[6599]0000        	mov	word [cs:$P_RC],0	;AC034; Assume no error
 30542 00004A7F 2EC706[7899]0000        	mov	word [cs:$P_Found_SYNONYM],0
 30543                                  					;AC034; initalize synonym pointer
 30544 00004A86 2EC706[6999]0000        	mov	word [cs:$P_DX],0	;AC034; (tm15)
 30545                                  
 30546                                  ;M029 -- Begin changes
 30547                                  ; The table of special chars $P_FileSp_Char should be initialized on every
 30548                                  ;entry to SysParse. This is in the non-checksum region and any program that
 30549                                  ;corrupts this table but does not corrupt the checksum region will leave
 30550                                  ;command.com parsing in an inconsistent state.
 30551                                  ; NB: The special characters string has been hardcoded here. If any change
 30552                                  ;is made to it in psdata.inc, a corresponding change needs to be made here.
 30553                                  
 30554 00004A8D 2EC706[359A]5B5D        	mov	word [cs:$P_FileSp_Char], '[]'	 ; "[]|<>+=;\""
 30555 00004A94 2EC706[379A]7C3C        	mov	word [cs:$P_FileSp_Char+2], '|<'
 30556 00004A9B 2EC706[399A]3E2B        	mov	word [cs:$P_FileSp_Char+4], '>+'
 30557 00004AA2 2EC706[3B9A]3D3B        	mov 	word [cs:$P_FileSp_Char+6], '=;'
 30558                                  
 30559                                  ;M029 -- End of changes
 30560                                  
 30561 00004AA9 E83609                  	call	$P_Skip_Delim		;AN000; Move si to 1st non white space
 30562 00004AAC 7312                    	jnc	short $P_Start		;AN000; If EOL is not encountered, do parse
 30563                                  
 30564                                  ;--------------------------- End of Line
 30565                                  	;mov	ax,$P_RC_EOL		;AN000; set exit code to -1
 30566 00004AAE B8FFFF                  	mov	ax,0FFFFh
 30567 00004AB1 53                      	push	bx			;AN000;
 30568                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 30569 00004AB2 268B1D                  	mov	bx,[es:di]		;AN000; Get the PARMSX address to
 30570                                  	
 30571                                  	;cmp	cl,[es:bx+$P_PARMSX_BLK.$P_MinP]
 30572 00004AB5 263A0F                  	cmp	cl,[es:bx]		;AN000; check ORDINAL to see if the minimum
 30573 00004AB8 7304                    	jae	short $P_Fin		;AN000; positional found.
 30574                                  
 30575                                  	;mov	ax,2
 30576 00004ABA B80200                  	mov	ax,$P_Op_Missing ; 2	;AN000; If no, set exit code to missing operand
 30577                                  	; 27/04/2023
 30578 00004ABD F8                      	clc
 30579                                  $P_Fin: 				;AN000;
 30580 00004ABE 5B                      	pop	bx			;AN000;
 30581                                  	;jmp	$P_Single_Exit		;AN000; return to the caller
 30582                                  	; 27/04/2023
 30583                                  	; cf = 0
 30584                                  	;clc
 30585 00004ABF C3                      	retn
 30586                                  
 30587                                  ;---------------------------
 30588                                  $P_Start:				;AN000;
 30589 00004AC0 2E8936[7299]            	mov	[cs:$P_SaveSI_Cmpx],si	;AN000;AC034;  save ptr to command line for later use by complex,
 30590 00004AC5 53                      	push	bx			;AN000; quoted string or file spec.
 30591 00004AC6 57                      	push	di			;AN000;
 30592 00004AC7 55                      	push	bp			;AN000;
 30593 00004AC8 8D1E[7A99]              	lea	bx,$P_STRING_BUF	;AC034; set buffer to copy from command string
 30594 00004ACC 2EF606[7199]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 30595                                  	;test	byte [cs:$P_Flags2],20h	;AC034; 3/9 extra delimiter encountered ?
 30596 00004AD2 7543                    	jnz	short $P_Pack_End	;AN000; 3/9 if yes, no need to copy
 30597                                  $P_Pack_Loop:				;AN000;
 30598 00004AD4 AC                      	lodsb				;AN000; Pick a operand from buffer
 30599 00004AD5 E8BF09                  	call	$P_Chk_Switch		;AN000; Check switch character
 30600 00004AD8 723C                    	jc	short $P_Pack_End_BY_EOL ;AN020; if carry set found delimiter type slash, need backup si, else continue
 30601                                  
 30602 00004ADA E82709                  	call	$P_Chk_EOL		;AN000; Check EOL character
 30603 00004ADD 7437                    	je	short $P_Pack_End_BY_EOL ;AN000; need backup si
 30604                                  
 30605 00004ADF E85409                  	call	$P_Chk_Delim		;AN000; Check delimiter
 30606 00004AE2 7518                    	jne	short $P_PL01 		;AN000; If no, process next byte
 30607                                  
 30608 00004AE4 2EF606[7199]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 30609                                  	;test	byte [cs:$P_Flags2],20h ;AC034; 3/9 If yes and white spec,
 30610 00004AEA 7505                    	jnz	short $P_Pack_End_backup_si
 30611                                  					;AN000; (tm08)
 30612 00004AEC E8F308                  	call	$P_Skip_Delim		;AN000; skip subsequent white space,too
 30613 00004AEF EB26                    	jmp	short $P_Pack_End	;AN000; finish copy by placing NUL at end
 30614                                  
 30615                                  $P_Pack_End_backup_si:			;AN000; (tm08)
 30616 00004AF1 2EF606[7199]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ ; 41h
 30617                                  	;test	byte [cs:$P_Flags2],41h ;AN000;AC034;  (tm08)
 30618 00004AF7 741E                    	jz	short $P_Pack_End	;AN000; (tm08)
 30619                                  
 30620 00004AF9 4E                      	dec	si			;AN000; (tm08)
 30621 00004AFA EB1B                    	jmp	short $P_Pack_End	;AN025; (tm08)
 30622                                  $P_PL01:				;AN000;
 30623 00004AFC 2E8807                  	mov	[cs:bx],al		;AN000; move byte to STRING_BUF
 30624                                  	;cmp	al,'='
 30625 00004AFF 3C3D                    	cmp	al,$P_Keyword ; '='	;AN000; if it is equal character,
 30626 00004B01 7506                    	jne	short $P_PL00 		;AN000; then
 30627                                  
 30628 00004B03 2E800E[7199]01          	or	byte [cs:$P_Flags2],$P_equ
 30629                                  	;or	byte [cs:$P_Flags_2],1	;AC034; remember it in flag
 30630                                  $P_PL00:				;AN000;
 30631 00004B09 43                      	inc	bx			;AN000; ready to see next byte
 30632 00004B0A E8B509                  	call	$P_Chk_DBCS		;AN000; was it 1st byte of DBCS ?
 30633 00004B0D 73C5                    	jnc	short $P_Pack_Loop	;AN000; if no, process to next byte
 30634                                  
 30635 00004B0F AC                      	lodsb				;AN000; if yes, store
 30636 00004B10 2E8807                  	mov	[cs:bx],al		;AN000;    2nd byte of DBCS
 30637 00004B13 43                      	inc	bx			;AN000; update pointer
 30638 00004B14 EBBE                    	jmp	short $P_Pack_Loop	;AN000; process to next byte
 30639                                  
 30640                                  $P_Pack_End_BY_EOL:			;AN000;
 30641 00004B16 4E                      	dec	si			;AN000; backup si pointer
 30642                                  $P_Pack_End:				;AN000;
 30643 00004B17 2E8936[6799]            	mov	[cs:$P_SI_Save],si	;AC034; save next pointer, SI
 30644                                  	;mov	byte [cs:bx],0
 30645 00004B1C 2EC60700                	mov	byte [cs:bx],$P_NULL	;AN000; put NULL at the end
 30646 00004B20 2E891E[7699]            	mov	[cs:$P_Save_EOB],bx
 30647                                  					;AC034; 3/17/87 keep the address for later use of complex
 30648                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 30649 00004B25 268B1D                  	mov	bx,[es:di]		;AN000; get PARMSX address
 30650 00004B28 8D36[7A99]              	lea	si,$P_STRING_BUF	;AC034;
 30651                                  	;cmp	byte [cs:si],'/'
 30652 00004B2C 2E803C2F                	cmp	byte [cs:si],$P_Switch	;AN000; the operand begins w/ switch char ?
 30653 00004B30 7436                    	je	short $P_SW_Manager	;AN000; if yes, process as switch
 30654                                  
 30655 00004B32 2E803C22                	cmp	byte [cs:si],$P_DQuote	;M005;is it a string?
 30656 00004B36 7408                    	je	short $P_Positional_Manager
 30657                                  					;M005;if so, process as one!
 30658 00004B38 2EF606[7199]01          	test	byte [cs:$P_Flags2],$P_equ
 30659                                  	;test	byte [cs:$P_Flags2],1	;AC034; the operand includes equal char ?
 30660 00004B3E 7554                    	jnz	short $P_Key_Manager	;AN000; if yes, process as keyword
 30661                                  
 30662                                  $P_Positional_Manager:			;AN000; else process as positional
 30663                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 30664 00004B40 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 30665 00004B44 30E4                    	xor	ah,ah			;AN000; ax = maxp
 30666 00004B46 2E3906[6399]            	cmp	[cs:$P_ORDINAL],ax	;AC034; too many positional ?
 30667 00004B4B 7312                    	jae	short $P_Too_Many_Error	;AN000; if yes, set exit code to too many
 30668                                  
 30669 00004B4D 2EA1[6399]              	mov	ax,[cs:$P_ORDINAL]	;AC034; see what the current ordinal
 30670 00004B51 D1E0                    	shl	ax,1			;AN000; ax = ax*2
 30671 00004B53 43                      	inc	bx			;AC035; add '2' to
 30672 00004B54 43                      	inc	bx			;AC035;  BX reg
 30673                                  					;AN000; now bx points to 1st CONTROL
 30674 00004B55 01C3                    	add	bx,ax			;AN000; now bx points to specified CONTROL address
 30675 00004B57 268B1F                  	mov	bx,[es:bx]		;AN000; now bx points to specified CONTROL itself
 30676 00004B5A E88800                  	call	$P_Chk_Pos_Control	;AN000; Do process for positional
 30677 00004B5D EB69                    	jmp	short $P_Return_to_Caller
 30678                                  					;AN000; and return to the caller
 30679                                  $P_Too_Many_Error:			;AN000;
 30680                                  	;mov	word [cs:$P_RC],1
 30681 00004B5F 2EC706[6599]0100        	mov	word [cs:$P_RC],$P_Too_Many
 30682                                  					;AC034; set exit code
 30683 00004B66 EB60                    	jmp	short $P_Return_to_Caller
 30684                                  					;AN000; and return to the caller
 30685                                  $P_SW_Manager:				;AN000;
 30686                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 30687 00004B68 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 30688 00004B6C 30E4                    	xor	ah,ah			;AN000; ax = maxp
 30689 00004B6E 40                      	inc	ax			;AN000;
 30690 00004B6F D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
 30691 00004B71 01C3                    	add	bx,ax			;AN000; now bx points to maxs
 30692 00004B73 268A0F                  	mov	cl,[es:bx]		;AN000;
 30693 00004B76 30ED                    	xor	ch,ch			;AN000; cx = maxs
 30694 00004B78 09C9                    	or	cx,cx			;AN000; at least one switch ?
 30695 00004B7A 740F                    	jz	short $P_SW_Not_Found 	;AN000;
 30696 00004B7C 43                      	inc	bx			;AN000; now bx points to 1st CONTROL address
 30697                                  $P_SW_Mgr_Loop: 			;AN000;
 30698 00004B7D 53                      	push	bx			;AN000;
 30699 00004B7E 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to Switch CONTROL itself
 30700 00004B81 E8C100                  	call	$P_Chk_SW_Control	;AN000; do process for switch
 30701 00004B84 5B                      	pop	bx			;AN000;
 30702 00004B85 7341                    	jnc	short $P_Return_to_Caller
 30703                                  					;AN000; if the CONTROL is for the switch, exit
 30704 00004B87 43                      	inc	bx			;AC035; add '2' to
 30705 00004B88 43                      	inc	bx			;AC035;  BX reg
 30706                                  					;AN000; else bx points to the next CONTROL
 30707 00004B89 E2F2                    	loop	$P_SW_Mgr_Loop		;AN000; and loop
 30708                                  $P_SW_Not_Found:			;AN000;
 30709                                  	;mov	word [cs:$P_RC],3
 30710 00004B8B 2EC706[6599]0300        	mov	word [cs:$P_RC],$P_Not_In_SW
 30711                                  					;AC034; here no CONTROL for the switch has
 30712 00004B92 EB34                    	jmp	short $P_Return_to_Caller0
 30713                                  					;AN000; not been found, means error.
 30714                                  $P_Key_Manager: 			;AN000;
 30715                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 30716 00004B94 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 30717 00004B98 30E4                    	xor	ah,ah			;AN000; ax = maxp
 30718 00004B9A 40                      	inc	ax			;AN000;
 30719 00004B9B D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
 30720 00004B9D 01C3                    	add	bx,ax			;AN000; now bx points to maxs
 30721 00004B9F 268A07                  	mov	al,[es:bx]		;AN000;
 30722 00004BA2 30E4                    	xor	ah,ah			;AN000; ax = maxs
 30723 00004BA4 D1E0                    	shl	ax,1			;AN000;
 30724 00004BA6 40                      	inc	ax			;AN000; ax = ax*2+1
 30725 00004BA7 01C3                    	add	bx,ax			;AN000; now bx points to maxk
 30726 00004BA9 268A0F                  	mov	cl,[es:bx]		;AN000;
 30727 00004BAC 30ED                    	xor	ch,ch			;AN000; cx = maxk
 30728 00004BAE 09C9                    	or	cx,cx			;AN000; at least one keyword ?
 30729 00004BB0 740F                    	jz	short $P_Key_Not_Found	;AN000;
 30730 00004BB2 43                      	inc	bx			;AN000; now bx points to 1st CONTROL
 30731                                  $P_Key_Mgr_Loop:			;AN000;
 30732 00004BB3 53                      	push	bx			;AN000;
 30733 00004BB4 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to keyword CONTROL itself
 30734 00004BB7 E85A00                  	call	$P_Chk_Key_Control	;AN000; do process for keyword
 30735 00004BBA 5B                      	pop	bx			;AN000;
 30736 00004BBB 730B                    	jnc	short $P_Return_to_Caller
 30737                                  					;AN000; if the CONTROL is for the keyword, exit
 30738 00004BBD 43                      	inc	bx			;AC035; add '2' to
 30739 00004BBE 43                      	inc	bx			;AC035;  BX reg
 30740                                  					;AN000; else bx points to the next CONTROL
 30741 00004BBF E2F2                    	loop	$P_Key_Mgr_Loop 	;AN000; and loop
 30742                                  $P_Key_Not_Found:			;AN000;
 30743                                  	;mov	word [cs:$P_RC],4
 30744 00004BC1 2EC706[6599]0400        	mov	word [cs:$P_RC],$P_Not_In_Key
 30745                                  					;AC034; here no CONTROL for the keyword has
 30746                                  $P_Return_to_Caller0:
 30747                                  $P_Return_to_Caller:			;AN000; not been found, means error.
 30748 00004BC8 5D                      	pop	bp			;AN000;
 30749 00004BC9 5F                      	pop	di			;AN000;
 30750 00004BCA 5B                      	pop	bx			;AN000;
 30751 00004BCB 2E8B0E[6399]            	mov	cx,[cs:$P_ORDINAL]	;AC034; return next ordinal
 30752 00004BD0 2EA1[6599]              	mov	ax,[cs:$P_RC]		;AC034; return exit code
 30753 00004BD4 2E8B36[6799]            	mov	si,[cs:$P_SI_Save]	;AC034; return next operand pointer
 30754 00004BD9 2E8B16[6999]            	mov	dx,[cs:$P_DX]		;AC034; return result buffer address
 30755 00004BDE 2E8A1E[6B99]            	mov	bl,[cs:$P_Terminator]	;AC034; return delimiter code found
 30756                                  $P_Single_Exit: 			;AN000;
 30757 00004BE3 F8                      	clc				;AN000;
 30758 00004BE4 C3                      	retn				;AN000;
 30759                                  
 30760                                  ;***********************************************************************
 30761                                  ; $P_Chk_Pos_Control
 30762                                  ;
 30763                                  ; Function: Parse CONTROL block for a positional
 30764                                  ;
 30765                                  ; Input:     ES:BX -> CONTROL block
 30766                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30767                                  ;
 30768                                  ; Output:    None
 30769                                  ;
 30770                                  ; Use:	 $P_Fill_Result, $P_Check_Match_Flags
 30771                                  ;
 30772                                  ; Vars: $P_Ordinal(W), $P_RC(W)
 30773                                  ;***********************************************************************
 30774                                  
 30775                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30776                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4671h
 30777                                  
 30778                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30779                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:4E35h
 30780                                  $P_Chk_Pos_Control:
 30781 00004BE5 50                      	push	ax			;AN000;
 30782                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 30783 00004BE6 268B07                  	mov	ax,[es:bx]		;AN000;
 30784                                  	;test	ax,2
 30785 00004BE9 A90200                  	test	ax,$P_Repeat		;AN000; repeat allowed ?
 30786 00004BEC 7505                    	jnz	short $P_CPC00		;AN000; then do not increment ORDINAL
 30787                                  
 30788 00004BEE 2EFF06[6399]            	inc	word [cs:$P_ORDINAL]	;AC034; update the ordinal
 30789                                  $P_CPC00:				;AN000;
 30790                                  	;cmp	byte [cs:si],0
 30791 00004BF3 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; no data ?
 30792 00004BF7 7516                    	jne	short $P_CPC01		;AN000;
 30793                                  
 30794                                  	;test	ax,1
 30795 00004BF9 A90100                  	test	ax,$P_Optional		;AN000; yes, then is it optional ?
 30796 00004BFC 7509                    	jnz	short $P_CPC02		;AN000;
 30797                                  
 30798 00004BFE 2EC706[6599]0200        	mov	word [cs:$P_RC],$P_Op_Missing ; 2
 30799                                  					;AC034; no, then error	 3/17/87
 30800 00004C05 EB0B                    	jmp	short $P_CPC_Exit	;AN000;
 30801                                  $P_CPC02:				;AN000;
 30802                                  	; 27/04/2023
 30803                                  	;push	ax ; *			;AN000;
 30804                                  	;
 30805                                  	;;mov	al,3
 30806                                  	;mov	al,$P_String		;AN000; if it is optional return NULL
 30807                                  	;;mov	ah,0FFh
 30808                                  	;mov	ah,$P_No_Tag		;AN000; no item tag indication
 30809                                  	;31/03/2023
 30810 00004C07 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30811 00004C0A E89500                  	call	$P_Fill_Result		;AN000;
 30812                                  	; 27/04/2023
 30813                                  	;pop	ax ; *			;AN000;
 30814 00004C0D EB03                    	jmp	short $P_CPC_Exit	;AN000;
 30815                                  $P_CPC01:				;AN000;
 30816 00004C0F E81101                  	call	$P_Check_Match_Flags	;AN000;
 30817                                  $P_CPC_Exit:				;AN000;
 30818 00004C12 58                      	pop	ax			;AN000;
 30819 00004C13 C3                      	retn				;AN000;
 30820                                  
 30821                                  ;***********************************************************************
 30822                                  ; $P_Chk_Key_Control
 30823                                  ;
 30824                                  ; Function: Parse CONTROL block for a keyword
 30825                                  ;
 30826                                  ; Input:     ES:BX -> CONTROL block
 30827                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30828                                  ;
 30829                                  ; Output:    CY = 1 : not match
 30830                                  ;
 30831                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 30832                                  ;
 30833                                  ; Vars: $P_RC(W), $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 30834                                  ;***********************************************************************
 30835                                  
 30836                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30837                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30838                                  $P_Chk_Key_Control:			;AN000;
 30839 00004C14 F9                      	stc				;AN000;this logic works when the KeySW
 30840 00004C15 C3                      	retn				;AN000;is reset.
 30841                                  
 30842                                  ;***********************************************************************
 30843                                  ; $P_Search_KEYorSW:
 30844                                  ;
 30845                                  ; Function: Seach specified keyword or switch from CONTROL
 30846                                  ;
 30847                                  ; Input:     ES:BX -> CONTROL block
 30848                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30849                                  ;
 30850                                  ; Output:    CY = 1 : not match
 30851                                  ;
 30852                                  ; Use:	 $P_String_Comp, $P_MoveBP_NUL, $P_Found_SYNONYM
 30853                                  ;***********************************************************************
 30854                                  
 30855                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30856                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30857                                  $P_Search_KEYorSW:
 30858 00004C16 55                      	push	bp			;AN000;
 30859 00004C17 51                      	push	cx			;AN000;
 30860 00004C18 268A4F08                	mov	cl,[es:bx+$P_CONTROL_BLK.$P_nid]
 30861                                  	;mov	cl,[es:bx+8]		;AN000; Get synonym count
 30862                                  	; 14/06/2023
 30863                                  	;xor	ch,ch			;AN000; and set it to cx
 30864                                  	;or	cx,cx			;AN000; No synonyms specified ?
 30865 00004C1C 08C9                    	or	cl,cl
 30866 00004C1E 740E                    	jz	short $P_KEYorSW_Not_Found
 30867                                  					;AN000; then indicate not found by CY
 30868 00004C20 268D6F09                	lea	bp,[es:bx+$P_CONTROL_BLK.$P_KEYorSW]
 30869                                  	;lea	bp,[es:bx+9]		;AN000; BP points to the 1st synonym
 30870                                  $P_KEYorSW_Loop:			;AN000;
 30871 00004C24 E8F803                  	call	$P_String_Comp		;AN000; compare string in buffer w/ the synonym
 30872 00004C27 7308                    	jnc	short $P_KEYorSW_Found	;AN000; If match, set it to synonym pointer
 30873 00004C29 E80D00                  	call	$P_MoveBP_NUL		;AN000; else, bp points to the next string
 30874 00004C2C E2F6                    	loop	$P_KEYorSW_Loop 	;AN000; loop nid times
 30875                                  $P_KEYorSW_Not_Found:			;AN000;
 30876 00004C2E F9                      	stc				;AN000; indicate not found in synonym list
 30877 00004C2F EB05                    	jmp	short $P_KEYorSW_Exit	;AN000; and exit
 30878                                  $P_KEYorSW_Found:			;AN000;
 30879 00004C31 2E892E[7899]            	mov	[cs:$P_Found_SYNONYM],bp
 30880                                  					;AC034; set synonym pointer
 30881                                  	; 27/04/2023
 30882                                  	; cf = 0
 30883                                  	;clc				;AN000; indicate found
 30884                                  $P_KEYorSW_Exit:			;AN000;
 30885 00004C36 59                      	pop	cx			;AN000;
 30886 00004C37 5D                      	pop	bp			;AN000;
 30887 00004C38 C3                      	retn				;AN000;
 30888                                  
 30889                                  ;***********************************************************************
 30890                                  ; $P_MoveBP_NUL
 30891                                  ;***********************************************************************
 30892                                  
 30893                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30894                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30895                                  $P_MoveBP_NUL:
 30896                                  $P_MBP_Loop:				;AN000;
 30897                                  	;cmp	byte [es:bp+0],0
 30898 00004C39 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000; Increment BP that points
 30899 00004C3E 7403                    	je	short $P_MBP_Exit	;AN000; to the synomym list
 30900 00004C40 45                      	inc	bp			;AN000; until
 30901 00004C41 EBF6                    	jmp	short $P_MBP_Loop	;AN000; NULL encountered.
 30902                                  $P_MBP_Exit:				;AN000;
 30903 00004C43 45                      	inc	bp			;AN000; bp points to next to NULL
 30904 00004C44 C3                      	retn				;AN000;
 30905                                  
 30906                                  ;***********************************************************************
 30907                                  ; $P_Chk_SW_Control
 30908                                  ;
 30909                                  ; Function: Parse CONTROL block for a switch
 30910                                  ;
 30911                                  ; Input:     ES:BX -> CONTROL block
 30912                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30913                                  ;
 30914                                  ; Output:    CY = 1 : not match
 30915                                  ;
 30916                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 30917                                  ;
 30918                                  ; Vars:  $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 30919                                  ;***********************************************************************
 30920                                  
 30921                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30922                                  	;
 30923                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30924                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:4E9Ah 
 30925                                  $P_Chk_SW_Control:
 30926 00004C45 2E800E[7199]10          	or	byte [cs:$P_Flags2],$P_SW_Cmp
 30927                                  	;or	byte [cs:$P_Flags2],10h	;AC034; Indicate switch for later string comparison
 30928 00004C4B E8C8FF                  	call	$P_Search_KEYorSW	;AN000; Search the switch in the CONTROL block
 30929 00004C4E 7251                    	jc	short $P_Chk_SW_Err0	;AN000; not found, then try next CONTROL
 30930                                  
 30931 00004C50 2E8026[7199]EF          	and	byte [cs:$P_Flags2],0FFh-$P_SW_Cmp
 30932                                  	;and	byte [cs:$P_Flags2],0EFh
 30933                                  					;AC034; reset the indicator previously set
 30934 00004C56 50                      	push	ax			;AN000;       /switch:
 30935 00004C57 2EA1[7499]              	mov	ax,[cs:$P_KEYorSW_Ptr]	;AC034;	      ^       ^
 30936 00004C5B 29F0                    	sub	ax,si			;AN000;  SI	KEYorSW
 30937 00004C5D 2E0106[7299]            	add	[cs:$P_SaveSI_Cmpx],ax	;AC034; update for complex list
 30938 00004C62 58                      	pop	ax			;AN000;
 30939                                  
 30940 00004C63 2E8B36[7499]            	mov	si,[cs:$P_KEYorSW_Ptr]	;AC034; set si at the end or colon
 30941                                  	;cmp	byte [cs:si],0
 30942 00004C68 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; any data after colon
 30943 00004C6C 7525                    	jne	short $P_CSW00		;AN000; if yes, process match flags
 30944                                  
 30945                                  	;cmp	byte [cs:si],':'
 30946 00004C6E 2E807CFF3A              	cmp	byte [cs:si-1],$P_Colon
 30947                                  					;AN000; if no, the switch terminated by colon ?
 30948 00004C73 7509                    	jne	short $P_Chk_if_data_required
 30949                                  					;AN000; if yes,
 30950                                  
 30951 00004C75 2EC706[6599]0900        	mov	word [cs:$P_RC],$P_Syntax
 30952                                  	;mov	word [cs:$P_RC],9	;AC034; return syntax error
 30953 00004C7C EB1A                    	jmp	short $P_Chk_SW_Exit	;AN000;
 30954                                  
 30955                                  $P_Chk_if_data_required:		;AN018; no data, no colon
 30956                                  	;cmp	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],0
 30957                                  	; 27/04/2023
 30958 00004C7E 26833F00                	cmp	word [es:bx],0		;AN018; should have data? zero match flag means switch followed by nothing is OK
 30959 00004C82 7414                    	je	short $P_Chk_SW_Exit	;AN018; match flags not zero so should have something if optional bit is not on
 30960                                  
 30961                                  	;;test	word [es:bx],1 ; $P_Optional
 30962                                  	;test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 30963 00004C84 26F60701                	test	byte [es:bx],$P_Optional
 30964                                  					;AN019; see if no value is valid
 30965 00004C88 750E                    	jnz	short $P_Chk_SW_Exit	;AN019; if so, then leave, else yell
 30966                                  
 30967 00004C8A 2EC706[6599]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 30968                                  	;mov	word [cs:$P_RC],2	;AC034; return required operand missing
 30969 00004C91 EB05                    	jmp	short $P_Chk_SW_Exit	;AN018;
 30970                                  
 30971                                  $P_CSW00:				;AN000;
 30972 00004C93 E88D00                  	call	$P_Check_Match_Flags	;AN000; process match flag
 30973 00004C96 F8                      	clc				;AN000; indicate match
 30974                                  	;jmp	short $P_Chk_SW_Single_Exit
 30975 00004C97 C3                      	retn	; 31/03/2023		;AN000;
 30976                                  	; 31/03/2023
 30977                                  ;$P_Chk_SW_Err0: 			;AN000;
 30978                                  ;	stc				;AN000; not found in switch synonym list
 30979                                  ;	;jmp	short $P_Chk_SW_Single_Exit
 30980                                  ;	retn	; 31/03/2023		;AN000;
 30981                                  	
 30982                                  $P_Chk_SW_Exit: 			;AN000;
 30983 00004C98 50                      	push	ax			;AN000;
 30984                                  	; 31/03/2023
 30985 00004C99 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30986                                  	;;mov	al,3
 30987                                  	;;mov	ah,0FFh
 30988                                  	;mov	al,$P_String		;AN000; set
 30989                                  	;mov	ah,$P_No_Tag		;AN000;    result
 30990 00004C9C E80300                  	call	$P_Fill_Result		;AN000; 	 buffer
 30991 00004C9F 58                      	pop	ax			;AN000;
 30992 00004CA0 F8                      	clc				;AN000;
 30993                                  	; 31/03/2023
 30994                                  $P_Chk_SW_Err0:
 30995                                  $P_Chk_SW_Single_Exit:			;AN000;
 30996 00004CA1 C3                      	retn				;AN000;
 30997                                  
 30998                                  ;***********************************************************************
 30999                                  ; $P_Fill_Result
 31000                                  ;
 31001                                  ; Function: Fill the result buffer
 31002                                  ;
 31003                                  ; Input:    AH = Item tag
 31004                                  ;	    AL = type
 31005                                  ;		  AL = 1: CX,DX has 32bit number (CX = high)
 31006                                  ;		  AL = 2: DX has index(offset) into value list
 31007                                  ;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
 31008                                  ;		  AL = 7: DX has year, CL has month and CH has date
 31009                                  ;		  AL = 8: DL has hours, DH has minutes, CL has secondsn,
 31010                                  ;			  amd CH has hundredths
 31011                                  ;		  AL = else: psdata_seg:SI points to returned string buffer
 31012                                  ;	    ES:BX -> CONTROL block
 31013                                  ;
 31014                                  ; Output:   None
 31015                                  ;
 31016                                  ; Use:	$P_Do_CAPS_String, $P_Remove_Colon, $P_Found_SYNONYM
 31017                                  ;
 31018                                  ; Vars: $P_DX(W)
 31019                                  ;***********************************************************************
 31020                                  
 31021                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31022                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31023                                  $P_Fill_Result:
 31024 00004CA2 57                      	push	di			;AN000;
 31025 00004CA3 268B7F04                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Result_Buf]
 31026                                  	;mov	di,[es:bx+4]		;AN000; di points to result buffer
 31027 00004CA7 2E893E[6999]            	mov	[cs:$P_DX],di		;AC034; set returned result address
 31028                                  	;mov	[es:di+$P_RESULT_BLK.$P_Type],al
 31029                                  	;;mov	[es:di],al		;AN000; store type
 31030                                  	;mov	[es:di+$P_RESULT_BLK.$P_Item_Tag],ah
 31031                                  	;;mov	[es:di+1],ah		;AN000; store item tag
 31032                                  	; 31/03/2023
 31033 00004CAC 268905                  	mov	[es:di],ax
 31034 00004CAF 50                      	push	ax			;AN000;
 31035 00004CB0 2EA1[7899]              	mov	ax,[cs:$P_Found_SYNONYM]
 31036                                  					;AC034; if yes,
 31037 00004CB4 26894502                	mov	[es:di+$P_RESULT_BLK.$P_SYNONYM_Ptr],ax
 31038                                  	;mov	[es:di+2],ax		;AN000;   then set it to the result
 31039 00004CB8 58                      	pop	ax			;AN000;
 31040                                  $P_RLT04:				;AN000;
 31041                                  	;cmp	al,1
 31042 00004CB9 3C01                    	cmp	al,$P_Number		;AN000; if number
 31043 00004CBB 750A                    	jne	short $P_RLT00		;AN000;
 31044                                  $P_RLT02:				;AN000;
 31045 00004CBD 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 31046                                  	;mov	[es:di+4],dx		;AN000; then store 32bit
 31047 00004CC1 26894D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cx
 31048                                  	;mov	[es:di+6],cx		;AN000;	number
 31049 00004CC5 EB5A                    	jmp	short $P_RLT_Exit	;AN000;
 31050                                  $P_RLT00:				;AN000;
 31051                                  	;cmp	al,2
 31052 00004CC7 3C02                    	cmp	al,$P_List_Idx		;AN000; if list index
 31053 00004CC9 7506                    	jne	short $P_RLT01		;AN000;
 31054 00004CCB 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 31055                                  	;mov	[es:di+4],dx		;AN000; then store list index
 31056 00004CCF EB50                    	jmp	short $P_RLT_Exit	;AN000;
 31057                                  $P_RLT01:				;AN000;
 31058                                  	;cmp	al,7
 31059 00004CD1 3C07                    	cmp	al,$P_Date_F ; 7	;AN000; Date format ?
 31060 00004CD3 74E8                    	je	short $P_RLT02		;AN000;
 31061                                  	;cmp	al,8
 31062 00004CD5 3C08                    	cmp	al,$P_Time_F ; 8	;AN000; Time format ?
 31063 00004CD7 74E4                    	je	short $P_RLT02		;AN000;
 31064                                  	;cmp	al,6
 31065 00004CD9 3C06                    	cmp	al,$P_Drive  ; 6	;AN000; drive format ?
 31066 00004CDB 7506                    	jne	short $P_RLT03		;AN000;
 31067                                  
 31068 00004CDD 26885504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dl
 31069                                  	;mov	[es:di+4],dl		;AN000; store drive number
 31070 00004CE1 EB3E                    	jmp	short $P_RLT_Exit	;AN000;
 31071                                  
 31072                                  $P_RLT03:				;AN000;
 31073                                  	;cmp	al,4
 31074 00004CE3 3C04                    	cmp	al,$P_Complex		;AN000; complex format ?
 31075 00004CE5 750F                    	jne	short $P_RLT05		;AN000;
 31076                                  
 31077 00004CE7 2EA1[7299]              	mov	ax,[cs:$P_SaveSI_Cmpx]	;AC034; then get pointer in command buffer
 31078 00004CEB 40                      	inc	ax			;AN000; skip left Parentheses
 31079 00004CEC 26894504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],ax
 31080                                  	;mov	[es:di+4],ax		;AN000; store offset
 31081 00004CF0 268C5D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],ds
 31082                                  	;mov	[es:di+6],ds		;AN000; store segment
 31083 00004CF4 EB2B                    	jmp	short $P_RLT_Exit	;AN000;
 31084                                  
 31085                                  $P_RLT05:				;AN000;
 31086                                  ;------------------------  AL = 3, 5, or 9
 31087 00004CF6 26897504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],si
 31088                                  	;mov	[es:di+4],si		;AN000; store offset of STRING_BUF
 31089 00004CFA 268C4D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cs
 31090                                  	;mov	[es:di+6],cs		;AN031; store segment of STRING_BUF
 31091                                  
 31092 00004CFE 50                      	push	ax			;AN000;
 31093 00004CFF 26F6470201              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_File
 31094                                  	;test	byte [es:bx+2],1	;AN000; need CAPS by file table?
 31095 00004D04 7404                    	jz	short $P_RLT_CAP00	;AN000;
 31096                                  
 31097                                  	;mov	al,4
 31098 00004D06 B004                    	mov	al,$P_DOSTBL_File ; 4	;AN000; use file upper case table
 31099 00004D08 EB09                    	jmp	short $P_RLT_CAP02	;AN000;
 31100                                  
 31101                                  $P_RLT_CAP00:				;AN000;
 31102 00004D0A 26F6470202              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_Char
 31103                                  	;test	byte [es:bx+2],2	;AN000; need CAPS by char table ?
 31104 00004D0F 7405                    	jz	short $P_RLT_CAP01	;AN000;
 31105                                  
 31106                                  	;mov	al,2
 31107 00004D11 B002                    	mov	al,$P_DOSTBL_Char ; 2	;AN000; use character upper case table
 31108                                  $P_RLT_CAP02:				;AN000;
 31109 00004D13 E80C01                  	call	$P_Do_CAPS_String	;AN000;  process CAPS along the table
 31110                                  $P_RLT_CAP01:				;AN000;
 31111 00004D16 58                      	pop	ax			;AN000;
 31112 00004D17 26F6470210              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_Rm_Colon
 31113                                  	;test	byte [es:bx+2],10h	;AN000; removing colon at end ?
 31114 00004D1C 7403                    	jz	short $P_RLT_Exit	;AN000;
 31115                                  
 31116 00004D1E E8DD00                  	call	$P_Remove_Colon 	;AN000; then process it.
 31117                                  $P_RLT_Exit:				;AN000;
 31118 00004D21 5F                      	pop	di			;AN000;
 31119 00004D22 C3                      	retn				;AN000;
 31120                                  
 31121                                  ;***********************************************************************
 31122                                  ; $P_Check_Match_Flags
 31123                                  ;
 31124                                  ; Function:  Check the mutch_flags and make the exit code and set the
 31125                                  ;	     result buffer
 31126                                  ;
 31127                                  ;	    Check for types in this order:
 31128                                  ;		Complex
 31129                                  ;		Date
 31130                                  ;		Time
 31131                                  ;		Drive
 31132                                  ;		Filespec
 31133                                  ;		Quoted String
 31134                                  ;		Simple String
 31135                                  ;
 31136                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31137                                  ;	     ES:BX -> CONTROL block
 31138                                  ;
 31139                                  ; Output:    None
 31140                                  ;
 31141                                  ; Use:	     $P_Value, P$_SValue, $P_Simple_String, $P_Date_Format
 31142                                  ;	     $P_Time_Format, $P_Complex_Format, $P_File_Foemat
 31143                                  ;	     $P_Drive_Format
 31144                                  ;***********************************************************************
 31145                                  
 31146                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31147                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31148                                  $P_Check_Match_Flags:
 31149 00004D23 2EC606[3E9A]00          	mov	byte [cs:$P_err_flag],$P_NULL ; 0
 31150                                  					;AN033;AC034;; clear filespec error flag.
 31151 00004D29 50                      	push	ax			;AN000;
 31152                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 31153 00004D2A 268B07                  	mov	ax,[es:bx]		;AN000; load match flag(16bit) to ax
 31154 00004D2D 09C0                    	or	ax,ax			;AC035; test ax for zero
 31155 00004D2F 7518                    	jnz	short $P_Mat		;AN000; (tm12)
 31156 00004D31 50                      	push	ax			;AN000; (tm12)
 31157 00004D32 53                      	push	bx			;AN000; (tm12)
 31158 00004D33 52                      	push	dx			;AN000; (tm12)
 31159 00004D34 57                      	push	di			;AN000; (tm12)
 31160 00004D35 2EC706[6599]0900        	mov	word [cs:$P_RC],$P_Syntax
 31161                                  	;mov	word [cs:$P_RC],9	;AC034; (tm12)
 31162                                  	; 31/03/2023
 31163 00004D3C B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31164                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; (tm12)
 31165                                  	;mov	al,$P_String ; 3	;AN000; (tm12)
 31166 00004D3F E860FF                  	call	$P_Fill_Result		;AN000; (tm12)
 31167 00004D42 5F                      	pop	di			;AN000; (tm12)
 31168 00004D43 5A                      	pop	dx			;AN000; (tm12)
 31169 00004D44 5B                      	pop	bx			;AN000; (tm12)
 31170 00004D45 58                      	pop	ax			;AN000; (tm12)
 31171                                  	;jmp	short $P_Bridge 	;AC035; (tm12)
 31172                                  	; 31/03/2023
 31173                                  $P_Bridge:	; 18/04/2023		;AN000;
 31174 00004D46 E99C00                  	jmp	$P_Match_Exit		;AN000; (tm02)
 31175                                  $P_Mat: 				;AN000; (tm12)
 31176                                  $P_Match01:				;AN000;
 31177                                  	;test	ax,1000h
 31178 00004D49 A90010                  	test	ax,$P_Date_S		;AN000; Date string
 31179 00004D4C 7412                    	jz	short $P_Match02	;AN000;
 31180 00004D4E 2EC706[6599]0000        	mov	word [cs:$P_RC],$P_No_Error
 31181                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 31182 00004D55 E86503                  	call	$P_Date_Format		;AN000; do process
 31183 00004D58 2E833E[6599]09          	cmp	word [cs:$P_RC],$P_Syntax
 31184                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 31185                                  	; 18/04/2023
 31186 00004D5E 75E6                    	jne	short $P_Bridge		;AN000;
 31187                                  $P_Match02:				;AN000;
 31188                                  	;test	ax,800h
 31189 00004D60 A90008                  	test	ax,$P_Time_S		;AN000; Time string
 31190 00004D63 7412                    	jz	short $P_Match03	;AN000;
 31191 00004D65 2EC706[6599]0000        	mov	word [cs:$P_RC],$P_No_Error
 31192                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 31193 00004D6C E86004                  	call	$P_Time_Format		;AN000; do process
 31194 00004D6F 2E833E[6599]09          	cmp	word [cs:$P_RC],$P_Syntax
 31195                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 31196                                  	;jne	short $P_Bridge		;AN000; (tm09)
 31197                                  	;jmp	short $P_Match03	;AN025; (tm09)
 31198                                  	; 31/03/2023
 31199 00004D75 756E                    	jne	short $P_Match_Exit
 31200                                  ;$P_Bridge:				;AN000;
 31201                                  	;jmp	short $P_Match_Exit	;AN000; (tm02)
 31202                                  $P_Match03:				;AN000;
 31203                                  	;test	ax,8000h
 31204 00004D77 A90080                  	test	ax,$P_Num_Val		;AN000; Numeric value
 31205 00004D7A 7412                    	jz	short $P_Match04	;AN000;
 31206 00004D7C 2EC706[6599]0000        	mov	word [cs:$P_RC],$P_No_Error
 31207                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 31208 00004D83 E82C01                  	call	$P_Value		;AN000; do process
 31209 00004D86 2E833E[6599]09          	cmp	word [cs:$P_RC],$P_Syntax
 31210                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 31211 00004D8C 7557                    	jne	short $P_Match_Exit	;AN000;
 31212                                  $P_Match04:				;AN000;
 31213                                  	;test	ax,4000h
 31214 00004D8E A90040                  	test	ax,$P_SNum_Val		;AN000; Signed numeric value
 31215 00004D91 7412                    	jz	short $P_Match05	;AN000;
 31216 00004D93 2EC706[6599]0000        	mov	word [cs:$P_RC],$P_No_Error
 31217                                  					;AC034; assume no error
 31218 00004D9A E8F100                  	call	$P_SValue		;AN000; do process
 31219 00004D9D 2E833E[6599]09          	cmp	word [cs:$P_RC],$P_Syntax
 31220                                  					;AC034; if error, examine the next type
 31221 00004DA3 7540                    	jne	short $P_Match_Exit	;AN000;
 31222                                  $P_Match05:				;AN000;
 31223                                  	;test	ax,100h
 31224 00004DA5 A90001                  	test	ax,$P_Drv_Only		;AN000; Drive only
 31225 00004DA8 7415                    	jz	short $P_Match06	;AN000;
 31226 00004DAA 2EC706[6599]0000        	mov	word [cs:$P_RC],$P_No_Error
 31227                                  					;AC034; assume no error
 31228 00004DB1 E86805                  	call	$P_File_Format		;AN000; 1st, call file format
 31229 00004DB4 E8E905                  	call	$P_Drive_Format 	;AN000; check drive format, next
 31230 00004DB7 2E833E[6599]09          	cmp	word [cs:$P_RC],$P_Syntax
 31231                                  					;AC034; if error, examinee the next type
 31232 00004DBD 7526                    	jne	short $P_Match_Exit	;AN000;
 31233                                  $P_Match06:				;AN000;
 31234                                  	;test	ax,200h
 31235 00004DBF A90002                  	test	ax,$P_File_Spc		;AN000; File spec
 31236 00004DC2 7412                    	jz	short $P_Match07	;AN000;
 31237 00004DC4 2EC706[6599]0000        	mov	word [cs:$P_RC],$P_No_Error
 31238                                  					;AC034; assume no error
 31239 00004DCB E84E05                  	call	$P_File_Format		;AN000; do process
 31240 00004DCE 2E833E[6599]09          	cmp	word [cs:$P_RC],$P_Syntax
 31241                                  					;AC034; if error, examine the next type
 31242 00004DD4 750F                    	jne	short $P_Match_Exit	;AN000;
 31243                                  $P_Match07:				;AN000;
 31244                                  $P_Match08:				;AN000;
 31245                                  	;test	ax,2000h
 31246 00004DD6 A90020                  	test	ax,$P_Simple_S		;AN000; Simple string
 31247 00004DD9 740A                    	jz	short $P_Match09	;AN000;
 31248 00004DDB 2EC706[6599]0000        	mov	word [cs:$P_RC],$P_No_Error
 31249                                  					;AC034; assume no error
 31250 00004DE2 E8D601                  	call	$P_Simple_String	;AN000; do process
 31251                                  $P_Match09:				;AN000;
 31252                                  $P_Match_Exit:				;AN000;
 31253 00004DE5 2E833E[3E9A]01          	cmp	word [cs:$P_err_flag],$P_error_filespec
 31254                                  	;cmp	word [cs:$P_err_flag],1 ;AC034; bad filespec ?
 31255 00004DEB 750F                    	jne	short $P_Match2_Exit	;AN033; no, continue
 31256 00004DED 2E833E[6599]00          	cmp	word [cs:$P_RC],$P_No_Error
 31257                                  	;cmp	word [cs:$P_RC],0	;AN033;AC034;; check for other errors ?
 31258 00004DF3 7507                    	jne	short $P_Match2_Exit	;AN033; no, continue
 31259 00004DF5 2EC706[6599]0900        	mov	word [cs:$P_RC],$P_Syntax
 31260                                  	;mov	word [cs:$P_RC],9	;AN033;AC034;; set error flag
 31261                                  $P_Match2_Exit: 			;AN033;
 31262 00004DFC 58                      	pop	ax			;AN000;
 31263 00004DFD C3                      	retn
 31264                                  
 31265                                  ;***********************************************************************
 31266                                  ; $P_Remove_Colon;
 31267                                  ;
 31268                                  ; Function: Remove colon at end
 31269                                  ;
 31270                                  ; Input:    psdata_seg:SI points to string buffer to be examineed
 31271                                  ;
 31272                                  ; Output:   None
 31273                                  ;
 31274                                  ; Use:	$P_Chk_DBCS
 31275                                  ;***********************************************************************
 31276                                  
 31277                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31278                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31279                                  $P_Remove_Colon:
 31280 00004DFE 50                      	push	ax			;AN000;
 31281 00004DFF 56                      	push	si			;AN000;
 31282                                  $P_RCOL_Loop:				;AN000;
 31283 00004E00 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 31284 00004E03 08C0                    	or	al,al			;AN000; end of string ?
 31285 00004E05 740F                    	jz	short $P_RCOL_Exit	;AN000; if yes, just exit
 31286                                  
 31287 00004E07 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; is it colon ?
 31288 00004E09 750E                    	jne	short $P_RCOL00		;AN000;
 31289                                  
 31290                                  	;cmp	byte [cs:si+1],0
 31291 00004E0B 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; if so, next is NULL ?
 31292 00004E10 7507                    	jne	short $P_RCOL00		;AN000; no, then next char
 31293                                  
 31294 00004E12 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; yes, remove colon
 31295                                  	; 31/03/2023
 31296                                  	;jmp	short $P_RCOL_Exit	;AN000; and exit.
 31297                                  $P_RCOL_Exit:
 31298 00004E16 5E                      	pop	si
 31299 00004E17 58                      	pop	ax
 31300 00004E18 C3                      	retn
 31301                                  
 31302                                  $P_RCOL00:				;AN000;
 31303 00004E19 E8A606                  	call	$P_Chk_DBCS		;AN000; if not colon, then check if
 31304 00004E1C 7301                    	jnc	short $P_RCOL01		;AN000; DBCS leading byte.
 31305                                  
 31306 00004E1E 46                      	inc	si			;AN000; if yes, skip trailing byte
 31307                                  $P_RCOL01:				;AN000;
 31308 00004E1F 46                      	inc	si			;AN000; si points to next byte
 31309 00004E20 EBDE                    	jmp	short $P_RCOL_Loop	;AN000; loop until NULL encountered
 31310                                  
 31311                                  	; 31/03/2023
 31312                                  ;$P_RCOL_Exit:				;AN000;
 31313                                  	;pop	si			;AN000;
 31314                                  	;pop	ax			;AN000;
 31315                                  	;retn
 31316                                  
 31317                                  ;***********************************************************************
 31318                                  ; $P_Do_CAPS_String;
 31319                                  ;
 31320                                  ; Function: Perform capitalization along with the file case map table
 31321                                  ;	    or character case map table.
 31322                                  ;
 31323                                  ; Input:    AL = 2 : Use character table
 31324                                  ;	    AL = 4 : Use file table
 31325                                  ;	    psdata_seg:SI points to string buffer to be capitalized
 31326                                  ;
 31327                                  ; Output:   None
 31328                                  ;
 31329                                  ; Use:	$P_Do_CAPS_Char, $P_Chk_DBCS
 31330                                  ;***********************************************************************
 31331                                  
 31332                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31333                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31334                                  $P_Do_CAPS_String:
 31335 00004E22 56                      	push	si			;AN000;
 31336 00004E23 52                      	push	dx			;AN000;
 31337 00004E24 88C2                    	mov	dl,al			;AN000; save info id
 31338                                  $P_DCS_Loop:				;AN000;
 31339 00004E26 2E8A04                  	mov	al,[cs:si]		;AN000; load character and
 31340 00004E29 E89606                  	call	$P_Chk_DBCS		;AN000; check if DBCS leading byte
 31341 00004E2C 720C                    	jc	short $P_DCS00		;AN000; if yes, do not need CAPS
 31342                                  
 31343 00004E2E 08C0                    	or	al,al			;AN000; end of string ?
 31344 00004E30 740C                    	jz	short $P_DCS_Exit	;AN000; then exit.
 31345                                  
 31346 00004E32 E80C00                  	call	$P_Do_CAPS_Char 	;AN000; Here a SBCS char need to be CAPS
 31347 00004E35 2E8804                  	mov	[cs:si],al		;AN000; stored upper case char to buffer
 31348 00004E38 EB01                    	jmp	short $P_DCS01		;AN000; process nexit
 31349                                  $P_DCS00:				;AN000;
 31350 00004E3A 46                      	inc	si			;AN000; skip DBCS leading and trailing byte
 31351                                  $P_DCS01:				;AN000;
 31352 00004E3B 46                      	inc	si			;AN000; si point to next byte
 31353 00004E3C EBE8                    	jmp	short $P_DCS_Loop	;AN000; loop until NULL encountered
 31354                                  $P_DCS_Exit:				;AN000;
 31355 00004E3E 5A                      	pop	dx			;AN000;
 31356 00004E3F 5E                      	pop	si			;AN000;
 31357 00004E40 C3                      	retn
 31358                                  
 31359                                  ;***********************************************************************
 31360                                  ; $P_Do_CAPS_Char;
 31361                                  ;
 31362                                  ; Function: Perform capitalization along with the file case map table
 31363                                  ;	    or character case map table.
 31364                                  ;
 31365                                  ; Input:    DL = 2 : Use character table
 31366                                  ;	    DL = 4 : Use file table
 31367                                  ;	    AL = character to be capitalized
 31368                                  ;
 31369                                  ; Output:   None
 31370                                  ;
 31371                                  ; Use:	INT 21h /w AH=65h
 31372                                  ;***********************************************************************
 31373                                  
 31374                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31375                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31376                                  $P_Do_CAPS_Char:
 31377 00004E41 3C80                    	cmp	al,$P_ASCII80	; 80h	;AN000; need upper case table ?
 31378 00004E43 730B                    	jae	short $P_DCC_Go		;AN000;
 31379                                  
 31380 00004E45 3C61                    	cmp	al,"a"  ; 61h		;AN000; if no,
 31381 00004E47 7244                    	jb	short $P_CAPS_Ret	;AN000;   check if  "a" <= AL <= "z"
 31382                                  
 31383 00004E49 3C7A                    	cmp	al,"z"  ; 7Ah		;AN000;
 31384 00004E4B 7740                    	ja	short $P_CAPS_Ret	;AN000;   if yes, make CAPS
 31385                                  
 31386 00004E4D 24DF                    	and	al,$P_Make_Upper ; 0DFh	;AN000;   else do nothing.
 31387                                  	;jmp	short $P_CAPS_Ret	;AN000;
 31388                                  	; 18/04/2023
 31389 00004E4F C3                      	retn
 31390                                  
 31391                                  $P_DCC_Go:				;AN000;
 31392 00004E50 53                      	push	bx			;AN000;
 31393 00004E51 06                      	push	es			;AN000;
 31394 00004E52 57                      	push	di			;AN000;
 31395                                  	; 18/04/2023
 31396 00004E53 8D3E[309A]              	lea	di,$P_File_CAP_Ptr	;AC034;
 31397 00004E57 80FA04                  	cmp	dl,$P_DOSTBL_File ; 4	;AN000; Use file CAPS table ?
 31398 00004E5A 7404                    	je	short $P_DCC00		;AN000;
 31399                                  	; 27/04/2023
 31400 00004E5C 8D3E[2B9A]              	lea	di,$P_Char_CAP_Ptr	;AC034; or use char CAPS table ?
 31401                                  $P_DCC00:				;AN000;
 31402 00004E60 2E3815                  	cmp	[cs:di],dl		;AN000; already got table address ?
 31403 00004E63 7417                    	je	short $P_DCC01		;AN000; if no,
 31404                                  
 31405                                  ;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
 31406                                  ; the GET COUNTYRY INFO call. This usage of ES is required by the function
 31407                                  ; call, regardless of what base register is currently be defined as PSDATA_SEG.
 31408                                  
 31409 00004E65 50                      	push	ax			;AN000; get CAPS table thru DOS call
 31410 00004E66 51                      	push	cx			;AN000;
 31411 00004E67 52                      	push	dx			;AN000;
 31412 00004E68 0E                      	push	cs			;AC036; pass current base seg into
 31413                                  					;(Note: this used to push CS. BUG...
 31414 00004E69 07                      	pop	es			;AN000;   ES reg, required for
 31415                                  					;get extended country information
 31416                                  	; 31/03/2023
 31417 00004E6A B465                    	mov	ah,$P_DOS_Get_TBL ; 65h	;AN000; get extended CDI
 31418                                  	;mov	ah,65h
 31419 00004E6C 88D0                    	mov	al,dl			;AN000; upper case table
 31420                                  	;mov	bx,-1 ; 0FFFFh
 31421                                  	;mov	cx,5
 31422                                  	;mov	dx,-1
 31423 00004E6E BBFFFF                  	mov	bx,$P_DOSTBL_Def ; -1	;AN000; get active CON
 31424 00004E71 B90500                  	mov	cx,$P_DOSTBL_BL  ; 5 	;AN000; buffer length
 31425 00004E74 BAFFFF                  	mov	dx,$P_DOSTBL_Def ; -1	;AN000; get for default code page
 31426                                  					;DI already set to point to buffer
 31427 00004E77 CD21                    	int	21h			;AN000; es:di point to buffer that
 31428                                  					;now has been filled in with info
 31429 00004E79 5A                      	pop	dx			;AN000;
 31430 00004E7A 59                      	pop	cx			;AN000;
 31431 00004E7B 58                      	pop	ax			;AN000;
 31432                                  
 31433                                  $P_DCC01:				;AN000;
 31434                                  
 31435                                  ;In this next section, ES will be used as the base of the XLAT table, provided
 31436                                  ; by the previous GET COUNTRY INFO DOS call. This usage of ES is made
 31437                                  ; regardless of which base reg is currently the PSDATA_SEG reg.
 31438                                  
 31439 00004E7C 2E8B5D01                	mov	bx,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Off]
 31440                                  	;mov	bx,[cs:di+1]		;AN000; get offset of table
 31441 00004E80 2E8E4503                	mov	es,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Seg]
 31442                                  	;mov	es,[cs:di+3]		;AN000; get segment of table
 31443 00004E84 43                      	inc	bx			;AC035; add '2' to
 31444 00004E85 43                      	inc	bx			;AC035;  BX reg
 31445                                  					;AN000; skip length field
 31446 00004E86 2C80                    	sub	al,$P_ASCII80 ; 80h	;AN000; make char to index
 31447                                  	;xlat	es:[bx] 		;AN000; perform case map
 31448                                  	; 31/03/2023
 31449 00004E88 26D7                    	es	xlat
 31450                                  
 31451 00004E8A 5F                      	pop	di			;AN000;
 31452 00004E8B 07                      	pop	es			;AN000;
 31453 00004E8C 5B                      	pop	bx			;AN000;
 31454                                  $P_CAPS_Ret:				;AN000;
 31455 00004E8D C3                      	retn
 31456                                  
 31457                                  ;***********************************************************************
 31458                                  ; $P_Value / $P_SValue
 31459                                  ;
 31460                                  ; Function:  Make 32bit value from psdata_seg:SI and see value list
 31461                                  ;	     and make result buffer.
 31462                                  ;	     $P_SValue is an entry point for the signed value
 31463                                  ;	     and this will simply call $P_Value after the handling
 31464                                  ;	     of the sign character, "+" or "-"
 31465                                  ;
 31466                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31467                                  ;	     ES:BX -> CONTROL block
 31468                                  ;
 31469                                  ; Output:    None
 31470                                  ;
 31471                                  ; Use:	$P_Fill_Result, $P_Check_OVF
 31472                                  ;
 31473                                  ; Vars: $P_RC(W), $P_Flags(RW)
 31474                                  ;***********************************************************************
 31475                                  
 31476                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31477                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31478                                  $P_SValue:
 31479 00004E8E 50                      	push	ax			;AN000;
 31480                                  	;or	byte [cs:$P_Flags2],80h
 31481 00004E8F 2E800E[7199]80          	or	byte [cs:$P_Flags2],$P_Signed
 31482                                  					;AC034; indicate a signed numeric
 31483                                  	;and	byte [cs:$P_Flags2],0FDh
 31484 00004E95 2E8026[7199]FD          	and	byte [cs:$P_Flags2],0FFh-$P_Neg
 31485                                  					;AC034; assume positive value
 31486 00004E9B 2E8A04                  	mov	al,[cs:si]		;AN000; get sign
 31487 00004E9E 3C2B                    	cmp	al,'+' ; 2Bh
 31488                                  	;cmp	al,$P_Plus ; '+'	;AN000; "+" ?
 31489 00004EA0 740A                    	je	short $P_SVal00		;AN000;
 31490                                  
 31491 00004EA2 3C2D                    	cmp	al,'-' ; 2Dh
 31492                                  	;cmp	al,$P_Minus ; '-'	;AN000; "-" ?
 31493 00004EA4 7507                    	jne	short $P_Sval01		;AN000; else
 31494                                  
 31495 00004EA6 2E800E[7199]02          	or	byte [cs:$P_Flags2],$P_Neg ; 2
 31496                                  					;AC034; set this is negative value
 31497                                  $P_SVal00:				;AN000;
 31498 00004EAC 46                      	inc	si			;AN000; skip sign char
 31499                                  $P_Sval01:				;AN000;
 31500 00004EAD E80200                  	call	$P_Value		;AN000; and process value
 31501 00004EB0 58                      	pop	ax			;AN000;
 31502 00004EB1 C3                      	retn				;AN000;
 31503                                  
 31504                                  ;***********************************************************************
 31505                                  
 31506                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31507                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4955h
 31508                                  
 31509                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31510                                  	; MSDOS 6.2 COMMAND.COM - TRANGROUP:5119h
 31511                                  $P_Value:
 31512 00004EB2 50                      	push	ax			;AN000;
 31513 00004EB3 51                      	push	cx			;AN000;
 31514 00004EB4 52                      	push	dx			;AN000;
 31515 00004EB5 56                      	push	si			;AN000;
 31516 00004EB6 31C9                    	xor	cx,cx			;AN000; cx = higher 16 bits
 31517 00004EB8 31D2                    	xor	dx,dx			;AN000; dx = lower 16 bits
 31518 00004EBA 53                      	push	bx			;AN000; save control pointer
 31519                                  $P_Value_Loop:				;AN000;
 31520 00004EBB 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 31521 00004EBE 08C0                    	or	al,al			;AN000; end of line ?
 31522 00004EC0 7442                    	jz	short $P_Value00	;AN000;
 31523                                  
 31524 00004EC2 E8EB00                  	call	$P_0099 		;AN000; make asc(0..9) to bin(0..9)
 31525 00004EC5 7239                    	jc	short $P_Value_Err0	;AN000;
 31526                                  
 31527 00004EC7 30E4                    	xor	ah,ah			;AN000;
 31528 00004EC9 89C5                    	mov	bp,ax			;AN000; save binary number
 31529 00004ECB D1E2                    	shl	dx,1			;AN000; to have 2*x
 31530 00004ECD D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 31531 00004ECF E8CC00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 31532 00004ED2 722C                    	jc	short $P_Value_Err0	;AN000; then error, exit
 31533                                  
 31534 00004ED4 89D3                    	mov	bx,dx			;AN000; save low(2*x)
 31535 00004ED6 89C8                    	mov	ax,cx			;AN000; save high(2*x)
 31536 00004ED8 D1E2                    	shl	dx,1			;AN000; to have 4*x
 31537 00004EDA D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 31538 00004EDC E8BF00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 31539 00004EDF 721F                    	jc	short $P_Value_Err0	;AN000; then error, exit
 31540                                  
 31541 00004EE1 D1E2                    	shl	dx,1			;AN000; to have 8*x
 31542 00004EE3 D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 31543 00004EE5 E8B600                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 31544 00004EE8 7216                    	jc	short $P_Value_Err0	;AN000; then error, exit
 31545                                  
 31546 00004EEA 01DA                    	add	dx,bx			;AN000; now have 10*x
 31547 00004EEC 11C1                    	adc	cx,ax			;AN000; 32bit ADD
 31548 00004EEE E8AD00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 31549 00004EF1 720D                    	jc	short $P_Value_Err0	;AN000; then error, exit
 31550                                  
 31551 00004EF3 01EA                    	add	dx,bp			;AN000; Add the current one degree decimal
 31552 00004EF5 83D100                  	adc	cx,0			;AN000; if carry, add 1 to high 16bit
 31553 00004EF8 E8A300                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 31554 00004EFB 7203                    	jc	short $P_Value_Err0	;AN000; then error, exit
 31555                                  
 31556 00004EFD 46                      	inc	si			;AN000; update pointer
 31557 00004EFE EBBB                    	jmp	short $P_Value_Loop	;AN000; loop until NULL encountered
 31558                                  
 31559                                  $P_Value_Err0:				;AN000;
 31560 00004F00 5B                      	pop	bx			;AN000;
 31561 00004F01 E98800                  	jmp	$P_Value_Err		;AN000; Bridge
 31562                                  
 31563                                  $P_Value00:				;AN000;
 31564 00004F04 5B                      	pop	bx			;AN000; restore control pointer
 31565 00004F05 2EF606[7199]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2 
 31566                                  					;AC034; here cx,dx = 32bit value
 31567 00004F0B 740A                    	jz	short $P_Value01	;AN000; was it negative ?
 31568                                  
 31569 00004F0D F7D1                    	not	cx			;AN000; +
 31570 00004F0F F7D2                    	not	dx			;AN000; |- Make 2's complement
 31571 00004F11 83C201                  	add	dx,1			;AN000; |
 31572 00004F14 83D100                  	adc	cx,0			;AN000; +
 31573                                  $P_Value01:				;AN000; / nval =0
 31574 00004F17 268B7706                	mov	si,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 31575                                  	;mov	si,[es:bx+6]		;AN000; si points to value list
 31576 00004F1B 268A04                  	mov	al,[es:si]		;AN000; get nval
 31577 00004F1E 3C00                    	cmp	al,$P_nval_None ; 0	;AN000; no value list ?
 31578 00004F20 7505                    	jne	short $P_Value02	;AN000;
 31579                                  
 31580                                  	;mov	al,$P_Number	; 1	;AN000; Set type
 31581                                  	;mov	ah,$P_No_Tag	; 0FFh	;AN000; No ITEM_TAG set
 31582                                  	; 31/03/2023
 31583 00004F22 B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 31584 00004F25 EB6F                    	jmp	short $P_Value_Exit	;AN000;
 31585                                  
 31586                                  $P_Value02:				;AN000; / nval = 1
 31587 00004F27 46                      	inc	si			;AN000;
 31588 00004F28 268A04                  	mov	al,[es:si]		;AN000; al = number of range
 31589 00004F2B 3C00                    	cmp	al,$P_No_nrng	; 0	;AN000; (tm07)
 31590 00004F2D 745D                    	je	short $P_Value03	;AN000; (tm07)
 31591                                  
 31592 00004F2F 46                      	inc	si			;AN000; si points to 1st item_tag
 31593                                  $P_Val02_Loop:				;AN000;
 31594 00004F30 2EF606[7199]80          	test	byte [cs:$P_Flags2],$P_Signed ; 80h
 31595                                  	;test	byte [cs:$P_Flags2],80h	;AC034;
 31596 00004F36 751E                    	jnz	short $P_Val02_Sign	;AN000;
 31597                                  
 31598 00004F38 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 31599                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 31600 00004F3C 723B                    	jb	short $P_Val02_Next	;AN000;
 31601 00004F3E 7706                    	ja	short $P_Val_In		;AN000;
 31602                                  
 31603 00004F40 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 31604                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 31605 00004F44 7233                    	jb	short $P_Val02_Next	;AN000;
 31606                                  
 31607                                  $P_Val_In:				;AN000;
 31608 00004F46 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 31609                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH (tm01)
 31610 00004F4A 772D                    	ja	short $P_Val02_Next	;AN000;
 31611 00004F4C 7224                    	jb	short $P_Val_Found	;AN000;
 31612                                  
 31613 00004F4E 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 31614                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 31615 00004F52 7725                    	ja	short $P_Val02_Next	;AN000;
 31616                                  
 31617 00004F54 EB1C                    	jmp	short $P_Val_Found	;AN000;
 31618                                  
 31619                                  $P_Val02_Sign:				;AN000;
 31620 00004F56 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 31621                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 31622 00004F5A 7C1D                    	jl	short $P_Val02_Next	;AN000;
 31623 00004F5C 7F06                    	jg	short $P_SVal_In	;AN000;
 31624                                  
 31625 00004F5E 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 31626                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 31627 00004F62 7C15                    	jl	short $P_Val02_Next	;AN000;
 31628                                  
 31629                                  $P_SVal_In:				;AN000;
 31630 00004F64 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 31631                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH
 31632 00004F68 7F0F                    	jg	short $P_Val02_Next	;AN000;
 31633 00004F6A 7C06                    	jl	short $P_Val_Found	;AN000;
 31634                                  
 31635 00004F6C 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 31636                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 31637 00004F70 7F07                    	jg	short $P_Val02_Next	;AN000;
 31638                                  
 31639                                  	;jmp	short $P_Val_Found	;AN000;
 31640                                  	; 27/04/2023
 31641                                  $P_Val_Found:				;AN000;
 31642 00004F72 B001                    	mov	al,$P_Number ; 1	;AN000;
 31643 00004F74 268A24                  	mov	ah,[es:si]		;AN000; found ITEM_TAG set
 31644 00004F77 EB1D                    	jmp	short $P_Value_Exit	;AN000;
 31645                                  
 31646                                  $P_Val02_Next:				;AN000;
 31647 00004F79 83C609                  	add	si,$P_Len_Range ; 9 	;AN000;
 31648 00004F7C FEC8                    	dec	al			;AN000; loop nrng times in AL
 31649 00004F7E 75B0                    	jnz	short $P_Val02_Loop	;AN000;
 31650                                  					; / Not found
 31651 00004F80 2EC706[6599]0600        	mov	word [cs:$P_RC],$P_Out_Of_Range
 31652                                  	;mov	word [cs:$P_RC],6	;AC034;
 31653                                  	
 31654                                  	;mov	al,$P_Number ; 1	;AN000;
 31655                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 31656                                  	; 31/03/2023
 31657 00004F87 B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 31658 00004F8A EB0A                    	jmp	short $P_Value_Exit	;AN000;
 31659                                  
 31660                                  	; 27/04/2023
 31661                                  ;$P_Val_Found:				;AN000;
 31662                                  	;mov	al,$P_Number ; 1	;AN000;
 31663                                  	;mov	ah,[es:si]		;AN000; found ITEM_TAG set
 31664                                  	;jmp	short $P_Value_Exit	;AN000;
 31665                                  
 31666                                  $P_Value03:				;AN000; / nval = 2
 31667                                  $P_Value04:				;AN000; / nval = 3 or else
 31668                                  $P_Value_Err:				;AN000;
 31669 00004F8C 2EC706[6599]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 31670                                  					;AC034;
 31671                                  	;mov	al,$P_String ; 3	;AN000; Set type
 31672                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 31673                                  	; 31/03/2023
 31674 00004F93 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31675                                  $P_Value_Exit:				;AN000;
 31676 00004F96 E809FD                  	call	$P_Fill_Result		;AN000;
 31677 00004F99 5E                      	pop	si			;AN000;
 31678 00004F9A 5A                      	pop	dx			;AN000;
 31679 00004F9B 59                      	pop	cx			;AN000;
 31680 00004F9C 58                      	pop	ax			;AN000;
 31681 00004F9D C3                      	retn				;AN000;
 31682                                  
 31683                                  ;***********************************************************************
 31684                                  ; $P_Check_OVF
 31685                                  ;
 31686                                  ; Function:  Check if overflow is occurred with consideration of
 31687                                  ;	     signed or un-signed numeric value
 31688                                  ;
 31689                                  ; Input:     Flag register
 31690                                  ;
 31691                                  ; Output:    CY = 1  :	Overflow
 31692                                  ;
 31693                                  ; Vars:     $P_Flags(R)
 31694                                  ;***********************************************************************
 31695                                  
 31696                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31697                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31698                                  $P_Check_OVF:
 31699 00004F9E 9C                      	pushf				;AN000;
 31700 00004F9F 2EF606[7199]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2
 31701                                  					;AC034; is it negative value ?
 31702 00004FA5 7502                    	jnz	short $P_COVF		;AN000; if no, check overflow
 31703 00004FA7 9D                      	popf				;AN000; by the CY bit
 31704 00004FA8 C3                      	retn				;AN000;
 31705                                  $P_COVF:				;AN000;
 31706 00004FA9 9D                      	popf				;AN000; else,
 31707 00004FAA 7002                    	jo	short $P_COVF00		;AN000; check overflow by the OF
 31708 00004FAC F8                      	clc				;AN000; indicate it with CY bit
 31709 00004FAD C3                      	retn				;AN000; CY=0 means no overflow
 31710                                  $P_0099Err:	; 31/03/2023
 31711                                  $P_COVF00:				;AN000;
 31712 00004FAE F9                      	stc				;AN000; and CY=1 means overflow
 31713                                  $P_0099Err2:	; 31/03/2023
 31714 00004FAF C3                      	retn				;AN000;
 31715                                  
 31716                                  ;***********************************************************************
 31717                                  ; $P_0099;
 31718                                  ;
 31719                                  ; Function:  Make ASCII 0-9 to Binary 0-9
 31720                                  ;
 31721                                  ; Input:     AL = character code
 31722                                  ;
 31723                                  ; Output:    CY = 1 : AL is not number
 31724                                  ;	     CY = 0 : AL contains binary value
 31725                                  ;***********************************************************************
 31726                                  
 31727                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31728                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31729                                  $P_0099:
 31730 00004FB0 3C30                    	cmp	al,"0"                  ;AN000;
 31731                                  	;jb	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 31732                                  	; 31/03/2023
 31733 00004FB2 72FB                    	jb	short $P_0099Err2
 31734                                  
 31735 00004FB4 3C39                    	cmp	al,"9"                  ;AN000;
 31736 00004FB6 77F6                    	ja	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 31737                                  
 31738 00004FB8 2C30                    	sub	al,"0"                  ;AN000; make char -> bin
 31739                                  	; 31/03/2023
 31740                                  	;clc				;AN000; indicate no error
 31741 00004FBA C3                      	retn				;AN000;
 31742                                  	 ;31/03/2023
 31743                                  ;$P_0099Err:				;AN000;
 31744                                  ;	stc				;AN000; indicate error
 31745                                  ;	retn				;AN000;
 31746                                  
 31747                                  ;***********************************************************************
 31748                                  ; $P_Simple_String
 31749                                  ;
 31750                                  ; Function:  See value list for the simple string
 31751                                  ;	     and make result buffer.
 31752                                  ;
 31753                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31754                                  ;	     ES:BX -> CONTROL block
 31755                                  ;
 31756                                  ; Output:    None
 31757                                  ;
 31758                                  ; Use:	$P_Fill_Result, $P_String_Comp
 31759                                  ;
 31760                                  ; Vars: $P_RC(W)
 31761                                  ;***********************************************************************
 31762                                  
 31763                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31764                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31765                                  $P_Simple_String:
 31766 00004FBB 50                      	push	ax			;AN000;
 31767 00004FBC 53                      	push	bx			;AN000;
 31768 00004FBD 52                      	push	dx			;AN000;
 31769 00004FBE 57                      	push	di			;AN000;
 31770 00004FBF 268B7F06                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 31771                                  	;mov	di,[es:bx+6]		;AN000; di points to value list
 31772 00004FC3 268A05                  	mov	al,[es:di]		;AN000; get nval
 31773 00004FC6 08C0                    	or	al,al			;AN000; no value list ?
 31774 00004FC8 7502                    	jnz	short $P_Sim00		;AN000; then
 31775                                  	; 31/03/2023
 31776                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 31777 00004FCA EB48                    	jmp	short $P_Sim_Exit	;AN000; and set result buffer
 31778                                  $P_Sim00:				;AN000;
 31779 00004FCC 3C03                    	cmp	al,$P_nval_String ; 3	;AN000; String choice list provided ?
 31780 00004FCE 753D                    	jne	short $P_Sim01		;AN000; if no, syntax error
 31781                                  
 31782 00004FD0 47                      	inc	di			;AN000;
 31783 00004FD1 268A05                  	mov	al,[es:di]		;AN000; al = nrng
 31784 00004FD4 B409                    	mov	ah,$P_Len_Range ; 9	;AN000;
 31785 00004FD6 F6E4                    	mul	ah			;AN000;  Skip nrng field
 31786 00004FD8 40                      	inc	ax			;AN000; ax = (nrng*9)+1
 31787 00004FD9 01C7                    	add	di,ax			;AN000; di points to nnval
 31788 00004FDB 268A05                  	mov	al,[es:di]		;AN000; get nnval
 31789 00004FDE B405                    	mov	ah,$P_Len_Value ; 5	;AN000;
 31790 00004FE0 F6E4                    	mul	ah			;AN000; Skip nnval field
 31791 00004FE2 40                      	inc	ax			;AN000; ax = (nnval*5)+1
 31792 00004FE3 01C7                    	add	di,ax			;AN000; di points to nstrval
 31793 00004FE5 268A05                  	mov	al,[es:di]		;AN000; get nstrval
 31794 00004FE8 47                      	inc	di			;AC035; add '2' to
 31795 00004FE9 47                      	inc	di			;AC035;  DI reg
 31796                                  					;AN000; di points to 1st string in list
 31797                                  $P_Sim_Loop:				;AN000;
 31798 00004FEA 268B2D                  	mov	bp,[es:di]		;AN000; get string pointer
 31799 00004FED E82F00                  	call	$P_String_Comp		;AN000; compare it with operand
 31800 00004FF0 7310                    	jnc	short $P_Sim_Found	;AN000; found on list ?
 31801                                  
 31802 00004FF2 83C703                  	add	di,$P_Len_String ; 3	;AN000; if no, point to next choice
 31803 00004FF5 FEC8                    	dec	al			;AN000; loop nstval times in AL
 31804 00004FF7 75F1                    	jnz	short $P_Sim_Loop	;AN000;
 31805                                  					;AN000; / Not found
 31806 00004FF9 2EC706[6599]0800        	mov	word [cs:$P_RC],$P_Not_In_Str
 31807                                  	;mov	[cs:$P_RC],8		;AC034;
 31808                                  	; 31/03/2023
 31809                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 31810 00005000 EB12                    	jmp	short $P_Sim_Exit	;AN000;
 31811                                  $P_Sim_Found:				;AN000;
 31812 00005002 268A65FF                	mov	ah,[es:di-1]		;AN000; set item_tag
 31813 00005006 B002                    	mov	al,$P_List_Idx	; 2	;AN000;
 31814 00005008 268B15                  	mov	dx,[es:di]		;AN000; get address of STRING
 31815 0000500B EB0A                    	jmp	short $P_Sim_Exit0	;AN000;
 31816                                  $P_Sim01:				;AN000;
 31817 0000500D 2EC706[6599]0900        	mov	word [cs:$P_RC],$P_Syntax
 31818                                  	;mov	word [cs:$P_RC],9	;AC034;
 31819                                  $P_Sim_Exit:
 31820                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 31821                                  ;$P_Sim_Exit:				;AN000;
 31822                                  	;mov	al,$P_String ; 3	;AN000; Set type
 31823                                  	; 31/03/2023
 31824 00005014 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31825                                  $P_Sim_Exit0:				;AN000;
 31826 00005017 E888FC                  	call	$P_Fill_Result		;AN000;
 31827 0000501A 5F                      	pop	di			;AN000;
 31828 0000501B 5A                      	pop	dx			;AN000;
 31829 0000501C 5B                      	pop	bx			;AN000;
 31830 0000501D 58                      	pop	ax			;AN000;
 31831 0000501E C3                      	retn				;AN000;
 31832                                  
 31833                                  ;***********************************************************************
 31834                                  ; $P_String_Comp:
 31835                                  ;
 31836                                  ; Function:  Compare two string
 31837                                  ;
 31838                                  ; Input:     psdata_seg:SI -> 1st string
 31839                                  ;	     ES:BP -> 2nd string  (Must be upper case)
 31840                                  ;	     ES:BX -> CONTROL block
 31841                                  ;
 31842                                  ; Output:    CY = 1 if not match
 31843                                  ;
 31844                                  ; Use:	$P_Chk_DBCS, $P_Do_CAPS_Char
 31845                                  ;
 31846                                  ; Vars: $P_KEYor_SW_Ptr(W), $P_Flags(R). $P_KEYorSW_Ptr
 31847                                  ;***********************************************************************
 31848                                  
 31849                                  	; 01/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31850                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31851                                  $P_String_Comp:
 31852 0000501F 50                      	push	ax			;AN000;
 31853 00005020 55                      	push	bp			;AN000;
 31854 00005021 52                      	push	dx			;AN000;
 31855 00005022 56                      	push	si			;AN000;
 31856 00005023 B202                    	mov	dl,$P_DOSTBL_Char ; 2	;AN000; use character case map table
 31857                                  $P_SCOM_Loop:				;AN000;
 31858 00005025 2E8A04                  	mov	al,[cs:si]		;AN000; get command character
 31859 00005028 E89704                  	call	$P_Chk_DBCS		;AN000; DBCS ?
 31860 0000502B 723C                    	jc	short $P_SCOM00		;AN000; yes,DBCS
 31861                                  
 31862 0000502D E811FE                  	call	$P_Do_CAPS_Char 	;AN000; else, upper case map before comparison
 31863                                  	
 31864 00005030 2EF606[7199]08          	test	byte [cs:$P_Flags2],$P_Key_Cmp ; 8
 31865                                  					;AC034; keyword search ?
 31866 00005036 740D                    	jz	short $P_SCOM04		;AN000;
 31867                                  
 31868                                  	;cmp	al,'=' ; 3Dh
 31869 00005038 3C3D                    	cmp	al,$P_Keyword  ;'='	;AN000; "=" is delimiter
 31870 0000503A 751F                    	jne	short $P_SCOM03		;AN000;IF "=" on command line AND  (bp+1=> char after the "=" in synonym list)
 31871                                  
 31872 0000503C 26807E0100              	cmp	byte [es:bp+1],$P_NULL	;AN021;   at end of keyword string in the control block THEN
 31873 00005041 7562                    	jne	short $P_SCOM_Differ	;AN021;
 31874                                  
 31875 00005043 EB13                    	jmp	short $P_SCOM05 	;AN000;   keyword found in synonym list
 31876                                  
 31877                                  $P_SCOM04:				;AN000;
 31878 00005045 2EF606[7199]10          	test	byte [cs:$P_Flags2],$P_SW_Cmp ; 10h 
 31879                                  					;AC034; switch search ?
 31880 0000504B 740E                    	jz	short $P_SCOM03		;AN000;
 31881                                  
 31882 0000504D 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; ":" is delimiter, at end of switch on command line
 31883 0000504F 750A                    	jne	short $P_SCOM03		;AN000; continue compares
 31884                                  
 31885 00005051 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN021; IF at end of switch on command AND
 31886 00005056 754D                    	jne	short $P_SCOM_Differ	;AN021;   at end of switch string in the control block THEN
 31887                                  
 31888                                  $P_SCOM05:				;AN000;   found a match
 31889 00005058 46                      	inc	si			;AN000; si points to just after "=" or ":"
 31890 00005059 EB58                    	jmp	short $P_SCOM_Same	;AN000; exit
 31891                                  
 31892                                  $P_SCOM03:				;AN000;
 31893 0000505B 263A4600                	cmp	al,[es:bp]		;AN000; compare operand w/ a synonym
 31894 0000505F 751D                    	jne	short $P_SCOM_Differ0 	;AN000; if different, check ignore colon option
 31895                                  
 31896 00005061 08C0                    	or	al,al			;AN000; end of line
 31897 00005063 744E                    	jz	short $P_SCOM_Same	;AN000; if so, exit
 31898                                  
 31899 00005065 46                      	inc	si			;AN000; update operand pointer
 31900 00005066 45                      	inc	bp			;AN000;    and synonym pointer
 31901 00005067 EB13                    	jmp	short $P_SCOM01 	;AN000; loop until NULL or "=" or ":" found in case
 31902                                  
 31903                                  $P_SCOM00:				;AN000; Here al is DBCS leading byte
 31904 00005069 263A4600                	cmp	al,[es:bp]		;AN000; compare leading byte
 31905 0000506D 7536                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different
 31906                                  
 31907 0000506F 46                      	inc	si			;AN000; else, load next byte
 31908 00005070 2E8A04                  	mov	al,[cs:si]		;AN000; and
 31909 00005073 45                      	inc	bp			;AN000;
 31910 00005074 263A4600                	cmp	al,[es:bp]		;AN000; compare 2nd byte
 31911 00005078 752B                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different, too
 31912                                  
 31913 0000507A 46                      	inc	si			;AN000; else update operand pointer
 31914 0000507B 45                      	inc	bp			;AN000; 	and synonym pointer
 31915                                  $P_SCOM01:				;AN000;
 31916 0000507C EBA7                    	jmp	short $P_SCOM_Loop	;AN000; loop until NULL or "=" or "/" found in case
 31917                                  
 31918                                  $P_SCOM_Differ0:			;AN000;
 31919 0000507E 2EF606[7199]40          	test	byte [cs:$P_Flags2],$P_SW ; 40h 
 31920                                  	;test	byte [cs:$P_Flags2],40h	;AC034;(tm10)
 31921 00005084 740E                    	jz	short $P_not_applicable	;AN000;(tm10)
 31922                                  
 31923                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary
 31924                                  	;;test	word [es:bx+2],20h	;AN000;(tm10)
 31925                                  	; 03/04/2023
 31926 00005086 26F6470220              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary	
 31927 0000508B 7407                    	jz	short $P_not_applicable	;AN000;(tm10)
 31928                                  
 31929 0000508D 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000;(tm10)
 31930 00005092 741F                    	je	short $P_SCOM_Same	;AN025;(tm10)
 31931                                  
 31932                                  $P_not_applicable:			;AN000;(tm10)
 31933                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31934                                  	;;test	word [es:bx],10h	;AN000; ignore colon option specified ?
 31935                                  	; 03/04/2023
 31936 00005094 26F60710                	test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31937 00005098 740B                    	jz	short $P_SCOM_Differ	;AN000; if no, say different.
 31938                                  
 31939 0000509A 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; End up with ":" and
 31940 0000509C 750A                    	jne	short $P_SCOM02		;AN000;    subseqently
 31941                                  
 31942 0000509E 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN000;      NULL ?
 31943                                  	;jne	short $P_SCOM_Differ	;AN000; if no, say different
 31944                                  	;jmp	short $P_SCOM_Same	;AN000; else, say same
 31945                                  	; 01/04/2023
 31946 000050A3 740E                    	je	short $P_SCOM_Same
 31947                                  $P_SCOM_Differ:
 31948 000050A5 F9                      	stc
 31949 000050A6 EB10                    	jmp	short $P_SCOM_Exit
 31950                                  
 31951                                  $P_SCOM02:				;AN000;
 31952 000050A8 3C00                    	cmp	al,$P_NULL ; 0		;AN000; end up NULL and :
 31953 000050AA 75F9                    	jne	short $P_SCOM_Differ	;AN000;
 31954                                  
 31955                                  	;cmp	byte [es:bp],':'
 31956 000050AC 26807E003A              	cmp	byte [es:bp],$P_Colon	;AN000; if no, say different
 31957                                  	;je	short $p_SCOM_Same	;AN000; else, say same
 31958                                  	; 01/04/2023
 31959 000050B1 75F2                    	jne	short $P_SCOM_Differ
 31960                                  ;$P_SCOM_Differ: 			;AN000;
 31961                                  	;stc				;AN000; indicate not found
 31962                                  	;jmp	short $P_SCOM_Exit	;AN000;
 31963                                  
 31964                                  $P_SCOM_Same:				;AN000;
 31965 000050B3 2E8936[7499]            	mov	[cs:$P_KEYorSW_Ptr],si	;AC034; for later use by keyword or switch
 31966                                  	; 01/04/2023
 31967                                  	;clc
 31968                                  	; cf = 0			;AN000; indicate found
 31969                                  $P_SCOM_Exit:				;AN000;
 31970 000050B8 5E                      	pop	si			;AN000;
 31971 000050B9 5A                      	pop	dx			;AN000;
 31972 000050BA 5D                      	pop	bp			;AN000;
 31973 000050BB 58                      	pop	ax			;AN000;
 31974 000050BC C3                      	retn				;AN000;
 31975                                  
 31976                                  ;***********************************************************************
 31977                                  ; $P_Date_Format
 31978                                  ;
 31979                                  ; Function:  Convert a date string to DOS date format for int 21h
 31980                                  ;	     with format validation.
 31981                                  ;
 31982                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31983                                  ;	     ES:BX -> CONTROL block
 31984                                  ;
 31985                                  ; Output:    None
 31986                                  ;
 31987                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum
 31988                                  ;
 31989                                  ; Vars: $P_RC(W), $P_1st_Val(RW), $P_2nd_Val(RW), $P_3rd_Val(RW)
 31990                                  ;***********************************************************************
 31991                                  
 31992                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31993                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31994                                  $P_Date_Format:
 31995 000050BD 50                      	push	ax			;AN000;
 31996 000050BE 51                      	push	cx			;AN000;
 31997 000050BF 52                      	push	dx			;AN000;
 31998 000050C0 56                      	push	si			;AN000;
 31999 000050C1 53                      	push	bx			;AN000;
 32000 000050C2 56                      	push	si			;AN000;
 32001 000050C3 E89F00                  	call	$P_Set_CDI		;AN000; set country dependent information before process
 32002                                  	; 03/04/2023
 32003                                  	;pop	si			;AN000;
 32004                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 32005                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 32006                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 32007 000050C6 31F6                    	xor	si,si
 32008 000050C8 2E8936[239A]            	mov	[cs:$P_1st_Val],si ; 0	;AC034; set initial value
 32009 000050CD 2E8936[259A]            	mov	[cs:$P_2nd_Val],si ; 0	;AC034; set initial value
 32010                                  	;mov	[cs:$P_3rd_Val],si ; 0	;AC034; set initial value
 32011 000050D2 5E                      	pop	si
 32012 000050D3 E8A900                  	call	$P_Get_DecNum		;AN000; get 1st number
 32013 000050D6 7218                    	jc	short $P_DateF_Err0	;AN000;-----------------------+
 32014 000050D8 2EA3[239A]              	mov	[cs:$P_1st_Val],ax	;AC034;			      |
 32015 000050DC 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 32016 000050DE 741A                    	jz	short $P_DateF_YMD	;AN000; 		      |
 32017 000050E0 E89C00                  	call	$P_Get_DecNum		;AN000; get 2nd number	      |
 32018 000050E3 726D                    	jc	short $P_DateF_Error	;AN000; 		      |
 32019 000050E5 2EA3[259A]              	mov	[cs:$P_2nd_Val],ax	;AC034;			      |
 32020 000050E9 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 32021 000050EB 740D                    	jz	short $P_DateF_YMD	;AN000; 		      |
 32022 000050ED E88F00                  	call	$P_Get_DecNum		;AN000; get 3rd number	      |
 32023                                  $P_DateF_Err0:				;AN000; Bridge	  <-----------+
 32024 000050F0 7260                    	jc	short $P_DateF_Error	;AN000;
 32025 000050F2 2EA3[279A]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 32026 000050F6 08DB                    	or	bl,bl			;AN000; end of line ?
 32027 000050F8 7558                    	jnz	short $P_DateF_Error	;AN000;
 32028                                  $P_DateF_YMD:				;AN000;
 32029 000050FA 2E8B1E[019A]            	mov	bx,[cs:$P_Country_Info+$P_CDI.$P_CDI_DateF]
 32030                                  	;mov	bx,[cs:$P_Country_Info]	;AC034; get date format
 32031 000050FF 83FB02                  	cmp	bx,$P_Date_YMD ; 2	;AN000;
 32032 00005102 7422                    	je	short $P_DateF00	;AN000;
 32033 00005104 2EA1[239A]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 32034 00005108 08E4                    	or	ah,ah			;AN000;
 32035 0000510A 7546                    	jnz	short $P_DateF_Error	;AN000;
 32036 0000510C 88C1                    	mov	cl,al			;AN000; set month
 32037 0000510E 2EA1[259A]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 32038 00005112 08E4                    	or	ah,ah			;AN000; if overflow, error.
 32039 00005114 753C                    	jnz	short $P_DateF_Error	;AN000;
 32040 00005116 88C5                    	mov	ch,al			;AN000; set date
 32041 00005118 2E8B16[279A]            	mov	dx,[cs:$P_3rd_Val]	;AC034; set year
 32042 0000511D 83FB01                  	cmp	bx,$P_Date_DMY ; 1	;AN000; from here format = MDY
 32043 00005120 7502                    	jne	short $P_DateF01	;AN000; if it is DMY
 32044 00005122 86E9                    	xchg	ch,cl			;AN000;  then swap M <-> D
 32045                                  $P_DateF01:				;AN000;
 32046 00005124 EB19                    	jmp	short $P_DateF02	;AN000;
 32047                                  $P_DateF00:				;AN000; / here format = YMD
 32048 00005126 2E8B16[239A]            	mov	dx,[cs:$P_1st_Val]	;AC034; set year
 32049 0000512B 2EA1[259A]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 32050 0000512F 08E4                    	or	ah,ah			;AN000; if overflow, error
 32051 00005131 751F                    	jnz	short $P_DateF_Error	;AN000;
 32052                                  
 32053 00005133 88C1                    	mov	cl,al			;AN000; set month
 32054 00005135 2EA1[279A]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 32055 00005139 08E4                    	or	ah,ah			;AN000; if overflow, error
 32056 0000513B 7515                    	jnz	short $P_DateF_Error	;AN000;
 32057 0000513D 88C5                    	mov	ch,al			;AN000; set date
 32058                                  $P_DateF02:				;AN000;
 32059 0000513F 83FA64                  	cmp	dx,100			;AN000; year is less that 100 ?
 32060 00005142 7304                    	jae	short $P_DateF03	;AN000;
 32061 00005144 81C26C07                	add	dx,1900 		;AN000; set year 19xx
 32062                                  $P_DateF03:				;AN000;
 32063 00005148 5B                      	pop	bx			;AN000; recover CONTROL block
 32064 00005149 5E                      	pop	si			;AN000; recover string pointer
 32065                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 32066                                  	;mov	al,$P_Date_F ; 7	;AN000;   result
 32067                                  	; 03/04/2023
 32068 0000514A B807FF                  	mov	ax,($P_No_Tag<<8)+$P_Date_F
 32069 0000514D E852FB                  	call	$P_Fill_Result		;AN000;        buffer
 32070 00005150 EB0F                    	jmp	short $P_Date_Format_Exit
 32071                                  					;AN000;	to Date
 32072                                  $P_DateF_Error: 			;AN000;
 32073 00005152 5B                      	pop	bx			;AN000; recover CONTROL block
 32074 00005153 5E                      	pop	si			;AN000; recover string pointer
 32075                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 32076                                  	;mov	al,$P_String ; 3	;AN000;   result
 32077                                  	; 03/04/2023
 32078 00005154 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 32079 00005157 E848FB                  	call	$P_Fill_Result		;AN000; 	buffer
 32080                                  					;AN000; to string
 32081 0000515A 2EC706[6599]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 32082                                  					;AC034; indicate syntax error
 32083                                  $P_Date_Format_Exit:			;AN000;
 32084 00005161 5A                      	pop	dx			;AN000;
 32085 00005162 59                      	pop	cx			;AN000;
 32086 00005163 58                      	pop	ax			;AN000;
 32087 00005164 C3                      	retn				;AN000;
 32088                                  
 32089                                  ;***********************************************************************
 32090                                  ; $P_Set_CDI:
 32091                                  ;
 32092                                  ; Function: Read CDI from DOS if it has not been read yet
 32093                                  ;
 32094                                  ; Input:    None
 32095                                  ;
 32096                                  ; Output:   psdata_seg:SI -> CDI
 32097                                  ;
 32098                                  ; Use:	INT 21h w/ AH = 38h
 32099                                  ;***********************************************************************
 32100                                  
 32101                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32102                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32103                                  $P_Set_CDI:
 32104                                  	; 18/04/2023
 32105 00005165 8D36[019A]              	lea	si,$P_Country_Info	;AC034;
 32106                                  	;cmp	word [cs:si+$P_CDI.$P_CDI_DateF],-1 ; $P_NeedToBeRead
 32107 00005169 2E833CFF                	cmp	word [cs:si],-1 ; $P_NeedToBeRead ; 0FFFFh
 32108                                  					;AN000; already read ?
 32109                                  	;je	short $P_Read_CDI	;AN000;
 32110                                  	;jmp	short $P_Set_CDI_Exit	;AN000; then do nothing
 32111                                  	; 03/04/2023
 32112 0000516D 750F                    	jne	short $P_Set_CDI_Exit
 32113                                  $P_Read_CDI:				;AN000; else read CDI thru DOS
 32114 0000516F 1E                      	push	ds			;AN000;
 32115 00005170 52                      	push	dx			;AN000;
 32116 00005171 50                      	push	ax			;AN000;
 32117 00005172 0E                      	push	cs			;AC023;
 32118 00005173 1F                      	pop	ds			;AN000; set segment register
 32119                                  	;mov	ax,3800h
 32120 00005174 B80038                  	mov	ax,$P_DOS_Get_CDI	;AN000; get country information
 32121 00005177 89F2                    	mov	dx,si			;AN000; set offset of CDI in local data area
 32122 00005179 CD21                    	int	21h			;AN000;
 32123 0000517B 58                      	pop	ax			;AN000;
 32124 0000517C 5A                      	pop	dx			;AN000;
 32125 0000517D 1F                      	pop	ds			;AN000;
 32126                                  $P_Set_CDI_Exit:			;AN000;
 32127 0000517E C3                      	retn				;AN000;
 32128                                  
 32129                                  ;***********************************************************************
 32130                                  ; $P_Get_DecNum:
 32131                                  ;
 32132                                  ; Function:  Read a chcrater code from psdata_seg:SI until specified delimiter
 32133                                  ;	     or NULL encountered. And make a decimal number.
 32134                                  ;
 32135                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32136                                  ;
 32137                                  ; Output:    BL = delimiter code or NULL
 32138                                  ;	     AX = Decimal number
 32139                                  ;	     SI advanced to the next number
 32140                                  ;	     CY = 1 : Syntax error, AL = Latest examineed number
 32141                                  ;
 32142                                  ; Use:	$P_0099
 32143                                  ;***********************************************************************
 32144                                  
 32145                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32146                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32147                                  $P_Get_DecNum:
 32148 0000517F 51                      	push	cx			;AN000;
 32149 00005180 52                      	push	dx			;AN000;
 32150 00005181 31C9                    	xor	cx,cx			;AN000; cx will have final value
 32151                                  $P_GetNum_Loop: 			;AN000;
 32152 00005183 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 32153 00005186 08C0                    	or	al,al			;AN000; end of line ?
 32154 00005188 7438                    	jz	short $P_GetNum00	;AN000; if yes, exit
 32155 0000518A 2E803E[009A]00          	cmp	byte [cs:$P_Got_Time],0 ;AC034; is this numeric in a time field? ;AC023
 32156 00005190 740B                    	je	short $P_Do_Date_Delims	;AN000; no, go check out Date delimiters ;AC023
 32157                                  
 32158                                  ; Determine which delimiter(s) to check for. Colon & period  or period only
 32159                                  	;cmp	bl,$P_colon_period
 32160 00005192 80FB01                  	cmp	bl,1 ; $P_colon_period	;AN032; ;Time
 32161 00005195 750E                    	jne	short $P_Do_Time_Delim1	;AN032; ;only check for period
 32162                                  
 32163 00005197 3C3A                    	cmp	al,$P_Colon ; ':'	;AN032; ;Is this a valid delimiter ?
 32164 00005199 742B                    	je	short $P_GetNum01	;AN032; ;yes, exit
 32165                                  
 32166                                  	; 03/04/2023
 32167 0000519B EB08                    	jmp	short $P_Do_Time_Delim1
 32168                                  ;$P_Do_Time_Delim1:			;AN000;
 32169                                  	;cmp	al,$P_Period ; '.'	;;AC032;;AC023;Is this a valid delimiter ?
 32170                                  	;je	short $P_GetNum01	;AC023; yes, exit
 32171                                  	;
 32172                                  	;jmp	short $P_Neither_Delims ;AN023;
 32173                                  
 32174                                  $P_Do_Date_Delims:			;AN000;
 32175                                  ;Regardless of the date delimiter character specified in the country
 32176                                  ;dependent information, check for the presence of any one of these
 32177                                  ;three field delimiters: "-", "/", or ".".
 32178 0000519D 3C2D                    	cmp	al,$P_Minus ;'-'	;AN020;is this a date delimiter character?
 32179 0000519F 7425                    	je	short $P_GetNum01	;AN020;if yes, exit
 32180                                  
 32181 000051A1 3C2F                    	cmp	al,$P_Slash ; '/'	;AN020;is this a date delimiter character?
 32182 000051A3 7421                    	je	short $P_GetNum01	;AN020;if yes, exit
 32183                                  
 32184                                  $P_Do_Time_Delim1:  ; 03/04/2023
 32185 000051A5 3C2E                    	cmp	al,$P_Period ; '.'	;AN020;is this a date delimiter character?
 32186 000051A7 741D                    	je	short $P_GetNum01	;AN000; if yes, exit
 32187                                  
 32188                                  $P_Neither_Delims:			;AN023;
 32189 000051A9 E804FE                  	call	$P_0099 		;AN000; convert it to binary
 32190 000051AC 721C                    	jc	short $P_GetNum_Exit	;AN000; if error exit
 32191                                  
 32192 000051AE B400                    	mov	ah,0			;AN000;
 32193 000051B0 91                      	xchg	ax,cx			;AN000;
 32194 000051B1 BA0A00                  	mov	dx,10			;AN000;
 32195 000051B4 F7E2                    	mul	dx			;AN000; ax = ax * 10
 32196 000051B6 09D2                    	or	dx,dx			;AN000; overflow
 32197 000051B8 750F                    	jnz	short $P_GetNum02	;AN000; then exit
 32198                                  
 32199 000051BA 01C8                    	add	ax,cx			;AN000;
 32200 000051BC 720C                    	jc	short $P_GetNum_Exit	;AN000;
 32201                                  
 32202 000051BE 91                      	xchg	ax,cx			;AN000;
 32203 000051BF 46                      	inc	si			;AN000;
 32204 000051C0 EBC1                    	jmp	short $P_GetNum_Loop	;AN000;
 32205                                  
 32206                                  $P_GetNum00:				;AN000;
 32207 000051C2 88C3                    	mov	bl,al			;AN000; set bl to NULL
 32208                                  	;03/04/2023
 32209                                  	; cf=0
 32210                                  	;clc				;AN000; indicate no error
 32211 000051C4 EB04                    	jmp	short $P_GetNum_Exit	;AN000;
 32212                                  
 32213                                  $P_GetNum01:				;AN000;
 32214 000051C6 46                      	inc	si			;AN000; si points to next number
 32215                                  	;03/04/2023
 32216                                  	; cf=0
 32217                                  	;clc				;AN000; indicate no error
 32218 000051C7 EB01                    	jmp	short $P_GetNum_Exit	;AN000;
 32219                                  
 32220                                  $P_GetNum02:				;AN000;
 32221 000051C9 F9                      	stc				;AN000; indicate error
 32222                                  $P_GetNum_Exit: 			;AN000;
 32223 000051CA 89C8                    	mov	ax,cx			;AN000;return value
 32224 000051CC 5A                      	pop	dx			;AN000;
 32225 000051CD 59                      	pop	cx			;AN000;
 32226 000051CE C3                      	retn				;AN000;
 32227                                  
 32228                                  ;***********************************************************************
 32229                                  ; $P_Time_Format
 32230                                  ;
 32231                                  ; Function:  Convert a time string to DOS time format for int 21h
 32232                                  ;	     with format validation.
 32233                                  ;
 32234                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32235                                  ;	     ES:BX -> CONTROL block
 32236                                  ;
 32237                                  ; Output:    None
 32238                                  ;
 32239                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum, $P_Time_2412
 32240                                  ;
 32241                                  ; Vars: $P_RC(W), $P_Flags(R), $P_1st_Val(RW), $P_2nd_Val(RW)
 32242                                  ;	$P_3rd_Val(RW), $P_4th_Val(RW)
 32243                                  ;***********************************************************************
 32244                                  
 32245                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32246                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32247                                  $P_Time_Format:				;AN000;
 32248 000051CF 50                      	push	ax			;AN000;
 32249 000051D0 51                      	push	cx			;AN000;
 32250 000051D1 52                      	push	dx			;AN000;
 32251 000051D2 56                      	push	si			;AN000;
 32252 000051D3 53                      	push	bx			;AN000;
 32253 000051D4 56                      	push	si			;AN000;
 32254 000051D5 E88DFF                  	call	$P_Set_CDI		;AN000; Set country independent
 32255                                  					; information before process
 32256                                  	;test	byte [cs:si+11h], 1
 32257 000051D8 2EF6441001              	test	byte [cs:si+$P_CDI.$P_CDI_TimeF],1 
 32258                                  					;AN000; 24 hour system
 32259 000051DD 5E                      	pop	si			;AN000;
 32260 000051DE 7503                    	jnz	short $P_TimeF00	;AN000; if no, means 12 hour system
 32261 000051E0 E8F800                  	call	$P_Time_2412		;AN000; this routine handle "am" "pm"
 32262                                  $P_TimeF00:				;AN000;
 32263                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 32264                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 32265                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 32266                                  	;mov	word [cs:$P_4th_Val],0	;AC034; set initial value
 32267                                  	;mov	byte [cs:$P_Got_Time],1	;AN023;AC034;; use time delimiter
 32268                                  	; 03/04/2023
 32269 000051E3 31DB                    	xor	bx,bx
 32270 000051E5 2E891E[239A]            	mov	[cs:$P_1st_Val],bx ; 0
 32271 000051EA 2E891E[259A]            	mov	[cs:$P_2nd_Val],bx ; 0
 32272 000051EF 2E891E[279A]            	mov	[cs:$P_3rd_Val],bx ; 0
 32273 000051F4 2E891E[299A]            	mov	[cs:$P_4th_Val],bx ; 0
 32274                                  	;inc	bl
 32275                                  	;mov	[cs:$P_Got_Time],bl ; 1
 32276                                  
 32277                                  	;mov	bl,$P_colon_period
 32278                                  	;mov	bl,1 ; $P_colon_period	;AN032; flag, indicates use of
 32279                                  					; delimiters between hours,
 32280                                  					;  minutes,seconds
 32281                                  	; 03/04/2023 - Retro DOS v4.0 COMMAND.COM
 32282 000051F9 FEC3                    	inc	bl ; bl = 1
 32283 000051FB 2E881E[009A]            	mov	[cs:$P_Got_Time],bl ; 1
 32284                                  	;
 32285 00005200 E87CFF                  	call	$P_Get_DecNum		;AN000; get 1st number
 32286 00005203 725D                    	jc	short $P_TimeF_Err0	;AN000;
 32287 00005205 2EA3[239A]              	mov	[cs:$P_1st_Val],ax	;AC034;
 32288 00005209 08DB                    	or	bl,bl			;AN000; end of line ?
 32289 0000520B 745F                    	jz	short $P_TimeF_Rlt	;AN000;
 32290 0000520D E86FFF                  	call	$P_Get_DecNum		;AN000; get 2nd number
 32291 00005210 7250                    	jc	short $P_TimeF_Err0	;AC038; if OK
 32292 00005212 2EA3[259A]              	mov	[cs:$P_2nd_Val],ax	;AC034;
 32293 00005216 08DB                    	or	bl,bl			;AN000; end of line ?
 32294 00005218 7452                    	jz	short $P_TimeF_Rlt	;AN000;
 32295 0000521A B302                    	mov	bl,2 ; $P_period_only	;AN032; flag, which to decimal separator
 32296 0000521C E860FF                  	call	$P_Get_DecNum		;AN000; get 3rd number
 32297 0000521F 7241                    	jc	short $P_TimeF_Err0	;AC039; if problem, bridge to error
 32298 00005221 2EA3[279A]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 32299 00005225 08DB                    	or	bl,bl			;AN000; end of line ?
 32300 00005227 7536                    	jnz	short $P_Time_4		;AN039; NOT END OF LINE,
 32301                                  					;AN039;   GO TO 4TH NUMBER
 32302                                  	;test	byte [cs:$P_Flags1],$P_Time_Again ; 2
 32303 00005229 2EF606[7099]02          	test	byte [cs:$P_Flags1],2 	;AN039; HAS TIME PARSE
 32304                                  					;AN039;    BEEN REPEATED?
 32305 0000522F 753B                    	jnz	short $P_TimeF_Rlt	;AN039; yes, this is really
 32306                                  					;AN039;   the end of line
 32307                                  					;AN039; no, time has not been repeated
 32308 00005231 2E8B36[6799]            	mov	si,[cs:$P_SI_Save]	;AN039; get where parser quit
 32309                                  					;AN039;   in command line
 32310 00005236 807CFF2C                	cmp	byte [si-1],$P_Comma ; ','
 32311                                  					;AN039; look at delimiter
 32312                                  					;AN039;   from command line
 32313 0000523A 7530                    	jne	short $P_TimeF_Rlt	;AN039; was not a comma, this is
 32314                                  					;AN039;  really end of line
 32315                                  					;AN039; is comma before hundredths,
 32316                                  					;AN039;   redo TIME
 32317 0000523C C644FF2E                	mov	byte [si-1],$P_Period ; '.' 
 32318                                  					;AN039; change that ambiguous
 32319                                  					;AN039;    comma to a decimal point
 32320                                  					;AN039;     parse can understand
 32321 00005240 2EC706[7099]0000        	mov	word [cs:$P_Flags],0	;AN039; Clear all internal flags
 32322                                  	;or	byte [cs:$P_Flags1],$P_Time_Again
 32323 00005247 2E800E[7099]02          	or	byte [cs:$P_Flags1],2	;AN039; indicate TIME
 32324                                  					;AN039; is being repeated
 32325 0000524D 2E8B0E[FA99]            	mov	cx,[cs:$P_ORIG_ORD]	;AN039; ORIGINAL ORDINAL FROM CX
 32326 00005252 2E8B26[FC99]            	mov	sp,[cs:$P_ORIG_STACK]	;AN039; ORIGINAL VALUE
 32327                                  					;AN039;   OF STACK FROM SP
 32328 00005257 2E8B36[FE99]            	mov	si,[cs:$P_ORIG_SI]	;AN039; ORIGINAL START
 32329                                  					;AN039;   PARSE POINTER FROM SI
 32330 0000525C E913F8                  	jmp	$P_Redo_Time		;AN039; go try TIME again
 32331                                  $P_Time_4:				;AN039; READY FOR 4TH (HUNDREDTHS) NUMBER
 32332 0000525F E81DFF                  	call	$P_Get_DecNum		;AN000; get 4th number
 32333                                  $P_TimeF_Err0:				;AN000; Bridge
 32334 00005262 725E                    	jc	short $P_TimeF_Error	;AN000;
 32335                                  	;
 32336 00005264 2EA3[299A]              	mov	[cs:$P_4th_Val],ax	;AC034;
 32337 00005268 08DB                    	or	bl,bl			;AN000; After hundredth, no data allowed
 32338 0000526A 7556                    	jnz	short $P_TimeF_Error	;AN000; if some, then error
 32339                                  $P_TimeF_Rlt:				;AN000;
 32340 0000526C 2EA1[239A]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 32341 00005270 08E4                    	or	ah,ah			;AN000; if overflow then error
 32342 00005272 754E                    	jnz	short $P_TimeF_Err	;AN000;
 32343                                  	;test	byte [cs:$P_Flags1],$P_Time12am ; 1
 32344 00005274 2EF606[7099]01          	test	byte [cs:$P_Flags1],1	;AN038;if "am" specified
 32345 0000527A 7408                    	jz	short $P_Time_notAM	;AN038;skip if no "AM" specified
 32346                                  					;since "AM" was specified,
 32347 0000527C 3C0C                    	cmp	al,12			;AN038: if hour specified as later than noon
 32348 0000527E 7742                    	ja	short $P_TimeF_Err	;AN038; error if "AM" on more than noon
 32349 00005280 7502                    	jne	short $P_Time_notAM	;AN038; for noon exactly,
 32350 00005282 30C0                    	xor	al,al			;AN038; set hour = zero
 32351                                  $P_Time_notAM:				;AN038;
 32352                                  	;test	byte [cs:$P_Flags2],$P_Time12
 32353 00005284 2EF606[7199]04          	test	byte [cs:$P_Flags2],4	;AC034; if 12 hour system and pm is specified
 32354 0000528A 740C                    	jz	short $P_TimeSkip00	;AN000; then
 32355 0000528C 3C0C                    	cmp	al,12			;AN038; if 12:00 o'clock already
 32356 0000528E 7408                    	je	short $P_TimeSkip00	;AN038; it is PM already
 32357 00005290 040C                    	add	al,12			;AN000; add 12 hours to make it afternoon
 32358 00005292 722E                    	jc	short $P_TimeF_Err	;AN000; if overflow then error
 32359 00005294 3C18                    	cmp	al,24			;AN038; after adding 12, now cannot be >24
 32360 00005296 772A                    	ja	short $P_TimeF_Err	;AN038; if too big, error
 32361                                  $P_TimeSkip00:				;AN000;
 32362 00005298 88C2                    	mov	dl,al			;AN000; set hour
 32363 0000529A 2EA1[259A]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 32364 0000529E 08E4                    	or	ah,ah			;AN000; if overflow then error
 32365 000052A0 7520                    	jnz	short $P_TimeF_Err	;AN000;
 32366 000052A2 88C6                    	mov	dh,al			;AN000; set minute
 32367 000052A4 2EA1[279A]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 32368 000052A8 08E4                    	or	ah,ah			;AN000; if overflow then error
 32369 000052AA 7516                    	jnz	short $P_TimeF_Err	;AN000;
 32370 000052AC 88C1                    	mov	cl,al			;AN000; set second
 32371 000052AE 2EA1[299A]              	mov	ax,[cs:$P_4th_Val]	;AC034;
 32372 000052B2 08E4                    	or	ah,ah			;AN000; if overflow then error
 32373 000052B4 750C                    	jnz	short $P_TimeF_Err	;AN000;
 32374 000052B6 88C5                    	mov	ch,al			;AN000; set hundredth
 32375 000052B8 5B                      	pop	bx			;AN000; recover CONTROL block
 32376 000052B9 5E                      	pop	si			;AN000; recover string pointer
 32377                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 32378                                  	;mov	al,$P_Time_F ; 8 	;AN000;   result
 32379                                  	; 03/04/2023
 32380 000052BA B808FF                  	mov	ax,($P_No_Tag<<8)+$P_Time_F
 32381 000052BD E8E2F9                  	call	$P_Fill_Result		;AN000;        buffer
 32382 000052C0 EB0F                    	jmp	short $P_Time_Format_Exit
 32383                                  					;AN000; to time
 32384                                  $P_TimeF_Error: 			;AN000;
 32385                                  $P_TimeF_Err:				;AN000;
 32386 000052C2 5B                      	pop	bx			;AN000; recover CONTROL block
 32387 000052C3 5E                      	pop	si			;AN000; recover string pointer
 32388                                  	;mov	ah,$P_No_Tag		;AN000; set
 32389                                  	;mov	al,$P_String		;AN000;     result
 32390                                  	; 03/04/2023
 32391 000052C4 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 32392 000052C7 E8D8F9                  	call	$P_Fill_Result		;AN000; 	  buffer
 32393                                  					;AN000; to string
 32394 000052CA 2EC706[6599]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9	
 32395                                  					;AC034; return syntax error
 32396                                  $P_Time_Format_Exit:			;AN000;
 32397 000052D1 2EC606[009A]00          	mov	byte [cs:$P_Got_Time],0	;AN023;AC034; finished with this time field
 32398 000052D7 5A                      	pop	dx			;AN000;
 32399 000052D8 59                      	pop	cx			;AN000;
 32400 000052D9 58                      	pop	ax			;AN000;
 32401 000052DA C3                      	retn
 32402                                  
 32403                                  ;***********************************************************************
 32404                                  ; $P_Time_2412:
 32405                                  ;
 32406                                  ; Function:  Remove "a", "p", "am", or "pm" from the end of stinrg
 32407                                  ;
 32408                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32409                                  ;
 32410                                  ; Output:    Set $P_Time12 flag when the string is terminated by "p"
 32411                                  ;	     or "pm"
 32412                                  ;
 32413                                  ; Vars:  $P_Flags(W)
 32414                                  ;***********************************************************************
 32415                                  
 32416                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32417                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32418                                  $P_Time_2412:				;AN000;
 32419 000052DB 50                      	push	ax			;AN000;
 32420 000052DC 56                      	push	si			;AN000;
 32421                                  $P_T12_Loop:				;AN000;
 32422 000052DD 2E8A04                  	mov	al,[cs:si]		;AN000; Move
 32423 000052E0 46                      	inc	si			;AN000;     si
 32424 000052E1 08C0                    	or	al,al			;AN000;       to
 32425 000052E3 75F8                    	jnz	short $P_T12_Loop	;AN000; 	end of string
 32426                                  
 32427 000052E5 2E8A44FE                	mov	al,[cs:si-2]		;AN000; get char just before NULL
 32428                                  	;or	al,20h
 32429 000052E9 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 32430 000052EB 3C70                    	cmp	al,"p"                  ;AN000; only "p" of "pm" ?
 32431 000052ED 7425                    	je	short $P_T1200		;AN000;
 32432                                  
 32433 000052EF 3C61                    	cmp	al,"a"                  ;AN000; only "a" of "am" ?
 32434 000052F1 7413                    	je	short $P_T1201		;AN000;
 32435                                  
 32436 000052F3 3C6D                    	cmp	al,"m"                  ;AN000; "m" of "am" or "pm"
 32437 000052F5 751A                    	jne	short $P_T12_Exit	;AN000;
 32438                                  
 32439 000052F7 4E                      	dec	si			;AN000;
 32440 000052F8 2E8A44FE                	mov	al,[cs:si-2]		;AN000;
 32441                                  	;or	al,20h
 32442 000052FC 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 32443 000052FE 3C70                    	cmp	al,"p"                  ;AN000; "p" of "pm" ?
 32444 00005300 7412                    	je	short $P_T1200		;AN000;
 32445                                  
 32446 00005302 3C61                    	cmp	al,"a"                  ;AN000; "a" of "am" ?
 32447                                  	;je	short $P_T1201		;AN000; go process "a"
 32448                                  	;jmp	short $P_T12_Exit	;AN000; no special chars found
 32449                                  	; 05/04/2023
 32450 00005304 750B                    	jne	short $P_T12_Exit
 32451                                  
 32452                                  ;$P_T1200:				;AN000; "P" found
 32453                                  	;;or	byte [cs:$P_Flags2],$P_Time12
 32454                                  	;or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 32455                                  	;jmp	short $P_Tclr_chr	;AN038; go clear the special char
 32456                                  
 32457                                  $P_T1201:				;AN000; "A" found
 32458                                  	;or	byte [cs:$P_Flags1],$P_Time12AM
 32459 00005306 2E800E[7099]01          	or	byte [cs:$P_Flags1],1	;AN038; flag "AM" found
 32460                                  $P_Tclr_chr:				;AN038;
 32461 0000530C 2EC644FE00              	mov	byte [cs:si-2],$P_NULL	;AN000; null out special char
 32462                                  $P_T12_Exit:				;AN000;
 32463 00005311 5E                      	pop	si			;AN000;
 32464 00005312 58                      	pop	ax			;AN000;
 32465 00005313 C3                      	retn				;AN000;
 32466                                  
 32467                                  	; 05/04/2023
 32468                                  $P_T1200:				;AN000; "P" found
 32469                                  	;or	byte [cs:$P_Flags2],$P_Time12
 32470 00005314 2E800E[7199]04          	or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 32471 0000531A EBF0                    	jmp	short $P_Tclr_chr	;AN038; go clear the special char
 32472                                  
 32473                                  ;***********************************************************************
 32474                                  ; $P_File_Format;
 32475                                  ;
 32476                                  ; Function:  Check if the input string is valid file spec format.
 32477                                  ;	     And set the result buffer.
 32478                                  ;
 32479                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32480                                  ;	     ES:BX -> CONTROL block
 32481                                  ;
 32482                                  ; Output:    None
 32483                                  ;
 32484                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_FileSp_Chk
 32485                                  ;
 32486                                  ; Vars: $P_RC(W), $P_SI_Save(W), $P_Terminator(W), $P_SaveSI_Cmpx(R)
 32487                                  ;	$P_SaveSI_Cmpx(R)
 32488                                  ;***********************************************************************
 32489                                  
 32490                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32491                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4DF0h
 32492                                  
 32493                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32494                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:55B4h
 32495                                  $P_File_Format:
 32496 0000531C 50                      	push	ax			;AN000;
 32497 0000531D 57                      	push	di			;AN000;
 32498 0000531E 56                      	push	si			;AN000;
 32499 0000531F 2E8B3E[7299]            	mov	di,[cs:$P_SaveSI_Cmpx]	;AC034; get user buffer address
 32500 00005324 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 32501 00005327 08C0                    	or	al,al			;AN000; end of line ?
 32502 00005329 7413                    	je	short $P_FileF_Err	;AN000; if yes, error exit
 32503 0000532B E85D00                  	call	$P_FileSp_Chk		;AN000; else, check if file special character
 32504 0000532E 7523                    	jne	short $P_FileF03	;AN000; if yes,
 32505 00005330 2EC606[3E9A]01          	mov	byte [cs:$P_err_flag],$P_error_filespec ; 1
 32506                                  					;AN033;AC034;; set error flag- bad char.
 32507 00005336 5E                      	pop	si			;AN033;
 32508 00005337 2EC60400                	mov	byte [cs:si],$P_NULL	;AN033;
 32509 0000533B 5F                      	pop	di			;AN033;
 32510 0000533C EB3E                    	jmp	short $P_FileF02	;AN033;
 32511                                  $P_FileF_Err:				;AN000;
 32512 0000533E 5E                      	pop	si			;AN000;
 32513 0000533F 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000;
 32514 00005343 5F                      	pop	di			;AN000;
 32515                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 32516                                  	;test	word [es:bx],1		;AN000; is it optional ?
 32517 00005344 26F60701                	test	byte [es:bx],$P_Optional ; 1
 32518 00005348 7532                    	jnz	short $P_FileF02	;AN000;
 32519 0000534A 2EC706[6599]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 32520                                  	;mov	word [cs:$P_RC],2	;AC034; 3/17/87
 32521 00005351 EB29                    	jmp	short $P_FileF02	;AN000;
 32522                                  $P_FileF03:				;AN000;
 32523 00005353 58                      	pop	ax			;AN000; discard save si
 32524 00005354 56                      	push	si			;AN000; save new si
 32525                                  $P_FileF_Loop1: 			;AN000;
 32526 00005355 2E8A04                  	mov	al,[cs:si]		;AN000; load character (not special char)
 32527 00005358 08C0                    	or	al,al			;AN000; end of line ?
 32528 0000535A 741E                    	jz	short $P_FileF_RLT	;AN000;
 32529 0000535C E82C00                  	call	$P_FileSp_Chk		;AN000; File special character ?
 32530 0000535F 740B                    	jz	short $P_FileF00	;AN000;
 32531 00005361 E85E01                  	call	$P_Chk_DBCS		;AN000; no, then DBCS ?
 32532 00005364 7302                    	jnc	short $P_FileF01	;AN000;
 32533 00005366 47                      	inc	di			;AN000; if yes, skip next byte
 32534 00005367 46                      	inc	si			;AN000;
 32535                                  $P_FileF01:				;AN000;
 32536 00005368 47                      	inc	di			;AN000;
 32537 00005369 46                      	inc	si			;AN000;
 32538 0000536A EBE9                    	jmp	short $P_FileF_Loop1	;AN000;
 32539                                  $P_FileF00:				;AN000;
 32540 0000536C 2EA2[6B99]              	mov	[cs:$P_Terminator],al	;AC034;
 32541 00005370 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; update end of string
 32542 00005374 47                      	inc	di			;AN000;
 32543 00005375 2E893E[6799]            	mov	[cs:$P_SI_Save],di	;AC034; update next pointer in command line
 32544                                  $P_FileF_RLT:				;AN000;
 32545 0000537A 5E                      	pop	si			;AN000;
 32546 0000537B 5F                      	pop	di			;AN000;
 32547                                  $P_FileF02:				;AN000;
 32548 0000537C 58                      	pop	ax			;AN000; (tm14)
 32549                                  	;;test	ax,200h
 32550                                  	;test	ax,$P_File_Spc		;AN000; (tm14)
 32551                                  	; 05/04/2023
 32552 0000537D F6C402                  	test	ah,($P_File_Spc>>8)
 32553 00005380 7408                    	jz	short $P_Drv_Only_Exit	;AN000; (tm14)
 32554 00005382 50                      	push	ax			;AN000; (tm14)
 32555                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 32556                                  	;mov	al,$P_File_Spec ; 5 	;AN000;    result
 32557                                  	; 05/04/2023
 32558 00005383 B805FF                  	mov	ax,($P_No_Tag<<8)+$P_File_Spec
 32559 00005386 E819F9                  	call	$P_Fill_Result		;AN000; 	buffer to file spec
 32560 00005389 58                      	pop	ax			;AN000;
 32561                                  $P_Drv_Only_Exit:			;AN000; (tm14)
 32562 0000538A C3                      	retn				;AN000;
 32563                                  
 32564                                  ;***********************************************************************
 32565                                  ; $P_FileSp_Chk
 32566                                  ;
 32567                                  ; Function:  Check if the input byte is one of file special characters
 32568                                  ;
 32569                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32570                                  ;	     AL = character code to be examineed
 32571                                  ;
 32572                                  ; Output:    ZF = 1 , AL is one of special characters
 32573                                  ;***********************************************************************
 32574                                  
 32575                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32576                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32577                                  $P_FileSp_Chk:
 32578 0000538B 53                      	push	bx			;AN000;
 32579 0000538C 51                      	push	cx			;AN000;
 32580                                  	;lea	bx,[cs:$P_FileSp_Char]	;AC034; special character table
 32581 0000538D 8D1E[359A]              	lea	bx,$P_FileSp_Char ; "[]|<>+=;\""
 32582 00005391 B90900                  	mov	cx,$P_FileSp_Len ; 9
 32583                                  	;mov	cx,9			;AN000; load length of it
 32584                                  $P_FileSp_Loop: 			;AN000;
 32585 00005394 2E3A07                  	cmp	al,[cs:bx]		;AN000; is it one of special character ?
 32586 00005397 7404                    	je	short $P_FileSp_Exit	;AN000;
 32587 00005399 43                      	inc	bx			;AN000;
 32588 0000539A E2F8                    	loop	$P_FileSp_Loop		;AN000;
 32589 0000539C 41                      	inc	cx			;AN000; reset ZF
 32590                                  $P_FileSp_Exit: 			;AN000;
 32591 0000539D 59                      	pop	cx			;AN000;
 32592 0000539E 5B                      	pop	bx			;AN000;
 32593 0000539F C3                      	retn				;AN000;
 32594                                  
 32595                                  ;***********************************************************************
 32596                                  ; $P_Drive_Format;
 32597                                  ;
 32598                                  ; Function:  Check if the input string is valid drive only format.
 32599                                  ;	     And set the result buffer.
 32600                                  ;
 32601                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32602                                  ;	     ES:BX -> CONTROL block
 32603                                  ;
 32604                                  ; Output:    None
 32605                                  ;
 32606                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS
 32607                                  ;
 32608                                  ; Vars: $P_RC(W)
 32609                                  ;***********************************************************************
 32610                                  
 32611                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32612                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32613                                  $P_Drive_Format:
 32614 000053A0 50                      	push	ax			;AN000;
 32615 000053A1 52                      	push	dx			;AN000;
 32616 000053A2 2E8A04                  	mov	al,[cs:si]		;AN000;
 32617 000053A5 08C0                    	or	al,al			;AN000; if null string
 32618 000053A7 7436                    	jz	short $P_Drv_Exit	;AN000; do nothing
 32619 000053A9 E81601                  	call	$P_Chk_DBCS		;AN000; is it leading byte ?
 32620 000053AC 722A                    	jc	short $P_Drv_Err	;AN000;
 32621                                  	;cmp	word [cs:si+1],3Ah ; $P_Colon  ; ':'
 32622 000053AE 2E837C013A              	cmp	word [cs:si+1],$P_Colon ;AN000; "d", ":", 0  ?
 32623 000053B3 740D                    	je	short $P_DrvF00		;AN000;
 32624                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 32625                                  	;test	word [es:bx],10h	;AN000; colon can be ignored?
 32626 000053B5 26F60710                	test	byte [es:bx],$P_Ig_Colon ; 10h
 32627 000053B9 741D                    	jz	short $P_Drv_Err	;AN000;
 32628 000053BB 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; "d", 0  ?
 32629 000053C0 7516                    	jne	short $P_Drv_Err	;AN000;
 32630                                  $P_DrvF00:				;AN000;
 32631 000053C2 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case
 32632 000053C4 3C61                    	cmp	al,"a" ; 61h            ;AN000; drive letter must
 32633 000053C6 7210                    	jb	short $P_Drv_Err	;AN000; in range of
 32634 000053C8 3C7A                    	cmp	al,"z" ; 7Ah            ;AN000; "a" - "z"
 32635 000053CA 770C                    	ja	short $P_Drv_Err	;AN000; if no, error
 32636 000053CC 2C60                    	sub	al,"a"-1  ; 60h         ;AN000; make text drive to binary drive
 32637 000053CE 88C2                    	mov	dl,al			;AN000; set
 32638                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000;    result
 32639                                  	;mov	al,$P_Drive ; 6		;AN000; 	 buffer
 32640                                  	; 05/04/2023
 32641 000053D0 B806FF                  	mov	ax,($P_No_Tag<<8)+$P_Drive ; 06FFh
 32642 000053D3 E8CCF8                  	call	$P_Fill_Result		;AN000; 	       to drive
 32643 000053D6 EB07                    	jmp	short $P_Drv_Exit	;AN000;
 32644                                  $P_Drv_Err:				;AN000;
 32645 000053D8 2EC706[6599]0900        	mov	word [cs:$P_RC],$P_Syntax
 32646                                  	;mov	word [cs:$P_RC],9	;AC034;
 32647                                  $P_Drv_Exit:				;AN000;
 32648 000053DF 5A                      	pop	dx			;AN000;
 32649 000053E0 58                      	pop	ax			;AN000;
 32650 000053E1 C3                      	retn				;AN000;
 32651                                  
 32652                                  ;***********************************************************************
 32653                                  ; $P_Skip_Delim;
 32654                                  ;
 32655                                  ; Function: Skip delimiters specified in the PARMS list, white space
 32656                                  ;	    and comma.
 32657                                  ;
 32658                                  ; Input:    DS:SI -> Command String
 32659                                  ;	    ES:DI -> Parameter List
 32660                                  ;
 32661                                  ; Output:   CY = 1 if the end of line encounterd
 32662                                  ;	    CY = 0 then SI move to 1st non-delimiter character
 32663                                  ;	    AL = Last examineed character
 32664                                  ;
 32665                                  ; Use:	    $P_Chk_EOL, $P_Chk_Delim,
 32666                                  ;
 32667                                  ; Vars:     $P_Flags(R)
 32668                                  ;***********************************************************************
 32669                                  
 32670                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32671                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32672                                  $P_Skip_Delim:				;AN000;
 32673                                  $P_Skip_Delim_Loop:			;AN000;
 32674 000053E2 AC                      	lodsb				;AN000;
 32675 000053E3 E81E00                  	call	$P_Chk_EOL		;AN000; is it EOL character ?
 32676 000053E6 7416                    	je	short $P_Skip_Delim_CY	;AN000; if yes, exit w/ CY on
 32677                                  
 32678 000053E8 E84B00                  	call	$P_Chk_Delim		;AN000; is it one of delimiters ?
 32679 000053EB 7514                    	jne	short $P_Skip_Delim_NCY	;AN000; if no, exit w/ CY off
 32680                                  
 32681 000053ED 2EF606[7199]20          	test	byte [cs:$P_Flags2],$P_Extra
 32682                                  	;test	byte [cs:$P_Flags2],20h ;AC034; extra delim or comma found ?
 32683 000053F3 74ED                    	jz	short $P_Skip_Delim_Loop
 32684                                  					;AN000; if no, loop
 32685 000053F5 2EF606[7199]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ
 32686                                  	;;test	byte [cs:$P_Flags2],41h	;AC034; /x , or xxx=zzz , (tm08)
 32687                                  	;jz	short $P_Exit_At_Extra	;AN000; no switch, no keyword (tm08)
 32688                                  	;dec	si ; *			;AN000; backup si for next call (tm08)
 32689                                  	;;jmp	short $P_Exit_At_Extra	;AN000; else exit w/ CY off
 32690                                  	; 05/04/2023
 32691 000053FB 7505                    	jnz	short $P_Skip_Delim_Exit ; cf = 0
 32692                                  $P_Exit_At_Extra:			;AN000;
 32693                                  	; cf = 0
 32694                                  	;clc				;AN000; indicate extra delim
 32695 000053FD C3                      	retn				;AN000;
 32696                                  
 32697                                  $P_Skip_Delim_CY:			;AN000;
 32698 000053FE F9                      	stc				;AN000; indicate EOL
 32699 000053FF EB01                    	jmp	short $P_Skip_Delim_Exit
 32700                                  					;AN000;
 32701                                  $P_Skip_Delim_NCY:			;AN000;
 32702 00005401 F8                      	clc				;AN000; indicate non delim
 32703                                  $P_Skip_Delim_Exit:			;AN000; in this case, need
 32704 00005402 4E                      	dec	si ; *			;AN000;  backup index pointer
 32705 00005403 C3                      	retn				;AN000;
 32706                                  	; 05/04/2023
 32707                                  ;$P_Exit_At_Extra:			;AN000;
 32708                                  	;clc				;AN000; indicate extra delim
 32709                                  	;retn				;AN000;
 32710                                  
 32711                                  ;***********************************************************************
 32712                                  ; $P_Chk_EOL;
 32713                                  ;
 32714                                  ; Function: Check if AL is one of End of Line characters.
 32715                                  ;
 32716                                  ; Input:    AL = character code
 32717                                  ;	    ES:DI -> Parameter List
 32718                                  ;
 32719                                  ; Output:   ZF = 1 if one of End of Line characters
 32720                                  ;***********************************************************************
 32721                                  
 32722                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32723                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32724                                  $P_Chk_EOL:
 32725 00005404 53                      	push	bx			;AN000;
 32726 00005405 51                      	push	cx			;AN000;
 32727 00005406 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; Carriage return ?
 32728 00005408 7429                    	je	short $P_Chk_EOL_Exit 	;AN000;
 32729 0000540A 3C00                    	cmp	al,$P_NULL ; 0		;AN000; zero ?
 32730 0000540C 7425                    	je	short $P_Chk_EOL_Exit 	;AN000;
 32731 0000540E 26807D0202              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_EOL
 32732                                  	;cmp	byte [es:di+2],2	;AN000; EOL character specified ?
 32733 00005413 721E                    	jb	short $P_Chk_EOL_Exit 	;AN000;
 32734 00005415 31DB                    	xor	bx,bx			;AN000;
 32735 00005417 268A5D03                	mov	bl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 32736                                  	;mov	bl,[es:di+3]		;AN000; get length of delimiter list
 32737 0000541B 83C304                  	add	bx,$P_Len_PARMS; 4 	;AN000; skip it
 32738 0000541E 26803900                	cmp	byte [es:bx+di],$P_I_Use_Default
 32739                                  	;cmp	byte [es:bx+di],0	;AN000; No extra EOL character ?
 32740 00005422 740D                    	je	short $P_Chk_EOL_NZ	;AN000;
 32741 00005424 31C9                    	xor	cx,cx			;AN000; Get number of extra chcracter
 32742 00005426 268A09                  	mov	cl,[es:bx+di]		;AN000;
 32743                                  $P_Chk_EOL_Loop:			;AN000;
 32744 00005429 43                      	inc	bx			;AN000;
 32745 0000542A 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra EOL character
 32746 0000542D 7404                    	je	short $P_Chk_EOL_Exit 	;AN000;
 32747 0000542F E2F8                    	loop	$P_Chk_EOL_Loop 	;AN000;
 32748                                  $P_Chk_EOL_NZ:				;AN000;
 32749 00005431 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; reset ZF
 32750                                  $P_Chk_EOL_Exit:			;AN000;
 32751 00005433 59                      	pop	cx			;AN000;
 32752 00005434 5B                      	pop	bx			;AN000;
 32753 00005435 C3                      	retn				;AN000;
 32754                                  
 32755                                  ;***********************************************************************
 32756                                  ; $P_Chk_Delim;
 32757                                  ;
 32758                                  ; Function: Check if AL is one of delimiter characters.
 32759                                  ;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
 32760                                  ;	    blanks.
 32761                                  ;
 32762                                  ; Input:    AL = character code
 32763                                  ;	    DS:SI -> Next Character
 32764                                  ;	    ES:DI -> Parameter List
 32765                                  ;
 32766                                  ; Output:   ZF = 1 if one of delimiter characters
 32767                                  ;	    SI points to the next character
 32768                                  ; Vars:  $P_Terminator(W), $P_Flags(W)
 32769                                  ;***********************************************************************
 32770                                  
 32771                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32772                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32773                                  $P_Chk_Delim:
 32774 00005436 53                      	push	bx			;AN000;
 32775 00005437 51                      	push	cx			;AN000;
 32776 00005438 2EC606[6B99]20          	mov	byte [cs:$P_Terminator],$P_Space ; 20h
 32777                                  					;AC034; Assume terminated by space
 32778 0000543E 2E8026[7199]DF          	and	byte [cs:$P_Flags2],0FFh-$P_Extra ; 0DFh
 32779                                  					;AC034;
 32780 00005444 3C20                    	cmp	al,$P_Space ; 20h ; ' '	;AN000; Space ?
 32781 00005446 7436                    	je	short $P_Chk_Delim_Exit	;AN000;
 32782                                  
 32783 00005448 3C09                    	cmp	al,$P_TAB ; 09h		;AN000; TAB ?
 32784 0000544A 7432                    	je	short $P_Chk_Delim_Exit	;AN000;
 32785                                  
 32786 0000544C 3C2C                    	cmp	al,$P_Comma  ; ',' 	;AN000; Comma ?
 32787 0000544E 7431                    	je	short $P_Chk_Delim_Exit0
 32788                                  					;AN000;
 32789                                  $P_Chk_Delim00: 			;AN000;
 32790 00005450 3C20                    	cmp	al,20h ; $P_DBSP1	;AN000; 1st byte of DBCS Space ?
 32791 00005452 750C                    	jne	short $P_Chk_Delim01	;AN000;
 32792 00005454 803C20                  	cmp	byte [si],20h ; $P_DBSP2
 32793                                  					;AN000; 2nd byte of DBCS Space ?
 32794 00005457 7507                    	jne	short $P_Chk_Delim01	;AN000;
 32795 00005459 B020                    	mov	al,$P_Space ; 20h	;AN000;
 32796 0000545B 46                      	inc	si			;AN000; make si point to next character
 32797 0000545C 38C0                    	cmp	al,al			;AN000; Set ZF
 32798 0000545E EB1E                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 32799                                  
 32800                                  $P_Chk_Delim01: 			;AN000;
 32801                                  	;cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_Delim
 32802 00005460 26807D0201              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],1
 32803                                  	;cmp	byte [es:di+2],1	;AN000; delimiter character specified ?
 32804 00005465 7217                    	jb	short $P_Chk_Delim_Exit	;AN000;
 32805                                  
 32806 00005467 31C9                    	xor	cx,cx			;AN000;
 32807 00005469 268A4D03                	mov	cl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 32808                                  	;mov	cl,[esi:di+3]		;AN000; get length of delimiter list
 32809 0000546D 09C9                    	or	cx,cx			;AN000; No extra Delim character ?
 32810 0000546F 740B                    	jz	short $P_Chk_Delim_NZ	;AN000;
 32811                                  
 32812 00005471 BB0300                  	mov	bx,$P_Len_PARMS-1 ; 3	;AN000; set bx to 1st extra delimiter
 32813                                  $P_Chk_Delim_Loop:			;AN000;
 32814 00005474 43                      	inc	bx			;AN000;
 32815 00005475 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra Delim character
 32816 00005478 7407                    	je	short $P_Chk_Delim_Exit0
 32817                                  					;AN000;
 32818 0000547A E2F8                    	loop	$P_Chk_Delim_Loop	;AN000; examine all extra delimiter
 32819                                  
 32820                                  $P_Chk_Delim_NZ:			;AN000;
 32821 0000547C 3C20                    	cmp	al,$P_Space ; 20h	;AN000; reset ZF
 32822                                  $P_Chk_Delim_Exit:			;AN000;
 32823 0000547E 59                      	pop	cx			;AN000;
 32824 0000547F 5B                      	pop	bx			;AN000;
 32825 00005480 C3                      	retn				;AN000;
 32826                                  
 32827                                  $P_Chk_Delim_Exit0:			;AN000;
 32828 00005481 2EA2[6B99]              	mov	[cs:$P_Terminator],al	;AC034; keep terminated delimiter
 32829 00005485 2EF606[7199]01          	test	byte [cs:$P_Flags2],$P_equ
 32830                                  	;test	byte [cs:$P_Flags2],1	;AN027;AC034;; if terminating a key=
 32831 0000548B 7506                    	jnz	short $P_No_Set_Extra 	;AN027; then do not set the EXTRA bit
 32832                                  
 32833 0000548D 2E800E[7199]20          	or	byte [cs:$P_Flags2],$P_Extra ; 20h
 32834                                  	;or	byte [cs:$P_Flags2],20h	;AC034; flag terminated extra delimiter or comma
 32835                                  $P_No_Set_Extra:			;AN027;
 32836 00005493 38C0                    	cmp	al,al			;AN000; set ZF
 32837 00005495 EBE7                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 32838                                  
 32839                                  ;***********************************************************************
 32840                                  ; $P_Chk_Switch;
 32841                                  ;
 32842                                  ; Function: Check if AL is the switch character not in first position of
 32843                                  ;	    $P_STRING_BUF
 32844                                  ;
 32845                                  ; Input:    AL = character code
 32846                                  ;	    BX = current pointer within $P_String_Buf
 32847                                  ;	    SI =>next char on command line (following the one in AL)
 32848                                  ;
 32849                                  ; Output:   CF = 1 (set)if AL is switch character, and not in first
 32850                                  ;		 position, and has no chance of being part of a date string,
 32851                                  ;		 i.e. should be treated as a delimiter.
 32852                                  ;
 32853                                  ;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
 32854                                  ;		 position, or is a slash but may be part of a date string, i.e.
 32855                                  ;		 should not be treated as a delimiter.
 32856                                  ;
 32857                                  ; Vars:  $P_Terminator(W)
 32858                                  ;
 32859                                  ; Use:	 $P_0099
 32860                                  ;***********************************************************************
 32861                                  
 32862                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32863                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32864                                  $P_Chk_Switch:
 32865                                  	; 18/04/2023
 32866 00005497 8D2E[7A99]              	lea	bp,$P_STRING_BUF	;AN020;AC034; BP=OFFSET of $P_String_Buf even in group addressing
 32867                                  
 32868 0000549B 39EB                    	cmp	bx,bp			;AN000;
 32869 0000549D 7418                    	je	short $P_STRUC_L2	;AN000;
 32870                                  
 32871 0000549F 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 32872 000054A1 7512                    	jne	short $P_STRUC_L5	;AN000;
 32873                                  
 32874 000054A3 F9                      	stc				;AN020;not in first position and is slash, now see if might be in date string
 32875 000054A4 50                      	push	ax			;AN020;save input char
 32876 000054A5 2E8A47FF                	mov	al,[cs:bx-1]		;AN026;AL=char before the current char
 32877 000054A9 E804FB                  	call	$P_0099 		;AN020;return carry set if not numeric
 32878 000054AC 7205                    	jc	short $P_STRUC_L7	;AN000;
 32879                                  
 32880 000054AE 8A04                    	mov	al,[si]			;AN020;AL=char after the current char
 32881 000054B0 E8FDFA                  	call	$P_0099			;AN020;return carry set if not numeric
 32882                                  $P_STRUC_L7:				;AN000;
 32883 000054B3 58                      	pop	ax			;AN020;restore AL to input char
 32884                                  	;jmp	short $P_STRUC_L1	;AN000;
 32885                                  	; 18/04/2023
 32886 000054B4 C3                      	retn
 32887                                  
 32888                                  $P_STRUC_L5:				;AN000;
 32889 000054B5 F8                      	clc				;AN020;not a slash
 32890                                  	;jmp	short $P_STRUC_L1	;AN000;
 32891                                  	 ;18/04/2023
 32892 000054B6 C3                      	retn
 32893                                  
 32894                                  $P_STRUC_L2:				;AN000;
 32895 000054B7 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 32896                                  	;jne	short $P_STRUC_L12	;AN000;
 32897                                  	; 18/04/2023
 32898 000054B9 75FA                    	jne	short $P_STRUC_L5
 32899                                  
 32900 000054BB 2E800E[7199]40          	or	byte [cs:$P_Flags2],$P_SW
 32901                                  	;or	byte [cs:$P_Flags2],40h	;AN020;AC034;;could be valid switch, first char and is slash
 32902                                  	; 18/04/2023
 32903                                  ;$P_STRUC_L12:				;AN000;
 32904                                  	;clc				;AN020;CF=0 indicating first char
 32905                                  $P_STRUC_L1:				;AN000;
 32906 000054C1 C3                      	retn				;AN000;
 32907                                  
 32908                                  ;**************************************************************************
 32909                                  ; $P_Chk_DBCS:
 32910                                  ;
 32911                                  ;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
 32912                                  ;
 32913                                  ;  Input:
 32914                                  ;	  AL	= Code to be examineed
 32915                                  ;
 32916                                  ;  Output:
 32917                                  ;	  If CF is on then a lead byte of DBCS
 32918                                  ;
 32919                                  ; Use: INT 21h w/AH=63
 32920                                  ;
 32921                                  ; Vars:  $P_DBCSEV_Seg(RW), $P_DBCSEV_Off(RW)
 32922                                  ;***************************************************************************
 32923                                  
 32924                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32925                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32926                                  $P_Chk_DBCS:
 32927 000054C2 1E                      	push	ds			;AN000;
 32928 000054C3 56                      	push	si			;AN000;
 32929 000054C4 53                      	push	bx			;AN000; (tm11)
 32930 000054C5 2E833E[6E99]00          	cmp	word [cs:$P_DBCSEV_SEG],0
 32931                                  					;AC034; ALREADY SET ?
 32932 000054CB 7527                    	jne	short $P_DBCS00		;AN000;
 32933 000054CD 50                      	push	ax			;AN000;
 32934 000054CE 1E                      	push	ds			;AN000; (tm11)
 32935 000054CF 51                      	push	cx			;AN000;
 32936 000054D0 52                      	push	dx			;AN000;
 32937 000054D1 57                      	push	di			;AN000;
 32938 000054D2 55                      	push	bp			;AN000;
 32939 000054D3 06                      	push	es			;AN000;
 32940 000054D4 31F6                    	xor	si,si			;AN000;
 32941 000054D6 8EDE                    	mov	ds,si			;AN000;
 32942                                  	;mov	ax,$P_DOS_GetEV 	;AN000; GET DBCS EV CALL
 32943 000054D8 B80063                  	mov	ax,6300h
 32944 000054DB CD21                    	int	21h			;AN000;
 32945 000054DD 8CDB                    	mov	bx,ds			;AN000; (tm11)
 32946 000054DF 09DB                    	or	bx,bx			;AN000; (tm11)
 32947 000054E1 07                      	pop	es			;AN000;
 32948 000054E2 5D                      	pop	bp			;AN000;
 32949 000054E3 5F                      	pop	di			;AN000;
 32950 000054E4 5A                      	pop	dx			;AN000;
 32951 000054E5 59                      	pop	cx			;AN000;
 32952 000054E6 1F                      	pop	ds			;AN000; (tm11)
 32953 000054E7 58                      	pop	ax			;AN000;
 32954 000054E8 7429                    	jz	short $P_NON_DBCS	;AN000;
 32955                                  $P_DBCS02:				;AN000;
 32956 000054EA 2E8936[6C99]            	mov	[cs:$P_DBCSEV_OFF],si	;AC034; save EV offset
 32957 000054EF 2E891E[6E99]            	mov	[cs:$P_DBCSEV_SEG],bx	;AC034; save EV segment (tm11)
 32958                                  $P_DBCS00:				;AN000;
 32959 000054F4 2E8B36[6C99]            	mov	si,[cs:$P_DBCSEV_OFF]	;AC034; load EV offset
 32960 000054F9 2E8E1E[6E99]            	mov	ds,[cs:$P_DBCSEV_SEG]	;AC034; and segment
 32961                                  $P_DBCS_LOOP:				;AN000;
 32962 000054FE 833C00                  	cmp	word [si],0 		;AN000; zero vector ?
 32963 00005501 7410                    	je	short $P_NON_DBCS	;AN000; then exit
 32964 00005503 3A04                    	cmp	al,[si] 		;AN000;
 32965 00005505 7208                    	jb	short $P_DBCS01		;AN000; Check if AL is in
 32966 00005507 3A4401                  	cmp	al,[si+1]		;AN000;   range of
 32967 0000550A 7703                    	ja	short $P_DBCS01		;AN000;      the vector
 32968 0000550C F9                      	stc				;AN000; if yes, indicate DBCS and exit
 32969 0000550D EB04                    	jmp	short $P_DBCS_EXIT	;AN000;
 32970                                  $P_DBCS01:				;AN000;
 32971 0000550F 46                      	inc	si			;AC035; add '2' to
 32972 00005510 46                      	inc	si			;AC035;  SI reg
 32973                                  					;AN000; get next vector
 32974 00005511 EBEB                    	jmp	short $P_DBCS_LOOP	;AN000; loop until zero vector found
 32975                                  
 32976                                  $P_NON_DBCS:				;AN000;
 32977                                  	; 18/04/2023
 32978                                  	; cf=0
 32979                                  	;clc				;AN000; indicate SBCS
 32980                                  $P_DBCS_EXIT:				;AN000;
 32981 00005513 5B                      	pop	bx			;AN000; (tm11)
 32982 00005514 5E                      	pop	si			;AN000;
 32983 00005515 1F                      	pop	ds			;AN000;
 32984 00005516 C3                      	retn				;AN000;
 32985                                  
 32986                                  ;============================================================================
 32987                                  ; TPARSE.ASM, MSDOS 6.0, 1991
 32988                                  ;============================================================================
 32989                                  ; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32990                                  
 32991                                  ; ****************************************************************
 32992                                  ; *
 32993                                  ; * ROUTINE:	 CMD_PARSE
 32994                                  ; *
 32995                                  ; * FUNCTION:	 Interface for transient COMMAND to invoke
 32996                                  ; *		 SYSPARSE.
 32997                                  ; *
 32998                                  ; * INPUT:	 inputs to SYSPARSE
 32999                                  ; *
 33000                                  ; * OUTPUT:	 outputs from SYSPARSE
 33001                                  ; *
 33002                                  ; ****************************************************************
 33003                                  
 33004                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33005                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4FF7h
 33006                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 33007                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:57BBh
 33008                                  ;cmd_parse:
 33009                                  	;call	sysparse		;AN000;
 33010                                  	;retn				;AN000;
 33011                                  	; 06/04/2023
 33012                                  	;jmp	sysparse
 33013                                  
 33014                                  append_parse:
 33015 00005517 E842F5                  	call	sysparse		;AN010;
 33016 0000551A CB                      	retf				;AN010;
 33017                                  
 33018                                  ;============================================================================
 33019                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 33020                                  ;============================================================================
 33021                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33022                                  ; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33023                                  
 33024                                  ; ----------------------------
 33025                                  ; MSDOS 6.0, MSGSERV.ASM, 1991
 33026                                  ; ----------------------------
 33027                                  
 33028                                  ;; Replacable parameters are described by a sublist structure
 33029                                  
 33030                                  struc $M_SUBLIST_STRUC		;;AN000;;
 33031 00000000 ??                       .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 33032 00000001 ??                       .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 33033 00000002 ????????                 .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 33034 00000006 ??                       .$M_S_ID:	resb 1		;;AN000;; n of %n
 33035 00000007 ??                       .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 33036 00000008 ??                       .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 33037 00000009 ??                       .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 33038 0000000A ??                       .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 33039                                  endstruc
 33040                                  
 33041                                  ; ---------------------------------------------------------------------------
 33042                                  ; ---------------------------------------------------------------------------
 33043                                  
 33044                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33045                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 4FFFh
 33046                                  
 33047                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33048                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 57C3h
 33049                                  
 33050                                  Printf_Init:
 33051 0000551B E80F00                  	call	std_printf
 33052 0000551E CB                      	retf
 33053                                  
 33054                                  Printf_Crlf:
 33055 0000551F E80B00                  	call	std_printf
 33056                                  	;call	CRLF2
 33057                                  	;retn
 33058                                  	; 07/04/2023
 33059 00005522 E9FCD5                  	jmp	CRLF2
 33060                                  
 33061                                  ;****************************************************************
 33062                                  ;*
 33063                                  ;* ROUTINE:	STD_PRINTF/STD_EPRINTF
 33064                                  ;*
 33065                                  ;* FUNCTION:	Set up to print out a message using SYSDISPMSG.
 33066                                  ;*		Set up substitutions if utility message.  Make
 33067                                  ;*		sure any changes to message variables in TDATA
 33068                                  ;*		are reset to avoid reloading the transient.
 33069                                  ;*
 33070                                  ;* INPUT:	Msg_Disp_Class	-  set to message class
 33071                                  ;*		Msg_Cont_Flag	-  set to control flags
 33072                                  ;*		DS	points to transient segment
 33073                                  ;*
 33074                                  ;*		if utility message:
 33075                                  ;*		DX	points to a block with message number
 33076                                  ;*			(word), number of substitutions (byte),
 33077                                  ;*			followed by substitution list if there
 33078                                  ;*			are substitutions.  If substitutions
 33079                                  ;*			are not in transient segment they must
 33080                                  ;*			be set.
 33081                                  ;*		else
 33082                                  ;*		AX	set to message number
 33083                                  ;*
 33084                                  ;* OUTPUT:	none
 33085                                  ;*
 33086                                  ;****************************************************************
 33087                                  
 33088                                  std_eprintf:
 33089 00005525 C706[419B]0200          	mov	word [PRINTF_HANDLE],2 		;AC000;Print to STDERR
 33090 0000552B EB06                    	jmp	short new_printf		;AC000;
 33091                                  
 33092                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33093                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 5012h
 33094                                  
 33095                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33096                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 57D6h
 33097                                  
 33098                                  std_printf:
 33099 0000552D C706[419B]0100          	mov	word [PRINTF_HANDLE],1 		;AC000;Print to STDOUT
 33100                                  
 33101                                  new_printf:
 33102 00005533 50                      	push	ax				;AN000;save registers
 33103 00005534 53                      	push	bx				;AN000;
 33104 00005535 51                      	push	cx				;AN000;
 33105 00005536 06                      	push	es				;AN000;get local ES
 33106 00005537 1E                      	push	ds				;AN000;
 33107 00005538 07                      	pop	es				;AN000;
 33108 00005539 57                      	push	di				;AN000;
 33109 0000553A 56                      	push	si				;AN000;
 33110 0000553B 52                      	push	dx				;AN000;
 33111                                  
 33112                                  	; 07/04/2023
 33113                                  	;mov	word [print_err_flag],0		;AN000;
 33114 0000553C 31C9                    	xor	cx,cx
 33115 0000553E 890E[4EA2]              	mov	[print_err_flag],cx ; 0
 33116                                  
 33117 00005542 89D6                    	mov	si,dx				;AN000;Get offset of message number
 33118 00005544 AD                      	lodsw					;AN000;load message number
 33119                                  	; 15/06/2023
 33120                                  	;push	ax				;AN000;save it
 33121                                  	;lodsb					;AN000;get number of substitutions
 33122                                  	;mov	cl,al				;AN000;set up CX as # of subst
 33123                                  	;; 07/04/2023
 33124                                  	;;xor	ch,ch				;AN000;SI now points to subst list
 33125                                  	;pop	ax				;AN000;get message number back
 33126                                  	; 15/06/2023
 33127 00005545 8A0C                    	mov	cl,[si]
 33128 00005547 46                      	inc	si
 33129                                  
 33130                                  	;cmp	cx,0				;AN000;Any substitutions?
 33131                                  	; 07/04/2023
 33132 00005548 21C9                    	and	cx,cx
 33133 0000554A 745C                    	jz	short ready_to_print		;AN000;No - continue
 33134                                  
 33135 0000554C BF[50A2]                	mov	di,subst_buffer			;AN061; Get address of message subst buffer
 33136 0000554F 57                      	push	di				;AN061; save it
 33137 00005550 51                      	push	cx				;AN061; save number of subst
 33138                                  
 33139                                  move_subst:
 33140 00005551 51                      	push	cx				;AN061;save number of subst
 33141 00005552 89F3                    	mov	bx,si				;AN061;save start of sublist
 33142                                  	;mov	cx,parm_block_size ; 11		;AN061;get size of sublist
 33143                                  	; 07/04/2023
 33144 00005554 B10B                    	mov	cl,parm_block_size ; 11
 33145 00005556 F3A4                    	rep	movsb				;AN061;move sublist
 33146                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 33147 00005558 F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 33148                                  	;test	byte [bx+7],4			;AN061;are we doing date/time?
 33149 0000555C 7406                    	jz	short move_subst_cont 		;AN061;no - no need to reset
 33150                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],0
 33151                                  	;mov	word [bx+2],0			;AN061;reset original date or time to 0
 33152 0000555E 894F02                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],cx ; 0
 33153                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 33154                                  	;mov	word [bx+4],0			;AN061;
 33155 00005561 894F04                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cx ; 0
 33156                                  
 33157                                  move_subst_cont:				;AN061;
 33158 00005564 59                      	pop	cx				;AN061;get number of subst back
 33159 00005565 E2EA                    	loop	move_subst			;AN061;move cx sublists
 33160                                  
 33161 00005567 59                      	pop	cx				;AN061;get number of subst
 33162 00005568 50                      	push	ax				;AN061;save message number
 33163 00005569 803E[F191]FF            	cmp	byte [msg_disp_class],util_msg_class
 33164                                  	;cmp	byte [msg_disp_class],0FFh	;AN061;Is this a utility message
 33165 0000556E 740C                    	je	short check_fix			;AN061;YES - go see if substitutions
 33166                                  	;mov	byte [msg_flag],1 ; ext_msg_class
 33167 00005570 C606[4AA2]01            	mov	byte [msg_flag],ext_msg_class	;AN061;set message flag
 33168 00005575 BF[F391]                	mov	di,extend_buf_ptr		;AN061; Get address of extended message block
 33169 00005578 31C0                    	xor	ax,ax				;AN061;clear ax register
 33170 0000557A AB                      	stosw					;AN061;clear out message number
 33171 0000557B AA                      	stosb					;AN061;clear out subst count
 33172                                  
 33173                                  check_fix:					;AN061;
 33174 0000557C 58                      	pop	ax				;AN061;get message number back
 33175 0000557D 5F                      	pop	di				;AN061;get start of sublists
 33176 0000557E 89FE                    	mov	si,di				;AN061;get into SI for msgserv
 33177 00005580 89F3                    	mov	bx,si				;AN061;get into BX for addressing
 33178 00005582 51                      	push	cx				;AN061;save number of subst
 33179                                  
 33180                                  set_subst:					;AN061;store the segment of the subst
 33181 00005583 837F0400                	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 33182                                  	;cmp	word [bx+4],0			;AN061;was it set already?
 33183 00005587 7509                    	jnz	short subst_seg_set		;AN061;if not 0, don't replace it
 33184 00005589 F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 33185                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 33186                                  	;test	byte [bx+7],4			;AN061;don't replace if date or time
 33187 0000558D 7503                    	jnz	short subst_seg_set		;AN061;yes - skip it
 33188 0000558F 8C4F04                  	mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cs
 33189                                  	;mov	word [bx+4],cs			;AN061;set segment value
 33190                                  
 33191                                  subst_seg_set:					;AN061;
 33192 00005592 83C30B                  	add	bx,parm_block_size ; add bx,11	;AN061;go to next sublist
 33193 00005595 E2EC                    	loop	set_subst			;AN061;loop CX times
 33194 00005597 59                      	pop	cx				;AN061;get number of subst back
 33195                                  
 33196 00005598 89F3                    	mov	bx,si				;AN061;get start of sublist to BX
 33197 0000559A 817F02[B7A0]            	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],string_ptr_2
 33198                                  	;cmp	word [bx+2],string_ptr_2	;AN061;are we using double indirection?
 33199 0000559F 7507                    	jne	short ready_to_print		;AN061;no - we already have address
 33200                                  	; 01/05/2023
 33201 000055A1 8B16[B7A0]              	mov	dx,[string_ptr_2] 		;AN061;get address in string_ptr_2
 33202 000055A5 895702                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],dx
 33203                                  						;AN061;put it into the subst block
 33204                                  	;mov	[bx+2],dx
 33205                                  
 33206                                  ready_to_print:
 33207 000055A8 8B1E[419B]              	mov	bx,[PRINTF_HANDLE]		;AN000;get print handle
 33208 000055AC 8A16[F291]              	mov	dl,[msg_cont_flag]		;AN000;set up control flag
 33209 000055B0 8A36[F191]              	mov	dh,[msg_disp_class]		;AN000;set up display class
 33210 000055B4 C606[F291]00            	mov	byte [msg_cont_flag],0 ; no_cont_flag
 33211                                  						;AN061;reset flags to avoid
 33212 000055B9 C606[F191]FF            	mov	byte [msg_disp_class],util_msg_class
 33213                                  	;mov	byte [msg_disp_class],0FFh	;AN061; transient reload
 33214                                  
 33215 000055BE 1E                      	push	ds				;AN026;
 33216 000055BF 06                      	push	es				;AN026;
 33217                                  
 33218 000055C0 E83702                  	call	SYSDISPMSG			;AN000;call Rod
 33219                                  
 33220 000055C3 07                      	pop	es				;AN026; restore registers
 33221 000055C4 1F                      	pop	ds				;AN026;
 33222                                  
 33223 000055C5 7303                    	jnc	short print_success		;AN000; everything went okay
 33224 000055C7 A3[4EA2]                	mov	[print_err_flag],ax		;AN000;
 33225                                  
 33226                                  print_success:
 33227 000055CA 5A                      	pop	dx				;AN061;restore dx
 33228 000055CB 5E                      	pop	si				;AN000;restore registers
 33229 000055CC 5F                      	pop	di				;AN000;
 33230 000055CD 07                      	pop	es				;AN000;restore registers
 33231 000055CE 59                      	pop	cx				;AN000;
 33232 000055CF 5B                      	pop	bx				;AN000;
 33233 000055D0 58                      	pop	ax				;AN000;
 33234 000055D1 833E[4EA2]00            	cmp	word [print_err_flag],0		;AN000; if an error occurred - handle it
 33235 000055D6 7501                    	jnz	short print_err			;AN000;
 33236                                  
 33237 000055D8 C3                      	retn					;AC000;
 33238                                  
 33239                                  print_err:
 33240 000055D9 0E                      	push	cs
 33241 000055DA 07                      	pop	es
 33242 000055DB 833E[419B]02            	cmp	word [PRINTF_HANDLE],2 		;AN026;Print to STDERR?
 33243 000055E0 7503                    	jne	short not_stderr		;AN026;no - continue
 33244 000055E2 E91FAB                  	jmp	TCOMMAND			;AN026;Yes - hopless - just exit
 33245                                  
 33246                                  not_stderr:
 33247 000055E5 A1[4EA2]                	mov	ax,[print_err_flag]		;AN026;get extended error number back
 33248 000055E8 8E06[159E]              	mov	es,[RESSEG]			; No, set up for error, load the
 33249                                  						;  right error msg, and jmp to cerror.
 33250 000055EC 26F606[B502]FF          	test	byte [es:PipeFlag],-1 ; 0FFh
 33251 000055F2 7408                    	jz	short _go_to_error
 33252 000055F4 E8C1DE                  	call	PipeOff
 33253 000055F7 BA[5493]                	mov	dx,PIPEEMES_PTR
 33254 000055FA EB0B                    	jmp	short print_err_exit			;AC000;
 33255                                  
 33256                                  _go_to_error:
 33257 000055FC C606[F191]01            	mov	byte [msg_disp_class],ext_msg_class
 33258                                  	;mov	byte [msg_disp_class],1		;AN000; set up extended error msg class
 33259 00005601 BA[F391]                	mov	dx,extend_buf_ptr		;AC000; get extended message pointer
 33260 00005604 A3[F391]                	mov	[extend_buf_ptr],ax		;AN000; get message number in control block
 33261                                  
 33262                                  print_err_exit: 				;AC000;
 33263 00005607 0E                      	push	cs
 33264 00005608 07                      	pop	es
 33265 00005609 E996D8                  	jmp	cerror
 33266                                  
 33267                                  ;****************************************************************
 33268                                  ;*
 33269                                  ;* ROUTINE:	TSYSLOADMSG
 33270                                  ;*
 33271                                  ;* FUNCTION:	Interface to call SYSLOADMSG to avoid duplicate
 33272                                  ;*		names since these routines are also used in the
 33273                                  ;*		resident.
 33274                                  ;*
 33275                                  ;* INPUT:	Inputs to SYSLOADMSG
 33276                                  ;*
 33277                                  ;* OUTPUT:	Outputs from SYSLOADMSG
 33278                                  ;*
 33279                                  ;****************************************************************
 33280                                  
 33281                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33282                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33283                                  TSYSLOADMSG:
 33284 0000560C 53                      	push	bx				;AN000;
 33285 0000560D E80800                  	call	SYSLOADMSG			;AN000; call routine
 33286 00005610 5B                      	pop	bx				;AN000;
 33287 00005611 C3                      	retn					;AN000; exit
 33288                                  
 33289                                  ;****************************************************************
 33290                                  ;*
 33291                                  ;* ROUTINE:	TSYSGETMSG
 33292                                  ;*
 33293                                  ;* FUNCTION:	Interface to call SYSGETMSG to avoid duplicate
 33294                                  ;*		names since these routines are also used in the
 33295                                  ;*		resident.
 33296                                  ;*
 33297                                  ;* INPUT:	Inputs to SYSGETMSG
 33298                                  ;*
 33299                                  ;* OUTPUT:	Outputs from SYSGETMSG
 33300                                  ;*
 33301                                  ;****************************************************************
 33302                                  
 33303                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33304                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33305                                  TSYSGETMSG:
 33306 00005612 51                      	push	cx				;AN000;
 33307 00005613 E8B500                  	call	SYSGETMSG			;AN000; call routine
 33308 00005616 59                      	pop	cx				;AN000;
 33309 00005617 C3                      	retn					;AN000; exit
 33310                                  
 33311                                  ;============================================================================
 33312                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 33313                                  ;============================================================================
 33314                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33315                                  ; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33316                                  
 33317                                  ; ---------------------------------------------------------------------------
 33318                                  ; MODULE NAME: MSGSERV.SAL
 33319                                  ;
 33320                                  ; DESCRIPTIVE NAME: Message Services SALUT file
 33321                                  ;
 33322                                  ; FUNCTION: This module incorporates all the messages services and
 33323                                  ;	    is called upon at build time to INCLUDE the code requested
 33324                                  ;	    by a utility. Code is requested using the macro MSG_SERVICES.
 33325                                  ;
 33326                                  ; ENTRY POINT: Since this a collection of subroutines, entry point is at
 33327                                  ;	    requested procedure.
 33328                                  ;
 33329                                  ; INPUT: Since this a collection of subroutines, input is dependent on
 33330                                  ;	    function requested.
 33331                                  ;
 33332                                  ; EXIT-NORMAL: In all cases, CARRY FLAG = 0
 33333                                  ;
 33334                                  ; EXIT-ERROR: In all cases, CARRY FLAG = 1
 33335                                  ;
 33336                                  ; INTERNAL REFERENCES: (list of included subroutines)
 33337                                  ;
 33338                                  ;	- SYSLOADMSG
 33339                                  ;	- SYSDISPMSG
 33340                                  ;	- SYSGETMSG
 33341                                  ;
 33342                                  ; EXTERNAL REFERENCES: None
 33343                                  ;
 33344                                  ; NOTES: At build time, some modules must be included. These are only included
 33345                                  ;	 once using assembler switches. Other logic is included at the request
 33346                                  ;	 of the utility.
 33347                                  ;
 33348                                  ;	 COMR and COMT are assembler switches to conditionally assemble code
 33349                                  ;	 for RESIDENT COMMAND.COM and TRANSIENT COMMAND.COM to reduce resident
 33350                                  ;	 storage and multiple EQUates.
 33351                                  ;
 33352                                  ; REVISION HISTORY: Created MAY 1987
 33353                                  ;
 33354                                  ;     Label: DOS - - Message Retriever
 33355                                  ;	     (c) Copyright 1988 Microsoft
 33356                                  ; ---------------------------------------------------------------------------
 33357                                  
 33358                                  ;	Revision History
 33359                                  ;	================
 33360                                  ;
 33361                                  ;	M007	SR	08/24/90	Fixed bug #1818 -- changed
 33362                                  ;				$M_DISPLAY_H_STRING to properly
 33363                                  ;				handle Ctrl-Z being passed
 33364                                  ;
 33365                                  ;	M013	SR	9/12/90	Make SETSTDIO flag false so that all
 33366                                  ;				these routines are no longer assembled.
 33367                                  ;
 33368                                  ;	M016	SR	10/14/90	Bug #3380. Changed SYSLOADMSG so that
 33369                                  ;				CR-LF string also gets reinitialized
 33370                                  ;				on every cycle.
 33371                                  ;
 33372                                  ;	M020	SR	10/26/90	Bug #3380 again. Initialize $M_DIVISOR
 33373                                  ;				& $_MSG_NUM also in SYSLOADMSG.
 33374                                  
 33375                                  ; ---------------------------------------------------------------------------
 33376                                  
 33377                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33378                                  
 33379                                  ;;; Replacable parameters are described by a sublist structure
 33380                                  ;
 33381                                  ;struc $M_SUBLIST_STRUC		;;AN000;;
 33382                                  ; .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 33383                                  ; .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 33384                                  ; .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 33385                                  ; .$M_S_ID:	resb 1		;;AN000;; n of %n
 33386                                  ; .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 33387                                  ; .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 33388                                  ; .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 33389                                  ; .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 33390                                  ;endstruc
 33391                                  
 33392                                  ;; Each class will be defined by this structure.
 33393                                  
 33394                                  struc $M_CLASS_ID		;;AN000;;
 33395 00000000 ??                       .$M_CLS_ID:	  resb 1	;;AN000;; Class identifer
 33396 00000001 ????                     .$M_COMMAND_VER: resw 1	;;AN003;; COMMAND.COM version check
 33397 00000003 ??                       .$M_NUM_CLS_MSG: resb 1	;;AN000;; Total number of message in class
 33398                                   .size:
 33399                                  endstruc
 33400                                  
 33401                                  $M_CLASS_ID_SZ	EQU $M_CLASS_ID.size	;;AN000;;
 33402                                  
 33403                                  ;; Each message will be defined by this structure.
 33404                                  
 33405                                  struc $M_ID			;;AN000;;
 33406 00000000 ????                     .$M_NUM:	resw 1		;;AN000;; Message Number
 33407 00000002 ????                     .$M_TXT_PTR:	resw 1		;;AN000;; Pointer to message text
 33408                                   .size:	
 33409                                  endstruc
 33410                                  
 33411                                  $M_ID_SZ	EQU  $M_ID.size	;;AN000;;
 33412                                  
 33413                                  ; ---------------------------
 33414                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33415                                  ; ---------------------------
 33416                                  $M_TEMP_BUF_SZ	EQU 64     ;; Size of temporary buffer	 ;AN003;
 33417                                  
 33418                                  ; --------------------------- 
 33419                                  
 33420                                  ; 07/04/2023
 33421                                  $M_NUM_CLS equ 3
 33422                                  
 33423                                  ;; Resident data area definition of variables
 33424                                  
 33425                                  struc $M_RES_ADDRS			;;AN000;;
 33426 00000000 ????????                 .$M_EXT_ERR_ADDRS: resd 1		;;AN000;; Allow pointers to THREE Extended error locations
 33427 00000004 ????????                 .$M_EXT_FILE:	    resd 1		;;AN001;;
 33428 00000008 ????????                 .$M_EXT_COMMAND:   resd 1		;;AN000;;
 33429 0000000C ????????                 .$M_EXT_TERM:	    resd 1		;;AN000;;
 33430 00000010 ????????                 .$M_PARSE_COMMAND: resd 1		;;AN000;;
 33431 00000014 ????????                 .$M_PARSE_ADDRS:   resd 1		;;AN000;; Allow pointers to TWO Parse error locations
 33432 00000018 ????????                 .$M_PARSE_TERM:    resd 1		;;AN000;;
 33433 0000001C ????????                 .$M_CRIT_ADDRS:    resd 1		;;AN000;; Allow pointers to TWO Critical error locations
 33434 00000020 ????????                 .$M_CRIT_COMMAND:  resd 1		;;AN000;;
 33435 00000024 ????????                 .$M_CRIT_TERM:	    resd 1		;;AN000;;
 33436 00000028 ????????                 .$M_DISK_PROC_ADDR: resd 1		;;AN004;; Address of READ_DISK_PROC
 33437 0000002C <res Ch>                 .$M_CLASS_ADDRS:   resd $M_NUM_CLS ; 3	;;AN000;; Allow pointers to specified classes
 33438 00000038 ????????                 .$M_CLS_TERM:	    resd 1		;;AN000;;
 33439 0000003C ????????                 .$M_DBCS_VEC:	    resd 1		;;AN000;; Save DBCS vector
 33440 00000040 ????                     .$M_HANDLE:	    resw 1 		;;AN000;;
 33441 00000042 ??                       .$M_SIZE:	    resb 1		;;AN000;;
 33442 00000043 ????                     .$M_CRLF:	    resb 2  		;;AN004;; CR LF message
 33443 00000045 ??                       .$M_CLASS:	    resb 1		;;AN004;; Saved class
 33444 00000046 ????                     .$M_RETURN_ADDR:   resw 1		;;AN000;;
 33445 00000048 ????                     .$M_MSG_NUM:	    resw 1		;;AN000;;
 33446 0000004A ????                     .$M_DIVISOR:	    resw 1		;;AN000;; Default = 10 (must be a WORD for division)
 33447 0000004C <res 40h>                .$M_TEMP_BUF:	    resb $M_TEMP_BUF_SZ	;;AN000;; Temporary buffer
 33448 0000008C ??                       .$M_BUF_TERM:	    resb 1		;;AN000;;
 33449                                   .size:
 33450                                  endstruc				;;AN000;;
 33451                                  
 33452                                  $M_RES_ADDRS_SZ	EQU $M_RES_ADDRS.size	;;AN000;;
 33453                                  
 33454                                  ;; Important fields of the Get Country Information call
 33455                                  
 33456                                  struc $M_COUNTRY_INFO			;;AN000;; Expected Country infomation
 33457 00000000 <res 4Ch>                .$M_HEADER:	    resb $M_RES_ADDRS_SZ-$M_TEMP_BUF_SZ-1
 33458                                  					;;AN000;; Go past first part of struc
 33459 0000004C ????                     .$M_DATE_FORMAT:   resw 1		;;AN000;; <------- Date Format
 33460 0000004E ??????????               .$M_CURR_SEPARA:   resb 5		;;AN000;;
 33461 00000053 ????                     .$M_THOU_SEPARA:   resb 2		;;AN000;; <------- Thou Separator
 33462 00000055 ????                     .$M_DECI_SEPARA:   resb 2		;;AN000;; <------- Decimal Separator
 33463 00000057 ????                     .$M_DATE_SEPARA:   resb 2		;;AN000;; <------- Date Separator
 33464 00000059 ????                     .$M_TIME_SEPARA:   resb 2		;;AN000;; <------- Time Separator
 33465 0000005B ??                       .$M_CURR_FORMAT:   resb 1		;;AN000;;
 33466 0000005C ??                       .$M_SIG_DIGS_CU:   resb 1		;;AN000;;
 33467 0000005D ??                       .$M_TIME_FORMAT:   resb 1		;;AN000;; <------- Time Format
 33468                                  endstruc				;;AN000;;
 33469                                  
 33470                                  ; ---------------------------------------------------------------------------
 33471                                  
 33472                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33473                                  ;;
 33474                                  ;;	PROC NAME: SYSLOADMSG
 33475                                  ;;
 33476                                  ;;	FUNCTION:
 33477                                  ;;	INPUTS:
 33478                                  ;;
 33479                                  ;;	OUTPUTS:
 33480                                  ;;
 33481                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33482                                  
 33483                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33484                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5107h
 33485                                  
 33486                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33487                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:58CBh
 33488                                  
 33489                                  SYSLOADMSG:
 33490 00005618 50                      	push	ax				;;AN000;
 33491 00005619 53                      	push	bx				;;AN000;
 33492 0000561A 52                      	push	dx				;;AN000;
 33493 0000561B 06                      	push	es				;;AN000;
 33494 0000561C 57                      	push	di				;;AN000;
 33495 0000561D 31C9                    	xor	cx,cx				;;AN000;  Reset to zero
 33496 0000561F 8EC1                    	mov	es,cx				;;AN000;
 33497 00005621 31FF                    	xor	di,di				;;AN000;
 33498 00005623 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33499 00005626 B200                    	mov	dl,0 ; DOS_GET_EXTENDED		;;AN000;; Where are the Extended errors in COMMAND.COM
 33500 00005628 CD2F                    	int	2Fh				;;AN000;; Private interface
 33501                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33502                                  		; DL = subfunction - get standard DOS error table (errors 00h-12h,50h-5Bh)
 33503                                  		; Return: ES:DI -> error table
 33504                                  	
 33505 0000562A 8C06[499A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND+2],es
 33506                                  	;mov	[$M_RT+10],es			;;AN000;; Move into first avaliable table location
 33507 0000562E 893E[479A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND],di
 33508                                  	;mov	[$M_RT+8],di			;;AN000;;
 33509                                  
 33510 00005632 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33511 00005635 B202                    	mov	dl,2 ; DOS_GET_PARSE		;;AN000;; Where are the Parse errors in COMMAND.COM
 33512 00005637 CD2F                    	int	2Fh				;;AN000;; Private interface
 33513                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33514                                  		; DL = subfunction - get critical/SHARE error table (errors 13h-2Bh)
 33515                                  		; ES:DI -> error table
 33516                                  
 33517 00005639 8C06[519A]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND+2],es
 33518                                  	;mov	[$M_RT+18],es			;;AN000;; Move into first avaliable table location
 33519 0000563D 893E[4F9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND],di
 33520                                  	;mov	[$M_RT+16],di			;;AN000;;
 33521                                  
 33522 00005641 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33523 00005644 B204                    	mov	dl,4 ; DOS_GET_CRITICAL		;;AN000;; Where are the Critical errors in COMMAND.COM
 33524 00005646 CD2F                    	int	2Fh				;;AN000;; Private interface
 33525                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33526                                  		; DL = subfunction - get ??? error table
 33527                                  		; ES:DI -> error table
 33528                                  
 33529 00005648 8C06[619A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND+2],es
 33530                                  	;mov	[$M_RT+34],es			;;AN000;; Move into first avaliable table location
 33531 0000564C 893E[5F9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND],di
 33532                                  	;mov	[$M_RT+32],di			;;AN000;;
 33533                                  
 33534 00005650 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 33535 00005653 B206                    	mov	dl,6 ; DOS_GET_FILE		;;AN001;; Where are the FILE dependant in IFSFUNC.EXE
 33536 00005655 CD2F                    	int	2Fh					     ;;AN001;; Private interface
 33537                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33538                                  		; DL = subfunction - get ??? error table
 33539                                  		; ES:DI -> error table
 33540                                  
 33541 00005657 8C06[459A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE+2],es
 33542                                  	;mov	[$M_RT+6],es			;;AN001;; Move into first avaliable table location
 33543 0000565B 893E[439A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE],di
 33544                                  	;mov	[$M_RT+4],di			;;AN001;;
 33545                                  
 33546 0000565F E86A3B                  	call	$M_MSGSERV_1			;;AN000;; Get addressibility to MSGSERV CLASS 1 (EXTENDED Errors)
 33547                                  						;;AN000;;
 33548 00005662 8C06[419A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS+2],es
 33549                                  	;mov	[$M_RT+2],es			;;AN000;; Move into first avaliable table location
 33550 00005666 893E[3F9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS],di
 33551                                  	;mov	[$M_RT+0],di			;;AN000;;
 33552 0000566A 8C06[5D9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS+2],es
 33553                                  	;mov	[$M_RT+30],es			;;AN000;; Move into first avaliable table location
 33554 0000566E 893E[5B9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS],di
 33555                                  	;mov	[$M_RT+28],di			;;AN000;;
 33556                                  
 33557 00005672 E8753B                  	call	$M_MSGSERV_2			;;AN000;; Get addressibility to MSGSERV CLASS 2 (PARSE Errors)
 33558                                  
 33559 00005675 8C06[559A]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS+2],es
 33560                                  	;mov	[$M_RT+22],es			;;AN000;; Move into first avaliable table location
 33561 00005679 893E[539A]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS],di
 33562                                  	;mov	[$M_RT+20],di			;;AN000;;
 33563                                  
 33564 0000567D B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 33565 00005680 B208                    	mov	dl,8 ; DOS_GET_ADDR 		;;AN001;; Where is the READ_DISK_PROC in COMMAND.COM
 33566 00005682 CD2F                    	int	2Fh				;;AN001;; Private interface
 33567                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33568                                  		; DL = subfunction - get ??? error table
 33569                                  		; ES:DI -> error table
 33570                                  
 33571 00005684 8C06[699A]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR+2],es
 33572                                  	;mov	[$M_RT+42],es			;;AN001;; Move into first avaliable table location
 33573 00005688 893E[679A]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],di
 33574                                  	;mov	[$M_RT+40],di			;;AN001;;
 33575                                  
 33576                                  ;M016; M020
 33577                                  ; Reinitialize the CR-LF string. Also, reinit the buffer terminator just to
 33578                                  ;be safe. Initialize $M_MSG_NUM and $M_DIVISOR also.
 33579                                  
 33580 0000568C C706[829A]0D0A          	mov	word [$M_RT+$M_RES_ADDRS.$M_CRLF],0A0Dh
 33581                                  	;mov	word [$M_RT+67],0A0Dh		; Reinit CR-LF ;M016
 33582 00005692 C606[CB9A]24            	mov	byte [$M_RT+$M_RES_ADDRS.$M_BUF_TERM],'$'
 33583                                  	;mov	word [$M_RT+140],'$'		; Reinit buffer end;M016
 33584 00005697 C706[879A]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 33585                                  	;mov	word [$M_RT+72],0		; M020
 33586 0000569D C706[899A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 33587                                  	;mov	word [$M_RT+74],10		; M020
 33588                                  
 33589                                  	; 07/04/2023 - Retro DOS v4.0 COMMAND.COM
 33590                                  	; --------------------------
 33591                                  	; MSDOS 6.0 SYSMSG.INC, 1991
 33592                                  	; --------------------------
 33593                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP5192h
 33594                                  
 33595                                  	;$M_BUILD_PTRS %$M_NUM_CLS     		;;AN000;; Build all utility classes	
 33596 000056A3 E8C33A                  	call    $M_CLS_3			; Get addressibility to class F
 33597 000056A6 893E[6B9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS],di
 33598                                  	;mov	[$M_RT+44],di
 33599                                  	
 33600 000056AA E80600                  	CALL	$M_GET_DBCS_VEC 		;;AN000;; Save the DBCS vector
 33601                                  
 33602                                  	; 15/04/2023
 33603                                  	;clc					;;AN000;; Make sure carry is clear
 33604                                  	;jc	short $MIF20
 33605                                  	
 33606 000056AD 5F                      	pop	di				;;AN000;; Restore REGS
 33607 000056AE 07                      	pop	es				;;AN000;;
 33608 000056AF 5A                      	pop	dx				;;AN000;;
 33609 000056B0 5B                      	pop	bx				;;AN000;;
 33610 000056B1 58                      	pop	ax				;;AN000;;
 33611                                  	;jmp	short $MEN20
 33612                                  	; 15/04/2023
 33613 000056B2 C3                      	retn
 33614                                  
 33615                                  	; 15/04/2023
 33616                                  ;$MIF20:
 33617                                  	;add	sp,10				;;AN000;;
 33618                                  	;stc					;;AN000;; Reset carry flag
 33619                                  ;$MEN20:
 33620                                  	;retn					;;AN000;;
 33621                                  
 33622                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33623                                  ;;
 33624                                  ;;  Proc Name:	$M_GET_DBCS_VEC
 33625                                  ;;
 33626                                  ;;  Function:	Get the DBCS vector and save it for later use
 33627                                  ;;
 33628                                  ;;  Inputs:	None
 33629                                  ;;
 33630                                  ;;  Outputs:	None
 33631                                  ;;
 33632                                  ;;  Regs Changed:
 33633                                  ;;
 33634                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33635                                  
 33636                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33637                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33638                                  $M_GET_DBCS_VEC:
 33639 000056B3 50                      	push	ax				;;AN000;; Save character to check
 33640 000056B4 56                      	push	si				;;AN000;;
 33641 000056B5 1E                      	push	ds				;;AN000;;
 33642 000056B6 B80063                  	mov	ax,6300h ;DOS_GET_DBCS_INFO	;;AN000;; DOS function to get DBSC environment
 33643 000056B9 CD21                    	int	21h				;;AN000;; Get environment pointer
 33644 000056BB 1E                      	push	ds				;;AN000;; Get environment pointer
 33645 000056BC 07                      	pop	es				;;AN000;; Get environment pointer
 33646 000056BD 1F                      	pop	ds				;;AN000;; Get environment pointer
 33647 000056BE 7208                    	jc	short $MIF23
 33648                                  	
 33649 000056C0 8936[7B9A]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC],si
 33650                                  	;mov	word [$M_RT+60],si		;;AN000;; Save DBCS Vector
 33651 000056C4 8C06[7D9A]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC+2],es
 33652                                  	;mov	word [$M_RT+62],es		;;AN000;;
 33653                                  $MIF23:
 33654 000056C8 5E                      	pop	si				;;AN000;;
 33655 000056C9 58                      	pop	ax				;;AN000;; Retrieve character to check
 33656 000056CA C3                      	retn					;;AN000;; Return
 33657                                  
 33658                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33659                                  ;;
 33660                                  ;;  Proc Name:	SYSGETMSG
 33661                                  ;;
 33662                                  ;;  Function:	The GET service returns the segment, offset and size of the
 33663                                  ;;		message text to the caller based on a message number.
 33664                                  ;;		The GET function will not display the message thus assumes
 33665                                  ;;		caller will handle replaceable parameters.
 33666                                  ;;
 33667                                  ;;  Inputs:
 33668                                  ;;
 33669                                  ;;  Outputs:
 33670                                  ;;
 33671                                  ;;  Psuedocode:
 33672                                  ;;		Call $M_GET_MSG_ADDRESS
 33673                                  ;;		IF MSG_NUM exists THEN
 33674                                  ;;		   Set DS:SI = MSG_TXT_PTR + 1
 33675                                  ;;		   CARRY_FLAG = 0
 33676                                  ;;		ELSE
 33677                                  ;;		   CARRY_FLAG = 1
 33678                                  ;;		ENDIF
 33679                                  ;;
 33680                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33681                                  
 33682                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33683                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33684                                  
 33685                                  	utility_msg_class equ 0FFh ; 18/04/2023
 33686                                  
 33687                                  SYSGETMSG:
 33688                                  	;; Save registers needed later
 33689 000056CB 50                      	push	ax				;;AN000;; Save changed regs
 33690 000056CC 06                      	push	es				;;AN000;;
 33691 000056CD 57                      	push	di				;;AN000;;
 33692 000056CE 55                      	push	bp				;;AN000;;
 33693                                  
 33694 000056CF E81400                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 33695 000056D2 720D                    	jc	short $MIF31
 33696                                  	
 33697 000056D4 80FEFF                  	cmp	dh,utility_msg_class ; 0FFh	;;AN000;; Were utility messages requested?
 33698                                  	;clc					;;AN000;;
 33699 000056D7 7404                    	je	short $MIF32			;;AN000;;
 33700                                  	; 15/06/2023
 33701 000056D9 F8                      	clc	
 33702                                  
 33703 000056DA 06                      	push	es				;;AN000;;
 33704                                  	;pop	ds				;;AN000;;
 33705 000056DB EB01                    	jmp	short $MEN32
 33706                                  $MIF32:
 33707 000056DD 0E                      	push	cs				;;AN000;;			
 33708                                  	;pop	ds				;;AN000;;
 33709                                  $MEN32:
 33710                                  	; 07/04/2023
 33711 000056DE 1F                      	pop	ds
 33712 000056DF 89FE                    	mov	si,di				;;AN000;; Return message in DS:SI
 33713                                  $MIF31:
 33714 000056E1 5D                      	pop	bp				;;AN000;; Restore changed regs
 33715 000056E2 5F                      	pop	di				;;AN000;;
 33716 000056E3 07                      	pop	es				;;AN000;;
 33717 000056E4 58                      	pop	ax				;;AN000;;
 33718 000056E5 C3                      	retn					;;AN000;; Return
 33719                                  
 33720                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33721                                  ;;
 33722                                  ;;	PROC NAME: $M_GET_MSG_ADDRESS
 33723                                  ;;
 33724                                  ;;	FUNCTION:  To scan thru classes to return pointer to the message header
 33725                                  ;;	INPUTS:    Access to $M_RES_ADDRESSES
 33726                                  ;;	OUTPUTS:   IF CX = 0 THEN Message was not found
 33727                                  ;;		   IF CX > 1 THEN ES:DI points to the specified message
 33728                                  ;;	REGS CHANGED: ES,DI,CX
 33729                                  ;;
 33730                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33731                                  
 33732                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33733                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33734                                  $M_GET_MSG_ADDRESS:
 33735 000056E6 56                      	push	si				;;AN000;;
 33736 000056E7 53                      	push	bx				;;AN000;;
 33737 000056E8 31F6                    	xor	si,si				;;AN000;; Use SI as an index
 33738 000056EA 31C9                    	xor	cx,cx				;;AN000;; Use CX as an size
 33739                                  $MDO36:
 33740 000056EC 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Were utility messages requested?
 33741 000056EF 7508                    	jne	short $MIF37			;;AN000;; No
 33742                                  
 33743                                  	; 07/04/2023
 33744                                  	;;mov	di,[si+89CAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33745 000056F1 8BBC[6B9A]              	mov	di,[si+$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS]
 33746                                  	;mov	di,[si+$M_RT+44]		;;AN000;; Get address of class
 33747 000056F5 89FB                    	mov	bx,di				;;AN000;;
 33748 000056F7 EB21                    	jmp	short $MEN37
 33749                                  $MIF37:
 33750 000056F9 F6C602                  	test	dh,2 ; parse_err_class		;;AN000;; Were parse errors requested?
 33751 000056FC 7406                    	jz	short $MIF39
 33752                                  	
 33753                                  	; 07/04/2023
 33754                                  	;;les	di,[si+89AEh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33755 000056FE C4BC[4F9A]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND]
 33756                                  	;les	di,[si+$M_RT+16]		;;AN000;; Get address of class
 33757                                  
 33758                                  	; 07/04/2023
 33759                                  	;mov	bx,es ; *			;;AN000;;
 33760 00005702 EB14                    	jmp	short $MEN39
 33761                                  $MIF39:
 33762 00005704 83F813                  	cmp	ax,19 ; $M_CRIT_LO		;;AN000;; Is this a critical error?
 33763 00005707 720B                    	jnae	short $MIF41  ; jb short $MIF41 ;;AN000;;
 33764                                  
 33765 00005709 83F827                  	cmp	ax,39 ; $M_CRIT_HI		;;AN000;;
 33766 0000570C 7706                    	jnbe	short $MIF41  ; ja short $MIF41 ;;AN000;;
 33767                                  
 33768                                  	; 07/04/2023
 33769                                  	;;les	di,[si+89BAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33770 0000570E C4BC[5B9A]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS]
 33771                                  	;les	di,[si+$M_RT+28]		;;AN000;; Get address of class
 33772                                  	
 33773                                  	; 07/04/2023
 33774                                  	;mov	bx,es ; *			;;AN000;;
 33775 00005712 EB04                    	jmp	short $MEN41
 33776                                  $MIF41:
 33777                                  	; 07/04/2023
 33778                                  	;;les	di,[si+899Eh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33779 00005714 C4BC[3F9A]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS]
 33780                                  	;les	di,[si+$M_RT+0]			;;AN000;; Get address of class
 33781                                  	
 33782                                  	; 07/04/2023
 33783                                  	;mov	bx,es ; *			;;AN000;;
 33784                                  $MEN41:
 33785                                  $MEN39:
 33786                                  	; 07/04/2023
 33787 00005718 8CC3                    	mov	bx,es ; *
 33788                                  $MEN37:						;;AN000;;
 33789 0000571A 83FBFF                  	cmp	bx,-1 ; $M_TERMINATING_FLAG	;;AN000;; Are we finished all classes?
 33790 0000571D 7515                    	jne	short $MIF46			;;AN000;; No
 33791                                  
 33792 0000571F 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Was it a UTILITY class?
 33793 00005722 7503                    	jne	short $MIF47			;;AN000;; No
 33794 00005724 F9                      	stc		     ; **-		;;AN000;; Set the carry flag
 33795                                  	; 07/04/2023
 33796                                  	;jmp	short $MEN47 ; **-
 33797 00005725 EB1B                    	jmp	short $MEN36 ; **-
 33798                                  $MIF47:
 33799 00005727 A3[879A]                	mov	[$M_RT+$M_RES_ADDRS.$M_MSG_NUM],ax
 33800                                  	;mov	[$M_RT+72],ax			;;AN000;; Save message number
 33801 0000572A B8FFFF                  	mov	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN000;; Set special message number
 33802 0000572D BD0100                  	mov	bp,1 ; $M_ONE_REPLACE		;;AN000;; Set one replace in message
 33803 00005730 31F6                    	xor	si,si				;;AN000;; Reset the SI index to start again
 33804                                  	; 28/04/2023
 33805                                  	; 07/04/2023
 33806                                  	;clc	; **+				;;AN000;;
 33807                                  ;$MEN47:
 33808                                  	;jmp	short $MEN46 ; ***
 33809 00005732 EB0A                    	jmp	short $MEN47 ; ***
 33810                                  $MIF46:
 33811                                  	;cmp	bx,0 ; $M_CLASS_NOT_EXIST	;;AN000;; Does this class exist?
 33812 00005734 21DB                    	and	bx,bx ; 0 ?
 33813 00005736 7403                    	jz	short $MIF51			;;AN000;; No
 33814                                  	
 33815 00005738 E84D00                  	call	$M_FIND_SPECIFIED_MSG		;;AN000;; Try to find the message
 33816                                  $MIF51:
 33817 0000573B 83C604                  	add	si,4 ; $M_ADDR_SZ_FAR 		;;AN000;; Get next class
 33818                                  	; 07/04/2023
 33819                                  	;clc					;;AN000;;
 33820                                  ;$MEN46:
 33821                                  	;jc	short $MEN36 ; **- ; **+	;;AN000;;
 33822                                  $MEN47:	; 07/04/2023	; **+
 33823 0000573E 09C9                    	or	cx,cx				;;AN000;; Was the message found?
 33824                                  	;jnz	short $MXL2			;;AN000;; Yes
 33825                                  	;jmp	short $MDO36
 33826                                  	; 07/04/2023
 33827 00005740 74AA                    	jz	short $MDO36	
 33828                                  $MXL2:
 33829                                  $MEN36:
 33830 00005742 9C                      	pushf 					;;AN006;; Save the flag state
 33831                                  	
 33832 00005743 80FE01                  	cmp	dh,1 ; EXT_ERR_CLASS		;;AN006;; Was an extended error requested?
 33833                                  	;jne	short $MIF56			;;AN006;; No
 33834                                  	; 28/04/2023
 33835 00005746 752A                    	jne	short $M_MYRET	
 33836                                  
 33837 00005748 52                      	push	dx				;;AN006;; Save all needed registers
 33838 00005749 55                      	push	bp				;;AN006;;
 33839 0000574A 51                      	push	cx				;;AN006;;
 33840 0000574B 06                      	push	es				;;AN006;;
 33841 0000574C 57                      	push	di				;;AN006;;
 33842 0000574D 50                      	push	ax				;;AN006;;
 33843                                  
 33844 0000574E B80005                  	mov	ax,500h ; IFSFUNC_INSTALL_CHECK	;;AN006;; Check if IFSFUNC is installed
 33845 00005751 CD2F                    	int	2Fh				;;AN006;;
 33846                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
 33847                                  		; Return: AL = 00h not installed, OK to install
 33848                                  		; 01h not installed, can't install
 33849                                  		; FFh installed
 33850                                  
 33851 00005753 3CFF                    	cmp	al,0FFh ; IFSFUNC_INSTALLED	;;AN006;; Is it installed?
 33852 00005755 58                      	pop	ax				;;AN006;; Restore msg number
 33853 00005756 7513                    	jne	short $MIF57			;;AN006;; No (not installed)
 33854                                  
 33855 00005758 89C3                    	mov	bx,ax				;;AN006;; BX is the extended error number
 33856 0000575A B80205                  	mov	ax,502h ; IFS_GET_ERR_TEXT	;;AN006;; AX is the muliplex number
 33857 0000575D CD2F                    	int	2Fh				;;AN006;; Call IFSFUNC
 33858                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER
 33859                                  
 33860                                  	;jmp	short $MEN57			;;AN006;;
 33861                                  	; 28/04/2023
 33862 0000575F 720B                    	jc	short $MEN57
 33863                                  $MIF60:
 33864 00005761 83C406                  	add	sp,6				;;AN006;; Throw away old pointer
 33865 00005764 E81200                  	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 33866                                  $MEN60:
 33867 00005767 5D                      	pop	bp				;;AN006;; Restore other Regs
 33868 00005768 5A                      	pop	dx				;;AN006;;
 33869                                  $MIF56:
 33870                                  	; 07/04/2023
 33871                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33872 00005769 EB07                    	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 33873                                  
 33874                                  $MIF57:
 33875 0000576B F9                      	stc					;;AN006;; Carry conditon
 33876                                  $MEN57:
 33877                                  	; 28/04/2023
 33878                                  	;jnc	short $MIF60			;;AN006;;
 33879                                  
 33880 0000576C 5F                      	pop	di				;;AN006;;
 33881 0000576D 07                      	pop	es				;;AN006;; Restore old pointer
 33882 0000576E 59                      	pop	cx				;;AN006;;
 33883 0000576F EBF6                    	jmp	short $MEN60
 33884                                  
 33885                                  ;$MIF60:
 33886                                  ;	add	sp,6				;;AN006;; Throw away old pointer
 33887                                  ;	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 33888                                  ;$MEN60:
 33889                                  ;	pop	bp				;;AN006;; Restore other Regs
 33890                                  ;	pop	dx				;;AN006;;
 33891                                  ;$MIF56:
 33892                                  ;	; 07/04/2023
 33893                                  ;	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33894                                  ;	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 33895                                  
 33896                                  ; 07/04/2023
 33897                                  ; ---------------------------
 33898                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33899                                  ; ---------------------------
 33900                                  	; $M_POPF macro
 33901                                  	;jmp	short $+3
 33902                                  m_popf_iret:
 33903 00005771 CF                      	iret
 33904                                  $M_MYRET:
 33905 00005772 0E                      	push	cs
 33906 00005773 E8FBFF                  	call	m_popf_iret
 33907                                  	;;; end macro	
 33908                                  ; ---------------------------
 33909                                  
 33910 00005776 5B                      	pop	bx				;;AN000;;
 33911 00005777 5E                      	pop	si				;;AN000;;
 33912 00005778 C3                      	retn					;;AN000;; Return ES:DI pointing to the message
 33913                                  
 33914                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33915                                  
 33916                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33917                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33918                                  $M_SET_LEN_IN_CX:			
 33919 00005779 57                      	push	di				;;AN006;; Save position
 33920 0000577A 50                      	push	ax				;;AN006;;
 33921 0000577B B9FFFF                  	mov	cx,-1 ; 65535 ; 0FFFFh		;;AN006;; Set CX for decrements
 33922 0000577E 30C0                    	xor	al,al				;;AN006;; Prepare compare register
 33923 00005780 F2AE                    	repne	scasb				;;AN006;; Scan for zero
 33924 00005782 F7D1                    	not	cx				;;AN006;; Change decrement into number
 33925 00005784 49                      	dec	cx				;;AN006;; Don't include the zero
 33926 00005785 58                      	pop	ax				;;AN006;;
 33927 00005786 5F                      	pop	di				;;AN006;; Restore position
 33928 00005787 C3                      	retn					;;AN006;;
 33929                                  
 33930                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33931                                  ;;
 33932                                  ;;	PROC NAME: $M_FIND_SPECIFIED_MSG
 33933                                  ;;
 33934                                  ;;	FUNCTION:  To scan thru message headers until message is found
 33935                                  ;;	INPUTS:    ES:DI points to beginning of msg headers
 33936                                  ;;		   CX contains the number of messages in class
 33937                                  ;;		   DH contains the message class
 33938                                  ;;	OUPUTS:    IF CX = 0 THEN Message was not found
 33939                                  ;;		   IF CX > 1 THEN ES:DI points to header of specified message
 33940                                  ;;
 33941                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33942                                  
 33943                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33944                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33945                                  $M_FIND_SPECIFIED_MSG:
 33946 00005788 83FB01                  	cmp	bx,1				;;AN004;; Do we have an address to CALL?
 33947 0000578B 751F                    	jne	short $MIF64
 33948 0000578D 833E[679A]FF            	cmp	word [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],-1
 33949                                  	;cmp	word [$M_RT+40],-1 ; 0FFFFh	;;AN004;; Do we have an address to CALL?
 33950                                  	; 15/06/2023
 33951 00005792 7418                    	je	short $MIF64
 33952                                  
 33953 00005794 83F8FF                  	cmp	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN004;; Are we displaying a default Ext Err?
 33954 00005797 750B                    	jne	short $MIF65
 33955                                  	
 33956 00005799 50                      	push	ax				;;AN004;; Reset the special message number
 33957 0000579A A1[879A]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 33958                                  	;mov	ax,[$M_RT+72]			;;AN004;; Get the old message number
 33959 0000579D FF1E[679A]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33960                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33961 000057A1 58                      	pop	ax				;;AN004;; Reset the special message number
 33962                                  	; 28/04/2023
 33963 000057A2 EB04                    	jmp	short $MEN65
 33964                                  	; 18/04/2023
 33965                                  	;jmp	short $MEN64
 33966                                  $MIF65:
 33967 000057A4 FF1E[679A]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33968                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33969                                  $MEN65:
 33970                                  	; 28/04/2023
 33971 000057A8 7344                    	jnc	short $MIF75
 33972                                  	;
 33973 000057AA EB19                    	jmp	short $MEN64 ; $MDO76		;;AN004;;
 33974                                  $MIF64:
 33975 000057AC 31C9                    	xor	cx,cx				;;AN002;; CX = 0 will allow us to
 33976 000057AE 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 33977 000057B1 7406                    	je	short $MIF69
 33978                                  	
 33979 000057B3 268A4D03                	mov	cl,[es:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33980                                  	;mov	cl,[es:di+3]			;;AN001;; Get number of messages in class
 33981 000057B7 EB09                    	jmp	short $MEN69
 33982                                  $MIF69:
 33983                                  	;cmp	[cs:di+$M_CLASS_ID.$M_CLS_ID],dh
 33984                                  	;cmp	[cs:di+0],dh
 33985 000057B9 2E3835                  	cmp	[cs:di],dh			;;AN002;; Check if class still exists at
 33986 000057BC 7504                    	jne	short $MIF71
 33987                                  
 33988 000057BE 2E8A4D03                	mov	cl,[cs:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33989                                  	;mov	cl,[cs:di+3]			;;AN000;; Get number of messages in class
 33990                                  $MIF71:						;;AN001;;
 33991                                  $MEN69:
 33992 000057C2 83C704                  	add	di,$M_CLASS_ID_SZ ; add di,4	;;AN000;; Point past the class header
 33993                                  	; 02/05/2023
 33994                                  	;stc					;;AN004;; Flag that we haven't found anything yet
 33995                                  $MEN64:
 33996                                  	;jnc	short $MIF75
 33997                                  	; 28/04/2023
 33998                                  	; (or instruction clears carry flag)
 33999                                  	;clc					;;AN004;; No, reset carry
 34000                                  $MDO76:
 34001 000057C5 09C9                    	or	cx,cx				;;AN000;; Do we have any to check?
 34002 000057C7 7417                    	jz	short $MEN76
 34003                                  
 34004 000057C9 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 34005 000057CC 7405                    	je	short $MIF78
 34006                                  
 34007                                  	;cmp	ax,[es:di+$M_ID.$M_NUM]		;;AN001;; Is this the message requested?
 34008 000057CE 263B05                  	cmp	ax,[es:di]
 34009 000057D1 EB03                    	jmp	short $MEN78
 34010                                  $MIF78:
 34011                                  	;cmp	ax,[cs:di+$M_ID.$M_NUM]		;;AN000;; Is this the message requested?
 34012 000057D3 2E3B05                  	cmp	ax,[cs:di]
 34013                                  $MEN78:
 34014                                  	;jne	short $MIF76
 34015                                  	;jmp	short $MSR76
 34016                                  	; 07/04/2023
 34017 000057D6 740B                    	je	short $MSR76 ; *
 34018                                  $MIF76:
 34019 000057D8 49                      	dec	cx				;;AN000;; No, well do we have more to check?
 34020 000057D9 7405                    	jz	short $MEN76
 34021                                  
 34022 000057DB 83C704                  	add	di,$M_ID_SZ ; add di,4		;;AN000;; Yes, skip past msg header
 34023 000057DE EBE5                    	jmp	short $MDO76			;;AN000;;
 34024                                  $MEN76:
 34025 000057E0 F9                      	stc					;;AN000;;
 34026                                  ;$MSR76:	; 07/04/2023
 34027                                  	;jc	short $MIF86			;;AN000;;
 34028                                  	; 07/04/2023
 34029                                  	;jc	short $MIF91
 34030 000057E1 EB11                    	jmp	short $MIF91 ;*
 34031                                  $MSR76:	; 07/04/2023 ; *	
 34032 000057E3 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;; Yes, is it a utility message?
 34033                                  	; 07/04/2023
 34034                                  	;clc					;;AN001;;
 34035 000057E6 7502                    	jne	short $MIF87
 34036                                  
 34037 000057E8 0E                      	push	cs				;;AN000;;
 34038 000057E9 07                      	pop	es				;;AN000;; Return ES:DI pointing to the message
 34039                                  $MIF87:
 34040                                  	;add	di,[es:di+2]
 34041 000057EA 26037D02                	add	di,[es:di+$M_ID.$M_TXT_PTR]     ;;AN000;; Prepare ES:DI pointing to the message
 34042                                  $MIF86:
 34043                                  ;$MIF75:
 34044                                  	; 02/05/2023
 34045                                  	;jc	short $MIF91
 34046                                  $MIF75:	; 28/04/2023
 34047 000057EE 30ED                    	xor	ch,ch				;;AN000;;
 34048 000057F0 268A0D                  	mov	cl,[es:di]			;;AN000;; Move size into CX
 34049 000057F3 47                      	inc	di				;;AN000;; Increment past length
 34050                                  $MIF91:
 34051 000057F4 C606[819A]00            	mov	byte [$M_RT+$M_RES_ADDRS.$M_SIZE],0 ; $M_NULL
 34052                                  	;mov	byte [$M_RT+66],0		;;AN004;; Reset variable
 34053 000057F9 C3                      	retn					;;AN000;; Return
 34054                                  
 34055                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34056                                  ;;
 34057                                  ;;  Proc Name:	SYSDISPMSG
 34058                                  ;;
 34059                                  ;;  Function:	The DISPLAY service will output a defined message to a handle
 34060                                  ;;		requested by the caller. It also provides function to display
 34061                                  ;;		messages when handles are not applicable (ie. DOS function calls
 34062                                  ;;		00h to 0Ah) Replaceable parameters are allowed and are
 34063                                  ;;		defined previous to entry.
 34064                                  ;;
 34065                                  ;;		It is assumes that a PRELOAD function has already determined
 34066                                  ;;		the addressibilty internally to the message retriever services.
 34067                                  ;;  Inputs:
 34068                                  ;;
 34069                                  ;;  Outputs:
 34070                                  ;;
 34071                                  ;;  Psuedocode:
 34072                                  ;;		Save registers needed later
 34073                                  ;;		Get address of the message requested
 34074                                  ;;		IF Message number exists THEN
 34075                                  ;;		  IF replacable parameters were specified THEN
 34076                                  ;;		     Display message with replacable parms
 34077                                  ;;		  ELSE
 34078                                  ;;		     Display string without replacable parms
 34079                                  ;;		  ENDIF
 34080                                  ;;		  IF character input was requested THEN
 34081                                  ;;		     Wait for character input
 34082                                  ;;		  ENDIF
 34083                                  ;;		  Clear CARRY FLAG
 34084                                  ;;		ELSE
 34085                                  ;;		   Set CARRY FLAG
 34086                                  ;;		ENDIF
 34087                                  ;;		Return
 34088                                  ;;
 34089                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34090                                  
 34091                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34092                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5307h
 34093                                  	;
 34094                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34095                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5ACBh
 34096                                  SYSDISPMSG:
 34097                                  	;; Save registers and values needed later
 34098 000057FA 50                      	push	ax				;;AN000;; Save changed REGs
 34099 000057FB 53                      	push	bx				;;AN000;;
 34100 000057FC 51                      	push	cx				;;AN000;;
 34101 000057FD 55                      	push	bp				;;AN000;;
 34102 000057FE 57                      	push	di				;;AN000;; Save pointer to input buffer (offset)
 34103 000057FF 06                      	push	es				;;AN000;; Save pointer to input buffer (segment)
 34104 00005800 52                      	push	dx				;;AN000;; Save Input/Class request
 34105                                  
 34106 00005801 89CD                    	mov	bp,cx				;;AN000;; Use BP to hold replace count
 34107 00005803 891E[7F9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_HANDLE],bx
 34108                                  	;mov	[$M_RT+64],bx			;;AN000;; Save handle
 34109 00005807 8836[849A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS],dh
 34110                                  	;mov	[$M_RT+69],dh			;;AN004;; Save class
 34111                                  
 34112                                  	;; Get address of the message requested
 34113 0000580B E8D8FE                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 34114                                  
 34115 0000580E 09C9                    	or	cx,cx				;;AN000;; Was message found?
 34116 00005810 7427                    	jz	short $MIF93
 34117                                  						;;AN000;; Yes, Message address in ES:DI
 34118                                  	
 34119                                  	;; Test if replacable parameters were specified
 34120 00005812 09ED                    	or	bp,bp				;;AN000;; Were replacable parameters requested
 34121 00005814 7505                    	jnz	short $MIF94
 34122                                  
 34123                                  	;; Display string without replacable parms
 34124 00005816 E82800                  	call	$M_DISPLAY_STRING		;;AN000;; No, great . . . Display message
 34125 00005819 EB03                    	jmp	short $MEN94
 34126                                  $MIF94:
 34127                                  	;; Display message with replacable parms
 34128 0000581B E88B01                  	call	$M_DISPLAY_MESSAGE		;;AN000;; Display the message with substitutions
 34129                                  $MEN94:
 34130 0000581E 7214                    	jc	short $MIF97
 34131 00005820 5A                      	pop	dx				;;AN000;; Get Input/Class request
 34132 00005821 E8FC00                  	call	$M_ADD_CRLF 			;;AN004;; Check if we need to add the CR LF chars.
 34133 00005824 07                      	pop	es				;;AN000;; Get location of input buffer (if specified)
 34134 00005825 5F                      	pop	di				;;AN000;;
 34135                                  	
 34136                                  ; 15/06/2023 - MSDOS 5.0
 34137                                  ;	;jmp	short $MEN97 ; ***
 34138                                  ;	; 08/04/2023
 34139                                  ;	;jmp	short $MEN93 ; **
 34140                                  ;
 34141                                  ;	; 08/04/2023
 34142                                  ;;$MEN93:
 34143                                  ;	jc	short $MIF104
 34144                                  
 34145                                  	; 15/06/2023 Retro DOS v4.2 COMMAND.COM
 34146                                   	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5AF7h
 34147                                  
 34148                                  	; MSDOS 6.0 (MSDOS 6.22)
 34149                                  	; Test if character input was requested	;;AN000;;
 34150 00005826 08D2                    	or	dl,dl
 34151 00005828 7403                    	jz	short $MIF98
 34152                                  	;jz	short $MEN98 ; *
 34153                                  
 34154 0000582A E88E05                  	call	$M_WAIT_FOR_INPUT	; MSDOS 6.0 (to 6.22)
 34155                                  	; cf = 0 ; *
 34156                                  $MIF98:
 34157                                  	;jmp	short $MEN97
 34158                                  	;;jc	short $MIF104 ; *
 34159                                  $MEN98:
 34160                                  ;$MEN97:
 34161 0000582D 5D                      	pop	bp				;;AN000;;
 34162 0000582E 59                      	pop	cx				;;AN000;;
 34163 0000582F 5B                      	pop	bx				;;AN000;;
 34164                                  	; 15/06/2023
 34165                                  	;pop	ax	; MSDOS 5.0		;;AN000;;
 34166 00005830 83C402                  	add	sp,2	; MSDOS 6.0 (to 6.22)
 34167 00005833 C3                      	retn
 34168                                   
 34169                                  $MIF97:
 34170                                  	; 08/04/2023
 34171                                  	;add	sp,6				;;AN000;;
 34172                                  	;stc					;;AN000;; Reset carry flag
 34173                                  ;$MEN97: ; ***
 34174                                  	;jmp	short $MEN93
 34175                                  	; 08/04/2023
 34176                                  	;jmp	short $MIF104
 34177                                  	; 08/04/2023
 34178 00005834 83C40E                  	add	sp,14 ; 6+8
 34179 00005837 F9                      	stc
 34180 00005838 C3                      	retn
 34181                                  $MIF93:
 34182                                  	; 08/04/2023 - 15/06/2023
 34183                                  	; (wrong pops ?) - correct order: pop dx, pop es, pop di -
 34184                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:533Bh
 34185                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5B06h
 34186 00005839 07                      	pop	es				;;AN000;; Get pointer to input buffer (segment)
 34187 0000583A 5F                      	pop	di				;;AN000;; Get base pointer to first sublist (offset)
 34188 0000583B 5A                      	pop	dx				;;AN000;; Get base pointer to first sublist (segment)
 34189                                  	;stc	; * 				;;AN000;; Set carry flag
 34190                                  	; 08/04/2023
 34191                                  	;jmp	short $MIF104 ; *
 34192                                  
 34193                                  ;$MEN93: ; **
 34194                                  ;	jc	short $MIF104
 34195                                  ;$MEN97: ; 08/04/2023
 34196                                  ;	pop	bp				;;AN000;;
 34197                                  ;	pop	cx				;;AN000;;
 34198                                  ;	pop	bx				;;AN000;;
 34199                                  ;	pop	ax				;;AN000;;
 34200                                  ;	;jmp	short $MEN104
 34201                                  ;	; 08/04/2023
 34202                                  ;	retn
 34203                                  
 34204                                  $MIF104: ; *
 34205 0000583C 83C408                  	add	sp,8				;;AN000;; Eliminate from stack
 34206 0000583F F9                      	stc					;;AN000;;
 34207                                  $MEN104:
 34208 00005840 C3                      	retn					;;AN000;; Return
 34209                                  
 34210                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34211                                  ;;
 34212                                  ;;	PROC NAME: $M_DISPLAY_STRING
 34213                                  ;;
 34214                                  ;;	FUNCTION:  Will display or write string
 34215                                  ;;	INPUTS:    ES:DI points to beginning of message
 34216                                  ;;		   CX contains the length of string to write (if applicable)
 34217                                  ;;	OUTPUTS:   None
 34218                                  ;;	REGS Revised: None
 34219                                  ;;
 34220                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34221                                  
 34222                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34223                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34224                                  $M_DISPLAY_STRING:
 34225 00005841 50                      	push	ax				;;AN000;;
 34226 00005842 53                      	push	bx				;;AN000;;
 34227 00005843 52                      	push	dx				;;AN000;;
 34228 00005844 8B1E[7F9A]              	mov	bx,[$M_RT+$M_RES_ADDRS.$M_HANDLE]
 34229                                  	;mov	bx,[$M_RT+64]			;;AN000;; Retrieve handle
 34230                                  	
 34231 00005848 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE 	;;AN000;; Was there a handle specified?
 34232 0000584B 7505                    	jne	short $MIF107
 34233                                  
 34234 0000584D E82600                  	call	$M_DISPLAY_$_STRING		;;AN000;; No, display $ terminated string
 34235 00005850 EB03                    	jmp	short $MEN107
 34236                                  $MIF107:
 34237 00005852 E86E00                  	call	$M_DISPLAY_H_STRING		;;AN000;; Yes, display string to handle
 34238                                  $MEN107:
 34239 00005855 730D                    	jnc	short $MIF110
 34240                                  	
 34241 00005857 B459                    	mov	ah,59h	; DOS_GET_EXT_ERROR	;;AN000;;
 34242                                  	;mov	bx,0	; DOS_GET_EXT_ERROR_BX	;;AN000;; Get extended error
 34243                                  	; 08/04/2023
 34244 00005859 31DB                    	xor	bx,bx
 34245 0000585B CD21                    	int	21h				;;AN000;;
 34246                                  		; DOS - 3+ - GET EXTENDED ERROR CODE
 34247                                  		; BX = version code (0000h for DOS 3.x)
 34248 0000585D 30E4                    	xor	ah,ah				;;AN000;; Clear AH
 34249                                  $MEN110: ; 08/04/2023 ; ***
 34250 0000585F 83C406                  	add	sp,6				;;AN000;; Clean up stack
 34251 00005862 F9                      	stc					;;AN000;; Flag that there was an error
 34252                                  	;jmp	short $MEN110 ; ****
 34253                                  	; 08/04/2023
 34254 00005863 C3                      	retn
 34255                                  $MIF110:
 34256                                  	;cmp	bx,$M_NO_HANDLE
 34257 00005864 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE	;;AN000;; Was there a handle specified?
 34258 00005867 7409                    	je	short $MIF112 ; *  ; cf = 0
 34259 00005869 39C8                    	cmp	ax,cx				;;AN001;; Was it ALL written?
 34260 0000586B 7405                    	je	short $MIF113 ; ** ; cf = 0
 34261 0000586D E8A700                  	call	$M_GET_EXT_ERR_39		;;AN001;; Set Extended error
 34262                                  	;add	sp,6				;;AN001;; Clean up stack
 34263                                  	;stc					;;AN001;; Flag that there was an error
 34264                                  	; 08/04/2023
 34265 00005870 EBED                    	jmp	short $MEN110 ; ***
 34266                                  	; 08/04/2023
 34267                                  ;$MIF112:
 34268                                  ;$MEN110: ; ****
 34269                                  	;jc	short $MIF117
 34270                                  $MIF112: ; 08/04/2023	; *
 34271                                  $MIF113:	; **
 34272 00005872 5A                      	pop	dx				;;AN000;; Restore regs
 34273 00005873 5B                      	pop	bx				;;AN000;;
 34274 00005874 58                      	pop	ax				;;AN000;;
 34275                                  $MIF117:
 34276 00005875 C3                      	retn
 34277                                  
 34278                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34279                                  ;;
 34280                                  ;;	PROC NAME: $M_DISPLAY_$_STRING
 34281                                  ;;
 34282                                  ;;	FUNCTION:  Will display a $ terminated string
 34283                                  ;;	INPUTS:    ES:DI points to beginning of message text (not the length)
 34284                                  ;;	OUTPUTS:   None
 34285                                  ;;	REGS USED: AX,DX
 34286                                  ;;
 34287                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34288                                  
 34289                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34290                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34291                                  $M_DISPLAY_$_STRING:
 34292 00005876 1E                      	push	ds				;;AN000;;
 34293 00005877 06                      	push	es				;;AN000;;
 34294 00005878 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 34295                                  
 34296                                  	; 08/04/2023
 34297 00005879 B402                    	mov	ah,2 ; DOS_DISP_CHAR
 34298                                  
 34299                                  	;cmp	cx,$M_SINGLE_CHAR		;;AN000;; Is this a single character?
 34300 0000587B 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR
 34301 0000587E 7518                    	jne	short $MIF119			;;AN000;; No
 34302                                  	
 34303                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 34304 00005880 268A15                  	mov	dl,[es:di]			;;AN000;; Get the character
 34305 00005883 CD21                    	int	21h				;;AN000;; Write character
 34306                                  		; DOS - DISPLAY OUTPUT
 34307                                  		; DL = character to send to standard output
 34308 00005885 1F                      	pop	ds				;;AN000;;
 34309 00005886 88D0                    	mov	al,dl				;;AN000;; Get the character in AL
 34310 00005888 E8AC00                  	call	$M_IS_IT_DBCS 			;;AN000;; Is this the first byte of a DB character
 34311 0000588B 1E                      	push	ds				;;AN000;;
 34312 0000588C 06                      	push	es				;;AN000;;
 34313 0000588D 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 34314 0000588E 7316                    	jnc	short $MIF120 ; *
 34315                                  
 34316 00005890 268A5501                	mov	dl,[es:di+1]			;;AN000;; Get the next character
 34317 00005894 CD21                    	int	21h				;;AN000;; Write character
 34318                                  		; DOS - DISPLAY OUTPUT
 34319                                  		; DL = character to send to standard output
 34320                                  	; 08/04/2023
 34321                                  	;clc					;;AN000;; Clear the DBCS indicator
 34322                                  ;$MIF120:
 34323 00005896 EB0D                    	jmp	short $MEN119
 34324                                  $MIF119:
 34325                                  	; 08/04/2023
 34326                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 34327                                  ;$MDO123:
 34328 00005898 09C9                    	or	cx,cx				;;AN002;; Are there any left to display?
 34329                                  	;jz	short $MEN123
 34330                                  	; 18/04/2023
 34331 0000589A 740A                    	jz	short $MIF120 ; cf = 0
 34332                                  $MDO123: ; 08/04/2023
 34333 0000589C 268A15                  	mov	dl,[es:di]			;;AN002;; Get the character
 34334 0000589F CD21                    	int	21h				;;AN002;; Display the character
 34335                                  		; DOS - DISPLAY OUTPUT
 34336                                  		; DL = character to send to standard output
 34337 000058A1 47                      	inc	di				;;AN002;; Set pointer to next character
 34338 000058A2 49                      	dec	cx				;;AN002;; Count this character
 34339 000058A3 75F7                    	jnz	short $MDO123
 34340                                  ;$MEN123:
 34341                                  $MEN119:
 34342 000058A5 F8                      	clc					;;AN000;;Char functions used don't return carry as error
 34343                                  $MIF120: ; 08/04/2023 ; *
 34344 000058A6 1F                      	pop	ds				;;AN000;;
 34345 000058A7 C3                      	retn
 34346                                  
 34347                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34348                                  ;;
 34349                                  ;; Scan_ctrlZ: This routine looks through the string to be printed and 
 34350                                  ;; truncates it at the Ctrl-Z if any present.
 34351                                  ;;
 34352                                  ;;	ENTRY:	ds:dx = String to be displayed
 34353                                  ;;		cx = number of chars to be displayed
 34354                                  ;;
 34355                                  ;;	EXIT:	cx = number of chars to be displayed
 34356                                  ;;
 34357                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34358                                  
 34359                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34360                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34361                                  scan_ctrlz:
 34362 000058A8 57                      	push	di
 34363 000058A9 50                      	push	ax
 34364 000058AA 06                      	push	es
 34365 000058AB 53                      	push	bx
 34366                                  
 34367 000058AC 89D7                    	mov	di,dx
 34368 000058AE 1E                      	push	ds
 34369 000058AF 07                      	pop	es   			;es:di points at string
 34370                                  
 34371 000058B0 89CB                    	mov	bx,cx			;save current count
 34372                                  
 34373 000058B2 B01A                    	mov	al,1Ah	; Ctrl-Z
 34374 000058B4 FC                      	cld
 34375 000058B5 F2AE                    	repne	scasb			;find first Ctrl-Z
 34376 000058B7 7503                    	jnz	short noCtrlZ		;no CtrlZ found in string
 34377                                  
 34378 000058B9 29CB                    	sub	bx,cx
 34379 000058BB 4B                      	dec	bx			;bx = new count to display
 34380                                  noCtrlZ:
 34381 000058BC 89D9                    	mov	cx,bx			;cx = actual display count
 34382                                  
 34383 000058BE 5B                      	pop	bx
 34384 000058BF 07                      	pop	es
 34385 000058C0 58                      	pop	ax
 34386 000058C1 5F                      	pop	di
 34387                                  $MIF127:	; 08/04/2023
 34388 000058C2 C3                      	retn
 34389                                  
 34390                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34391                                  ;;
 34392                                  ;;	PROC NAME: $M_DISPLAY_H_STRING
 34393                                  ;;
 34394                                  ;;	FUNCTION:  Will display a string to a specified handle
 34395                                  ;;	INPUTS:    ES:DI points to beginning of message
 34396                                  ;;		   CX contains the number of bytes to write
 34397                                  ;;		   BX contains the handle to write to
 34398                                  ;;	OUPUTS:    None
 34399                                  ;;	REGS USED: AX,DX
 34400                                  ;;
 34401                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34402                                  
 34403                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34404                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34405                                  $M_DISPLAY_H_STRING:
 34406 000058C3 31C0                    	xor	ax,ax			;;AN002;; Set number of bytes written to 0
 34407 000058C5 09C9                    	or	cx,cx			;;AN002;; For performance, don't write if not necessary
 34408 000058C7 74F9                    	jz	short $MIF127
 34409                                  	
 34410 000058C9 1E                      	push	ds			;;AN000;;
 34411 000058CA 06                      	push	es			;;AN000;;
 34412 000058CB 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 34413                                  	
 34414 000058CC B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 34415 000058CE 89FA                    	mov	dx,di			;;AN000;; Pointer to data to write
 34416                                  
 34417 000058D0 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR	;;AN000;; Is this a single character?
 34418 000058D3 7528                    	jne	short $MIF128		;;AN000;; No
 34419                                  
 34420 000058D5 CD21                    	int	21h			;;AN000;; Write character
 34421                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 34422                                  		; BX = file handle, CX = number of bytes to writ
 34423                                  
 34424 000058D7 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 34425 000058D8 50                      	push	ax			;;AN000;;
 34426 000058D9 268A05                  	mov	al,[es:di] 		;;AN000;; Get the character
 34427 000058DC E85800                  	CALL    $M_IS_IT_DBCS		;;AN000;; Is this the first byte of a DB character
 34428 000058DF 58                      	pop	ax			;;AN000;;
 34429 000058E0 1E                      	push	ds			;;AN000;;
 34430 000058E1 06                      	push	es			;;AN000;;
 34431 000058E2 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 34432 000058E3 7306                    	jnc	short $MIF129
 34433                                  	
 34434 000058E5 F8                      	clc				;;AN000;; Clear the DBCS indicator
 34435 000058E6 B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 34436 000058E8 42                      	inc	dx			;;AN000;; Point to next character
 34437 000058E9 CD21                    	int	21h			;;AN000;; Write character
 34438                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 34439                                  		; BX = file handle, CX = number of bytes to write, 
 34440                                  $MIF129:
 34441                                  ;SR;
 34442                                  ; If the single char happened to be a Ctrl-Z, the dos write would return
 34443                                  ;0 chars written making the caller think there was an error writing. To 
 34444                                  ;avoid this, we check if the single char was a Ctrl-Z and if so, return that
 34445                                  ;the char was written, thus fooling the caller.
 34446                                  
 34447 000058EB 9C                      	pushf				;save flags
 34448 000058EC 26803D1A                	cmp	byte [es:di],1Ah	;is char a Ctrl-Z?
 34449 000058F0 7502                    	jne	short m_popf_j		;no, continue
 34450                                  
 34451 000058F2 89C8                    	mov	ax,cx			;yes, fake as if it was written
 34452                                  m_popf_j:
 34453                                  	; 08/04/2023
 34454                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 34455 000058F4 EB01                    	jmp	short m_popf		;restore flags
 34456                                  
 34457                                  ; 07/04/2023
 34458                                  ; ---------------------------
 34459                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 34460                                  ; ---------------------------
 34461                                  	; $M_POPF macro
 34462                                  	;jmp	short $+3
 34463                                  intret:
 34464 000058F6 CF                      	iret
 34465                                  m_popf:
 34466 000058F7 0E                      	push	cs
 34467 000058F8 E8FBFF                  	call	intret
 34468                                  	;;; end macro	
 34469                                  ; ---------------------------
 34470                                  
 34471 000058FB EB18                    	jmp	short $MEN128
 34472                                  
 34473                                  $MIF128:
 34474                                  ;SR;
 34475                                  ; Prescan the string looking for Ctrl-Z. We terminate the message the moment 
 34476                                  ;we hit a Ctrl-Z. cx will contain the number of characters to be printed.
 34477                                  
 34478 000058FD 55                      	push	bp			; M007
 34479 000058FE 51                      	push	cx
 34480 000058FF E8A6FF                  	call	scan_ctrlz		;cx = count without Ctrl-Z
 34481 00005902 89CD                    	mov	bp,cx			;store no ^Z count in bp ;M007
 34482 00005904 59                      	pop	cx			;get old count back ;M007
 34483                                  	
 34484 00005905 CD21                    	int	21h			;;AN000;; Write String at DS:SI to handle
 34485                                  	;jnc	short chk_count		;no error, adjust return count
 34486                                  	;jmp	short m_cnt_ok		;error, return with carry set;M007
 34487                                  	; 08/04/2023
 34488 00005907 720B                    	jc	short m_cnt_ok 
 34489                                  ;M007
 34490                                  ; If we are writing to con and there is a Ctrl-Z in the string, the
 34491                                  ;return count will be much less and if this returns to the caller we can get
 34492                                  ;spurious error messages. We check here if the count returned is same as
 34493                                  ;original count or same as the count if we stop at Ctrl-Z. In the second
 34494                                  ;case, we fake it as if all bytes have been written. If the return count
 34495                                  ;does not match either count, then we had some other disk error (such as
 34496                                  ;insufficient disk space) and we pass it through
 34497                                  
 34498                                  chk_count:
 34499 00005909 39C1                    	cmp	cx,ax			;have all bytes been written?;M007
 34500 0000590B 7407                    	je	short m_cnt_ok		;there was an error writing ;M007
 34501 0000590D 39C5                    	cmp	bp,ax			;count = Ctrl-Z count? ;M007
 34502 0000590F F8                      	clc				;no error either way ;M007
 34503 00005910 7502                    	jne	short m_cnt_ok		;no, pass it through ;M007
 34504 00005912 89C8                    	mov	ax,cx			;return old count ;M007
 34505                                  m_cnt_ok:				; M007
 34506 00005914 5D                      	pop	bp			; M007
 34507                                  $MEN128:
 34508 00005915 1F                      	pop	ds			;;AN000;;
 34509                                  ;$MIF127: ; 08/04/2023
 34510 00005916 C3                      	retn
 34511                                  
 34512                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34513                                  ;;
 34514                                  ;;	PROC NAME: $M_GET_EXT_ERR_39
 34515                                  ;;
 34516                                  ;;	FUNCTION:  Will set registers for extended error #39
 34517                                  ;;	INPUTS:    None
 34518                                  ;;	OUPUTS:    AX,BX,CX set
 34519                                  ;;	REGS USED:
 34520                                  ;;
 34521                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34522                                  
 34523                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34524                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:542Dh
 34525                                  
 34526                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34527                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5BFAh
 34528                                  
 34529                                  $M_GET_EXT_ERR_39:
 34530 00005917 B82700                  	mov	ax,27h ; EXT_ERR_39	;AN001; Set AX=39
 34531                                  	;mov	bx,(ERROR_CLASS_39 SHR 8) + ACTION_39
 34532 0000591A BB0400                  	mov	bx,4			;AN001; Set BH=1 BL=4
 34533                                  	;mov	ch,LOCUS_39		;AN001; Set CH=1
 34534 0000591D B501                    	mov	ch,1			;AN001;
 34535 0000591F C3                      	retn				;AN001;
 34536                                  
 34537                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34538                                  ;;
 34539                                  ;;	PROC NAME: $M_ADD_CRLF
 34540                                  ;;
 34541                                  ;;	FUNCTION:  Will decide whether to display a CRLF
 34542                                  ;;	INPUTS:    DX contains the Input/Class requested
 34543                                  ;;	OUTPUTS:   None
 34544                                  ;;	REGS Revised: CX,ES,DI
 34545                                  ;;
 34546                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34547                                  
 34548                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34549                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34550                                  $M_ADD_CRLF:
 34551                                  	;cmp	dh,0FFh
 34552 00005920 80FEFF                  	cmp	dh,utility_msg_class	;;AN004;; Is it a utility message?
 34553 00005923 7411                    	je	short $MIF134		;;AN004;; Yes
 34554 00005925 F6C680                  	test	dh,80h; $M_NO_CRLF_MASK	;;AN004;; Are we to supress the CR LF?
 34555 00005928 750C                    	jnz	short $MIF135
 34556                                  					;;AN004;; No	
 34557 0000592A 1E                      	push	ds			;;AN004;;
 34558 0000592B 07                      	pop	es			;;AN004;; Set ES to data segment
 34559 0000592C 8D3E[829A]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_CRLF]
 34560                                  	;lea	di,[$M_RT+67]		;;AN004;; Point at CRLF message
 34561 00005930 B90200                  	mov	cx,2 ; $M_CRLF_SIZE	;;AN004;; Set the message size
 34562 00005933 E80BFF                  	call	$M_DISPLAY_STRING	;;AN004;; Display the CRLF
 34563                                  $MIF135:
 34564                                  $MIF134:
 34565 00005936 C3                      	retn				;;AN004;; Return
 34566                                  
 34567                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34568                                  ;;
 34569                                  ;;	PROC NAME: $M_IS_IT_DBCS
 34570                                  ;;
 34571                                  ;;	FUNCTION:  Will decide whether character is Single or Double Byte
 34572                                  ;;	INPUTS:    AL contains the byte to be checked
 34573                                  ;;	OUTPUTS:   Carry flag = 0 if byte is NOT in DBCS range
 34574                                  ;;		   Carry flag = 1 if byte IS in DBCS range
 34575                                  ;;	REGS USED: All restored
 34576                                  ;;
 34577                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34578                                  
 34579                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34580                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34581                                  $M_IS_IT_DBCS:
 34582 00005937 06                      	push	es			;;AN000;; Save Extra Segment register
 34583 00005938 57                      	push	di			;;AN000;; Save DI register
 34584                                  
 34585 00005939 C43E[7B9A]              	les	di,[$M_RT+$M_RES_ADDRS.$M_DBCS_VEC]
 34586                                  	;les	di,[$M_RT+60]		;;AN000;;
 34587 0000593D 09FF                    	or	di,di			;;AN000;; Was the DBCS vector set?
 34588 0000593F 7417                    	jz	short $MIF138		;;AN000;; No
 34589                                  $MDO139:
 34590 00005941 26833D00                	cmp	word [es:di],0 ; $M_DBCS_TERM
 34591                                  					;;AN000;; Is this the terminating flag?
 34592 00005945 F8                      	clc				;;AN000;;
 34593 00005946 7410                    	jz	short $MEN139
 34594                                  					;;AN000;; No
 34595 00005948 263A05                  	cmp	al,[es:di]		;;AN000;; Does the character fall in the DBCS range?
 34596 0000594B 7207                    	jnae	short $MIF141 ; jb	;;AN000;; No		
 34597 0000594D 263A4501                	cmp	al,[es:di+1]		;;AN000;; Does the character fall in the DBCS range?
 34598 00005951 7701                    	jnbe	short $MIF141 ; ja	;;AN000;; No
 34599                                  					;;AN000;; Yes
 34600 00005953 F9                      	stc				;;AN000;; Set carry flag
 34601                                  $MIF141:
 34602 00005954 47                      	inc	di			;;AN000;;
 34603 00005955 47                      	inc	di			;;AN000;;
 34604 00005956 EBE9                    	jmp	short $MDO139		;;AN000;; Go to next vector
 34605                                  $MEN139:
 34606                                  $MIF138:
 34607 00005958 5F                      	pop	di			;;AN000;; Restore DI register
 34608 00005959 07                      	pop	es			;;AN000;; Restore Extra Segment register
 34609 0000595A C3                      	retn				;;AN000;; Return
 34610                                  
 34611                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34612                                  ;;
 34613                                  ;;	PROC NAME: $M_CONVERT2ASC
 34614                                  ;;
 34615                                  ;;	FUNCTION: Convert a binary number to a ASCII string
 34616                                  ;;	INPUTS: DX:AX contains the number to be converted
 34617                                  ;;		$M_RT_DIVISOR contains the divisor
 34618                                  ;;	OUTPUTS: CX contains the number of characters
 34619                                  ;;		Top of stack  --> Last character
 34620                                  ;;				     . . .
 34621                                  ;;		Bot of stack  --> First character
 34622                                  ;;	REGS USED:
 34623                                  ;;
 34624                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34625                                  
 34626                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34627                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34628                                  $M_CONVERT2ASC:
 34629 0000595B 8F06[859A]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34630                                  	;pop	word [$M_RT+70]			;;AN000;; Save Return Address
 34631                                  	
 34632 0000595F 31DB                    	xor	bx,bx				;;AN000;; Use BX as a swapping register
 34633 00005961 93                      	xchg	bx,ax				;;AN000;; Initialize - Low Word in BX
 34634 00005962 92                      	xchg	ax,dx				;;AN000;;	  - High Word in AX
 34635                                  $MDO145:					;;AN000;; DO UNTIL Low Word becomes zero
 34636 00005963 F736[899A]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 34637                                  	;div	word [$M_RT+74]			;;AN000;; Divide High Word by divisor
 34638 00005967 93                      	xchg	bx,ax				;;AN000;; Setup to divide Low Word using remainder
 34639                                  						;;AN000;;  and save reduced High Word in BX
 34640 00005968 F736[899A]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 34641                                  	;div	word [$M_RT+74]			;;AN000;; Divide Low Word by divisor
 34642                                  
 34643 0000596C 83FA09                  	cmp	dx,9				;;AN000;; Make a digit of the remainder
 34644 0000596F 7605                    	jna	short $MIF146			;;AN000;; 0-9
 34645 00005971 80C237                  	add	dl,55	; add dl,37h		;;AN000;; Make A to F ASCII
 34646 00005974 EB03                    	jmp	short $MEN146
 34647                                  $MIF146:
 34648 00005976 80C230                  	add	dl,'0'				;;AN000;; Make 0 to 9 ASCII
 34649                                  $MEN146:
 34650 00005979 52                      	push	dx				;;AN000;; Save the digit on the stack
 34651 0000597A 41                      	inc	cx				;;AN000;; Count that digit
 34652 0000597B 09C0                    	or	ax,ax				;;AN000;; Are we done?
 34653 0000597D 7504                    	jnz	short $MLL149			;;AN000;; No
 34654 0000597F 09DB                    	or	bx,bx				;;AN000;; AX and BX must be ZERO!!
 34655 00005981 741F                    	jz	short $MEN145 ; * ; ax = 0	;;AN000;; Yes
 34656                                  $MLL149:
 34657 00005983 83F903                  	cmp	cx,3 ; $M_FIRST_THOU		;;AN000;; Are we at the first thousands mark
 34658                                  ; 28/04/2023
 34659 00005986 740A                    	je	short $MIF153
 34660                                  ;	jne	short $MIF150			;;AN000;; No
 34661                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34662                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 34663                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34664                                  ;	;jne	short $MIF151
 34665                                  ;	; 09/04/2023
 34666                                  ;	jne	short $MEN150
 34667                                  ;						;;AN000;; Yes
 34668                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34669                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34670                                  ;	inc	cx				;;AN000;;
 34671                                  ;$MIF151:
 34672                                  ;	jmp	short $MEN150
 34673                                  
 34674                                  $MIF150:
 34675                                  	; 15/06/2023 (6)
 34676                                  	; MSDOS 6.0
 34677                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54ABh 
 34678                                  	;cmp	cx,6 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark
 34679                                  	; 15/06/2023 (7)
 34680                                  	; MSDOS 6.22
 34681                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5C78h 
 34682 00005988 83F907                  	cmp	cx,7 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark	
 34683                                  
 34684                                  ; 28/04/2023
 34685 0000598B 7405                    	je	short $MIF153
 34686                                  ;	jne	short $MIF154			;;AN000;; No
 34687                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34688                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 34689                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34690                                  ;	;jne	short $MIF155			;;AN000;; No
 34691                                  ;	; 09/04/2023
 34692                                  ;	jne	short $MEN154
 34693                                  ;						;;AN000;; Yes				
 34694                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34695                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34696                                  ;	inc	cx				;;AN000;;
 34697                                  ;$MIF155:
 34698                                  ;	jmp	short $MEN154
 34699                                  
 34700                                  $MIF154:
 34701                                  	; 15/06/2023 (9)
 34702                                  	; MSDOS 6.0
 34703                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54BDh 
 34704                                  	;cmp	cx,9 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
 34705                                  	; 15/06/2023 (11)
 34706                                  	; MSDOS 6.22
 34707                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5C8Ah 
 34708 0000598D 83F90B                  	cmp	cx,11 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
 34709 00005990 750B                    	jne	short $MIF158			;;AN000;; No  
 34710                                  ; 28/04/2023
 34711                                  $MIF153:
 34712                                  	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34713 00005992 807C0A2C                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 34714                                  	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34715 00005996 7505                    	jne	short $MIF159			;;AN000;; No
 34716                                  						;;AN000;; Yes
 34717 00005998 FF36[929A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34718                                  	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34719 0000599C 41                      	inc	cx				;;AN000;;
 34720                                  $MIF159:
 34721                                  $MIF158:
 34722                                  $MEN154:
 34723                                  $MEN150:					;;AN000;;
 34724 0000599D 93                      	xchg	ax,bx				;;AN000;; Setup to divide the reduced High Word
 34725                                  						;;AN000;;  and Revised Low Word
 34726 0000599E 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 34727                                  	; 28/04/2023
 34728 000059A0 EBC1                    	jmp	short $MDO145
 34729                                  ;$MEN145:
 34730                                  	; 28/04/2023
 34731                                  	;xor	ax,ax				;;AN000;; Reset remainder
 34732                                  $MEN145: ; 09/04/2023 ; * ; ax = 0
 34733 000059A2 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 34734 000059A4 FF36[859A]              	push	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34735                                  	;push	word [$M_RT+70]			;;AN000;; Restore Return Address
 34736 000059A8 C3                      	retn					;;AN000;; Return
 34737                                  
 34738                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34739                                  ;;
 34740                                  ;;	PROC NAME: $M_DISPLAY_MESSAGE
 34741                                  ;;
 34742                                  ;;	FUNCTION:  Will display or write entire message (with replacable parameters)
 34743                                  ;;	INPUTS:    ES:DI points to beginning of message
 34744                                  ;;		   DS:SI points to first sublist structure in chain
 34745                                  ;;		   BX contains the handle to write to (if applicable)
 34746                                  ;;		   CX contains the length of string to write (before substitutions)
 34747                                  ;;		   BP contains the count of replacables
 34748                                  ;;
 34749                                  ;;	OUTPUTS:
 34750                                  ;;	REGS USED: All
 34751                                  ;;
 34752                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34753                                  
 34754                                  	; 10/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34755                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54DBh
 34756                                  
 34757                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34758                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:54DBh
 34759                                  
 34760                                  $M_DISPLAY_MESSAGE:
 34761                                  ; $DO						;;AN000;; Note: DS:SI -> message
 34762                                  $MDO165:
 34763 000059A9 31D2                    	xor	dx,dx				;;AN000;; Set size = 0
 34764 000059AB 09C9                    	or	cx,cx				;;AN000;; Are we finished the message yet?
 34765                                  ;; $IF NZ					;;AN000;; No
 34766 000059AD 7421                    	jz	short $MIF166			;;AN000;; Yes
 34767 000059AF B425                    	mov	ah,"%"				;;AN000;; Prepare to scan for %
 34768 000059B1 B000                    	mov	al,0				;;AN004;;
 34769                                  ;; $DO						;;AN000;; Scan through string until %
 34770                                  $MDO167:
 34771 000059B3 263825                  	cmp	byte [es:di],ah			;;AN000;; Is this character NOT a %
 34772                                  ;; $LEAVE E,AND					;;AN000;; No
 34773 000059B6 750A                    	jne	short $MLL168
 34774 000059B8 26386501                	cmp	byte [es:di+1],ah		;;AN000;; Is the next character also a %
 34775                                  ;; $LEAVE NE,AND				;;AN000;; No
 34776 000059BC 7404                    	je	short $MLL168
 34777                                  
 34778 000059BE 38E0                    	cmp	al,ah				;;AN000;; Was the character before a %
 34779                                  ;; $LEAVE NE					;;AN000;; No, GREAT found it
 34780 000059C0 750E                    	jne	short MEN167
 34781                                  $MLL168:
 34782 000059C2 268A05                  	mov	al,[es:di]			;;AN004;; Yes, (to any of the above)
 34783 000059C5 E86FFF                  	call	$M_IS_IT_DBCS			;;AN004;; Is this character the first part of a DBCS?
 34784                                  ;;; $IF C					;;AN004;; Yes
 34785 000059C8 7301                    	jnc	short $MIF169
 34786 000059CA 47                      	inc	di				;;AN004;; Increment past second part
 34787                                  ;;; $ENDIF					;;AN004;;
 34788                                  $MIF169:
 34789 000059CB 47                      	inc	di				;;AN000;; Next character in string
 34790 000059CC 42                      	inc	dx				;;AN000;; Size = Size + 1
 34791 000059CD 49                      	dec	cx				;;AN000;; Decrement total size
 34792                                  ;; $ENDDO Z					;;AN000;; Exit scan if we're at the end of the line
 34793 000059CE 75E3                    	jnz	short $MDO167
 34794                                  $MEN167:
 34795                                  ;; $ENDIF					;;AN000;;
 34796                                  $MIF166:
 34797 000059D0 56                      	push	si				;;AN000;; Save beginning of sublists
 34798 000059D1 87CA                    	xchg	cx,dx				;;AN000;; Get size of message to display (tot sz in DX)
 34799 000059D3 09ED                    	or	bp,bp				;;AN000;; Do we have any replacables to do?
 34800                                  ;; $IF NZ					;;AN000;; Yes
 34801 000059D5 7431                    	jz	short $MIF173
 34802 000059D7 4D                      	dec	bp				;;AN000;; Decrement number of replacables
 34803                                  
 34804                                  ;; Search through sublists to find applicable one
 34805                                  
 34806 000059D8 833E[879A]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34807                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34808                                  ;;; $IF E					;;AN000;; No
 34809 000059DD 7529                    	jne	short $MIF174
 34810                                  ;;; $SEARCH					;;AN000;;
 34811                                  $MDO175:
 34812                                  	;mov	al,$M_SL.$M_S_ID ;$M_SL=DS:[SI]	;;AN000;; Get ID byte
 34813 000059DF 8A4406                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_ID]
 34814                                  	;mov	al,[si+6]
 34815 000059E2 0430                    	add	al,30h				;;AN000;; Convert to ASCII
 34816                                  	; 28/04/2023					
 34817 000059E4 263A4501                	cmp	al,[es:di+1]			;;AN000;; Is this the right sublist?
 34818                                  ;;; $EXITIF E					;;AN000;;
 34819                                  	;jne	short $MIF175
 34820                                  ;;; $ORELSE					;;AN000;; No
 34821                                  	;jmp	short $MSR175
 34822                                  	; 28/04/2023
 34823 000059E8 741E                    	je	short $MSR175
 34824                                  $MIF175:
 34825 000059EA 3C30                    	cmp	al,30h ; $M_SPECIAL_CASE	;;AN000;; Does this sublist have ID = 0
 34826                                  ;;; $LEAVE E,AND				;;AN000;; Yes
 34827 000059EC 7504                    	jne	short $MLL178
 34828 000059EE 09D2                    	or	dx,dx				;;AN000;; Are we at the end of the message?
 34829                                  ;;; $LEAVE Z					;;AN000;; No
 34830 000059F0 7404                    	jz	short $MEN175
 34831                                  $MLL178:
 34832                                  	;add	si,$M_SL.$M_S_SIZE		;;AN000;; Next SUBLIST
 34833                                  	;add	si,[si+$M_SUBLIST_STRUC.$M_S_SIZE] ; [si+0]
 34834                                  	;;add	si,[si+0]
 34835 000059F2 0334                    	add	si,[si]
 34836                                  ;;; ENDLOOP					;;AN000;; Yes
 34837 000059F4 EBE9                    	jmp	short $MDO175
 34838                                  $MEN175:
 34839 000059F6 803E[849A]FF            	cmp	byte [$M_RT+$M_RES_ADDRS.$M_CLASS],utility_msg_class
 34840                                  	;cmp	byte [$M_RT+69],0FFh		;;AN004;; Is it a utility message?
 34841                                  ;;;; $IF E					;;AN004;; Yes
 34842 000059FB 7508                    	jne	short $MIF180
 34843 000059FD 42                      	inc	dx				;;AN000;; Remember to display CR,LF
 34844 000059FE 42                      	inc	dx				;;AN000;;  at the end of the message
 34845 000059FF 49                      	dec	cx				;;AN000;; Adjust message length
 34846 00005A00 49                      	dec	cx				;;AN000;;
 34847 00005A01 4F                      	dec	di				;;AN000;; Adjust ending address of message
 34848 00005A02 4F                      	dec	di				;;AN000;;
 34849                                  ;;;; $ELSE					;;AN004;; No
 34850 00005A03 EB03                    	jmp	short $MEN180
 34851                                  $MIF180:
 34852 00005A05 BAFFFF                  	mov	dx,-1 				;;AN004;; Set special case
 34853                                  ;;;; $ENDIF					;;AN004;;
 34854                                  $MEN180:
 34855                                  ;;; $ENDSRCH					;;AN000;;
 34856                                  $MSR175:
 34857                                  ;; $ENDIF					;;AN000;;
 34858                                  $MIF174:
 34859                                  ; $ENDIF					;;AN000;;
 34860                                  $MIF173:
 34861                                  ;; Prepare and display this part of message
 34862                                  
 34863 00005A08 57                      	push	di				;;AN000;; Save pointer to replace number
 34864 00005A09 29CF                    	sub	di,cx				;;AN000;; Determine beginning of string
 34865 00005A0B E833FE                  	call	$M_DISPLAY_STRING		;;AN000;; Display string until % (or end)
 34866 00005A0E 5F                      	pop	di				;;AN000;; Get back pointer to replace number
 34867 00005A0F 59                      	pop	cx				;;AN000;; Clean up stack in case error
 34868                                  ; $LEAVE C,LONG					;;AN000;; Fail if carry was set
 34869                                  	;jnc	short $MXL3
 34870                                  	;jmp	$MEN165
 34871                                  	; 02/05/2023
 34872 00005A10 7214                    	jc	short $MEN165
 34873                                  $MXL3:
 34874 00005A12 51                      	push	cx				;;AN000;;
 34875                                  
 34876                                  ;; Save and reset pointer registers
 34877                                  
 34878 00005A13 89D1                    	mov	cx,dx				;;AN000;; Get the size of the rest of the message
 34879                                  	;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h
 34880 00005A15 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0 ; $M_SPECIAL_CASE-30h
 34881                                  	;cmp	byte [si+6],0 			;;AN000;; Is this the %0 case?
 34882                                  ; $IF NE					;;AN000;; No
 34883 00005A19 7412                    	je	short $MIF187			;;AN000;; Yes			
 34884 00005A1B 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 34885                                  ;; $IF NZ					;;AN000;; No
 34886 00005A1D 7406                    	jz	short $MIF188			;;AN000;; Yes
 34887 00005A1F 49                      	dec	cx				;;AN000;; Decrement total size (%)
 34888 00005A20 49                      	dec	cx				;;AN000;; Decrement total size (#)
 34889 00005A21 47                      	inc	di				;;AN000;; Go past %
 34890 00005A22 47                      	inc	di				;;AN000;; Go past replace number
 34891                                  ;; $ELSE					;;AN000;; Yes, (Note this will not leave because INC)
 34892                                  	;jmp	short $MEN188
 34893                                  	; 28/04/2023
 34894 00005A23 EB15                    	jmp	short $MEN187
 34895                                  $MIF188:
 34896 00005A25 5E                      	pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 34897                                  ;; $ENDIF					;;AN000;; Yes, Note this will not leave because INC
 34898                                  $MEN188:
 34899                                  ; $ELSE 					;;AN000;;
 34900                                  	;jmp	short $MEN187
 34901                                  	; 28/04/2023
 34902                                  	; zf = 1
 34903                                  	;jmp	short $MEN165 
 34904                                  
 34905                                  ; 28/04/2023
 34906                                  $MXL4:
 34907                                  $MLL214:
 34908                                  $MEN165:
 34909 00005A26 C706[879A]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 34910                                  	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 34911                                  						;;AN000;; Reset message number to null
 34912 00005A2C C3                      	retn					;;AN000;; Return
 34913                                  
 34914                                  $MIF187:
 34915 00005A2D 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 34916                                  ;; $IF Z					;;AN004;; No
 34917                                  	;jnz	short $MIF192
 34918                                  	;pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 34919                                  ;; $ELSE					;;AN000;; No
 34920                                  	;jmp	short $MEN192
 34921                                  	; 28/04/2023
 34922 00005A2F 74F4                    	jz	short $MIF188
 34923                                  $MIF192:
 34924 00005A31 83F9FF                  	cmp	cx,-1				;;AN004;; Are we at the end of the message?
 34925                                  ;;; $IF Z					;;AN004;; No
 34926 00005A34 7502                    	jnz	short $MIF194
 34927 00005A36 31C9                    	xor	cx,cx				;;AN004;;
 34928                                  ;;; $ENDIF					;;AN000;;
 34929                                  $MIF194:
 34930 00005A38 09FF                    	or	di,di				;;AN004;; Turn ZF off
 34931                                  ;; $ENDIF					;;AN000;;
 34932                                  $MEN192:
 34933                                  ; $ENDIF					;;AN000;; Note this will not leave because INC
 34934                                  $MEN187:
 34935                                  ; $LEAVE Z					;;AN000;;
 34936 00005A3A 74EA                    	jz	short $MEN165
 34937                                  	;
 34938 00005A3C 55                      	push	bp				;;AN000;; Save the replace count
 34939 00005A3D 57                      	push	di				;;AN000;; Save location to complete message
 34940 00005A3E 06                      	push	es				;;AN000;;
 34941 00005A3F 51                      	push	cx				;;AN000;; Save size of the rest of the message
 34942 00005A40 31C9                    	xor	cx,cx				;;AN000;; Reset CX used for character count
 34943                                  
 34944                                  ;; Determine what action is required on parameter
 34945                                  
 34946 00005A42 833E[879A]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34947                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34948                                  ; $IF E						;;AN000;;
 34949 00005A47 753B                    	jne	short $MIF199
 34950                                  
 34951                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 34952 00005A49 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34953                                  	;test	byte [si+7],0Fh			;;AN000;;
 34954                                  ;; $IF Z					;;AN000;;
 34955 00005A4D 7508                    	jnz	short $MIF200
 34956                                  
 34957                                  ;; Character type requested
 34958                                  
 34959                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34960 00005A4F C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34961                                  	;les	di,[si+2]
 34962 00005A52 E84801                  	call	$M_CHAR_REPLACE			;;AN000;;
 34963                                  ;; $ELSE					;;AN000;; Get the rest of the message to display
 34964 00005A55 EB28                    	jmp	short $MEN200
 34965                                  $MIF200:
 34966                                  ;; ENDIF					;;AN000;;
 34967                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34968 00005A57 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34969                                  	;test	byte [si+7],0Dh			;;AN000;;
 34970                                  ;; $IF Z,OR					;;AN000;;
 34971 00005A5B 740C                    	jz	short $MLL202
 34972                                  	;test	byte ptr $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
 34973 00005A5D F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34974                                  	;test	byte [si+7],0Eh			;;AN000;;
 34975                                  ;;; $IF Z,OR					;;AN000;;
 34976 00005A61 7406                    	jz	short $MLL202
 34977                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Bin_Hex_Type and $M_TYPE_MASK
 34978 00005A63 F644070C                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Ch
 34979                                  	;test	byte [si+7],0Ch			;;AN000;;
 34980                                  ;;;; $IF Z 					;;AN000;;
 34981 00005A67 7508                    	jnz	short $MIF202
 34982                                  $MLL202:
 34983                                  
 34984                                  ;; Numeric type requested
 34985                                  
 34986                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34987 00005A69 C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34988                                  	;les	di,[si+2]
 34989 00005A6C E85601                  	call	$M_BIN2ASC_REPLACE		;;AN000;;
 34990                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 34991 00005A6F EB0E                    	jmp	short $MEN202
 34992                                  $MIF202:
 34993                                  ;;;; ENDIF					;;AN000;;
 34994                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Date_Type and $M_TYPE_MASK
 34995 00005A71 F644070B                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Bh
 34996                                  	;test	byte [si+7],0Bh			;;AN000;;
 34997                                  ;;;; $IF E					;;AN000;;
 34998 00005A75 7505                    	jnz	short $MIF204
 34999                                  
 35000                                  ;; Date type requested
 35001                                  
 35002 00005A77 E8EC01                  	call	$M_DATE_REPLACE			;;AN000;;
 35003                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 35004 00005A7A EB03                    	jmp	short $MEN204
 35005                                  $MIF204:					;;AN000;;
 35006                                  
 35007                                  ;; Time type requested (Default if we have not matched until here)
 35008                                  
 35009 00005A7C E89E02                  	call	$M_TIME_REPLACE			;;AN000;;
 35010                                  
 35011                                  ;;;; $ENDIF					;;AN000;;
 35012                                  $MEN204:
 35013                                  ;;; $ENDIF					;;AN000;;
 35014                                  $MEN202:
 35015                                  ;; $ENDIF					;;AN000;;
 35016                                  $MEN200:
 35017                                  
 35018                                  ;; With the replace information of the Stack, display the replaceable field
 35019                                  
 35020 00005A7F E85F00                  	call	$M_DISPLAY_REPLACE		;;AN000;; Display the replace
 35021                                  
 35022                                  ;; None of the above - Extended/Parse replace
 35023                                  ; $ELSE 					;;AN000;;
 35024 00005A82 EB03                    	jmp	short $MEN199
 35025                                  $MIF199:
 35026 00005A84 E81600                  	call	$M_EXT_PAR_REPLACE		;;AN000;;
 35027                                  ; $ENDIF					;;AN000;;
 35028                                  $MEN199:
 35029                                  
 35030                                  ;; We must go back and complete the message after the replacable parameter if there is any left
 35031                                  
 35032                                  ; $IF NC					;;AN000;; IF there was an error displaying then EXIT
 35033 00005A87 7207                    	jc	short $MIF211
 35034                                  	;
 35035 00005A89 59                      	pop	cx				;;AN000;; Get size of the rest of the message
 35036 00005A8A 07                      	pop	es				;;AN000;; Get address of the rest of the message
 35037 00005A8B 5F                      	pop	di				;;AN000;;
 35038 00005A8C 5D                      	pop	bp				;;AN000;; Get replacment count
 35039 00005A8D 5E                      	pop	si				;;AN000;; ELSE get address of first sublist structure
 35040                                  ; $ELSE						;;AN000;;
 35041 00005A8E EB03                    	jmp	short $MEN211
 35042                                  $MIF211:
 35043 00005A90 83C40A                  	add	sp,10				;;AN000;; Clean up stack if error
 35044                                  	; 28/04/2023
 35045                                  	;stc					;;AN000;;
 35046                                  ; $ENDIF					;;AN000;;
 35047                                  $MEN211:
 35048 00005A93 833E[879A]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 35049                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 35050                                  ; $ENDDO NE,OR					;;AN000;;
 35051 00005A98 758C                    	jne	short $MLL214
 35052                                  ; $ENDDO C,LONG					;;AN000;; Go back and display the rest of the message
 35053                                  	; 10/04/2023
 35054                                  	;jc	short $MXL4
 35055 00005A9A E90CFF                  	jmp	$MDO165
 35056                                  
 35057                                  ; 28/04/2023
 35058                                  ;$MXL4:
 35059                                  ;$MLL214:
 35060                                  ;$MEN165:
 35061                                  ;	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 35062                                  ;	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 35063                                  ;						;;AN000;; Reset message number to null
 35064                                  ;	retn					;;AN000;; Return
 35065                                  
 35066                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35067                                  ;;
 35068                                  ;;	PROC NAME: $M_EXT_PAR_REPLACE
 35069                                  ;;
 35070                                  ;;	FUNCTION:
 35071                                  ;;	INPUTS:
 35072                                  ;;	OUPUTS:
 35073                                  ;;
 35074                                  ;;	REGS USED:
 35075                                  ;;
 35076                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35077                                  
 35078                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35079                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35080                                  
 35081                                  $M_EXT_PAR_REPLACE:
 35082 00005A9D 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 35083 00005A9F A1[879A]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 35084                                  	;mov	ax,[$M_RT+72]			;;AN000;; Prepare for get binary value (LOW)
 35085 00005AA2 C706[899A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35086                                  	;mov	word [$M_RT+74],10 ; $M_BASE10	;;AN000;; Set default divisor
 35087 00005AA8 E8B0FE                  	call	$M_CONVERT2ASC			;;AN000;;
 35088                                  $MDO215:
 35089 00005AAB 58                      	pop	ax				;;AN000;; Get character in register
 35090 00005AAC 8887[8B9A]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 35091                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 35092 00005AB0 43                      	inc	bx				;;AN000;; Increase buffer count
 35093 00005AB1 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 35094 00005AB4 7503                    	jne	short $MIF216			;;AN000;; No
 35095 00005AB6 E80D00                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 35096                                  $MIF216:
 35097 00005AB9 FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 35098 00005ABB 75EE                    	jnz	short $MDO215
 35099                                  
 35100 00005ABD B80D0A                  	mov	ax,0A0Dh ; mov ax,$M_CR_LF	;;AN000;; Move char into the buffer
 35101 00005AC0 8987[8B9A]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],ax
 35102                                  	;;mov	[bx+$M_RT+76],ax		;;AN000;; Move char into the buffer
 35103 00005AC4 43                      	inc	bx				;;AN000;; Increase buffer count
 35104 00005AC5 43                      	inc	bx				;;AN000;; Increase buffer count
 35105                                  	;call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 35106                                  	;retn					;;AN000::
 35107                                  	; 11/04/2023
 35108                                  	;jmp	$M_FLUSH_BUF
 35109                                  
 35110                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35111                                  ;;
 35112                                  ;;	PROC NAME: $M_FLUSH_BUFFER
 35113                                  ;;
 35114                                  ;;	FUNCTION: Display the contents of the temporary buffer
 35115                                  ;;	INPUTS: DI contains the number of bytes to display
 35116                                  ;;	OUTPUTS: BX reset to zero
 35117                                  ;;
 35118                                  ;;	REGS USED:
 35119                                  ;;
 35120                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35121                                  	
 35122                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35123                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:56C8h
 35124                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35125                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5E95h
 35126                                  $M_FLUSH_BUF:
 35127 00005AC6 51                      	push	cx				;;AN000;; Save changed regs
 35128 00005AC7 06                      	push	es				;;AN000;;
 35129 00005AC8 57                      	push	di				;;AN000;;
 35130 00005AC9 1E                      	push	ds				;;AN000;; Set ES pointing to buffer
 35131 00005ACA 07                      	pop	es				;;AN000;;
 35132 00005ACB 89D9                    	mov	cx,bx				;;AN000;; Set number of bytes to display
 35133 00005ACD 31DB                    	xor	bx,bx				;;AN000;; Reset buffer counter
 35134 00005ACF 8D3E[8B9A]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35135                                  	;lea	di,[$M_RT+76]			;;AN000;; Reset buffer location pointer
 35136 00005AD3 E86BFD                  	call	$M_DISPLAY_STRING		;;AN000;; Display the buffer
 35137 00005AD6 7204                    	jc	short $MIF314
 35138 00005AD8 5F                      	pop	di				;;AN000;; No, Restore changed regs
 35139 00005AD9 07                      	pop	es				;;AN000;;
 35140 00005ADA 59                      	pop	cx				;;AN000;;
 35141                                  	;jmp	short $MEN314
 35142                                  	; 11/04/2023
 35143 00005ADB C3                      	retn
 35144                                  $MIF314:
 35145 00005ADC 83C406                  	add	sp,6				;;AN000;; Fix stack
 35146 00005ADF F9                      	stc					;;AN000;;
 35147                                  $MEN314:
 35148 00005AE0 C3                      	retn					;;AN000;; Return
 35149                                  
 35150                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35151                                  ;;
 35152                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35153                                  
 35154                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35155                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5609h
 35156                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35157                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5DD6h
 35158                                  $M_DISPLAY_REPLACE:
 35159 00005AE1 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 35160                                  	;;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h ; 0
 35161 00005AE3 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0	
 35162                                  	;cmp	byte [si+6],0			;;AN000;; Is this the special case (convert to ASCII)
 35163 00005AE7 7511                    	jne	short $MIF276
 35164                                  	
 35165 00005AE9 C787[8B9A]202D          	mov	word [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],2D20h ; $M_SPACE_HYP
 35166                                  	;mov	word [bx+$M_RT+76],2D20h	;;AN000;; Move in a " -"
 35167                                  	
 35168 00005AEF 43                      	inc	bx				;;AN000;; Increment count
 35169 00005AF0 43                      	inc	bx				;;AN000;; Increment count
 35170                                  	
 35171 00005AF1 C687[8B9A]20            	mov	byte [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],20h ; $M_SPACE
 35172                                  	;mov	byte [bx+$M_RT+76],20h		;;AN000;; Move in a " "
 35173                                  	
 35174 00005AF6 43                      	inc	bx				;;AN000;; Increment count
 35175 00005AF7 E8CCFF                  	call	$M_FLUSH_BUF			;;AN000;; Write out " - " to prepare for special case
 35176                                  $MIF276:
 35177 00005AFA 5D                      	pop	bp				;;AN000;; Remember the return address
 35178 00005AFB 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 35179 00005AFD 31D2                    	xor	dx,dx				;;AN000;; Use DX for count of parms taken off the stack
 35180                                  
 35181 00005AFF 880E[819A]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl	;;AN000;; Save size to later clear stack
 35182                                  	;mov	[$M_RT+66],cl
 35183                                  	
 35184                                  	;mov	al,byte ptr $M_SL.$M_S_MINW	;;AN000;; Get the minimum width
 35185 00005B03 8A4409                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_MINW]
 35186                                  	;mov	al,[si+9]
 35187                                  	
 35188 00005B06 38C8                    	cmp	al,cl				;;AN000;; Do we need pad chars added?
 35189 00005B08 761E                    	jna	short $MIF278
 35190 00005B0A 28C8                    	sub	al,cl				;;AN000;; Calculate how many pad chars are needed.
 35191 00005B0C 88C6                    	mov	dh,al				;;AN000;; Save the number of pad characters
 35192                                  	
 35193                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 35194 00005B0E F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 35195                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be right aligned?
 35196 00005B12 7414                    	jz	short $MIF279			;;AN000;; No
 35197                                  $MDO280:
 35198                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 35199 00005B14 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 35200                                  	;mov	al,[si+0Ah]
 35201 00005B17 8887[8B9A]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 35202                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 35203                                  	
 35204 00005B1B 43                      	inc	bx				;;AN000;;
 35205 00005B1C 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; 64		;;AN000;; Is buffer full?
 35206 00005B1F 7503                    	jne	short $MIF281
 35207 00005B21 E8A2FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 35208                                  $MIF281:
 35209 00005B24 FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 35210 00005B26 75EC                    	jnz	short $MDO280
 35211                                  $MIF279:
 35212                                  $MIF278:
 35213                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,$M_UNLIM_W
 35214 00005B28 807C0800                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],0 ; $M_UNLIM_W
 35215                                  	;cmp	byte [si+8],0			;;AN000;; Is maximum width unlimited
 35216 00005B2C 740C                    	je	short $MIF286
 35217                                  	
 35218                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,CL	;;AN000;; Will we exceed maximum width?
 35219 00005B2E 384C08                  	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],cl
 35220                                  	;;cmp	byte [si+8],cl
 35221 00005B31 7307                    	jnb	short $MIF287
 35222                                  
 35223                                  	; 03/05/2023
 35224                                  	;;sub	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Calculate how many extra chars
 35225                                  	;sub	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 35226                                  	;;sub	cl,[si+8]
 35227 00005B33 88CA                    	mov	dl,cl				;;AN000;; Remember how many chars to pop off
 35228                                  	;;mov	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Set new string length
 35229                                  	;mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 35230                                  	;;mov	cl,[si+8]
 35231                                  	; 03/05/2023
 35232 00005B35 8A4C08                  	mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 35233 00005B38 28CA                    	sub	dl,cl
 35234                                  $MIF287:
 35235                                  $MIF286:
 35236 00005B3A 09C9                    	or	cx,cx				;;AN000;;
 35237 00005B3C 7424                    	jz	short $MIF290			;;AN000;;
 35238                                  $MDO291:
 35239                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type not $M_TYPE_MASK
 35240 00005B3E F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 35241                                  	;test	byte [si+7],0Fh			;;AN000;;
 35242 00005B42 750C                    	jnz	short $MIF292
 35243                                  
 35244                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 35245 00005B44 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35246                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?			 
 35247 00005B48 7406                    	jz	short $MIF292			;;AN000;; No
 35248                                  
 35249 00005B4A 268A05                  	mov	al,[es:di]			;;AN000;; Get first character from string
 35250 00005B4D 47                      	inc	di				;;AN000;; Next character in string
 35251 00005B4E EB01                    	jmp	short $MEN292
 35252                                  $MIF292:
 35253 00005B50 58                      	pop	ax				;;AN000;; Get character in register
 35254                                  $MEN292:
 35255                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 35256 00005B51 8887[8B9A]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 35257                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 35258                                  	; 03/05/2023
 35259 00005B55 43                      	inc	bx				;;AN000;; Increase buffer count
 35260 00005B56 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 35261 00005B59 7503                    	jne	short $MIF295			;;AN000;;
 35262 00005B5B E868FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 35263                                  $MIF295:
 35264 00005B5E FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 35265 00005B60 75DC                    	jnz	short $MDO291
 35266                                  $MIF290:
 35267                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 35268 00005B62 F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 35269                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be left aligned?
 35270 00005B66 7518                    	jnz	short $MIF299			;;AN000;; Yes
 35271 00005B68 08F6                    	or	dh,dh				;;AN000;; Do we need pad chars added?
 35272 00005B6A 7414                    	jz	short $MIF300
 35273                                  $MDO301:
 35274                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 35275 00005B6C 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 35276                                  	;mov	al,[si+0Ah]
 35277                                  
 35278                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 35279 00005B6F 8887[8B9A]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 35280                                  	; 03/05/2023
 35281                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 35282                                  
 35283 00005B73 43                      	inc	bx				;;AN000;;
 35284 00005B74 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ  ; 64		;;AN000;; Is buffer full?
 35285 00005B77 7503                    	jne	short $MIF302			;;AN000;; No
 35286                                  						;;AN000;; Yes
 35287 00005B79 E84AFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 35288                                  $MIF302:
 35289 00005B7C FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 35290 00005B7E 75EC                    	jnz	short $MDO301			;;AN000;;
 35291                                  $MIF300:
 35292                                  $MIF299:
 35293                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 35294 00005B80 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 35295                                  	;test	byte [si+7],0Fh			;;AN000;;
 35296 00005B84 7506                    	jnz	short $MIF307
 35297                                  	
 35298                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 35299 00005B86 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35300                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?
 35301                                  	; 11/04/2023
 35302                                  	;jz	short $MIF307			;;AN000;;
 35303                                  	;jmp	short $MEN307			;;AN000;;
 35304 00005B8A 750C                    	jnz	short $MEN307
 35305                                  $MIF307:
 35306 00005B8C 08D2                    	or	dl,dl				;;AN000;;
 35307 00005B8E 7408                    	jz	short $MIF309			;;AN000;;
 35308                                  $MDO310:
 35309 00005B90 8F06[859A]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 35310                                  	;pop	word [$M_RT+70]			;;AN000;; Clean Up stack using spare variable
 35311 00005B94 FECA                    	dec	dl				;;AN000;; Are we done?
 35312 00005B96 75F8                    	jnz	short $MDO310
 35313                                  $MIF309:
 35314                                  $MEN307:
 35315 00005B98 E82BFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer for the final time
 35316 00005B9B 55                      	push	bp				;;AN000;; Restore the return address
 35317 00005B9C C3                      	retn					;;AN000;;
 35318                                  
 35319                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35320                                  ;;
 35321                                  ;;	PROC NAME: $M_CHAR_REPLACE
 35322                                  ;;
 35323                                  ;;	FUNCTION: Will prepare a single char or ASCIIZ string for replace
 35324                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35325                                  ;;		ES:DI contains the VALUE from SUBLIST
 35326                                  ;;	OUTPUTS: CX contains number of characters on stack
 35327                                  ;;		 Top of stack  --> Last character
 35328                                  ;;					. . .
 35329                                  ;;		 Bot of stack  --> First character
 35330                                  ;;
 35331                                  ;;	OTHER REGS Revised: AX
 35332                                  ;;
 35333                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35334                                  
 35335                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35336                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35337                                  $M_CHAR_REPLACE:
 35338 00005B9D 5D                      	pop	bp				;;AN000;; Save return address
 35339                                  	;test	$M_SL.$M_S_FLAG,not Char_Field_Char and $M_SIZE_MASK
 35340 00005B9E F6440730                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],30h
 35341                                  	;test	byte [si+7],30h			;;AN000;; Was Character specified?
 35342 00005BA2 7512                    	jnz	short $MIF317			;;AN000;; No
 35343 00005BA4 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 35344 00005BA7 50                      	push	ax				;;AN000;; Put it on the stack
 35345 00005BA8 41                      	inc	cx				;;AN000;; Increase the count
 35346 00005BA9 E88BFD                  	call	$M_IS_IT_DBCS			;;AN000;; Is this the first byte of a DB character
 35347 00005BAC 7306                    	jnc	short $MIF318
 35348 00005BAE 268A4501                	mov	al,[es:di+1]			;;AN000;; Get the next character
 35349 00005BB2 50                      	push	ax				;;AN000;; Put it on the stack
 35350 00005BB3 F8                      	clc					;;AN000;; Clear the carry
 35351                                  $MIF318:
 35352 00005BB4 EB0D                    	jmp	short $MEN317
 35353                                  $MIF317:
 35354                                  $MDO321:
 35355 00005BB6 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 35356 00005BB9 08C0                    	or	al,al				;;AN000;; Is it the NULL?
 35357 00005BBB 7404                    	jz	short $MEN321			;;AN000;; Yes
 35358 00005BBD 47                      	inc	di				;;AN000;; Next character
 35359 00005BBE 41                      	inc	cx				;;AN000;; Increment the count
 35360 00005BBF EBF5                    	jmp	short $MDO321
 35361                                  $MEN321:
 35362 00005BC1 29CF                    	sub	di,cx				;;AN000;; Set DI at the beginning of the string
 35363                                  $MEN317:
 35364 00005BC3 55                      	push	bp				;;AN000;; Restore return address
 35365 00005BC4 C3                      	retn					;;AN000;;	
 35366                                  
 35367                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35368                                  ;;
 35369                                  ;;	PROC NAME: $M_BIN2ASC_REPLACE
 35370                                  ;;
 35371                                  ;;	FUNCTION: Convert a signed or unsigned binary number to an ASCII string
 35372                                  ;;		  and prepare to display
 35373                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35374                                  ;;		ES:DI contains the VALUE from SUBLIST
 35375                                  ;;	OUTPUTS: CX contains number of characters on stack
 35376                                  ;;		 Top of stack  --> Last character
 35377                                  ;;					. . .
 35378                                  ;;		 Bot of stack  --> First character
 35379                                  ;;	OTHER REGS Revised: BX,DX,AX
 35380                                  ;;
 35381                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35382                                  
 35383                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35384                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35385                                  $M_BIN2ASC_REPLACE:
 35386 00005BC5 5D                      	pop	bp				;;AN000;; Save return address
 35387 00005BC6 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 35388 00005BC8 31C0                    	xor	ax,ax				;;AN000;; Prepare for get binary value (LOW)
 35389 00005BCA C706[899A]1000          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],16 ; $M_BASE16
 35390                                  	;mov	word [$M_RT+74],16  ; $M_BASE16	;;AN000;; Set default divisor
 35391                                  
 35392 00005BD0 31DB                    	xor	bx,bx				;;AN000;; Use BX as the NEG flag (if applicable)
 35393                                  
 35394                                  	;test	$M_SL.$M_S_FLAG,not $M_BYTE and $M_SIZE_MASK
 35395 00005BD2 F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35396                                  	;test	byte [si+7],20h			;;AN000;; Was BYTE specified?		
 35397 00005BD6 7511                    	jnz	short $MIF325			;;AN000;; No
 35398                                  	
 35399 00005BD8 268A05                  	mov	al,[es:di]			;;AN000;; Setup byte in AL
 35400                                  
 35401                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35402 00005BDB F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35403                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?
 35404 00005BDF 753D                    	jnz	short $MIF326			;;AN000;; No
 35405                                  			 
 35406 00005BE1 A880                    	test	al,10000000b ; 80h		;;AN000;; Is this number negative?
 35407 00005BE3 7433                    	jz	short $MIF327			;;AN000;; No
 35408                                  						;;AN000;; Yes				
 35409                                  	; 12/04/2023
 35410                                  	;inc	bx				;;AN000;; Remember that it was negative
 35411 00005BE5 247F                    	and	al,01111111b			;;AN000;; Make it positive
 35412                                  
 35413                                  	; 12/04/2023 - Retrop DOS v4.0 COMMAND.COM
 35414                                  	;jmp	short $MIF327
 35415 00005BE7 EB2E                    	jmp	short $MIF350 ; inc bx
 35416                                  
 35417                                  ; 12/04/2023
 35418                                  %if 0
 35419                                  
 35420                                  $MIF327:
 35421                                  $MIF335:	; 12/04/2023
 35422                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35423                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35424                                  $MIF326:
 35425                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35426                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35427                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35428                                  	jnz	short $MIF330			;;AN000;; No
 35429                                  						;;AN000;; Yes
 35430                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35431                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35432                                  $MIF330:
 35433                                  	jmp	short $MEN325
 35434                                  
 35435                                  %endif
 35436                                  
 35437                                  $MIF325:
 35438                                  	;test	$M_SL.$M_S_FLAG,not $M_WORD and $M_SIZE_MASK
 35439 00005BE9 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35440                                  	;test	byte [si+7],10h			;;AN000;; Was WORD specified?
 35441 00005BED 7513                    	jnz	short $MIF333			;;AN000;; No
 35442                                  						;;AN000;; Yes
 35443 00005BEF 268B05                  	mov	ax,[es:di]			;;AN000;; Setup byte in AL
 35444                                  
 35445                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35446 00005BF2 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35447                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 35448 00005BF6 7526                    	jnz	short $MIF334			;;AN000;; No
 35449                                  						;;AN000;; Yes
 35450 00005BF8 F6C480                  	test	ah,10000000b ; 80h		;;AN000;; Is this number negative?
 35451 00005BFB 741B                    	jz	short $MIF335			;;AN000;; No
 35452                                  						;;AN000;; Yes
 35453                                  	; 12/04/2023
 35454                                  	;inc	bx				;;AN000;; Remember that it was negative
 35455 00005BFD 80E47F                  	and	ah,01111111b			;;AN000;; Make it positive
 35456                                  
 35457                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 35458                                  	;jmp	short $MIF335
 35459 00005C00 EB15                    	jmp	short $MIF350 ; inc bx
 35460                                  
 35461                                  ; 12/04/2023
 35462                                  %if 0
 35463                                  
 35464                                  $MIF335:
 35465                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35466                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35467                                  $MIF334:
 35468                                  	test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
 35469                                  	jnz	short $MIF338
 35470                                  
 35471                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35472                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35473                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35474                                  	jnz	short $MIF338			;;AN000;; No
 35475                                  						;;AN000;; Yes
 35476                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35477                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35478                                  $MIF338:
 35479                                  	jmp	short $MEN333			;;AN000;;
 35480                                  %endif
 35481                                  
 35482                                  $MIF333:
 35483 00005C02 268B05                  	mov	ax,[es:di]			;;AN000;; Setup Double word in DX:AX
 35484 00005C05 268B5502                	mov	dx,[es:di+2]			;;AN000;;
 35485                                  
 35486                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35487 00005C09 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35488                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 35489 00005C0D 750F                    	jnz	short $MIF341			;;AN000;; No
 35490                                  						;;AN000;; Yes
 35491 00005C0F F6C680                  	test	dh,10000000b ; 80h		;;AN000;; Is this number negative?
 35492 00005C12 7404                    	jz	short $MIF342			;;AN000;; No
 35493                                  						;;AN000;; Yes
 35494                                  	; 12/04/2023
 35495                                  	;inc	bx				;;AN000;; Remember that it was negative
 35496 00005C14 80E67F                  	and	dh,01111111b			;;AN000;; Make it positive
 35497                                  	
 35498                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 35499                                  $MIF350:
 35500 00005C17 43                      	inc	bx
 35501                                  $MIF342:
 35502                                  	; 12/04/2023
 35503                                  $MIF327:
 35504                                  $MIF335:
 35505 00005C18 C706[899A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35506                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35507                                  $MIF341:
 35508                                  $MIF326:
 35509                                  	; 18/04/2023
 35510                                  $MIF334:
 35511                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35512 00005C1E F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35513                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35514 00005C22 7506                    	jnz	short $MIF345			;;AN000;; No
 35515                                  						;;AN000;; Yes
 35516 00005C24 C706[899A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35517                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35518                                  
 35519                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35520                                  	; ****************************************
 35521                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5F64h
 35522                                  $MIF345:
 35523                                  	; *** (Disassembled MSDOS 6.22 COMMAND.COM source code.)
 35524                                  $MEN333:
 35525 00005C2A F6440740                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],40h
 35526                                  	;test	byte [si+7],40h		; MSDOS 6.22
 35527                                  				; (Custom/International flag for thousand separator)
 35528 00005C2E 7428                    	jz	short $MEN325
 35529 00005C30 50                      	push	ax			; MSDOS 6.22
 35530 00005C31 52                      	push	dx
 35531 00005C32 B438                    	mov	ah,38h	 ; International
 35532 00005C34 30C0                    	xor	al,al
 35533 00005C36 8D16[8B9A]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35534 00005C3A CD21                    	int	21h		; DOS - 2+ - GET COUNTRY-DEPENDENT INFORMATION
 35535                                  				; get current-country info
 35536                                  				; DS:DX -> buffer for returned info
 35537 00005C3C 7305                    	jnb	short $MEN341		; (use country depended thousand separator)
 35538 00005C3E C606[929A]2C            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA],','
 35539                                  $MEN341:
 35540 00005C43 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 35541                                  	;mov	al,[si+0Ah]		; (save pad character)
 35542 00005C46 89C7                    	mov	di,ax
 35543 00005C48 5A                      	pop	dx
 35544 00005C49 58                      	pop	ax
 35545 00005C4A C6440A2C                	mov	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','  ; $M_COMMA
 35546                                  	;mov	byte [si+0Ah],','	; (comma is needed for converting procedure)
 35547 00005C4E E80AFD                  	call	$M_CONVERT2ASC
 35548 00005C51 89F8                    	mov	ax,di
 35549 00005C53 88440A                  	mov	[si+$M_SUBLIST_STRUC.$M_S_PAD],al
 35550                                  	;mov	[si+0Ah],al		; (restore pad character)
 35551 00005C56 EB03                    	jmp	short $MEN345		; MSDOS 6.22
 35552                                  	; *** (end of disassembled MSDOS 6.22 COMMAND.COM source code porehion) 
 35553                                  	; ****************************************
 35554                                  ;$MIF345:
 35555                                  ;$MEN333:
 35556                                  $MEN325:
 35557 00005C58 E800FD                  	call	$M_CONVERT2ASC			;;AN000;; Convert to ASCII string
 35558                                  $MEN345: 	; 15/06/2023 - MSDOS 6.22
 35559 00005C5B 09DB                    	or	bx,bx				;;AN000;; Was number negative?
 35560 00005C5D 7405                    	jz	short $MIF349			;;AN000;; No
 35561                                  						;;AN000;; Yes
 35562 00005C5F 31D2                    	xor	dx,dx				;;AN000;;
 35563 00005C61 B22D                    	mov	dl,'-'	; $M_NEG_SIGN		;;AN000;; Put "-" on the stack with the number
 35564 00005C63 52                      	push	dx				;;AN000;;
 35565                                  $MIF349:
 35566 00005C64 55                      	push	bp				;;AN000;; Restore return address
 35567 00005C65 C3                      	retn					;;AN000;; Return
 35568                                  
 35569                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35570                                  ;;
 35571                                  ;;	PROC NAME: $M_DATE_REPLACE
 35572                                  ;;
 35573                                  ;;	FUNCTION: Convert a date to a decimal ASCII string using current
 35574                                  ;;		  country format and prepare to display
 35575                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35576                                  ;;		ES:DI points at VALUE from SUBLIST
 35577                                  ;;	OUTPUTS: CX contains number of characters on stack
 35578                                  ;;		 Top of stack  --> Last character
 35579                                  ;;					. . .
 35580                                  ;;		 Bot of stack  --> First character
 35581                                  ;;	OTHER REGS Revised: DX,AX
 35582                                  ;;
 35583                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35584                                  
 35585                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35586                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35587                                  $M_DATE_REPLACE:
 35588 00005C66 5D                      	pop	bp				;;AN000;; Save return address
 35589                                  
 35590 00005C67 C706[899A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35591                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 35592                                  	
 35593 00005C6D E86700                  	call	$M_GET_DATE			;;AN000;; Set date format/separator in $M_RT
 35594                                  						;;AN000;; All O.K.?
 35595 00005C70 31D2                    	xor	dx,dx				;;AN000;; Reset DX value
 35596                                  	; 12/04/2023
 35597                                  	;xor	ax,ax				;;AN000;; Reset AX value
 35598                                  	
 35599                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0
 35600                                  	;;cmp	word [$M_RT+76],0		;;AN000;; USA Date Format
 35601                                  	;jne	short $MIF351
 35602                                  	; 12/04/2023
 35603 00005C72 A1[8B9A]                	mov	ax,[$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 35604 00005C75 09C0                    	or	ax,ax
 35605 00005C77 751D                    	jnz	short $MIF351
 35606                                  
 35607 00005C79 E87200                  	call	$M_YEAR				;;AN000;; Get Year
 35608 00005C7C E88100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35609                                  
 35610 00005C7F FF36[969A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35611                                  	;push	word [$M_RT+87]			;;AN000;;
 35612                                  	
 35613 00005C83 41                      	inc	cx				;;AN000;; Increment count
 35614 00005C84 31C0                    	xor	ax,ax				;;AN000;; Reset AX value
 35615                                  
 35616 00005C86 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35617                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35618 00005C89 E87400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35619                                  	
 35620 00005C8C FF36[969A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35621                                  	;push	word [$M_RT+87]			;;AN000;;
 35622                                  
 35623 00005C90 41                      	inc	cx				;;AN000;; Increment count
 35624 00005C91 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35625                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35626                                  	; 12/04/2023
 35627                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35628 00005C94 EB3C                    	jmp	short $MIF354 ; **
 35629                                  $MIF351:
 35630                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],1
 35631                                  	;;cmp	word [$M_RT+76],1		;;AN000;; EUROPE Date Format
 35632                                  	;jne	short $MIF353
 35633                                  	; 12/04/2023
 35634                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 35635 00005C96 48                      	dec	ax 
 35636 00005C97 751D                    	jnz	short $MIF352 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] <> 1
 35637                                  
 35638 00005C99 E85200                  	call	$M_YEAR				;;AN000;; Get Year
 35639 00005C9C E86100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35640                                  
 35641 00005C9F FF36[969A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35642                                  	;push	word [$M_RT+87]			;;AN000;;
 35643                                  	
 35644 00005CA3 41                      	inc	cx				;;AN000;; Increment count
 35645 00005CA4 31C0                    	xor	ax,ax				;;AN000;; Reset AX
 35646                                  
 35647 00005CA6 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35648                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35649 00005CA9 E85400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35650                                  
 35651 00005CAC FF36[969A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35652                                  	;push	word [$M_RT+87]			;;AN000;;
 35653                                  
 35654 00005CB0 41                      	inc	cx				;;AN000;;
 35655                                  	      
 35656 00005CB1 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35657                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35658                                  
 35659                                  	; 12/04/2023
 35660                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35661 00005CB4 EB1C                    	jmp	short $MIF354 ; **
 35662                                  	; 12/04/2023
 35663                                  $MIF352:
 35664                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT]-1 ; *
 35665 00005CB6 48                      	dec	ax
 35666                                  	;jz	short $MIF353 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] = 2
 35667                                  	;xor	ax,ax
 35668                                  	;jmp	short $MIF355
 35669                                  	; 12/04/2023
 35670 00005CB7 751C                    	jnz	short $MIF355
 35671                                  $MIF353:
 35672                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],2
 35673                                  	;;cmp	word [$M_RT+76],2		;;AN000;; JAPAN Date Format
 35674                                  	;jne	short $MIF355
 35675                                  
 35676 00005CB9 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35677                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35678 00005CBC E84100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35679                                  	
 35680 00005CBF FF36[969A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35681                                  	;push	word [$M_RT+87]			;;AN000;;
 35682                                  
 35683 00005CC3 41                      	inc	cx				;;AN000;;
 35684                                  
 35685 00005CC4 8A4404                  	 mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35686                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35687 00005CC7 E83600                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35688                                  	
 35689 00005CCA FF36[969A]              	 push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35690                                  	;push	word [$M_RT+87]			;;AN000;;
 35691                                  	
 35692 00005CCE 41                      	inc	cx				;;AN000;;
 35693                                  
 35694 00005CCF E81C00                  	call	$M_YEAR				;;AN000;; Get Year
 35695                                  	; 12/04/2023
 35696                                  $MIF354:
 35697 00005CD2 E82B00                  	call	$M_CONVERTDATE	; **		;;AN000;; Convert it to an ASCII string
 35698                                  $MIF355:
 35699 00005CD5 55                      	push	bp				;;AN000;; Restore return address
 35700 00005CD6 C3                      	retn					;;AN000;; Return
 35701                                  
 35702                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35703                                  ;;
 35704                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35705                                  
 35706                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35707                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35708                                  $M_GET_DATE:
 35709                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 35710                                  	;mov	al,0 				;;AN000;; Get current country info
 35711                                  	; 12/04/2023
 35712 00005CD7 B80038                  	mov	ax,3800h
 35713                                  	;
 35714 00005CDA 8D16[8B9A]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35715                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 35716 00005CDE CD21                    	int	21h				;;AN000;;
 35717 00005CE0 730B                    	jnc	short $MIF357
 35718                                  	;
 35719 00005CE2 C706[8B9A]0000          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0 ; $M_DEF_DATE_FORM
 35720                                  	;mov	word [$M_RT+76+0],0		;;AN000;; Set default date format (BH)
 35721 00005CE8 C606[969A]2D            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA],'-' ; $M_DEF_DATE_SEP
 35722                                  	;mov	byte [$M_RT+87],'-'		;;AN000;; Set default date separator (BL)
 35723                                  $MIF357:
 35724 00005CED C3                      	retn					;;AN000;;
 35725                                  
 35726                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35727                                  ;;
 35728                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35729                                  
 35730                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35731                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35732                                  $M_YEAR:
 35733 00005CEE 8B4402                  	mov	ax,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35734                                  	;mov	ax,[si+2]			;;AN000;; Get Year
 35735                                  
 35736                                  	;test	$M_SL.$M_S_FLAG,Date_MDY_4 and $M_DATE_MASK
 35737 00005CF1 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35738                                  	;test	byte [si+7],10h			;;AN000;; Was Month/Day/Year (2 Digits) specified?
 35739 00005CF5 7508                    	jnz	short $MIF359			;;AN000;; No
 35740                                  						;;AN000;; Yes
 35741 00005CF7 83F863                  	cmp	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 35742 00005CFA 7603                    	jna	short $MIF360			;;AN000;;
 35743 00005CFC B86300                  	mov	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 35744                                  $MIF360:
 35745                                  $MIF359:
 35746 00005CFF C3                      	retn					;;AN000;;
 35747                                  
 35748                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35749                                  ;;
 35750                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35751                                  
 35752                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35753                                  $M_CONVERTDATE:
 35754                                  $M_CONVERTTIME: ; *!*!  ; 12/04/2023
 35755 00005D00 8F06[8B9A]              	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35756                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 35757 00005D04 880E[819A]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 35758                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 35759 00005D08 E850FC                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 35760 00005D0B 49                      	dec	cx				;;AN000;; Test if size only grew by 1
 35761 00005D0C 3A0E[819A]              	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 35762 00005D10 7505                    	jne	short $MIF363			;;AN000;; No
 35763 00005D12 B83000                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 35764 00005D15 50                      	push	ax				;;AN000;; Save it
 35765 00005D16 41                      	inc	cx				;;AN000;; Count it
 35766                                  $MIF363:
 35767 00005D17 41                      	inc	cx				;;AN000;; Restore CX
 35768 00005D18 FF36[8B9A]              	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35769                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 35770 00005D1C C3                      	retn
 35771                                  
 35772                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35773                                  ;;
 35774                                  ;;	PROC NAME: $M_TIME_REPLACE
 35775                                  ;;
 35776                                  ;;	FUNCTION: Convert a time to a decimal ASCII string
 35777                                  ;;		  and prepare to display
 35778                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35779                                  ;;		ES:DI points at VALUE from SUBLIST
 35780                                  ;;	OUTPUTS: CX contains number of characters on stack
 35781                                  ;;		 Top of stack  --> Last character
 35782                                  ;;					. . .
 35783                                  ;;		 Bot of stack  --> First character
 35784                                  ;;	REGS USED: BP,CX,AX
 35785                                  ;;
 35786                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35787                                  
 35788                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35789                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM							     ;;
 35790                                  $M_TIME_REPLACE:
 35791 00005D1D 5D                      	pop	bp				;;AN000;; Save return address
 35792                                  
 35793 00005D1E C706[899A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35794                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 35795                                  
 35796 00005D24 E87800                  	call	$M_GET_TIME			;;AN000;; All O.K.?
 35797                                  
 35798                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 35799 00005D27 F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1
 35800                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 35801 00005D2B 741A                    	jz	short $MIF365			;;AN000;; No
 35802                                  						;;AN000;; Yes
 35803 00005D2D 803E[9C9A]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 35804                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 35805 00005D32 7513                    	jne	short $MIF366			;;AN000;; No
 35806                                  						;;AN000;; Yes
 35807 00005D34 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35808                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 35809 00005D37 3C0C                    	cmp	al,12				;;AN000;; Is hour 12 or less?
 35810 00005D39 7C04                    	jl	short $MLL367 ; jnge		;;AN000;; Yes	
 35811 00005D3B 3C17                    	cmp	al,23				;;AN000;; Is hour 24 or greater?
 35812 00005D3D 7E04                    	jng	short $MIF367 ; jle		;;AN000;; No
 35813                                  $MLL367:
 35814 00005D3F B061                    	mov	al,'a'	; $M_AM			;;AN000;;
 35815                                  	;push	ax				;;AN000;; Push an "a" to represent AM.
 35816                                  	;inc	cx				;;AN000;;
 35817                                  	;jmp	short $MEN367			;;AN000;;
 35818                                  	; 12/04/2023
 35819 00005D41 EB02                    	jmp	short $MEN367 ; *
 35820                                  $MIF367:
 35821 00005D43 B070                    	mov	al,'p'	; $M_PM			;;AN000;;
 35822                                  $MEN367:	; * ; 12/04/2023
 35823 00005D45 50                      	push	ax				;;AN000;; Push an "p" to represent PM.
 35824 00005D46 41                      	inc	cx				;;AN000;;
 35825                                  ;$MEN367:
 35826                                  $MIF366:
 35827                                  $MIF365:					;;AN000;;
 35828 00005D47 31C0                    	xor	ax,ax				;;AN000;;
 35829 00005D49 31D2                    	xor	dx,dx				;;AN000;;
 35830                                  	
 35831                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 35832 00005D4B F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35833                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 35834 00005D4F 740B                    	jz	short $MIF372			;;AN000;;
 35835                                  
 35836 00005D51 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35837                                  	;mov	al,[si+5]			;;AN000;; Get Hundreds
 35838 00005D54 E8A9FF                  	call	$M_CONVERTTIME			;;AN000;;
 35839                                  
 35840 00005D57 FF36[949A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA]
 35841                                  	;push	word [$M_RT+85]			;;AN000;;
 35842 00005D5B 41                      	inc	cx				;;AN000;;
 35843                                  $MIF372:
 35844                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 35845 00005D5C F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35846                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 35847 00005D60 7506                    	jnz	short $MLL374			;;AN000;; No
 35848                                  
 35849                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSS_Cty AND $M_SIZE_MASK
 35850 00005D62 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35851                                  	;test	byte [si+7],10h			;;AN000;; Was Hour/Min/Sec (12 Hour) specified?
 35852 00005D66 740B                    	jz	short $MIF374			;;AN000;; No
 35853                                  $MLL374:
 35854 00005D68 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35855                                  	;mov	al,[si+4]			;;AN000;; Get Seconds
 35856 00005D6B E892FF                  	call	$M_CONVERTTIME			;;AN000;;
 35857                                  
 35858 00005D6E FF36[989A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 35859                                  	;push	word [$M_RT+89]			;;AN000;;
 35860 00005D72 41                      	inc	cx				;;AN000;;
 35861                                  $MIF374:	;;  Do Hour/Min (12 Hour)
 35862 00005D73 8A4403                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+1]
 35863                                  	;mov	al,[si+3]			;;AN000;; Get Minutes
 35864 00005D76 E887FF                  	call	$M_CONVERTTIME			;;AN000;;
 35865                                  
 35866 00005D79 FF36[989A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 35867                                  	;push	word [$M_RT+89]			;;AN000;;
 35868 00005D7D 41                      	inc	cx				;;AN000;;
 35869                                  
 35870 00005D7E 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35871                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 35872                                  
 35873                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 35874 00005D81 F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1 
 35875                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 35876 00005D85 7413                    	jz	short $MIF376			;;AN000;; No
 35877                                  
 35878 00005D87 803E[9C9A]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 35879                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 35880 00005D8C 750C                    	jne	short $MIF377			;;AN000;; No
 35881                                  
 35882 00005D8E 3C0D                    	cmp	al,13				;;AN000;; Is hour less than 12?
 35883 00005D90 7C02                    	jnge	short $MIF378 ; jl
 35884 00005D92 2C0C                    	sub	al,12				;;AN000;; Set to a 12 hour value
 35885                                  $MIF378:
 35886                                  	;cmp	al,0				;;AN000;; Is hour less than 12?
 35887                                  	;jne	short $MIF380			;;AN000;; No
 35888                                  	; 12/04/2023
 35889 00005D94 20C0                    	and	al,al
 35890 00005D96 7502                    	jnz	short $MIF380	
 35891 00005D98 B00C                    	mov	al,12				;;AN000;; Set to a 12 hour value
 35892                                  $MIF380:
 35893                                  $MIF377:
 35894                                  $MIF376:
 35895 00005D9A E8BEFB                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to ASCII
 35896 00005D9D 55                      	push	bp				;;AN000;; Restore return address
 35897 00005D9E C3                      	retn					;;AN000;; Return
 35898                                  
 35899                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35900                                  ;;
 35901                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35902                                  
 35903                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35904                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35905                                  $M_GET_TIME:
 35906                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 35907                                  	;mov	al,0 				;;AN000;; Get current country info
 35908                                  	; 12/04/2023
 35909 00005D9F B80038                  	mov	ax,3800h
 35910                                  	;
 35911 00005DA2 8D16[8B9A]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35912                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 35913 00005DA6 CD21                    	int	21h				;;AN000;;
 35914 00005DA8 7310                    	jnc	short $MIF384
 35915                                  
 35916 00005DAA C706[9C9A]0100          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],1 ; $M_DEF_TIME_FORM
 35917                                  	;mov	word [$M_RT+93],1		;;AN000;; Set default time format (BH)
 35918 00005DB0 C606[989A]3A            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA],':' ; $M_DEF_TIME_SEP
 35919                                  	;mov	byte [$M_RT+89],':'		;;AN000;; Set default time separator (BL)
 35920 00005DB5 C606[949A]2E            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA],'.' ; $M_DEF_DECI_SEP
 35921                                  	;mov	byte [$M_RT+85],'.'		;;AN000;; Set default time separator (BL)		
 35922                                  $MIF384:
 35923 00005DBA C3                      	retn					;;AN000;;
 35924                                  
 35925                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35926                                  ;;
 35927                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35928                                  
 35929                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35930                                  
 35931                                  ; 12/04/2023 
 35932                                  ;; ($M_CONVERTTIME is same with $M_CONVERTDATE)
 35933                                  %if 0
 35934                                  $M_CONVERTTIME:
 35935                                  $M_CONVERTDATE: ; *!*!  ; 12/04/2023
 35936                                  	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35937                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 35938                                  	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 35939                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 35940                                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 35941                                  	dec	cx				;;AN000;; Test if size only grew by 1
 35942                                  	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 35943                                  	jne	short $MIF386			;;AN000;; No
 35944                                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 35945                                  	push	ax				;;AN000;; Save it
 35946                                  	inc	cx				;;AN000;; Count itount it
 35947                                  $MIF386:
 35948                                  	inc	cx				;;AN000;; Restore CX
 35949                                  	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35950                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 35951                                  	retn
 35952                                  %endif
 35953                                  
 35954                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35955                                  ;;
 35956                                  ;;	PROC NAME: $M_WAIT_FOR_INPUT
 35957                                  ;;
 35958                                  ;;	FUNCTION:  To accept keyed input and return extended key value
 35959                                  ;;		   in AX register
 35960                                  ;;	INPUTS:    DL contains the DOS function requested for input
 35961                                  ;;	OUTPUTS:   AX contains the extended key value that was read
 35962                                  ;;	REGS USED:
 35963                                  ;;
 35964                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35965                                  
 35966                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35967                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6123h
 35968                                  $M_WAIT_FOR_INPUT:
 35969 00005DBB 51                      	push	cx				;;AN000;; Save CX
 35970 00005DBC 52                      	push	dx				;;AN000;; Save DX
 35971 00005DBD 1E                      	push	ds				;;AN000;; Save Data segment
 35972                                  
 35973 00005DBE 80FAC0                  	cmp	dl,0C0h ; DOS_CLR_KEYB_BUF_MASK	;;AN001;; Are we to clear the keyboard buffer?
 35974 00005DC1 7608                    	jna	short $MIF388	; jbe		;;AN001;; No,
 35975                                  						;;AN001;; Yes,
 35976 00005DC3 88D0                    	mov	al,dl				;;AN001;; Mov function into AL
 35977 00005DC5 240F                    	and	al,0Fh	; LOW_NIB_MASK		;;AN001;; Mask out the C in high nibble
 35978 00005DC7 B40C                    	mov	ah,0Ch	; DOS_CLR_KEYB_BUF 	;;AN001;; Set input function
 35979 00005DC9 EB02                    	jmp	short $MEN388
 35980                                  $MIF388:
 35981 00005DCB 88D4                    	mov	ah,dl				;;AN000;; Put DOS function in AH
 35982                                  $MEN388:
 35983 00005DCD 06                      	push	es				;;AN000;; Get output buffer segment
 35984 00005DCE 1F                      	pop	ds				;;AN000;;
 35985 00005DCF 89FA                    	mov	dx,di				;;AN000;; Get output buffer offset in case needed
 35986 00005DD1 CD21                    	int	21h				;;AN000;; Get keyboard input
 35987 00005DD3 1F                      	pop	ds				;;AN000;;
 35988 00005DD4 80FA0A                  	cmp	dl,0Ah	; DOS_BUF_KEYB_INP	;;AN000;;
 35989                                  	;clc					;;AN000;;
 35990 00005DD7 7412                    	je	short $MIF391
 35991 00005DD9 E85BFB                  	call	$M_IS_IT_DBCS			;;AN000;; Is this character DBCS?
 35992 00005DDC 730B                    	jnc	short $MIF392
 35993 00005DDE 88C1                    	mov	cl,al				;;AN000;; Save first character
 35994 00005DE0 88D4                    	mov	ah,dl				;;AN001;; Get back function
 35995 00005DE2 CD21                    	int	21h				;;AN000;; Get keyboard input
 35996 00005DE4 88CC                    	mov	ah,cl				;;AN000;; Retreive first character  AX = xxxx
 35997 00005DE6 F8                      	clc					;;AN000;; Clear carry condition
 35998 00005DE7 EB02                    	jmp	short $MEN392
 35999                                  $MIF392:
 36000 00005DE9 B400                    	mov	ah,0				;;AN000;; AX = 00xx where xx is SBCS
 36001                                  $MEN392:
 36002                                  $MIF391:
 36003                                  	;jc	short $MIF396 ; 15/06/2023
 36004 00005DEB 5A                      	pop	dx				;;AN000;;
 36005 00005DEC 59                      	pop	cx				;;AN000;;
 36006                                  	;jmp	short $MEN396
 36007 00005DED C3                      	retn
 36008                                  
 36009                                  	; 15/06/2023
 36010                                  ;$MIF396:
 36011                                  	;add	sp,4				;;AN000;;
 36012                                  	;stc					;;AN000;; Reset carry flag
 36013                                  ;$MEN396:
 36014                                  	;retn					;;AN000;; Return
 36015                                  
 36016                                  ; ----------------------------
 36017                                  ; MSDOS 6.0, TPRINTF.ASM, 1991
 36018                                  ; ----------------------------
 36019                                  ; include msgdcl.inc
 36020                                  ; ----------------------------
 36021                                  
 36022                                  ;============================================================================
 36023                                  ; HIGHLOAD.INC, MSDOS 6.0, 1992
 36024                                  ;============================================================================
 36025                                  ; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 36026                                  
 36027                                  ;****************************************************************************
 36028                                  ;
 36029                                  ; This file contains routines needed to parse and implement user-given
 36030                                  ; command-line options of the form "/S/L:3,0x500;2;7,127;0x0BE4". InitVar()
 36031                                  ; and Parsevar() are used to parse this data and place it in encoded form into
 36032                                  ; the variables in highvar.inc, for use by the rest of the routines.
 36033                                  ;
 36034                                  ; DeviceHigh accepts this command-line (handled in sysconf.asm, not here):
 36035                                  ;    DEVICEHIGH SIZE=hhhhhh module opts
 36036                                  ; Or, DeviceHigh and LoadHigh accept any of the following:
 36037                                  ;    DH/LH module opts
 36038                                  ;    DH/LH [/S][/L:umb[,size][;umb[,size]]*] module opts
 36039                                  ;    DH/LH [/L:umb[,size][;umb[,size]]*][/S] module opts
 36040                                  ; The initial UMB,SIZE pair designates the module's load address; the remainder
 36041                                  ; of the UMB and SIZE pairs are used to indicate specific UMBs to be left
 36042                                  ; available during the load.
 36043                                  ;
 36044                                  ; When an actual load is ready to be performed, a call to HideUMBs() will
 36045                                  ; temporarily allocate (as owner 8+"HIDDEN  ") all free elements in any
 36046                                  ; upper-memory block which was not specified by the user... in addition, if
 36047                                  ; UMBs were marked to shrink (/S option) to a certain size ("umb,size"), any
 36048                                  ; elements in that umb SAVE the lower-half of the newly-shrunken one are also
 36049                                  ; allocated.  After the load, the function UnHideUMBs() (in highexit.inc) will
 36050                                  ; free any UMBs so allocated.
 36051                                  ;
 36052                                  ; When a device driver loads, there is the additional problem of allocating its
 36053                                  ; initial load site; this should be restricted to the first UMB specified on
 36054                                  ; the command-line.  The function FreezeUM temporarily allocates all remaining
 36055                                  ; free upper-memory elements (as owner 8+"FROZEN  "), except those in the load
 36056                                  ; UMB.  Then the initial allocation may be made, and a call to UnFreeze will
 36057                                  ; return any so-allocated memory elements to FREE, for the true load.  Note
 36058                                  ; that UnFreeze leaves HIDDEN elements allocated; it only frees FROZEN ones.
 36059                                  ;
 36060                                  ;****************************************************************************
 36061                                  
 36062                                  ;___PROCEDURES_______________________________________________________________
 36063                                  ;
 36064                                  ;   AddrToUmb   - converts a segment address in AX to its appropriate UMB #
 36065                                  ;   BigFree     - makes ES:0 point to the largest free MCB in UMB given as AL
 36066                                  ;   FixMem      - scans the UM chain and concatenates adjacent free MCBs
 36067                                  ;   FreezeUM    - Marks FROZEN all UM elements now FREE, save those in load UMB
 36068                                  ;   GetLoadSize - Returns the load UMB minimum size (0 if not specified)
 36069                                  ;   GetLoadUMB  - Returns the load UMB number in AL (-1 if not specified)
 36070                                  ;   GetSize     - Returns the UMB in AL's minimum size (0 if not specified)
 36071                                  ;   GetXNum     - reads a 32-bit ASCII number at ES:SI and returns it in DX:AX
 36072                                  ;   HideUMBs    - links UMBs and hides upper-memory as appropriate
 36073                                  ;   InitVar     - initializes all the variables used in ParseVar and HideUMBs
 36074                                  ;   NextMCB     - moves an MCB pointer forward to the next MCB
 36075                                  ;   ParseVar    - parses [/S][/L:umb[,size][;umb[,size]]*] and builds the table
 36076                                  ;   PrTable     - produces a printout of the variables in highvar.inc
 36077                                  ;   StoLoadSize - Overrides the load UMB minimum size with what's in AX
 36078                                  ;   StoLoadUMB  - Overrides the load UMB number with what's in AL
 36079                                  ;   UmbHead     - returns in AX the address of the first UMB block (0x9FFF)
 36080                                  ;   UnFreeze    - Marks FROZEN elements as FREE
 36081                                  ;
 36082                                  ;___VARIABLES________________________________________________________________
 36083                                  ;
 36084                                  ;   gnradix     - After a call to GetXNum, is 16 or 10, depending on the # read
 36085                                  ;
 36086                                  ;   Internal:
 36087                                  ;___PROCEDURES_______________________________________________________________
 36088                                  ;
 36089                                  ;   convUMB     - checks after GetXNum to convert an address to a UMB number
 36090                                  ;   findUMB     - makes ES:0 point to the first MCB in UMB given as AL
 36091                                  ;   fm_link     - links UMBs not already linked in
 36092                                  ;   fm_unlink   - unlinks UMBs if fm_umb is set to 0
 36093                                  ;   frezMCB     - marks as 8+FROZEN the MCB at ES:0
 36094                                  ;   hideMCB     - marks as HIDDEN the MCB at ES:0
 36095                                  ;   hideUMB     - marks as HIDDEN all FREE elements in UMB passed as AL
 36096                                  ;   hideUMB?    - hides as appropriate the UMB in CL
 36097                                  ;   hl_unlink   - unlinks UMBs if fm_umb is set to 0; restores strategy too
 36098                                  ;   incArgc     - increments fm_argc, for use with LH command-line parsing
 36099                                  ;   isEOL       - returns with ZF set iff AL contains CR or LF, or 0
 36100                                  ;   isFreeMCB   - returns with ZF set if current MCB (ES:0) is FREE
 36101                                  ;   isFrozMCB   - returns with ZF set if current MCB (ES:0) is FROZEN
 36102                                  ;   isSpecified - sets ZF if UMB in AL wasn't specified in DH/LH line.
 36103                                  ;   isSysMCB    - sets ZF iff ES points to an MCB owned by "SC" + (8 or 9)
 36104                                  ;   isTiny      - returns with ZF set if user didn't specify /S
 36105                                  ;   isWhite     - returns with ZF set iff AL contains whitespace (or "=")
 36106                                  ;   loadLow     - returns AL==0 if UMB0 == 0, else AL==1
 36107                                  ;   mul32       - multiplies the number in DX:AX by gnradix
 36108                                  ;   parseL      - parses ":nnnn[,nnnn][;nnnn[,nnnn]]*" for ParseVar
 36109                                  ;   setUMBs     - links umbs and sets allocation strategy for a load
 36110                                  ;   shrinkMCB   - breaks an MCB into two pieces, the lowest one's size==AX
 36111                                  ;   stowSiz     - marks a given UMB as having a given minimum size
 36112                                  ;   stowUMB     - marks a given UMB as used, if it hasn't been so marked before
 36113                                  ;   toDigit     - converts a character-digit to its binary counterpart
 36114                                  ;   toPara      - divides DX:AX by 16; result in AX only
 36115                                  ;   toUpper     - accepts one argument (probly a register), and upper-cases it.
 36116                                  ;   unHideMCB   - marks as FREE the MCB at ES:0
 36117                                  ;   unMarkUMB   - marks a given UMB as unused, even if previously marked used
 36118                                  ;
 36119                                  ;****************************************************************************
 36120                                  
 36121                                  ;DOS_CHECK_STRATEGY equ 5800h ; Int 21h, Func 58h, Svc 0 = check alloc strat
 36122                                  ;DOS_SET_STRATEGY   equ 5801h ; Int 21h, Func 58h, Svc 1 = set alloc strategy
 36123                                  ;DOS_CHECK_UMBLINK  equ 5802h ; Int 21h, Func 58h, Svc 2 = check link state
 36124                                  ;DOS_SET_UMBLINK    equ 5803h ; Int 21h, Func 58h, Svc 3 = set link state
 36125                                  ;DOS_GET_DOS_LISTS  equ   52h ; Int 21h, Func 52h = return list of lists
 36126                                  ;DOS_UMB_HEAD       equ   8Ch ; Offset from ES (after func52h) to get UMBHead
 36127                                  
 36128                                  ; -----------------------------------------------------------------------------
 36129                                  ;*** InitVar - initializes all the variables used in ParseVar and HideUMBs
 36130                                  ; -----------------------------------------------------------------------------
 36131                                  ; ENTRY:       None
 36132                                  ; EXIT:        Variables listed in highvar.inc are initialized
 36133                                  ; ERROR EXIT:  None
 36134                                  ; USES:        Flags, variables in highvar.inc
 36135                                  ; -----------------------------------------------------------------------------
 36136                                  ; Note that element 0 references UMB 0 (conventional), not UMB 1.  Its contents
 36137                                  ; are largely ignored, but it is initialized nonetheless.
 36138                                  ; -----------------------------------------------------------------------------
 36139                                  
 36140                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36141                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:615Fh
 36142                                  InitVar:	; proc	near
 36143                                  	;push	ax
 36144                                  	;push	cx
 36145                                  	;push	di
 36146 00005DEE 06                      	push	es ; * es = ds
 36147 00005DEF 8E06[159E]              	mov	es,[RESSEG]		;Point ES into appropriate data segment
 36148 00005DF3 31C0                    	xor	ax,ax
 36149                                  	;mov	[es:fUmbTiny],al	;Shrink UMBs? (made 1 if /S given)
 36150                                  	;mov	[es:fInHigh],al		;Set to 1 when DH/LH has been called
 36151 00005DF5 26A3[D804]              	mov	[es:fInHigh],ax ; 16/06/2023
 36152 00005DF9 26A3[DA04]              	mov	[es:SegLoad],ax		;Load Address (seg), used for DH only
 36153 00005DFD 26C606[DC04]FF          	mov	byte [es:UmbLoad],0FFh ;UNSPECIFIED
 36154                                  					;Later is the # of the 1st spec'd UMB
 36155 00005E03 26A2[DF04]              	mov	[es:fm_argc],al		;Start with zero args having been read
 36156                                  
 36157 00005E07 FC                      	cld
 36158                                  
 36159 00005E08 B91000                  	mov	cx,16 ; MAXUMB		;For each entry
 36160 00005E0B BF[0204]                	mov	di,UmbUsed		;on the UmbUsed array,
 36161 00005E0E F3AA                    	rep	stosb			;	Store 0
 36162                                  
 36163                                  	;mov	cx,16 ; MAXUMB		;Okay... for each entry
 36164 00005E10 B110                    	mov	cl,16
 36165 00005E12 BF[1204]                	mov	di,UmbSize		;on the UmbSize array,
 36166 00005E15 F3AB                    	rep	stosw			;	Store 0
 36167                                  
 36168 00005E17 07                      	pop	es ; * es = ds
 36169                                  	;pop	di
 36170                                  	;pop	cx
 36171                                  	;pop	ax
 36172 00005E18 C3                       	retn
 36173                                  
 36174                                  ;InitVar endp
 36175                                  
 36176                                  ; -----------------------------------------------------------------------------
 36177                                  ;*** FixMem - scans the upper memory chain and concatenates adjacent free MCBs
 36178                                  ; -----------------------------------------------------------------------------
 36179                                  ; ENTRY   : None
 36180                                  ; EXIT    : None
 36181                                  ; ERROR   : None
 36182                                  ; USES    : Flags, fm_umb, fm_strat
 36183                                  ; -----------------------------------------------------------------------------
 36184                                  
 36185                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36186                                  FixMem:
 36187                                  	;push	ax
 36188                                  	;push	bx
 36189                                  	;push	cx
 36190                                  	;push	dx
 36191 00005E19 06                      	push	es
 36192                                  
 36193 00005E1A E84900                  	call	fm_link			; Link in UMBs
 36194                                  
 36195 00005E1D E82302                  	call	UmbHead			; Get first upper-memory MCB address (0x9FFF)
 36196 00005E20 723F                    	jc	short fmX		; (if couldn't get it, leave now).
 36197                                  
 36198 00005E22 8EC0                    	mov	es,ax			; It returns in AX, so move it to ES.
 36199                                  
 36200                                  ; - Walk MCB Chain ------------------------------------------------------------
 36201                                  
 36202 00005E24 31D2                    	xor	dx,dx			; We're keeping the address of the last MCB
 36203 00005E26 89D1                    	mov 	cx,dx			; in CX... and the last owner
 36204 00005E28 42                      	inc	dx			; in dx as we go through the loop:
 36205                                  
 36206                                  ; ------------------------------------------
 36207                                  ; FM10--DX  = last MCB's owner's PSP address
 36208                                  ;       CX  = last MCB's address (segment)
 36209                                  ; ------------------------------------------
 36210                                  
 36211                                  fm10:	
 36212 00005E29 26A00000                	mov	al,[es:arena_signature]	; if 'Z', don't repeat loop
 36213                                  	;mov	al,[es:0]
 36214 00005E2D 268B1E0100              	mov	bx,[es:arena_owner]	; if not zero, do nothing
 36215                                  	;mov	bx,[es:1]
 36216 00005E32 09D3                    	or	bx,dx			; dx was owner of previous MCB
 36217 00005E34 7516                    	jnz	short fm30		; If not both zero, don't cat.
 36218                                  
 36219                                  ; - Coalesce memory blocks at ES:00 and CX:00 ---------------------------------
 36220                                  
 36221                                  fm20:	
 36222 00005E36 268B1E0300              	mov	bx,[es:arena_size]	; Grab this block's Size,
 36223                                  	;mov	bx,[es:3]
 36224 00005E3B 8EC1                    	mov	es,cx			; Go back to prev MCB's address
 36225 00005E3D 26A20000                	mov	[es:arena_signature], al ; & move the SECOND sig here
 36226                                  	;mov	[es:0],al
 36227                                  
 36228 00005E41 26031E0300              	add	bx,[es:arena_size]	; Size += first MCB's size
 36229                                  	;add	bx,1			; And add one for the header
 36230 00005E46 43                      	inc	bx
 36231 00005E47 26891E0300              	mov	[es:arena_size],bx	; Write the size
 36232                                  
 36233                                  	; ---------------------------------------------------------------------
 36234                                  fm30:	
 36235 00005E4C 8CC1                    	mov	cx,es			; Put this address on the stack
 36236 00005E4E 268B160100              	mov	dx,[es:arena_owner]	; And remember its owner
 36237                                  	;mov	dx,[es:1]
 36238                                  
 36239                                  	;NextMCB es,bx			; Move to the next MCB
 36240                                  	
 36241 00005E53 8CC3                    	mov	bx,es
 36242                                  	;add	bx,[es:3]
 36243 00005E55 26031E0300              	add	bx,[es:arena_size]
 36244 00005E5A 43                      	inc	bx
 36245 00005E5B 8EC3                    	mov	es,bx
 36246                                  
 36247                                  	;cmp	al,'Z'	; cmp al,5Ah
 36248 00005E5D 3C5A                    	cmp	al,arena_signature_end
 36249 00005E5F 75C8                    	jnz	short fm10		; If signature != 'Z', there are more.
 36250                                  fmX:	
 36251 00005E61 E81900                  	call	fm_unlink		; Unlink UMBs
 36252                                  
 36253 00005E64 07                      	pop	es
 36254                                  	;pop	dx
 36255                                  	;pop	cx
 36256                                  	;pop	bx
 36257                                  	;pop	ax
 36258 00005E65 C3                      	retn
 36259                                  
 36260                                  ; -----------------------------------------------------------------------------
 36261                                  ; 16/06/2023
 36262                                  
 36263                                  ;INT 21h - DOS 5+ - GET OR SET UMB LINK STATE
 36264                                  ; .......................................................
 36265                                  ;     AH = 58h
 36266                                  ;     AL = subfunction
 36267                                  ;	02h get UMB link state
 36268                                  ;	    Return:
 36269                                  ;		AL = current link state
 36270                                  ;		  00h - UMBs not part of DOS memory chain
 36271                                  ;		  01h - UMBs in DOS memory chain
 36272                                  ;	03h set UMB link state
 36273                                  ;	    BX = new link state
 36274                                  ;		0000h - remove UMBs from DOS memory chain
 36275                                  ;		0001h - add UMBs to DOS memory chain
 36276                                  ;
 36277                                  ;Return: CF clear if successful
 36278                                  ;	CF set on error
 36279                                  ;	AX = error code (01h) (see #01680)
 36280                                  ; .......................................................
 36281                                  
 36282                                  ; -----------------------------------------------------------------------------
 36283                                  ;*** fm_link - links UMBs not already linked in
 36284                                  ; -----------------------------------------------------------------------------
 36285                                  ; ENTRY:    None
 36286                                  ; EXIT:     fm_umb == 0 if not linked in previously, 1 if already linked in
 36287                                  ; ERROR:    None
 36288                                  ; USES:     AX, BX, fm_umb
 36289                                  ; -----------------------------------------------------------------------------
 36290                                  
 36291                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36292                                  fm_link:
 36293 00005E66 B80258                  	mov	ax,5802h ; DOS_CHECK_UMBLINK
 36294 00005E69 CD21                    	int	21h			; Current link-state is now in al
 36295                                  
 36296                                  	;putdata fm_umb,al		; So store it in fm_umb for later
 36297                                  
 36298                                  	;push	es
 36299                                  	;mov	es,[RESSEG]
 36300                                  	;mov	[es:fm_umb],al
 36301                                  	;pop	es
 36302 00005E6B 1E                      	push	ds
 36303 00005E6C 8E1E[159E]              	mov	ds,[RESSEG]
 36304 00005E70 A2[DD04]                	mov	[fm_umb],al
 36305 00005E73 1F                      	pop	ds
 36306                                  
 36307 00005E74 B80358                  	mov	ax,5803h ; DOS_SET_UMBLINK
 36308 00005E77 BB0100                  	mov	bx,1
 36309 00005E7A CD21                    	int	21h
 36310 00005E7C C3                      	retn
 36311                                  
 36312                                  ; -----------------------------------------------------------------------------
 36313                                  ;*** fm_unlink - unlinks UMBs if fm_umb is set to 0
 36314                                  ; -----------------------------------------------------------------------------
 36315                                  ; ENTRY:    fm_umb == 1 : leave linked, else unlink
 36316                                  ; EXIT:     None
 36317                                  ; ERROR:    None
 36318                                  ; USES:     AX, BX
 36319                                  ; -----------------------------------------------------------------------------
 36320                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36321                                  fm_unlink:
 36322 00005E7D 31DB                    	xor	bx,bx
 36323                                  	
 36324                                  	;getdata bl,fm_umb		; fm_umb already has the old link-state
 36325                                  
 36326 00005E7F 1E                      	push    ds
 36327 00005E80 8E1E[159E]              	mov     ds,[RESSEG]
 36328 00005E84 8A1E[DD04]              	mov     bl,[fm_umb]
 36329 00005E88 1F                      	pop     ds
 36330                                  	
 36331 00005E89 B80358                  	mov	ax,5803h ; DOS_SET_UMBLINK
 36332 00005E8C CD21                    	int	21h			; so just use that, and call int 21h
 36333 00005E8E C3                      	retn
 36334                                  
 36335                                  ; -----------------------------------------------------------------------------
 36336                                  ;*** ParseVar - parses [/S][/L:umb[,size][;umb[,size]]*] and builds the table
 36337                                  ; laid out in highvar.inc
 36338                                  ; -----------------------------------------------------------------------------
 36339                                  ; ENTRY:    ES:SI points to command tail of LoadHigh/DeviceHigh (whitespace ok)
 36340                                  ; EXIT:     ES:SI points to first character in child program name
 36341                                  ; ERROR:    ES:SI points to character which caused error, carry set, AX == code
 36342                                  ; USES:     ES:SI, AX, flags, variables in highvar.inc
 36343                                  ; -----------------------------------------------------------------------------
 36344                                  ; Error codes (in AX if carry set on return):
 36345                                  ;
 36346                                  
 36347                                  ;PV_InvArg	equ	1	; Invalid argument passed
 36348                                  ;PV_BadUMB	equ	2	; Bad UMB number passed (duplicate?)
 36349                                  ;PV_InvSwt	equ	3	; Unrecognized switch passed
 36350                                  
 36351                                  ;
 36352                                  ; This routine exects ES:SI to point to a string much like the following:
 36353                                  ;    "/S/L:1,200;2 module options"
 36354                                  ; Optionally, the string can begin with whitespace; neither /S nor /L is
 36355                                  ; required, though that's what this routine is supposed to parse.
 36356                                  ;
 36357                                  
 36358                                  ;optS		equ	'S'	; /S
 36359                                  ;optL		equ	'L'	; /L:...
 36360                                  
 36361                                  ;
 36362                                  ; -----------------------------------------------------------------------------
 36363                                  ; LoadHigh has a list of arguments, returned by cparse, which is used to create
 36364                                  ; a command-line for spawning a child process. For a typical LH command, say,
 36365                                  ;     lh /l:1,1000;2 print/d:lpt2
 36366                                  ; the arguments would look like (one per line):
 36367                                  ;     lh
 36368                                  ;     /l
 36369                                  ;     1
 36370                                  ;     1000
 36371                                  ;     2
 36372                                  ;     print
 36373                                  ;     /d
 36374                                  ;     :lpt2
 36375                                  ; In short, if "print" were, say, "43", there'd be no way to determine which
 36376                                  ; arg was the filename. So, inside this routine, we keep a running counter
 36377                                  ; of the number of arguments LH will need to skip in order to get to the
 36378                                  ; program name. The "lh" is implicit--it'll always have to skip that. So if
 36379                                  ; there's no "/l" or "/s", fm_argc will be 0 ... other than that, 1 is added
 36380                                  ; for:
 36381                                  ;    Each /L
 36382                                  ;    Each /S (there should be only one)
 36383                                  ;    Each UMB number (they follow ":" or ";")
 36384                                  ;    Each UMB size   (they follow ",")
 36385                                  ; So, in the above example, fm_argc would be 4-- and LH would skip right to
 36386                                  ; "print". Note that InitVar initializes fm_argc to zero.
 36387                                  ; -----------------------------------------------------------------------------
 36388                                  
 36389                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36390                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6216h
 36391                                  ParseVar:	; proc	near
 36392                                  	;push	di
 36393                                  	;push	ds ; *
 36394                                  	;push	es
 36395                                  	;
 36396                                  	; 16/06/2023
 36397                                  	; es = ds (from 'ParseLhCmd')
 36398                                  	;push	es		; Make DS:SI point to it, as well as ES:SI
 36399                                  	;pop	ds		; (regardless if we're in devhigh or loadhigh)
 36400                                  	
 36401 00005E8F FC                      	cld
 36402                                  
 36403                                  ; ------------------------------------------------
 36404                                  ; PV10--ES:SI = any whitespace on the command-line
 36405                                  ; ------------------------------------------------
 36406                                  
 36407                                  pv10:	
 36408 00005E90 AC                      	lodsb			; here, ES:SI=="  /L..."--must eat whitespace
 36409 00005E91 E8A800                  	call	isWhite
 36410 00005E94 74FA                    	jz	short pv10	;       ES:SI==" /L..."--keep eating.
 36411 00005E96 3C2F                    	cmp	al,'/' ; SWTCH
 36412 00005E98 7404                    	je	short pv20	;       ES:SI=="/L..."--go process a switch
 36413                                  
 36414 00005E9A 4E                      	dec	si		; Backup--it's now "odule options", and we need
 36415 00005E9B F8                      	clc			; that "m" we just read (or whatever it is).
 36416 00005E9C EB2C                    	jmp	short pvX	; Then return with carry clear == we're done.
 36417                                  pv20:
 36418 00005E9E AC                      	lodsb			; Just read 'S' or 'L', hopefully
 36419                                  
 36420                                  	;toUpper al		; So we make it upper-case, and...
 36421 00005E9F 24DF                    	and	al,0DFh
 36422                                  
 36423 00005EA1 3C53                    	cmp	al,'S' ; optS	; just read 'S'?
 36424 00005EA3 7510                    	jne	short pv30
 36425                                  
 36426 00005EA5 E87E00                  	call	incArgc		; If it's /S, it's another arg for LH to skip.
 36427                                  
 36428                                  	;putdata fUmbTiny,1	; /S, so ES:SI=="  /L..." or " module opts", or
 36429                                  
 36430                                  	;push	es
 36431                                  	;mov	es,[RESSEG]
 36432                                  	;mov	byte [es:fUmbTiny],1
 36433                                  	;pop	es
 36434 00005EA8 1E                      	push	ds
 36435 00005EA9 8E1E[159E]              	mov	ds,[RESSEG]
 36436 00005EAD C606[D904]01            	mov	byte [fUmbTiny],1
 36437 00005EB2 1F                      	pop	ds
 36438                                  
 36439 00005EB3 EBDB                    	jmp	short pv10	; possibly even "/L...".
 36440                                  pv30:	
 36441 00005EB5 3C4C                    	cmp	al,'L' ; optL	; If it's not 'L' either, then it's a bad
 36442 00005EB7 750B                    	jne	short pvE1	; switch!
 36443                                  
 36444 00005EB9 E86A00                  	call	incArgc		; If it's /L, it's another arg for LH to skip.
 36445                                  
 36446 00005EBC E80C00                  	call	parseL
 36447 00005EBF 73CF                    	jnc	short pv10	; If no carry, go back and look for more
 36448                                  
 36449 00005EC1 4E                      	dec	si		; Else, back up and exit.
 36450 00005EC2 EB03                    	jmp	short pvErr	; AX has already been set by parseL
 36451                                  pvE1:	
 36452 00005EC4 B80300                  	mov	ax,3 ; PV_InvSwt
 36453                                  				; Unrecognized switch passed
 36454                                  pvErr:
 36455 00005EC7 4E                      	dec	si
 36456 00005EC8 4E                      	dec	si
 36457 00005EC9 F9                      	stc
 36458                                  pvX:	
 36459                                  	;pop	es
 36460                                  	;pop	ds ; *
 36461                                  	;pop	di
 36462 00005ECA C3                      	retn
 36463                                  
 36464                                  ;ParseVar endp
 36465                                  
 36466                                  ; -----------------------------------------------------------------------------
 36467                                  ;*** parseL - parses ":nnnn[,nnnn][;nnnn[,nnnn]]*" for ParseVar
 36468                                  ; -----------------------------------------------------------------------------
 36469                                  ; ENTRY:    ES:SI points to colon
 36470                                  ; EXIT:     ES:SI points to first character not parsed
 36471                                  ; ERROR:    Carry set; rewind three characters and return (see ParseVar)
 36472                                  ; USES:     ES:SI, flags, AX, CX, DX, variables in highvar.inc
 36473                                  ; -----------------------------------------------------------------------------
 36474                                  ; If the string here is terminated with anything other than whitespace or a
 36475                                  ; switchchar (perhaps it's /S or another /L:... ), then we return with carry
 36476                                  ; set, indicating that they've screwed up the syntax.  The 3-character rewind
 36477                                  ; makes sure the app /L: is reported as being the culprit.
 36478                                  ; -----------------------------------------------------------------------------
 36479                                  
 36480                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36481                                  parseL:
 36482 00005ECB AC                      	lodsb
 36483 00005ECC 3C3A                    	cmp	al,':'		; Make sure they did /L:
 36484 00005ECE 754A                    	jne	short plE1	; If they didn't, return with carry set.
 36485                                  
 36486                                  ; ------------------------------------------
 36487                                  ; PL10--ES:SI = a UMB number, after /L: or ;
 36488                                  ; ------------------------------------------
 36489                                  
 36490                                  pl10:
 36491 00005ED0 E8FD00                  	call	GetXNum		; After this, 'tis ",size" or ";umb" or " mod"
 36492 00005ED3 724B                    	jc	short plE2	; And error if it's a bad number.
 36493 00005ED5 E8C801                  	call	convUMB		; Convert any address to a UMB number
 36494                                  
 36495 00005ED8 88C1                    	mov	cl,al	; !*	; Remember the UMB number
 36496 00005EDA E88300                  	call	stowUMB		; Mark this UMB # as used;
 36497 00005EDD 7241                    	jc	short plE2	; If it was already marked, it'll error
 36498                                  
 36499 00005EDF E84400                  	call	incArgc		; Each UMB number is another arg for LH to skip
 36500                                  
 36501 00005EE2 AC                      	lodsb
 36502 00005EE3 3C3B                    	cmp	al,';'		; Did "umb;" ?
 36503 00005EE5 74E9                    	je	short pl10	; Yep: go back and get another UMB.
 36504                                  
 36505 00005EE7 E85200                  	call	isWhite		; Did "umb " ?
 36506 00005EEA 7439                    	jz	short plX	; Yep: return (it'll go back to whitespace)
 36507                                  
 36508 00005EEC E84200                  	call	isEOL		; Did "umb" ?
 36509 00005EEF 7433                    	jz	short plSwX	; If so, backup and exit like everything's ok
 36510                                  
 36511 00005EF1 3C2F                    	cmp	al,'/' ; SWTCH	; Did "umb/" ? (as in, "/L:1,100;2/S")
 36512 00005EF3 742F                    	je	short plSwX	; If so, back up ES:SI one character and return
 36513                                  
 36514 00005EF5 3C2C                    	cmp	al,','		; Did "umb," ?
 36515 00005EF7 7521                    	jne	short plE1	; Just what the heck DID they do? Return error.
 36516                                  
 36517                                  ; --- Read a size -------------------------------------------------------------
 36518                                  
 36519 00005EF9 E8D400                  	call	GetXNum		; Stop on "size;" or "size " or anything else
 36520 00005EFC 721C                    	jc	short plE1	; And error if it's a bad size.
 36521                                  
 36522 00005EFE E83401                  	call	toPara		; Convert from bytes to paragraphs
 36523                                  
 36524 00005F01 E88600                  	call	stowSiz		; CL still has the UMB number for this routine
 36525                                  
 36526 00005F04 E81F00                  	call	incArgc		; Each UMB size is another arg for LH to skip
 36527                                  
 36528 00005F07 AC                      	lodsb
 36529 00005F08 3C3B                    	cmp	al,';'		; They did "umb,size;", so get another UMB.
 36530 00005F0A 74C4                    	je	short pl10		;
 36531                                  
 36532 00005F0C E82D00                  	call	isWhite		; Did it end with whitespace?
 36533 00005F0F 7414                    	jz	short plX	; If so, we're done here--go back.
 36534                                  
 36535 00005F11 E81D00                  	call	isEOL		; Did they do "umb,size" and end??? (stupid)
 36536 00005F14 740E                    	jz	short plSwX	; If so, backup and exit like everything's ok
 36537                                  
 36538 00005F16 3C2F                    	cmp	al,'/' ; SWTCH	; Did they do "umb,size/" ?
 36539 00005F18 740A                    	je	short plSwX	; If so, again, we're done here.
 36540                                  plE1:	
 36541 00005F1A B80100                  	mov	ax,1 ; PV_InvArg
 36542                                  				; If not, we don't know WHAT they did...
 36543 00005F1D 4E                      	dec	si
 36544 00005F1E F9                      	stc
 36545 00005F1F C3                      	retn
 36546                                  plE2:
 36547                                  	; cf = 1 
 36548 00005F20 B80200                  	mov	ax,2 ; PV_BadUMB
 36549                                  				; In this case, they've specified a UMB twice
 36550                                  	;stc
 36551 00005F23 C3                      	retn
 36552                                  plSwX:
 36553 00005F24 4E                      	dec	si		; If we hit a '/' character, back up one char
 36554                                  				; so the whitespace checker will see it too.
 36555                                  plX:
 36556                                  	; cf = 0
 36557                                  	;clc			; Then just return with carry clear, so
 36558 00005F25 C3                      	retn			; ParseVar will go about its business.
 36559                                  
 36560                                  ; -----------------------------------------------------------------------------
 36561                                  ;*** incArgc - increments fm_argc, for use with LoadHigh command-line parsing
 36562                                  ; -----------------------------------------------------------------------------
 36563                                  ; ENTRY:    None
 36564                                  ; EXIT:     None
 36565                                  ; ERROR:    None
 36566                                  ; USES:     fm_argc, flags
 36567                                  ; -----------------------------------------------------------------------------
 36568                                  
 36569                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36570                                  incArgc:
 36571                                  	;push	ax
 36572                                  
 36573                                  	;;getdata al,fm_argc	; Obtain previous value of fm_argc,
 36574                                  	;
 36575                                  	;push	ds		; getdata (macro)
 36576                                  	;			; getdata al, fm_argc
 36577                                  	;mov	ds,[RESSEG]
 36578                                  	;mov	al,[fm_argc]	; Obtain previous value of fm_argc,
 36579                                  	;pop	ds
 36580                                  	;
 36581                                  	;inc	al		; Increment it,
 36582                                  	;
 36583                                  	;;putdata fm_argc,al	; And store it right back.
 36584                                  	;
 36585                                  	;push	es		; putdata (macro)
 36586                                  	;			; putdata fm_argc, al
 36587                                  	;mov	es,[RESSEG]
 36588                                  	;mov	[es:fm_argc],al	; and store it right back.
 36589                                  	;pop	es
 36590                                  
 36591                                  	; 16/06/2023
 36592 00005F26 1E                      	push	ds
 36593 00005F27 8E1E[159E]              	mov	ds,[RESSEG]
 36594 00005F2B FE06[DF04]              	inc	byte [fm_argc]	; increment fm_argc
 36595 00005F2F 1F                      	pop	ds
 36596                                  
 36597                                  	;pop	ax
 36598 00005F30 C3                      	retn
 36599                                  
 36600                                  ; -----------------------------------------------------------------------------
 36601                                  ;*** isEOL - returns with ZF set iff AL contains CR or LF, or 0
 36602                                  ; -----------------------------------------------------------------------------
 36603                                  ; ENTRY:    AL contains character to test
 36604                                  ; EXIT:     ZF set if AL contains CR or LF, or 0
 36605                                  ; ERROR:    None
 36606                                  ; USES:     ZF
 36607                                  ; -----------------------------------------------------------------------------
 36608                                  
 36609                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36610                                  isEOL:
 36611                                  	;cmp	al,0		; Null-terminator
 36612 00005F31 20C0                    	and	al,al
 36613 00005F33 7406                    	jz	short ieX
 36614 00005F35 3C0D                    	cmp	al,0Dh ; CR	; Carriage Return
 36615 00005F37 7402                    	je	short ieX
 36616 00005F39 3C0A                    	cmp	al,0Ah ; LF	; LineFeed
 36617                                  ieX:
 36618 00005F3B C3                      	retn
 36619                                  
 36620                                  
 36621                                  ; -----------------------------------------------------------------------------
 36622                                  ;*** isWhite - returns with ZF set iff AL contains whitespace (or "=")
 36623                                  ; -----------------------------------------------------------------------------
 36624                                  ; ENTRY:    AL contains character to test
 36625                                  ; EXIT:     ZF set if AL contains space, tab, or equals
 36626                                  ; ERROR:    None
 36627                                  ; USES:     ZF
 36628                                  ; -----------------------------------------------------------------------------
 36629                                  
 36630                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36631                                  isWhite:
 36632 00005F3C 3C20                    	cmp	al,' '		; Space
 36633 00005F3E 7406                    	je	short iwX
 36634 00005F40 3C3D                    	cmp	al,'='		; Equals (treat as whitespace)
 36635 00005F42 7402                    	je	short iwX
 36636 00005F44 3C09                    	cmp	al,09h ; TAB	; Tab
 36637                                  iwX:
 36638 00005F46 C3                      	retn
 36639                                  
 36640                                  ; -----------------------------------------------------------------------------
 36641                                  ;*** unMarkUMB - marks a given UMB as unused, even if previously marked used
 36642                                  ; -----------------------------------------------------------------------------
 36643                                  ; ENTRY:    AL contains UMB number
 36644                                  ; EXIT:     None
 36645                                  ; ERROR:    None
 36646                                  ; USES:     Flags, variables in highvar.inc
 36647                                  ; -----------------------------------------------------------------------------
 36648                                  
 36649                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36650                                  unMarkUMB:
 36651                                  	;;pushreg <ax,bx,di,es>
 36652                                  	;push	ax ; ***
 36653                                  	
 36654                                  	;push	bx ; **
 36655                                  	
 36656                                  	;push	di
 36657                                  	;push	es
 36658 00005F47 1E                      	push	ds ; *	
 36659                                  
 36660                                  	;;dataseg es
 36661                                  	;mov	es,[RESSEG]
 36662                                  
 36663 00005F48 8E1E[159E]              	mov	ds,[RESSEG] ; *
 36664                                  	
 36665                                  	;xor	ah,ah ; 0
 36666                                  	;mov	bx,ax
 36667                                  	;mov	byte [es:bx+UmbUsed],0
 36668                                  	;mov	[bx+UmbUsed],ah ; marks the UMB as unused
 36669 00005F4C 88C3                    	mov	bl,al
 36670 00005F4E 30FF                    	xor	bh,bh ; 0	
 36671 00005F50 88BF[0204]              	mov	[bx+UmbUsed],bh ; 0 ; **
 36672                                  
 36673                                  	;cmp	[es:UmbLoad],al
 36674                                  	;jnz	short umu10
 36675 00005F54 3806[DC04]              	cmp	[UmbLoad],al
 36676 00005F58 7504                    	jne	short umu10
 36677                                  
 36678                                  	;mov	byte [es:UmbLoad],0
 36679                                  	;mov	[UmbLoad],ah	; If unmarked the load UMB, load into convent.
 36680 00005F5A 883E[DC04]              	mov	[UmbLoad],bh ; 0 ; **
 36681                                  umu10:	
 36682 00005F5E 1F                      	pop	ds ; *
 36683                                  	;;popreg <es,di,bx,ax>
 36684                                  	;pop	es
 36685                                  	;pop	di
 36686                                  	
 36687                                  	;pop	bx ; **
 36688                                  	
 36689                                  	;pop	ax ; ***
 36690                                  
 36691                                  	;;normseg es
 36692                                  	
 36693 00005F5F C3                      	retn
 36694                                  
 36695                                  ; -----------------------------------------------------------------------------
 36696                                  ;*** stowUMB - marks a given UMB as used, if it hasn't been so marked before
 36697                                  ;            -- accepts a UMB # in AL, and makes sure it hasn't yet been
 36698                                  ; listed in the /L:... chain.  If it's the first one specified, it sets UmbLoad
 36699                                  ; to that UMB #... and in any case, it marks the UMB as specified.
 36700                                  ; -----------------------------------------------------------------------------
 36701                                  ; ENTRY:    AL contains UMB number, as specified by the user
 36702                                  ; EXIT:     None
 36703                                  ; ERROR:    Carry set if UMB # is less than 0 or >= MAXUMB (see highvar.inc)
 36704                                  ; USES:     AX, Flags, variables in highvar.inc
 36705                                  ; -----------------------------------------------------------------------------
 36706                                  
 36707                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36708                                  stowUMB:
 36709 00005F60 3C10                    	cmp	al,16 ; MAXUMB
 36710 00005F62 7202                    	jb	short su10
 36711 00005F64 F9                      	stc
 36712 00005F65 C3                      	retn			; Ooops-- UMB>=MAXUMB
 36713                                  su10:
 36714                                  	;pushreg <bx,di,si,ds,es>
 36715                                  	;dataseg es		; Point ES into appropriate data segment
 36716                                  	;dataseg ds		; Point DS into appropriate data segment
 36717                                  
 36718                                  	;push	bx ; **
 36719                                  	
 36720                                  	;push	di
 36721                                  	;push	si
 36722                                  
 36723 00005F66 1E                      	push	ds ; *
 36724                                  
 36725                                  	;push	es
 36726                                  	;mov	es,[RESSEG]
 36727 00005F67 8E1E[159E]              	mov	ds,[RESSEG]
 36728                                  
 36729 00005F6B 803E[DC04]FF            	cmp	byte [UmbLoad],0FFh ; UNSPECIFIED
 36730                                  				; If this, we haven't been here before
 36731 00005F70 7503                    	jne	short su20
 36732 00005F72 A2[DC04]                	mov	[UmbLoad],al	; So remember this UMB as the load UMB slot.
 36733                                  su20:	
 36734 00005F75 08C0                    	or	al,al		; If they gave UMB 0, there's really nothing
 36735 00005F77 740F                    	jz	short su30	; that we should do here.
 36736                                  
 36737                                  	;mov	bl,al
 36738                                  	;xor	bh,bh
 36739                                  	;mov	ax,1		; Now, AX = 1, and BX = UMB Number
 36740 00005F79 30E4                    	xor	ah,ah
 36741 00005F7B 89C3                    	mov	bx,ax
 36742 00005F7D B001                    	mov	al,1
 36743                                  
 36744                                  	;xchg	[es:bx+UmbUsed],al
 36745 00005F7F 8687[0204]              	xchg	[bx+UmbUsed],al
 36746                                  
 36747 00005F83 08C0                    	or	al,al		; If it was already 1, then al==1... and that
 36748 00005F85 7401                    	jz	short su30	; means an error.
 36749                                  
 36750 00005F87 F9                      	stc			; OOOPS! This one's been used before. :(
 36751                                  su30:	
 36752                                  	;popreg	<es,ds,si,di,bx>
 36753                                  	;normseg ds
 36754                                  	;normseg es
 36755                                  	;retn
 36756                                  
 36757                                  	;pop	es
 36758                                  	
 36759 00005F88 1F                      	pop	ds ; *
 36760                                  	
 36761                                  	;pop	si
 36762                                  	;pop	di
 36763                                  	
 36764                                  	;pop	bx ; **
 36765                                  
 36766 00005F89 C3                      	retn
 36767                                  
 36768                                  ; -----------------------------------------------------------------------------
 36769                                  ;*** stowSiz - marks a given UMB as having a given minimum size
 36770                                  ; -----------------------------------------------------------------------------
 36771                                  ; ENTRY:    CL contains UMB number, AX contains size
 36772                                  ; EXIT:     None
 36773                                  ; ERROR:    None
 36774                                  ; USES:     AX, DX, Flags, variables in highvar.inc
 36775                                  ; -----------------------------------------------------------------------------
 36776                                  	
 36777                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36778                                  stowSiz:
 36779                                  	;pushreg <bx,di,es>
 36780                                  	;dataseg es		; Point ES into appropriate data seg
 36781                                  
 36782                                  	;push	bx ; **
 36783                                  	
 36784                                  	;push	di
 36785                                  	;push	es
 36786                                  	;mov	es,[RESSEG]
 36787 00005F8A 1E                      	push	ds ; *
 36788 00005F8B 8E1E[159E]              	mov	ds,[RESSEG]
 36789                                  
 36790 00005F8F 88CB                    	mov	bl,cl		; Now bl==UMB number, AX==size
 36791 00005F91 B700                    	mov	bh,0		;     bx==UMB number, AX==size
 36792 00005F93 D0E3                    	shl	bl,1		;     bx==offset into array, AX=size
 36793                                  	;mov	[es:bx+UmbSize],ax
 36794 00005F95 8987[1204]              	mov	[bx+UmbSize],ax	; Store the size
 36795                                  
 36796 00005F99 1F                      	pop	ds ; *
 36797                                  
 36798                                  	;popreg	<es,di,bx>
 36799                                  	;normseg es		; Return ES to where it was
 36800                                  
 36801                                  	;pop	es
 36802                                  	;pop	di
 36803                                  	
 36804                                  	;pop	bx ; **
 36805                                  
 36806 00005F9A C3                      	retn
 36807                                  
 36808                                  ; -----------------------------------------------------------------------------
 36809                                  ;*** toDigit - converts a character-digit to its binary counterpart
 36810                                  ;            -- verifies that CL contains a valid character-digit; if so, it
 36811                                  ; changes CL to its counterpart binary digit ((CL-'0') or (CL-'A'+10)).  A-F
 36812                                  ; are considered valid iff gnradix is 16.
 36813                                  ; -----------------------------------------------------------------------------
 36814                                  ; ENTRY:    CL contains a digit ('0' to '9' or, if gnradix==16, 'A' to 'F')
 36815                                  ; EXIT:     CL contains digit in binary (0 to 9 or, if gnradix==16, 0 to 15)
 36816                                  ; ERROR:    Carry set indicates invalid digit; carry clear indicates good digit
 36817                                  ; USES:     CL, Flags
 36818                                  ; -----------------------------------------------------------------------------
 36819                                  ; If the string is preceeded with "0x", the value is read as hexadecimal; else,
 36820                                  ; as decimal. After a read, you may check the radix by examining gnradix--it
 36821                                  ; will be 10 or 16.
 36822                                  ; -----------------------------------------------------------------------------
 36823                                  
 36824                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36825                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6358h
 36826                                  gnradix:
 36827 00005F9B 0000                    	dw	0		; Must be a word--16x16 multiplication
 36828                                  
 36829                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36830                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:635Ah
 36831                                  toDigit:
 36832                                  	;cmp	word [gnradix],16
 36833 00005F9D 803E[9B5F]10            	cmp	byte [gnradix],16
 36834 00005FA2 751C                    	jne	short td20	; Don't check hex digits if radix isn't 16
 36835                                  
 36836 00005FA4 80F961                  	cmp	cl,'a'
 36837 00005FA7 7209                    	jb	short td10
 36838 00005FA9 80F966                  	cmp	cl,'f'
 36839 00005FAC 7720                    	ja	short tdE	; Nothing valid above 'z' at all...
 36840 00005FAE 80E957                  	sub	cl,'a'-10 ; 57h	; Make 'a'==10 and return.
 36841                                  ;	clc			; <- CLC is implicit from last SUB
 36842 00005FB1 C3                      	retn
 36843                                  td10:
 36844 00005FB2 80F941                  	cmp	cl,'A'
 36845 00005FB5 7209                    	jb	short td20	; Below 'A'?  Not a letter...
 36846 00005FB7 80F946                  	cmp	cl,'F'
 36847 00005FBA 7712                    	ja	short tdE	; Above 'F'?  Not a digit.
 36848 00005FBC 80E937                  	sub	cl,'A'-10 ; 37h	; Make 'A'==10 and return.
 36849                                  ;	clc			; <- CLC is implicit from last SUB
 36850                                  tdErr:
 36851 00005FBF C3                      	retn
 36852                                  td20:
 36853 00005FC0 80F930                  	cmp	cl,'0'		; If less than zero,
 36854                                  	;jb	short tdE	; Done.
 36855 00005FC3 72FA                    	jb	short tdErr ; cf = 1
 36856 00005FC5 80F939                  	cmp	cl,'9'		; Or, if greater than nine,
 36857 00005FC8 7704                    	ja	short tdE	; Done.
 36858 00005FCA 80E930                  	sub	cl,'0'	  ; 30h	; Okay--make '0'==0 and return.
 36859                                  ;	clc			; <- CLC is implicit from last SUB
 36860 00005FCD C3                      	retn
 36861                                  tdE:
 36862 00005FCE F9                      	stc
 36863 00005FCF C3                      	retn
 36864                                  
 36865                                  ; -----------------------------------------------------------------------------
 36866                                  ;*** GetXNum - reads a 32-bit ASCII number at ES:SI and returns it in DX:AX
 36867                                  ; -----------------------------------------------------------------------------
 36868                                  ; ENTRY:    ES:SI points to an ascii string to scan
 36869                                  ; EXIT:     ES:SI moved to first invalid digit, DX:AX contains value read
 36870                                  ; ERROR:    Carry set if # is too big, or has no digits (EOL possibly)
 36871                                  ; USES:     ES:SI, DX, AX, Flags, gnradix
 36872                                  ; -----------------------------------------------------------------------------
 36873                                  ; If the string is preceeded with "0x", the value is read as hexadecimal; else,
 36874                                  ; as decimal. After a read, you may check the radix by examining gnradix--it
 36875                                  ; will be 10 or 16.
 36876                                  ; -----------------------------------------------------------------------------
 36877                                  
 36878                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36879                                  GetXNum:
 36880                                  	;pushreg <bx,cx,ds>
 36881                                  	
 36882                                  	;push	bx ; **
 36883 00005FD0 51                      	push	cx ; *
 36884                                  	
 36885                                  	;push	ds
 36886                                  
 36887 00005FD1 FC                      	cld
 36888 00005FD2 31C0                    	xor	ax,ax
 36889 00005FD4 31DB                    	xor	bx,bx
 36890 00005FD6 31C9                    	xor	cx,cx
 36891 00005FD8 31D2                    	xor	dx,dx		; Start with 0 (makes sense)
 36892                                  
 36893                                  	;mov	word [gnradix],10 ; And default to a radix of 10 (dec)
 36894 00005FDA C606[9B5F]0A            	mov	byte [gnradix],10
 36895                                  
 36896 00005FDF 268A0C                  	mov	cl,[es:si]	; Now AX=0, BX=0, CH=0/CL=char, DX=0
 36897 00005FE2 E8B8FF                  	call	toDigit
 36898 00005FE5 722D                    	jc	short gxnE	; If it's not a digit, leave now.
 36899                                  
 36900 00005FE7 08C9                    	or	cl,cl
 36901 00005FE9 7515                    	jnz	short gxn20	; Doesn't have '0x'
 36902 00005FEB 268A4C01                	mov	cl,[es:si+1]
 36903 00005FEF 80F978                  	cmp	cl,'x'		; Either 'x'...
 36904 00005FF2 7405                    	je	short gxn10
 36905 00005FF4 80F958                  	cmp	cl,'X'		; ...or 'X' means it's hexadecimal
 36906 00005FF7 7507                    	jne	short gxn20
 36907                                  
 36908                                  gxn10:
 36909                                  	;mov	word [gnradix],16
 36910 00005FF9 C606[9B5F]10            	mov	byte [gnradix],16
 36911 00005FFE 46                      	inc	si		; Since we read "0x", march over it.
 36912 00005FFF 46                      	inc	si
 36913                                  
 36914                                  ; ------------------------------------------------------
 36915                                  ; GXN20--ES:SI = a digit in a number; if not, we're done
 36916                                  ;        DX:AX = current total
 36917                                  ;        BX    = 0
 36918                                  ;        CH    = 0
 36919                                  ; ------------------------------------------------------
 36920                                  
 36921                                  gxn20:
 36922 00006000 268A0C                  	mov	cl,[es:si]	; Now DX:AX=current total, CH=0/CL=char
 36923 00006003 46                      	inc	si
 36924                                  
 36925 00006004 E896FF                  	call	toDigit		; Accepts only valid digits, A-F -> 10-16
 36926 00006007 720D                    	jc	short gxnQ	; <- Ah... wasn't a digit. Stop.
 36927                                  
 36928 00006009 E80E00                  	call	mul32		; Multiply DX:AX by gnradix
 36929 0000600C 7206                    	jc	short gxnX	; (if it's too big, error out)
 36930                                  
 36931 0000600E 01C8                    	add	ax,cx		; Add the digit
 36932 00006010 11DA                    	adc	dx,bx		; (BX is 0!)--Adds 1 if last add wrapped
 36933                                  	;jc	short gxnX	; If _that_ wrapped, it's too big.
 36934                                  	;jmp	short gxn20
 36935 00006012 73EC                    	jnc	short gxn20
 36936                                  gxnE:
 36937                                  	; cf = 1
 36938                                  	;stc			; In this case, we need to set the carry
 36939                                  	;jmp	short gxnX	; and leave--there were no digits given.
 36940                                  ;gxnQ:
 36941                                  	;dec	si		; Don't read in the offensive character.
 36942                                  	;clc			; And clear carry, so they know it's okay.
 36943                                  gxnX:
 36944                                  	;popreg	<ds,cx,bx>
 36945                                  
 36946                                  	;pop	ds
 36947                                  
 36948 00006014 59                      	pop	cx ; *
 36949                                  	;pop	bx ; **
 36950                                  
 36951 00006015 C3                      	retn
 36952                                  gxnQ:
 36953 00006016 4E                      	dec	si
 36954 00006017 F8                      	clc
 36955 00006018 EBFA                    	jmp	short gxnX
 36956                                  
 36957                                  ; -----------------------------------------------------------------------------
 36958                                  ;*** mul32 - multiplies the number in DX:AX by gnradix
 36959                                  ; -----------------------------------------------------------------------------
 36960                                  ; ENTRY:   DX:AX = the number to be multiplied, BX = 0, gnradix = multiplier
 36961                                  ; EXIT:    DX:AX has been multiplied by gnradix if carry clear; BX still 0
 36962                                  ; ERROR:   Carry set if number was too large
 36963                                  ; USES:    Flags, AX, DX
 36964                                  ; -----------------------------------------------------------------------------
 36965                                  
 36966                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 36967                                  mul32:
 36968 0000601A 50                      	push	ax		; DX=old:hi, AX=old:lo, TOS=old:lo, BX=0
 36969 0000601B 89D0                    	mov	ax,dx		; DX=old:hi, AX=old:hi, TOS=old:lo, BX=0
 36970 0000601D F726[9B5F]              	mul	word [gnradix]	; DX=?,      AX=new:hi, TOS=old:lo, BX=0
 36971 00006021 7210                    	jc	short m32E	; Too big?
 36972                                  
 36973 00006023 89C2                    	mov	dx,ax		; DX=new:hi, AX=new:hi, TOS=old:lo, BX=0
 36974 00006025 58                      	pop	ax		; DX=new:hi, AX=old:lo, TOS=orig,   BX=0
 36975                                  
 36976 00006026 87D3                    	xchg	dx,bx		; DX=0,      AX=old:lo, TOS=orig,   BX=new:hi
 36977 00006028 F726[9B5F]              	mul	word [gnradix]	; DX=carry,  AX=new:lo, TOS=orig,   BX=new:hi
 36978 0000602C 87D3                    	xchg	dx,bx		; DX=new:hi, AX=new:lo, TOS=orig,   BX=carry
 36979 0000602E 01DA                    	add	dx,bx		; DX=new:hi, AX=new:lo, TOS=orig,   BX=carry
 36980 00006030 31DB                    	xor	bx,bx		; DX=new:hi, AX=new:lo, TOS=orig,   BX=0
 36981 00006032 C3                      	retn
 36982                                  m32E:
 36983 00006033 58                      	pop	ax
 36984 00006034 C3                      	retn
 36985                                  
 36986                                  ; -----------------------------------------------------------------------------
 36987                                  ;*** toPara - divides DX:AX by 16; result in AX only (discards extra DX data)
 36988                                  ; -----------------------------------------------------------------------------
 36989                                  ; ENTRY:   DX:AX = the number to be divided
 36990                                  ; EXIT:    Interpereting DX:AX as bytes, AX=paragraph equivalent, 0xFFFF max
 36991                                  ; ERROR:   None
 36992                                  ; USES:    Flags, AX, DX
 36993                                  ; -----------------------------------------------------------------------------
 36994                                  ; Note: The 386 has a 32-bit SHR, which would work perfectly for this... but we
 36995                                  ;       can't ensure a 386 host machine. Sorry.
 36996                                  ; -----------------------------------------------------------------------------
 36997                                  
 36998                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 36999                                  toPara:
 37000 00006035 51                      	push	cx		; DX:AX=HHHH hhhh hhhh hhhh:LLLL llll llll llll
 37001                                  
 37002 00006036 B104                    	mov	cl,4		;
 37003 00006038 D3E8                    	shr	ax,cl		; DX:AX=HHHH hhhh hhhh hhhh:0000 LLLL llll llll
 37004 0000603A 92                      	xchg	ax,dx		; DX:AX=0000 LLLL llll llll:HHHH hhhh hhhh hhhh
 37005 0000603B B10C                    	mov	cl,12
 37006 0000603D D3E0                    	shl	ax,cl		; DX:AX=0000 LLLL llll llll:hhhh 0000 0000 0000
 37007 0000603F 09D0                    	or	ax,dx		;    AX=hhhh LLLL llll llll
 37008                                  
 37009 00006041 59                      	pop	cx
 37010 00006042 C3                      	retn
 37011                                  
 37012                                  ; -----------------------------------------------------------------------------
 37013                                  ;*** UmbHead - returns in AX the address of the first UMB block (0x9FFF)
 37014                                  ; -----------------------------------------------------------------------------
 37015                                  ; ENTRY:  Nothing
 37016                                  ; EXIT:   AX contains 0x9FFF for most systems
 37017                                  ; ERROR:  Carry set if pointer is 0xFFFF (if not set up yet--DH runs into this)
 37018                                  ; USES:   Flags, AX
 37019                                  ; -----------------------------------------------------------------------------
 37020                                  ; Early in the boot-cycle, the pointer used to obtain this value isn't set up;
 37021                                  ; to be precise, before a UMB provider is around.  In this event, the pointer
 37022                                  ; is always set to 0xFFFF; it changes once a provider is around.  On most
 37023                                  ; machines (all of 'em I've seen), it changes to 0x9FFF at that point.
 37024                                  ; -----------------------------------------------------------------------------
 37025                                  
 37026                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37027                                  UmbHead:
 37028                                  	;pushreg <si,ds,es>
 37029                                  	
 37030                                  	;push	si
 37031                                  	;push	ds
 37032                                  	;push	es
 37033                                  
 37034 00006043 B452                    	mov	ah,52h	; DOS_GET_DOS_LISTS
 37035                                  					; Call int 21h, function 52h...
 37036 00006045 CD21                    	int	21h
 37037                                  			; DOS - 2+ internal - GET LIST OF LISTS
 37038                                  			; Return: ES:BX -> DOS list of lists
 37039                                  
 37040                                  	;mov	ax,[es:DOS_UMB_HEAD]	; And read what's in ES:[008C]
 37041 00006047 26A18C00                	mov	ax,[es:8Ch]
 37042 0000604B 83F8FF                  	cmp	ax,0FFFFh
 37043                                  	;je	short uhE		; If it's 0xFFFF, it's an error...
 37044                                  
 37045                                  	;clc				; Else, it isn't (CLC done by prev cmp)
 37046                                  	;jmp	short uhX
 37047                                  	; 17/06/2023
 37048 0000604E F5                      	cmc	; cf = 0 <--> cf = 1
 37049                                  uhE:
 37050                                  	;stc
 37051                                  uhX:	
 37052                                  	;popreg	<es,ds,si>
 37053                                  	
 37054                                  	;pop	es
 37055                                  	;pop	ds
 37056                                  	;pop	si
 37057                                  
 37058 0000604F C3                      	retn
 37059                                  
 37060                                  ; -----------------------------------------------------------------------------
 37061                                  ;*** isSysMCB - sets ZF iff ES points to an MCB owned by "SC" + (8 or 9)
 37062                                  ; -----------------------------------------------------------------------------
 37063                                  ; ENTRY:  ES:0 should point to a valid MCB
 37064                                  ; EXIT:   ZF set if owned by SC+8 or SC+9 (for japan)
 37065                                  ; USES:   Flags
 37066                                  ; -----------------------------------------------------------------------------
 37067                                  
 37068                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37069                                  isSysMCB:
 37070                                  	;push	ax
 37071                                  	
 37072                                  	;mov	ax,[es:1]
 37073 00006050 26A10100                	mov	ax,[es:arena_owner]	; Check the owner...
 37074 00006054 83F808                  	cmp	ax,8 ; SystemPSPOwner	; 8 (for US OR Japan) is valid
 37075 00006057 7405                    	jz	short ism10
 37076 00006059 83F809                  	cmp	ax,9 ; JapanPSPOwner	; 9 (for Japan) is valid
 37077                                  	;jz	short ism10
 37078                                  	;jmp	short ismX		; Anything else isn't.
 37079 0000605C 7507                    	jnz	short ismX
 37080                                  ism10:
 37081                                  	;mov	ax,[es:8]
 37082 0000605E 26A10800                	mov	ax,[es:arena_name]	; Check the name...
 37083 00006062 3D5343                  	cmp	ax,'SC' ; cmp ax,4353h
 37084                                  ismX:
 37085                                  	;pop	ax
 37086 00006065 C3                      	retn
 37087                                  
 37088                                  ; -----------------------------------------------------------------------------
 37089                                  ;*** AddrToUmb - converts a segment address in AX to its appropriate UMB number
 37090                                  ; -----------------------------------------------------------------------------
 37091                                  ; ENTRY:  AX contains a segment address
 37092                                  ; EXIT:   AX will contain the UMB number which contains the address (0==conv)
 37093                                  ; ERROR:  If the address is above UM Range, AX will return as FFFF.
 37094                                  ; USES:   Flags, AX
 37095                                  ; -----------------------------------------------------------------------------
 37096                                  ; An address in the following areas is treated as:
 37097                                  ;    0      <-> umbhead (0x9FFF)          = Conventional memory
 37098                                  ;    0x9FFF <-> addr of first UM sys MCB  = UMB #1
 37099                                  ;      ...
 37100                                  ;    addr of last UM sys MCB <-> TOM      = invalid; returns #0xFFFF
 37101                                  ; -----------------------------------------------------------------------------
 37102                                  
 37103                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37104                                  AddrToUmb:
 37105                                  	;pushreg <cx,dx,es>
 37106                                  	
 37107                                  	;push	cx
 37108                                  	;push	dx
 37109 00006066 06                      	push	es
 37110                                  
 37111 00006067 89C2                    	mov	dx,ax		; DX = address to search for
 37112                                  
 37113 00006069 E8D7FF                  	call	UmbHead		; AX = first segment
 37114 0000606C 722B                    	jc	short atuE	; If it couldn't get it, error out.
 37115                                  
 37116                                  	;mov	es,ax ; *	; ES = first UMB segment
 37117 0000606E 31C9                    	xor	cx,cx		; Pretend we're on UMB 0 for now... (cx = UMB#)
 37118                                  
 37119                                  ; ----------------------------------------
 37120                                  ; ATU10--ES - Current MCB address
 37121                                  ;        DX - Address given for conversion
 37122                                  ;        CX - Current UMB #
 37123                                  ; ----------------------------------------
 37124                                  
 37125                                  	; 17/06/2023
 37126                                  atu10:
 37127 00006070 8EC0                    	mov	es,ax ; *
 37128                                  ;atu10:
 37129                                  	;mov	ax,es
 37130 00006072 39D0                            cmp	ax,dx		; Present segment >= given segment?
 37131 00006074 7326                    	jae	short atuX	; Yep--done.
 37132                                  
 37133 00006076 E8D7FF                  	call	isSysMCB	; Returns with ZF set if this is a system MCB
 37134 00006079 7501                    	jnz	short atu20
 37135                                  
 37136 0000607B 41                      	inc	cx		; If it _was_ a system MCB, we're in a new UMB.
 37137                                  atu20:
 37138                                  	;mov	al,[es:0]
 37139 0000607C 26A00000                	mov	al,[es:arena_signature]
 37140                                  	;cmp	al,'Z' ; 5Ah
 37141 00006080 3C5A                    	cmp	al,arena_signature_end
 37142 00006082 740A                    	je	short atu30	; 'Z' means this was the last MCB... that's it.
 37143                                  
 37144                                  	;NextMCB es,ax
 37145 00006084 8CC0                    	mov	ax,es
 37146                                  	;add	ax,[es:3]	; NextMCB (macro)
 37147 00006086 2603060300              	add	ax,[es:arena_size]
 37148 0000608B 40                      	inc	ax
 37149                                  	;mov	es,ax ; * ; 17/06/2023
 37150 0000608C EBE2                    	jmp	short atu10
 37151                                  
 37152                                  ; -----------------------------------------------------------------------------
 37153                                  ; if we get to atu30, they specified a number that was past the last MCB.
 37154                                  ; make sure it's not _inside_ that MCB before we return an error condition.
 37155                                  ; -----------------------------------------------------------------------------
 37156                                  
 37157                                  atu30:
 37158 0000608E 8CC0                    	mov	ax,es
 37159                                  	;add	ax,[es:3]
 37160 00006090 2603060300              	add	ax,[es:arena_size]
 37161 00006095 39D0                    	cmp	ax,dx		; Present >= given?
 37162 00006097 7303                    	jae	short atuX	; Yep! It _was_ inside.
 37163                                  atuE:
 37164 00006099 31C9                    	xor	cx,cx		; Else, fall through with UMB # == -1
 37165 0000609B 49                      	dec	cx		; (that makes it return 0xFFFF and sets CF)
 37166                                  atuX:	
 37167 0000609C 89C8                    	mov	ax,cx		; Return the UMB number in AX
 37168                                  	
 37169                                  	;popreg	<es,dx,cx>
 37170                                  
 37171 0000609E 07                      	pop	es
 37172                                  	;pop	dx
 37173                                  	;pop	cx
 37174                                  	
 37175 0000609F C3                      	retn
 37176                                  
 37177                                  ; -----------------------------------------------------------------------------
 37178                                  ;*** convUMB - checks after GetXNum to convert an address to a UMB number
 37179                                  ;            -- if GetXNum read a hex number, we interperete that as a segment
 37180                                  ; address rather than a UMB number... and use that address to look up a UMB.
 37181                                  ; This routine checks for that condition and calls AddrToUmb if necessary.
 37182                                  ; -----------------------------------------------------------------------------
 37183                                  ; ENTRY:  AX contains a UMB number or segment, gnradix has been set by GetXNum
 37184                                  ; EXIT:   AX will contain a UMB number
 37185                                  ; ERROR:  None
 37186                                  ; USES:   Flags, AX
 37187                                  ; -----------------------------------------------------------------------------
 37188                                  
 37189                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37190                                  convUMB:
 37191                                  	;cmp	word [gnradix],16
 37192 000060A0 803E[9B5F]10            	cmp	byte [gnradix],16
 37193 000060A5 7509                    	jne	short cu10	; If it didn't read in hex, it's not an address
 37194 000060A7 E8BCFF                  	call	AddrToUmb	; Else, convert the address to a UMB number
 37195 000060AA 83F8FF                  	cmp	ax,0FFFFh
 37196 000060AD 7501                    	jne	short cu10
 37197 000060AF 40                      	inc	ax ; ax = 0	; If too high, ignore it (make it conventional)
 37198                                  cu10:
 37199 000060B0 C3                      	retn
 37200                                  
 37201                                  ; -----------------------------------------------------------------------------
 37202                                  ;*** setUMBs - links umbs and sets allocation strategy for a load
 37203                                  ;            -- if LoadHigh, the allocation strategy MAY be LOW_FIRST instead
 37204                                  ; of the usual HIGH_FIRST.  See the code.
 37205                                  ; -----------------------------------------------------------------------------
 37206                                  ; ENTRY:  None
 37207                                  ; EXIT:   None
 37208                                  ; ERROR:  None
 37209                                  ; USES:   Flags, fm_umb, fm_strat
 37210                                  ; -----------------------------------------------------------------------------
 37211                                  
 37212                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37213                                  setUMBs:
 37214                                  	;pushreg <ax,bx>
 37215                                  	
 37216                                  	;push	ax
 37217                                  	;push	bx
 37218                                  
 37219 000060B1 E8B2FD                  	call	fm_link
 37220                                  
 37221 000060B4 B80058                  	mov	ax,5800h ; DOS_CHECK_STRATEGY
 37222 000060B7 CD21                    	int	21h
 37223                                  
 37224                                  	;putdata fm_strat,al	; Store the current strategy for later restore
 37225                                  
 37226                                  	;push	es
 37227                                  	;mov	es,[RESSEG]
 37228                                  	;mov	[es:fm_strat],al ; store the current strategy
 37229                                  	;pop	es
 37230 000060B9 1E                      	push	ds ; *
 37231 000060BA 8E1E[159E]              	mov	ds,[RESSEG]
 37232 000060BE A2[DE04]                	mov	[fm_strat],al
 37233                                  	;pop	ds ; *
 37234                                  
 37235 000060C1 83E07F                  	and	ax,007Fh	; 0000.0000.0111.1111 == All that other stuff
 37236 000060C4 50                      	push	ax ; **		; Watch this carefully...
 37237                                  
 37238 000060C5 E80C00                  	call	loadLow		; returns al==0 if load low, al==1 if loadhigh
 37239 000060C8 D0C8                    	ror	al,1		; Shift that to al==0 or al==0x80
 37240                                  
 37241 000060CA 5B                      	pop	bx ; **		; ...pushed as AX above
 37242                                  	
 37243 000060CB 1F                      	pop	ds ; *
 37244                                  	
 37245 000060CC 08C3                    	or	bl,al		; Now we have 0000.0000.?111.1111 in BX;
 37246                                  
 37247 000060CE B80158                  	mov	ax,5801h ; DOS_SET_STRATEGY
 37248                                  				; with ? ==1 if load highfirst. Perfect!
 37249 000060D1 CD21                    	int	21h
 37250                                  
 37251                                  	;popreg	<bx,ax>
 37252                                  
 37253                                  	;pop	bx
 37254                                  	;pop	ax
 37255                                  
 37256 000060D3 C3                      	retn
 37257                                  
 37258                                  ; -----------------------------------------------------------------------------
 37259                                  ;*** loadLow - returns AL==0 if UMB0 == 0, else AL==1
 37260                                  ; -----------------------------------------------------------------------------
 37261                                  ; ENTRY:  None
 37262                                  ; EXIT:   AL==0 if mem strategy should be set to LOW_FIRST, else AL==1
 37263                                  ;         Carry set if UMB0 not specified (_NOT_ an error)
 37264                                  ; ERROR:  None
 37265                                  ; USES:   Flags, fm_strat, fm_umb
 37266                                  ; -----------------------------------------------------------------------------
 37267                                  ; We want to set the memory strategy to LOW_FIRST if the user specified a
 37268                                  ; load UMB, and it is 0.  That 0 can be either from the user having _specified_
 37269                                  ; zero (/L:0;...), or from having specified a too-big min size (/L:1,99999999)
 37270                                  ; such that the load UMB is too small, and shouldn't be used.
 37271                                  ; -----------------------------------------------------------------------------
 37272                                  
 37273                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37274                                  loadLow:
 37275                                  	;push	ds ; *	
 37276                                  	
 37277                                  	;dataseg ds		; Point DS into appropriate data segment
 37278                                  	;mov	ds,[RESSEG]
 37279                                  
 37280                                  	; * ; ds = [RESSEG] from 'setUMBs') ; 17/06/2023
 37281                                  
 37282 000060D4 A0[DC04]                	mov	al,[UmbLoad]
 37283 000060D7 3CFF                    	cmp	al,0FFh ; UNSPECIFIED
 37284 000060D9 7503                    	jne	short ll10
 37285                                  
 37286                                  	;mov	al,1		; Return with AL==1 && STC if no UMBs specified
 37287 000060DB F9                      	stc
 37288                                  	;jmp	short llX
 37289 000060DC EB04                    	jmp	short lly ; 17/06/2023
 37290                                  ll10:
 37291 000060DE 08C0                    	or	al,al		; AL=the load UMB: Is it == 0?
 37292 000060E0 7402                    	jz	short llX	; Yep... CF==0 (from OR) && AL=0, so just exit
 37293                                  	; cf= 0
 37294                                  
 37295                                  	;mov	al,1
 37296                                  	;clc	
 37297                                  lly:		; 17/06/2023
 37298 000060E2 B001                    	mov	al,1
 37299                                  llX:
 37300                                  	;pop	ds ; *		; Return DS to where it was
 37301                                  	
 37302                                  	;normseg ds		;
 37303                                  	
 37304 000060E4 C3                      	retn
 37305                                  
 37306                                  ; -----------------------------------------------------------------------------
 37307                                  ;*** HideUMBs - links UMBs and hides upper-memory as appropriate
 37308                                  ; -----------------------------------------------------------------------------
 37309                                  ; ENTRY:  None
 37310                                  ; EXIT:   None
 37311                                  ; ERROR:  None
 37312                                  ; USES:   Flags, fm_strat, fm_umb
 37313                                  ; -----------------------------------------------------------------------------
 37314                                  
 37315                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37316                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:64D0h
 37317                                  HideUMBs:
 37318                                  	;pushreg <ax,cx,ds,es>
 37319                                  	
 37320                                  	;push	ax
 37321                                  	;push	cx
 37322                                  	;push	ds
 37323                                  	;push	es
 37324                                  
 37325 000060E5 E8EF01                  	call	UmbTest		; See if we REALLY linked in anything...
 37326 000060E8 7236                    	jc	short husX	; ...if not, there's nothing for us to do.
 37327                                  
 37328 000060EA E82CFD                  	call	FixMem		; Concatenate adjacent free MCBs in upper mem
 37329 000060ED E8C1FF                  	call	setUMBs		; Link UMBs and set memory-allocation strategy
 37330                                  
 37331                                  	;putdata fInHigh,1	; Remember that we're now running high
 37332                                  	;push	es
 37333                                  	;mov	es,[RESSEG]
 37334                                  	;mov	byte [es:fInHigh], 1
 37335                                  	;			; remember that we're now running high
 37336                                  	;pop	es
 37337 000060F0 1E                      	push	ds
 37338 000060F1 8E1E[159E]              	mov	ds,[RESSEG]
 37339 000060F5 C606[D804]01            	mov	byte [fInHigh], 1
 37340 000060FA 1F                      	pop	ds
 37341                                  
 37342 000060FB E82300                  	call	GetLoadUMB	; See if they gave us a list to leave free
 37343 000060FE 3CFF                    	cmp	al,0FFh	; UNSPECIFIED
 37344                                  				; If they didn't,
 37345 00006100 741E                    	je	short husX	; then we shouldn't do this loop:
 37346                                  
 37347 00006102 31C9                    	xor	cx,cx
 37348                                  
 37349                                  ; -----------------------------------------------
 37350                                  ; HUS10-CX - UMB number (after inc, 1==first UMB)
 37351                                  ; -----------------------------------------------
 37352                                  
 37353                                  hus10:
 37354 00006104 41                      	inc	cx		; For each UMB:
 37355 00006105 83F910                  	cmp	cx,16 ; MAXUMB
 37356 00006108 730C                    	jae	short hus20
 37357                                  
 37358 0000610A 88C8                    	mov	al,cl		; (stopping as soon as we're outside of the
 37359                                  	; 17/06/2023
 37360                                  	;push	es
 37361 0000610C E8A900                  	call	findumb		; valid range of UMBs)
 37362                                  	;pop	es		; push/pop: trash what findumb finds.  :-)
 37363 0000610F 7205                    	jc	short hus20
 37364                                  
 37365 00006111 E87901                  	call	hideUMB?	; hide what we need to hide.
 37366                                  
 37367 00006114 EBEE                    	jmp	short hus10
 37368                                  hus20:
 37369 00006116 E80800                  	call	GetLoadUMB	; Now check if they offered /L:0
 37370 00006119 08C0                    	or	al,al		; --Is the load UMB 0? (-1==unspecified)
 37371 0000611B 7503                    	jnz	short husX	; If not, we're done.
 37372                                  
 37373 0000611D E8E701                  	call	hl_unlink	; If so, however, fix UMBs and strategy.
 37374                                  husX:
 37375                                  	;popreg	<es,ds,cx,ax>
 37376                                  	
 37377                                  	;pop	es
 37378                                  	;pop	ds
 37379                                  	;pop	cx
 37380                                  	;pop	ax
 37381                                  
 37382 00006120 C3                      	retn
 37383                                  
 37384                                  ; -----------------------------------------------------------------------------
 37385                                  ;*** GetLoadUMB - Returns the load UMB number in AL (-1 if not specified)
 37386                                  ; -----------------------------------------------------------------------------
 37387                                  ; ENTRY:  None
 37388                                  ; EXIT:   AL == load UMB
 37389                                  ; ERROR:  None
 37390                                  ; USES:   Flags, AX
 37391                                  ; -----------------------------------------------------------------------------
 37392                                  
 37393                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37394                                  GetLoadUMB:
 37395                                  	;getdata al,UmbLoad
 37396                                  
 37397 00006121 1E                      	push    ds
 37398 00006122 8E1E[159E]              	mov     ds,[RESSEG]   ; getdata (macro)
 37399 00006126 A0[DC04]                	mov     al,[UmbLoad]
 37400 00006129 1F                      	pop     ds
 37401                                  
 37402 0000612A C3                      	retn
 37403                                  
 37404                                  ; -----------------------------------------------------------------------------
 37405                                  ;*** GetSize - Returns the UMB in AL's minimum size (0 if not specified)
 37406                                  ; -----------------------------------------------------------------------------
 37407                                  ; ENTRY:  AL == a UMB number
 37408                                  ; EXIT:   AX == UMB minimum size, as specified by the user
 37409                                  ; ERROR:  None
 37410                                  ; USES:   Flags, AX
 37411                                  ; -----------------------------------------------------------------------------
 37412                                  
 37413                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37414                                  GetSize:
 37415                                  	;pushreg <bx,si,ds>
 37416                                  	;push	bx
 37417                                  	;push	si
 37418 0000612B 1E                      	push	ds
 37419                                  	
 37420                                  	;dataseg ds
 37421 0000612C 8E1E[159E]              	mov	ds,[RESSEG]
 37422                                  
 37423 00006130 30E4                    	xor	ah,ah			;    ax==UMB
 37424                                  	;mov	bx,offset UmbSize
 37425 00006132 BB[1204]                	mov	bx,UmbSize		;    bx==array
 37426 00006135 D0E0                    	shl	al,1	                ;    ax==offset
 37427                                  	;add	ax,bx			;    ax==element index
 37428                                  	;mov	si,ax			; ds:si==element index
 37429                                  	;lodsw				;    ax==size
 37430 00006137 01C3                    	add	bx,ax
 37431 00006139 8B07                    	mov	ax,[bx]
 37432                                  
 37433                                  	;popreg	<ds,si,bx>
 37434 0000613B 1F                      	pop	ds
 37435                                  	;pop	si
 37436                                  	;pop	bx
 37437                                  
 37438                                  	;normseg ds
 37439 0000613C C3                      	retn
 37440                                  
 37441                                  ; -----------------------------------------------------------------------------
 37442                                  ;*** hideUMB - marks as HIDDEN all FREE elements in UMB passed as AL
 37443                                  ; -----------------------------------------------------------------------------
 37444                                  ; ENTRY:    AL must indicate a valid UMB; 0==conv && is invalid.
 37445                                  ; EXIT:     None; free elements in UMB marked as hidden
 37446                                  ; ERROR:    None
 37447                                  ; USES:     Flags
 37448                                  ; -----------------------------------------------------------------------------
 37449                                  
 37450                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37451                                  hideUMB:
 37452                                  	;pushreg <ax,es>
 37453                                  	
 37454                                  	;push	ax
 37455                                  	;push	es
 37456                                  
 37457 0000613D E87800                  	call	findumb		; Returns with carry if err, else ES == MCB
 37458 00006140 7221                    	jc	short huX
 37459                                  
 37460                                  ; ------------------------------------------------
 37461                                  ; HU10--ES - MCB inside UMB; if it's a system MCB,
 37462                                  ;            we're not in the same UMB, so exit.
 37463                                  ; ------------------------------------------------
 37464                                  
 37465                                  hu10:
 37466 00006142 E80BFF                  	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
 37467 00006145 741C                    	jz	short huX	; If it is, we've finished the UMB.
 37468 00006147 E82800                  	call	isFreeMCB	; Returns with ZF set if owner is 0
 37469 0000614A 7503                    	jnz	short hu20
 37470                                  
 37471 0000614C E82A00                  	call	hideMCB
 37472                                  hu20:
 37473                                  	;mov	al,[es:0]
 37474 0000614F 26A00000                	mov	al,[es:arena_signature]
 37475                                  	;cmp	al,'Z'
 37476 00006153 3C5A                    	cmp	al,arena_signature_end
 37477 00006155 740C                    	je	short huX	; 'Z' means this was the last MCB... that's it.
 37478                                  
 37479                                  	;NextMCB es,ax		; Go on forward.
 37480                                  
 37481 00006157 8CC0                     	mov	ax,es		; NextMCB (macro)
 37482                                  	;add	ax,[es:3]
 37483 00006159 2603060300              	add	ax,[es:arena_size]
 37484 0000615E 40                      	inc	ax
 37485 0000615F 8EC0                    	mov	es,ax
 37486                                  
 37487 00006161 EBDF                    	jmp	short hu10
 37488                                  huX:
 37489                                  	;popreg	<es,ax>
 37490                                  	
 37491                                  	;pop	es
 37492                                  	;pop	ax
 37493                                  
 37494 00006163 C3                      	retn
 37495                                  
 37496                                  ; -----------------------------------------------------------------------------
 37497                                  ;*** isTiny - returns with ZF set if user didn't specify /S
 37498                                  ; -----------------------------------------------------------------------------
 37499                                  ; ENTRY:    None
 37500                                  ; EXIT:     ZF set if user DIDN'T specify /S
 37501                                  ; ERROR:    None
 37502                                  ; USES:     Flags
 37503                                  ; -----------------------------------------------------------------------------
 37504                                  
 37505                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37506                                  isTiny:
 37507 00006164 50                      	push	ax
 37508                                  
 37509                                  	;getdata al,fUmbTiny
 37510 00006165 1E                      	push    ds
 37511 00006166 8E1E[159E]              	mov     ds,[RESSEG]   ; getdata (macro)
 37512 0000616A A0[D904]                	mov     al,[fUmbTiny]
 37513 0000616D 1F                      	pop     ds
 37514                                  
 37515 0000616E 08C0                    	or	al,al
 37516 00006170 58                      	pop	ax
 37517 00006171 C3                      	retn
 37518                                  
 37519                                  ; -----------------------------------------------------------------------------
 37520                                  ;*** isFreeMCB - returns with ZF set if current MCB (ES:0) is FREE
 37521                                  ; -----------------------------------------------------------------------------
 37522                                  ; ENTRY:    ES:0 should point to an MCB
 37523                                  ; EXIT:     ZF set if MCB is free, else !ZF
 37524                                  ; ERROR:    None
 37525                                  ; USES:     Flags
 37526                                  ; -----------------------------------------------------------------------------
 37527                                  
 37528                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37529                                  isFreeMCB:
 37530                                  	;or	word [es:1],0
 37531 00006172 26830E010000            	or	word [es:arena_owner],0
 37532 00006178 C3                      	retn
 37533                                  
 37534                                  ; -----------------------------------------------------------------------------
 37535                                  ;*** hideMCB - marks as HIDDEN the MCB at ES:0
 37536                                  ; -----------------------------------------------------------------------------
 37537                                  ; ENTRY:    ES:0 should point to an MCB
 37538                                  ; EXIT:     None; MCB marked as HIDDEN
 37539                                  ; ERROR:    None
 37540                                  ; USES:     None
 37541                                  ; -----------------------------------------------------------------------------
 37542                                  
 37543                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37544                                  hideMCB:
 37545                                  	;mov	word [es:1],8
 37546 00006179 26C70601000800          	mov	word [es:arena_owner],8 ; SystemPSPOwner
 37547                                  	;mov	word [es:8],4948h     ; 'HIDDEN  ' 
 37548 00006180 26C70608004849          	mov	word [es:arena_name+0], 'HI' ; 4948h
 37549 00006187 26C7060A004444          	mov	word [es:arena_name+2], 'DD' ; 4444h
 37550 0000618E 26C7060C00454E          	mov	word [es:arena_name+4], 'EN' ; 4E45h
 37551                                  	;mov	word [es:14],2020h
 37552 00006195 26C7060E002020          	mov	word [es:arena_name+6], '  ' ; 2020h 
 37553 0000619C C3                      	retn
 37554                                  
 37555                                  ; -----------------------------------------------------------------------------
 37556                                  ;*** unHideMCB - marks as FREE the MCB at ES:0
 37557                                  ; -----------------------------------------------------------------------------
 37558                                  ; ENTRY:    ES:0 should point to an MCB
 37559                                  ; EXIT:     None; MCB marked as FREE
 37560                                  ; ERROR:    None
 37561                                  ; USES:     None
 37562                                  ; -----------------------------------------------------------------------------
 37563                                  
 37564                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37565                                  unHideMCB:
 37566                                  	;push	ax
 37567                                  	;mov	word [es:1],0
 37568 0000619D 26C70601000000          	mov	word [es:arena_owner],0 ; FreePSPOwner
 37569 000061A4 B82020                  	mov	ax, '  '  ; mov ax,2020h
 37570                                  	;mov	[es:8],ax
 37571 000061A7 26A30800                	mov	[es:arena_name+0],ax
 37572 000061AB 26A30A00                	mov	[es:arena_name+2],ax
 37573 000061AF 26A30C00                	mov	[es:arena_name+4],ax
 37574                                  	;mov	[es:14],ax
 37575 000061B3 26A30E00                	mov	[es:arena_name+6],ax
 37576                                  	;pop	ax
 37577 000061B7 C3                      	retn
 37578                                  
 37579                                  ; -----------------------------------------------------------------------------
 37580                                  ;*** findUMB - makes ES:0 point to the first MCB in UMB given as AL
 37581                                  ;            -- returns UmbHEAD pointer (0x9FFF) if passed AL==0
 37582                                  ; -----------------------------------------------------------------------------
 37583                                  ; ENTRY:    AL should be to a valid UMB number
 37584                                  ; EXIT:     ES:0 points to first MCB in UMB (_not_ the 8+SC MCB that heads it)
 37585                                  ; ERROR:    Carry set if couldn't reach UMB (too high)
 37586                                  ; USES:     Flags, ES
 37587                                  ; -----------------------------------------------------------------------------
 37588                                  
 37589                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37590                                  findumb:
 37591                                  	;pushreg <ax,cx,dx>
 37592                                  	
 37593                                  	;push	ax
 37594 000061B8 51                      	push	cx
 37595 000061B9 52                      	push	dx
 37596                                  
 37597 000061BA 30E4                    	xor	ah,ah		; Zap ah, so al==ax
 37598                                  
 37599 000061BC 89C2                    	mov	dx,ax		; Store the to-be-found UMB number in DX
 37600                                  
 37601 000061BE E882FE                  	call	UmbHead		; Returns first UMB segment in AX
 37602                                  
 37603 000061C1 8EC0                    	mov	es,ax
 37604 000061C3 31C9                    	xor	cx,cx		; Pretend we're on UMB 0 for now...
 37605                                  
 37606                                  ; ---------------------------------------------
 37607                                  ; FU10--CX - This UMB number; 0 == conventional
 37608                                  ;       DX - The UMB number they're looking for
 37609                                  ;       ES - The current MCB address
 37610                                  ; ---------------------------------------------
 37611                                  
 37612                                  fu10:	
 37613 000061C5 39D1                    	cmp	cx,dx		; If CX==DX, we've found the UMB we're
 37614 000061C7 741B                    	je	short fuX	; searching for--so exit.
 37615                                  
 37616 000061C9 E884FE                  	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
 37617 000061CC 7501                    	jnz	short fu20
 37618                                  
 37619 000061CE 41                      	inc	cx		; If it _was_ SYSTEM, we're in a new UMB.
 37620                                  fu20:
 37621                                  	;mov	al,[es:0]
 37622 000061CF 26A00000                	mov	al,[es:arena_signature]
 37623                                  	;cmp	al,'Z'
 37624 000061D3 3C5A                    	cmp	al,arena_signature_end
 37625 000061D5 740C                    	je	short fuE	; 'Z' means this was the last MCB... that's it.
 37626                                  
 37627                                  	;NextMCB es,ax		; Go on forward.
 37628                                  
 37629 000061D7 8CC0                     	mov	ax,es		; NextMCB (macro)
 37630                                  	;add	ax,[es:3]
 37631 000061D9 2603060300              	add	ax,[es:arena_size]
 37632 000061DE 40                      	inc	ax
 37633 000061DF 8EC0                    	mov	es,ax
 37634                                  
 37635 000061E1 EBE2                    	jmp	short fu10
 37636                                  fuE:
 37637 000061E3 F9                      	stc
 37638                                  fuX:
 37639                                  	;popreg	<dx,cx,ax>	; The address is already in ES.
 37640                                  	
 37641 000061E4 5A                      	pop	dx
 37642 000061E5 59                      	pop	cx
 37643                                  	
 37644                                  	;pop	ax
 37645 000061E6 C3                      	retn
 37646                                  
 37647                                  ; -----------------------------------------------------------------------------
 37648                                  ;*** BigFree - makes ES:0 point to the largest free MCB in UMB given as AL
 37649                                  ; -----------------------------------------------------------------------------
 37650                                  ; ENTRY:    AL should be to a valid UMB number
 37651                                  ; EXIT:     ES:0 points to largest free MCB in UMB, AX returns its size
 37652                                  ; ERROR:    Carry set if couldn't reach UMB (0 or too high)
 37653                                  ; USES:     Flags, ES
 37654                                  ; -----------------------------------------------------------------------------
 37655                                  
 37656                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37657                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6624h
 37658                                  BigFree:
 37659                                  	;pushreg <bx,cx>
 37660                                  	
 37661                                  	;push	bx
 37662 000061E7 51                      	push	cx
 37663                                  
 37664 000061E8 E8CDFF                  	call	findumb			; Returns with CF if err, else ES==MCB
 37665 000061EB 7239                    	jc	short bfX		; (would be "jc bfE"; it just does stc)
 37666                                  
 37667 000061ED 31DB                    	xor	bx,bx			; Segment address of largest free MCB
 37668 000061EF 31C9                    	xor	cx,cx			; Size of largest free MCB
 37669                                  
 37670                                  ; ---------------------------------------------
 37671                                  ; BF10--ES - Current MCB address
 37672                                  ;       BX - Address of largest free MCB so far
 37673                                  ;       CX - Size of largest free MCB so far
 37674                                  ; ---------------------------------------------
 37675                                  
 37676                                  bf10:
 37677 000061F1 E85CFE                  	call	isSysMCB		; If we've left the MCB, we're done.
 37678 000061F4 7427                    	jz	short bf30
 37679                                  
 37680 000061F6 E879FF                  	call	isFreeMCB		; Returns with ZF set if owner is 0
 37681 000061F9 750E                    	jnz	short bf20
 37682                                  
 37683                                  	;cmp	cx,[es:3]
 37684 000061FB 263B0E0300              	cmp	cx,[es:arena_size]	; Compare sizes...
 37685 00006200 7F07                    	jg	short bf20		; Unless we're bigger,
 37686                                  
 37687 00006202 8CC3                    	mov	bx,es			; Store this new element's address,
 37688                                  	;mov	cx,[es:3]
 37689 00006204 268B0E0300              	mov	cx,[es:arena_size]	; and its size.
 37690                                  bf20:
 37691                                  	;mov	al,[es:0]
 37692 00006209 26A00000                	mov	al,[es:arena_signature]
 37693                                  	;cmp	al,'Z'  ; 5Ah
 37694 0000620D 3C5A                    	cmp	al,arena_signature_end
 37695 0000620F 740C                    	je	short bf30		; 'Z' means this was the last MCB.
 37696                                  
 37697                                  	;NextMCB es,ax			; Go on forward.
 37698                                  
 37699 00006211 8CC0                    	mov	ax,es 
 37700                                  	;add	ax,[es:3]
 37701 00006213 2603060300              	add	ax,[es:arena_size]
 37702 00006218 40                      	inc	ax
 37703 00006219 8EC0                    	mov	es,ax
 37704                                  
 37705 0000621B EBD4                    	jmp	short bf10
 37706                                  bf30:
 37707 0000621D 8EC3                    	mov	es,bx			; Return the address
 37708 0000621F 89C8                    	mov	ax,cx			; Return the size
 37709 00006221 09DB                    	or	bx,bx
 37710 00006223 7501                    	jnz	short bfX		; (if size==0, there's nothing free)
 37711                                  bfE:
 37712 00006225 F9                      	stc
 37713                                  bfX:
 37714                                  	;popreg	<cx,bx>
 37715                                  
 37716 00006226 59                      	pop	cx
 37717                                  	;pop	bx
 37718                                  
 37719 00006227 C3                      	retn
 37720                                  
 37721                                  ; -----------------------------------------------------------------------------
 37722                                  ;*** isSpecified - sets ZF if UMB in AL wasn't specified in DH/LH line.
 37723                                  ; -----------------------------------------------------------------------------
 37724                                  ; ENTRY:    AL should be to a valid UMB number
 37725                                  ; EXIT:     ZF set if UMB wasn't specified, ZF clear if it was
 37726                                  ; ERROR:    None
 37727                                  ; USES:     Flags
 37728                                  ; -----------------------------------------------------------------------------
 37729                                  
 37730                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37731                                  isSpecified:
 37732                                  	;push	ax
 37733                                  
 37734 00006228 30FF                    	xor	bh,bh
 37735 0000622A 88C3                    	mov	bl,al
 37736                                  
 37737                                  	;getdata al,DS:UmbUsed[bx]
 37738                                  
 37739 0000622C 1E                      	push	ds
 37740 0000622D 8E1E[159E]              	mov	ds,[RESSEG]
 37741 00006231 8A87[0204]              	mov	al,[bx+UmbUsed]
 37742 00006235 1F                      	pop     ds
 37743                                  
 37744 00006236 08C0                    	or	al,al		; Sets ZF if al==0 (ie, if unspecified)
 37745                                  
 37746                                  	;pop	ax
 37747 00006238 C3                      	retn
 37748                                  
 37749                                  ; -----------------------------------------------------------------------------
 37750                                  ;*** shrinkMCB - breaks an MCB into two pieces, the lowest one's size==AX
 37751                                  ; -----------------------------------------------------------------------------
 37752                                  ; ENTRY:    AX == new size, ES:0 == current MCB
 37753                                  ; EXIT:     None; MCB broken if carry clear
 37754                                  ; ERROR:    Carry set if MCB isn't as large as AX+0x20 (not a useful split)
 37755                                  ; USES:     Flags
 37756                                  ; -----------------------------------------------------------------------------
 37757                                  ; If the size of the to-be-split MCB isn't at least 0x20 bytes greater than
 37758                                  ; the specified new size, the split is useless; if it's onnly 0x10 bytes, that
 37759                                  ; 0x10 will be used to make a header that mentions a 0-byte free space, and
 37760                                  ; that just sucks up 0x10 bytes for nothing. So we make 0x20 bytes the
 37761                                  ; minimum for performing a split.
 37762                                  ; -----------------------------------------------------------------------------
 37763                                  
 37764                                  ;MIN_SPLIT_SIZE	equ 20h
 37765                                  
 37766                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37767                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:667Ah
 37768                                  shrinkMCB:
 37769                                  	;pushreg <bx,cx,es>
 37770                                  
 37771                                  	;push	bx
 37772 00006239 51                      	push	cx ; *
 37773 0000623A 26                      	psuh	es ; **
 37774                                  
 37775 0000623B 89C3                    	mov	bx,ax			; Move things around... and
 37776 0000623D 8CC0                    	mov	ax,es			; save this one for later.
 37777                                  
 37778 0000623F 268B0E0300              	mov	cx,[es:arena_size]
 37779 00006244 83E920                  	sub	cx,32 ; sub cx,MIN_SPLIT_SIZE
 37780                                  	;cmp	bx,cx			; {New size} vs {Current Size-20h}
 37781                                  	;ja	short smE		; if wanted_size > cur-20h, abort.
 37782 00006247 39D9                    	cmp	cx,bx
 37783 00006249 723E                    	jb	short smE ; cf = 1 (***)
 37784                                  
 37785                                  	;mov	dl,[es:0]
 37786 0000624B 268A160000              	mov	dl,[es:arena_signature]
 37787                                  
 37788                                  	;;mov	cx,[es:3]
 37789                                  	;mov	cx,[es:arena_size] ; *!
 37790                                  
 37791 00006250 26891E0300              	mov	[es:arena_size],bx
 37792                                  	;mov	byte [es:0],'M' ; 4Dh
 37793 00006255 26C60600004D            	mov	byte [es:arena_signature],'M'
 37794                                  
 37795 0000625B 01D8                    	add	ax,bx
 37796 0000625D 40                      	inc	ax
 37797 0000625E 8EC0                    	mov	es,ax			; Move to new arena area
 37798                                  
 37799                                  	;mov	ax,cx ; !*
 37800 00006260 26A10300                	mov	ax,[es:arena_size] ; *!
 37801 00006264 29D8                    	sub	ax,bx
 37802 00006266 48                      	dec	ax			; And prepare the new size
 37803                                  
 37804                                  	;mov	[es:0],dl
 37805 00006267 2688160000              	mov	[es:arena_signature],dl
 37806                                  	;;mov	word [es:1],0
 37807                                  	;mov	word [es:arena_owner],0
 37808                                  	;mov	[es:3],ax
 37809 0000626C 26A30300                	mov	[es:arena_size],ax
 37810 00006270 B82020                  	mov	ax,'  ' ; mov ax,2020h
 37811                                  	;mov	[es:8],ax
 37812 00006273 26A30800                	mov	[es:arena_name+0],ax
 37813 00006277 26A30A00                	mov	[es:arena_name+2],ax
 37814 0000627B 26A30C00                	mov	[es:arena_name+4],ax
 37815                                  	;mov	[es:14],ax
 37816 0000627F 26A30E00                	mov	[es:arena_name+6],ax
 37817                                  
 37818                                  	;clc
 37819 00006283 31C0                    	xor	ax,ax
 37820 00006285 26A30100                	mov	[es:arena_owner],ax ; 0
 37821                                  	; cf = 0
 37822                                  	;jmp	short smX
 37823                                  smE:
 37824                                  	;stc	 ; cf = 1 (***)
 37825                                  smX:
 37826                                  	;popreg	<es,cx,bx>
 37827 00006289 07                      	pop	es ; **
 37828 0000628A 59                      	pop	cx ; *
 37829 0000628B 5B                      	pop	bx
 37830                                  
 37831 0000628C C3                      	retn
 37832                                  
 37833                                  ; -----------------------------------------------------------------------------
 37834                                  ;*** hideUMB? - hides as appropriate the UMB in CL
 37835                                  ; -----------------------------------------------------------------------------
 37836                                  ; ENTRY:    CL should be to a valid UMB number, and AX to its address (findUMB)
 37837                                  ; EXIT:     None; UMB is hidden as necessary
 37838                                  ; ERROR:    None
 37839                                  ; USES:     Flags, AX, CX
 37840                                  ; -----------------------------------------------------------------------------
 37841                                  ; PRIMARY LOGIC:
 37842                                  ;
 37843                                  ; If the UMB is specified in the DH/LH statement, then:
 37844                                  ;    If the largest free segment is too small (check specified size), then:
 37845                                  ;       Pretend it wasn't ever specified, and fall out of this IF.
 37846                                  ;    Else, if largest free segment is LARGER than specified size, then:
 37847                                  ;       If /S was given on the command-line, then:
 37848                                  ;          Break that element into two pieces
 37849                                  ;          Set a flag that we're shrinking
 37850                                  ;       Endif
 37851                                  ;    Endif
 37852                                  ; Endif
 37853                                  ; If the UMB is NOT specified (or was removed by the above):
 37854                                  ;    Hide all free elements in the UMB
 37855                                  ;    If the flag that we're shrinking was set, then:
 37856                                  ;       UN-hide the lower portion of the shrunken UMB
 37857                                  ;    ENDIF
 37858                                  ; ENDIF
 37859                                  ; -----------------------------------------------------------------------------
 37860                                  
 37861                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37862                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:66D7h
 37863                                  hideUMB?:
 37864                                  	;pushreg <bx,dx,es>
 37865                                  
 37866                                  	;push	bx
 37867                                  	;push	dx
 37868                                  	;push	es
 37869                                  
 37870 0000628D 88C8                    	mov	al,cl
 37871 0000628F E896FF                  	call	isSpecified	; Returns ZF set if al's umb was NOT specified
 37872                                  	;jz	short hu?20
 37873                                  	; 17/06/2023
 37874 00006292 7432                    	jz	short hu?25 ; *
 37875                                  
 37876 00006294 88C8                    	mov	al,cl		; Retrieve the size of the largest
 37877 00006296 E84EFF                  	call	BigFree		; free element in AX; put its address in ES
 37878                                  	;jc	short hu?20	; Oops. Errors mean skip this part.
 37879                                  	; 17/06/2023
 37880 00006299 723B                    	jc	short hu?X ; **
 37881                                  
 37882 0000629B 50                      	push	ax		; TOS==size of BigFree in UMB (popped as BX)
 37883 0000629C 88C8                    	mov	al,cl		; Retrieve the user's specified
 37884 0000629E E88AFE                  	call	GetSize		; minimum size for this umb (into AX)
 37885 000062A1 5B                      	pop	bx		; Now BX==BigFree, AX==Specified Size
 37886                                  
 37887 000062A2 09C0                    	or	ax,ax		; If they didn't specify one,
 37888                                  	;jz	short hu?20	; Skip over all this.
 37889                                  	; 17/06/2023
 37890 000062A4 7530                    	jnz	short hu?X ; **
 37891                                  
 37892 000062A6 39D8                    	cmp	ax,bx		; Ah... if (specified > max free)
 37893 000062A8 7607                    	jbe	short hu?10
 37894                                  
 37895 000062AA 88C8                    	mov	al,cl		;  Then mark that UMB as unused. Nya nya.
 37896 000062AC E898FC                  	call	unMarkUMB
 37897                                  	;jmp	short hu?20 ; ***
 37898                                  	; 17/06/2023
 37899                                  	; ('isSpecified' would return with ZF=1) ; ***
 37900 000062AF EB15                    	jmp	short hu?25
 37901                                  hu?10:
 37902 000062B1 E8B0FE                  	call	isTiny		; Returns ZF clear if user specified /S
 37903                                  	;jz	short hu?20
 37904                                  	; 17/06/2023
 37905                                  	; ('isSpecified' would return with ZF=0) ; **
 37906 000062B4 7420                    	jz	short hu?X
 37907                                  
 37908 000062B6 E880FF                  	call	shrinkMCB	; They specified /S, so shrink the MCB to AX
 37909                                  	;jc	short hu?20	; Ah... if didn't shrink after all, skip this:
 37910                                  	; 17/06/2023
 37911                                  	; ('isSpecified' would return with ZF=0) ; **
 37912 000062B9 721B                    	jc	short hu?X
 37913                                  
 37914 000062BB 8CC2                    	mov	dx,es
 37915 000062BD EB09                    	jmp	short hu?30	; Skip the spec check.. we wanna hide this one.
 37916                                  hu?20:
 37917                                  	;mov	al,cl
 37918 000062BF 89C8                    	mov	ax,cx
 37919 000062C1 E864FF                  	call	isSpecified	; If they specified this UMB, we're done...
 37920 000062C4 7510                    	jnz	short hu?X ; **	; so leave.
 37921                                  hu?25:	; 17/06/2023 ; *
 37922 000062C6 31D2                    	xor	dx,dx
 37923                                  hu?30:
 37924 000062C8 88C8                    	mov	al,cl
 37925                                  
 37926 000062CA E870FE                  	call	hideUMB		; Hides everything in UMB #al
 37927                                  
 37928 000062CD 09D2                    	or	dx,dx		; Did we shrink a UMB? If not, DX==0,
 37929 000062CF 7405                    	jz	short hu?X	; So we should leave.
 37930                                  
 37931 000062D1 8EC2                    	mov	es,dx		; Ah, but if it isn't, DX==the MCB's address;
 37932 000062D3 E8C7FE                  	call	unHideMCB	; Un-hides the lower portion of that MCB.
 37933                                  hu?X:
 37934                                  	;popreg	<es,dx,bx>
 37935                                  
 37936                                  	;pop	es
 37937                                  	;pop	dx
 37938                                  	;pop	bx
 37939                                  
 37940 000062D6 C3                      	retn
 37941                                  
 37942                                  ; -----------------------------------------------------------------------------
 37943                                  ;*** UmbTest - returns with carry set if UMBs are not available, else CF==false
 37944                                  ; -----------------------------------------------------------------------------
 37945                                  ; ENTRY:    None
 37946                                  ; EXIT:     Carry is clear if UMBs are available, or set if they are not
 37947                                  ; ERROR:    None
 37948                                  ; USES:     CF (AX,BX,DS,ES pushed 'cause they're used by others)
 37949                                  ; -----------------------------------------------------------------------------
 37950                                  
 37951                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37952                                  UmbTest:
 37953                                  	;pushreg <ax,bx,ds,es>
 37954                                  	
 37955                                  	;push	ax
 37956                                  	;push	bx
 37957                                  	;push	ds
 37958                                  	;push	es
 37959                                  
 37960 000062D7 E88CFB                  	call	fm_link		; Link in UMBs (if not already linked)
 37961 000062DA E80600                  	call	WalkMem		; Check to see if they're really linked
 37962 000062DD 9C                      	pushf			; And remember what we found out
 37963 000062DE E89CFB                  	call	fm_unlink	; Unlink UMBs (if WE have linked 'em)
 37964 000062E1 9D                      	popf			; And restore what we found out.
 37965                                  
 37966                                  	;popreg	<es,ds,bx,ax>
 37967                                  	
 37968                                  	;pop	es
 37969                                  	;pop	ds
 37970                                  	;pop	bx
 37971                                  	;pop	ax
 37972                                  	
 37973 000062E2 C3                      	retn
 37974                                  
 37975                                  ; -----------------------------------------------------------------------------
 37976                                  ;*** WalkMem - travels memory chain and returns carry clear iff UMBs are linked
 37977                                  ; -----------------------------------------------------------------------------
 37978                                  ; ENTRY:    None
 37979                                  ; EXIT:     Carry SET if MCB chain stops before 9FFF, CLEAR if stops >= 9FFF.
 37980                                  ; ERROR:    None
 37981                                  ; USES:     Flags
 37982                                  ; -----------------------------------------------------------------------------
 37983                                  
 37984                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37985                                  WalkMem:
 37986                                  	;pushreg <ax,bx,es>
 37987                                  	
 37988                                  	;push	ax
 37989                                  	;push	bx
 37990 000062E3 06                      	push	es
 37991                                  
 37992 000062E4 B452                    	mov	ah,52h ; DOS_GET_DOS_LISTS
 37993                                  				; Call int 21h, function 52h...
 37994 000062E6 CD21                    	int	21h
 37995                                  
 37996 000062E8 268B47FE                	mov	ax,[es:bx-2]
 37997                                  	;mov	es,ax ; *
 37998                                  
 37999                                  ; ------------------------------
 38000                                  ; UM10: ES = Current MCB pointer
 38001                                  ; ------------------------------
 38002                                  
 38003                                  um10:	
 38004 000062EC 8EC0                    	mov	es,ax ; *
 38005                                  
 38006                                  	;mov	al,[es:0]
 38007 000062EE 26A00000                	mov	al,[es:arena_signature]
 38008                                  	;cmp	al,'Z' ; 5Ah
 38009 000062F2 3C5A                    	cmp	al,arena_signature_end
 38010 000062F4 740A                    	je	short um20	; If signature == 'Z', hay no more.
 38011                                  
 38012                                  	;NextMCB es,bx		; Move to the next MCB
 38013                                  	
 38014                                  	;mov	bx,es
 38015                                  	;;add	bx,[es:3]
 38016                                  	;add	bx,[es:arena_size]
 38017                                  	;inc	bx
 38018                                  	;mov	es,bx
 38019 000062F6 8CC0                    	mov	ax,es
 38020 000062F8 2603060300              	add	ax,[es:arena_size]
 38021 000062FD 40                      	inc	ax
 38022                                  	;mov	es,ax ; *
 38023                                  
 38024 000062FE EBEC                    	jmp	short um10	; And restart the loop.
 38025                                  um20:
 38026 00006300 8CC0                    	mov	ax,es
 38027 00006302 3DFF9F                  	cmp	ax,9FFFh	; This sets CF if ax < 9FFF.
 38028                                  
 38029                                  	;popreg	<es,bx,ax>
 38030 00006305 07                      	pop	es
 38031                                  	;pop	bx
 38032                                  	;pop	ax
 38033                                  
 38034 00006306 C3                      	retn
 38035                                  
 38036                                  ; -----------------------------------------------------------------------------
 38037                                  ;*** hl_unlink - unlinks UMBs if fm_umb is set to 0; restores strategy too
 38038                                  ; -----------------------------------------------------------------------------
 38039                                  ; ENTRY:    fm_umb == 1 : leave linked, else unlink
 38040                                  ; EXIT:     None
 38041                                  ; ERROR:    None
 38042                                  ; USES:     AX, BX
 38043                                  ; -----------------------------------------------------------------------------
 38044                                  
 38045                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38046                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:681Ch
 38047                                  hl_unlink:
 38048 00006307 1E                      	push	ds ; *
 38049                                  
 38050 00006308 30FF                    	xor	bh,bh
 38051                                  	;getdata bl,fm_umb	; Restore original link-state
 38052                                  
 38053                                  	;push	ds
 38054 0000630A 8E1E[159E]              	mov	ds,[RESSEG]
 38055 0000630E 8A1E[DD04]              	mov	bl,[fm_umb]	; Restore original link-state
 38056                                  	;pop	ds
 38057                                  	
 38058 00006312 B80358                  	mov	ax,5803h ; DOS_SET_UMBLINK
 38059 00006315 CD21                    	int	21h
 38060                                  
 38061 00006317 30FF                    	xor	bh,bh
 38062                                  
 38063                                  	;getdata bl,fm_strat	; Restore original mem-alloc strategy
 38064                                  
 38065                                  	;push	ds
 38066                                  	;mov	ds,[RESSEG]
 38067 00006319 8A1E[DE04]              	mov	bl,[fm_strat]	;Restore original mem-alloc strategy
 38068                                  	;pop	ds
 38069                                  
 38070 0000631D B80158                  	mov	ax,5801h ; DOS_SET_STRATEGY
 38071 00006320 CD21                    	int	21h
 38072                                  
 38073 00006322 1F                      	pop	ds ; *
 38074                                  
 38075 00006323 C3                      	retn
 38076                                  
 38077                                  ;============================================================================
 38078                                  ; LOADHIGH.ASM, MSDOS 6.0, 1991
 38079                                  ;============================================================================
 38080                                  ; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38081                                  
 38082                                  ; This is a new module added to support loading programs into UMBs provided
 38083                                  ; by DOS 5.0. 
 38084                                  ; ---------------------------------------------------------------------------
 38085                                  ; Usage:
 38086                                  ;
 38087                                  ; LOADHIGH [/L:umb[,size][;umb[,size]]*] <filespec>
 38088                                  ;
 38089                                  ; <filespec> has to be a filename that is not wildcarded.
 38090                                  
 38091                                  ; ---------------------------------------------------------------------------
 38092                                  ;
 38093                                  ;	Revision History
 38094                                  ;	================
 38095                                  ;
 38096                                  ;	M009	SR	08/01/90	Set flags to indicate that we are
 38097                                  ;				loading and high and also remember
 38098                                  ;				current UMB state.
 38099                                  ;
 38100                                  ;	M016	SR	08/09/90	Give special error message on attempt
 38101                                  ;				to loadhigh batch files and invalid
 38102                                  ;				filename on Loadhigh command line.
 38103                                  ;
 38104                                  ;	M039	SR	11/19/90	Bug #4270. Copy all the whitespaces
 38105                                  ;				after the program name also as part
 38106                                  ;				of the command line being passed to
 38107                                  ;				the program to be invoked.
 38108                                  ;
 38109                                  ; ---------------------------------------------------------------------------
 38110                                  
 38111                                  ; ---------------------------------------------------------------------------
 38112                                  ;
 38113                                  ;	include highload.inc		; Grab code for ParseVar and such
 38114                                  
 38115                                  iCmdLine	equ	81h		; PSP:81h points to command-line
 38116                                  
 38117                                  ;
 38118                                  ; ---------------------------------------------------------------------------
 38119                                  
 38120                                  ;****	LoadHigh -- Main routine for Loadhigh command
 38121                                  ;
 38122                                  ;	ENTRY	Command line tail is at PSP:iCmdLine terminated by 0dh
 38123                                  ;		CS = DS = SS = TRANGROUP
 38124                                  ;
 38125                                  ;	EXIT	None
 38126                                  ;
 38127                                  ;	USED	ax, bx, cx, dx, si, di, es
 38128                                  ;
 38129                                  ;	ERROR EXITS
 38130                                  ;		Message pointers are setup at the error locations and then
 38131                                  ;	we jump back to CERROR which is the transient error recycle point.
 38132                                  ;	Apart from parse errors, the other errors handled are too many
 38133                                  ;	switches anf invalid filenames.
 38134                                  ;
 38135                                  ;	EFFECTS
 38136                                  ;		The allocation strategy and the state of the arena chain are
 38137                                  ;	put in the requested state according to the given options. If a 
 38138                                  ;	filename is also given, it is executed as well.
 38139                                  ; ---------------------------------------------------------------------------
 38140                                  
 38141                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38142                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5927h
 38143                                  
 38144                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 38145                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:683Fh
 38146                                  LoadHigh:
 38147 00006324 1E                      	push	ds
 38148 00006325 07                      	pop	es
 38149                                  	
 38150                                  	; 16/06/2023
 38151                                  	;call	SkipLhDelims	; MSDOS 5.0 !
 38152                                  
 38153                                  ;Get command tail to be passed to the program. This includes any whitespace
 38154                                  ;chars between the program name and its parameters as well.
 38155                                  ;On return, ds:si points at the start of the command tail.
 38156                                  
 38157                                  	; 16/06/2023
 38158                                  	;push	si		; MSDOS 5.0 !
 38159 00006326 E81300                  	call	ParseLhCmd
 38160                                  	;pop	si		; MSDOS 5.0 !	
 38161 00006329 720E                    	jc	short LhErr
 38162                                  	
 38163 0000632B E86500                  	call	SetupCmdLine		;setup pgm's command line
 38164                                  
 38165 0000632E E88700                  	call	SetupPath		;setup path for file
 38166 00006331 7206                    	jc	short LhErr		;file not found
 38167                                  
 38168                                  ;Set allocation strategy to HighFirst and link in UMBs for exec. This will
 38169                                  ;be reset after return from the Exec
 38170                                  ;We will also set a resident flag to indicate that UMBs were activated for
 38171                                  ;the Exec. On return from the Exec, this flag will be used to deactivate UMBs
 38172                                  
 38173 00006333 E8AFFD                  	call	HideUMBs		;prepare upper-memory for load
 38174                                  
 38175 00006336 E916CB                  	jmp	LH_EXECUTE		;go and exec file ;M051
 38176                                  
 38177                                  LhErr:
 38178                                  ;The error message has been setup at this stage
 38179                                  
 38180 00006339 E966CB                  	jmp	cerror			;print error message and recycle 
 38181                                  
 38182                                  ; ---------------------------------------------------------------------------
 38183                                  					
 38184                                  ;*** 	ParseLhCmd - parses any command-line options
 38185                                  ;
 38186                                  ;	ENTRY	None
 38187                                  ;
 38188                                  ;	EXIT	Carry clear -- command line parsed successfully
 38189                                  ;		Carry set -- appropriate error message setup
 38190                                  ;
 38191                                  ;	USED	ax, si
 38192                                  ;
 38193                                  ;	EFFECTS
 38194                                  ;		Options set up (see highvar.inc)
 38195                                  ;		Filename to be executed setup
 38196                                  ;
 38197                                  ;	ParseLhCmd calls InitVar to initialize data filled in by ParseVar,
 38198                                  ;	then calls ParseVar itself to actually parse the commmand-line.  On
 38199                                  ;	return from ParseVar, DS:SI will point to the beginning of the child
 38200                                  ;	module's name on the command-line; thus it calls LhCopyFilename to
 38201                                  ;	prepare the command-line for that program.
 38202                                  ; ---------------------------------------------------------------------------
 38203                                  
 38204                                  ; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 38205                                  %if 0
 38206                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38207                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5944h
 38208                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 38209                                  	; 11/06/2023
 38210                                  ParseLhCmd:
 38211                                  	;mov	si,81h
 38212                                  	mov	si,iCmdLine	;ds:si points at command line
 38213                                  
 38214                                  	mov	word [COMSW],0
 38215                                  	mov	di,Parse_LoadHi
 38216                                  	xor	cx,cx
 38217                                  	call	Parse_With_Msg
 38218                                  
 38219                                  	; 11/06/2023
 38220                                  	;cmp	ax,0FFFFh ; -1
 38221                                  	;jz	short PLhCmd2
 38222                                  	;cmp	ax,0
 38223                                  	;jnz	short PLhCmd1
 38224                                  	; 11/06/2023
 38225                                  	inc	ax ; cmp ax,-1
 38226                                  	jz	short PLhCmd2 ; 0FFFFh -> 0
 38227                                  	dec	ax ; cmp ax,0
 38228                                  	jnz	short PLhCmd1 ; 1 -> 0
 38229                                  	; ax = 0
 38230                                  
 38231                                  	mov	bx,dx
 38232                                  	; 14/04/2023
 38233                                  	;call	LhCopyFilename
 38234                                  	;; 13/04/2023
 38235                                  	;;;jc	short PLhCmd2  ; !!! jmp short PLhCmd2 !!!
 38236                                  	;;jmp	short PLhCmd2
 38237                                  	;retn
 38238                                  	; 14/04/2023
 38239                                  	jmp	short LhCopyFilename
 38240                                  PLhCmd1:
 38241                                  	stc
 38242                                  PLhCmd2:
 38243                                  	retn
 38244                                  %endif
 38245                                  
 38246                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 38247                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6857h
 38248                                  	; MSDOS 6.0
 38249                                  ParseLhCmd:
 38250                                  	;assume	ds:TRANGROUP, es:TRANGROUP
 38251                                  	
 38252                                  	;mov	si,81h
 38253 0000633C BE8100                  	mov	si,iCmdLine	;ds:si points at command line
 38254                                  
 38255                                  	; es = ds (from 'LoadHigh') 
 38256                                  	;push	es		;Store ES 'cause we're gonna change it:
 38257                                  
 38258                                  	;push	ds
 38259                                  	;pop	es		;Make sure es:si points to cmd line as well
 38260                                  
 38261 0000633F E8ACFA                  	call	InitVar		;Initialize data for ParseVar
 38262                                  
 38263 00006342 E84AFB                  	call	ParseVar	;And parse the command line
 38264                                  
 38265                                  	;pop	es		;Restore ES now; we're done with it.
 38266                                  
 38267 00006345 7317                    	jnc	short plcC	;If no error, continue on our way.
 38268                                  
 38269 00006347 83F802                  	cmp	ax,2 ; PV_BadUMB
 38270                                  				;Bad UMB passed?
 38271 0000634A 7505                    	jne	short plc10
 38272                                  	;mov	dx,offset TRANGROUP:LhBadUMB_Ptr
 38273 0000634C BA[7594]                	mov	dx,LhBadUMB_Ptr
 38274 0000634F F9                      	stc
 38275 00006350 C3                      	retn
 38276                                  plc10:	
 38277                                  	;mov	dx,offset TRANGROUP:LhInvSwt_Ptr
 38278 00006351 BA[7294]                	mov	dx,LhInvSwt_Ptr
 38279 00006354 83F803                  	cmp	ax,3 ; PV_InvSwt
 38280                                  				;Unrecognized switch passed?
 38281 00006357 7403                    	je	short plc20
 38282                                  	;mov	dx,offset TRANGROUP:LhInvArg_Ptr
 38283 00006359 BA[6C94]                	mov	dx,LhInvArg_Ptr
 38284                                  plc20:
 38285 0000635C F9                      	stc
 38286 0000635D C3                      	retn
 38287                                  plcC:
 38288                                  	;call	LhCopyFilename	;copy filename into our buffer
 38289                                  	;retn			;Return-- carry=status
 38290                                  	; 16/06/2023
 38291                                  	;jmp	short LhCopyFilename
 38292                                  
 38293                                  ; ---------------------------------------------------------------------------
 38294                                  
 38295                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38296                                  
 38297                                  ; ---------------------------------------------------------------------------
 38298                                  ; HIGHlOAD.INC, MSDOS 6.0, 1992
 38299                                  ; ---------------------------------------------------------------------------
 38300                                  
 38301                                  	; 13/04/2023
 38302                                  	; MSDOS 5.0 COMMAND.COM only !
 38303                                  	; (Procedure names are not from original Microsoft source code!)
 38304                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 38305                                  ;set_strategy:
 38306                                  	;mov	ax,5800h	; DOS_CHECK_STRATEGY
 38307                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38308                                  	;		; AL = function code: get allocation strategy
 38309                                  	;mov	bx,ax
 38310                                  	;or	bx,80h
 38311                                  	;mov	ax,5801h	; DOS_SET_STRATEGY
 38312                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38313                                  	;		; AL = function code: set allocation strategy
 38314                                  	;retn
 38315                                  
 38316                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 38317                                  ;set_umblink:
 38318                                  	;mov	ax,5803h	; DOS_SET_UMBLINK
 38319                                  	;mov	bx,1
 38320                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38321                                  	;		; AL = function code: (DOS 5beta) set UMB link state
 38322                                  	;retn
 38323                                  
 38324                                  ; ---------------------------------------------------------------------------
 38325                                  
 38326                                  ;***	LhCopyFilename -- copy filename from command line to buffer
 38327                                  ;
 38328                                  ;	ENTRY	ds:si points at primary argument (filename)
 38329                                  ;
 38330                                  ;	EXIT	Carry set -- filename has wildcards. In this event, DX will
 38331                                  ;				already contain an appropriate error number.
 38332                                  ;		Carry clear -- filename has been copied as needed; DS:SI
 38333                                  ;				points to first character (most likely space)
 38334                                  ;				after filename.
 38335                                  ;
 38336                                  ;	USED	ax, si
 38337                                  ;
 38338                                  ;	EFFECTS
 38339                                  ;		ExecPath contains the filename
 38340                                  ;
 38341                                  ; If there are any wildcards in the filename, then we have an error
 38342                                  ; ---------------------------------------------------------------------------
 38343                                  
 38344                                  ; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 38345                                  %if 0
 38346                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38347                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5984h
 38348                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 38349                                  LhCopyFilename:
 38350                                  	push	ds
 38351                                  	push	si
 38352                                  	push	di
 38353                                  	lds	si,[bx+4]
 38354                                  	mov	di,EXECPATH
 38355                                  lhcpfn1:
 38356                                  	lodsb
 38357                                  	cmp	al,2Ah ; '*'
 38358                                  	jz	short lhfilerr
 38359                                  	cmp	al,3Fh ; '?'
 38360                                  	jz	short lhfilerr
 38361                                  	stosb
 38362                                  	or	al,al
 38363                                  	jnz	short lhcpfn1
 38364                                  	; 14/04/2023
 38365                                  	; cf = 0
 38366                                  	;clc
 38367                                  lhfilerr2:
 38368                                  	pop	di
 38369                                  	pop	si
 38370                                  	pop	ds
 38371                                  	retn
 38372                                  lhfilerr:
 38373                                  	mov	dx,LhInvFil_Ptr
 38374                                  	stc
 38375                                  	jmp	short lhfilerr2
 38376                                  
 38377                                  %endif
 38378                                  
 38379                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 38380                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6881h
 38381                                  	; MSDOS 6.0
 38382                                  LhCopyFilename:
 38383                                  	;assume	ds:TRANGROUP, es:TRANGROUP
 38384                                  
 38385                                  	;mov	di,offset TRANGROUP:ExecPath
 38386 0000635E BF[3D9D]                	mov	di,EXECPATH
 38387                                  
 38388                                  	;mov	cx,0	; Copied zero characters
 38389 00006361 29C9                    	sub	cx,cx
 38390                                  ;@@:
 38391                                  lhcpfn1:
 38392 00006363 AC                      	lodsb
 38393 00006364 3C2A                    	cmp	al,'*'			;wildcard?
 38394 00006366 7421                    	je	short lhfilerr		;yes, error
 38395 00006368 3C3F                    	cmp	al,'?'			;wildcard?
 38396 0000636A 741D                    	je	short lhfilerr		;yes, error
 38397                                  
 38398 0000636C 3C0D                    	cmp	al,0Dh			;carriage return?
 38399                                  	;jz	@f
 38400 0000636E 7410                    	je	short lhcpfn2
 38401 00006370 3C2F                    	cmp	al,'/' ; SwitChar	;'/'?
 38402                                  	;jz	@f
 38403 00006372 740C                    	je	short lhcpfn2
 38404 00006374 08C0                    	or	al,al			;EOS?
 38405                                  	;jz	@f
 38406 00006376 7408                    	jz	short lhcpfn2
 38407 00006378 3C20                    	cmp	al,' '			;Space?
 38408                                  	;jz	@f
 38409 0000637A 7404                    	je	short lhcpfn2
 38410                                  	
 38411                                  	;or	al,al
 38412                                  	;;jz	@f
 38413                                  	;je	short lhcpfn2	
 38414                                  
 38415 0000637C AA                      	stosb				;store char
 38416 0000637D 41                      	inc	cx			;And remember that we did one more
 38417                                  	;jmp	short @b
 38418 0000637E EBE3                    	jmp	short lhcpfn1
 38419                                  ;@@:
 38420                                  lhcpfn2:
 38421 00006380 30C0                    	xor	al,al			;Indicate EOS reached
 38422 00006382 AA                      	stosb				;store char
 38423                                  
 38424 00006383 09C9                    	or	cx,cx			;If we didn't copy any characters,
 38425 00006385 7407                    	jz	short lhmissing	; they didn't give a filename.
 38426                                  
 38427 00006387 4E                      	dec	si			;Move back to the delimiting character
 38428                                  	; cf = 0
 38429                                  	;clc				;And indicate no error occurred
 38430 00006388 C3                      	retn
 38431                                  lhfilerr:
 38432                                  	;mov	dx,offset TRANGROUP:LhInvFil_Ptr
 38433 00006389 BA[6694]                	mov	dx,LhInvFil_Ptr		;"Invalid Filename" ; M016
 38434 0000638C F9                      	stc
 38435 0000638D C3                      	retn
 38436                                  lhmissing:
 38437                                  	;mov	dx,offset TRANGROUP:ReqParmMiss
 38438 0000638E BA[6F94]                	mov	dx,ReqParmMiss		;"Required parm missing"
 38439 00006391 F9                      	stc
 38440 00006392 C3                      	retn
 38441                                  
 38442                                  ; ---------------------------------------------------------------------------
 38443                                  	
 38444                                  ; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM 
 38445                                  %if 0
 38446                                  	; 14/04/2023
 38447                                  	; 13/04/2023
 38448                                  	; MSDOS 5.0 COMMAND.COM only !
 38449                                  	; (Procedure name is not from original Microsoft source code!)
 38450                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 38451                                  set_strategy:
 38452                                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 38453                                  	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38454                                  			; AL = function code: get allocation strategy
 38455                                  	mov	bx,ax
 38456                                  	or	bx,80h
 38457                                  	mov	ax,5801h	; DOS_SET_STRATEGY
 38458                                  	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38459                                  			; AL = function code: set allocation strategy
 38460                                  	retn
 38461                                  
 38462                                  ; ---------------------------------------------------------------------------
 38463                                  
 38464                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38465                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59A6h
 38466                                  	; MSDOS 5.0 COMMAND.COM only !
 38467                                  	; (Procedure name is not from original Microsoft source code!)
 38468                                  SkipLhDelims:
 38469                                  	mov	si,81h
 38470                                  	call	scanoff
 38471                                  stfn1:
 38472                                  	lodsb
 38473                                  	call	DELIM
 38474                                  	jz	short stfn2
 38475                                  	cmp	al,0Dh
 38476                                  	jz	short stfn2
 38477                                  	cmp	al,[SWITCHAR]
 38478                                  	jnz	short stfn1
 38479                                  stfn2:
 38480                                  	dec	si
 38481                                  	retn
 38482                                  
 38483                                  %endif
 38484                                  
 38485                                  ; ---------------------------------------------------------------------------
 38486                                  
 38487                                  ;***	SetupCmdLine -- prepare command line for the program
 38488                                  ;
 38489                                  ;	ENTRY	{es/ds}:si = points just after the end of the child program
 38490                                  ;
 38491                                  ;	EXIT	None
 38492                                  ;
 38493                                  ;	USED
 38494                                  ;
 38495                                  ;	EFFECTS		
 38496                                  ;		The rest of the command line following the pgm name is 
 38497                                  ;	moved to the top of the command line buffer (at TRANGROUP:81h)
 38498                                  ;	and a new command line length is put in
 38499                                  ; ---------------------------------------------------------------------------
 38500                                  
 38501                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38502                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59BEh
 38503                                  
 38504                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38505                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:68BEh
 38506                                  SetupCmdLine:
 38507                                  	;mov	di,81h
 38508 00006393 BF8100                  	mov	di,iCmdLine
 38509 00006396 30C9                    	xor	cl,cl
 38510 00006398 FEC9                    	dec	cl			;just CR means count = 0
 38511                                  SetCmdL1:
 38512 0000639A AC                      	lodsb
 38513 0000639B AA                      	stosb
 38514 0000639C FEC1                    	inc	cl			;update count
 38515                                  	
 38516                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38517                                  	; MSDOS 6.0
 38518                                  	; 14/04/2023
 38519                                  	; * ; MSDOS 6.0 only !
 38520 0000639E 08C0                    	or	al,al	; *
 38521 000063A0 7404                    	jz	short SetCmdL2 ; *
 38522                                  	
 38523 000063A2 3C0D                    	cmp	al,0Dh			;carriage return?
 38524 000063A4 75F4                    	jnz	short SetCmdL1		;no, continue storing
 38525                                  SetCmdL2:
 38526 000063A6 26880E8000              	mov	[es:80h],cl		;store new cmd line length
 38527 000063AB C3                      	retn
 38528                                  
 38529                                  ; ---------------------------------------------------------------------------
 38530                                  
 38531                                  ;***	LhSetupErrMsg -- Sets up error messages
 38532                                  ;
 38533                                  ;	ENTRY	ax = error message number
 38534                                  ;
 38535                                  ;	EXIT	None
 38536                                  ;
 38537                                  ;	USED	dx
 38538                                  ;
 38539                                  ;	EFFECTS
 38540                                  ;		Everything setup to display error message
 38541                                  ; ---------------------------------------------------------------------------
 38542                                  	
 38543                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38544                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38545                                  LhSetupErrMsg:
 38546 000063AC C606[F191]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 38547 000063B1 BA[F391]                	mov	dx,extend_buf_ptr
 38548 000063B4 A3[F391]                	mov	[extend_buf_ptr],ax
 38549 000063B7 C3                      	retn
 38550                                  
 38551                                  ; ---------------------------------------------------------------------------
 38552                                  
 38553                                  ; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM 
 38554                                  %if 0
 38555                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38556                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59DFh
 38557                                  	; MSDOS 5.0 COMMAND.COM only !
 38558                                  	; (Procedure name is not from original Microsoft source code!)
 38559                                  check_umblink:
 38560                                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 38561                                  	int	21h 	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38562                                  			 ; AL = function code: get allocation strategy
 38563                                  	mov	bl,al
 38564                                  	mov	ax,5802h	; DOS_CHECK_UMBLINK
 38565                                  	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38566                                  			; AL = function code: (DOS 5beta) get UMB link state
 38567                                  	mov	bh,al
 38568                                  	xchg	ax,bx
 38569                                  	rol	al,1
 38570                                  	and	al,1
 38571                                  	shl	ah,1
 38572                                  	or	al,ah
 38573                                  	retn
 38574                                  
 38575                                  ; ---------------------------------------------------------------------------
 38576                                  
 38577                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38578                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59F7h
 38579                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 38580                                  HideUMBs:
 38581                                  	push	ds
 38582                                  	call	check_umblink
 38583                                  	mov	ds,[RESSEG]
 38584                                  	mov	[fInHigh],al
 38585                                  	or	byte [fInHigh],80h
 38586                                  	pop	ds
 38587                                  	call	set_strategy
 38588                                  	;call	set_umblink
 38589                                  	;retn
 38590                                  	; 14/04/023
 38591                                  	;jmp	short set_umblink
 38592                                  
 38593                                  ; ---------------------------------------------------------------------------
 38594                                  
 38595                                  	; 14/04/2023
 38596                                  	; 13/04/2023
 38597                                  	; MSDOS 5.0 COMMAND.COM only !
 38598                                  	; (Procedure name is not from original Microsoft source code!)
 38599                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 38600                                  set_umblink:
 38601                                  	mov	ax,5803h	; DOS_SET_UMBLINK
 38602                                  	mov	bx,1
 38603                                  	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38604                                  			; AL = function code: (DOS 5beta) set UMB link state
 38605                                  	retn
 38606                                  %endif
 38607                                  
 38608                                  ; ---------------------------------------------------------------------------
 38609                                  
 38610                                  ;***	SetupPath -- Do path search for the file to be executed
 38611                                  ;
 38612                                  ;	ENTRY	None
 38613                                  ;
 38614                                  ;	EXIT	Carry set if file not found or not executable file
 38615                                  ;
 38616                                  ;	EFFECTS
 38617                                  ;		ExecPath contains the full path of the file to be executed
 38618                                  ; ---------------------------------------------------------------------------
 38619                                  
 38620                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38621                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A0Fh
 38622                                  
 38623                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38624                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:68E3h
 38625                                  SetupPath:
 38626                                  
 38627                                  ;Juggle around the argv pointers to make argv[1] into argv[0]. This is 
 38628                                  ;because the path search routine that we are about to invoke expects the
 38629                                  ;filename to search for to be argv[0].
 38630                                  ;
 38631                                  ;If our new argv[0] starts with a switcharacter, it's an option... skip right
 38632                                  ;over it by doing the whole move again (smaller, of course, this time).
 38633                                  
 38634                                  
 38635                                  	;mov	ax,arg.argvcnt		;total number of arguments
 38636                                  	; 14/04/2023
 38637                                  	;mov	ax,[ARG_ARGVCNT]
 38638 000063B8 A1[27A5]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 38639                                  
 38640 000063BB 48                      	dec	ax			;less one - skip "LoadHigh"
 38641                                  	;mov	bx,SIZE Argv_ele
 38642 000063BC BB0B00                  	mov	bx,ARGV_ELE.SIZE ; 11
 38643                                  	;mov	bx,11
 38644 000063BF F7E3                    	mul	bx			;dx:ax = size of argument lists
 38645                                  
 38646                                  	; 17/06/2023 - Retro DOS 4.2 COMMAND.COM
 38647                                  	; --------------------------------------
 38648                                  	; MSDOS 6.0
 38649                                  
 38650                                  	;getdata cl,fm_argc		;CL = number of arguments to skip
 38651 000063C1 1E                      	push	ds              ; getdata (macro)
 38652 000063C2 8E1E[159E]              	mov	ds,[RESSEG]
 38653 000063C6 8A0E[DF04]              	mov	cl,[fm_argc]
 38654 000063CA 1F                      	pop	ds
 38655                                  	
 38656 000063CB FEC1                    	inc	cl			;Skip one arg, to get over "lh"
 38657                                  
 38658                                  ;Move argv[1]..argv[n] to argv[0]..argv[n-1]. Here, AX == the overall size
 38659                                  ;of the argument lists.
 38660                                  
 38661                                  argloop:
 38662 000063CD E31B                    	jcxz	argdone			;If we've finished copying args, leave.
 38663                                  
 38664 000063CF 49                      	dec	cx			;One less time we'll go through this.
 38665                                  
 38666 000063D0 50                      	push	ax			;Copy ( size of remaining list ) bytes
 38667 000063D1 51                      	push	cx			;And remember how many args there were
 38668                                  
 38669                                  	; --------------------------------------
 38670                                  
 38671                                  	; 14/04/2023
 38672 000063D2 89C1                    	mov	cx,ax			;size to move
 38673                                  
 38674                                  	;mov	di,offset TRANGROUP:Arg	;Copy TO argv[0]
 38675                                  	;mov	di,ARG_ARGV ;mov di,[ARG+ARG_UNIT.argv] ; mov di,[ARG]
 38676 000063D4 BF[67A2]                	mov	di,ARG	
 38677 000063D7 89FE                    	mov	si,di			;
 38678                                  	;add	si,SIZE Argv_ele	;Copy FROM argv[1]
 38679 000063D9 83C60B                  	add	si,ARGV_ELE.SIZE ; 11
 38680                                  	
 38681                                  	; 14/04/2023
 38682                                  	;mov	cx,ax
 38683                                  
 38684 000063DC FC                      	cld
 38685 000063DD F3A4                    	rep	movsb			;Move the argument list
 38686                                  	
 38687                                  	;dec	arg.argvcnt		;Fake one less argument, and
 38688                                  	;dec	word [ARG_ARGVCNT]
 38689 000063DF FF0E[27A5]              	dec	word [ARG+ARG_UNIT.argvcnt]
 38690                                  
 38691                                  	; 17/06/2023 - Retro DOS 4.2 COMMAND.COM
 38692                                  	; --------------------------------------
 38693                                  	; MSDOS 6.0
 38694                                  	
 38695                                  	;sub	ax,ARGV_ELE.SIZE ; 11	;there's one argument we don't copy.
 38696                                  
 38697 000063E3 59                      	pop	cx
 38698 000063E4 58                      	pop	ax			;Restore the size of the arg list
 38699                                  	; 17/06/2023
 38700                                  	;jmp	short argloop
 38701                                  	
 38702                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38703 000063E5 83E80B                  	sub	ax,ARGV_ELE.SIZE ; 11
 38704 000063E8 77E3                    	ja	short argloop
 38705                                  	; --------------------------------------
 38706                                  	
 38707                                  ; Done moving... argv[0] is now the child program's name, and [1] its first arg
 38708                                  
 38709                                  	; 17/06/2023
 38710                                  argdone:
 38711 000063EA E8C3D2                  	call	path_search		;look in the path
 38712                                  
 38713                                  ;ax = 0, no file found
 38714                                  ;ax < 4, batch file found -- cant be executed
 38715                                  ;ax = 4,8 => .com or .exe file found
 38716                                  
 38717 000063ED 09C0                    	or	ax,ax			;any file found?
 38718 000063EF 740B                    	jz	short no_exec_file	;no, error
 38719                                  
 38720 000063F1 83F804                  	cmp	ax,4			;executable file?
 38721                                  	;jl	short no_exec_bat	;no, indicate fail ; M016
 38722                                  	;clc
 38723                                  	;retn
 38724                                  	; 14/04/2023
 38725 000063F4 7201                    	jb	short no_exec_bat
 38726 000063F6 C3                      	retn 
 38727                                  
 38728                                  no_exec_bat:
 38729 000063F7 BA[6394]                	mov	dx,NoExecBat_Ptr	;Setup message ptr ; M016
 38730 000063FA EB06                    	jmp	short lhsp_errret	;return error; M016
 38731                                  
 38732                                  no_exec_file:
 38733 000063FC B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 38734 000063FF E8AAFF                  	call	LhSetupErrMsg		;setup error message
 38735                                  lhsp_errret:				; M016
 38736 00006402 F9                      	stc
 38737 00006403 C3                      	retn
 38738                                  
 38739                                  ;============================================================================
 38740                                  ; COMMAND.SKL (MESSAGE.SKL), BUILDMSG.C, MSDOS 6.0, 1991
 38741                                  ;============================================================================
 38742                                  ; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38743                                  
 38744                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A44h
 38745                                  
 38746                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38747                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6930h
 38748                                  
 38749                                  ; ---------------------------------------------------------------------------
 38750                                  ; Class 3 message table/structure
 38751                                  ; ---------------------------------------------------------------------------
 38752                                  
 38753                                  $M_CLASS_3_STRUC:
 38754 00006404 FF                      	db 0FFh			; $M_CLASS_ID (Class identifer)
 38755                                  	;dw 5			; $M_COMMAND_VER (COMMAND.COM version)
 38756                                  	;db 162			; Total number of messages
 38757                                  	; 17/06/2023
 38758 00006405 0616                    	dw 1606h		; MSDOS 6.22 COMMAND.COM (hb=22,lb=6)	
 38759 00006407 BB                      	db 187			; Total number of messages
 38760                                  $M_ID_3_1:
 38761                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:5A48h)
 38762 00006408 FC03                    	dw 1020			; Message Number = 1020
 38763                                  	;dw MSG_1020-$+2 ; 288h	; Message offset from message number (5A48h+0288h=5CD0h)
 38764                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38765 0000640A EC02                    	dw MSG_1020-$+2 ; 2ECh	; Message offset from message number (6934h+02ECh=6C20h)
 38766                                  $M_ID_3_2:
 38767 0000640C F703                    	dw 1015			; Message Number = 1015
 38768                                  	;dw MSG_1015-$+2 ; 294h ; Message offset from message number (5A4Ch+0294h=5CE0h)
 38769                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38770 0000640E F802                    	dw MSG_1015-$+2 ; 2F8h	; Message offset from message number (6938h+02F8h=6C30h)
 38771                                  $M_ID_3_3:	; 26/04/2023
 38772                                  			; 17/06/2023
 38773 00006410 EC031803                	dw 1004,MSG_1004-$ ; 792
 38774 00006414 02042E03                	dw 1026,MSG_1026-$ ; 814
 38775 00006418 07043E03                	dw 1031,MSG_1031-$ ; 830
 38776 0000641C 0B044903                	dw 1035,MSG_1035-$ ; 841
 38777 00006420 26045403                	dw 1062,MSG_1062-$ ; 852
 38778 00006424 04045F03                	dw 1028,MSG_1028-$ ; 863
 38779 00006428 15047D03                	dw 1045,MSG_1045-$ ; 893
 38780 0000642C 11049603                	dw 1041,MSG_1041-$ ; 918
 38781 00006430 1204B403                	dw 1042,MSG_1042-$ ; 948
 38782                                  $M_ID_3_12:
 38783 00006434 1304CB03                	dw 1043,MSG_1043-$ ; 971
 38784 00006438 EA03E703                	dw 1002,MSG_1002-$ ; 999
 38785 0000643C EB030B04                	dw 1003,MSG_1003-$ ; 1035
 38786 00006440 EF032304                	dw 1007,MSG_1007-$ ; 1059
 38787 00006444 F0033A04                	dw 1008,MSG_1008-$ ; 1082
 38788 00006448 F1034C04                	dw 1009,MSG_1009-$ ; 1100
 38789 0000644C F2035D04                	dw 1010,MSG_1010-$ ; 1117
 38790 00006450 F3037904                	dw 1011,MSG_1011-$ ; 1145
 38791 00006454 F6039004                	dw 1014,MSG_1014-$ ; 1168
 38792 00006458 F8039D04                	dw 1016,MSG_1016-$ ; 1181
 38793 0000645C F903C304                	dw 1017,MSG_1017-$ ; 1219
 38794 00006460 FA03E404                	dw 1018,MSG_1018-$ ; 1252
 38795                                  $M_ID_3_24:
 38796 00006464 FB03F404                	dw 1019,MSG_1019-$ ; 1268
 38797 00006468 FD03FC04                	dw 1021,MSG_1021-$ ; 1276
 38798 0000646C FE031605                	dw 1022,MSG_1022-$ ; 1302
 38799 00006470 FF033905                	dw 1023,MSG_1023-$ ; 1337
 38800 00006474 00046105                	dw 1024,MSG_1024-$ ; 1377
 38801 00006478 01047405                	dw 1025,MSG_1025-$ ; 1396
 38802 0000647C 03048805                	dw 1027,MSG_1027-$ ; 1416
 38803 00006480 0504A505                	dw 1029,MSG_1029-$ ; 1445
 38804 00006484 0604B305                	dw 1030,MSG_1030-$ ; 1459
 38805 00006488 0804BE05                	dw 1032,MSG_1032-$ ; 1470
 38806 0000648C 0904D205                	dw 1033,MSG_1033-$ ; 1490
 38807 00006490 0A04E405                	dw 1034,MSG_1034-$ ; 1508
 38808 00006494 0C04F605                	dw 1036,MSG_1036-$ ; 1526
 38809 00006498 0D040706                	dw 1037,MSG_1037-$ ; 1543
 38810 0000649C 0E041406                	dw 1038,MSG_1038-$ ; 1556
 38811 000064A0 0F042306                	dw 1039,MSG_1039-$ ; 1571
 38812                                  $M_ID_3_40:
 38813 000064A4 10045C06                	dw 1040,MSG_1040-$ ; 1628
 38814 000064A8 14046D06                	dw 1044,MSG_1044-$ ; 1645
 38815 000064AC 16047D06                	dw 1046,MSG_1046-$ ; 1661
 38816 000064B0 1704B006                	dw 1047,MSG_1047-$ ; 1712
 38817 000064B4 1804C506                	dw 1048,MSG_1048-$ ; 1733
 38818 000064B8 1904D306                	dw 1049,MSG_1049-$ ; 1747
 38819 000064BC 1A04D906                	dw 1050,MSG_1050-$ ; 1753
 38820 000064C0 1B04F406                	dw 1051,MSG_1051-$ ; 1780
 38821 000064C4 1C040107                	dw 1052,MSG_1052-$ ; 1793
 38822 000064C8 1D041407                	dw 1053,MSG_1053-$ ; 1812
 38823 000064CC 1E043607                	dw 1054,MSG_1054-$ ; 1846
 38824                                  $M_ID_3_51:
 38825 000064D0 1F045907                	dw 1055,MSG_1055-$ ; 1881
 38826 000064D4 20046307                	dw 1056,MSG_1056-$ ; 1891
 38827 000064D8 21046E07                	dw 1057,MSG_1057-$ ; 1902
 38828 000064DC 23047707                	dw 1059,MSG_1059-$ ; 1911
 38829 000064E0 24047807                	dw 1060,MSG_1060-$ ; 1912
 38830 000064E4 25047807                	dw 1061,MSG_1061-$ ; 1912
 38831 000064E8 27048E07                	dw 1063,MSG_1063-$ ; 1934
 38832 000064EC 28048D07                	dw 1064,MSG_1064-$ ; 1933
 38833 000064F0 29048C07                	dw 1065,MSG_1065-$ ; 1932
 38834 000064F4 2A048B07                	dw 1066,MSG_1066-$ ; 1931
 38835 000064F8 2B048A07                	dw 1067,MSG_1067-$ ; 1930
 38836 000064FC 2C048807                	dw 1068,MSG_1068-$ ; 1928
 38837 00006500 2D048F07                	dw 1069,MSG_1069-$ ; 1935
 38838 00006504 2E048F07                	dw 1070,MSG_1070-$ ; 1935
 38839 00006508 2F048E07                	dw 1071,MSG_1071-$ ; 1934
 38840 0000650C 30048D07                	dw 1072,MSG_1072-$ ; 1933
 38841                                  $M_ID_3_67:
 38842 00006510 31049307                	dw 1073,MSG_1073-$ ; 1939
 38843 00006514 32049907                	dw 1074,MSG_1074-$ ; 1945
 38844 00006518 33049F07                	dw 1075,MSG_1075-$ ; 1951
 38845 0000651C 3404A107                	dw 1076,MSG_1076-$ ; 1953
 38846 00006520 3504A007                	dw 1077,MSG_1077-$ ; 1952
 38847 00006524 3604A407                	dw 1078,MSG_1078-$ ; 1956
 38848 00006528 3704BB07                	dw 1079,MSG_1079-$ ; 1979
 38849 0000652C 3804C207                	dw 1080,MSG_1080-$ ; 1986
 38850 00006530 3904D407                	dw 1081,MSG_1081-$ ; 2004
 38851                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38852 00006534 3A04FB07                	dw 1082,MSG_1082-$ ; 2043	
 38853 00006538 3B04FF07                	dw 1083,MSG_1083-$ ; 2047	
 38854                                  	;
 38855 0000653C 3C04FE07                	dw 1084,MSG_1084-$ ; 2046
 38856 00006540 42040A08                	dw 1090,MSG_1090-$ ; 2058
 38857 00006544 43041408                	dw 1091,MSG_1091-$ ; 2068
 38858 00006548 44041E08                	dw 1092,MSG_1092-$ ; 2078
 38859 0000654C 45042808                	dw 1093,MSG_1093-$ ; 2088
 38860 00006550 46043908                	dw 1094,MSG_1094-$ ; 2105
 38861 00006554 47045208                	dw 1095,MSG_1095-$ ; 2130
 38862 00006558 48046B08                	dw 1096,MSG_1096-$ ; 2155
 38863                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38864 0000655C 49049808                	dw 1097,MSG_1097-$ ; 2200
 38865 00006560 4A04B108                	dw 1098,MSG_1098-$ ; 2225
 38866 00006564 4B04CA08                	dw 1099,MSG_1099-$ ; 2250
 38867 00006568 4C04DC08                	dw 1100,MSG_1100-$ ; 2268
 38868 0000656C 4D04FE08                	dw 1101,MSG_1101-$ ; 2302
 38869 00006570 4E040909                	dw 1102,MSG_1102-$ ; 2313
 38870 00006574 4F043F09                	dw 1103,MSG_1103-$ ; 2367
 38871 00006578 50045609                	dw 1104,MSG_1104-$ ; 2390
 38872 0000657C 51045609                	dw 1105,MSG_1105-$ ; 2390 ; TRANGROUP:6AA8h 
 38873                                  ;$M_ID_3_84:
 38874                                  $M_ID_3_95: ; 17/06/2023	
 38875 00006580 B0045709                	dw 1200,MSG_1200-$ ; 2391
 38876 00006584 14055409                	dw 1300,MSG_1300-$ ; 2388
 38877 00006588 2805D709                	dw 1320,MSG_1320-$ ; 2519
 38878 0000658C 2905130A                	dw 1321,MSG_1321-$ ; 2579
 38879 00006590 3C05800A                	dw 1340,MSG_1340-$ ; 2688
 38880 00006594 3D05D80A                	dw 1341,MSG_1341-$ ; 2776
 38881 00006598 3E05370B                	dw 1342,MSG_1342-$ ; 2871
 38882 0000659C 5005C50B                	dw 1360,MSG_1360-$ ; 3013
 38883 000065A0 7805DD0B                	dw 1400,MSG_1400-$ ; 3037
 38884 000065A4 7905760C                	dw 1401,MSG_1401-$ ; 3190
 38885 000065A8 7A05DB0C                	dw 1402,MSG_1402-$ ; 3291
 38886 000065AC 7B054E0D                	dw 1403,MSG_1403-$ ; 3406
 38887 000065B0 7C058A0D                	dw 1404,MSG_1404-$ ; 3466 ; TRANGROUP:6ADCh 
 38888                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38889 000065B4 7D05FB0D                	dw 1405,MSG_1405-$ ; 3579 ; TRANGROUP:6AE0h 
 38890 000065B8 7E056A0E                	dw 1406,MSG_1406-$ ; 3690
 38891 000065BC 7F05A90E                	dw 1407,MSG_1407-$ ; 3753 ; (MSG_1404 for MSDOS 5.0 COMMAND.COM)
 38892                                  	;
 38893 000065C0 8C052D0F                	dw 1420,MSG_1420-$ ; 3885
 38894 000065C4 A005B40F                	dw 1440,MSG_1440-$ ; 4020
 38895 000065C8 A1050E10                	dw 1441,MSG_1441-$ ; 4110
 38896                                  ;$M_ID_3_100:
 38897                                  $M_ID_3_114: ; 17/06/2023
 38898 000065CC B4058E10                	dw 1460,MSG_1460-$ ; 4238
 38899 000065D0 B505EF10                	dw 1461,MSG_1461-$ ; 4335
 38900 000065D4 B6056F11                	dw 1462,MSG_1462-$ ; 4463
 38901 000065D8 C805BB11                	dw 1480,MSG_1480-$ ; 4539
 38902 000065DC C9054112                	dw 1481,MSG_1481-$ ; 4673
 38903 000065E0 CA055C12                	dw 1482,MSG_1482-$ ; 4700
 38904 000065E4 CB05A912                	dw 1483,MSG_1483-$ ; 4777
 38905 000065E8 CC05FF12                	dw 1484,MSG_1484-$ ; 4863
 38906 000065EC CD057A13                	dw 1485,MSG_1485-$ ; 4986
 38907 000065F0 CE05F213                	dw 1486,MSG_1486-$ ; 5106
 38908 000065F4 CF058414                	dw 1487,MSG_1487-$ ; 5252
 38909 000065F8 D005C714                	dw 1488,MSG_1488-$ ; 5319
 38910                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38911 000065FC D1054315                	dw 1489,MSG_1489-$ ; 5443
 38912 00006600 D2058115                	dw 1490,MSG_1490-$ ; 5505
 38913 00006604 D3059915                	dw 1491,MSG_1491-$ ; 5529
 38914 00006608 D405E815                	dw 1492,MSG_1492-$ ; 5608
 38915 0000660C D5057716                	dw 1493,MSG_1493-$ ; 5751
 38916 00006610 D6058A16                	dw 1494,MSG_1494-$ ; 5770
 38917                                  ;$M_ID_3_112:
 38918                                  $M_ID_3_132: ; 17/06/2023
 38919 00006614 DC05A416                	dw 1500,MSG_1500-$ ; 5796
 38920 00006618 F005DF16                	dw 1520,MSG_1520-$ ; 5855
 38921 0000661C 04061917                	dw 1540,MSG_1540-$ ; 5913
 38922 00006620 05067317                	dw 1541,MSG_1541-$ ; 6003
 38923 00006624 0606DB17                	dw 1542,MSG_1542-$ ; 6107
 38924 00006628 18061318                	dw 1560,MSG_1560-$ ; 6163
 38925 0000662C 19064718                	dw 1561,MSG_1561-$ ; 6215
 38926 00006630 1A06C018                	dw 1562,MSG_1562-$ ; 6336
 38927 00006634 1B06EC18                	dw 1563,MSG_1563-$ ; 6380
 38928 00006638 1C061319                	dw 1564,MSG_1564-$ ; 6419
 38929 0000663C 1D064D19                	dw 1565,MSG_1565-$ ; 6477
 38930 00006640 1E067E19                	dw 1566,MSG_1566-$ ; 6526
 38931 00006644 1F06A719                	dw 1567,MSG_1567-$ ; 6567
 38932 00006648 20061D1A                	dw 1568,MSG_1568-$ ; 6685
 38933 0000664C 2C06661A                	dw 1580,MSG_1580-$ ; 6758
 38934                                  ;$M_ID_3_127:
 38935                                  $M_ID_3_147: ; 17/06/2023
 38936 00006650 4006AA1A                	dw 1600,MSG_1600-$ ; 6826
 38937 00006654 4106C31A                	dw 1601,MSG_1601-$ ; 6851
 38938 00006658 4206131B                	dw 1602,MSG_1602-$ ; 6931
 38939 0000665C 5406B01B                	dw 1620,MSG_1620-$ ; 7088
 38940 00006660 5506041C                	dw 1621,MSG_1621-$ ; 7172
 38941 00006664 5606821C                	dw 1622,MSG_1622-$ ; 7298
 38942 00006668 6806CA1C                	dw 1640,MSG_1640-$ ; 7370
 38943 0000666C 6906F41C                	dw 1641,MSG_1641-$ ; 7412
 38944 00006670 7C06741D                	dw 1660,MSG_1660-$ ; 7540
 38945 00006674 9006B71D                	dw 1680,MSG_1680-$ ; 7607
 38946 00006678 A406D91D                	dw 1700,MSG_1700-$ ; 7641
 38947 0000667C B806871E                	dw 1720,MSG_1720-$ ; 7815
 38948 00006680 CC06D61E                	dw 1740,MSG_1740-$ ; 7894
 38949 00006684 CD062E1F                	dw 1741,MSG_1741-$ ; 7982
 38950 00006688 E0069D1F                	dw 1760,MSG_1760-$ ; 8093
 38951 0000668C F406E61F                	dw 1780,MSG_1780-$ ; 8166
 38952                                  ;$M_ID_3_143:
 38953                                  $M_ID_3_163: ; 17/06/2023
 38954 00006690 08074E20                	dw 1800,MSG_1800-$ ; 8270
 38955 00006694 09079820                	dw 1801,MSG_1801-$ ; 8344
 38956 00006698 1C07EC20                	dw 1820,MSG_1820-$ ; 8428
 38957 0000669C 1D073021                	dw 1821,MSG_1821-$ ; 8496
 38958 000066A0 3007B721                	dw 1840,MSG_1840-$ ; 8631
 38959 000066A4 4407FE21                	dw 1860,MSG_1860-$ ; 8702
 38960 000066A8 45075522                	dw 1861,MSG_1861-$ ; 8789
 38961 000066AC 46079822                	dw 1862,MSG_1862-$ ; 8856
 38962 000066B0 47071223                	dw 1863,MSG_1863-$ ; 8978
 38963 000066B4 4807B123                	dw 1864,MSG_1864-$ ; 9137
 38964 000066B8 49071424                	dw 1865,MSG_1865-$ ; 9236
 38965 000066BC 4A077B24                	dw 1866,MSG_1866-$ ; 9339
 38966 000066C0 5807DF24                	dw 1880,MSG_1880-$ ; 9439
 38967 000066C4 59075325                	dw 1881,MSG_1881-$ ; 9555
 38968 000066C8 5A07CD25                	dw 1882,MSG_1882-$ ; 9677
 38969 000066CC 5B072026                	dw 1883,MSG_1883-$ ; 9760
 38970 000066D0 6C07BF26                	dw 1900,MSG_1900-$ ; 9919
 38971 000066D4 8007D326                	dw 1920,MSG_1920-$ ; 9939
 38972 000066D8 8107FF26                	dw 1921,MSG_1921-$ ; 9983
 38973                                  ;$M_ID_3_162:
 38974                                  $M_ID_3_182: ; 17/06/2023
 38975 000066DC 82079927                	dw 1922,MSG_1922-$ ; 9285
 38976                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38977 000066E0 83074C28                	dw 1923,MSG_1923-$ ; 10316
 38978 000066E4 8407CE28                	dw 1924,MSG_1924-$ ; 10446
 38979 000066E8 85074A29                	dw 1925,MSG_1925-$ ; 10570
 38980 000066EC 8607CA29                	dw 1926,MSG_1926-$ ; 10698
 38981                                  $M_ID_3_187:	; 17/06/2023
 38982 000066F0 8707                    	dw 1927	; 19/06/2023	; Message Number = 1927
 38983 000066F2 1E2A                    	dw MSG_1927-$+2	; 10782	; Message offset from message number
 38984                                  				; (Msg addr: 6C1Ch+2A1Eh = TRANGROUP:963Ah)
 38985                                  
 38986                                  ; ---------------------------------------------------------------------------
 38987                                  ; Class 3 messages
 38988                                  ; ---------------------------------------------------------------------------
 38989                                  	
 38990                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38991                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5CD0h
 38992                                  
 38993                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38994                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6C20h
 38995                                  
 38996                                  MSG_1020:	; COMMON4
 38997 000066F4 0F                      	db 15	; (MSG_1015-MSG_1020)-1
 38998 000066F5 253120627974657320-     	db '%1 bytes free',0Dh,0Ah
 38998 000066FE 667265650D0A       
 38999                                  MSG_1015:	; COMMON18
 39000 00006704 23                      	db 35
 39001 00006705 46696C652063616E6E-     	db 'File cannot be copied onto itself',0Dh,0Ah
 39001 0000670E 6F7420626520636F70-
 39001 00006717 696564206F6E746F20-
 39001 00006720 697473656C660D0A   
 39002                                  MSG_1004:	; COMMON20
 39003 00006728 19                      	db 25
 39004 00006729 496E73756666696369-     	db 'Insufficient disk space',0Dh,0Ah
 39004 00006732 656E74206469736B20-
 39004 0000673B 73706163650D0A     
 39005                                  MSG_1026:	; COMMON22
 39006 00006742 13                      	db 19
 39007 00006743 496E76616C69642063-     	db 'Invalid code page',0Dh,0Ah
 39007 0000674C 6F646520706167650D-
 39007 00006755 0A                 
 39008                                  MSG_1031:	; COMMON23
 39009 00006756 0E                      	db 14
 39010 00006757 496E76616C69642064-     	db 'Invalid date',0Dh,0Ah
 39010 00006760 6174650D0A         
 39011                                  MSG_1035:	; COMMON24
 39012 00006765 0E                      	db 14
 39013 00006766 496E76616C69642074-     	db 'Invalid time',0Dh,0Ah
 39013 0000676F 696D650D0A         
 39014                                  MSG_1062:	; COMMON25
 39015 00006774 0E                      	db 14
 39016 00006775 496E76616C69642070-     	db 'Invalid path',0Dh,0Ah
 39016 0000677E 6174680D0A         
 39017                                  MSG_1028:	; COMMON28
 39018 00006783 21                      	db 33
 39019 00006784 507265737320616E79-     	db 'Press any key to continue . . .',0Dh,0Ah
 39019 0000678D 206B657920746F2063-
 39019 00006796 6F6E74696E7565202E-
 39019 0000679F 202E202E0D0A       
 39020                                  MSG_1045:	; COMMON32
 39021 000067A5 1C                      	db 28
 39022 000067A6 556E61626C6520746F-     	db 'Unable to create directory',0Dh,0Ah
 39022 000067AF 206372656174652064-
 39022 000067B8 69726563746F72790D-
 39022 000067C1 0A                 
 39023                                  MSG_1041:	; COMMON33
 39024 000067C2 21                      	db 33
 39025 000067C3 566F6C756D6520696E-     	db 'Volume in drive %1 has no label',0Dh,0Ah
 39025 000067CC 206472697665202531-
 39025 000067D5 20686173206E6F206C-
 39025 000067DE 6162656C0D0A       
 39026                                  MSG_1042:	; COMMON34
 39027 000067E4 1A                      	db 26
 39028 000067E5 566F6C756D6520696E-     	db 'Volume in drive %1 is %2',0Dh,0Ah
 39028 000067EE 206472697665202531-
 39028 000067F7 2069732025320D0A   
 39029                                  MSG_1043:	; COMMON36
 39030 000067FF 1F                      	db 31  ; (MSG_1002-MSG_1043)-1
 39031 00006800 566F6C756D65205365-     	db 'Volume Serial Number is %1-%2',0Dh,0Ah
 39031 00006809 7269616C204E756D62-
 39031 00006812 65722069732025312D-
 39031 0000681B 25320D0A           
 39032                                  MSG_1002:
 39033 0000681F 27                              db 39
 39034 00006820 4475706C6963617465-     	db 'Duplicate file name or file not found',0Dh,0Ah
 39034 00006829 2066696C65206E616D-
 39034 00006832 65206F722066696C65-
 39034 0000683B 206E6F7420666F756E-
 39034 00006844 640D0A             
 39035                                  MSG_1003:
 39036 00006847 1B                      	db 27
 39037 00006848 496E76616C69642070-     	db 'Invalid path or file name',0Dh,0Ah
 39037 00006851 617468206F72206669-
 39037 0000685A 6C65206E616D650D0A 
 39038                                  MSG_1007:
 39039 00006863 1A                      	db 26
 39040 00006864 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
 39040 0000686D 7669726F6E6D656E74-
 39040 00006876 2073706163650D0A   
 39041                                  MSG_1008:
 39042 0000687E 15                      	db 21
 39043 0000687F 46696C652063726561-     	db 'File creation error',0Dh,0Ah
 39043 00006888 74696F6E206572726F-
 39043 00006891 720D0A             
 39044                                  MSG_1009:
 39045 00006894 14                      	db 20  ; (MSG_1010-MSG_1009)-1
 39046 00006895 42617463682066696C-     	db 'Batch file missing',0Dh,0Ah
 39046 0000689E 65206D697373696E67-
 39046 000068A7 0D0A               
 39047                                  MSG_1010:
 39048 000068A9 1F                      	db 31
 39049 000068AA 0D0A                    	db 0Dh,0Ah
 39050 000068AC 496E73657274206469-     	db 'Insert disk with batch file',0Dh,0Ah
 39050 000068B5 736B20776974682062-
 39050 000068BE 617463682066696C65-
 39050 000068C7 0D0A               
 39051                                  MSG_1011:
 39052 000068C9 1A                      	db 26
 39053 000068CA 42616420636F6D6D61-     	db 'Bad command or file name',0Dh,0Ah
 39053 000068D3 6E64206F722066696C-
 39053 000068DC 65206E616D650D0A   
 39054                                  MSG_1014:	; EXTEND5
 39055 000068E4 10                      	db 16
 39056 000068E5 416363657373206465-     	db 'Access denied ',0Dh,0Ah
 39056 000068EE 6E696564200D0A     
 39057                                  MSG_1016:
 39058 000068F5 29                      	db 41
 39059 000068F6 436F6E74656E74206F-     	db 'Content of destination lost before copy',0Dh,0Ah
 39059 000068FF 662064657374696E61-
 39059 00006908 74696F6E206C6F7374-
 39059 00006911 206265666F72652063-
 39059 0000691A 6F70790D0A         
 39060                                  MSG_1017:
 39061 0000691F 24                      	db 36
 39062 00006920 496E76616C69642066-     	db 'Invalid filename or file not found',0Dh,0Ah
 39062 00006929 696C656E616D65206F-
 39062 00006932 722066696C65206E6F-
 39062 0000693B 7420666F756E640D0A 
 39063                                  MSG_1018:
 39064 00006944 13                      	db 19
 39065 00006945 25312066696C652873-     	db '%1 file(s) copied',0Dh,0Ah
 39065 0000694E 2920636F706965640D-
 39065 00006957 0A                 
 39066                                  MSG_1019:
 39067 00006958 0B                      	db 11
 39068 00006959 25312066696C652873-     	db '%1 file(s) '
 39068 00006962 2920               
 39069                                  MSG_1021:	; EXTEND15
 39070 00006964 1D                      	db 29
 39071 00006965 496E76616C69642064-     	db 'Invalid drive specification',0Dh,0Ah
 39071 0000696E 726976652073706563-
 39071 00006977 696669636174696F6E-
 39071 00006980 0D0A               
 39072                                  MSG_1022:
 39073 00006982 26                      	db 38
 39074 00006983 436F64652070616765-     	db 'Code page %1 not prepared for system',0Dh,0Ah
 39074 0000698C 202531206E6F742070-
 39074 00006995 726570617265642066-
 39074 0000699E 6F722073797374656D-
 39074 000069A7 0D0A               
 39075                                  MSG_1023:
 39076 000069A9 2B                      	db 43
 39077 000069AA 436F64652070616765-     	db 'Code page %1 not prepared for all devices',0Dh,0Ah
 39077 000069B3 202531206E6F742070-
 39077 000069BC 726570617265642066-
 39077 000069C5 6F7220616C6C206465-
 39077 000069CE 76696365730D0A     
 39078                                  MSG_1024:
 39079 000069D5 16                      	db 22
 39080 000069D6 41637469766520636F-     	db 'Active code page: %1',0Dh,0Ah
 39080 000069DF 646520706167653A20-
 39080 000069E8 25310D0A           
 39081                                  MSG_1025:
 39082 000069EC 17                      	db 23
 39083 000069ED 4E4C5346554E43206E-     	db 'NLSFUNC not installed',0Dh,0Ah
 39083 000069F6 6F7420696E7374616C-
 39083 000069FF 6C65640D0A         
 39084                                  MSG_1027:
 39085 00006A04 20                      	db 32
 39086 00006A05 43757272656E742064-     	db 'Current drive is no longer valid'
 39086 00006A0E 72697665206973206E-
 39086 00006A17 6F206C6F6E67657220-
 39086 00006A20 76616C6964         
 39087                                  MSG_1029:
 39088 00006A25 11                      	db 17
 39089 00006A26 4C6162656C206E6F74-     	db 'Label not found',0Dh,0Ah
 39089 00006A2F 20666F756E640D0A   
 39090                                  MSG_1030:
 39091 00006A37 0E                      	db 14
 39092 00006A38 53796E746178206572-     	db 'Syntax error',0Dh,0Ah
 39092 00006A41 726F720D0A         
 39093                                  MSG_1032:
 39094 00006A46 17                      	db 23
 39095 00006A47 43757272656E742064-     	db 'Current date is %1 %2',0Dh,0Ah
 39095 00006A50 617465206973202531-
 39095 00006A59 2025320D0A         
 39096                                  MSG_1033:
 39097 00006A5E 15                      	db 21
 39098 00006A5F 53756E4D6F6E547565-     	db 'SunMonTueWedThuFriSat'
 39098 00006A68 576564546875467269-
 39098 00006A71 536174             
 39099                                  MSG_1034:
 39100 00006A74 15                      	db 21
 39101 00006A75 456E746572206E6577-     	db 'Enter new date (%1): '
 39101 00006A7E 206461746520282531-
 39101 00006A87 293A20             
 39102                                  MSG_1036:
 39103 00006A8A 14                      	db 20
 39104 00006A8B 43757272656E742074-     	db 'Current time is %1',0Dh,0Ah
 39104 00006A94 696D65206973202531-
 39104 00006A9D 0D0A               
 39105                                  MSG_1037:
 39106 00006A9F 10                      	db 16
 39107 00006AA0 456E746572206E6577-     	db 'Enter new time: '
 39107 00006AA9 2074696D653A20     
 39108                                  MSG_1038:
 39109 00006AB0 12                              db 18
 39110 00006AB1 2C2020202044656C65-     	db ',    Delete (Y/N)?'
 39110 00006ABA 74652028592F4E293F 
 39111                                  MSG_1039:
 39112 00006AC3 3C                              db 60
 39113 00006AC4 416C6C2066696C6573-     	db 'All files in directory will be deleted!',0Dh,0Ah
 39113 00006ACD 20696E206469726563-
 39113 00006AD6 746F72792077696C6C-
 39113 00006ADF 2062652064656C6574-
 39113 00006AE8 6564210D0A         
 39114 00006AED 41726520796F752073-     	db 'Are you sure (Y/N)?'
 39114 00006AF6 7572652028592F4E29-
 39114 00006AFF 3F                 
 39115                                  MSG_1040:
 39116 00006B00 14                      	db 20
 39117 00006B01 4D532D444F53205665-     	db 'MS-DOS Version %1.%2'
 39117 00006B0A 7273696F6E2025312E-
 39117 00006B13 2532               
 39118                                  MSG_1044:
 39119 00006B15 13                      	db 19
 39120 00006B16 496E76616C69642064-     	db 'Invalid directory',0Dh,0Ah
 39120 00006B1F 69726563746F72790D-
 39120 00006B28 0A                 
 39121                                  MSG_1046:
 39122 00006B29 36                      	db 54
 39123 00006B2A 496E76616C69642070-     	db 'Invalid path, not directory,',0Dh,0Ah
 39123 00006B33 6174682C206E6F7420-
 39123 00006B3C 6469726563746F7279-
 39123 00006B45 2C0D0A             
 39124 00006B48 6F7220646972656374-     	db 'or directory not empty',0Dh,0Ah
 39124 00006B51 6F7279206E6F742065-
 39124 00006B5A 6D7074790D0A       
 39125                                  MSG_1047:
 39126 00006B60 18                      	db 24
 39127 00006B61 4D7573742073706563-     	db 'Must specify ON or OFF',0Dh,0Ah
 39127 00006B6A 696679204F4E206F72-
 39127 00006B73 204F46460D0A       
 39128                                  MSG_1048:
 39129 00006B79 11                      	db 17
 39130 00006B7A 4469726563746F7279-     	db 'Directory of %1',0Dh,0Ah
 39130 00006B83 206F662025310D0A   
 39131                                  MSG_1049:
 39132 00006B8B 09                      	db 9
 39133 00006B8C 4E6F20506174680D0A      	db 'No Path',0Dh,0Ah
 39134                                  MSG_1050:
 39135 00006B95 1E                      	db 30
 39136 00006B96 496E76616C69642064-     	db 'Invalid drive in search path',0Dh,0Ah
 39136 00006B9F 7269766520696E2073-
 39136 00006BA8 656172636820706174-
 39136 00006BB1 680D0A             
 39137                                  MSG_1051:
 39138 00006BB4 10                      	db 16
 39139 00006BB5 496E76616C69642064-     	db 'Invalid device',0Dh,0Ah
 39139 00006BBE 65766963650D0A     
 39140                                  MSG_1052:
 39141 00006BC5 16                      	db 22
 39142 00006BC6 464F522063616E6E6F-     	db 'FOR cannot be nested',0Dh,0Ah
 39142 00006BCF 74206265206E657374-
 39142 00006BD8 65640D0A           
 39143                                  MSG_1053:
 39144 00006BDC 25                      	db 37
 39145 00006BDD 496E7465726D656469-     	db 'Intermediate file error during pipe',0Dh,0Ah
 39145 00006BE6 6174652066696C6520-
 39145 00006BEF 6572726F7220647572-
 39145 00006BF8 696E6720706970650D-
 39145 00006C01 0A                 
 39146                                  MSG_1054:
 39147 00006C02 26                      	db 38
 39148 00006C03 43616E6E6F7420646F-     	db 'Cannot do binary reads from a device',0Dh,0Ah
 39148 00006C0C 2062696E6172792072-
 39148 00006C15 656164732066726F6D-
 39148 00006C1E 206120646576696365-
 39148 00006C27 0D0A               
 39149                                  
 39150                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:6205h)
 39151                                  	; 17/06/2023
 39152                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:7155h)
 39153                                  MSG_1055:
 39154 00006C29 0D                      	db 13
 39155 00006C2A 425245414B20697320-     	db 'BREAK is %1',0Dh,0Ah
 39155 00006C33 25310D0A           
 39156                                  MSG_1056:
 39157 00006C37 0E                      	db 14
 39158 00006C38 564552494659206973-     	db 'VERIFY is %1',0Dh,0Ah
 39158 00006C41 2025310D0A         
 39159                                  MSG_1057:
 39160 00006C46 0C                      	db 12
 39161 00006C47 4543484F2069732025-     	db 'ECHO is %1',0Dh,0Ah
 39161 00006C50 310D0A             
 39162                                  MSG_1059:
 39163 00006C53 04                      	db 4
 39164 00006C54 6F666600                	db 'off',0
 39165                                  MSG_1060:
 39166 00006C58 03                      	db 3
 39167 00006C59 6F6E00                  	db 'on',0
 39168                                  MSG_1061:
 39169 00006C5C 19                      	db 25
 39170 00006C5D 4572726F7220777269-     	db 'Error writing to device',0Dh,0Ah
 39170 00006C66 74696E6720746F2064-
 39170 00006C6F 65766963650D0A     
 39171                                  MSG_1063:
 39172 00006C76 02                      	db 2
 39173 00006C77 2531                    	db '%1'
 39174                                  MSG_1064:
 39175 00006C79 02                      	db 2
 39176 00006C7A 2531                    	db '%1'
 39177                                  MSG_1065:
 39178 00006C7C 02                      	db 2
 39179 00006C7D 2531                    	db '%1'
 39180                                  MSG_1066:
 39181 00006C7F 02                      	db 2
 39182 00006C80 2531                    	db '%1'
 39183                                  MSG_1067:
 39184 00006C82 01                      	db 1
 39185 00006C83 09                      	db 9
 39186                                  MSG_1068:
 39187 00006C84 0A                      	db 10
 39188 00006C85 203C4449523E202020-     	db ' <DIR>    '
 39188 00006C8E 20                 
 39189                                  MSG_1069:
 39190 00006C8F 03                      	db 3
 39191 00006C90 082008                  	db 8, 20h, 8
 39192                                  MSG_1070:	; CRLF		
 39193 00006C93 02                      	db 2
 39194 00006C94 0D                      	db 0Dh
 39195 00006C95 0A                      	db 0Ah
 39196                                  MSG_1071:
 39197 00006C96 02                      	db 2
 39198 00006C97 2531                    	db '%1'
 39199                                  	; 17/06/2023 - Retro DOS 4.2 COMMAND.COM
 39200                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:71C5h
 39201                                  MSG_1072:
 39202                                  	;db 8
 39203                                  	;db 'mm-dd-yy'
 39204 00006C99 09                      	db 9
 39205 00006C9A 6D6D2D64642D797900      	db 'mm-dd-yy',0
 39206                                  MSG_1073:
 39207                                  	;db 8
 39208                                  	;db 'dd-mm-yy'
 39209 00006CA3 09                      	db 9
 39210 00006CA4 64642D6D6D2D797900      	db 'dd-mm-yy',0
 39211                                  MSG_1074:
 39212                                  	;db 8
 39213                                  	;db 'yy-mm-dd'
 39214 00006CAD 09                      	db 9
 39215 00006CAE 79792D6D6D2D646400      	db 'yy-mm-dd',0
 39216                                  MSG_1075:
 39217 00006CB7 05                      	db 5
 39218 00006CB8 2531202532              	db '%1 %2'
 39219                                  MSG_1076:
 39220 00006CBD 02                      	db 2
 39221 00006CBE 2531                    	db '%1'
 39222                                  MSG_1077:
 39223 00006CC0 07                      	db 7
 39224 00006CC1 20253120202532          	db ' %1  %2'
 39225                                  MSG_1078:
 39226 00006CC8 1A                      	db 26
 39227 00006CC9 4469726563746F7279-     	db 'Directory already exists',0Dh,0Ah
 39227 00006CD2 20616C726561647920-
 39227 00006CDB 6578697374730D0A   
 39228                                  MSG_1079:
 39229 00006CE3 0A                      	db 10
 39230 00006CE4 25312062797465730D-     	db '%1 bytes',0Dh,0Ah
 39230 00006CED 0A                 
 39231                                  MSG_1080:
 39232 00006CEE 15                      	db 21
 39233 00006CEF 546F74616C2066696C-     	db 'Total files listed:',0Dh,0Ah
 39233 00006CF8 6573206C6973746564-
 39233 00006D01 3A0D0A             
 39234                                  MSG_1081:
 39235 00006D04 2A                      	db 42
 39236 00006D05 284572726F72206F63-     	db '(Error occurred in environment variable)',0Dh,0Ah
 39236 00006D0E 63757272656420696E-
 39236 00006D17 20656E7669726F6E6D-
 39236 00006D20 656E74207661726961-
 39236 00006D29 626C65290D0A       
 39237                                  	;
 39238                                  	; 17/06/2023 - Retro DOS 4.2 COMMAND.COM
 39239                                  MSG_1082:
 39240 00006D2F 07                              db 7
 39241 00006D30 205B592F4E5D3F          	db ' [Y/N]?'
 39242                                  MSG_1083:
 39243 00006D37 02                      	db 2
 39244 00006D38 594E                    	db 'YN'
 39245                                  	;
 39246                                  MSG_1084:
 39247 00006D3A 0F                      	db 15
 39248 00006D3B 28636F6E74696E7569-     	db '(continuing %1)'
 39248 00006D44 6E6720253129       
 39249                                  MSG_1090:
 39250 00006D4A 0D                      	db 13
 39251 00006D4B 5265766973696F6E20-     	db 'Revision %1',0Dh,0Ah
 39251 00006D54 25310D0A           
 39252                                  MSG_1091:
 39253 00006D58 0D                      	db 13
 39254 00006D59 444F5320697320696E-     	db 'DOS is in ROM'
 39254 00006D62 20524F4D           
 39255                                  MSG_1092:
 39256 00006D66 0D                      	db 13
 39257 00006D67 444F5320697320696E-     	db 'DOS is in HMA'
 39257 00006D70 20484D41           
 39258                                  MSG_1093:
 39259 00006D74 14                      	db 20
 39260 00006D75 444F5320697320696E-     	db 'DOS is in low memory'
 39260 00006D7E 206C6F77206D656D6F-
 39260 00006D87 7279               
 39261                                  MSG_1094:
 39262 00006D89 1C                      	db 28
 39263 00006D8A 43616E6E6F74204C6F-     	db 'Cannot Loadhigh batch file',0Dh,0Ah
 39263 00006D93 616468696768206261-
 39263 00006D9C 7463682066696C650D-
 39263 00006DA5 0A                 
 39264                                  MSG_1095:
 39265 00006DA6 1C                      	db 28
 39266 00006DA7 4C6F6164486967683A-     	db 'LoadHigh: Invalid filename',0Dh,0Ah
 39266 00006DB0 20496E76616C696420-
 39266 00006DB9 66696C656E616D650D-
 39266 00006DC2 0A                 
 39267                                  MSG_1096:
 39268 00006DC3 30                      	db 48
 39269 00006DC4 43616E6E6F74206F70-     	db 'Cannot open specified country information file',0Dh,0Ah
 39269 00006DCD 656E20737065636966-
 39269 00006DD6 69656420636F756E74-
 39269 00006DDF 727920696E666F726D-
 39269 00006DE8 6174696F6E2066696C-
 39269 00006DF1 650D0A             
 39270                                  
 39271                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39272                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:7320h
 39273                                  MSG_1097:
 39274 00006DF4 1C                      	db 28
 39275 00006DF5 4C6F6164486967683A-     	db 'LoadHigh: Invalid argument',0Dh,0Ah
 39275 00006DFE 20496E76616C696420-
 39275 00006E07 617267756D656E740D-
 39275 00006E10 0A                 
 39276                                  MSG_1098:
 39277 00006E11 1C                      	db 28
 39278 00006E12 526571756972656420-     	db 'Required parameter missing',0Dh,0Ah
 39278 00006E1B 706172616D65746572-
 39278 00006E24 206D697373696E670D-
 39278 00006E2D 0A                 
 39279                                  MSG_1099:
 39280 00006E2E 15                      	db 21
 39281 00006E2F 556E7265636F676E69-     	db 'Unrecognized switch',0Dh,0Ah
 39281 00006E38 7A6564207377697463-
 39281 00006E41 680D0A             
 39282                                  MSG_1100:
 39283 00006E44 25                      	db 37
 39284 00006E45 412062616420554D42-     	db 'A bad UMB number has been specified',0Dh,0Ah
 39284 00006E4E 206E756D6265722068-
 39284 00006E57 6173206265656E2073-
 39284 00006E60 70656369666965640D-
 39284 00006E69 0A                 
 39285                                  MSG_1101:
 39286 00006E6A 0E                      	db 14
 39287 00006E6B 202025312E25322074-     	db '  %1.%2 to 1.0'
 39287 00006E74 6F20312E30         
 39288                                  MSG_1102:
 39289 00006E79 39                      	db 57
 39290 00006E7A 202020202020202020-     	db '                 %1.%2 to 1.0 average compression ratio',0Dh,0Ah
 39290 00006E83 202020202020202025-
 39290 00006E8C 312E253220746F2031-
 39290 00006E95 2E3020617665726167-
 39290 00006E9E 6520636F6D70726573-
 39290 00006EA7 73696F6E2072617469-
 39290 00006EB0 6F0D0A             
 39291                                  MSG_1103:
 39292 00006EB3 1A                      	db 26
 39293 00006EB4 4F7665727772697465-     	db 'Overwrite %1 (Yes/No/All)?'
 39293 00006EBD 20253120285965732F-
 39293 00006EC6 4E6F2F416C6C293F   
 39294                                  MSG_1104:
 39295 00006ECE 03                      	db 3
 39296 00006ECF 59                      _Y_es:	db 'Y'
 39297 00006ED0 4E                      _N_o:	db 'N'
 39298 00006ED1 41                      _A_ll:	db 'A'
 39299                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:73FEh)
 39300                                  MSG_1105:
 39301 00006ED2 04                      	db 4
 39302 00006ED3 20202020                	db '    '
 39303                                  	
 39304                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C2h)
 39305                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:7403h
 39306                                  MSG_1200:
 39307 00006ED7 00                      	db 0	; /? unimplemented
 39308                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:7404h)
 39309                                  MSG_1300:
 39310 00006ED8 86                      	db 134
 39311 00006ED9 53657473206F722063-     	db 'Sets or clears extended CTRL+C checking.',0Dh,0Ah
 39311 00006EE2 6C6561727320657874-
 39311 00006EEB 656E64656420435452-
 39311 00006EF4 4C2B4320636865636B-
 39311 00006EFD 696E672E0D0A       
 39312 00006F03 0D0A                    	db 0Dh,0Ah
 39313 00006F05 425245414B205B4F4E-     	db 'BREAK [ON | OFF]',0Dh,0Ah
 39313 00006F0E 207C204F46465D0D0A 
 39314 00006F17 0D0A                    	db 0Dh,0Ah
 39315 00006F19 547970652042524541-     	db 'Type BREAK without a parameter to display the current BREAK setting.',0Dh,0Ah
 39315 00006F22 4B20776974686F7574-
 39315 00006F2B 206120706172616D65-
 39315 00006F34 74657220746F206469-
 39315 00006F3D 73706C617920746865-
 39315 00006F46 2063757272656E7420-
 39315 00006F4F 425245414B20736574-
 39315 00006F58 74696E672E0D0A     
 39316                                  MSG_1320:
 39317 00006F5F 3F                      	db 63
 39318 00006F60 446973706C61797320-     	db 'Displays or sets the active code page number.',0Dh,0Ah
 39318 00006F69 6F7220736574732074-
 39318 00006F72 686520616374697665-
 39318 00006F7B 20636F646520706167-
 39318 00006F84 65206E756D6265722E-
 39318 00006F8D 0D0A               
 39319 00006F8F 0D0A                    	db 0Dh,0Ah
 39320 00006F91 43484350205B6E6E6E-     	db 'CHCP [nnn]',0Dh,0Ah
 39320 00006F9A 5D0D0A             
 39321 00006F9D 0D0A                    	db 0Dh,0Ah
 39322                                  MSG_1321:
 39323 00006F9F 70                      	db 112
 39324 00006FA0 20206E6E6E20202053-     	db '  nnn   Specifies a code page number.',0Dh,0Ah
 39324 00006FA9 706563696669657320-
 39324 00006FB2 6120636F6465207061-
 39324 00006FBB 6765206E756D626572-
 39324 00006FC4 2E0D0A             
 39325 00006FC7 0D0A                    	db 0Dh,0Ah
 39326 00006FC9 547970652043484350-     	db 'Type CHCP without a parameter to display the active code page number.',0Dh,0Ah
 39326 00006FD2 20776974686F757420-
 39326 00006FDB 6120706172616D6574-
 39326 00006FE4 657220746F20646973-
 39326 00006FED 706C61792074686520-
 39326 00006FF6 61637469766520636F-
 39326 00006FFF 64652070616765206E-
 39326 00007008 756D6265722E0D0A   
 39327                                  MSG_1340:
 39328 00007010 5B                      	db 91
 39329 00007011 446973706C61797320-     	db 'Displays the name of or changes the current directory.',0Dh,0Ah
 39329 0000701A 746865206E616D6520-
 39329 00007023 6F66206F7220636861-
 39329 0000702C 6E6765732074686520-
 39329 00007035 63757272656E742064-
 39329 0000703E 69726563746F72792E-
 39329 00007047 0D0A               
 39330 00007049 0D0A                    	db 0Dh,0Ah
 39331 0000704B 4348444952205B6472-     	db 'CHDIR [drive:][path]',0Dh,0Ah
 39331 00007054 6976653A5D5B706174-
 39331 0000705D 685D0D0A           
 39332 00007061 43484449525B2E2E5D-     	db 'CHDIR[..]',0Dh,0Ah
 39332 0000706A 0D0A               
 39333                                  MSG_1341:
 39334 0000706C 62                      	db 98
 39335 0000706D 4344205B6472697665-     	db 'CD [drive:][path]',0Dh,0Ah
 39335 00007076 3A5D5B706174685D0D-
 39335 0000707F 0A                 
 39336 00007080 43445B2E2E5D0D0A        	db 'CD[..]',0Dh,0Ah
 39337 00007088 0D0A                    	db 0Dh,0Ah
 39338 0000708A 20202E2E2020205370-     	db '  ..   Specifies that you want to change to the parent directory.'
 39338 00007093 656369666965732074-
 39338 0000709C 68617420796F752077-
 39338 000070A5 616E7420746F206368-
 39338 000070AE 616E676520746F2074-
 39338 000070B7 686520706172656E74-
 39338 000070C0 206469726563746F72-
 39338 000070C9 792E               
 39339 000070CB 0D0A                    	db 0Dh,0Ah
 39340 000070CD 0D0A                    	db 0Dh,0Ah
 39341                                  MSG_1342:
 39342 000070CF 91                      	db 145
 39343 000070D0 547970652043442064-     	db 'Type CD drive: to display the current directory in the specified '
 39343 000070D9 726976653A20746F20-
 39343 000070E2 646973706C61792074-
 39343 000070EB 68652063757272656E-
 39343 000070F4 74206469726563746F-
 39343 000070FD 727920696E20746865-
 39343 00007106 207370656369666965-
 39343 0000710F 6420               
 39344 00007111 64726976652E0D0A        	db 'drive.',0Dh,0Ah
 39345 00007119 547970652043442077-     	db 'Type CD without parameters to display the current drive and directory.',0Dh,0Ah
 39345 00007122 6974686F7574207061-
 39345 0000712B 72616D657465727320-
 39345 00007134 746F20646973706C61-
 39345 0000713D 792074686520637572-
 39345 00007146 72656E742064726976-
 39345 0000714F 6520616E6420646972-
 39345 00007158 6563746F72792E0D0A 
 39346                                  MSG_1360:
 39347 00007161 1B                      	db 27
 39348 00007162 436C65617273207468-     	db 'Clears the screen.',0Dh,0Ah
 39348 0000716B 652073637265656E2E-
 39348 00007174 0D0A               
 39349 00007176 0D0A                    	db 0Dh,0Ah
 39350 00007178 434C530D0A              	db 'CLS',0Dh,0Ah
 39351                                  MSG_1400:
 39352                                  	;db 145
 39353                                  	;db 'Copies one or more files to another location.',0Dh,0Ah
 39354                                  	;db 0Dh,0Ah
 39355                                  	;db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [destination',0Dh,0Ah
 39356                                  	;db '  [/A | /B]] [/V]',0Dh,0Ah
 39357                                  	;db 0Dh,0Ah
 39358                                  	
 39359                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39360                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:76A9h)
 39361 0000717D 9C                      	db 156 ; 19/06/2023	
 39362 0000717E 436F70696573206F6E-     	db 'Copies one or more files to another location.',0Dh,0Ah
 39362 00007187 65206F72206D6F7265-
 39362 00007190 2066696C657320746F-
 39362 00007199 20616E6F7468657220-
 39362 000071A2 6C6F636174696F6E2E-
 39362 000071AB 0D0A               
 39363 000071AD 0D0A                    	db 0Dh,0Ah
 39364 000071AF 434F5059205B2F4120-     	db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [destination',0Dh,0Ah
 39364 000071B8 7C202F425D20736F75-
 39364 000071C1 726365205B2F41207C-
 39364 000071CA 202F425D205B2B2073-
 39364 000071D3 6F75726365205B2F41-
 39364 000071DC 207C202F425D205B2B-
 39364 000071E5 202E2E2E5D5D205B64-
 39364 000071EE 657374696E6174696F-
 39364 000071F7 6E0D0A             
 39365 000071FA 20205B2F41207C202F-     	db '  [/A | /B]] [/V] [/Y | /-Y]',0Dh,0Ah
 39365 00007203 425D5D205B2F565D20-
 39365 0000720C 5B2F59207C202F2D59-
 39365 00007215 5D0D0A             
 39366 00007218 0D0A                    	db 0Dh,0Ah
 39367                                  MSG_1401:
 39368 0000721A 68                      	db 104
 39369 0000721B 2020736F7572636520-     	db '  source       Specifies the file or files to be copied.',0Dh,0Ah
 39369 00007224 202020202020537065-
 39369 0000722D 636966696573207468-
 39369 00007236 652066696C65206F72-
 39369 0000723F 2066696C657320746F-
 39369 00007248 20626520636F706965-
 39369 00007251 642E0D0A           
 39370 00007255 20202F412020202020-     	db '  /A           Indicates an ASCII text file.',0Dh,0Ah
 39370 0000725E 202020202020496E64-
 39370 00007267 69636174657320616E-
 39370 00007270 204153434949207465-
 39370 00007279 78742066696C652E0D-
 39370 00007282 0A                 
 39371                                  MSG_1402:
 39372 00007283 76                      	db 118
 39373 00007284 20202F422020202020-     	db '  /B           Indicates a binary file.',0Dh,0Ah
 39373 0000728D 202020202020496E64-
 39373 00007296 696361746573206120-
 39373 0000729F 62696E617279206669-
 39373 000072A8 6C652E0D0A         
 39374 000072AD 202064657374696E61-     	db '  destination  Specifies the directory and/or filename for the new file(s).',0Dh,0Ah
 39374 000072B6 74696F6E2020537065-
 39374 000072BF 636966696573207468-
 39374 000072C8 65206469726563746F-
 39374 000072D1 727920616E642F6F72-
 39374 000072DA 2066696C656E616D65-
 39374 000072E3 20666F722074686520-
 39374 000072EC 6E65772066696C6528-
 39374 000072F5 73292E0D0A         
 39375                                  MSG_1403:	
 39376                                  	;db 65  ;  MSDOS 5.0
 39377                                  	; 17/06/2023
 39378 000072FA 3F                      	db 63 ; MSDOS 6.22	
 39379 000072FB 20202F562020202020-     	db '  /V           Verifies that new files are written correctly.',0Dh,0Ah
 39379 00007304 202020202020566572-
 39379 0000730D 696669657320746861-
 39379 00007316 74206E65772066696C-
 39379 0000731F 657320617265207772-
 39379 00007328 697474656E20636F72-
 39379 00007331 726563746C792E0D0A 
 39380                                  	;db 0Dh,0Ah ; MSDOS 5.0
 39381                                  
 39382                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39383                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:7866h
 39384                                  MSG_1404:
 39385 0000733A 74                              db 116
 39386 0000733B 20202F592020202020-     	db '  /Y           Suppresses prompting to confirm you want to overwrite an',0Dh,0Ah
 39386 00007344 202020202020537570-
 39386 0000734D 707265737365732070-
 39386 00007356 726F6D7074696E6720-
 39386 0000735F 746F20636F6E666972-
 39386 00007368 6D20796F752077616E-
 39386 00007371 7420746F206F766572-
 39386 0000737A 777269746520616E0D-
 39386 00007383 0A                 
 39387 00007384 202020202020202020-     	db '               existing destination file.',0Dh,0Ah
 39387 0000738D 202020202020657869-
 39387 00007396 7374696E6720646573-
 39387 0000739F 74696E6174696F6E20-
 39387 000073A8 66696C652E0D0A     
 39388                                  MSG_1405:
 39389 000073AF 72                      	db 114
 39390 000073B0 20202F2D5920202020-     	db '  /-Y          Causes prompting to confirm you want to overwrite an',0Dh,0Ah
 39390 000073B9 202020202020436175-
 39390 000073C2 7365732070726F6D70-
 39390 000073CB 74696E6720746F2063-
 39390 000073D4 6F6E6669726D20796F-
 39390 000073DD 752077616E7420746F-
 39390 000073E6 206F76657277726974-
 39390 000073EF 6520616E0D0A       
 39391 000073F5 202020202020202020-     	db '               existing destination file.',0Dh,0Ah
 39391 000073FE 202020202020657869-
 39391 00007407 7374696E6720646573-
 39391 00007410 74696E6174696F6E20-
 39391 00007419 66696C652E0D0A     
 39392 00007420 0D0A                    	db 0Dh,0Ah
 39393                                  MSG_1406:
 39394 00007422 42                      	db 66
 39395 00007423 546865207377697463-     	db 'The switch /Y may be preset in the COPYCMD environment variable.',0Dh,0Ah
 39395 0000742C 68202F59206D617920-
 39395 00007435 626520707265736574-
 39395 0000743E 20696E207468652043-
 39395 00007447 4F5059434D4420656E-
 39395 00007450 7669726F6E6D656E74-
 39395 00007459 207661726961626C65-
 39395 00007462 2E0D0A             
 39396                                  
 39397                                  ;MSG_1404: ; MSDOS 5.0 (TRANGROUP:681Ch)
 39398                                  MSG_1407:  ; MSDOS 6.22	(TRANGROUP:7991h)
 39399 00007465 87                      	db 135
 39400 00007466 546F20617070656E64-     	db 'To append files, specify a single file for destination, but multiple files',0Dh,0Ah
 39400 0000746F 2066696C65732C2073-
 39400 00007478 706563696679206120-
 39400 00007481 73696E676C65206669-
 39400 0000748A 6C6520666F72206465-
 39400 00007493 7374696E6174696F6E-
 39400 0000749C 2C20627574206D756C-
 39400 000074A5 7469706C652066696C-
 39400 000074AE 65730D0A           
 39401 000074B2 666F7220736F757263-     	db 'for source (using wildcards or file1+file2+file3 format).',0Dh,0Ah
 39401 000074BB 6520287573696E6720-
 39401 000074C4 77696C646361726473-
 39401 000074CD 206F722066696C6531-
 39401 000074D6 2B66696C65322B6669-
 39401 000074DF 6C653320666F726D61-
 39401 000074E8 74292E0D0A         
 39402                                  MSG_1420:
 39403 000074ED 8A                      	db 138
 39404 000074EE 4368616E6765732074-     	db 'Changes the terminal device used to control your system.',0Dh,0Ah
 39404 000074F7 6865207465726D696E-
 39404 00007500 616C20646576696365-
 39404 00007509 207573656420746F20-
 39404 00007512 636F6E74726F6C2079-
 39404 0000751B 6F7572207379737465-
 39404 00007524 6D2E0D0A           
 39405 00007528 0D0A                    	db 0Dh,0Ah
 39406 0000752A 435454592064657669-     	db 'CTTY device',0Dh,0Ah
 39406 00007533 63650D0A           
 39407 00007537 0D0A                    	db 0Dh,0Ah
 39408 00007539 202064657669636520-     	db '  device   The terminal device you want to use, such as COM1.',0Dh,0Ah
 39408 00007542 202054686520746572-
 39408 0000754B 6D696E616C20646576-
 39408 00007554 69636520796F752077-
 39408 0000755D 616E7420746F207573-
 39408 00007566 652C20737563682061-
 39408 0000756F 7320434F4D312E0D0A 
 39409                                  MSG_1440:
 39410                                  	;db 45
 39411                                  	;db 'Displays or sets the date.',0Dh,0Ah
 39412                                  	;db 0Dh,0Ah
 39413                                  	;db 'DATE [date]',0Dh,0Ah
 39414                                  	;db 0Dh,0Ah
 39415                                  
 39416                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39417                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:7AA4h)
 39418 00007578 5D                      	db 93
 39419 00007579 446973706C61797320-     	db 'Displays or sets the date.',0Dh,0Ah
 39419 00007582 6F7220736574732074-
 39419 0000758B 686520646174652E0D-
 39419 00007594 0A                 
 39420 00007595 0D0A                    	db 0Dh,0Ah
 39421 00007597 44415445205B6D6D2D-     	db 'DATE [mm-dd-yy]',0Dh,0Ah
 39421 000075A0 64642D79795D0D0A   
 39422 000075A8 0D0A                    	db 0Dh,0Ah
 39423 000075AA 20206D6D2D64642D79-     	db '  mm-dd-yy    Sets the date you specify.',0Dh,0Ah
 39423 000075B3 792020202053657473-
 39423 000075BC 207468652064617465-
 39423 000075C5 20796F752073706563-
 39423 000075CE 6966792E0D0A       
 39424 000075D4 0D0A                    	db 0Dh,0Ah
 39425                                  MSG_1441:
 39426 000075D6 83                      	db 131
 39427 000075D7 547970652044415445-     	db 'Type DATE without parameters to display the current date setting and',0Dh,0Ah
 39427 000075E0 20776974686F757420-
 39427 000075E9 706172616D65746572-
 39427 000075F2 7320746F2064697370-
 39427 000075FB 6C6179207468652063-
 39427 00007604 757272656E74206461-
 39427 0000760D 74652073657474696E-
 39427 00007616 6720616E640D0A     
 39428 0000761D 612070726F6D707420-     	db 'a prompt for a new one.  Press ENTER to keep the same date.',0Dh,0Ah
 39428 00007626 666F722061206E6577-
 39428 0000762F 206F6E652E20205072-
 39428 00007638 65737320454E544552-
 39428 00007641 20746F206B65657020-
 39428 0000764A 7468652073616D6520-
 39428 00007653 646174652E0D0A     
 39429                                  MSG_1460:	
 39430 0000765A 64                      	db 100
 39431 0000765B 44656C65746573206F-     	db 'Deletes one or more files.',0Dh,0Ah
 39431 00007664 6E65206F72206D6F72-
 39431 0000766D 652066696C65732E0D-
 39431 00007676 0A                 
 39432 00007677 0D0A                    	db 0Dh,0Ah
 39433 00007679 44454C205B64726976-     	db 'DEL [drive:][path]filename [/P]',0Dh,0Ah
 39433 00007682 653A5D5B706174685D-
 39433 0000768B 66696C656E616D6520-
 39433 00007694 5B2F505D0D0A       
 39434 0000769A 4552415345205B6472-     	db 'ERASE [drive:][path]filename [/P]',0Dh,0Ah
 39434 000076A3 6976653A5D5B706174-
 39434 000076AC 685D66696C656E616D-
 39434 000076B5 65205B2F505D0D0A   
 39435 000076BD 0D0A                    	db 0Dh,0Ah
 39436                                  MSG_1461:
 39437 000076BF 83                      	db 131
 39438 000076C0 20205B64726976653A-     	db '  [drive:][path]filename  Specifies the file(s) to delete.  Specify multiple',0Dh,0Ah
 39438 000076C9 5D5B706174685D6669-
 39438 000076D2 6C656E616D65202053-
 39438 000076DB 706563696669657320-
 39438 000076E4 7468652066696C6528-
 39438 000076ED 732920746F2064656C-
 39438 000076F6 6574652E2020537065-
 39438 000076FF 63696679206D756C74-
 39438 00007708 69706C650D0A       
 39439 0000770E 202020202020202020-     	db '                          files by using wildcards.',0Dh,0Ah
 39439 00007717 202020202020202020-
 39439 00007720 202020202020202066-
 39439 00007729 696C65732062792075-
 39439 00007732 73696E672077696C64-
 39439 0000773B 63617264732E0D0A   
 39440                                  MSG_1462:
 39441 00007743 4F                      	db 79
 39442 00007744 20202F502020202020-     	db '  /P                      Prompts for confirmation before deleting each file.',0Dh,0Ah
 39442 0000774D 202020202020202020-
 39442 00007756 202020202020202050-
 39442 0000775F 726F6D70747320666F-
 39442 00007768 7220636F6E6669726D-
 39442 00007771 6174696F6E20626566-
 39442 0000777A 6F72652064656C6574-
 39442 00007783 696E67206561636820-
 39442 0000778C 66696C652E0D0A     
 39443                                  
 39444                                  ; 17/06/2023
 39445                                  %if 0	; MSDOS 5.0 DIR Help messages 
 39446                                  
 39447                                  MSG_1480:
 39448                                  	db 162
 39449                                  	db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
 39450                                  	db 0Dh,0Ah
 39451                                  	db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attributes]]',0Dh,0Ah
 39452                                  	db '  [/O[[:]sortorder]] [/S] [/B] [/L]',0Dh,0Ah
 39453                                  	db 0Dh,0Ah
 39454                                  MSG_1481:
 39455                                  	db 93
 39456                                  	db '  [drive:][path][filename]',0Dh,0Ah
 39457                                  	db '              Specifies drive, directory, and/or files to list.',0Dh,0Ah
 39458                                  MSG_1482:
 39459                                  	db 97
 39460                                  	db '  /P          Pauses after each screenful of information.',0Dh,0Ah
 39461                                  	db '  /W          Uses wide list format.',0Dh,0Ah
 39462                                  MSG_1483:	
 39463                                  	db 122
 39464                                  	db '  /A          Displays files with specified attributes.',0Dh,0Ah
 39465                                  	db '  attributes   D  Directories                R  Read-only files',0Dh,0Ah
 39466                                  MSG_1484:
 39467                                  	db 191
 39468                                  	db '               H  Hidden files               A  Files ready for archiving',0Dh,0Ah
 39469                                  	db '               S  System files               -  Prefix meaning "not"',0Dh,0Ah
 39470                                  	db '  /O          List by files in sorted order.',0Dh,0Ah
 39471                                  MSG_1485:
 39472                                  	db 155
 39473                                  	db '  sortorder    N  By name (alphabetic)       S  By size (smallest first)',0Dh,0Ah
 39474                                  	db '               E  By extension (alphabetic)  D  By date & time (earliest first)',0Dh,0Ah
 39475                                  MSG_1486:
 39476                                  	db 150
 39477                                  	db '               G  Group directories first    -  Prefix to reverse order',0Dh,0Ah
 39478                                  	db '  /S          Displays files in specified directory and all subdirectories.',0Dh,0Ah
 39479                                  MSG_1487:
 39480                                  	db 102
 39481                                  	db '  /B          Uses bare format (no heading information or summary).',0Dh,0Ah
 39482                                  	db '  /L          Uses lowercase.',0Dh,0Ah
 39483                                  	db 0Dh,0Ah
 39484                                  MSG_1488:
 39485                                  	db 146
 39486                                  	db 'Switches may be preset in the DIRCMD environment variable.  Override',0Dh,0Ah
 39487                                  	db 'preset switches by prefixing any switch with - (hyphen)--for example, /-W.',0Dh,0Ah
 39488                                  %endif
 39489                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39490                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:7CBFh
 39491                                  MSG_1480:
 39492 00007793 89                      	db 137
 39493 00007794 446973706C61797320-     	db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
 39493 0000779D 61206C697374206F66-
 39493 000077A6 2066696C657320616E-
 39493 000077AF 642073756264697265-
 39493 000077B8 63746F726965732069-
 39493 000077C1 6E2061206469726563-
 39493 000077CA 746F72792E0D0A     
 39494 000077D1 0D0A                    	db 0Dh,0Ah
 39495 000077D3 444952205B64726976-     	db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attribs]] [/O[[:]sortord]]',0Dh,0Ah
 39495 000077DC 653A5D5B706174685D-
 39495 000077E5 5B66696C656E616D65-
 39495 000077EE 5D205B2F505D205B2F-
 39495 000077F7 575D205B2F415B5B3A-
 39495 00007800 5D617474726962735D-
 39495 00007809 5D205B2F4F5B5B3A5D-
 39495 00007812 736F72746F72645D5D-
 39495 0000781B 0D0A               
 39496                                  MSG_1481:
 39497 0000781D 1E                      	db 30
 39498 0000781E 202020205B2F535D20-     	db '    [/S] [/B] [/L] [/C[H]]',0Dh,0Ah
 39498 00007827 5B2F425D205B2F4C5D-
 39498 00007830 205B2F435B485D5D0D-
 39498 00007839 0A                 
 39499 0000783A 0D0A                    	db 0Dh,0Ah
 39500                                  MSG_1482:
 39501 0000783C 50                      	db 80
 39502 0000783D 20205B64726976653A-     	db '  [drive:][path][filename]   Specifies drive, directory, and/or files to list.',0Dh,0Ah
 39502 00007846 5D5B706174685D5B66-
 39502 0000784F 696C656E616D655D20-
 39502 00007858 202053706563696669-
 39502 00007861 65732064726976652C-
 39502 0000786A 206469726563746F72-
 39502 00007873 792C20616E642F6F72-
 39502 0000787C 2066696C657320746F-
 39502 00007885 206C6973742E0D0A   
 39503                                  MSG_1483:
 39504 0000788D 59                      	db 89
 39505 0000788E 20202F502020202020-     	db '  /P      Pauses after each screenful of information.',0Dh,0Ah
 39505 00007897 205061757365732061-
 39505 000078A0 667465722065616368-
 39505 000078A9 2073637265656E6675-
 39505 000078B2 6C206F6620696E666F-
 39505 000078BB 726D6174696F6E2E0D-
 39505 000078C4 0A                 
 39506 000078C5 20202F572020202020-     	db '  /W      Uses wide list format.',0Dh,0Ah
 39506 000078CE 205573657320776964-
 39506 000078D7 65206C69737420666F-
 39506 000078E0 726D61742E0D0A     
 39507                                  MSG_1484:
 39508 000078E7 7E                      	db 126
 39509 000078E8 20202F412020202020-     	db '  /A      Displays files with specified attributes.',0Dh,0Ah
 39509 000078F1 20446973706C617973-
 39509 000078FA 2066696C6573207769-
 39509 00007903 746820737065636966-
 39509 0000790C 696564206174747269-
 39509 00007915 62757465732E0D0A   
 39510 0000791D 202061747472696273-     	db '  attribs   D  Directories   R  Read-only files         H  Hidden files',0Dh,0Ah
 39510 00007926 202020442020446972-
 39510 0000792F 6563746F7269657320-
 39510 00007938 202052202052656164-
 39510 00007941 2D6F6E6C792066696C-
 39510 0000794A 657320202020202020-
 39510 00007953 202048202048696464-
 39510 0000795C 656E2066696C65730D-
 39510 00007965 0A                 
 39511                                  MSG_1485:
 39512 00007966 7B                      	db 123
 39513 00007967 202020202020202020-     	db '            S  System files  A  Files ready to archive  -  Prefix meaning "not"',0Dh,0Ah
 39513 00007970 202020532020537973-
 39513 00007979 74656D2066696C6573-
 39513 00007982 202041202046696C65-
 39513 0000798B 732072656164792074-
 39513 00007994 6F2061726368697665-
 39513 0000799D 20202D202050726566-
 39513 000079A6 6978206D65616E696E-
 39513 000079AF 6720226E6F74220D0A 
 39514 000079B8 20202F4F2020202020-     	db '  /O      List by files in sorted order.',0Dh,0Ah
 39514 000079C1 204C69737420627920-
 39514 000079CA 66696C657320696E20-
 39514 000079D3 736F72746564206F72-
 39514 000079DC 6465722E0D0A       
 39515                                  MSG_1486:
 39516 000079E2 95                      	db 149
 39517 000079E3 2020736F72746F7264-     	db '  sortord   N  By name (alphabetic)       S  By size (smallest first)',0Dh,0Ah
 39517 000079EC 2020204E2020427920-
 39517 000079F5 6E616D652028616C70-
 39517 000079FE 686162657469632920-
 39517 00007A07 202020202020532020-
 39517 00007A10 42792073697A652028-
 39517 00007A19 736D616C6C65737420-
 39517 00007A22 6669727374290D0A   
 39518 00007A2A 202020202020202020-     	db '            E  By extension (alphabetic)  D  By date & time (earliest first)',0Dh,0Ah
 39518 00007A33 202020452020427920-
 39518 00007A3C 657874656E73696F6E-
 39518 00007A45 2028616C7068616265-
 39518 00007A4E 746963292020442020-
 39518 00007A57 427920646174652026-
 39518 00007A60 2074696D6520286561-
 39518 00007A69 726C69657374206669-
 39518 00007A72 727374290D0A       
 39519                                  MSG_1487:
 39520 00007A78 46                      	db 70
 39521 00007A79 202020202020202020-     	db '            G  Group directories first    -  Prefix to reverse order',0Dh,0Ah
 39521 00007A82 20202047202047726F-
 39521 00007A8B 757020646972656374-
 39521 00007A94 6F7269657320666972-
 39521 00007A9D 7374202020202D2020-
 39521 00007AA6 50726566697820746F-
 39521 00007AAF 207265766572736520-
 39521 00007AB8 6F726465720D0A     
 39522                                  MSG_1488:
 39523 00007ABF 7F                      	db 127
 39524 00007AC0 202020202020202020-     	db '            C  By compression ratio (smallest first)',0Dh,0Ah
 39524 00007AC9 202020432020427920-
 39524 00007AD2 636F6D707265737369-
 39524 00007ADB 6F6E20726174696F20-
 39524 00007AE4 28736D616C6C657374-
 39524 00007AED 206669727374290D0A 
 39525 00007AF6 20202F532020202020-     	db '  /S      Displays files in specified directory and all subdirectories.',0Dh,0Ah
 39525 00007AFF 20446973706C617973-
 39525 00007B08 2066696C657320696E-
 39525 00007B11 207370656369666965-
 39525 00007B1A 64206469726563746F-
 39525 00007B23 727920616E6420616C-
 39525 00007B2C 6C2073756264697265-
 39525 00007B35 63746F726965732E0D-
 39525 00007B3E 0A                 
 39526                                  MSG_1489:
 39527 00007B3F 41                      	db 65
 39528 00007B40 20202F422020202020-     	db '  /B      Uses bare format (no heading information or summary).',0Dh,0Ah
 39528 00007B49 205573657320626172-
 39528 00007B52 6520666F726D617420-
 39528 00007B5B 286E6F206865616469-
 39528 00007B64 6E6720696E666F726D-
 39528 00007B6D 6174696F6E206F7220-
 39528 00007B76 73756D6D617279292E-
 39528 00007B7F 0D0A               
 39529                                  MSG_1490:
 39530 00007B81 1B                      	db 27
 39531 00007B82 20202F4C2020202020-     	db '  /L      Uses lowercase.',0Dh,0Ah
 39531 00007B8B 2055736573206C6F77-
 39531 00007B94 6572636173652E0D0A 
 39532                                  MSG_1491:
 39533 00007B9D 52                      	db 82
 39534 00007B9E 20202F435B485D2020-     	db '  /C[H]   Displays file compression ratio; /CH uses host allocation unit size.',0Dh,0Ah
 39534 00007BA7 20446973706C617973-
 39534 00007BB0 2066696C6520636F6D-
 39534 00007BB9 7072657373696F6E20-
 39534 00007BC2 726174696F3B202F43-
 39534 00007BCB 48207573657320686F-
 39534 00007BD4 737420616C6C6F6361-
 39534 00007BDD 74696F6E20756E6974-
 39534 00007BE6 2073697A652E0D0A   
 39535 00007BEE 0D0A                    	db 0Dh,0Ah
 39536                                  MSG_1492:
 39537 00007BF0 92                      	db 146
 39538 00007BF1 537769746368657320-     	db 'Switches may be preset in the DIRCMD environment variable.  Override',0Dh,0Ah
 39538 00007BFA 6D6179206265207072-
 39538 00007C03 6573657420696E2074-
 39538 00007C0C 686520444952434D44-
 39538 00007C15 20656E7669726F6E6D-
 39538 00007C1E 656E74207661726961-
 39538 00007C27 626C652E20204F7665-
 39538 00007C30 72726964650D0A     
 39539 00007C37 707265736574207377-     	db 'preset switches by prefixing any switch with - (hyphen)--for example, /-W.',0Dh,0Ah
 39539 00007C40 697463686573206279-
 39539 00007C49 20707265666978696E-
 39539 00007C52 6720616E7920737769-
 39539 00007C5B 746368207769746820-
 39539 00007C64 2D202868797068656E-
 39539 00007C6D 292D2D666F72206578-
 39539 00007C76 616D706C652C202F2D-
 39539 00007C7F 572E0D0A           
 39540                                  MSG_1493:
 39541 00007C83 16                      	db 22
 39542 00007C84 202020205B2F535D20-     	db '    [/S] [/B] [/L]',0Dh,0Ah
 39542 00007C8D 5B2F425D205B2F4C5D-
 39542 00007C96 0D0A               
 39543 00007C98 0D0A                    	db 0Dh,0Ah
 39544                                  MSG_1494:
 39545 00007C9A 1D                      	db 29
 39546 00007C9B 20202F4C2020202020-     	db '  /L      Uses lowercase.',0Dh,0Ah
 39546 00007CA4 2055736573206C6F77-
 39546 00007CAD 6572636173652E0D0A 
 39547 00007CB6 0D0A                    	db 0Dh,0Ah
 39548                                  
 39549                                  MSG_1500:
 39550 00007CB8 3E                      	db 62
 39551 00007CB9 517569747320746865-     	db 'Quits the COMMAND.COM program (command interpreter).',0Dh,0Ah
 39551 00007CC2 20434F4D4D414E442E-
 39551 00007CCB 434F4D2070726F6772-
 39551 00007CD4 616D2028636F6D6D61-
 39551 00007CDD 6E6420696E74657270-
 39551 00007CE6 7265746572292E0D0A 
 39552 00007CEF 0D0A                    	db 0Dh,0Ah
 39553 00007CF1 455849540D0A            	db 'EXIT',0Dh,0Ah
 39554                                  MSG_1520:
 39555 00007CF7 3D                      	db 61
 39556 00007CF8 437265617465732061-     	db 'Creates a directory.',0Dh,0Ah
 39556 00007D01 206469726563746F72-
 39556 00007D0A 792E0D0A           
 39557 00007D0E 0D0A                    	db 0Dh,0Ah
 39558 00007D10 4D4B444952205B6472-     	db 'MKDIR [drive:]path',0Dh,0Ah
 39558 00007D19 6976653A5D70617468-
 39558 00007D22 0D0A               
 39559 00007D24 4D44205B6472697665-     	db 'MD [drive:]path',0Dh,0Ah
 39559 00007D2D 3A5D706174680D0A   
 39560                                  MSG_1540:
 39561 00007D35 5D                      	db 93
 39562 00007D36 446973706C61797320-     	db 'Displays or sets a search path for executable files.',0Dh,0Ah
 39562 00007D3F 6F7220736574732061-
 39562 00007D48 207365617263682070-
 39562 00007D51 61746820666F722065-
 39562 00007D5A 786563757461626C65-
 39562 00007D63 2066696C65732E0D0A 
 39563 00007D6C 0D0A                    	db 0Dh,0Ah
 39564 00007D6E 50415448205B5B6472-     	db 'PATH [[drive:]path[;...]]',0Dh,0Ah
 39564 00007D77 6976653A5D70617468-
 39564 00007D80 5B3B2E2E2E5D5D0D0A 
 39565 00007D89 50415448203B0D0A        	db 'PATH ;',0Dh,0Ah
 39566 00007D91 0D0A                    	db 0Dh,0Ah
 39567                                  MSG_1541:
 39568 00007D93 6B                      	db 107
 39569 00007D94 547970652050415448-     	db 'Type PATH ; to clear all search-path settings and direct MS-DOS to search',0Dh,0Ah
 39569 00007D9D 203B20746F20636C65-
 39569 00007DA6 617220616C6C207365-
 39569 00007DAF 617263682D70617468-
 39569 00007DB8 2073657474696E6773-
 39569 00007DC1 20616E642064697265-
 39569 00007DCA 6374204D532D444F53-
 39569 00007DD3 20746F207365617263-
 39569 00007DDC 680D0A             
 39570 00007DDF 6F6E6C7920696E2074-     	db 'only in the current directory.',0Dh,0Ah
 39570 00007DE8 68652063757272656E-
 39570 00007DF1 74206469726563746F-
 39570 00007DFA 72792E0D0A         
 39571                                  MSG_1542:	
 39572 00007DFF 3B                      	db 59
 39573 00007E00 547970652050415448-     	db 'Type PATH without parameters to display the current path.',0Dh,0Ah
 39573 00007E09 20776974686F757420-
 39573 00007E12 706172616D65746572-
 39573 00007E1B 7320746F2064697370-
 39573 00007E24 6C6179207468652063-
 39573 00007E2D 757272656E74207061-
 39573 00007E36 74682E0D0A         
 39574                                  MSG_1560:
 39575 00007E3B 37                      	db 55
 39576 00007E3C 4368616E6765732074-     	db 'Changes the MS-DOS command prompt.',0Dh,0Ah
 39576 00007E45 6865204D532D444F53-
 39576 00007E4E 20636F6D6D616E6420-
 39576 00007E57 70726F6D70742E0D0A 
 39577 00007E60 0D0A                    	db 0Dh,0Ah
 39578 00007E62 50524F4D5054205B74-     	db 'PROMPT [text]',0Dh,0Ah
 39578 00007E6B 6578745D0D0A       
 39579 00007E71 0D0A                    	db 0Dh,0Ah
 39580                                  MSG_1561:	
 39581 00007E73 7C                      	db 124
 39582 00007E74 202074657874202020-     	db '  text    Specifies a new command prompt.',0Dh,0Ah
 39582 00007E7D 205370656369666965-
 39582 00007E86 732061206E65772063-
 39582 00007E8F 6F6D6D616E64207072-
 39582 00007E98 6F6D70742E0D0A     
 39583 00007E9F 0D0A                    	db 0Dh,0Ah
 39584 00007EA1 50726F6D7074206361-     	db 'Prompt can be made up of normal characters and the following special codes:',0Dh,0Ah
 39584 00007EAA 6E206265206D616465-
 39584 00007EB3 207570206F66206E6F-
 39584 00007EBC 726D616C2063686172-
 39584 00007EC5 61637465727320616E-
 39584 00007ECE 642074686520666F6C-
 39584 00007ED7 6C6F77696E67207370-
 39584 00007EE0 656369616C20636F64-
 39584 00007EE9 65733A0D0A         
 39585 00007EEE 0D0A                    	db 0Dh,0Ah
 39586                                  MSG_1562:
 39587 00007EF0 2F                      	db 47
 39588 00007EF1 202024512020203D20-     	db '  $Q   = (equal sign)',0Dh,0Ah
 39588 00007EFA 28657175616C207369-
 39588 00007F03 676E290D0A         
 39589 00007F08 202024242020202420-     	db '  $$   $ (dollar sign)',0Dh,0Ah
 39589 00007F11 28646F6C6C61722073-
 39589 00007F1A 69676E290D0A       
 39590                                  MSG_1563:
 39591 00007F20 2A                      	db 42
 39592 00007F21 202024542020204375-     	db '  $T   Current time',0Dh,0Ah
 39592 00007F2A 7272656E742074696D-
 39592 00007F33 650D0A             
 39593 00007F36 202024442020204375-     	db '  $D   Current date',0Dh,0Ah
 39593 00007F3F 7272656E7420646174-
 39593 00007F48 650D0A             
 39594                                  MSG_1564:
 39595 00007F4B 3D                      	db 61
 39596 00007F4C 202024502020204375-     	db '  $P   Current drive and path',0Dh,0Ah
 39596 00007F55 7272656E7420647269-
 39596 00007F5E 766520616E64207061-
 39596 00007F67 74680D0A           
 39597 00007F6B 202024562020204D53-     	db '  $V   MS-DOS version number',0Dh,0Ah
 39597 00007F74 2D444F532076657273-
 39597 00007F7D 696F6E206E756D6265-
 39597 00007F86 720D0A             
 39598                                  MSG_1565:
 39599 00007F89 34                      	db 52
 39600 00007F8A 2020244E2020204375-     	db '  $N   Current drive',0Dh,0Ah
 39600 00007F93 7272656E7420647269-
 39600 00007F9C 76650D0A           
 39601 00007FA0 202024472020203E20-     	db '  $G   > (greater-than sign)',0Dh,0Ah
 39601 00007FA9 28677265617465722D-
 39601 00007FB2 7468616E207369676E-
 39601 00007FBB 290D0A             
 39602                                  MSG_1566:
 39603 00007FBE 2C                      	db 44
 39604 00007FBF 2020244C2020203C20-     	db '  $L   < (less-than sign)',0Dh,0Ah
 39604 00007FC8 286C6573732D746861-
 39604 00007FD1 6E207369676E290D0A 
 39605 00007FDA 202024422020207C20-     	db '  $B   | (pipe)',0Dh,0Ah
 39605 00007FE3 2870697065290D0A   
 39606                                  MSG_1567:
 39607 00007FEB 79                      	db 121
 39608 00007FEC 202024482020204261-     	db '  $H   Backspace (erases previous character)',0Dh,0Ah
 39608 00007FF5 636B73706163652028-
 39608 00007FFE 657261736573207072-
 39608 00008007 6576696F7573206368-
 39608 00008010 61726163746572290D-
 39608 00008019 0A                 
 39609 0000801A 202024452020204573-     	db '  $E   Escape code (ASCII code 27)',0Dh,0Ah
 39609 00008023 6361706520636F6465-
 39609 0000802C 202841534349492063-
 39609 00008035 6F6465203237290D0A 
 39610 0000803E 2020245F2020204361-     	db '  $_   Carriage return and linefeed',0Dh,0Ah
 39610 00008047 727269616765207265-
 39610 00008050 7475726E20616E6420-
 39610 00008059 6C696E65666565640D-
 39610 00008062 0A                 
 39611 00008063 0D0A                    	db 0Dh,0Ah
 39612                                  MSG_1568:
 39613 00008065 4C                      	db 76
 39614 00008066 547970652050524F4D-     	db 'Type PROMPT without parameters to reset the prompt to the default setting.',0Dh,0Ah
 39614 0000806F 505420776974686F75-
 39614 00008078 7420706172616D6574-
 39614 00008081 65727320746F207265-
 39614 0000808A 736574207468652070-
 39614 00008093 726F6D707420746F20-
 39614 0000809C 746865206465666175-
 39614 000080A5 6C742073657474696E-
 39614 000080AE 672E0D0A           
 39615                                  MSG_1580:
 39616 000080B2 47                      	db 71
 39617 000080B3 52656D6F7665732028-     	db 'Removes (deletes) a directory.',0Dh,0Ah
 39617 000080BC 64656C657465732920-
 39617 000080C5 61206469726563746F-
 39617 000080CE 72792E0D0A         
 39618 000080D3 0D0A                    	db 0Dh,0Ah
 39619 000080D5 524D444952205B6472-     	db 'RMDIR [drive:]path',0Dh,0Ah
 39619 000080DE 6976653A5D70617468-
 39619 000080E7 0D0A               
 39620 000080E9 5244205B6472697665-     	db 'RD [drive:]path',0Dh,0Ah
 39620 000080F2 3A5D706174680D0A   
 39621                                  MSG_1600:
 39622 000080FA 1C                      	db 28
 39623 000080FB 52656E616D65732061-     	db 'Renames a file or files.',0Dh,0Ah
 39623 00008104 2066696C65206F7220-
 39623 0000810D 66696C65732E0D0A   
 39624 00008115 0D0A                    	db 0Dh,0Ah
 39625                                  MSG_1601:
 39626 00008117 53                      	db 83
 39627 00008118 52454E414D45205B64-     	db 'RENAME [drive:][path]filename1 filename2',0Dh,0Ah
 39627 00008121 726976653A5D5B7061-
 39627 0000812A 74685D66696C656E61-
 39627 00008133 6D65312066696C656E-
 39627 0000813C 616D65320D0A       
 39628 00008142 52454E205B64726976-     	db 'REN [drive:][path]filename1 filename2',0Dh,0Ah
 39628 0000814B 653A5D5B706174685D-
 39628 00008154 66696C656E616D6531-
 39628 0000815D 2066696C656E616D65-
 39628 00008166 320D0A             
 39629 00008169 0D0A                    	db 0Dh,0Ah
 39630                                  MSG_1602:
 39631                                  	;db 77
 39632                                  	;db 'Note that you cannot specify a new drive or path for your destination file.',0Dh,0Ah
 39633                                  
 39634                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39635                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:8697h
 39636                                  MSG_1602:
 39637 0000816B A0                      	db 160
 39638 0000816C 4E6F74652074686174-     	db 'Note that you cannot specify a new drive or path for your destination file.',0Dh,0Ah
 39638 00008175 20796F752063616E6E-
 39638 0000817E 6F7420737065636966-
 39638 00008187 792061206E65772064-
 39638 00008190 72697665206F722070-
 39638 00008199 61746820666F722079-
 39638 000081A2 6F7572206465737469-
 39638 000081AB 6E6174696F6E206669-
 39638 000081B4 6C652E0D0A         
 39639 000081B9 0D0A                    	db 0Dh,0Ah
 39640 000081BB 557365204D4F564520-     	db 'Use MOVE to rename a directory, or to move files from one directory to another.',0Dh,0Ah
 39640 000081C4 746F2072656E616D65-
 39640 000081CD 206120646972656374-
 39640 000081D6 6F72792C206F722074-
 39640 000081DF 6F206D6F7665206669-
 39640 000081E8 6C65732066726F6D20-
 39640 000081F1 6F6E65206469726563-
 39640 000081FA 746F727920746F2061-
 39640 00008203 6E6F746865722E0D0A 
 39641                                  MSG_1620:
 39642 0000820C 57                      	db 87
 39643 0000820D 446973706C6179732C-     	db 'Displays, sets, or removes MS-DOS environment variables.',0Dh,0Ah
 39643 00008216 20736574732C206F72-
 39643 0000821F 2072656D6F76657320-
 39643 00008228 4D532D444F5320656E-
 39643 00008231 7669726F6E6D656E74-
 39643 0000823A 207661726961626C65-
 39643 00008243 732E0D0A           
 39644 00008247 0D0A                    	db 0Dh,0Ah
 39645 00008249 534554205B76617269-     	db 'SET [variable=[string]]',0Dh,0Ah
 39645 00008252 61626C653D5B737472-
 39645 0000825B 696E675D5D0D0A     
 39646 00008262 0D0A                    	db 0Dh,0Ah
 39647                                  MSG_1621:
 39648 00008264 81                      	db 129
 39649 00008265 20207661726961626C-     	db '  variable  Specifies the environment-variable name.',0Dh,0Ah
 39649 0000826E 652020537065636966-
 39649 00008277 696573207468652065-
 39649 00008280 6E7669726F6E6D656E-
 39649 00008289 742D7661726961626C-
 39649 00008292 65206E616D652E0D0A 
 39650 0000829B 2020737472696E6720-     	db '  string    Specifies a series of characters to assign to the variable.',0Dh,0Ah
 39650 000082A4 202020537065636966-
 39650 000082AD 696573206120736572-
 39650 000082B6 696573206F66206368-
 39650 000082BF 617261637465727320-
 39650 000082C8 746F2061737369676E-
 39650 000082D1 20746F207468652076-
 39650 000082DA 61726961626C652E0D-
 39650 000082E3 0A                 
 39651 000082E4 0D0A                    	db 0Dh,0Ah
 39652                                  MSG_1622:
 39653 000082E6 4B                      	db 75
 39654 000082E7 547970652053455420-     	db 'Type SET without parameters to display the current environment variables.',0Dh,0Ah
 39654 000082F0 776974686F75742070-
 39654 000082F9 6172616D6574657273-
 39654 00008302 20746F20646973706C-
 39654 0000830B 617920746865206375-
 39654 00008314 7272656E7420656E76-
 39654 0000831D 69726F6E6D656E7420-
 39654 00008326 7661726961626C6573-
 39654 0000832F 2E0D0A             
 39655                                  MSG_1640:
 39656                                  	;db 52
 39657                                  	;db 'Displays or sets the system time.',0Dh,0Ah
 39658                                  	;db 0Dh,0Ah
 39659                                  	;db 'TIME [time]',0Dh,0Ah
 39660                                  	;db 0Dh,0Ah
 39661                                  
 39662                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39663                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:885Eh)
 39664 00008332 2D                      	db 45
 39665 00008333 446973706C61797320-     	db 'Displays or sets the time.',0Dh,0Ah
 39665 0000833C 6F7220736574732074-
 39665 00008345 68652074696D652E0D-
 39665 0000834E 0A                 
 39666 0000834F 0D0A                    	db 0Dh,0Ah
 39667 00008351 54494D45205B74696D-     	db 'TIME [time]',0Dh,0Ah
 39667 0000835A 655D0D0A           
 39668 0000835E 0D0A                    	db 0Dh,0Ah
 39669                                  MSG_1641:
 39670 00008360 83                      	db 131
 39671 00008361 547970652054494D45-     	db 'Type TIME with no parameters to display the current time setting and a prompt',0Dh,0Ah
 39671 0000836A 2077697468206E6F20-
 39671 00008373 706172616D65746572-
 39671 0000837C 7320746F2064697370-
 39671 00008385 6C6179207468652063-
 39671 0000838E 757272656E74207469-
 39671 00008397 6D652073657474696E-
 39671 000083A0 6720616E6420612070-
 39671 000083A9 726F6D70740D0A     
 39672 000083B0 666F722061206E6577-     	db 'for a new one.  Press ENTER to keep the same time.',0Dh,0Ah
 39672 000083B9 206F6E652E20205072-
 39672 000083C2 65737320454E544552-
 39672 000083CB 20746F206B65657020-
 39672 000083D4 7468652073616D6520-
 39672 000083DD 74696D652E0D0A     
 39673                                  MSG_1660:
 39674 000083E4 46                      	db 70
 39675 000083E5 446973706C61797320-     	db 'Displays the contents of a text file.',0Dh,0Ah
 39675 000083EE 74686520636F6E7465-
 39675 000083F7 6E7473206F66206120-
 39675 00008400 746578742066696C65-
 39675 00008409 2E0D0A             
 39676 0000840C 0D0A                    	db 0Dh,0Ah
 39677 0000840E 54595045205B647269-     	db 'TYPE [drive:][path]filename',0Dh,0Ah
 39677 00008417 76653A5D5B70617468-
 39677 00008420 5D66696C656E616D65-
 39677 00008429 0D0A               
 39678                                  MSG_1680:
 39679 0000842B 25                      	db 37
 39680 0000842C 446973706C61797320-     	db 'Displays the MS-DOS version.',0Dh,0Ah
 39680 00008435 746865204D532D444F-
 39680 0000843E 532076657273696F6E-
 39680 00008447 2E0D0A             
 39681 0000844A 0D0A                    	db 0Dh,0Ah
 39682 0000844C 5645520D0A              	db 'VER',0Dh,0Ah
 39683                                  MSG_1700:
 39684 00008451 B1                      	db 177
 39685 00008452 54656C6C73204D532D-     	db 'Tells MS-DOS whether to verify that your files are written correctly to a',0Dh,0Ah
 39685 0000845B 444F53207768657468-
 39685 00008464 657220746F20766572-
 39685 0000846D 696679207468617420-
 39685 00008476 796F75722066696C65-
 39685 0000847F 732061726520777269-
 39685 00008488 7474656E20636F7272-
 39685 00008491 6563746C7920746F20-
 39685 0000849A 610D0A             
 39686 0000849D 6469736B2E0D0A          	db 'disk.',0Dh,0Ah
 39687 000084A4 0D0A                    	db 0Dh,0Ah
 39688 000084A6 564552494659205B4F-     	db 'VERIFY [ON | OFF]',0Dh,0Ah
 39688 000084AF 4E207C204F46465D0D-
 39688 000084B8 0A                 
 39689 000084B9 0D0A                    	db 0Dh,0Ah
 39690 000084BB 547970652056455249-     	db 'Type VERIFY without a parameter to display the current VERIFY setting.',0Dh,0Ah
 39690 000084C4 465920776974686F75-
 39690 000084CD 74206120706172616D-
 39690 000084D6 6574657220746F2064-
 39690 000084DF 6973706C6179207468-
 39690 000084E8 652063757272656E74-
 39690 000084F1 205645524946592073-
 39690 000084FA 657474696E672E0D0A 
 39691                                  MSG_1720:              
 39692 00008503 52                      	db 82
 39693 00008504 446973706C61797320-     	db 'Displays the disk volume label and serial number, if they exist.',0Dh,0Ah
 39693 0000850D 746865206469736B20-
 39693 00008516 766F6C756D65206C61-
 39693 0000851F 62656C20616E642073-
 39693 00008528 657269616C206E756D-
 39693 00008531 6265722C2069662074-
 39693 0000853A 686579206578697374-
 39693 00008543 2E0D0A             
 39694 00008546 0D0A                    	db 0Dh,0Ah
 39695 00008548 564F4C205B64726976-     	db 'VOL [drive:]',0Dh,0Ah
 39695 00008551 653A5D0D0A         
 39696                                  MSG_1740:
 39697 00008556 5B                      	db 91
 39698 00008557 43616C6C73206F6E65-     	db 'Calls one batch program from another.',0Dh,0Ah
 39698 00008560 206261746368207072-
 39698 00008569 6F6772616D2066726F-
 39698 00008572 6D20616E6F74686572-
 39698 0000857B 2E0D0A             
 39699 0000857E 0D0A                    	db 0Dh,0Ah
 39700 00008580 43414C4C205B647269-     	db 'CALL [drive:][path]filename [batch-parameters]',0Dh,0Ah
 39700 00008589 76653A5D5B70617468-
 39700 00008592 5D66696C656E616D65-
 39700 0000859B 205B62617463682D70-
 39700 000085A4 6172616D6574657273-
 39700 000085AD 5D0D0A             
 39701 000085B0 0D0A                    	db 0Dh,0Ah
 39702                                  MSG_1741:
 39703 000085B2 72                      	db 114
 39704 000085B3 202062617463682D70-     	db '  batch-parameters   Specifies any command-line information required by the',0Dh,0Ah
 39704 000085BC 6172616D6574657273-
 39704 000085C5 202020537065636966-
 39704 000085CE 69657320616E792063-
 39704 000085D7 6F6D6D616E642D6C69-
 39704 000085E0 6E6520696E666F726D-
 39704 000085E9 6174696F6E20726571-
 39704 000085F2 756972656420627920-
 39704 000085FB 7468650D0A         
 39705 00008600 202020202020202020-     	db '                     batch program.',0Dh,0Ah
 39705 00008609 202020202020202020-
 39705 00008612 202020626174636820-
 39705 0000861B 70726F6772616D2E0D-
 39705 00008624 0A                 
 39706                                  MSG_1760:	
 39707 00008625 4C                      	db 76
 39708 00008626 5265636F7264732063-     	db 'Records comments (remarks) in a batch file or CONFIG.SYS.',0Dh,0Ah
 39708 0000862F 6F6D6D656E74732028-
 39708 00008638 72656D61726B732920-
 39708 00008641 696E20612062617463-
 39708 0000864A 682066696C65206F72-
 39708 00008653 20434F4E4649472E53-
 39708 0000865C 59532E0D0A         
 39709 00008661 0D0A                    	db 0Dh,0Ah
 39710 00008663 52454D205B636F6D6D-     	db 'REM [comment]',0Dh,0Ah
 39710 0000866C 656E745D0D0A       
 39711                                  MSG_1780:
 39712 00008672 6B                      	db 107
 39713 00008673 53757370656E647320-     	db 'Suspends processing of a batch program and displays the message "'
 39713 0000867C 70726F63657373696E-
 39713 00008685 67206F662061206261-
 39713 0000868E 7463682070726F6772-
 39713 00008697 616D20616E64206469-
 39713 000086A0 73706C617973207468-
 39713 000086A9 65206D657373616765-
 39713 000086B2 2022               
 39714 000086B4 507265737320616E79-     	db 'Press any',0Dh,0Ah
 39714 000086BD 0D0A               
 39715 000086BF 6B657920746F20636F-     	db 'key to continue...."',0Dh,0Ah
 39715 000086C8 6E74696E75652E2E2E-
 39715 000086D1 2E220D0A           
 39716 000086D5 0D0A                    	db 0Dh,0Ah
 39717 000086D7 50415553450D0A          	db 'PAUSE',0Dh,0Ah
 39718                                  MSG_1800:
 39719 000086DE 4D                      	db 77
 39720 000086DF 446973706C61797320-     	db 'Displays messages, or turns command-echoing on or off.',0Dh,0Ah
 39720 000086E8 6D657373616765732C-
 39720 000086F1 206F72207475726E73-
 39720 000086FA 20636F6D6D616E642D-
 39720 00008703 6563686F696E67206F-
 39720 0000870C 6E206F72206F66662E-
 39720 00008715 0D0A               
 39721 00008717 0D0A                    	db 0Dh,0Ah
 39722 00008719 20204543484F205B4F-     	db '  ECHO [ON | OFF]',0Dh,0Ah
 39722 00008722 4E207C204F46465D0D-
 39722 0000872B 0A                 
 39723                                  MSG_1801:
 39724 0000872C 57                      	db 87
 39725 0000872D 20204543484F205B6D-     	db '  ECHO [message]',0Dh,0Ah
 39725 00008736 6573736167655D0D0A 
 39726 0000873F 0D0A                    	db 0Dh,0Ah
 39727 00008741 54797065204543484F-     	db 'Type ECHO without parameters to display the current echo setting.'
 39727 0000874A 20776974686F757420-
 39727 00008753 706172616D65746572-
 39727 0000875C 7320746F2064697370-
 39727 00008765 6C6179207468652063-
 39727 0000876E 757272656E74206563-
 39727 00008777 686F2073657474696E-
 39727 00008780 672E               
 39728 00008782 0D0A                    	db 0Dh,0Ah
 39729                                  MSG_1820:
 39730 00008784 47                      	db 71
 39731 00008785 44697265637473204D-     	db 'Directs MS-DOS to a labelled line in a batch program.',0Dh,0Ah
 39731 0000878E 532D444F5320746F20-
 39731 00008797 61206C6162656C6C65-
 39731 000087A0 64206C696E6520696E-
 39731 000087A9 206120626174636820-
 39731 000087B2 70726F6772616D2E0D-
 39731 000087BB 0A                 
 39732 000087BC 0D0A                    	db 0Dh,0Ah
 39733 000087BE 474F544F206C616265-     	db 'GOTO label',0Dh,0Ah
 39733 000087C7 6C0D0A             
 39734 000087CA 0D0A                    	db 0Dh,0Ah
 39735                                  MSG_1821:
 39736 000087CC 8A                      	db 138
 39737 000087CD 20206C6162656C2020-     	db '  label   Specifies a text string used in the batch program as a label.',0Dh,0Ah
 39737 000087D6 205370656369666965-
 39737 000087DF 732061207465787420-
 39737 000087E8 737472696E67207573-
 39737 000087F1 656420696E20746865-
 39737 000087FA 206261746368207072-
 39737 00008803 6F6772616D20617320-
 39737 0000880C 61206C6162656C2E0D-
 39737 00008815 0A                 
 39738 00008816 0D0A                    	db 0Dh,0Ah
 39739 00008818 596F75207479706520-     	db 'You type a label on a line by itself, beginning with a colon.',0Dh,0Ah
 39739 00008821 61206C6162656C206F-
 39739 0000882A 6E2061206C696E6520-
 39739 00008833 627920697473656C66-
 39739 0000883C 2C20626567696E6E69-
 39739 00008845 6E6720776974682061-
 39739 0000884E 20636F6C6F6E2E0D0A 
 39740                                  MSG_1840:
 39741 00008857 4A                      	db 74
 39742 00008858 4368616E6765732074-     	db 'Changes the position of replaceable parameters in a batch file.',0Dh,0Ah
 39742 00008861 686520706F73697469-
 39742 0000886A 6F6E206F6620726570-
 39742 00008873 6C61636561626C6520-
 39742 0000887C 706172616D65746572-
 39742 00008885 7320696E2061206261-
 39742 0000888E 7463682066696C652E-
 39742 00008897 0D0A               
 39743 00008899 0D0A                    	db 0Dh,0Ah
 39744 0000889B 53484946540D0A          	db 'SHIFT',0Dh,0Ah
 39745                                  MSG_1860:
 39746 000088A2 5A                      	db 90
 39747 000088A3 506572666F726D7320-     	db 'Performs conditional processing in batch programs.',0Dh,0Ah
 39747 000088AC 636F6E646974696F6E-
 39747 000088B5 616C2070726F636573-
 39747 000088BE 73696E6720696E2062-
 39747 000088C7 617463682070726F67-
 39747 000088D0 72616D732E0D0A     
 39748 000088D7 0D0A                    	db 0Dh,0Ah
 39749 000088D9 4946205B4E4F545D20-     	db 'IF [NOT] ERRORLEVEL number command',0Dh,0Ah
 39749 000088E2 4552524F524C455645-
 39749 000088EB 4C206E756D62657220-
 39749 000088F4 636F6D6D616E640D0A 
 39750                                  MSG_1861:
 39751 000088FD 46                      	db 70
 39752 000088FE 4946205B4E4F545D20-     	db 'IF [NOT] string1==string2 command',0Dh,0Ah
 39752 00008907 737472696E67313D3D-
 39752 00008910 737472696E67322063-
 39752 00008919 6F6D6D616E640D0A   
 39753 00008921 4946205B4E4F545D20-     	db 'IF [NOT] EXIST filename command',0Dh,0Ah
 39753 0000892A 45584953542066696C-
 39753 00008933 656E616D6520636F6D-
 39753 0000893C 6D616E640D0A       
 39754 00008942 0D0A                    	db 0Dh,0Ah
 39755                                  MSG_1862:
 39756 00008944 7D                      	db 125
 39757 00008945 20204E4F5420202020-     	db '  NOT               Specifies that MS-DOS should carry out the command only',0Dh,0Ah
 39757 0000894E 202020202020202020-
 39757 00008957 202053706563696669-
 39757 00008960 65732074686174204D-
 39757 00008969 532D444F532073686F-
 39757 00008972 756C64206361727279-
 39757 0000897B 206F75742074686520-
 39757 00008984 636F6D6D616E64206F-
 39757 0000898D 6E6C790D0A         
 39758 00008992 202020202020202020-     	db '                    if the condition is false.',0Dh,0Ah
 39758 0000899B 202020202020202020-
 39758 000089A4 202069662074686520-
 39758 000089AD 636F6E646974696F6E-
 39758 000089B6 2069732066616C7365-
 39758 000089BF 2E0D0A             
 39759                                  MSG_1863:
 39760 000089C2 A2                      	db 162
 39761 000089C3 20204552524F524C45-     	db '  ERRORLEVEL number Specifies a true condition if the last program run returned',0Dh,0Ah
 39761 000089CC 56454C206E756D6265-
 39761 000089D5 722053706563696669-
 39761 000089DE 657320612074727565-
 39761 000089E7 20636F6E646974696F-
 39761 000089F0 6E2069662074686520-
 39761 000089F9 6C6173742070726F67-
 39761 00008A02 72616D2072756E2072-
 39761 00008A0B 657475726E65640D0A 
 39762 00008A14 202020202020202020-     	db '                    '
 39762 00008A1D 202020202020202020-
 39762 00008A26 2020               
 39763 00008A28 616E20657869742063-     	db 'an exit code equal to or greater than the number specified.',0Dh,0Ah
 39763 00008A31 6F646520657175616C-
 39763 00008A3A 20746F206F72206772-
 39763 00008A43 656174657220746861-
 39763 00008A4C 6E20746865206E756D-
 39763 00008A55 626572207370656369-
 39763 00008A5E 666965642E0D0A     
 39764                                  MSG_1864:
 39765 00008A65 66                      	db 102
 39766 00008A66 2020636F6D6D616E64-     	db '  command           Specifies the command to carry out if the condition is',0Dh,0Ah
 39766 00008A6F 202020202020202020-
 39766 00008A78 202053706563696669-
 39766 00008A81 65732074686520636F-
 39766 00008A8A 6D6D616E6420746F20-
 39766 00008A93 6361727279206F7574-
 39766 00008A9C 206966207468652063-
 39766 00008AA5 6F6E646974696F6E20-
 39766 00008AAE 69730D0A           
 39767 00008AB2 202020202020202020-     	db '                    met.',0Dh,0Ah
 39767 00008ABB 202020202020202020-
 39767 00008AC4 20206D65742E0D0A   
 39768                                  MSG_1865:
 39769 00008ACC 6A                      	db 106
 39770 00008ACD 2020737472696E6731-     	db '  string1==string2  Specifies a true condition if the specified text strings',0Dh,0Ah
 39770 00008AD6 3D3D737472696E6732-
 39770 00008ADF 202053706563696669-
 39770 00008AE8 657320612074727565-
 39770 00008AF1 20636F6E646974696F-
 39770 00008AFA 6E2069662074686520-
 39770 00008B03 737065636966696564-
 39770 00008B0C 207465787420737472-
 39770 00008B15 696E67730D0A       
 39771 00008B1B 202020202020202020-     	db '                    match.',0Dh,0Ah
 39771 00008B24 202020202020202020-
 39771 00008B2D 20206D617463682E0D-
 39771 00008B36 0A                 
 39772                                  MSG_1866:
 39773 00008B37 67                      	db 103
 39774 00008B38 202045584953542066-     	db '  EXIST filename    Specifies a true condition if the specified filename',0Dh,0Ah
 39774 00008B41 696C656E616D652020-
 39774 00008B4A 202053706563696669-
 39774 00008B53 657320612074727565-
 39774 00008B5C 20636F6E646974696F-
 39774 00008B65 6E2069662074686520-
 39774 00008B6E 737065636966696564-
 39774 00008B77 2066696C656E616D65-
 39774 00008B80 0D0A               
 39775 00008B82 202020202020202020-     	db '                    exists.',0Dh,0Ah
 39775 00008B8B 202020202020202020-
 39775 00008B94 20206578697374732E-
 39775 00008B9D 0D0A               
 39776                                  MSG_1880:
 39777 00008B9F 77                      	db 119
 39778 00008BA0 52756E732061207370-     	db 'Runs a specified command for each file in a set of files.',0Dh,0Ah
 39778 00008BA9 656369666965642063-
 39778 00008BB2 6F6D6D616E6420666F-
 39778 00008BBB 722065616368206669-
 39778 00008BC4 6C6520696E20612073-
 39778 00008BCD 6574206F662066696C-
 39778 00008BD6 65732E0D0A         
 39779 00008BDB 0D0A                    	db 0Dh,0Ah
 39780 00008BDD 464F52202576617269-     	db 'FOR %variable IN (set) DO command [command-parameters]',0Dh,0Ah
 39780 00008BE6 61626C6520494E2028-
 39780 00008BEF 7365742920444F2063-
 39780 00008BF8 6F6D6D616E64205B63-
 39780 00008C01 6F6D6D616E642D7061-
 39780 00008C0A 72616D65746572735D-
 39780 00008C13 0D0A               
 39781 00008C15 0D0A                    	db 0Dh,0Ah
 39782                                  MSG_1881:
 39783 00008C17 7D                      	db 125
 39784 00008C18 202025766172696162-     	db '  %variable  Specifies a replaceable parameter.',0Dh,0Ah
 39784 00008C21 6C6520205370656369-
 39784 00008C2A 666965732061207265-
 39784 00008C33 706C61636561626C65-
 39784 00008C3C 20706172616D657465-
 39784 00008C45 722E0D0A           
 39785 00008C49 202028736574292020-     	db '  (set)      Specifies a set of one or more files.  Wildcards may be used.',0Dh,0Ah
 39785 00008C52 202020205370656369-
 39785 00008C5B 666965732061207365-
 39785 00008C64 74206F66206F6E6520-
 39785 00008C6D 6F72206D6F72652066-
 39785 00008C76 696C65732E20205769-
 39785 00008C7F 6C646361726473206D-
 39785 00008C88 617920626520757365-
 39785 00008C91 642E0D0A           
 39786                                  MSG_1882:
 39787 00008C95 56                      	db 86
 39788 00008C96 2020636F6D6D616E64-     	db '  command    Specifies the command to carry out for each file.',0Dh,0Ah
 39788 00008C9F 202020205370656369-
 39788 00008CA8 666965732074686520-
 39788 00008CB1 636F6D6D616E642074-
 39788 00008CBA 6F206361727279206F-
 39788 00008CC3 757420666F72206561-
 39788 00008CCC 63682066696C652E0D-
 39788 00008CD5 0A                 
 39789 00008CD6 2020636F6D6D616E64-     	db '  command-parameters',0Dh,0Ah
 39789 00008CDF 2D706172616D657465-
 39789 00008CE8 72730D0A           
 39790                                  MSG_1883:
 39791 00008CEC A2                      	db 162
 39792 00008CED 202020202020202020-     	db '             Specifies parameters or switches for the specified command.',0Dh,0Ah
 39792 00008CF6 202020205370656369-
 39792 00008CFF 666965732070617261-
 39792 00008D08 6D6574657273206F72-
 39792 00008D11 207377697463686573-
 39792 00008D1A 20666F722074686520-
 39792 00008D23 737065636966696564-
 39792 00008D2C 20636F6D6D616E642E-
 39792 00008D35 0D0A               
 39793 00008D37 0D0A                    	db 0Dh,0Ah
 39794 00008D39 546F20757365207468-     	db 'To use the FOR command in a batch program, specify %%variable instead of',0Dh,0Ah
 39794 00008D42 6520464F5220636F6D-
 39794 00008D4B 6D616E6420696E2061-
 39794 00008D54 206261746368207072-
 39794 00008D5D 6F6772616D2C207370-
 39794 00008D66 656369667920252576-
 39794 00008D6F 61726961626C652069-
 39794 00008D78 6E7374656164206F66-
 39794 00008D81 0D0A               
 39795 00008D83 257661726961626C65-     	db '%variable.',0Dh,0Ah
 39795 00008D8C 2E0D0A             
 39796                                  MSG_1900:
 39797 00008D8F 17                      	db 23
 39798 00008D90 526573657276656420-     	db 'Reserved command name',0Dh,0Ah
 39798 00008D99 636F6D6D616E64206E-
 39798 00008DA2 616D650D0A         
 39799                                  MSG_1920:
 39800 00008DA7 2F                      	db 47
 39801 00008DA8 4C6F61647320612070-     	db 'Loads a program into the upper memory area.',0Dh,0Ah
 39801 00008DB1 726F6772616D20696E-
 39801 00008DBA 746F20746865207570-
 39801 00008DC3 706572206D656D6F72-
 39801 00008DCC 7920617265612E0D0A 
 39802 00008DD5 0D0A                    	db 0Dh,0Ah
 39803                                  MSG_1921:
 39804                                  	;db 88
 39805                                  	;db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
 39806                                  	;db 'LH [drive:][path]filename [parameters]',0Dh,0Ah
 39807                                  	;db 0Dh,0Ah
 39808                                  
 39809                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39810                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9303h
 39811 00008DD7 9D                      	db 157
 39812 00008DD8 4C4F41444849474820-     	db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
 39812 00008DE1 5B64726976653A5D5B-
 39812 00008DEA 706174685D66696C65-
 39812 00008DF3 6E616D65205B706172-
 39812 00008DFC 616D65746572735D0D-
 39812 00008E05 0A                 
 39813 00008E06 4C4F41444849474820-     	db 'LOADHIGH [/L:region1[,minsize1][;region2[,minsize2]...] [/S]]',0Dh,0Ah
 39813 00008E0F 5B2F4C3A726567696F-
 39813 00008E18 6E315B2C6D696E7369-
 39813 00008E21 7A65315D5B3B726567-
 39813 00008E2A 696F6E325B2C6D696E-
 39813 00008E33 73697A65325D2E2E2E-
 39813 00008E3C 5D205B2F535D5D0D0A 
 39814 00008E45 202020202020202020-     	db '         [drive:][path]filename [parameters]',0Dh,0Ah
 39814 00008E4E 5B64726976653A5D5B-
 39814 00008E57 706174685D66696C65-
 39814 00008E60 6E616D65205B706172-
 39814 00008E69 616D65746572735D0D-
 39814 00008E72 0A                 
 39815 00008E73 0D0A                    	db 0Dh,0Ah
 39816                                  	
 39817                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:8111h)
 39818                                  ;MSG_1922: 	; MSDOS 5.0 COMMAND.COM
 39819                                  	;db 113
 39820                                  	;db '  parameters   Specifies any command-line information required by the',0Dh,0Ah
 39821                                  	;db '               program you want to load.',0Dh,0Ah
 39822                                  
 39823                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39824                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:93A1h
 39825                                  MSG_1922:
 39826 00008E75 B6                      	db 182
 39827 00008E76 2F4C3A726567696F6E-     	db '/L:region1[,minsize1][;region2[,minsize2]]...',0Dh,0Ah
 39827 00008E7F 315B2C6D696E73697A-
 39827 00008E88 65315D5B3B72656769-
 39827 00008E91 6F6E325B2C6D696E73-
 39827 00008E9A 697A65325D5D2E2E2E-
 39827 00008EA3 0D0A               
 39828 00008EA5 202020202020202020-     	db '            Specifies the region(s) of memory into which to load',0Dh,0Ah
 39828 00008EAE 202020537065636966-
 39828 00008EB7 696573207468652072-
 39828 00008EC0 6567696F6E28732920-
 39828 00008EC9 6F66206D656D6F7279-
 39828 00008ED2 20696E746F20776869-
 39828 00008EDB 636820746F206C6F61-
 39828 00008EE4 640D0A             
 39829 00008EE7 202020202020202020-     	db '            the program.  Region1 specifies the number of the first',0Dh,0Ah
 39829 00008EF0 202020746865207072-
 39829 00008EF9 6F6772616D2E202052-
 39829 00008F02 6567696F6E31207370-
 39829 00008F0B 656369666965732074-
 39829 00008F14 6865206E756D626572-
 39829 00008F1D 206F66207468652066-
 39829 00008F26 697273740D0A       
 39830                                  MSG_1923:
 39831 00008F2C 85                      	db 133
 39832 00008F2D 202020202020202020-     	db '            memory region; minsize1 specifies the minimum size, if',0Dh,0Ah
 39832 00008F36 2020206D656D6F7279-
 39832 00008F3F 20726567696F6E3B20-
 39832 00008F48 6D696E73697A653120-
 39832 00008F51 737065636966696573-
 39832 00008F5A 20746865206D696E69-
 39832 00008F63 6D756D2073697A652C-
 39832 00008F6C 2069660D0A         
 39833 00008F71 202020202020202020-     	db '            any, for region1.  Region2 and minsize2 specify the',0Dh
 39833 00008F7A 202020616E792C2066-
 39833 00008F83 6F7220726567696F6E-
 39833 00008F8C 312E2020526567696F-
 39833 00008F95 6E3220616E64206D69-
 39833 00008F9E 6E73697A6532207370-
 39833 00008FA7 656369667920746865-
 39833 00008FB0 0D                 
 39834 00008FB1 0A                      	db 0Ah
 39835                                  MSG_1924:
 39836 00008FB2 7F                      	db 127
 39837 00008FB3 202020202020202020-     	db '            number and minimum size of the second region, if any.',0Dh,0Ah
 39837 00008FBC 2020206E756D626572-
 39837 00008FC5 20616E64206D696E69-
 39837 00008FCE 6D756D2073697A6520-
 39837 00008FD7 6F6620746865207365-
 39837 00008FE0 636F6E642072656769-
 39837 00008FE9 6F6E2C20696620616E-
 39837 00008FF2 792E0D0A           
 39838 00008FF6 202020202020202020-     	db '            You can specify as many regions as you want.',0Dh,0Ah
 39838 00008FFF 202020596F75206361-
 39838 00009008 6E2073706563696679-
 39838 00009011 206173206D616E7920-
 39838 0000901A 726567696F6E732061-
 39838 00009023 7320796F752077616E-
 39838 0000902C 742E0D0A           
 39839 00009030 0D0A                    	db 0Dh,0Ah
 39840                                  MSG_1925:
 39841 00009032 83                      	db 131
 39842 00009033 2F5320202020202020-     	db '/S          Shrinks a UMB to its minimum size while the program',0Dh,0Ah
 39842 0000903C 202020536872696E6B-
 39842 00009045 73206120554D422074-
 39842 0000904E 6F20697473206D696E-
 39842 00009057 696D756D2073697A65-
 39842 00009060 207768696C65207468-
 39842 00009069 652070726F6772616D-
 39842 00009072 0D0A               
 39843 00009074 202020202020202020-     	db '            is loading.  /S is normally used only by MemMaker.',0Dh,0Ah
 39843 0000907D 2020206973206C6F61-
 39843 00009086 64696E672E20202F53-
 39843 0000908F 206973206E6F726D61-
 39843 00009098 6C6C79207573656420-
 39843 000090A1 6F6E6C79206279204D-
 39843 000090AA 656D4D616B65722E0D-
 39843 000090B3 0A                 
 39844 000090B4 0D0A                    	db 0Dh,0Ah
 39845                                  MSG_1926:
 39846 000090B6 57                      	db 87
 39847 000090B7 5B64726976653A5D5B-     	db '[drive:][path]filename',0Dh,0Ah
 39847 000090C0 706174685D66696C65-
 39847 000090C9 6E616D650D0A       
 39848 000090CF 202020202020202020-     	db '            Specifies the location and name of the program.',0Dh,0Ah
 39848 000090D8 202020537065636966-
 39848 000090E1 69657320746865206C-
 39848 000090EA 6F636174696F6E2061-
 39848 000090F3 6E64206E616D65206F-
 39848 000090FC 66207468652070726F-
 39848 00009105 6772616D2E0D0A     
 39849 0000910C 0D0A                    	db 0Dh,0Ah
 39850                                  
 39851                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39852                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:963Ah
 39853                                  MSG_1927:
 39854 0000910E 5A                      	db 90
 39855 0000910F 706172616D65746572-     	db 'parameters  Specifies any command-line information required by',0Dh,0Ah
 39855 00009118 732020537065636966-
 39855 00009121 69657320616E792063-
 39855 0000912A 6F6D6D616E642D6C69-
 39855 00009133 6E6520696E666F726D-
 39855 0000913C 6174696F6E20726571-
 39855 00009145 75697265642062790D-
 39855 0000914E 0A                 
 39856 0000914F 202020202020202020-     	db '            the program.',0Dh,0Ah
 39856 00009158 202020746865207072-
 39856 00009161 6F6772616D2E0D0A   
 39857                                  
 39858                                  ; ---------------------------------------------------------------------------
 39859                                  
 39860                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39861                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8183h
 39862                                  
 39863                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39864                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9695h
 39865                                  
 39866                                  ; --------------- S U B R O U T I N E ---------------------------------------
 39867                                  
 39868                                  $M_CLS_3:
 39869 00009169 0E                      	push	cs		; CLASS_F
 39870 0000916A 07                      	pop	es
 39871 0000916B 8D3E[0464]              	lea	di,$M_CLASS_3_STRUC ; LEA DI,$M_CLASS_3_STRUC
 39872                                  	; 15/04/2023
 39873                                  	;add	cx,10053	; ADD CX,$-$M_CLASS_3_STRUC ; 8189h-5A44h
 39874                                  	; 17/06/2023
 39875 0000916F 81C16B2D                	add	cx,11627	; ADD CX,$-$M_CLASS_3_STRUC ; 969Bh-6930h
 39876 00009173 C3                      	retn
 39877                                  
 39878                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39879                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:818Eh
 39880                                  
 39881                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39882                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:96A0h
 39883                                  
 39884                                  ; ---------------------------------------------------------------------------
 39885                                  ; Class 1 messages
 39886                                  ; ---------------------------------------------------------------------------
 39887                                  	
 39888                                  $M_CLASS_1_STRUC:
 39889 00009174 01                      	db 1			; $M_CLASS_ID
 39890                                  	;dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 39891                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39892 00009175 0616                    	dw 1606h  ; MSDOS 6.22 COMMAND.COM
 39893 00009177 04                      	db 4			; Class_1_MessageCount
 39894                                  $M_ID_1_1:
 39895 00009178 0200                    	dw 2			; Message Number = 2
 39896 0000917A 1000                    	dw EXTEND2-$+2 ; 10h	; Message offset from message number
 39897                                  $M_ID_1_2:
 39898 0000917C 0300                    	dw 3			; Message Number = 3
 39899 0000917E 1B00                    	dw EXTEND3-$+2 ; 1Bh	; Message offset from message number
 39900                                  $M_ID_1_3:
 39901 00009180 0800                    	dw 8			; Message Number = 8
 39902 00009182 2600                    	dw EXTEND8-$+2 ; 26h	; Message offset from message number
 39903                                  $M_ID_1_4:
 39904 00009184 FFFF                    	dw 0FFFFh		; Message Number = -1
 39905 00009186 3600                    	dw EXTEND999-$+2 ; 36h	; Message offset from message number
 39906                                  
 39907                                  ; ---------------------------------------------------------------------------
 39908                                  
 39909                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81A2h
 39910                                  EXTEND2:
 39911 00009188 0E                      	db 14
 39912 00009189 46696C65206E6F7420-     	db 'File not found'
 39912 00009192 666F756E64         
 39913                                  EXTEND3:
 39914 00009197 0E                      	db 14
 39915 00009198 50617468206E6F7420-     	db 'Path not found'
 39915 000091A1 666F756E64         
 39916                                  EXTEND8:
 39917 000091A6 13                      	db 19
 39918 000091A7 496E73756666696369-     	db 'Insufficient memory'
 39918 000091B0 656E74206D656D6F72-
 39918 000091B9 79                 
 39919                                  EXTEND999:
 39920 000091BA 11                      	db 17
 39921 000091BB 457874656E64656420-     	db 'Extended Error %1'
 39921 000091C4 4572726F72202531   
 39922                                  
 39923                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39924                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81E6h
 39925                                  
 39926                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39927                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:96F8h
 39928                                  
 39929                                  ; --------------- S U B R O U T I N E ---------------------------------------
 39930                                  $M_MSGSERV_1:
 39931 000091CC 0E                      	push	cs
 39932 000091CD 07                      	pop	es
 39933 000091CE 8D3E[7491]              	lea	di,$M_CLASS_1_STRUC
 39934                                  	; 15/04/2023
 39935                                  	;add	cx,94		; $-$M_CLASS_1_STRUC ; 81ECh-818Eh
 39936                                  			; 17/06/2023 MSDOS 6.22 COMMAND.COM
 39937                                  				; 96FEh-96A0h = 5Eh = 94
 39938 000091D2 C3                      	retn
 39939                                  
 39940                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39941                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F0h
 39942                                  
 39943                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39944                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9702h
 39945                                  
 39946                                  ; ---------------------------------------------------------------------------
 39947                                  ; Class 2 messages
 39948                                  ; ---------------------------------------------------------------------------
 39949                                  	
 39950                                  $M_CLASS_2_STRUC:
 39951 000091D3 02                      	db 2			; $M_CLASS_ID
 39952                                  	;dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 39953                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39954 000091D4 0616                    	dw 1606h  ; MSDOS 6.22 COMMAND.COM
 39955 000091D6 01                      	db 1			; Class_2_MessageCount
 39956                                  $M_ID_2_1:
 39957 000091D7 FFFF                    	dw 0FFFFh		; Message Number = -1
 39958 000091D9 0400                    	dw PARSE999-$+2 ; 4	; Message offset from message number
 39959                                  ; ---------------------------------------------------------------------------
 39960                                  
 39961                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F8h
 39962                                  PARSE999:
 39963 000091DB 0E                      	db 14
 39964 000091DC 506172736520457272-     	db 'Parse Error %1'
 39964 000091E5 6F72202531         
 39965                                  
 39966                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39967                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8207h
 39968                                  
 39969                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39970                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9719h
 39971                                  
 39972                                  ; --------------- S U B R O U T I N E ---------------------------------------
 39973                                  $M_MSGSERV_2:
 39974 000091EA 0E                      	push	cs
 39975 000091EB 07                      	pop	es
 39976 000091EC 8D3E[D391]              	lea	di,$M_CLASS_2_STRUC
 39977                                  	; 15/04/2023
 39978                                  	;add	cx,29		; $-$M_CLASS_2_STRUC ; 820Dh-81F0h
 39979                                  			; 17/06/2023 MSDOS 6.22 COMMAND.COM
 39980                                  				; 971Fh-9702h = 1Dh = 29
 39981 000091F0 C3                      	retn
 39982                                  
 39983                                  ;============================================================================
 39984                                  ; TRANMSG.ASM, MSDOS 6.0, 1991
 39985                                  ;============================================================================
 39986                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39987                                  ; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39988                                  
 39989                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8211h
 39990                                  	
 39991                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9723h
 39992                                  
 39993                                  ;****************************************************
 39994                                  ;* TRANSIENT MESSAGE POINTERS & SUBSTITUTION BLOCKS *
 39995                                  ;****************************************************
 39996                                  
 39997                                  msg_disp_class:
 39998 000091F1 FF                      	db	util_msg_class ; 0FFh
 39999                                  msg_cont_flag:
 40000 000091F2 00                      	db	no_cont_flag ; 0
 40001                                  
 40002                                  ;  extended error string output
 40003                                  extend_buf_ptr:
 40004 000091F3 0000                    	dw	0			;AN000;set to no message
 40005                                  extend_buf_sub:
 40006 000091F5 00                      	db	0			;AN000;set to no substitutions
 40007 000091F6 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40008 000091F7 00                      	db	0			;AN000;reserved
 40009                                  extend_buf_off:
 40010 000091F8 [B7A0]                  	dw	string_ptr_2		;AN000;offset of arg
 40011                                  extend_buf_seg:
 40012 000091FA 0000                    	dw	0			;AN000;segment of arg
 40013 000091FC 00                      	db	0			;AN000;first subst
 40014 000091FD 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40015 000091FE 80                      	db	128			;AN000;maximum width
 40016 000091FF 00                      	db	0			;AN000;minimum width
 40017 00009200 20                      	db	blank ; 20h		;AN000;pad character
 40018                                  
 40019                                  ;  "Duplicate file name or file not found"
 40020                                  RENERR_PTR:
 40021 00009201 EA03                    	dw	1002			;AN000;message number
 40022 00009203 00                      	db	no_subst ; 0		;AN000;number of subst
 40023                                  
 40024                                  ;  "Invalid path or file name"
 40025                                  BADCPMES_PTR:
 40026 00009204 EB03                    	dw	1003			;AN000;message number
 40027 00009206 00                      	db	no_subst ; 0		;AN000;number of subst
 40028                                  
 40029                                  ;  "Insufficient disk space"
 40030                                  NOSPACE_PTR:
 40031 00009207 EC03                    	dw	1004			;AN000;message number
 40032 00009209 00                      	db	no_subst ; 0		;AN000;number of subst
 40033                                  
 40034                                  ;  "Out of environment space"
 40035                                  ENVERR_PTR:
 40036 0000920A EF03                    	dw	1007			;AN000;message number
 40037 0000920C 00                      	db	no_subst ; 0		;AN000;number of subst
 40038                                  
 40039                                  ;  "File creation error"
 40040                                  FULLDIR_PTR:
 40041 0000920D F003                    	dw	1008			;AN000;message number
 40042 0000920F 00                      	db	no_subst ; 0		;AN000;number of subst
 40043                                  
 40044                                  ;  "Batch file missing",13,10
 40045                                  BADBAT_PTR:
 40046 00009210 F103                    	dw	1009			;AN000;message number
 40047 00009212 00                      	db	no_subst ; 0		;AN000;number of subst
 40048                                  
 40049                                  ;  "Insert disk with batch file",13,10
 40050                                  NEEDBAT_PTR:
 40051 00009213 F203                    	dw	1010			;AN000;message number
 40052 00009215 00                      	db	no_subst ; 0		;AN000;number of subst
 40053                                  
 40054                                  ;  "Bad command or file name",13,10
 40055                                  BADNAM_PTR:
 40056 00009216 F303                    	dw	1011			;AN000;message number
 40057 00009218 00                      	db	no_subst ; 0		;AN000;number of subst
 40058                                  
 40059                                  ;  "Access denied",13,10
 40060                                  ACCDEN_PTR:
 40061 00009219 F603                    	dw	1014			;AN000;message number
 40062 0000921B 00                      	db	no_subst ; 0		;AN000;number of subst
 40063                                  
 40064                                  ;  "File cannot be copied onto itself",13,10
 40065                                  OVERWR_PTR:
 40066 0000921C F703                    	dw	1015			;AN000;message number
 40067 0000921E 00                      	db	no_subst ; 0		;AN000;number of subst
 40068                                  
 40069                                  ;  "Content of destination lost before copy",13,10
 40070                                  LOSTERR_PTR:
 40071 0000921F F803                    	dw	1016			;AN000;message number
 40072 00009221 00                      	db	no_subst ; 0		;AN000;number of subst
 40073                                  
 40074                                  ;  "Invalid filename or file not found",13,10
 40075                                  INORNOT_PTR:
 40076 00009222 F903                    	dw	1017			;AN000;message number
 40077 00009224 00                      	db	no_subst		;AN000;number of subst
 40078                                  
 40079                                  ;  "%1 File(s) copied",13,10
 40080                                  copied_ptr:
 40081 00009225 FA03                    	dw	1018			;AN000;message number
 40082 00009227 01                      	db	1			;AN000;number of subst
 40083 00009228 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40084 00009229 00                      	db	0			;AN000;reserved
 40085 0000922A [B9A0]                  	dw	Copy_num		;AN000;offset of arg
 40086 0000922C 0000                    	dw	0			;AN000;segment of arg
 40087 0000922E 01                      	db	1			;AN000;first subst
 40088 0000922F A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 40089                                  					;AN000;binary to decimal
 40090 00009230 09                      	db	9			;AN000;maximum width
 40091 00009231 09                      	db	9			;AN000;minimum width
 40092 00009232 20                      	db	blank ; 20h		;AN000;pad character
 40093                                  
 40094                                  ;  "%1 File(s) "
 40095                                  dirmes_ptr:
 40096 00009233 FB03                    	dw	1019			;AN000;message number
 40097 00009235 01                      	db	1			;AN000;number of subst
 40098 00009236 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40099 00009237 00                      	db	0			;AN000;reserved
 40100 00009238 [BCA0]                  	dw	Dir_Num			;AN000;offset of arg
 40101 0000923A 0000                    	dw	0			;AN000;segment of arg
 40102 0000923C 01                      	db	1			;AN000;first subst
 40103                                  	; MSDOS 5.0 COMMAND.COM
 40104                                  	;db	0A1h ; Right_Align+Unsgn_Bin_Word
 40105                                  	; 17/06/2023
 40106                                  screen_f_3:
 40107 0000923D E1                      	db	0E1h ; MSDOS 6.22 COMMAND.COM
 40108                                  					;AN000;binary to decimal
 40109 0000923E 09                      	db	9			;AN000;maximum width
 40110 0000923F 09                      	db	9			;AN000;minimum width
 40111 00009240 20                      	db	blank ; 20h		;AN000;pad character
 40112                                  
 40113                                  ;  "%1 bytes free",13,10
 40114                                  bytmes_ptr:
 40115 00009241 FC03                    	dw	1020			;AN000;message number
 40116 00009243 01                      	db	1			;AN000;number of subst
 40117 00009244 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40118 00009245 00                      	db	0			;AN000;reserved
 40119 00009246 [C0A0]                  	dw	Bytes_Free		;AN000;offset of arg
 40120 00009248 0000                    	dw	0			;AN000;segment of arg
 40121 0000924A 01                      	db	1			;AN000;first subst
 40122                                  	; MSDOS 5.0 COMMAND.COM
 40123                                  	;db	0B1h ; Right_Align+Unsgn_Bin_DWord
 40124                                  	; 17/06/2023
 40125                                  screen_f_6:
 40126 0000924B F1                      	db	0F1h
 40127                                  					;AN000;long binary to decimal
 40128                                  	; MSDOS 5.0 COMMAND.COM
 40129                                  	;db	28			;AN000;maximum width
 40130                                  	;db	28			;AN000;minimum width
 40131                                  	; 17/06/2023
 40132                                  screen_f_7:
 40133 0000924C 20                      	db	32 ; MSDOS 6.22 COMMAND.COM
 40134 0000924D 20                      	db	32
 40135                                  
 40136 0000924E 20                      	db	blank ; 20h		;AN000;pad character
 40137                                  
 40138                                  ;  "Invalid drive specification",13,10
 40139                                  baddrv_ptr:
 40140 0000924F FD03                    	dw	1021			;AN000;message number
 40141 00009251 00                      	db	no_subst ; 0		;AN000;number of subst
 40142                                  
 40143                                  ;  "Code page %1 not prepared for system",13,10
 40144                                  cp_not_set_ptr:
 40145 00009252 FE03                    	dw	1022			;AN000;message number
 40146 00009254 01                      	db	1			;AN000;number of subst
 40147 00009255 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40148 00009256 00                      	db	0			;AN000;reserved
 40149 00009257 [B1A0]                  	dw	system_cpage		;AN000;offset of arg
 40150 00009259 0000                    	dw	0			;AN000;segment of arg
 40151 0000925B 01                      	db	1			;AN000;first subst
 40152 0000925C A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 40153                                  					;AN000;binary to decimal
 40154 0000925D 05                      	db	5			;AN000;maximum width
 40155 0000925E 01                      	db	1			;AN000;minimum width
 40156 0000925F 20                      	db	blank ; 20h		;AN000;pad character
 40157                                  
 40158                                  ;  "Code page %1 not prepared for all devices",13,10
 40159                                  cp_not_all_ptr:
 40160 00009260 FF03                    	dw	1023			;AN000;message number
 40161 00009262 01                      	db	1			;AN000;number of subst
 40162 00009263 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 40163 00009264 00                      	db	0			;AN000;reserved
 40164 00009265 [B1A0]                  	dw	system_cpage		;AN000;offset of arg
 40165 00009267 0000                    	dw	0			;AN000;segment of arg
 40166 00009269 01                      	db	1			;AN000;first subst
 40167 0000926A A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 40168                                  					;AN000;binary to decimal
 40169 0000926B 05                      	db	5			;AN000;maximum width
 40170 0000926C 01                      	db	1			;AN000;minimum width
 40171 0000926D 20                      	db	blank ; 20h		;AN000;pad character
 40172                                  
 40173                                  ;  "Active code page: %1",13,10
 40174                                  cp_active_ptr:
 40175 0000926E 0004                    	dw	1024			;AN000;message number
 40176 00009270 01                      	db	1			;AN000;number of subst
 40177 00009271 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40178 00009272 00                      	db	0			;AN000;reserved
 40179 00009273 [B1A0]                  	dw	system_cpage		;AN000;offset of arg
 40180 00009275 0000                    	dw	0			;AN000;segment of arg
 40181 00009277 01                      	db	1			;AN000;first subst
 40182 00009278 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 40183                                  					;AN000;binary to decimal
 40184 00009279 05                      	db	5			;AN000;maximum width
 40185 0000927A 01                      	db	1			;AN000;minimum width
 40186 0000927B 20                      	db	blank ; 20h		;AN000;pad character
 40187                                  
 40188                                  ;  "NLSFUNC not installed",13,10
 40189                                  NLSFUNC_PTR:
 40190 0000927C 0104                    	dw	1025			;AN000;message number
 40191 0000927E 00                      	db	no_subst ; 0		;AN000;number of subst
 40192                                  
 40193                                  ;  "Invalid code page",13,10
 40194                                  INV_CODE_PAGE:
 40195 0000927F 0204                    	dw	1026			;AN000;message number
 40196 00009281 00                      	db	no_subst ; 0		;AN000;number of subst
 40197                                  
 40198                                  ;  "Current drive is no longer valid"
 40199                                  BADCURDRV:
 40200 00009282 0304                    	dw	1027			;AN000;message number
 40201 00009284 00                      	db	no_subst ; 0		;AN000;number of subst
 40202                                  
 40203                                  ;  "Press any key to continue"
 40204                                  PAUSEMES_PTR:
 40205 00009285 0404                    	dw	1028			;AN000;message number
 40206 00009287 00                      	db	no_subst ; 0		;AN000;number of subst
 40207                                  
 40208                                  ;  "Label not found",13,10
 40209                                  BADLAB_PTR:
 40210 00009288 0504                    	dw	1029			;AN000;message number
 40211 0000928A 00                      	db	no_subst ; 0		;AN000;number of subst
 40212                                  
 40213                                  ;  "Syntax error",13,10
 40214                                  SYNTMES_PTR:
 40215 0000928B 0604                    	dw	1030			;AN000;message number
 40216 0000928D 00                      	db	no_subst ; 0		;AN000;number of subst
 40217                                  
 40218                                  ;  "Invalid date",13,10
 40219                                  BADDAT_PTR:
 40220 0000928E 0704                    	dw	1031			;AN000;message number
 40221 00009290 00                      	db	no_subst ; 0		;AN000;number of subst
 40222                                  
 40223                                  ;  "Current date is %1 %2",13,10
 40224                                  CurDat_Ptr:
 40225 00009291 0804                    	dw	1032			;AN000;message number
 40226 00009293 02                      	db	2			;AN000;number of subst
 40227 00009294 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40228 00009295 00                      	db	0			;AN000;reserved
 40229 00009296 [ADA7]                  	dw	Arg_Buf			;AN000;offset of arg
 40230 00009298 0000                    	dw	0			;AN000;segment of arg
 40231 0000929A 01                      	db	1			;AN000;first subst
 40232 0000929B 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40233 0000929C 03                      	db	3			;AN000;maximum width
 40234 0000929D 03                      	db	3			;AN000;minimum width
 40235 0000929E 20                       	db	blank ; 20h		;AN000;pad character
 40236 0000929F 0B                      	db	parm_block_size 	;AN000;size of sublist
 40237 000092A0 00                      	db	0			;AN000;reserved
 40238                                  CurDat_yr:
 40239 000092A1 0000                    	dw	0			;AN000;year
 40240                                  CurDat_mo_day:
 40241 000092A3 0000                    	dw	0			;AN000;month,day
 40242 000092A5 02                      	db	2			;AN000;second subst
 40243 000092A6 34                      	db	34h ; DATE_MDY_4	;AN000;date
 40244 000092A7 0A                      	db	10			;AN000;maximum width
 40245 000092A8 0A                      	db	10			;AN000;minimum width
 40246 000092A9 20                      	db	blank ; 20h		;AN000;pad character
 40247                                  
 40248                                  ;  "SunMonTueWedThuFriSat"
 40249                                  WeekTab:
 40250 000092AA 0904                    	dw	1033			;AN000;message number
 40251 000092AC 00                      	db	no_subst ; 0		;AN000;number of subst
 40252                                  
 40253                                  ;  "Enter new date (%1):"
 40254                                  
 40255                                  NewDat_Ptr:
 40256 000092AD 0A04                    	dw	1034			;AN000;message number
 40257 000092AF 01                      	db	1			;AN000;number of subst
 40258 000092B0 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40259 000092B1 00                      	db	0			;AN000;reserved
 40260                                  NewDat_Format:
 40261 000092B2 0000                    	dw	0			;AN000;offset of replacement
 40262 000092B4 0000                    	dw	0			;AN000;segment of arg
 40263 000092B6 01                      	db	1			;AN000;first subst
 40264 000092B7 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40265 000092B8 08                      	db	8			;AN000;maximum width
 40266 000092B9 08                      	db	8			;AN000;minimum width
 40267 000092BA 20                      	db	blank ; 20h		;AN000;pad character
 40268                                  
 40269                                  ;  "Invalid time",13,10
 40270                                  
 40271                                  BadTim_Ptr:
 40272 000092BB 0B04                    	dw	1035			;AN000;message number
 40273 000092BD 00                      	db	no_subst ; 0		;AN000;number of subst
 40274                                  
 40275                                  ;  "Current time is %1",13,10
 40276                                  CurTim_Ptr:
 40277 000092BE 0C04                    	dw	1036			;AN000;message number
 40278 000092C0 01                      	db	1			;AN000;number of subst
 40279 000092C1 0B                      	db	parm_block_size 	;AN000;size of sublist
 40280 000092C2 00                      	db	0			;AN000;reserved
 40281                                  CurTim_hr_min:
 40282 000092C3 0000                    	dw	0			;AN000;hours,minutes
 40283                                  CurTim_Sec_hn:
 40284 000092C5 0000                    	dw	0			;AN000;seconds,hundredths
 40285 000092C7 01                      	db	1			;AN000;first subst
 40286 000092C8 A5                      	db	0A5h ; Right_Align+TIME_HHMMSSHH_Cty
 40287                                  					;AC059;time
 40288 000092C9 0C                      	db	12			;AC059;maximum width
 40289 000092CA 0C                      	db	12			;AC059;minimum width
 40290 000092CB 20                      	db	blank ; 20h		;AN000;pad character
 40291                                  
 40292                                  ;  "Enter new time:"
 40293                                  NewTim_Ptr:
 40294 000092CC 0D04                    	dw	1037			;AN000;message number
 40295 000092CE 00                      	db	no_subst ; 0		;AN000;number of subst
 40296                                  
 40297                                  ;  ",    Delete (Y/N)?",13,10
 40298                                  Del_Y_N_Ptr:
 40299 000092CF 0E04                    	dw	1038			;AN000;message number
 40300 000092D1 00                      	db	no_subst ; 0		;AN000;number of subst
 40301                                  
 40302                                  ;  "All files in directory will be deleted!",13,10
 40303                                  ;  "Are you sure (Y/N)?",13,10
 40304                                  SureMes_Ptr:
 40305 000092D2 0F04                    	dw	1039			;AN000;message number
 40306 000092D4 00                      	db	no_subst ; 0		;AN000;number of subst
 40307                                  
 40308                                  ;  "Microsoft DOS Version %1.%2",13,10
 40309                                  VerMes_Ptr:
 40310 000092D5 1004                    	dw	1040			;AN000;message number
 40311 000092D7 02                      	db	2			;AN000;number of subst
 40312 000092D8 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 40313 000092D9 00                      	db	0			;AN000;reserved
 40314 000092DA [C4A0]                  	dw	Major_Ver_Num		;AN000;offset of arg
 40315 000092DC 0000                    	dw	0			;AN000;segment of arg
 40316 000092DE 01                      	db	1			;AN000;first subst
 40317 000092DF A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 40318                                  					;AN000;binary to decimal
 40319 000092E0 01                      	db	1			;AN000;maximum width
 40320 000092E1 01                      	db	1			;AN000;minimum width
 40321 000092E2 20                      	db	blank ; 20h		;AN000;pad character
 40322 000092E3 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40323 000092E4 00                      	db	0			;AN000;reserved
 40324 000092E5 [C6A0]                  	dw	Minor_Ver_Num	;AN000;offset of arg
 40325 000092E7 0000                    	dw	0			;AN000;segment of arg
 40326 000092E9 02                      	db	2			;AN000;second subst
 40327 000092EA A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 40328                                  					;AN000;binary to decimal
 40329 000092EB 02                      	db	2			;AN000;maximum width
 40330 000092EC 02                      	db	2			;AN000;minimum width
 40331 000092ED 30                      	db	'0' ; 30h		;AN000;pad character
 40332                                  
 40333                                  ;  "Volume in drive %1 has no label",13,10
 40334                                  VolMes_Ptr_2:
 40335 000092EE 1104                    	dw	1041			;AN000;message number
 40336 000092F0 01                      	db	1			;AN000;number of subst
 40337 000092F1 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 40338 000092F2 00                      	db	0			;AN000;reserved
 40339 000092F3 [CAA0]                  	dw	vol_drv			;AN000;offset of drive
 40340 000092F5 0000                    	dw	0			;AN000;segment of arg
 40341 000092F7 01                      	db	1			;AN000;first subst
 40342 000092F8 00                      	db	0 ; Char_field_Char 	;AN000;character
 40343 000092F9 80                      	db	128			;AN000;maximum width
 40344 000092FA 01                      	db	1			;AN000;minimum width
 40345 000092FB 20                      	db	blank ; 20h		;AN000;pad character
 40346                                  
 40347                                  ;  "Volume in drive %1 is %2",13,10
 40348                                  VolMes_Ptr:
 40349 000092FC 1204                    	dw	1042			;AN000;message number
 40350 000092FE 02                      	db	2			;AN000;number of subst
 40351 000092FF 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40352 00009300 00                      	db	0			;AN000;reserved
 40353 00009301 [CAA0]                  	dw	vol_drv			;AN000;offset of drive
 40354 00009303 0000                    	dw	0			;AN000;segment of arg
 40355 00009305 01                      	db	1			;AN000;first subst
 40356 00009306 00                      	db	00000000b		;AN000;character
 40357 00009307 80                      	db	128			;AN000;maximum width
 40358 00009308 01                      	db	1			;AN000;minimum width
 40359 00009309 20                      	db	blank ; 20h		;AN000;pad character
 40360 0000930A 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40361 0000930B 00                      	db	0			;AN000;reserved
 40362 0000930C [819F]                  	dw	CHARBUF			;AN000;offset of string
 40363 0000930E 0000                    	dw	0			;AN000;segment of arg
 40364 00009310 02                      	db	2			;AN000;second subst
 40365 00009311 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40366 00009312 80                      	db	128			;AN000;maximum width
 40367 00009313 01                      	db	1			;AN000;minimum width
 40368 00009314 20                      	db	blank ; 20h		;AN000;pad character
 40369                                  
 40370                                  ;  "Volume Serial Number is %1-%2",13,10
 40371                                  VolSerMes_Ptr:
 40372 00009315 1304                    	dw	1043			;AN000;message number
 40373 00009317 02                      	db	2			;AN000;number of subst
 40374 00009318 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 40375 00009319 00                      	db	0			;AN000;reserved
 40376 0000931A [34A2]                  	dw	vol_serial+2		;AN000;offset of serial
 40377 0000931C 0000                    	dw	0			;AN000;segment of arg
 40378 0000931E 01                      	db	1			;AN000;first subst
 40379 0000931F A3                      	db	0A3h ; Right_Align+Bin_Hex_Word 
 40380                                  					;AN000;binary to hex
 40381 00009320 04                      	db	4			;AN000;maximum width
 40382 00009321 04                      	db	4			;AN000;minimum width
 40383 00009322 30                      	db	'0' ; 30h		;AN000;pad character
 40384 00009323 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40385 00009324 00                      	db	0			;AN000;reserved
 40386 00009325 [32A2]                  	dw	vol_serial		;AN000;offset of serial
 40387 00009327 0000                    	dw	0			;AN000;segment of arg
 40388 00009329 02                      	db	2			;AN000;second subst
 40389 0000932A A3                      	db	0A3h ; Right_Align+Bin_Hex_Word
 40390                                  					;AN000;binary to hex
 40391 0000932B 04                      	db	4			;AN000;maximum width
 40392 0000932C 04                      	db	4			;AN000;minimum width
 40393 0000932D 30                      	db	'0' ; 30h		;AN000;pad character
 40394                                  
 40395                                  ;  "Invalid directory",13,10
 40396                                  badcd_ptr:
 40397 0000932E 1404                    	dw	1044			;AN000;message number
 40398 00009330 00                      	db	no_subst ; 0		;AN000;number of subst
 40399                                  
 40400                                  ;  "Unable to create directory",13,10
 40401                                  badmkd_ptr:
 40402 00009331 1504                    	dw	1045			;AN000;message number
 40403 00009333 00                      	db	no_subst ; 0		;AN000;number of subst
 40404                                  
 40405                                  ;  "Invalid path, not directory,",13,10
 40406                                  ;  "or directory not empty",13,10
 40407                                  badrmd_ptr:
 40408 00009334 1604                    	dw	1046			;AN000;message number
 40409 00009336 00                      	db	no_subst ; 0		;AN000;number of subst
 40410                                  
 40411                                  ;  "Must specify ON or OFF",13,10
 40412                                  bad_on_off_ptr:
 40413 00009337 1704                    	dw	1047			;AN000;message number
 40414 00009339 00                      	db	no_subst ; 0		;AN000;number of subst
 40415                                  
 40416                                  ;  "Directory of %1",13,10
 40417                                  dirhead_ptr:
 40418 0000933A 1804                    	dw	1048			;AN000;message number
 40419 0000933C 01                      	db	1			;AN000;number of subst
 40420 0000933D 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 40421 0000933E 00                      	db	0			;AN000;reserved
 40422 0000933F [50A0]                  	dw	BWDBUF			;AN000;offset of arg
 40423 00009341 0000                    	dw	0			;AN000;segment of arg
 40424 00009343 01                      	db	1			;AN000;first subst
 40425 00009344 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40426 00009345 80                      	db	128			;AN000;maximum width
 40427 00009346 00                      	db	0			;AN000;minimum width
 40428 00009347 20                      	db	blank ; 20h		;AN000;pad character
 40429                                  
 40430                                  ;  "No Path",13,10
 40431                                  NULLPATH_PTR:
 40432 00009348 1904                    	dw	1049			;AN000;message number
 40433 0000934A 00                      	db	no_subst ; 0		;AN000;number of subst
 40434                                  
 40435                                  ;  "Invalid drive in search path",13,10
 40436                                  BADPMES_PTR:
 40437 0000934B 1A04                    	dw	1050			;AN000;message number
 40438 0000934D 00                      	db	no_subst ; 0		;AN000;number of subst
 40439                                  
 40440                                  ;  "Invalid device",13,10
 40441                                  BADDEV_PTR:
 40442 0000934E 1B04                    	dw	1051			;AN000;message number
 40443 00009350 00                      	db	no_subst ; 0		;AN000;number of subst
 40444                                  
 40445                                  ;  "FOR cannot be nested",13,10
 40446                                  FORNESTMES_PTR:
 40447 00009351 1C04                    	dw	1052			;AN000;message number
 40448 00009353 00                      	db	no_subst ; 0		;AN000;number of subst
 40449                                  
 40450                                  ;  "Intermediate file error during pipe",13,10
 40451                                  PIPEEMES_PTR:
 40452 00009354 1D04                    	dw	1053			;AN000;message number
 40453 00009356 00                      	db	no_subst ; 0		;AN000;number of subst
 40454                                  
 40455                                  ;  "Cannot do binary reads from a device",13,10
 40456                                  INBDEV_PTR:
 40457 00009357 1E04                    	dw	1054			;AN000;message number
 40458 00009359 00                      	db	no_subst ; 0		;AN000;number of subst
 40459                                  
 40460                                  ;  "BREAK is %1",13,10
 40461                                  CtrlcMes_Ptr:
 40462 0000935A 1F04                    	dw	1055			;AN000;message number
 40463 0000935C 01                      	db	1			;AN000;number of subst
 40464 0000935D 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40465 0000935E 00                      	db	0			;AN000;reserved
 40466 0000935F 0000                    	dw	0			;AN000;offset of on/off (new)
 40467 00009361 0000                    	dw	0			;AN000;segment of arg
 40468 00009363 01                      	db	1			;AN000;first subst
 40469 00009364 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40470 00009365 80                      	db	128			;AN000;maximum width
 40471 00009366 01                      	db	1			;AN000;minimum width
 40472 00009367 20                      	db	blank ; 20h		;AN000;pad character
 40473                                  
 40474                                  ;  "VERIFY is %1",13,10
 40475                                  VeriMes_Ptr:
 40476 00009368 2004                    	dw	1056			;AN000;message number
 40477 0000936A 01                      	db	1			;AN000;number of subst
 40478 0000936B 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40479 0000936C 00                      	db	0			;AN000;reserved
 40480 0000936D 0000                    	dw	0			;AN000;offset of on/off (new)
 40481 0000936F 0000                    	dw	0			;AN000;segment of arg
 40482 00009371 01                      	db	1			;AN000;first subst
 40483 00009372 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40484 00009373 80                      	db	128			;AN000;maximum width
 40485 00009374 01                      	db	1			;AN000;minimum width
 40486 00009375 20                      	db	blank ; 20h		;AN000;pad character
 40487                                  
 40488                                  ;  "ECHO is %1",13,10
 40489                                  EchoMes_Ptr:
 40490 00009376 2104                    	dw	1057			;AN000;message number
 40491 00009378 01                      	db	1			;AN000;number of subst
 40492 00009379 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40493 0000937A 00                      	db	0			;AN000;reserved
 40494 0000937B 0000                    	dw	0			;AN000;offset of on/off (new)
 40495 0000937D 0000                    	dw	0			;AN000;segment of arg
 40496 0000937F 01                      	db	1			;AN000;first subst
 40497 00009380 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40498 00009381 80                      	db	128			;AN000;maximum width
 40499 00009382 01                      	db	1			;AN000;minimum width
 40500 00009383 20                      	db	blank ; 20h		;AN000;pad character
 40501                                  
 40502                                  ;  "off"
 40503                                  OFFMES_PTR:
 40504 00009384 2304                    	dw	1059			;AN000;message number
 40505 00009386 00                      	db	no_subst		;AN000;number of subst
 40506                                  
 40507                                  ;  "on"
 40508                                  ONMES_PTR:
 40509 00009387 2404                    	dw	1060			;AN000;message number
 40510 00009389 00                      	db	no_subst ; 0		;AN000;number of subst
 40511                                  
 40512                                  ;  "Error writing to device",13,10
 40513                                  DEVWMES_PTR:
 40514 0000938A 2504                    	dw	1061			;AN000;message number
 40515 0000938C 00                      	db	no_subst ; 0		;AN000;number of subst
 40516                                  
 40517                                  ;  "Invalid path",13,10
 40518                                  INVAL_PATH_PTR:
 40519 0000938D 2604                    	dw	1062			;AN000;message number
 40520 0000938F 00                      	db	no_subst ; 0		;AN000;number of subst
 40521                                  
 40522                                  ;  unformatted string output
 40523                                  arg_buf_ptr:
 40524 00009390 2704                    	dw	1063			;AN000;message number
 40525 00009392 01                      	db	1			;AN000;number of subst
 40526 00009393 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40527 00009394 00                      	db	0			;AN000;reserved
 40528 00009395 [ADA7]                  	dw	Arg_Buf 		;AN000;offset of arg
 40529 00009397 0000                    	dw	0			;AN000;segment of arg
 40530 00009399 01                      	db	1			;AN000;first subst
 40531 0000939A 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40532 0000939B 80                      	db	128			;AN000;maximum width
 40533 0000939C 00                      	db	0			;AN000;minimum width
 40534 0000939D 20                      	db	blank ; 20h		;AN000;pad character
 40535                                  
 40536                                  ;  file name output
 40537                                  file_name_ptr:
 40538 0000939E 2804                    	dw	1064			;AN000;message number
 40539 000093A0 01                      	db	1			;AN000;number of subst
 40540 000093A1 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40541 000093A2 00                      	db	0			;AN000;reserved
 40542 000093A3 [38A1]                  	dw	SrcBuf			;AN000;offset of arg
 40543 000093A5 0000                    	dw	0			;AN000;segment of arg
 40544 000093A7 01                      	db	1			;AN000;first subst
 40545 000093A8 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40546 000093A9 80                      	db	128			;AN000;maximum width
 40547 000093AA 00                      	db	0			;AN000;minimum width
 40548 000093AB 20                      	db	blank ; 20h		;AN000;pad character
 40549                                  
 40550                                  ;  file size output for dir
 40551                                  disp_file_size_ptr:
 40552 000093AC 2904                    	dw	1065			;AN000;message number
 40553 000093AE 01                      	db	1			;AN000;number of subst
 40554 000093AF 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 40555 000093B0 00                      	db	0			;AN000;reserved
 40556 000093B1 [B3A0]                  	dw	File_Size_Low		;AN000;offset of arg
 40557 000093B3 0000                    	dw	0			;AN000;segment of arg
 40558 000093B5 01                      	db	1			;AN000;first subst
 40559                                  	; MSDOS 5.0 COMMAND.COM
 40560                                  	;db	0B1h ; Right_Align+Unsgn_Bin_DWord
 40561                                  	; 17/06/2023
 40562                                  screen_f_1:
 40563 000093B6 F1                      	db	0F1h ; MSDOS 6.22 COMMAND.COM
 40564                                  					;AN000;long binary to decimal
 40565                                  	; MSDOS 5.0 COMMAND.COM
 40566                                  	;db	10			;AN000;maximum width
 40567                                  	;db	10			;AN000;minimum width
 40568                                  screen_f_2:
 40569 000093B7 0E                      	db	14 ; MSDOS 6.22 COMMAND.COM		
 40570 000093B8 0E                      	db	14
 40571                                  	
 40572 000093B9 20                      	db	blank ; 20h		;AN000;pad character
 40573                                  
 40574                                  ;  unformatted string output
 40575                                  ; %s
 40576                                  string_buf_ptr:
 40577 000093BA 2A04                    	dw	1066			;AN000;message number
 40578 000093BC 01                      	db	1			;AN000;number of subst
 40579 000093BD 0B                      	db	parm_block_size 	;AN000;size of sublist
 40580 000093BE 00                      	db	0			;AN000;reserved
 40581 000093BF [B7A0]                  	dw	string_ptr_2		;AN000;offset of arg
 40582 000093C1 0000                    	dw	0			;AN000;segment of arg
 40583 000093C3 01                      	db	1			;AN000;first subst
 40584 000093C4 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40585 000093C5 80                      	db	128			;AN000;maximum width
 40586 000093C6 00                      	db	0			;AN000;minimum width
 40587 000093C7 20                      	db	blank ; 20h		;AN000;pad character
 40588 000093C8 00                      	db	0			;AN000;
 40589                                  
 40590                                  ;  tab character
 40591                                  tab_ptr:
 40592 000093C9 2B04                    	dw	1067			;AN000;message number
 40593 000093CB 00                      	db	no_subst ; 0		;AN000;number of subst
 40594                                  
 40595                                  ;  " <DIR>   "
 40596                                  dmes_ptr:
 40597 000093CC 2C04                    	dw	1068			;AN000;message number
 40598 000093CE 00                      	db	no_subst ; 0		;AN000;number of subst
 40599                                  
 40600                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 40601                                  space_4_ptr :
 40602 000093CF 5104                    	dw	1105 
 40603 000093D1 00                      	db	no_subst ; 0
 40604                                  
 40605                                  ;  destructive back space
 40606                                  dback_ptr:
 40607 000093D2 2D04                    	dw	1069			;AN000;message number
 40608 000093D4 00                      	db	no_subst ; 0		;AN000;number of subst
 40609                                  
 40610                                  ;  carriage return / line feed
 40611                                  acrlf_ptr:
 40612 000093D5 2E04                    	dw	1070			;AN000;message number
 40613 000093D7 00                      	db	no_subst ; 0		;AN000;number of subst
 40614                                  
 40615                                  ;  "mm-dd-yy"
 40616                                  usadat_ptr:
 40617 000093D8 3004                    	dw	1072			;AN000;message number
 40618 000093DA 00                      	db	no_subst ; 0		;AN000;number of subst
 40619                                  
 40620                                  ;  "dd-mm-yy"
 40621                                  eurdat_ptr:
 40622 000093DB 3104                    	dw	1073			;AN000;message number
 40623 000093DD 00                      	db	no_subst ; 0		;AN000;number of subst
 40624                                  
 40625                                  ;  "yy-mm-dd"
 40626                                  japdat_ptr:
 40627 000093DE 3204                    	dw	1074			;AN000;message number
 40628 000093E0 00                      	db	no_subst ; 0		;AN000;number of subst
 40629                                  
 40630                                  ;  date string for prompt
 40631                                  promptdat_ptr:
 40632 000093E1 3304                    	dw	1075			;AN000;message number
 40633 000093E3 02                      	db	2			;AN000;number of subst
 40634 000093E4 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40635 000093E5 00                      	db	0			;AN000;reserved
 40636 000093E6 [ADA7]                  	dw	Arg_Buf			;AN000;offset of arg
 40637 000093E8 0000                    	dw	0			;AN000;segment of arg
 40638 000093EA 01                      	db	1			;AN000;first subst
 40639 000093EB 10                      	db	10h ; Char_field_ASCIIZ ;AN000;character string
 40640 000093EC 03                      	db	3			;AN000;maximum width
 40641 000093ED 03                      	db	3			;AN000;minimum width
 40642 000093EE 20                       	db	blank ; 20h		;AN000;pad character
 40643 000093EF 0B                      	db	parm_block_size  ; 11	;AN000;size of sublist
 40644 000093F0 00                      	db	0			;AN000;reserved
 40645                                  promptDat_yr:
 40646 000093F1 0000                    	dw	0			;AN000;year
 40647                                  promptDat_moday:
 40648 000093F3 0000                    	dw	0			;AN000;month,day
 40649 000093F5 02                      	db	2			;AN000;second subst
 40650 000093F6 34                       	db	34h ; DATE_MDY_4	;AN000;date
 40651 000093F7 0A                      	db	10			;AN000;maximum width
 40652 000093F8 08                      	db	8			;AN000;minimum width
 40653 000093F9 20                      	db	blank ; 20h		;AN000;pad character
 40654                                  
 40655                                  ;  Time for prompt
 40656                                  promtim_ptr:
 40657 000093FA 3404                    	dw	1076			;AN000;message number
 40658 000093FC 01                      	db	1			;AN000;number of subst
 40659 000093FD 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40660 000093FE 00                      	db	0			;AN000;reserved
 40661                                  PromTim_hr_min:
 40662 000093FF 0000                    	dw	0			;AN000;hours,minutes
 40663                                  PromTim_Sec_hn:
 40664 00009401 0000                    	dw	0			;AN000;seconds,hundredths
 40665 00009403 01                      	db	1			;AN000;first subst
 40666 00009404 A6                      	db	0A6h ; Right_Align+TIME_HHMMSSHH_24
 40667                                  					;AC013;time
 40668 00009405 0B                      	db	11			;AN000;maximum width
 40669 00009406 0B                      	db	11			;AC013;minimum width
 40670 00009407 20                      	db	blank ; 20h		;AN000;pad character
 40671                                  
 40672                                  ;  Date and time for DIR
 40673                                  dirdattim_ptr:
 40674 00009408 3504                    	dw	1077			;AN000;message number
 40675 0000940A 02                      	db	2			;AN000;number of subst
 40676 0000940B 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40677 0000940C 00                      	db	0			;AN000;reserved
 40678                                  DirDat_Yr:
 40679 0000940D 0000                    	dw	0			;AN000;year
 40680                                  DirDat_Mo_Day:
 40681 0000940F 0000                    	dw	0			;AN000;month,day
 40682 00009411 01                      	db	1			;AN000;first subst
 40683 00009412 A4                      	db	0A4h ; Right_Align+DATE_MDY_2
 40684                                  					;AN000;date
 40685 00009413 0A                      	db	10			;AN000;maximum width
 40686 00009414 08                      	db	8			;AN000;minimum width
 40687 00009415 20                      	db	blank ; 20h		;AN000;pad character
 40688 00009416 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40689 00009417 00                      	db	0			;AN000;reserved
 40690                                  DirTim_Hr_Min:
 40691 00009418 0000                    	dw	0			;AN000;hours,minutes
 40692                                  DirTim_Sec_hn:
 40693 0000941A 0000                    	dw	0			;AN000;seconds,hundredths
 40694 0000941C 02                      	db	2			;AN000;second subst
 40695 0000941D 85                      	db	85h ; Right_align+TIME_HHMM_Cty
 40696                                  					;AN000;time
 40697 0000941E 06                      	db	6			;AN000;maximum width
 40698 0000941F 06                      	db	6			;AN000;minimum width
 40699 00009420 20                      	db	blank ; 20h		;AN000;pad character
 40700                                  
 40701                                  ;  "Directory already exists"
 40702                                  MD_EXISTS_PTR:
 40703 00009421 3604                    	dw	1078			;AN000;message number
 40704 00009423 00                      	db	no_subst		;AN000;number of subst
 40705                                  
 40706                                  ;  "%1 bytes",13,10
 40707                                  bytes_ptr:
 40708 00009424 3704                    	dw	1079			; message number
 40709 00009426 01                      	db	1			; number of subst
 40710 00009427 0B                      	db	parm_block_size ; 11	; size of sublist
 40711 00009428 00                      	db	0			; reserved
 40712 00009429 [459E]                  	dw	FileSiz			; offset of arg
 40713 0000942B 0000                    	dw	0			; segment of arg
 40714 0000942D 01                      	db	1			; first subst
 40715                                  	; MSDOS 5.0 COMMAND.COM
 40716                                  	;db	0B1h ; Right_Align+Unsgn_Bin_DWord
 40717                                  	; 17/06/2023
 40718                                  screen_f_4:
 40719 0000942E F1                      	db	0F1h ; MSDOS 6.22 COMMAND.COM
 40720                                  					; long binary to decimal
 40721                                  	; MSDOS 5.0 COMMAND.COM
 40722                                  	;db	10			; maximum width
 40723                                  	;db	10			; minimum width
 40724                                  screen_f_5:
 40725 0000942F 0E                      	db	14 ; MSDOS 6.22 COMMAND.COM
 40726 00009430 0E                      	db	14	
 40727                                  
 40728 00009431 20                      	db	blank ; 20h		; pad character
 40729                                  
 40730                                  ;  "Total:",13,10
 40731                                  total_ptr:
 40732 00009432 3804                    	dw	1080			; message number
 40733 00009434 00                      	db	no_subst ; 0		; number of subst
 40734                                  
 40735                                  ;  "Error parsing environment variable:",13,10
 40736                                  errparsenv_ptr:
 40737 00009435 3904                    	dw	1081			; message number
 40738 00009437 00                      	db	no_subst ; 0		; number of subst
 40739                                  
 40740                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 40741                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:996Ah)
 40742                                  cox_Y_quest_ptr:
 40743 00009438 3A04                    	dw	1082
 40744 0000943A 00                      	db	no_subst ; 0
 40745                                  cox_Y_answ_ptr:
 40746 0000943B 3B04                    	dw	1083
 40747 0000943D 00                      	db	no_subst ; 0
 40748                                  
 40749                                  ;  "(continuing %1)",13,10
 40750                                  dircont_ptr:
 40751 0000943E 3C04                    	dw	1084			;AN000;message number
 40752 00009440 01                      	db	1			;AN000;number of subst
 40753 00009441 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40754 00009442 00                      	db	0			;AN000;reserved
 40755 00009443 [50A0]                  	dw	BWDBUF			;AN000;offset of arg
 40756 00009445 0000                    	dw	0			;AN000;segment of arg
 40757 00009447 01                      	db	1			;AN000;first subst
 40758 00009448 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40759 00009449 80                      	db	128			;AN000;maximum width
 40760 0000944A 00                      	db	0			;AN000;minimum width
 40761 0000944B 20                      	db	blank ; 20h		;AN000;pad character
 40762                                  
 40763                                  ;  "Revision %1",CR,LF
 40764                                  dosrev_ptr:
 40765 0000944C 4204                    	dw	1090
 40766 0000944E 01                      	db	1			; one substitution
 40767 0000944F 0B                      	db	parm_block_size ; 11
 40768 00009450 00                      	db	0
 40769 00009451 [C8A0]                  	dw	One_Char_Val		; ptr to char
 40770 00009453 0000                    	dw	0			; segment addr?
 40771 00009455 01                      	db	1			; 1st substitution
 40772 00009456 00                      	db	0 ; CHAR_FIELD_CHAR	; character
 40773 00009457 01                      	db	1			; max width
 40774 00009458 01                      	db	1			; min width
 40775 00009459 20                      	db	blank ; 20h		; pad char
 40776                                  
 40777                                  ;  "DOS is in ROM"
 40778                                  DosRom_Ptr:
 40779 0000945A 4304                    	dw	1091
 40780 0000945C 00                      	db	no_subst ; 0		
 40781                                  
 40782                                  ;  "DOS is in HMA"
 40783                                  DosHma_Ptr:
 40784 0000945D 4404                    	dw	1092
 40785 0000945F 00                      	db	no_subst ; 0		
 40786                                  
 40787                                  ;  "DOS is in low memory"
 40788                                  DosLow_Ptr:
 40789 00009460 4504                    	dw	1093
 40790 00009462 00                      	db	no_subst ; 0		
 40791                                  
 40792                                  ;  "Cannot Loadhigh batch file" ;M016
 40793                                  NoExecBat_Ptr:
 40794 00009463 4604                    	dw	1094			; M016
 40795 00009465 00                      	db	no_subst ; 0		; M016
 40796                                  
 40797                                  ;  "LoadHigh: Invalid filename" ; M016
 40798                                  LhInvFil_Ptr:
 40799 00009466 4704                    	dw	1095			; M016
 40800 00009468 00                      	db	no_subst ; 0		; M016
 40801                                  
 40802                                  ;  "Could not open specified country information file" ; M045
 40803                                  NoCntry_Ptr:
 40804 00009469 4804                    	dw	1096			; M045
 40805 0000946B 00                      	db	no_subst ; 0		; M045
 40806                                  
 40807                                  ; 15/04/2023
 40808                                  ; MSDOS 6.0 COMMAND.COM only !
 40809                                  ; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 40810                                  ;%if 0
 40811                                  
 40812                                  ;* The next four errors emulate those reported by the normal parse
 40813                                  ;  mechanism, with a little more accurate wording; that parser has been
 40814                                  ;  replaced with a custom routine (ParseVar) for LoadHigh and DeviceHigh.
 40815                                  ;  These errors aren't normally generated by LoadHigh except by the normal
 40816                                  ;  parser, so they've been added here.
 40817                                  
 40818                                  ;  "LoadHigh: Invalid argument"
 40819                                  LhInvArg_Ptr:
 40820 0000946C 4904                    	dw	1097
 40821 0000946E 00                      	db	no_subst ; 0		
 40822                                  
 40823                                  ;  "Required parameter missing"
 40824                                  ReqParmMiss:
 40825 0000946F 4A04                    	dw	1098
 40826 00009471 00                      	db	no_subst ; 0		
 40827                                  
 40828                                  ;  "Unrecognized switch"
 40829                                  LhInvSwt_Ptr:
 40830 00009472 4B04                    	dw	1099
 40831 00009474 00                      	db	no_subst ; 0		
 40832                                  
 40833                                  ;  "A bad UMB number has been specified"
 40834                                  LhBadUMB_Ptr:
 40835 00009475 4C04                    	dw	1100
 40836 00009477 00                      	db	no_subst ; 0
 40837                                  ;%endif	
 40838                                  
 40839                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 40840                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:99AAh
 40841                                  
 40842                                  DirCompRatio_Ptr:
 40843 00009478 4D04                    	dw	1101			;message number
 40844 0000947A 02                      	db	2			;number of subst
 40845 0000947B 0B                      	db	parm_block_size ; 11	;size of sublist
 40846 0000947C 00                      	db	0			;reserved
 40847 0000947D [BEA0]                  	dw	Dir_CRatio_1		;offset of arg
 40848 0000947F 0000                    	dw	0			;segment of arg
 40849 00009481 01                      	db	1			;first subst
 40850 00009482 91                      	db	91h			;format
 40851 00009483 02                      	db	2			;maximum width
 40852 00009484 02                      	db	2			;minimum width
 40853 00009485 20                      	db	blank ; 20h		;pad character
 40854 00009486 0B                      	db	parm_block_size  ; 11	;size of sublist
 40855 00009487 00                      	db	0			; reserved
 40856 00009488 [BFA0]                  	dw	Dir_CRatio_2		;offset of arg
 40857 0000948A 0000                    	dw	0			;segment of arg
 40858 0000948C 02                      	db	2			;second subst
 40859 0000948D 11                      	db	11h			;format
 40860 0000948E 01                      	db	1			;maximum width
 40861 0000948F 01                      	db	1			;minimum width
 40862 00009490 20                      	db	blank ; 20h		;pad character
 40863                                  
 40864                                  AveCompRatio_Ptr:
 40865 00009491 4E04                    	dw	1102			;message number
 40866 00009493 02                      	db	2			;number of subst
 40867 00009494 0B                      	db	parm_block_size ; 11	;size of sublist
 40868 00009495 00                      	db	0			;reserved
 40869 00009496 [BEA0]                  	dw	Dir_CRatio_1		;offset of arg
 40870 00009498 0000                    	dw	0			;segment of arg
 40871 0000949A 01                      	db	1			;first subst
 40872 0000949B 91                      	db	91h			;format
 40873 0000949C 02                      	db	2			;maximum width
 40874 0000949D 02                      	db	2			;minimum width
 40875 0000949E 20                      	db	blank ; 20h		;pad character
 40876 0000949F 0B                      	db	parm_block_size  ; 11	;size of sublist
 40877 000094A0 00                      	db	0			; reserved
 40878 000094A1 [BFA0]                  	dw	Dir_CRatio_2		;offset of arg
 40879 000094A3 0000                    	dw	0			;segment of arg
 40880 000094A5 02                      	db	2			;second subst
 40881 000094A6 11                      	db	11h			;format
 40882 000094A7 01                      	db	1			;maximum width
 40883 000094A8 01                      	db	1			;minimum width
 40884 000094A9 20                      	db	blank ; 20h		;pad character
 40885                                  
 40886                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 40887                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8483h
 40888                                  
 40889                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 40890                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:99DCh
 40891                                  
 40892                                  ; ---------------------------------------------------------------------------
 40893                                  
 40894                                  PATH_TEXT:
 40895 000094AA 504154483D              	db	"PATH="
 40896                                  PROMPT_TEXT:
 40897 000094AF 50524F4D50543D          	db	"PROMPT="
 40898                                  COMSPECSTR:
 40899 000094B6 434F4D535045433D        	db	"COMSPEC="
 40900                                  DirEnvVar:
 40901 000094BE 444952434D443D          	db	"DIRCMD="		; DIR's environment variable
 40902                                  
 40903                                  ;============================================================================
 40904                                  ; TDATA.ASM, MSDOS 6.0, 1991
 40905                                  ;============================================================================
 40906                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 40907                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 40908                                  
 40909                                  	; 15/04/2023
 40910 000094C5 00                      	db	0
 40911                                  align 2
 40912                                  
 40913                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:849Eh
 40914                                  ; ---------------------------------------------------------------------------
 40915                                  	; 18/06/2023
 40916                                  	;db	0
 40917                                  
 40918                                  ; Lists of help message numbers for internal commands and /?
 40919                                  
 40920                                  	; 18/06/2023
 40921                                  ;;NoHelpMsgs:
 40922                                  	;dw	1200,0		;M014
 40923                                  
 40924                                  	; 18/06/2023
 40925                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:99F7h
 40926                                  
 40927                                  BreakHelpMsgs:
 40928 000094C6 14050000                	dw	1300,0
 40929                                  ChcpHelpMsgs:
 40930 000094CA 280529050000            	dw	1320,1321,0
 40931                                  CdHelpMsgs:
 40932 000094D0 3C053D053E050000        	dw	1340,1341,1342,0
 40933                                  ClsHelpMsgs:
 40934 000094D8 50050000                	dw	1360,0
 40935                                  CopyHelpMsgs:
 40936                                  	;dw	1400,1401,1402,1403,1404,0
 40937                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 40938 000094DC 780579057A057B057C-     	dw	1400,1401,1402,1403,1404,1405,1406,1407,0
 40938 000094E5 057D057E057F050000 
 40939                                  CttyHelpMsgs:
 40940 000094EE 8C050000                	dw	1420,0
 40941                                  DateHelpMsgs:
 40942 000094F2 A005A1050000            	dw	1440,1441,0
 40943                                  DelHelpMsgs:
 40944 000094F8 B405B505B6050000        	dw	1460,1461,1462,0
 40945                                  DirHelpMsgs:
 40946 00009500 C805C905CA05CB05CC-     	dw	1480,1481,1482,1483,1484,1485,1486,1487,1488
 40946 00009509 05CD05CE05CF05D005 
 40947                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM 
 40948                                  	; MSDOS 6.0 COMMAND.COM
 40949 00009512 D105D205D305D405        	dw	1489,1490,1491,1492
 40950 0000951A 0000                    	dw	0
 40951                                  ExitHelpMsgs:
 40952 0000951C DC050000                	dw	1500,0
 40953                                  MdHelpMsgs:
 40954 00009520 F0050000                	dw	1520,0
 40955                                  PathHelpMsgs:
 40956 00009524 0406050606060000        	dw	1540,1541,1542,0
 40957                                  PromptHelpMsgs:
 40958 0000952C 180619061A061B061C-     	dw	1560,1561,1562,1563,1564,1565,1566,1567,1568,0
 40958 00009535 061D061E061F062006-
 40958 0000953E 0000               
 40959                                  RdHelpMsgs:
 40960 00009540 2C060000                	dw	1580,0
 40961                                  RenHelpMsgs:
 40962 00009544 4006410642060000        	dw	1600,1601,1602,0
 40963                                  SetHelpMsgs:
 40964 0000954C 5406550656060000        	dw	1620,1621,1622,0
 40965                                  TimeHelpMsgs:
 40966 00009554 680669060000            	dw	1640,1641,0
 40967                                  TypeHelpMsgs:
 40968 0000955A 7C060000                	dw	1660,0
 40969                                  VerHelpMsgs:
 40970 0000955E 90060000                	dw	1680,0
 40971                                  VerifyHelpMsgs:
 40972 00009562 A4060000                	dw	1700,0
 40973                                  VolHelpMsgs:
 40974 00009566 B8060000                	dw	1720,0
 40975                                  CallHelpMsgs:
 40976 0000956A CC06CD060000            	dw	1740,1741,0	;M014
 40977                                  RemHelpMsgs:
 40978 00009570 E0060000                	dw	1760,0		;M014
 40979                                  PauseHelpMsgs:
 40980 00009574 F4060000                	dw	1780,0		;M014
 40981                                  EchoHelpMsgs:
 40982 00009578 080709070000            	dw	1800,1801,0	;M014
 40983                                  GotoHelpMsgs:
 40984 0000957E 1C071D070000            	dw	1820,1821,0	;M014
 40985                                  ShiftHelpMsgs:
 40986 00009584 30070000                	dw	1840,0		;M014
 40987                                  IfHelpMsgs:
 40988 00009588 440745074607470748-     	dw	1860,1861,1862,1863,1864,1865,1866,0	;M014
 40988 00009591 0749074A070000     
 40989                                  ForHelpMsgs:
 40990 00009598 580759075A075B0700-     	dw	1880,1881,1882,1883,0 ;M014
 40990 000095A1 00                 
 40991                                  TruenameHelpMsgs:
 40992 000095A2 6C070000                	 dw	1900,0		;M014
 40993                                  LoadhighHelpMsgs:
 40994 000095A6 800781078207            	dw	1920,1921,1922
 40995                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM 
 40996                                  	; MSDOS 6.0 COMMAND.COM
 40997 000095AC 830784078507860787-     	dw	1923,1924,1925,1926,1927 ;M014
 40997 000095B5 07                 
 40998 000095B6 0000                    	dw	0
 40999                                  
 41000                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8578h
 41001                                  CLSSTRING:
 41002 000095B8 041B5B324A              	db	4,1Bh,"[2J"		; ANSI Clear screen
 41003                                  
 41004                                  PROMPT_TABLE:
 41005 000095BD 42                      	db	"B"
 41006 000095BE [4B23]                  	dw	Print_B
 41007 000095C0 44                      	db	"D"
 41008 000095C1 [1A3C]                  	dw	PRINT_DATE
 41009 000095C3 45                      	db	"E"
 41010 000095C4 [3F23]                  	dw	PRINT_ESC
 41011 000095C6 47                      	db	"G"
 41012 000095C7 [4323]                  	dw	PRINT_G
 41013 000095C9 48                      	db	"H"
 41014 000095CA [3523]                  	dw	PRINT_BACK
 41015 000095CC 4C                      	db	"L"
 41016 000095CD [4723]                  	dw	PRINT_L
 41017 000095CF 4E                      	db	"N"
 41018 000095D0 [5C23]                  	dw	PRINT_DRIVE
 41019 000095D2 50                      	db	"P"
 41020 000095D3 [6423]                  	dw	build_dir_for_prompt
 41021 000095D5 51                      	db	"Q"
 41022 000095D6 [3B23]                  	dw	PRINT_EQ
 41023 000095D8 54                      	db	"T"
 41024 000095D9 [D034]                  	dw	PRINT_TIME
 41025 000095DB 56                      	db	"V"
 41026 000095DC [CB22]                  	dw	PRINT_VERSION
 41027 000095DE 5F                      	db	"_"
 41028 000095DF [212B]                  	dw	CRLF2
 41029 000095E1 24                      	db	"$"
 41030 000095E2 [4D23]                  	dw	PRINT_CHAR
 41031 000095E4 00                      	db	0			; NUL TERMINATED
 41032                                  
 41033                                  ; Table of IF conditionals
 41034                                  IFTAB:
 41035 000095E5 034E4F54                	db	3,"NOT"			; First byte is count
 41036 000095E9 [B30B]                  	dw	IFNOT
 41037 000095EB 0A4552524F524C4556-     	db	10,"ERRORLEVEL"
 41037 000095F4 454C               
 41038 000095F6 [720C]                  	dw	IFERLEV
 41039 000095F8 054558495354            	db	5,"EXIST"
 41040 000095FE [070C]                  	dw	IFEXISTS
 41041 00009600 00                      	db	0
 41042                                  
 41043                                  ; Table for internal command names
 41044                                  COMTAB:
 41045 00009601 0344495203              	db	3,"DIR",fSwitchAllowed+fCheckDrive ; 3
 41046 00009606 [3711]                  	dw	CATALOG			; In TCMD1.ASM
 41047 00009608 [0095]                  	dw	DirHelpMsgs
 41048                                  
 41049 0000960A 0443414C4C02            	db	4,"CALL",fSwitchAllowed	; 2
 41050 00009610 [E70C]                  	dw	_$CALL			; In TBATCH2.ASM
 41051 00009612 [6A95]                  	dw	CallHelpMsgs
 41052                                  
 41053 00009614 044348435002            	db	4,"CHCP",fSwitchAllowed ; 2
 41054 0000961A [A725]                  	dw	CHCP			; In TCMD2B.ASM
 41055 0000961C [CA94]                  	dw	ChcpHelpMsgs
 41056                                  
 41057 0000961E 0652454E414D4503        	db	6,"RENAME",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 41058 00009626 [931F]                  	dw	CRENAME			; In TCMD1.ASM
 41059 00009628 [4495]                  	dw	RenHelpMsgs
 41060                                  
 41061 0000962A 0352454E03              	db	3,"REN",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 41062 0000962F [931F]                  	dw	CRENAME			; In TCMD1.ASM
 41063 00009631 [4495]                  	dw	RenHelpMsgs
 41064                                  	
 41065 00009633 05455241534503          	db	5,"ERASE",fSwitchAllowed+fCheckDrive	; 3
 41066 0000963A [111F]                  	dw	ERASE			; In TCMD1.ASM
 41067 0000963C [F894]                  	dw	DelHelpMsgs
 41068                                  	
 41069 0000963E 0344454C03              	db	3,"DEL",fSwitchAllowed+fCheckDrive	; 3
 41070 00009643 [111F]                  	dw	ERASE			; In TCMD1.ASM
 41071 00009645 [F894]                  	dw	DelHelpMsgs
 41072                                  	
 41073 00009647 045459504503            	db	4,"TYPE",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 41074 0000964D [3A20]                  	dw	TYPEFIL			; In TCMD1.ASM
 41075 0000964F [5A95]                  	dw	TypeHelpMsgs
 41076                                  	
 41077 00009651 0352454D06              	db	3,"REM",fSwitchAllowed+fLimitHelp	; 6
 41078 00009656 [0401]                  	dw	TCOMMAND		; In TCODE.ASM
 41079 00009658 [7095]                  	dw	RemHelpMsgs
 41080                                  	
 41081 0000965A 04434F505903            	db	4,"COPY",fSwitchAllowed+fCheckDrive	; 3
 41082 00009660 [673C]                  	dw	COPY			; In COPY.ASM
 41083 00009662 [DC94]                  	dw	CopyHelpMsgs
 41084                                  	
 41085 00009664 05504155534506          	db	5,"PAUSE",fSwitchAllowed+fLimitHelp	; 6
 41086 0000966B [051F]                  	dw	PAUSE			; In TCMD1.ASM
 41087 0000966D [7495]                  	dw	PauseHelpMsgs
 41088                                  	
 41089 0000966F 044441544502            	db	4,"DATE",fSwitchAllowed	; 2
 41090 00009675 [E333]                  	dw	DATE			; In TPIPE.ASM
 41091 00009677 [F294]                  	dw	DateHelpMsgs
 41092                                  	
 41093 00009679 0454494D4502            	db	4,"TIME",fSwitchAllowed ; 2		;AC018; P3903
 41094 0000967F [4234]                  	dw	CTIME			; In TPIPE.ASM
 41095 00009681 [5495]                  	dw	TimeHelpMsgs
 41096                                  	
 41097 00009683 0356455202              	db	3,"VER",fSwitchAllowed ; 2
 41098 00009688 [5922]                  	dw	VERSION			; In TCMD2.ASM
 41099 0000968A [5E95]                  	dw	VerHelpMsgs
 41100                                  	
 41101 0000968C 03564F4C03              	db	3,"VOL",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 41102 00009691 [6121]                  	dw	VOLUME			; In TCMD1.ASM
 41103 00009693 [6695]                  	dw	VolHelpMsgs
 41104                                  	
 41105 00009695 02434403                	db	2,"CD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 41106 00009699 [EA29]                  	dw	_$CHDIR			; In TENV.ASM
 41107 0000969B [D094]                  	dw	CdHelpMsgs
 41108                                  	
 41109 0000969D 05434844495203          	db	5,"CHDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 41110 000096A4 [EA29]                  	dw	_$CHDIR			; In TENV.ASM
 41111 000096A6 [D094]                  	dw	CdHelpMsgs
 41112                                  	
 41113 000096A8 024D4403                	db	2,"MD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 41114 000096AC [4F2A]                  	dw	_$MKDIR			; In TENV.ASM
 41115 000096AE [2095]                  	dw	MdHelpMsgs
 41116                                  	
 41117 000096B0 054D4B44495203          	db	5,"MKDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 41118 000096B7 [4F2A]                  	dw	_$MKDIR			; In TENV.ASM
 41119 000096B9 [2095]                  	dw	MdHelpMsgs
 41120                                  	
 41121 000096BB 02524403                	db	2,"RD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 41122 000096BF [912A]                  	dw	_$RMDIR			; In TENV.ASM
 41123 000096C1 [4095]                  	dw	RdHelpMsgs
 41124                                  	
 41125 000096C3 05524D44495203          	db	5,"RMDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 41126 000096CA [912A]                  	dw	_$RMDIR			; In TENV.ASM
 41127 000096CC [4095]                  	dw	RdHelpMsgs
 41128                                  	
 41129 000096CE 05425245414B02          	db	5,"BREAK",fSwitchAllowed ; 2		;AC018; P3903
 41130 000096D5 [643B]                  	dw	CNTRLC			; In TUCODE.ASM
 41131 000096D7 [C694]                  	dw	BreakHelpMsgs
 41132                                  	
 41133 000096D9 0656455249465902        	db	6,"VERIFY",fSwitchAllowed ; 2		;AC018; P3903
 41134 000096E1 [A63B]                  	dw	VERIFY			; In TUCODE.ASM
 41135 000096E3 [6295]                  	dw	VerifyHelpMsgs
 41136                                  	
 41137 000096E5 0353455406              	db	3,"SET",fSwitchAllowed+fLimitHelp ; 6
 41138 000096EA [5427]                  	dw	ADD_NAME_TO_ENVIRONMENT	; In TENV.ASM
 41139 000096EC [4C95]                  	dw	SetHelpMsgs
 41140                                  	
 41141 000096EE 0650524F4D505406        	db	6,"PROMPT",fSwitchAllowed+fLimitHelp ; 6
 41142 000096F6 [3A27]                  	dw	ADD_PROMPT		; In TENV.ASM
 41143 000096F8 [2C95]                  	dw	PromptHelpMsgs
 41144                                  	
 41145 000096FA 045041544802            	db	4,"PATH",fSwitchAllowed ; 2
 41146 00009700 [CB23]                  	dw	PATH			; In TCMD2.ASM
 41147 00009702 [2495]                  	dw	PathHelpMsgs
 41148                                  	
 41149 00009704 044558495400            	db	4,"EXIT",0
 41150 0000970A [9C26]                  	dw	_$EXIT			; In TCMD2.ASM
 41151 0000970C [1C95]                  	dw	ExitHelpMsgs
 41152                                  	
 41153 0000970E 044354545903            	db	4,"CTTY",fCheckDrive+fSwitchAllowed ; 3
 41154 00009714 [0925]                  	dw	CTTY			; In TCMD2.ASM
 41155 00009716 [EE94]                  	dw	CttyHelpMsgs
 41156                                  	
 41157 00009718 044543484F06            	db	4,"ECHO",fSwitchAllowed+fLimitHelp ; 6
 41158 0000971E [2B3B]                  	dw	_ECHO			; In TUCODE.ASM
 41159 00009720 [7895]                  	dw	EchoHelpMsgs
 41160                                  	
 41161 00009722 04474F544F06            	db	4,"GOTO",fSwitchAllowed+fLimitHelp
 41162 00009728 [1B0D]                  	dw	_GOTO			; In TBATCH.ASM
 41163 0000972A [7E95]                  	dw	GotoHelpMsgs
 41164                                  	
 41165 0000972C 05534849465402          	db	5,"SHIFT",fSwitchAllowed ; 2
 41166 00009733 [A00C]                  	dw	_SHIFT			; In TBATCH.ASM
 41167 00009735 [8495]                  	dw	ShiftHelpMsgs
 41168                                  	
 41169 00009737 02494606                	db	2,"IF",fSwitchAllowed+fLimitHelp ; 6
 41170 0000973B [4C0B]                  	dw	_$IF			; In TBATCH.ASM
 41171 0000973D [8895]                  	dw	IfHelpMsgs
 41172                                  	
 41173 0000973F 03464F5206              	db	3,"FOR",fSwitchAllowed+fLimitHelp ; 6
 41174 00009744 [D00F]                  	dw	_$FOR			; In TBATCH.ASM
 41175 00009746 [9895]                  	dw	ForHelpMsgs
 41176                                  	
 41177 00009748 03434C5300              	db	3,"CLS",0
 41178 0000974D [7024]                  	dw	CLS			; In TCMD2.ASM
 41179 0000974F [D894]                  	dw	ClsHelpMsgs
 41180                                  	
 41181 00009751 08545255454E414D45-     	db	8,"TRUENAME",fSwitchAllowed+fCheckDrive	;AN000; P3903 changed
 41181 0000975A 03                 
 41182 0000975B [2526]                  	dw	TRUENAME		;AN000;
 41183 0000975D [A295]                  	dw	TruenameHelpMsgs
 41184                                  	
 41185 0000975F 084C4F414448494748-     	db	8,"LOADHIGH",fSwitchAllowed ; 2	; M003
 41185 00009768 02                 
 41186 00009769 [2463]                  	dw	LoadHigh		; In loadhi.asm ; M003
 41187 0000976B [A695]                  	dw	LoadhighHelpMsgs	; M003
 41188                                  	
 41189 0000976D 024C4802                	db	2,"LH",fSwitchAllowed ; 2	; Short form; M003
 41190 00009771 [2463]                  	dw	LoadHigh		; In loadhi.asm ; M003
 41191 00009773 [A695]                  	dw	LoadhighHelpMsgs	; M003
 41192                                  	
 41193 00009775 00                      	db	0			; Terminate command table
 41194                                  
 41195                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8736h
 41196                                  
 41197 00009776 2E434F4D                comext:	db	".COM"
 41198 0000977A 2E455845                exeext:	db	".EXE"
 41199 0000977E 2E424154                batext:	db	".BAT"
 41200                                  
 41201                                  switch_list:
 41202                                  	; MSDOS 5.0 (& 6.0) COMMAND.COM
 41203                                  	;db	"?VBAPW"		; flags we can recognize
 41204                                  	; 18/06/2023
 41205                                  	; MSDOS 6.22 COMMAND.COM
 41206 00009782 2D593F5642415057        	db "-Y?VBAPW"
 41207                                  
 41208                                  AttrLtrs:
 41209 0000978A 524853764441            	db	"RHSvDA"		; attribute letters for DIR
 41210                                  
 41211                                  ;	Attribute letters in AttrLtrs must appear in the order that
 41212                                  ;	attribute bits occur in the attribute byte returned by
 41213                                  ;	directory searches, starting with bit 0.
 41214                                  ;	The volume label attribute is lowercased to keep it from
 41215                                  ;	being matched (by an uppercase comparison).
 41216                                  
 41217                                  OrderLtrs:
 41218                                  	; MSDOS 5.0
 41219                                  	;db	"NEDSG"			; sort order letters for DIR
 41220                                  	; 18/06/2023
 41221                                  	; MSDOS 6.0 COMMAND.COM
 41222 00009790 4E4544534743            	db	"NEDSGC"		; sort order letters for DIR
 41223                                  
 41224                                  ;	Sort order letters stand for file name, extension,
 41225                                  ;	date/time, size, grouped (directory files before others),
 41226                                  ;	and compression ratio. DIR routines rely on the specific
 41227                                  ;	order of the letters in this list.
 41228                                  
 41229                                  comspec_flag:
 41230 00009796 00                      	db	0                       ;AN071;
 41231                                  
 41232                                  BATBUFLEN:
 41233 00009797 2000                    	dw	BatLen ; 32
 41234                                  
 41235                                  ; *****************************************************
 41236                                  ; EMG 4.00
 41237                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 41238                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 41239                                  ; *****************************************************
 41240                                  
 41241                                  ; COMMON PARSE BLOCKS
 41242                                  
 41243                                  ; Indicates no value list for PARSE.
 41244                                  
 41245                                  NO_VALUES:
 41246 00009799 0000                    	dw	0			;AN000;  no values
 41247                                  
 41248                                  NULL_VALUE_LIST:  ; for unvalidated value
 41249 0000979B 00                       	db	0                       ; no value lists
 41250                                  
 41251                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41252                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8759h
 41253                                  
 41254                                  ; PARSE control block for a required file specification (upper cased)
 41255                                  
 41256                                  FILE_REQUIRED:
 41257 0000979C 0002                    	dw	0200h			;AN000;  filespec - required
 41258 0000979E 0100                    	dw	1			;AN000;  capitalize - file table
 41259 000097A0 [07AA]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41260 000097A2 [9997]                  	dw	NO_VALUES		;AN000;
 41261 000097A4 00                      	db	0			;AN000;  no keywords
 41262                                  
 41263                                  ; PARSE control block for an optional file specification (upper cased)
 41264                                  ; or drive number
 41265                                  
 41266                                  FILE_OPTIONAL:
 41267 000097A5 0103                    	dw	0301h			;AN000;  filespec or drive number
 41268                                  					;	 optional
 41269 000097A7 0100                    	dw	1			;AN000;  capitalize - file table
 41270 000097A9 [07AA]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41271 000097AB [9997]                  	dw	NO_VALUES		;AN000;
 41272 000097AD 00                      	db	0			;AN000;  no keywords
 41273                                  
 41274                                  ; PARSE control block for an optional file specification (upper cased)
 41275                                  
 41276                                  FILE_OPTIONAL2:
 41277 000097AE 0102                    	dw	0201h                   ;AN000;  filespec optional
 41278 000097B0 0100                    	dw	1                       ;AN000;  capitalize - file table
 41279 000097B2 [07AA]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41280 000097B4 [9997]                  	dw	NO_VALUES		;AN000;
 41281 000097B6 00                      	db	0			;AN000;  no keywords
 41282                                  
 41283                                  ; PARSE control block for an optional /P switch
 41284                                  
 41285                                  SLASH_P_SWITCH:
 41286 000097B7 0000                    	dw	0			;AN000;  no match flags
 41287 000097B9 0200                    	dw	2			;AN000;  capitalize - char table
 41288 000097BB [07AA]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41289 000097BD [9997]                  	dw	NO_VALUES		;AN000;
 41290 000097BF 01                      	db	1			;AN000;  1 keyword
 41291                                  SLASH_P_SYN:
 41292 000097C0 2F5000                  	db	"/P",0                  ;AN000;  /P switch
 41293                                  
 41294                                  ; PARSE BLOCK FOR BREAK, VERIFY, ECHO
 41295                                  
 41296                                  ; The following parse control block can be used for any command which
 41297                                  ; needs only the optional "ON" and "OFF" keywords as operands. Allows
 41298                                  ; the equal sign as an additional delimiter. Returns verified result
 41299                                  ; in PARSE1_OUTPUT. Currently used for the BREAK, VERIFY, and ECHO
 41300                                  ; internal commands.
 41301                                  
 41302                                  PARSE_BREAK:
 41303 000097C3 [C697]                  	dw	BREAK_PARMS		;AN000;
 41304 000097C5 00                      	db	0			;AN032; no extra delimiter
 41305                                  
 41306                                  BREAK_PARMS:
 41307 000097C6 0001                    	db	0,1			;AN000;  1 positional parm
 41308 000097C8 [CC97]                  	dw	BREAK_CONTROL1		;AN000;
 41309 000097CA 00                      	db	0			;AN000;  no switches
 41310 000097CB 00                      	db	0			;AN000;  no keywords
 41311                                  
 41312                                  BREAK_CONTROL1:
 41313 000097CC 0120                    	dw	2001h			;AN000;  string value - optional
 41314 000097CE 0200                    	dw	2			;AN000;  capitalize - char table
 41315 000097D0 [07AA]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41316 000097D2 [D597]                  	dw	BREAK_VALUES		;AN000;
 41317 000097D4 00                      	db	0			;AN000;  no keywords
 41318                                  
 41319                                  BREAK_VALUES:
 41320 000097D5 03                      	db	3			;AN000;
 41321 000097D6 00                      	db	0			;AN000;  no ranges
 41322 000097D7 00                      	db	0			;AN000;  no numeric values
 41323 000097D8 02                      	db	2			;AN000;  2 string values
 41324 000097D9 00                      	db	0			;AN000;  returned if ON
 41325 000097DA [DF97]                  	dw	BREAK_ON		;AN000;  point to ON string
 41326 000097DC 66                      	db	'f'                     ;AN000;  returned if OFF
 41327 000097DD [E297]                  	dw	BREAK_OFF		;AN000;  point to OFF string
 41328                                  
 41329                                  BREAK_ON:
 41330 000097DF 4F4E00                  	db	"ON",0                  ;AN000;
 41331                                  BREAK_OFF:
 41332 000097E2 4F464600                	db	"OFF",0                 ;AN000;
 41333                                  
 41334                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41335                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:87A3h
 41336                                  
 41337                                  ; PARSE BLOCK FOR CHCP
 41338                                  
 41339                                  ; The following parse control block can be used for any command which
 41340                                  ; needs only one optional three digit decimal parameter for operands.
 41341                                  ; Returns verified result in PARSE1_OUTPUT. Currently used for the
 41342                                  ; CHCP internal command.
 41343                                  
 41344                                  CHCP_MINVAL	EQU	100			;AN000;
 41345                                  CHCP_MAXVAL	EQU	999			;AN000;
 41346                                  
 41347                                  PARSE_CHCP:
 41348 000097E6 [E997]                  	dw	CHCP_PARMS			;AN000;
 41349 000097E8 00                      	db	0				;AN000;  no extra delimiter
 41350                                  CHCP_PARMS:
 41351 000097E9 0001                    	db	0,1				;AN000;  1 positional parm
 41352 000097EB [EF97]                  	dw	CHCP_CONTROL1			;AN000;
 41353 000097ED 00                      	db	0				;AN000;  no switches
 41354 000097EE 00                      	db	0				;AN000;  no keywords
 41355                                  
 41356                                  CHCP_CONTROL1:
 41357 000097EF 0180                    	dw	8001h				;AN000;  numeric value - optional
 41358 000097F1 0000                    	dw	0				;AN000;  no function flags
 41359 000097F3 [07AA]                  	dw	PARSE1_OUTPUT			;AN000;  result buffer
 41360 000097F5 [F897]                  	dw	CHCP_VALUES			;AN000;
 41361 000097F7 00                      	db	0				;AN000;  no keywords
 41362                                  
 41363                                  CHCP_VALUES:
 41364 000097F8 01                      	db	1				;AN000;
 41365 000097F9 01                      	db	1				;AN000;  1 range
 41366 000097FA 01                      	db	1				;AN000;  returned if result
 41367 000097FB 64000000E7030000        	dd	CHCP_MINVAL,CHCP_MAXVAL		;AN000;  minimum & maximum value
 41368 00009803 00                      	db	0				;AN000;  no numeric values
 41369 00009804 00                      	db	0				;AN000;  no string values
 41370                                  
 41371                                  ; PARSE BLOCK FOR DATE
 41372                                  
 41373                                  ; The following parse control block can be used for any command which
 41374                                  ; needs only an optional date string as an operand. Returns unverified
 41375                                  ; result in DATE_OUTPUT. Currently used for the DATE internal command.
 41376                                  
 41377                                  PARSE_DATE:
 41378 00009805 [0898]                  	dw	DATE_PARMS			;AN000;
 41379 00009807 00                      	db	0				;AN000;  no extra delimiter
 41380                                  DATE_PARMS:
 41381 00009808 0001                    	db	0,1				;AN000;  1 positional parm
 41382 0000980A [0E98]                  	dw	DATE_CONTROL1			;AN000;
 41383 0000980C 00                      	db	0				;AN000;  no switches
 41384 0000980D 00                      	db	0				;AN000;  no keywords
 41385                                  
 41386                                  DATE_CONTROL1:
 41387 0000980E 0110                    	dw	1001h				;AN000;  date - optional
 41388 00009810 0000                    	dw	0				;AN000;  no function flags
 41389 00009812 [0FAA]                  	dw	DATE_OUTPUT			;AN000;  result buffer
 41390 00009814 [9997]                  	dw	NO_VALUES			;AN000;
 41391 00009816 00                      	db	0				;AN000;  no keywords
 41392                                  
 41393                                  ; PARSE BLOCK FOR TIME
 41394                                  
 41395                                  ; The following parse control block can be used for any command which
 41396                                  ; needs only an optional time string as an operand. Returns unverified
 41397                                  ; result in TIME_OUTPUT. Currently used for the TIME internal command.
 41398                                  
 41399                                  PARSE_TIME:
 41400 00009817 [1A98]                  	dw	TIME_PARMS			;AN000;
 41401 00009819 00                      	db	0				;AN000;  no extra delimiter
 41402                                  TIME_PARMS:
 41403 0000981A 0001                    	db	0,1				;AN000;  1 positional parm
 41404 0000981C [2098]                  	dw	TIME_CONTROL1			;AN000;
 41405 0000981E 00                      	db	0				;AN000;  no switches
 41406 0000981F 00                      	db	0				;AN000;  no keywords
 41407                                  
 41408                                  TIME_CONTROL1:
 41409 00009820 0108                    	dw	0801h				;AN000;  TIME - optional
 41410 00009822 0000                    	dw	0				;AN000;  no function flags
 41411 00009824 [17AA]                  	dw	TIME_OUTPUT			;AN000;  result buffer
 41412 00009826 [9997]                  	dw	NO_VALUES			;AN000;
 41413 00009828 00                      	db	0				;AN000;  no keywords
 41414                                  
 41415                                  ; PARSE BLOCK FOR VOL
 41416                                  
 41417                                  ; The following parse control block can be used for any command which
 41418                                  ; needs only an optional drive letter as an operand.  Returns unverified
 41419                                  ; drive number (one based) in DRIVE_OUTPUT. Currently used for the VOL
 41420                                  ; internal command.
 41421                                  
 41422                                  PARSE_VOL:
 41423 00009829 [2C98]                  	dw	VOL_PARMS			;AN000;
 41424 0000982B 00                      	db	0				;AN000;  no extra delimiter
 41425                                  VOL_PARMS:
 41426 0000982C 0001                    	db	0,1				;AN000;  1 positional parm
 41427 0000982E [3298]                  	dw	DRIVE_CONTROL1			;AN000;
 41428 00009830 00                      	db	0				;AN000;  no switches
 41429 00009831 00                      	db	0				;AN000;  no keywords
 41430                                  
 41431                                  DRIVE_CONTROL1:
 41432 00009832 0101                    	dw	0101h				;AN000;  DRIVE - optional
 41433 00009834 0100                    	dw	1				;AN000;  capitalize - file table
 41434 00009836 [1FAA]                  	dw	DRIVE_OUTPUT			;AN000;  result buffer
 41435 00009838 [9997]                  	dw	NO_VALUES			;AN000;
 41436 0000983A 00                      	db	0				;AN000;  no keywords
 41437                                  
 41438                                  ; PARSE BLOCK FOR MKDIR, RMDIR, TYPE
 41439                                  
 41440                                  ; The following parse control block can be used for any command which
 41441                                  ; needs only one required file specification as an operand. Returns a
 41442                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 41443                                  ; for the MKDIR, RMDIR, and TYPE internal commands.
 41444                                  
 41445                                  PARSE_MRDIR:
 41446 0000983B [3E98]                  	dw	MRDIR_PARMS			;AN000;
 41447 0000983D 00                      	db	0				;AN000;  no extra delimiter
 41448                                  MRDIR_PARMS:
 41449 0000983E 0101                    	db	1,1				;AN000;  1 positional parm
 41450 00009840 [9C97]                  	dw	FILE_REQUIRED			;AN000;
 41451 00009842 00                      	db	0				;AN000;  no switches
 41452 00009843 00                      	db	0				;AN000;  no keywords
 41453                                  
 41454                                  ; PARSE BLOCK FOR CHDIR, TRUENAME
 41455                                  
 41456                                  ; The following parse control block can be used for any command which
 41457                                  ; needs only one optional file specification an operand. Returns a
 41458                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 41459                                  ; for the CHDIR and TRUENAME internal commands.
 41460                                  
 41461                                  PARSE_CHDIR:
 41462 00009844 [4798]                  	dw	CHDIR_PARMS			;AN000;
 41463 00009846 00                      	db	0				;AN000;  no extra delimiter
 41464                                  CHDIR_PARMS:
 41465 00009847 0001                    	db	0,1				;AN000;  1 positional parm
 41466 00009849 [A597]                  	dw	FILE_OPTIONAL			;AN000;
 41467 0000984B 00                      	db	0				;AN000;  no switches
 41468 0000984C 00                      	db	0				;AN000;  no keywords
 41469                                  
 41470                                  ; PARSE BLOCK FOR ERASE
 41471                                  
 41472                                  ; The following parse control block is used for the DEL/ERASE internal
 41473                                  ; commands. This command has one required file specification and an
 41474                                  ; optional switch (/p) as operands. The verified switch or unverified
 41475                                  ; file specification is returned in PARSE1_OUTPUT.
 41476                                  
 41477                                  PARSE_ERASE:
 41478 0000984D [5098]                  	dw	ERASE_PARMS			;AN000;
 41479 0000984F 00                      	db	0				;AN000;  no extra delimiter
 41480                                  
 41481                                  ERASE_PARMS:
 41482 00009850 0101                    	db	1,1				;AN000;  1 positional parm
 41483 00009852 [9C97]                  	dw	FILE_REQUIRED			;AN000;
 41484 00009854 01                      	db	1				;AN000;  1 switch
 41485 00009855 [B797]                  	dw	SLASH_P_SWITCH			;AN000;
 41486 00009857 00                      	db	0				;AN000;  no keywords
 41487                                  
 41488                                  ; PARSE BLOCK FOR DIR
 41489                                  
 41490                                  ; The following parse control block is used for the DIR internal command.
 41491                                  ; This command has one optional file specification and several optional
 41492                                  ; switches. Switches, switch values, and the filespec are returned in 
 41493                                  ; PARSE1_OUTPUT.
 41494                                  ;
 41495                                  ; Switches are /a[value], /-a, /o[value], /-o, /s, /-s, /?, /b, /-b,
 41496                                  ; /w, /-w, /p, and /-p. The string values for /a and /o are optional,
 41497                                  ; do not require colons, and are not checked against a value list.
 41498                                  ;
 41499                                  ; Switch /h has been removed from the DIR command	;M008
 41500                                  ; Switch /? is no longer handled internally		;M008
 41501                                  ;
 41502                                  ; A list of pointers to all the switch synonyms is provided here to
 41503                                  ; help identify which switch has been matched.
 41504                                  
 41505                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 41506                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8815h
 41507                                  
 41508                                  PARSE_DIR:
 41509 00009858 [5B98]                  	dw	DIR_PARMS
 41510 0000985A 00                      	db	0			; no extra delimiters
 41511                                  DIR_PARMS:
 41512 0000985B 0001                    	db	0,1			; 1 optional positional param
 41513 0000985D [AE97]                  	dw	FILE_OPTIONAL2
 41514 0000985F 02                      	db	2			; 2 kinds of switches
 41515 00009860 [6598]                  	dw	DIR_SW_VALUED
 41516 00009862 [7798]                  	dw	DIR_SW_UNVALUED
 41517 00009864 00                      	db	0			; no keywords
 41518                                  
 41519                                  DIR_SW_VALUED:
 41520 00009865 0120                    	dw	2001h			; optional string value
 41521 00009867 2100                    	dw	21h			; optional colon; capitalize 
 41522 00009869 [07AA]                  	dw	PARSE1_OUTPUT		; result buffer
 41523 0000986B [9B97]                  	dw	NULL_VALUE_LIST		; don't validate value
 41524                                  
 41525                                  	; 18/06/2023
 41526                                  	;db	2
 41527                                  
 41528                                  ; MSDOS 6.0 COMMAND.COM
 41529                                  ;ifdef DBLSPACE_HOOKS
 41530                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41531 0000986D 03                      	db	3		; 3 'synonyms'
 41532                                  ;else
 41533                                  ;	db	2		; 2 'synonyms'
 41534                                  ;endif
 41535                                  
 41536                                  DIR_SW_A:
 41537 0000986E 2F4100                  	db	"/A",0
 41538                                  DIR_SW_O:
 41539 00009871 2F4F00                  	db	"/O",0
 41540                                  
 41541                                  ; MSDOS 6.0 COMMAND.COM
 41542                                  ;ifdef DBLSPACE_HOOKS
 41543                                  	; 18/06/2023
 41544                                  DIR_SW_C:
 41545 00009874 2F4300                  	db	"/C",0
 41546                                  ;endif
 41547                                  
 41548                                  DIR_SW_UNVALUED:
 41549 00009877 0000                    	dw	0			; no value
 41550 00009879 0000                    	dw	0			; no format functions
 41551 0000987B [07AA]                  	dw	PARSE1_OUTPUT		; result buffer
 41552 0000987D [9997]                  	dw	NO_VALUES
 41553                                  
 41554                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 41555                                  	;;db	12
 41556                                  	
 41557                                  	; 18/06/2023
 41558                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8839h
 41559                                  	;db	14		; 14 'synonyms' !?
 41560                                  
 41561                                  ; MSDOS 6.0 COMMAND.COM
 41562                                  ;ifdef DBLSPACE_HOOKS
 41563                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41564                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9DB0h
 41565 0000987F 0D                      	db	13		; 13 'synonyms'
 41566                                  ;else
 41567                                  ;	db	12		; 12 'synonyms'
 41568                                  ;endif
 41569                                  
 41570                                  DIR_SW_NEG_A:
 41571 00009880 2F2D4100                	db	"/-A",0
 41572                                  DIR_SW_NEG_O:
 41573 00009884 2F2D4F00                	db	"/-O",0
 41574                                  DIR_SW_S:
 41575 00009888 2F5300                  	db	"/S",0
 41576                                  DIR_SW_NEG_S:
 41577 0000988B 2F2D5300                	db	"/-S",0
 41578                                  DIR_SW_B:
 41579 0000988F 2F4200                  	db	"/B",0
 41580                                  DIR_SW_NEG_B:
 41581 00009892 2F2D4200                	db	"/-B",0
 41582                                  DIR_SW_W:
 41583 00009896 2F5700                  	db	"/W",0
 41584                                  DIR_SW_NEG_W:
 41585 00009899 2F2D5700                	db	"/-W",0
 41586                                  DIR_SW_P:
 41587 0000989D 2F5000                  	db	"/P",0
 41588                                  DIR_SW_NEG_P:
 41589 000098A0 2F2D5000                	db	"/-P",0
 41590                                  DIR_SW_L:
 41591 000098A4 2F4C00                  	db	"/L",0		;M010
 41592                                  DIR_SW_NEG_L:
 41593 000098A7 2F2D4C00                	db	"/-L",0 	;M010
 41594                                  
 41595                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41596                                  ; MSDOS 6.0 COMMAND.COM (DBLSPACE_HOOKS)
 41597                                  DIR_SW_NEG_C:
 41598 000098AB 2F2D4300                	db	"/-C",0
 41599                                  
 41600                                  ; Here's a list of pointers to DIR's switch synonyms, for easier
 41601                                  ; identification. Order is critical - DIR routines rely on the
 41602                                  ; specific order in this list. Negated options appear at odd 
 41603                                  ; positions in the list, and simple on/off options appear first.
 41604                                  
 41605                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41606                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9DE0h
 41607                                  Dir_Sw_Ptrs:			; list of ptrs to switch synonyms
 41608                                  	; 18/06/2023
 41609                                  	; MSDOS 6.0 COMMAND.COM ; *
 41610 000098AF [AB98]                  	dw	DIR_SW_NEG_C	; * 
 41611                                  Dir_Sw_Ptrs_2:
 41612 000098B1 [7498]                  	dw	DIR_SW_C	; *
 41613                                  	; MSDOS 5.0 COMMAND.COM	
 41614                                  ;Dir_Sw_Ptrs:
 41615 000098B3 [9998]                  	dw	DIR_SW_NEG_W
 41616                                  ;Dir_Sw_Ptrs_2:
 41617 000098B5 [9698]                  	dw	DIR_SW_W
 41618 000098B7 [A098]                  	dw	DIR_SW_NEG_P
 41619 000098B9 [9D98]                  	dw	DIR_SW_P
 41620 000098BB [8B98]                  	dw	DIR_SW_NEG_S
 41621 000098BD [8898]                  	dw	DIR_SW_S
 41622 000098BF [9298]                  	dw	DIR_SW_NEG_B
 41623 000098C1 [8F98]                  	dw	DIR_SW_B
 41624 000098C3 [A798]                  	dw	DIR_SW_NEG_L	;M010
 41625 000098C5 [A498]                  	dw	DIR_SW_L	;M010
 41626 000098C7 [8498]                  	dw	DIR_SW_NEG_O
 41627 000098C9 [7198]                  	dw	DIR_SW_O
 41628 000098CB [8098]                  	dw	DIR_SW_NEG_A
 41629 000098CD [6E98]                  	dw	DIR_SW_A
 41630                                  
 41631                                  ; PARSE BLOCK FOR RENAME
 41632                                  
 41633                                  ; The following parse control block can be used for any command which
 41634                                  ; needs only two required file specifications as operands. Returns
 41635                                  ; pointers to the unverified string in PARSE1_OUTPUT.
 41636                                  ; Currently used for the RENAME internal command.
 41637                                  
 41638                                  PARSE_RENAME:
 41639 000098CF [D298]                  	dw	RENAME_PARMS		;AN000;
 41640 000098D1 00                      	db	0			;AN000;  no extra delimiter
 41641                                  RENAME_PARMS:
 41642 000098D2 0202                    	db	2,2			;AN000;  2 positional parms
 41643 000098D4 [9C97]                  	dw	FILE_REQUIRED		;AN000;
 41644 000098D6 [9C97]                  	dw	FILE_REQUIRED		;AN000;
 41645 000098D8 00                      	db	0			;AN000;  no switches
 41646 000098D9 00                      	db	0			;AN000;  no keywords
 41647                                  
 41648                                  ; PARSE BLOCK FOR CTTY
 41649                                  
 41650                                  ; The following parse control block can be used for any command which
 41651                                  ; needs one required device name as an operand. Returns a pointer to
 41652                                  ; unverified string in PARSE1_OUTPUT. Currently used for the CTTY
 41653                                  ; internal command.
 41654                                  
 41655                                  PARSE_CTTY:
 41656 000098DA [DD98]                  	dw	CTTY_PARMS		;AN000;
 41657 000098DC 00                      	db	0			;AN000;  no extra delimiter
 41658                                  CTTY_PARMS:
 41659 000098DD 0101                    	db	1,1			;AN000;  1 positional parm
 41660 000098DF [E398]                  	dw	CTTY_CONTROL1		;AN000;
 41661 000098E1 00                      	db	0			;AN000;  no switches
 41662 000098E2 00                      	db	0			;AN000;  no keywords
 41663                                  CTTY_CONTROL1:
 41664 000098E3 0020                    	dw	2000h			;AN000;  string value - required
 41665 000098E5 1100                    	dw	11h			;AN000;  capitalize - file table
 41666                                  					;AN000;  remove colon at end
 41667 000098E7 [07AA]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41668 000098E9 [9997]                  	dw	NO_VALUES		;AN000;
 41669 000098EB 00                      	db	0			;AN000;  no keywords
 41670                                  
 41671                                  ; PARSE BLOCK FOR VER
 41672                                  
 41673                                  ; The following parse control block can be used for any command which
 41674                                  ; needs an optional switch "/debug". Currently used for the VER command.
 41675                                  
 41676                                  PARSE_VER:
 41677 000098EC [EF98]                  	dw	VER_PARMS
 41678 000098EE 00                      	db	0			; no extra delimiters
 41679                                  VER_PARMS:
 41680 000098EF 0000                    	db	0,0			; no positional parameters
 41681                                  ; 20/07/2024 - Retro DOS v4.2 COMMAND.COM
 41682                                  %if 0	; PCDOS 7.1 (& MSDOS 5.0-6.22) COMMAND.COM 
 41683                                  	db	1			; one switch
 41684                                  	dw	SLASH_R
 41685                                  %else
 41686                                  	; 20/07/2024 - Retro DOS v4-v5 COMMAND.COM
 41687 000098F1 02                      	db	2			; two switches
 41688 000098F2 [F798]                  	dw	SLASH_R
 41689 000098F4 [0399]                  	dw	SLASH_T ; Retro DOS v4-v5 COMMAND.COM switch
 41690                                  %endif
 41691 000098F6 00                      	db	0			; no keywords
 41692                                  SLASH_R:
 41693 000098F7 0000                    	dw	0			; no values
 41694 000098F9 0200                    	dw	2			; capitalize by filename table
 41695 000098FB [07AA]                  	dw	PARSE1_OUTPUT		; result buffer
 41696 000098FD [9997]                  	dw	NO_VALUES		; no values
 41697 000098FF 01                      	db	1			; one synonym
 41698                                  SLASH_R_SYN:
 41699 00009900 2F5200                  	db	"/R",0
 41700                                  
 41701                                  ; 20/07/2024 - Retro DOS v4.2 COMMAND.COM
 41702                                  %if 1
 41703                                  SLASH_T:
 41704 00009903 0000                    	dw	0			; no values
 41705 00009905 0200                    	dw	2			; capitalize by filename table
 41706 00009907 [07AA]                  	dw	PARSE1_OUTPUT		; result buffer
 41707 00009909 [9997]                  	dw	NO_VALUES		; no values
 41708 0000990B 01                      	db	1			; one synonym
 41709                                  SLASH_T_SYN:
 41710 0000990C 2F5400                  	db	"/T",0
 41711                                  %endif
 41712                                  
 41713                                  ; M003 ; Start of changes for LoadHigh support
 41714                                  
 41715                                  ;Parse Control Block for LOADHIGH command
 41716                                  
 41717                                  Parse_LoadHi:
 41718 0000990F [1299]                  	dw	LoadHi_Parms		;extended parm table
 41719 00009911 00                      	db	0			;no extra delimiters
 41720                                  
 41721                                  LoadHi_Parms:
 41722 00009912 0101                    	db	1,1			;min. 1 parm, max. 1 parm
 41723 00009914 [9C97]                  	dw	FILE_REQUIRED		;control struc for filename
 41724 00009916 00                      	db	0			;no switches
 41725 00009917 00                      	db	0			;no keywords
 41726                                  
 41727                                  ; M003 ; End of changes for LoadHigh support
 41728                                  
 41729                                  TempVarName:
 41730 00009918 54454D503D00            	db	"TEMP=",0
 41731                                  
 41732                                  	; 16/04/2023 - Retro DOS v4.0 (MSDOS 5.0) COMMAND.COM
 41733                                  ;TRANDATAEND:		; TRANGROUP:88C2h
 41734                                  
 41735                                  	; 18/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 41736                                  copycmd:
 41737 0000991E 434F5059434D443D        	db 'COPYCMD='
 41738                                  sCVFRoot:
 41739 00009926 5C44424C5350414345-     	db '\DBLSPACE.'
 41739 0000992F 2E                 
 41740                                  
 41741                                  ; ---------------------------------------------------------------------------
 41742                                  ; 20/07/2024 - Retro DOS v4.2 COMMAND.COM
 41743                                  %if 1
 41744 00009930 0D0A                    RD4CMD_VER_MSG:	db 0Dh,0Ah
 41745 00009932 526574726F20444F53-     		db 'Retro DOS v4.2 COMMAND.COM'
 41745 0000993B 2076342E3220434F4D-
 41745 00009944 4D414E442E434F4D   
 41746 0000994C 0D0A                    		db 0Dh,0Ah 
 41747 0000994E 32303234202D204572-     		db '2024 - Erdogan Tan'
 41747 00009957 646F67616E2054616E 
 41748 00009960 0D0A                    		db 0Dh,0Ah
 41749 00009962 24                      		db '$'
 41750                                  %endif
 41751                                  ; ---------------------------------------------------------------------------
 41752                                  
 41753                                  	; 18/06/2023
 41754                                  	; MSDOS 6.22 COMMAND.COM
 41755                                  TRANDATAEND:		; TRANGROUP:9E53h
 41756                                  
 41757                                  ;============================================================================
 41758                                  ; PSDATA.INC, MSDOS 6.0, 1991
 41759                                  ;============================================================================
 41760                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41761                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41762                                  
 41763                                  ; 18/04/2023
 41764                                  TRANSPACESTART:
 41765                                  
 41766                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:88C2h
 41767                                  	
 41768                                  	; 18/06/2023
 41769                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9E53h
 41770                                  
 41771                                  ;********************** Local Data *************************************
 41772                                  
 41773                                  $P_ORDINAL:
 41774 00009963 0000                    	dw	0		;AN000; Operand ordinal save area
 41775                                  $P_RC:
 41776 00009965 0000                    	dw	0		;AN000; Return code from parser
 41777                                  $P_SI_Save:
 41778 00009967 0000                    	dw	0		;AN000; Pointer of command buffer
 41779                                  $P_DX:
 41780 00009969 0000                    	dw	0		;AN000; Return result buffer address
 41781                                  $P_Terminator:
 41782 0000996B 00                      	db	0		;AN000; Terminator code (ASCII)
 41783                                  $P_DBCSEV_OFF:
 41784 0000996C 0000                    	dw	0		;AN000; Offset of DBCS EV
 41785                                  $P_DBCSEV_SEG:
 41786 0000996E 0000                    	dw	0		;AN000; Segment of DBCS EV
 41787                                  $P_Flags:			;AN000; Parser internal flags
 41788                                  $P_Flags1:
 41789 00009970 00                      	db	0		;AN038; to reference first byte flags
 41790                                  $P_Flags2:
 41791 00009971 00                      	db	0		;AN038; to reference second byte flags only
 41792                                  $P_SaveSI_Cmpx:
 41793 00009972 0000                    	dw	0		;AN000; save si for later use by complex
 41794                                  $P_KEYorSW_Ptr:
 41795 00009974 0000                    	dw	0		;AN000; points next to "=" or ":" code
 41796                                  $P_Save_EOB:
 41797 00009976 0000                    	dw	0		;AN000; save pointer to EOB
 41798                                  $P_Found_SYNONYM:
 41799 00009978 0000                    	dw	0		;AN000; es:@ points to found synonym
 41800                                  $P_STRING_BUF:
 41801 0000997A 00<rep 80h>             	times  128 db 0		;AN000; Pick a operand from command line
 41802                                  $P_ORIG_ORD:
 41803 000099FA 0000                    	dw	0		;AN039; ORIGINAL ORDINAL FROM CX
 41804                                  $P_ORIG_STACK:
 41805 000099FC 0000                    	dw	0		;AN039; ORIGINAL VALUE OF STACK FROM SP
 41806                                  $P_ORIG_SI:
 41807 000099FE 0000                    	dw	0		;AN039; ORIGINAL START PARSE POINTER FROM SI
 41808                                  $P_Got_Time:
 41809 00009A00 00                      	db	0		;AN023; if 1, use Time delimiters
 41810                                  $P_Country_Info:
 41811 00009A01 FFFF                    	dw	-1 ; 0FFFFh
 41812 00009A03 00<rep 20h>             	times	32 db 0	
 41813                                  $P_1st_Val:
 41814 00009A23 0000                    	dw	0		;AN000; used when process date or time
 41815                                  $P_2nd_Val:
 41816 00009A25 0000                    	dw	0		;AN000; used when process date or time
 41817                                  $P_3rd_Val:
 41818 00009A27 0000                    	dw	0		;AN000; used when process date or time
 41819                                  $P_4th_Val:
 41820 00009A29 0000                    	dw	0		;AN000; used when process date or time
 41821                                  $P_Char_CAP_Ptr:
 41822 00009A2B FF                      	db	0FFh		;AN000; info id
 41823 00009A2C 0000                    	dw	0		;AN000; offset	of char case map table
 41824 00009A2E 0000                    	dw	0		;AN000; segment of char case map table
 41825                                  $P_File_CAP_Ptr:
 41826 00009A30 FF                      	db	0FFh		;AN000; info id
 41827 00009A31 0000                    	dw	0		;AN000; offset	of file case map table
 41828 00009A33 0000                    	dw	0		;AN000; segment of file case map table
 41829                                  
 41830                                  	; 18/04/2023
 41831                                  ;M029
 41832                                  ;!!!WARNING!!!
 41833                                  ; In routine SYSPARSE (parse.asm), $P_FileSp_Char is reinitialized using 
 41834                                  ;hardcoded strings. If the chars in the string are changed here, corresponding
 41835                                  ;changes need to be made in SYSPARSE
 41836                                  
 41837                                  $P_FileSp_Char:
 41838 00009A35 5B5D7C3C3E2B3D3B22      	db	'[]|<>+=;"'     ;AN000; delimitter of file spec
 41839                                  $P_FileSp_Len equ $-$P_FileSp_Char ;AN000;
 41840                                  
 41841                                  ;filespec error flag
 41842                                  $P_err_flag:
 41843 00009A3E 00                      	db	0		;AN033; flag set if filespec parsing error
 41844                                  				;AN033;  was detected.
 41845                                  
 41846                                  ;============================================================================
 41847                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 41848                                  ;============================================================================
 41849                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41850                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41851                                  
 41852                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:899Eh
 41853                                  
 41854                                  	; 18/06/2023
 41855                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9F2Fh
 41856                                  
 41857                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 41858                                  ;;
 41859                                  ;; STRUCTURE: $M_RES_ADDRS
 41860                                  ;;
 41861                                  ;; Resident data area definition of variables
 41862                                  ;;
 41863                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 41864                                  
 41865                                  $M_RT:
 41866 00009A3F 00<rep 8Dh>             	times $M_RES_ADDRS_SZ db 0   ; times 141 db 0
 41867                                  
 41868                                  ;============================================================================
 41869                                  ; COPYRIGHT.INC, MSDOS 6.0, 1993
 41870                                  ;============================================================================
 41871                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41872                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41873                                  
 41874                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8A2Bh
 41875                                  ; ---------------------------------------------------------------------------
 41876                                  ;;M00 - changed to DOS 5.0 copyright - MD 9 Jul 90
 41877                                  ;;M031 - changed copyright to 1991
 41878                                  ;;9/16 - changed version to 6.0 and copyright to 1992
 41879                                  ;;9/21 - Added international translations, language passed through COUNTRY macro
 41880                                  ;;B49,50 - changed version to 6 and copyright to 1993
 41881                                  ; ---------------------------------------------------------------------------
 41882                                  	
 41883                                  	; 18/06/2023
 41884                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9FBCh
 41885                                  ;ifdef USA
 41886                                  MsDosVer6_CCopy:
 41887                                  	; MSDOS 6.0
 41888                                  	;db	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
 41889                                  	; 18/06/2023
 41890                                  	; MSDOS 6.22
 41891 00009ACC 4D5320444F53205665-     	db	"MS DOS Version 6 (C)Copyright 1981-1994 Microsoft Corp "
 41891 00009AD5 7273696F6E20362028-
 41891 00009ADE 4329436F7079726967-
 41891 00009AE7 687420313938312D31-
 41891 00009AF0 393934204D6963726F-
 41891 00009AF9 736F667420436F7270-
 41891 00009B02 20                 
 41892 00009B03 4C6963656E73656420-     	db	"Licensed Material - Property of Microsoft "
 41892 00009B0C 4D6174657269616C20-
 41892 00009B15 2D2050726F70657274-
 41892 00009B1E 79206F66204D696372-
 41892 00009B27 6F736F667420       
 41893 00009B2D 416C6C207269676874-     	db	"All rights reserved "
 41893 00009B36 732072657365727665-
 41893 00009B3F 6420               
 41894                                  ;endif
 41895                                  
 41896                                  ; ---------------------------------------------------------------------------
 41897                                  ; 18/06/2023
 41898                                  ; 15/04/2023
 41899                                  ;MsDosVer5_CCopy:
 41900                                  	;db	"MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp "
 41901                                  	;db	"Licensed Material - Property of Microsoft "
 41902                                  	;db	"All rights reserved "
 41903                                  ; ---------------------------------------------------------------------------
 41904                                  ; 15/04/2023
 41905                                  	; 16/04/2023 - 21/04/2023
 41906                                  	;db 	0
 41907                                  	;db	0Dh,0Ah
 41908                                  	;db	'Retro DOS v4.0 (& v4.1) COMMAND.COM '
 41909                                  	;db	0
 41910                                  	;db	'by Erdogan Tan - 05/05/2023'
 41911                                  	;db	0
 41912                                  
 41913                                  	; 19/06/2023
 41914                                  	; 18/06/2023
 41915                                  	;db 	0
 41916                                  	;db	0Dh,0Ah
 41917                                  	;db	'Retro DOS v4.2 COMMAND.COM '
 41918                                  	;db	0
 41919                                  	;db	'by Erdogan Tan - 19/6/2023'
 41920                                  	;db	0
 41921                                  
 41922                                  ;============================================================================
 41923                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 41924                                  ;============================================================================
 41925                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41926                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41927                                  
 41928                                  PRINTF_HANDLE:
 41929 00009B41 0000                    	dw	0		;AC000;
 41930                                  
 41931                                  ;============================================================================
 41932                                  ; TSPC.ASM, MSDOS 6.0, 1991
 41933                                  ;============================================================================
 41934                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41935                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41936                                  
 41937                                  ;TITLE	COMMAND Transient Uninitialized DATA
 41938                                  
 41939                                  ;The TRANSPACE segment contains variable data that is considered
 41940                                  ;volatile between command cycles, and therefore is not included in the
 41941                                  ;transient checksum area. Contents of these variables MUST be
 41942                                  ;initialized before use, and must not be relied upon from command
 41943                                  ;cycle to command cycle.
 41944                                  ;
 41945                                  ;No constant data values should be stored here.
 41946                                  
 41947                                  ; ---------------------------------------------------------------------------
 41948                                  ; START OF UNITIALIZED DATA
 41949                                  ; ---------------------------------------------------------------------------
 41950                                  
 41951                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8AA5h
 41952                                  
 41953                                  	; 18/06/2023
 41954                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 0A033h
 41955                                  
 41956 00009B43 00<rep 57h>             SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 41957 00009B9A 00<rep 57h>             TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 41958 00009BF1 00<rep 83h>             UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 41959 00009C74 00<rep 83h>             COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 41960 00009CF7 00<rep 46h>             USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 41961 00009D3D 00<rep 83h>             EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 41962 00009DC0 00<rep 53h>             RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 41963                                  
 41964                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 41965                                  HEADCALL:
 41966 00009E13 0000                    	dw 0			; TRANVARS  (dw THEADFIX)
 41967 00009E15 0000                    RESSEG:	dw 0			; MYSEG     (dw 0) 	 	
 41968 00009E17 0000                    TPA:	dw 0			; LTPA	    (dw 0)	
 41969                                  SWITCHAR:
 41970 00009E19 00                      	db 0			; RSWITCHAR (db '-')
 41971                                  DIRCHAR:
 41972 00009E1A 00                      	db 0			; RDIRCHAR  (db '/')
 41973                                  EXEC_ADDR:
 41974 00009E1B 00000000                	dd 0			; 	    (dw EXT_EXEC)	 
 41975                                  				; MYSEG1    (dw 0)	
 41976                                  RCH_ADDR:
 41977 00009E1F 00000000                	dd 0			;	    (dw TREMCHECK) 	
 41978                                  				; MYSEG2    (dw 0)	
 41979 00009E23 0000                    	dw 0			; RESTEST   (dw 0)	
 41980                                  TRAN_TPA:
 41981 00009E25 0000                    	dw 0			; RES_TPA   (dw 0)	
 41982                                  
 41983 00009E27 00                      CHKDRV:	db 0
 41984                                  IFNOTFLAG:
 41985                                  FILTYP:
 41986 00009E28 00                      RDEOF:	db 0			; Misc flags
 41987 00009E29 00                      CURDRV:	db 0
 41988                                  PARM1:
 41989 00009E2A 00                      Concat:	db 0
 41990                                  PARM2:
 41991 00009E2B 00                      ArgC:	db 0
 41992 00009E2C 0000                    COMSW:	dw 0			; Switches between command and 1st arg
 41993 00009E2E 0000                    ARG1S:	dw 0			; Switches between 1st and 2nd arg
 41994                                  ARG2S:				; Switches after 2nd arg		
 41995                                  DestSwitch:
 41996 00009E30 0000                    	dw 0
 41997                                  ARGTS:
 41998                                  AllSwitch:
 41999 00009E32 0000                    	dw 0			; ALL switches except for COMSW
 42000 00009E34 00                      CFLAG:	db 0
 42001                                  DestClosed:
 42002                                  SPECDRV:
 42003 00009E35 00                      	db 0
 42004 00009E36 0000                    BYTCNT:	dw 0			; Size of buffer between RES and TRANS
 42005                                  
 42006                                  ; 18/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 42007                                  ;ifdef DBLSPACE_HOOKS
 42008                                  savBytCnt: ; MSDOS 6.0
 42009 00009E38 0000                    	dw 0
 42010                                  ;endif
 42011                                  	
 42012 00009E3A 0000                    NXTADD:	dw 0
 42013                                  FRSTSRCH:
 42014 00009E3C 00                      	db 0
 42015                                  ; 15/04/2023
 42016                                  LeftOnLine:
 42017 00009E3D 00                      	db 0			; entries left on line u.b. DIR
 42018                                  PerLine:
 42019 00009E3E 00                      	db 0			; entries/line u.b. DIR
 42020 00009E3F 00                      LINCNT:	db 0
 42021 00009E40 00                      LINLEN:	db 0
 42022                                  LeftOnPage:
 42023 00009E41 0000                    	dw 0			; lines left on page u.b. DIR
 42024                                  FileCnt:
 42025 00009E43 0000                    	dw 0			; file count u.b. DIR
 42026                                  FileSiz:
 42027 00009E45 00000000                	dd 0			; file size u.b. DIR
 42028                                  
 42029                                  ; Note: keep FileCntTotal through csecUsedTotal together!
 42030                                  
 42031                                  FileCntTotal:
 42032 00009E49 00000000                	dd 0			; total file count u.b. DIR
 42033                                  FileSizTotal:
 42034 00009E4D 00000000                	dd 0			; total file size u.b. DIR
 42035                                  
 42036                                  	; 18/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 42037                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 0A33Fh
 42038                                  	; MSDOS 6.0
 42039                                  ;ifdef DBLSPACE_HOOKS
 42040                                  ccluUsed:
 42041 00009E51 0000                    	dw 0			; count of DOS clusters used
 42042                                  ccluUsedDir:
 42043 00009E53 0000                    	dw 0			
 42044                                  ccluUsedTotal:
 42045 00009E55 0000                    	dw 0			
 42046                                  csecUsed:
 42047 00009E57 00000000                	dd 0			; count of comp sectors used
 42048                                  csecUsedDir:
 42049 00009E5B 00000000                	dd 0			
 42050                                  csecUsedTotal:
 42051 00009E5F 00000000                	dd 0			
 42052                                  
 42053                                  ; Note:  keep FileCntTotal through csecUsedTotal together!
 42054                                  
 42055                                  fhCVF:
 42056 00009E63 0000                    	dw 0			; Compressed Volume File handle
 42057                                  szCVF:
 42058 00009E65 00<rep 10h>             	times	16 db 0		; "X:\\12345678.123\0"
 42059                                  MDBPB:
 42060                                  	;MD_BPB	<>		; Extended MagicDrv BPB
 42061 00009E75 00<rep 40h>             	times	64 db 0
 42062                                  csecPerCluster:
 42063 00009EB5 00                      	db 0			; sectors/cluster for ratio calc
 42064                                  fUseHostSize:
 42065 00009EB6 00                      	db 0			; NZ if using host cluster size
 42066                                  cFATEntries:
 42067 00009EB7 0000                    	dw 0			; # FAT entries in buffers
 42068                                  entInBuf:
 42069 00009EB9 0000                    	dw 0			; 1st entry # in FAT buffers
 42070                                  segFATBuf:
 42071 00009EBB 0000                    	dw 0			; seg of DOS & MD FAT buffers
 42072                                  pbufDOSFAT:
 42073 00009EBD 0000                    	dw 0			; off of DOS FAT buffer
 42074                                  pbufMDFAT:
 42075 00009EBF 0000                    	dw 0			; off of MD FAT buffer
 42076                                  bufDOSFAT:
 42077                                  	;times (cRES_FAT_ENTRIES*2) db 0
 42078 00009EC1 00<rep 40h>             	times 64 db 0	 	; small DOS FAT buffer
 42079                                  bufMDFAT:
 42080                                  	;times (cRES_FAT_ENTRIES*4) db 0
 42081 00009F01 00<rep 80h>             	times 128 db 0		; small MD FAT buffer
 42082                                  ;endif
 42083                                  
 42084                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8DAFh
 42085                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 0A46Fh
 42086                                  CHARBUF:
 42087 00009F81 00<rep 50h>             	times	80 db 0		;line byte character buffer for xenix write
 42088                                  DESTFCB2:
 42089 00009FD1 00                      IDLEN:	db 0
 42090 00009FD2 00<rep 8h>              ID:	times	8  db 0
 42091 00009FDA 00<rep 3h>              COM:	times	3  db 0 
 42092 00009FDD 00<rep 25h>             DEST:	times	37 db 0
 42093                                  DESTNAME:
 42094 0000A002 00<rep Bh>              	times	11 db 0
 42095                                  DESTDIR:
 42096                                  DestFcb:
 42097 0000A00D 00<rep 43h>             	times DIRSTRLEN db 0 ; 67 ; Directory for PATH searches
 42098                                  GOTOLEN: ; word
 42099                                  BWDBUF:  ; byte
 42100                                  EXEFCB:  ; word
 42101 0000A050 00<rep 46h>             DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 42102                                  
 42103                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 42104                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 42105                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 42106                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 42107                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 42108                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 42109                                  
 42110                                  	; 16/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 42111                                  
 42112                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42113                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0A584h
 42114                                  SDIRBUF:
 42115 0000A096 00<rep Ch>              	times 12 db 0	
 42116                                  _Bits:
 42117 0000A0A2 0000                    	dw 0
 42118                                  PathCnt:
 42119 0000A0A4 0000                    	dw 0
 42120                                  PathPos:
 42121 0000A0A6 0000                    	dw 0
 42122 0000A0A8 0000                    PathSw:	dw 0
 42123                                  AttrSpecified:
 42124 0000A0AA 00                      	db 0			; attribute bits u.b. DIR
 42125                                  AttrSelect:
 42126 0000A0AB 00                      	db 0			; attribute bits u.b. DIR
 42127 0000A0AC 00                      comma:	db 0			; flag set if +,, occurs
 42128                                  plus_comma:
 42129 0000A0AD 00                      	db 0			; flag set if +,, occurs
 42130                                  DirFlag:
 42131 0000A0AE 00                       	db 0			;AN015; set when pathcrunch called from DIR
 42132                                  parse_last:
 42133 0000A0AF 0000                    	dw 0			;AN018; used to hold parsing position
 42134                                  system_cpage:
 42135 0000A0B1 0000                    	dw 0			;AC001; used for CHCP variable
 42136                                  ; 03/08/2024
 42137                                  ;Arg_Buf:
 42138                                  ;	times 128 db 0	
 42139                                  File_Size_Low:
 42140 0000A0B3 0000                    	dw 0	
 42141                                  File_Size_High:
 42142 0000A0B5 0000                    	dw 0		
 42143                                  string_ptr_2:
 42144 0000A0B7 0000                    	dw 0	
 42145                                  Copy_num:
 42146 0000A0B9 0000                    	dw 0
 42147                                  cpyflag:
 42148 0000A0BB 00                      	db 0
 42149                                  Dir_Num:
 42150 0000A0BC 0000                    	dw 0
 42151                                  
 42152                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42153                                  	; MSDOS 6.0
 42154                                  ;ifdef DBLSPACE_HOOKS
 42155                                  Dir_CRatio_1:
 42156 0000A0BE 00                      	db 0
 42157                                  Dir_CRatio_2:
 42158 0000A0BF 00                      	db 0
 42159                                  ;endif
 42160                                  
 42161                                  Bytes_Free:
 42162 0000A0C0 00000000                	dd 0
 42163                                  
 42164                                  Major_Ver_Num:
 42165 0000A0C4 0000                    	dw 0
 42166                                  Minor_Ver_Num:
 42167 0000A0C6 0000                    	dw 0
 42168                                  
 42169                                  One_Char_Val:
 42170 0000A0C8 00                      	db 0
 42171 0000A0C9 00                      	db 0
 42172                                  vol_drv:
 42173 0000A0CA 00                      	db 0
 42174                                  ROM_CALL:
 42175 0000A0CB 00                      	db 0			; flag for rom function
 42176 0000A0CC 0000                    ROM_IP:	dw 0
 42177 0000A0CE 0000                    ROM_CS:	dw 0
 42178                                  
 42179                                  DestVars:
 42180                                  DestIsDir:
 42181 0000A0D0 00                      	db 0
 42182                                  DestSiz:
 42183 0000A0D1 00                      	db 0
 42184                                  DestTail:
 42185 0000A0D2 0000                    	dw 0
 42186                                  DestInfo:
 42187 0000A0D4 00                      	db 0
 42188                                  DestBuf:
 42189 0000A0D5 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 42190                                  EndDestBuf:
 42191                                  DESTHAND:
 42192 0000A12C 0000                    	dw 0
 42193                                  DESTISDEV:
 42194 0000A12E 00                      	db 0
 42195                                  FIRSTDEST:
 42196 0000A12F 00                      	db 0
 42197                                  MELCOPY:
 42198 0000A130 00                      	db 0
 42199                                  MELSTART:
 42200 0000A131 0000                    	dw 0
 42201                                  SrcVars:
 42202                                  SrcIsDir:
 42203 0000A133 00                      	db 0
 42204 0000A134 00                      SrcSiz:	db 0
 42205                                  SrcTail:
 42206 0000A135 0000                    	dw 0
 42207                                  SrcInfo:
 42208 0000A137 00                      	db 0
 42209                                  SrcBuf:
 42210 0000A138 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 42211                                  SRCHAND:
 42212 0000A18F 0000                    	dw 0
 42213                                  SRCISDEV:
 42214 0000A191 00                      	db 0
 42215                                  ScanBuf:
 42216 0000A192 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 42217                                  
 42218 0000A1E9 0000                    SRCPT:	dw 0
 42219                                  INEXACT:
 42220 0000A1EB 00                      	db 0
 42221                                  NOWRITE:
 42222 0000A1EC 00                      	db 0
 42223                                  BINARY:
 42224 0000A1ED 00                      	db 0
 42225                                  WRITTEN:
 42226 0000A1EE 0000                    	dw 0
 42227                                  TERMREAD:
 42228 0000A1F0 00                      	db 0
 42229 0000A1F1 00                      ASCII:	db 0
 42230 0000A1F2 00                      PLUS:	db 0
 42231 0000A1F3 00                      objcnt:	db 0			; Used in copy
 42232 0000A1F4 0000                    CPDATE:	dw 0
 42233 0000A1F6 0000                    CPTIME:	dw 0
 42234                                  
 42235                                  OFilePtr_Lo:
 42236 0000A1F8 0000                    	dw 0			; original file ptr for COPY when
 42237                                  OFilePtr_Hi:
 42238 0000A1FA 0000                    	dw 0			; 1st source is also destination
 42239 0000A1FC 00                      OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 42240                                  
 42241                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42242                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0A76Bh
 42243                                  cox_sublist_buff:
 42244 0000A1FD 00<rep Bh>              	times 11 db 0
 42245                                  cox_y_override:
 42246 0000A208 00                      	db 0
 42247                                  cox_dest_file:
 42248 0000A209 00                      	db 0
 42249                                  cox_src_file:
 42250 0000A20A 00                      	db 0
 42251                                  
 42252                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:0A779h)
 42253                                  BATHAND:
 42254 0000A20B 0000                    	dw 0			; Batch handle
 42255                                  STARTEL:
 42256 0000A20D 0000                    	dw 0
 42257 0000A20F 00                      ELCNT:	db 0
 42258 0000A210 00                      ELPOS:	db 0
 42259                                  
 42260                                  ; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 42261                                  ; MSDOS 5.0
 42262                                  SKPDEL:
 42263                                  	; 18/06/2023
 42264 0000A211 00                      	db 0	; MSDOS 6.22 (& MSDOS 5.0)  	
 42265 0000A212 00<rep Bh>              SOURCE:	times 11 db 0
 42266                                  
 42267                                  ext_entered:
 42268 0000A21D 00                      	db 0			;AN005;
 42269                                  
 42270                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:90BCh
 42271                                  
 42272                                  Display_Ioctl:
 42273 0000A21E 00                      	db 0			;AN000; info level
 42274 0000A21F 00                      	db 0			;AN000; reserved
 42275 0000A220 0E00                    	dw crt_ioctl_ln		;AN000; length of data
 42276 0000A222 0000                    	dw 0			;AN000; control flags
 42277                                  display_mode:
 42278 0000A224 00                      	db 0			;AN000; display mode, colors
 42279 0000A225 00                      	db 0			;AN000; reserved
 42280 0000A226 0000                    	dw 0			;AN023; colors
 42281 0000A228 0000                    	dw 0			;AN000; display width (PELS)
 42282 0000A22A 0000                    	dw 0			;AN000; display length (PELS)
 42283                                  display_width:
 42284 0000A22C 0000                    	dw 0			;AN000; display width
 42285                                  LinPerPag:
 42286 0000A22E 1900                    	dw LINESPERPAGE	; 25	;AN000; display length (default to linesperpage)
 42287                                  
 42288                                  vol_ioctl_buf:			;AN000; buffer for ioctl volume label/serial call
 42289 0000A230 0000                    	dw 0			;AN000; info level
 42290                                  vol_serial:
 42291 0000A232 00000000                	dd 0			;AN000; volume serial number
 42292                                  vol_label:
 42293 0000A236 20<rep Bh>              	times 11 db 20h ; " "	;AN000; volume label - init to blanks
 42294 0000A241 20<rep 8h>              	times 8  db 20h ; " "	;AN000; file system type
 42295                                  
 42296                                  expand_star:
 42297 0000A249 00                      	db 0
 42298                                  
 42299                                  msg_flag:
 42300 0000A24A 00                      	db 0			;AN022; flag set if non-utility message issued
 42301                                  Msg_Numb:
 42302 0000A24B 0000                    	dw 0			;AN022; set with extended error message issued
 42303                                  append_exec:
 42304 0000A24D 00                      	db 0			;AN041; set if internal append executed
 42305                                  print_err_flag:
 42306 0000A24E 0000                    	dw 0			;AN000; flag set if error during sysdispmsg
 42307                                  subst_buffer:
 42308 0000A250 00<rep 16h>             	times parm_block_size*2 db 0 ; times 22 db 0 
 42309                                  				;AN061;
 42310                                  ; 15/04/2023
 42311 0000A266 00                      KPARSE:	db 0	; 3/3/KK	
 42312                                  
 42313                                  ; Data declarations taken out of parse.asm
 42314                                  
 42315                                  ; MSDOS 6.0
 42316                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 42317                                  ;argbufptr	dw	?		; index for argv[].argpointer
 42318                                  ;tpbuf		db	128 DUP (?)	; temporary buffer
 42319                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 42320                                  ;comptr		dw	?		; ptr into combuf
 42321                                  
 42322                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9105h
 42323                                  
 42324                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42325                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 0A7D5h
 42326                                  ARG:
 42327                                  ARG_ARGV:
 42328                                  ARGV0_ARGPOINTER:
 42329 0000A267 0000                    	dw 0	; ARGV[0]
 42330                                  ARGV0_ARG_FLAGS:
 42331 0000A269 00                      	db 0
 42332                                  ARGV0_ARGSTARTEL:
 42333 0000A26A 0000                    	dw 0
 42334                                  ARGV0_ARGLEN:
 42335 0000A26C 0000                    	dw 0
 42336                                  ARGV0_ARGSW_WORD:
 42337 0000A26E 0000                    	dw 0
 42338                                  ARGV0_OCOMPTR:
 42339 0000A270 0000                    	dw 0
 42340                                  ARGV1_ARGPOINTER:
 42341 0000A272 0000                    	dw 0	; ARGV[1]	
 42342 0000A274 00<rep 5h>              	times 5 db 0
 42343                                  ARGV1_ARGSW_WORD:
 42344 0000A279 0000                    	dw 0
 42345 0000A27B 0000                    	dw 0
 42346                                  ARGV2_ARGPOINTER:
 42347 0000A27D 0000                    	dw 0	; ARGV[2]
 42348 0000A27F 00<rep 5h>              	times 5 db 0
 42349                                  ARGV2_ARGSW_WORD:
 42350 0000A284 0000                    	dw 0
 42351 0000A286 0000                    	dw 0
 42352 0000A288 00<rep 29Fh>            	times 671 db 0  ; ARGV[3] to ARGV[63]
 42353                                  ARG_ARGVCNT:
 42354 0000A527 0000                    	dw 0
 42355                                  ARG_ARGSWINFO:
 42356 0000A529 0000                    	dw 0
 42357                                  ARG_ARGBUF:
 42358 0000A52B 0000<rep 100h>          	times 256 dw 0	; times ARGBLEN dw 0 
 42359                                  ARG_ARGFORCOMBUF:
 42360 0000A72B 00<rep 80h>             	times 128 db 0  ; times COMBUFLEN db 0 
 42361                                  
 42362                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9649h
 42363                                  	; 18/06/2023
 42364                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 0AD19h
 42365                                  ARGBUF_PTR:
 42366 0000A7AB 0000                    	dw 0			; index for argv[].argpointer
 42367                                  TPBUF:	;times 128 db 0		; temporary buffer
 42368                                  Arg_Buf:
 42369 0000A7AD 00<rep 80h>             	times 128 db 0	; 03/08/2024 (PCDOS 7.1 COMMAND.COM)
 42370                                  LASTARG:
 42371 0000A82D 0000                    	dw 0			; point at which to accumulate switch info
 42372 0000A82F 0000                    COMPTR:	dw 0			; ptr into combuf
 42373                                  
 42374                                  ; Data declarations taken out of path.asm
 42375                                  ;fbuf	find_buf	<>		; dma buffer for findfirst/findnext
 42376                                  ;pathinfo	DW	3 DUP (?)	; ES, SI(old), and SI(new) of user path
 42377                                  ;psep_char	DB	?		; '/' or '\'
 42378                                  ;search_best	DB	(?)		; best code, best filename so far
 42379                                  ;fname_max_len	equ	13
 42380                                  ;search_best_buf DB	fname_max_len DUP (?)
 42381                                  ;search_curdir_buf DB	64 DUP (?)	; a place for CurDir info, if successful
 42382                                  ;search_error	DW	(?)		; address of error message to be printed
 42383                                  
 42384                                  FINDBUFLEN equ FIND_BUF.size ; 43
 42385                                  
 42386                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 96CFh
 42387                                  
 42388                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42389                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0AD9Fh
 42390                                  
 42391 0000A831 00<rep 2Bh>             FBUF:	times FINDBUFLEN db 0	; times 43 db 0
 42392                                  FBUF_PNAME equ FBUF+30		; packed name, 13 bytes
 42393                                  pathinfo:
 42394                                  ;pathinfo_0:
 42395 0000A85C 0000                    	dw 0
 42396                                  ;pathinfo_2:
 42397 0000A85E 0000                    	dw 0
 42398                                  ;pathinfo_4:
 42399 0000A860 0000                    	dw 0
 42400                                  psep_char:
 42401 0000A862 00                      	db 0
 42402                                  search_best:
 42403 0000A863 00                      	db 0
 42404                                  FNAME_MAX_LEN equ 13
 42405                                  search_best_buf:
 42406 0000A864 00<rep Dh>              	times FNAME_MAX_LEN db 0 ; times 13 db 0
 42407                                  search_curdir_buf:
 42408 0000A871 00<rep 40h>             	times 64 db 0
 42409                                  search_error:
 42410 0000A8B1 0000                    	dw 0
 42411                                  
 42412                                  ; Data declarations taken out of tbatch.asm
 42413                                  
 42414                                  ;if_not_count	DW	?
 42415                                  ;
 42416                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 42417                                  ;
 42418                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 42419                                  
 42420                                  ; 31/03/2023
 42421                                  ;STACK:	;LABEL	WORD
 42422                                  
 42423                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9751h
 42424                                  
 42425                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42426                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0AE21h
 42427                                  
 42428                                  IF_NOT_COUNT:
 42429 0000A8B3 0000                    	dw 0
 42430 0000A8B5 00                      zflag:	db 0
 42431                                  
 42432                                  align 2	; 18/06/2023
 42433                                  
 42434 0000A8B6 00<rep 100h>            	times 256 db 0 
 42435                                  
 42436                                  	; 16/04/2023
 42437                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:9854h
 42438                                  
 42439                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42440                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0AF24h
 42441                                  STACK:
 42442                                  
 42443                                  ;INTERNATVARS	internat_block <>
 42444                                  ;	db	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 42445                                  
 42446                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9854h
 42447                                  INTERNATVARS:
 42448                                  		; (24+8 = 32 bytes)
 42449                                  DATE_TIME_FORMAT:
 42450 0000A9B6 0000                    	dw 0			; 0-USA, 1-EUR, 2-JAP
 42451                                  CURRENCY_SYM:
 42452 0000A9B8 0000000000              	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 42453                                  THOUS_SEP:
 42454 0000A9BD 0000                    	db 0,0			; Thousands separator 2 bytes
 42455                                  DECIMAL_SEP:
 42456 0000A9BF 0000                    	db 0,0			; Decimal separator 2 bytes
 42457                                  DATE_SEP:
 42458 0000A9C1 0000                    	db 0,0			; Date separator 2 bytes
 42459                                  TIME_SEP:
 42460 0000A9C3 0000                    	db 0,0			; Time separator 2 bytes	
 42461                                  BIT_FIELD:
 42462 0000A9C5 00                      	db 0			; Bit values
 42463                                  				;   Bit 0 = 0 if currency symbol first
 42464                                  				;	  = 1 if currency symbol last
 42465                                  				;   Bit 1 = 0 if No space after currency symbol
 42466                                  				;	  = 1 if space after currency symbol
 42467                                  CURRENCY_CENTS:
 42468 0000A9C6 00                      	db 0			; Number of places after currency dec point
 42469                                  TIME_24:
 42470 0000A9C7 00                      	db 0			; 1 if 24 hour time, 0 if 12 hour time
 42471                                  MAP_CALL:
 42472 0000A9C8 00000000                	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 42473                                  				; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 42474                                  				;  in pieces.
 42475                                  DATA_SEP:
 42476 0000A9CC 0000                    	db 0,0			; Data list separator character		
 42477                                  
 42478 0000A9CE 00<rep 8h>              	times 8 db 0
 42479                                  
 42480                                  ; Max size of the block returned by the INTERNATIONAL call
 42481                                  
 42482                                  INTERNAT_BLOCK_SIZE EQU	32
 42483                                  
 42484                                  ;;	Buffer for DOS function 64h (Get extended country information)
 42485                                  ;;	subfunctions 2, 4, 6, or 7:
 42486                                  ;
 42487                                  ;CountryPtrInfo	label	byte
 42488                                  ;CountryPtrId	db	?
 42489                                  ;CountryPtr	dd	?
 42490                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 42491                                  	
 42492                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9874h
 42493                                  CountryPtrInfo:
 42494                                  CountryPtrId:	
 42495 0000A9D6 00                      	db 0
 42496                                  CountryPtr:
 42497 0000A9D7 00000000                	dd 0
 42498                                  
 42499                                  OldCtrlCHandler:
 42500 0000A9DB 00000000                	dd 0			; previous int 23 vector		
 42501                                  
 42502                                  BATLEN equ 32
 42503                                  
 42504                                  BATBUFPOS:
 42505 0000A9DF 0000                    	dw 0			; integer position in buffer of next byte
 42506                                  
 42507 0000A9E1 00<rep 20h>             BATBUF:	times BATLEN db 0 ; times 32 db 0
 42508                                  BATBUFEND:
 42509 0000AA01 0000                    	dw 0
 42510                                  TypeFilSiz:
 42511 0000AA03 00000000                	dd 0			; stores size of file to be typed
 42512                                  
 42513                                  ; *****************************************************
 42514                                  ; EMG 4.00
 42515                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 42516                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 42517                                  ; *****************************************************
 42518                                  ;
 42519                                  ; COMMON PARSE OUTPUT BLOCKS
 42520                                  
 42521                                  ; Common output blocks for PARSE number, complex, or string values.
 42522                                  
 42523                                  PARSE1_OUTPUT:
 42524                                  PARSE1_TYPE:
 42525 0000AA07 00                      	db 0			;AN000;  type
 42526                                  PARSE1_CODE:
 42527 0000AA08 00                      	db 0			;AN000;  return value
 42528                                  PARSE1_SYN:
 42529 0000AA09 0000                    	dw 0			;AN000;  es offset of synonym
 42530                                  PARSE1_ADDR:
 42531 0000AA0B 00000000                	dd 0			;AN000;  numeric value / address
 42532                                  				;	 of string value
 42533                                  
 42534                                  ;  Common output block for PARSE date strings.
 42535                                  
 42536                                  DATE_OUTPUT:
 42537                                  DATE_TYPE:
 42538 0000AA0F 00                      	db 0			;AN000;  type
 42539 0000AA10 00                      	db 0			;AN000;  return value
 42540 0000AA11 0000                    	dw 0			;AN000;  es offset of synonym
 42541                                  DATE_YEAR:
 42542 0000AA13 0000                    	dw 0			;AN000;  year
 42543                                  DATE_MONTH:
 42544 0000AA15 00                      	db 0			;AN000;  month
 42545                                  DATE_DAY:
 42546 0000AA16 00                      	db 0			;AN000;  day
 42547                                  
 42548                                  ;  Common output block for PARSE time strings.
 42549                                  
 42550                                  TIME_OUTPUT:
 42551                                  TIME_TYPE:
 42552 0000AA17 00                      	db 0			;AN000;  type
 42553 0000AA18 00                      	db 0			;AN000;  return value
 42554 0000AA19 0000                    	dw 0			;AN000;  es offset of synonym
 42555                                  TIME_HOUR:
 42556 0000AA1B 00                      	db 0			;AN000;  hour
 42557                                  TIME_MINUTES:
 42558 0000AA1C 00                      	db 0			;AN000;  minutes
 42559                                  TIME_SECONDS:
 42560 0000AA1D 00                      	db 0			;AN000;  seconds
 42561                                  TIME_FRACTION:
 42562 0000AA1E 00                      	db 0			;AN000;  hundredths
 42563                                  
 42564                                  ;  Common output block for PARSE drive specifier (one based drive number).
 42565                                  
 42566                                  DRIVE_OUTPUT:
 42567                                  DRIVE_TYPE:
 42568 0000AA1F 00                      	db 0			;AN000;  type
 42569                                  DRIVE_VALUE:
 42570 0000AA20 00                      	db 0			;AN000;  return value
 42571 0000AA21 0000                    	dw 0			;AN000;  es offset of synonym
 42572                                  DRIVE_NUMBER:
 42573 0000AA23 00                      	db 0			;AN000;  drive number
 42574 0000AA24 000000                  	db 0,0,0		;AN000;  reserved
 42575                                  
 42576                                  	; 18/04/2023
 42577                                  	; 16/04/2023
 42578                                  ;TRANSPACEEND:	; 98C5h
 42579                                  		; End of MSDOS 5.0 COMMAND.COM (1991) Transient portion
 42580                                  
 42581                                  	; 18/06/2023
 42582                                  ;TRANSPACEEND:	; 0AF95h 
 42583                                  		; End of MSDOS 6.22 COMMAND.COM (1994) Transient portion
 42584                                  
 42585                                  ; ----------------------------------------------------------------------------
 42586                                  ; 18/06/2023
 42587                                  ; 20/04/2023
 42588                                  TRANSPACEEND equ ($-TRANSIENTSTART)	; Transient portion size
